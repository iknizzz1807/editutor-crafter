{"html":"<h1 id=\"-project-charter-linux-kernel-module\">ðŸŽ¯ Project Charter: Linux Kernel Module</h1>\n<h2 id=\"what-you-are-building\">What You Are Building</h2>\n<p>You are building a production-grade Linux character device driverâ€”a loadable kernel module (<code>.ko</code>) that acts as a bridge between the Linux kernel and userspace. This isn&#39;t a simple &quot;Hello World&quot;; you will build a virtual device that manages a kernel-space buffer, exposes a <code>/dev/</code> file interface for data transfer, implements a custom <code>ioctl</code> control protocol, and provides a <code>/proc</code> entry for live system introspection. By the end, your driver will safely handle concurrent access from multiple processes using kernel synchronization primitives.</p>\n<h2 id=\"why-this-project-exists\">Why This Project Exists</h2>\n<p>Most developers interact with the operating system through high-level abstractions, treating the kernel as a &quot;black box.&quot; Building a kernel module from scratch is the only way to truly understand the &quot;everything is a file&quot; philosophy. You will confront the hardware-enforced boundary between userspace and kernelspace, learning why direct pointer dereferencing is fatal and how the kernel manages memory, scheduling, and concurrency at the highest privilege level (Ring 0).</p>\n<h2 id=\"what-you-will-be-able-to-do-when-done\">What You Will Be Able to Do When Done</h2>\n<ul>\n<li><strong>Develop and Debug LKMs:</strong> Compile, load, and unload out-of-tree modules using the Kbuild system and inspect logs via <code>dmesg</code>.</li>\n<li><strong>Bridge the Memory Divide:</strong> Use <code>copy_to_user</code> and <code>copy_from_user</code> to safely move data across the kernel-userspace boundary.</li>\n<li><strong>Implement VFS Operations:</strong> Write handlers for standard system calls like <code>open()</code>, <code>read()</code>, <code>write()</code>, and <code>close()</code>.</li>\n<li><strong>Design Binary Protocols:</strong> Create custom control interfaces using <code>ioctl</code> with unique magic numbers and encoded command structures.</li>\n<li><strong>Master Kernel Concurrency:</strong> Use <code>mutexes</code> to prevent race conditions and <code>wait queues</code> to implement blocking I/O and process sleeping.</li>\n<li><strong>Support Multiplexed I/O:</strong> Implement the <code>.poll</code> operation to make your device compatible with <code>select()</code>, <code>poll()</code>, and <code>epoll()</code>.</li>\n</ul>\n<h2 id=\"final-deliverable\">Final Deliverable</h2>\n<p>A robust C source file (approx. 500 lines) and a Kbuild-compatible <code>Makefile</code>. The final module creates <code>/dev/mydevice</code> (for data) and <code>/proc/mydevice</code> (for stats). It must pass a concurrent stress test where 8 processes (4 readers, 4 writers) access the device simultaneously without data corruption, deadlocks, or a &quot;Kernel Oops.&quot;</p>\n<h2 id=\"is-this-project-for-you\">Is This Project For You?</h2>\n<p><strong>You should start this if you:</strong></p>\n<ul>\n<li>Are proficient in C (specifically pointers, structs, and manual memory management).</li>\n<li>Understand basic concurrency concepts like race conditions and locks.</li>\n<li>Are comfortable working in a Linux terminal and using <code>sudo</code> privileges.</li>\n</ul>\n<p><strong>Come back after you&#39;ve learned:</strong></p>\n<ul>\n<li><a href=\"https://en.cppreference.com/w/c/language/pointer\">C Programming Pointers &amp; Structs</a></li>\n<li><a href=\"https://man7.org/linux/man-pages/man7/signal.7.html\">Basic Linux Signal Handling</a> (If you don&#39;t know why <code>read()</code> might be interrupted).</li>\n</ul>\n<h2 id=\"estimated-effort\">Estimated Effort</h2>\n<table>\n<thead>\n<tr>\n<th>Phase</th>\n<th>Time</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>M1: Hello World &amp; Metadata</strong> (Setup, Kbuild, and Params)</td>\n<td>~4 hours</td>\n</tr>\n<tr>\n<td><strong>M2: Character Device Core</strong> (Read/Write &amp; /dev creation)</td>\n<td>~8 hours</td>\n</tr>\n<tr>\n<td><strong>M3: Control &amp; Introspection</strong> (ioctl and /proc seq_file)</td>\n<td>~8 hours</td>\n</tr>\n<tr>\n<td><strong>M4: Concurrency &amp; Poll</strong> (Mutex, Wait Queues, and Poll)</td>\n<td>~10 hours</td>\n</tr>\n<tr>\n<td><strong>Total</strong></td>\n<td><strong>~30 hours</strong></td>\n</tr>\n</tbody></table>\n<h2 id=\"definition-of-done\">Definition of Done</h2>\n<p>The project is complete when:</p>\n<ul>\n<li>The module compiles with <code>-Werror</code> and loads without &quot;tainting&quot; the kernel (proper GPL license).</li>\n<li>A userspace <code>echo</code> can write data to <code>/dev/mydevice</code> and <code>cat</code> can read it back.</li>\n<li>Custom <code>ioctl</code> commands successfully resize the internal kernel buffer at runtime.</li>\n<li><code>/proc/mydevice</code> displays real-time, accurate counts of total bytes read and written.</li>\n<li>The driver survives the &quot;Thundering Herd&quot; stress test (multiple concurrent readers/writers) without a kernel panic or data loss.</li>\n</ul>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>\n---\n\n# ðŸ“š Before You Read This: Prerequisites &amp; Further Reading\n\n&gt; **Read these first.** The Atlas assumes you are familiar with the foundations below.\n&gt; Resources are ordered by when you should encounter them â€” some before you start, some at specific milestones.\n\n### 1. The Kernel-Userspace Boundary\n**Topic: System Call Architecture &amp; Memory Protection**\n\n*   **Paper**: P. J. Braam, 2003, &quot;The Linux Virtual File System.&quot;\n*   **Code**: `arch/x86/entry/entry_64.S` â€” The raw assembly handling the transition from ring 3 to ring 0.\n*   **Best Explanation**: *Linux Kernel Development* (3rd Ed) by Robert Love, Chapter 5: &quot;System Calls.&quot;\n*   **Why**: It provides the most readable explanation of how the processor physically switches privilege levels and how the kernel validates the syscall table.\n*   **Timing**: Read **BEFORE Milestone 1** to understand the &quot;physics&quot; of the environment you are entering.\n\n*   **Spec**: POSIX.1-2017, Section 2.9.7: &quot;Thread-Safety&quot; and &quot;Memory Sanity.&quot;\n*   **Code**: `arch/x86/lib/copy_user_64.S` â€” Look for the `_copy_to_user` implementation and the `.fixup` section.\n*   **Best Explanation**: LWN.net, &quot;Accessing user-space memory&quot; by Jonathan Corbet.\n*   **Why**: This article explains the &quot;Trap and Recover&quot; mechanism (exception tables) that makes `copy_from_user` safe without pre-checking pointers.\n*   **Timing**: Read **during Milestone 2** after your first kernel panic to understand why your direct pointer dereference failed.\n\n---\n\n### 2. Character Device Architecture\n**Topic: VFS &amp; Device Registration**\n\n*   **Code**: `fs/char_dev.c` â€” The core implementation of the major/minor number registry.\n*   **Best Explanation**: *Linux Device Drivers* (3rd Ed) by Corbet, Rubini, &amp; Kroah-Hartman, Chapter 3: &quot;Char Drivers.&quot;\n*   **Why**: Though written for older kernels, the architectural pattern of `struct cdev` and the VFS dispatch remains the definitive pedagogical map.\n*   **Timing**: Read **at the start of Milestone 2** to see the &quot;contract&quot; you are about to fulfill.\n\n*   **Spec**: Linux Kernel Documentation: `admin-guide/devices.txt`.\n*   **Code**: `include/linux/fs.h` â€” Focus on the `struct file_operations` definition.\n*   **Best Explanation**: &quot;The Linux VFS&quot; by Neil Brown (LWN series).\n*   **Why**: It explains how the VFS provides polymorphism in C, allowing a socket, a file, and your driver to share the same `read()` interface.\n*   **Timing**: Read **after Milestone 2** to appreciate how your driver fits into the global Linux filesystem tree.\n\n---\n\n### 3. Memory Management\n**Topic: SLUB Allocator &amp; Kernel Paging**\n\n*   **Paper**: Jeff Bonwick, 1994, &quot;The Slab Allocator: An Object-Caching Kernel Memory Allocator.&quot;\n*   **Code**: `mm/slub.c` â€” Specifically the `slab_alloc_node` function.\n*   **Best Explanation**: *Understanding the Linux Kernel* by Bovet &amp; Cesati, Chapter 8: &quot;Memory Management.&quot;\n*   **Why**: It explains the &quot;Bento Box&quot; model of memory allocation and why `kmalloc` is faster than `malloc`.\n*   **Timing**: Read **during Milestone 2** when you call `kzalloc()` for the first time.\n\n---\n\n### 4. Control Plane &amp; Introspection\n**Topic: ioctl Design &amp; Virtual Filesystems**\n\n*   **Spec**: Linux Kernel Documentation: `userspace-api/ioctl/ioctl-number.rst`.\n*   **Code**: `include/uapi/asm-generic/ioctl.h` â€” The macros that define the 32-bit command encoding.\n*   **Best Explanation**: &quot;The new way of doing ioctl()&quot; (LWN) regarding the transition to `unlocked_ioctl`.\n*   **Why**: Essential for understanding why the Big Kernel Lock was removed and how modern ioctl dispatch works.\n*   **Timing**: Read **at the start of Milestone 3** to avoid defining &quot;garbage&quot; ioctl numbers that conflict with other drivers.\n\n*   **Code**: `fs/seq_file.c` â€” The implementation of the iterator pattern for `/proc`.\n*   **Best Explanation**: Linux Kernel Documentation: &quot;The seq_file Interface.&quot;\n*   **Why**: It is the only resource that correctly explains why you don't need to worry about 4KB buffer limits when using `seq_printf`.\n*   **Timing**: Read **during Milestone 3** while implementing your `/proc` entry.\n\n---\n\n### 5. Concurrency &amp; Synchronization\n**Topic: Mutexes, Wait Queues, and Scheduling**\n\n*   **Code**: `kernel/locking/mutex.c` â€” Look for the &quot;Fast path&quot; vs &quot;Slow path&quot; logic.\n*   **Best Explanation**: *Linux Kernel Development* by Robert Love, Chapter 9: &quot;Kernel Synchronization Methods.&quot;\n*   **Why**: Love differentiates between spinlocks and mutexes based on &quot;context,&quot; which is the single most important concept for kernel stability.\n*   **Timing**: Read **BEFORE starting Milestone 4**; it is required knowledge to prevent deadlocks.\n\n*   **Paper**: S. Molloy, 2006, &quot;The 'Thundering Herd' Problem in Network Servers.&quot;\n*   **Code**: `kernel/sched/wait.c` â€” The `prepare_to_wait` and `finish_wait` functions.\n*   **Best Explanation**: &quot;Wait queues in the Linux kernel&quot; (KernelNewbies Wiki).\n*   **Why**: It provides a line-by-line breakdown of how `sleep()` actually informs the scheduler to stop running a task.\n*   **Timing**: Read **during Milestone 4** while debugging why your reader process won't wake up.\n\n---\n\n### 6. Event Multiplexing\n**Topic: Poll, Select, and Epoll**\n\n*   **Code**: `fs/select.c` â€” The `do_poll` function loop.\n*   **Best Explanation**: &quot;The Implementation of epoll (1)&quot; by Marek Majkowski.\n*   **Why**: It traces the `poll_wait` callback from your driver all the way up to the `epoll_wait` system call in userspace.\n*   **Timing**: Read **at the end of Milestone 4** to understand how your driver enables high-performance servers (Nginx/Node.js).\n\n---\n\n### 7. Reliability &amp; Debugging\n**Topic: Tainting &amp; Oops Analysis**\n\n*   **Best Explanation**: Linux Kernel Documentation: `admin-guide/tainted-kernels.rst`.\n*   **Why**: You need to know what the letters in `Tainted: P  G      W` mean when your kernel crashes.\n*   **Timing**: Read **the first time you see a &quot;Kernel Oops&quot;** in your dmesg logs.\n\n*   **Code**: `scripts/decode_stacktrace.sh` in the Linux source tree.\n*   **Best Explanation**: &quot;Kernel Address Space Layout Randomization (KASLR)&quot; (LWN).\n*   **Why**: It explains why your crash addresses look different every time you reboot.\n*   **Timing**: Read **after Milestone 4** to transition from a student to a professional systems engineer.\n\n---\n\n# Linux Kernel Module: Interactive Atlas\n\nThis project builds a fully functional Linux character device driver from scratch â€” starting with a minimal loadable kernel module and progressively adding file operations, ioctl control interfaces, /proc introspection, and concurrent access handling with wait queues and poll support. The journey traverses the most fundamental boundary in modern computing: the line between kernel space and user space. Every system call you've ever made â€” read(), write(), open() â€” terminates in code that looks exactly like what you'll write here.\n\nBy the end, you'll have a character device that multiple processes can open, read, write, and poll concurrently, with proper mutex synchronization, blocking/non-blocking I/O semantics, and runtime introspection via /proc. This isn't a toy: it's the same architecture used by /dev/null, /dev/random, /dev/tty, and every hardware driver in the Linux kernel.\n\nThe real learning isn't just the API â€” it's understanding WHY the API looks the way it does. Why does copy_to_user() exist instead of memcpy()? Why does wait_event_interruptible() return -ERESTARTSYS? Why must poll() both register a wait queue AND return a mask? Each answer reveals a deep design constraint that ripples across all of systems programming.\n\n\n\n&lt;!-- MS_ID: build-kernel-module-m1 --&gt;\n# Milestone 1: Hello World Kernel Module\n## The Ground Beneath Your Feet\nBefore you write a single line of kernel code, you need to confront a misconception that trips up nearly every developer coming to kernel programming for the first time. It's worth addressing head-on because getting it wrong doesn't just cause bugs â€” it causes *kernel panics*.\n---\n### The Revelation: You Are Not Writing a Library\nYou probably know that Linux supports dynamically loaded shared libraries â€” `.so` files that a process loads at runtime via `dlopen()`. The mental model is clean: the library gets mapped into the process's address space, the dynamic linker resolves symbols, the library runs in the same process context as the caller, and if the library crashes, it crashes the process (not the whole system). You've worked with this model before.\nWhen you hear &quot;loadable kernel module,&quot; your brain reaches for this analogy: *it's probably like a kernel-side .so file, loaded on demand, running in some contained kernel process, debuggable with gdb.*\n**Every part of that model is wrong.**\nA kernel module is not loaded *into* a process. It is injected *into the kernel itself* â€” the same 40-million-line entity that manages every process, every memory mapping, every hardware interrupt on your machine. There is no isolation. There is no &quot;kernel process&quot; running your module's code in a sandbox.\nWhen your module's `init` function runs, it runs with **ring 0 CPU privilege** â€” the highest privilege level the hardware supports. It can access any physical memory address. It can execute any hardware instruction. It can corrupt the kernel's own data structures. When your module's functions are called later (by processes making system calls), they run directly in the kernel's address space, on whatever CPU the calling process happened to be scheduled on, with no process boundary separating them from the kernel's internals.\nThe consequence: a NULL pointer dereference in your module doesn't produce a segmentation fault. It produces a **kernel oops** â€” a diagnostic dump showing the CPU state, register values, and stack trace at the moment of the crash â€” and potentially a kernel panic that halts the machine. There is no signal handler to catch this, no garbage collector to save you, no memory-safe language to interpose. You are the kernel.\n\n![Kernel vs User Address Space Layout](./diagrams/diag-m1-address-space-split.svg)\n\n\n&gt; **ðŸ”‘ Foundation: Kernel vs userspace address spaces**\n&gt; \n&gt; **1. What it IS**\nIn a modern operating system, the CPU uses virtual memory to isolate processes. This virtual memory is split into two primary regions: **Userspace** and **Kernelspace**. \n*   **Userspace** is the restricted sandbox where your applications (like `ls`, `web browsers`, or `python`) run. They cannot touch hardware directly and have a limited view of memory.\n*   **Kernelspace** is the privileged area where the core operating system resides. It has full access to the CPU instructions and all physical hardware.\n\n**2. WHY you need it right now**\nIf you are writing a device driver or a kernel module, you are operating in Kernelspace. You cannot simply &quot;pass a pointer&quot; from a user application to the kernel and dereference it. Because each user process has its own isolated address space, the address `0x400500` in a user program might point to a string, but in the kernel, that same address could point to something entirely differentâ€”or nothing at all. You must use specific functions (like `copy_from_user`) to safely bridge this gap.\n\n**3. Key Insight: The &quot;One-Way Mirror&quot; Mental Model**\nThink of the Kernel as the landlord of an apartment building and Userspace processes as the tenants. Each tenant lives in their own apartment (Address Space) and canâ€™t see inside others. The landlord lives in a private office (Kernelspace). The landlord can look into any apartment to move furniture or fix pipes, but the tenants can only interact with the landlord through a specific mail slot (System Calls). They can never walk into the landlord's office uninvited.\n\nThis isn't meant to frighten you â€” it's meant to orient you. Kernel development has a different *physics* than userspace development. The same discipline that makes you check every `malloc()` return value in userspace needs to be applied with ten times the rigor here, because the cost of failure is ten times higher. Once you internalize this, the entire design of the kernel API â€” the strange-looking macros, the mandatory error checks, the careful memory barriers â€” starts making sense. Every API is designed the way it is because someone suffered the alternative.\n---\n## What a Module Actually Is\n\n![Module Lifecycle: Load â†’ Init â†’ Running â†’ Exit â†’ Unload](./diagrams/diag-m1-module-lifecycle.svg)\n\nA kernel module is an **ELF object file** (`.ko` extension, for &quot;kernel object&quot;) that the kernel's module loader reads, relocates, and links into the live kernel image at runtime.\n[[EXPLAIN:how-the-kernel-loads-and-links-modules-(.ko-files,-symbol-resolution)|How the kernel loads and links modules (.ko files, symbol resolution)]]\nThe `.ko` file is structurally similar to a `.o` file from your compiler â€” it has code sections, data sections, relocation entries, and a symbol table. The critical difference is what it links *against*: not libc, not any userspace library, but the **kernel's own symbol table** â€” the list of all functions and variables the running kernel has explicitly exported for module use. Functions like `printk`, `kmalloc`, `class_create` â€” these are kernel symbols that your module will reference, and they get resolved at load time against the kernel that's actually running.\nThis is why the kernel headers you compile against must **exactly match** the running kernel. If your headers say `struct file_operations` has 25 fields but the running kernel's struct has 26 fields, your module will write to wrong memory offsets when it fills that struct. The result is not a compile error â€” it's silent data corruption that may not manifest until some seemingly unrelated kernel path trips over your corrupted data.\n---\n## The Kbuild System: Compiling Into the Kernel\nYou won't use a plain `Makefile` with `gcc` directly. The Linux kernel uses its own build system, **Kbuild**, which knows how to compile code that will be linked against the kernel. Kbuild handles the complex flags required to build kernel code correctly â€” position-independent code settings, stack protector flags, no standard library includes, kernel-specific warning flags, and more.\n{{DIAGRAM:diag-m1-kbuild-flow}}\nFor an out-of-tree module (one that lives outside the kernel source tree), you write a two-line `Makefile` that delegates to Kbuild:\n```makefile\n# Makefile â€” out-of-tree kernel module build\nobj-m += hello.o\nall:\n\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\nclean:\n\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean</code></pre></div>\n<p>Let&#39;s read this carefully:</p>\n<ul>\n<li><code>obj-m += hello.o</code> â€” tells Kbuild to compile <code>hello.c</code> and link it as a module (the <code>-m</code> suffix means &quot;module&quot;, as opposed to <code>-y</code> which means &quot;built into the kernel image&quot;). Kbuild automatically maps <code>hello.o</code> to <code>hello.c</code> as the source.</li>\n<li><code>-C /lib/modules/$(shell uname -r)/build</code> â€” changes to the kernel build directory for the <strong>currently running kernel</strong> (<code>uname -r</code> returns something like <code>6.8.0-47-generic</code>). The kernel build directory contains the Kbuild infrastructure and the kernel configuration used to build the running kernel.</li>\n<li><code>M=$(PWD) modules</code> â€” tells Kbuild that the module source lives in the current directory (<code>$(PWD)</code>), and to build the <code>modules</code> target (which compiles out-of-tree modules).\nThe practical implication: you must have the <strong>kernel headers</strong> installed for your running kernel. On Ubuntu/Debian:</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> apt</span><span style=\"color:#9ECBFF\"> install</span><span style=\"color:#9ECBFF\"> linux-headers-</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">uname</span><span style=\"color:#79B8FF\"> -r</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n<p>On Fedora/RHEL:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> dnf</span><span style=\"color:#9ECBFF\"> install</span><span style=\"color:#9ECBFF\"> kernel-devel-</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">uname</span><span style=\"color:#79B8FF\"> -r</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n<p>If the headers aren&#39;t installed, the build directory won&#39;t exist and <code>make</code> will fail immediately.</p>\n<blockquote>\n<p><strong>Hardware Soul</strong>: Compiling kernel code requires disabling features like stack canaries in certain contexts, enabling specific code model flags (<code>-mcmodel=kernel</code> on x86_64) that constrain how code addresses memory, and ensuring no floating-point instructions are emitted (the kernel doesn&#39;t save/restore FPU state except when explicitly crossing to/from userspace). Kbuild applies all of these automatically. If you tried to compile with <code>gcc hello.c -o hello.ko</code> directly, you&#39;d produce an object that <em>looks</em> correct but would corrupt the kernel when loaded.</p>\n</blockquote>\n<hr>\n<h2 id=\"writing-the-minimal-module\">Writing the Minimal Module</h2>\n<p>Here is the smallest valid kernel module:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// hello.c â€” minimal kernel module</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/module.h></span><span style=\"color:#6A737D\">   /* MODULE_LICENSE, MODULE_AUTHOR, etc. */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/kernel.h></span><span style=\"color:#6A737D\">   /* printk, KERN_INFO */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/init.h></span><span style=\"color:#6A737D\">     /* __init, __exit */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_LICENSE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"GPL\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_AUTHOR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Your Name\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_DESCRIPTION</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"A minimal kernel module demonstrating load/unload lifecycle\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_VERSION</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"1.0\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> __init </span><span style=\"color:#B392F0\">hello_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"hello: module loaded</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#E1E4E8\"> __exit </span><span style=\"color:#B392F0\">hello_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"hello: module unloaded</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">module_init</span><span style=\"color:#E1E4E8\">(hello_init);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">module_exit</span><span style=\"color:#E1E4E8\">(hello_exit);</span></span></code></pre></div>\n<p>Every line here does something specific. Let&#39;s walk through each piece.</p>\n<h3 id=\"include-headers-the-kernel39s-standard-library\">Include Headers â€” The Kernel&#39;s Standard Library</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/module.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/kernel.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/init.h></span></span></code></pre></div>\n<p>These are not the headers from <code>/usr/include</code> that your userspace programs use. They come from the kernel source tree under <code>include/linux/</code>. Crucially, you <strong>never</strong> include <code>&lt;stdio.h&gt;</code>, <code>&lt;stdlib.h&gt;</code>, <code>&lt;string.h&gt;</code>, or any other C standard library header. The C standard library is a userspace library â€” it doesn&#39;t exist in the kernel. The kernel has its own implementations of common utilities (<code>strlen</code>, <code>memcpy</code>, <code>sprintf</code>) in <code>&lt;linux/string.h&gt;</code>, <code>&lt;linux/kernel.h&gt;</code>, etc.\nIf you accidentally include <code>&lt;stdio.h&gt;</code> in kernel code, the compiler will fail in spectacular ways â€” the standard library headers include syscall wrappers and type definitions that conflict with kernel type definitions.</p>\n<h3 id=\"module-metadata-macros\">Module Metadata Macros</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">MODULE_LICENSE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"GPL\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_AUTHOR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Your Name\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_DESCRIPTION</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"A minimal kernel module demonstrating load/unload lifecycle\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_VERSION</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"1.0\"</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<p>These macros don&#39;t generate function calls or runtime initialization code. They inject <strong>strings into dedicated ELF sections</strong> in the <code>.ko</code> file. The <code>modinfo</code> tool reads these sections directly from the file, and the kernel&#39;s module loader reads <code>MODULE_LICENSE</code> to decide whether to grant access to GPL-only symbols.\n<code>MODULE_LICENSE(&quot;GPL&quot;)</code> is not a legal formality â€” it is <strong>functionally required</strong>. The Linux kernel uses the GNU Public License </p>\n<blockquote>\n<p><strong>ðŸ”‘ Foundation: GPL symbol export mechanism: how EXPORT_SYMBOL_GPL works and what &quot;tainting&quot; means</strong></p>\n<p><strong>1. What it IS</strong>\nThe Linux kernel is modular. To allow one module to use functions (symbols) from another, the kernel uses the <code>EXPORT_SYMBOL</code> macro. There are two tiers:</p>\n</blockquote>\n<ul>\n<li><strong>EXPORT_SYMBOL:</strong> Makes a function available to any module, regardless of license.</li>\n<li><strong>EXPORT_SYMBOL_GPL:</strong> Makes a function available <em>only</em> to modules that declare a GPL-compatible license.</li>\n</ul>\n<p><strong>Tainting</strong> is a state flag in the kernel. If you load a module that is proprietary (non-GPL) or if the kernel encounters a catastrophic hardware error, the kernel marks itself as &quot;Tainted.&quot;</p>\n<p><strong>2. WHY you need it right now</strong>\nWhen developing a kernel module, your choice of license (<code>MODULE_LICENSE(&quot;GPL&quot;)</code>) determines which internal APIs you can access. If you try to use a function exported via <code>EXPORT_SYMBOL_GPL</code> in a non-GPL module, the kernel will refuse to load your module. Furthermore, if you are debugging a crash and your kernel is &quot;Tainted,&quot; kernel developers will often ignore your bug report because proprietary code makes it impossible to verify the kernel&#39;s internal state.</p>\n<p><strong>3. Key Insight: The &quot;Void if Seal Broken&quot; Sticker</strong>\nThink of &quot;Tainting&quot; like the warranty sticker on a piece of electronics. Loading a non-GPL module or forcing a module into the kernel is like peeling that sticker off. The device (the kernel) might still work perfectly fine, but the &quot;manufacturer&quot; (the Linux community) will no longer support it because they can&#39;t be sure what happened inside the box once the &quot;seal&quot; was broken.\n to gate access to certain symbols. Functions like <code>__alloc_pages</code>, most of the crypto API, and many driver APIs are exported only to GPL-licensed modules via <code>EXPORT_SYMBOL_GPL()</code>. If your module declares any other license (or omits the macro), loading it will &quot;taint&quot; the kernel â€” marking it as running non-GPL code â€” and the symbol resolution for any <code>EXPORT_SYMBOL_GPL</code> symbol your module needs will fail with an <code>Unknown symbol</code> error.\nThe accepted values for <code>MODULE_LICENSE</code> are: <code>&quot;GPL&quot;</code>, <code>&quot;GPL v2&quot;</code>, <code>&quot;GPL and additional rights&quot;</code>, <code>&quot;Dual BSD/GPL&quot;</code>, <code>&quot;Dual MIT/GPL&quot;</code>, <code>&quot;Dual MPL/GPL&quot;</code>, and <code>&quot;Proprietary&quot;</code>. The last one taints the kernel and blocks GPL-only symbols.</p>\n<h3 id=\"__init-and-__exit-section-annotations\"><code>__init</code> and <code>__exit</code> â€” Section Annotations</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> __init </span><span style=\"color:#B392F0\">hello_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) { ... }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#E1E4E8\"> __exit </span><span style=\"color:#B392F0\">hello_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) { ... }</span></span></code></pre></div>\n<p>The <code>__init</code> and <code>__exit</code> macros are <strong>section annotations</strong> that place the decorated functions into special ELF sections (<code>.init.text</code> and <code>.exit.text</code> respectively).\nFor functions in <code>.init.text</code>: after the module successfully initializes, the kernel <strong>frees the memory</strong> occupied by those functions. The init code runs exactly once â€” never again after initialization â€” so keeping it resident wastes RAM. On resource-constrained systems (embedded, server with thousands of modules), this matters.\nFor functions in <code>.exit.text</code>: if the module is compiled as a built-in (not loadable, but baked into the kernel image at compile time), the exit functions are discarded entirely â€” a built-in module can never be unloaded, so the exit function is dead code.\nThe <code>static</code> keyword matters too: it prevents these functions from being exported as global symbols, which keeps the module&#39;s symbol footprint minimal and prevents accidental name collisions with other kernel symbols.</p>\n<h3 id=\"module_init-and-module_exit-registration\"><code>module_init()</code> and <code>module_exit()</code> â€” Registration</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">module_init</span><span style=\"color:#E1E4E8\">(hello_init);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">module_exit</span><span style=\"color:#E1E4E8\">(hello_exit);</span></span></code></pre></div>\n<h2 id=\"these-macros-register-your-init-and-exit-functions-with-the-kernel39s-module-framework-they-don39t-call-the-functions-they-tell-the-kernel-loader-quotwhen-this-module-is-loaded-call-hello_init-when-it39s-unloaded-call-hello_exitquot-the-return-value-of-the-init-function-is-critical-returning-0-means-success-returning-a-negative-error-code-like-enomem-for-out-of-memory-or-ebusy-for-a-resource-conflict-causes-insmod-to-fail-and-the-module-to-not-be-loaded-the-error-code-propagates-back-to-the-insmod-process-as-the-exit-status-never-return-a-positive-value-from-init-positive-values-have-undefined-behavior-in-this-context-if-init-returns-an-error-the-kernel-guarantees-that-exit-will-not-be-called-this-means-your-init-function-must-clean-up-any-resources-it-already-allocated-before-returning-the-error-a-partial-initialization-that-returns-an-error-but-leaves-resources-allocated-will-leak-them-permanently\">These macros register your init and exit functions with the kernel&#39;s module framework. They don&#39;t <em>call</em> the functions â€” they tell the kernel loader &quot;when this module is loaded, call <code>hello_init</code>; when it&#39;s unloaded, call <code>hello_exit</code>.&quot;\nThe return value of the init function is critical: returning <code>0</code> means success, returning a negative error code (like <code>-ENOMEM</code> for out-of-memory, or <code>-EBUSY</code> for a resource conflict) causes <code>insmod</code> to fail and the module to not be loaded. The error code propagates back to the <code>insmod</code> process as the exit status. <strong>Never return a positive value from init</strong> â€” positive values have undefined behavior in this context.\nIf init returns an error, the kernel guarantees that exit will <strong>not</strong> be called. This means your init function must clean up any resources it already allocated before returning the error â€” a partial initialization that returns an error but leaves resources allocated will leak them permanently.</h2>\n<h2 id=\"printk-logging-without-a-terminal\"><code>printk</code> â€” Logging Without a Terminal</h2>\n<p>Your first instinct when debugging might be to reach for <code>printf</code>. In the kernel, <code>printf</code> doesn&#39;t exist. Instead you use <code>printk</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"hello: module loaded</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<p>Note the unusual syntax: <code>KERN_INFO</code> is not a separate argument separated by a comma â€” it&#39;s a string <strong>concatenated</strong> with the format string at compile time. <code>KERN_INFO</code> expands to the string <code>&quot;\\001\\006&quot;</code> (SOH followed by &#39;6&#39;, the log level number), and the C compiler concatenates adjacent string literals. The result is a single string: <code>&quot;\\001\\006hello: module loaded\\n&quot;</code>.</p>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiag-m1-printk-ring-buffer.svg\" alt=\"printk Ring Buffer and dmesg\"></p>\n<p>The log levels in order from most to least severe:</p>\n<table>\n<thead>\n<tr>\n<th>Macro</th>\n<th>Level</th>\n<th>Numeric</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>KERN_EMERG</code></td>\n<td>0</td>\n<td>Emergency</td>\n<td>System is unusable</td>\n</tr>\n<tr>\n<td><code>KERN_ALERT</code></td>\n<td>1</td>\n<td>Alert</td>\n<td>Immediate action required</td>\n</tr>\n<tr>\n<td><code>KERN_CRIT</code></td>\n<td>2</td>\n<td>Critical</td>\n<td>Critical condition</td>\n</tr>\n<tr>\n<td><code>KERN_ERR</code></td>\n<td>3</td>\n<td>Error</td>\n<td>Error condition</td>\n</tr>\n<tr>\n<td><code>KERN_WARNING</code></td>\n<td>4</td>\n<td>Warning</td>\n<td>Warning condition</td>\n</tr>\n<tr>\n<td><code>KERN_NOTICE</code></td>\n<td>5</td>\n<td>Notice</td>\n<td>Normal but significant</td>\n</tr>\n<tr>\n<td><code>KERN_INFO</code></td>\n<td>6</td>\n<td>Info</td>\n<td>Informational</td>\n</tr>\n<tr>\n<td><code>KERN_DEBUG</code></td>\n<td>7</td>\n<td>Debug</td>\n<td>Debug-level message</td>\n</tr>\n<tr>\n<td><code>printk</code> writes its output to the <strong>kernel ring buffer</strong> â€” a circular buffer in kernel memory (typically 512KB to 4MB, configurable). The <code>dmesg</code> command reads this buffer by reading <code>/dev/kmsg</code> (which is itself a character device â€” you&#39;ll be building something structurally similar in Milestone 2). Because the buffer is circular, old messages get overwritten when the buffer fills up.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>The ring buffer is not stdout.</strong> <code>printk</code> doesn&#39;t write to a terminal. If the console log level is high enough (controlled by <code>/proc/sys/kernel/printk</code>), messages may also appear on the system console, but the primary output path is the ring buffer accessible via <code>dmesg</code>.</p>\n</blockquote>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># After insmod hello.ko, check dmesg for your message</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dmesg</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tail</span><span style=\"color:#79B8FF\"> -5</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Or follow in real-time with -w (like tail -f)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dmesg</span><span style=\"color:#79B8FF\"> -w</span></span></code></pre></div>\n<h2 id=\"the-timestamp-format-in-dmesg-output-12345678901-is-seconds-since-boot-not-wall-clock-time-use-dmesg-t-to-convert-to-human-readable-timestamps\">The timestamp format in dmesg output (<code>[12345.678901]</code>) is seconds since boot, not wall clock time. Use <code>dmesg -T</code> to convert to human-readable timestamps.</h2>\n<h2 id=\"module-parameters-runtime-configurability\">Module Parameters: Runtime Configurability</h2>\n<p>A static module is limited. Real modules need to be tunable: buffer sizes, timeout values, debug levels, device addresses. The <code>module_param()</code> macro system exposes module-level variables as parameters settable at load time and (optionally) at runtime via <code>/sys</code>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/moduleparam.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> buffer_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 4096</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* default: 4KB */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">module_param</span><span style=\"color:#E1E4E8\">(buffer_size, </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">644</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_PARM_DESC</span><span style=\"color:#E1E4E8\">(buffer_size, </span><span style=\"color:#9ECBFF\">\"Size of the device buffer in bytes (default: 4096)\"</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<p>The <code>module_param(name, type, permissions)</code> macro takes three arguments:</p>\n<ol>\n<li><strong><code>name</code></strong>: The variable name. Must be a static module-level variable â€” this is <strong>not</strong> a copy; the macro makes the variable itself accessible through sysfs.</li>\n<li><strong><code>type</code></strong>: The kernel&#39;s type tag for the parameter. Common types:<ul>\n<li><code>int</code>, <code>uint</code>, <code>long</code>, <code>ulong</code> â€” integer types</li>\n<li><code>bool</code> â€” boolean (accepts <code>y</code>/<code>n</code>/<code>1</code>/<code>0</code>)</li>\n<li><code>charp</code> â€” char pointer (string, kernel allocates memory)</li>\n<li><code>byte</code> â€” unsigned char</li>\n</ul>\n</li>\n<li><strong><code>permissions</code></strong>: The filesystem permission bits for the sysfs attribute. <code>0644</code> means owner can read/write, everyone else can read. Use <code>0</code> to make the parameter not appear in sysfs at all (load-time only). <strong>Never use <code>0666</code></strong> â€” that lets any unprivileged user modify kernel state, which is a security vulnerability.\nAfter loading, the parameter appears at:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>/sys/module/&lt;module_name&gt;/parameters/&lt;parameter_name&gt;</code></pre></div>\n<p>So for our module:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Load with non-default parameter</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> insmod</span><span style=\"color:#9ECBFF\"> hello.ko</span><span style=\"color:#9ECBFF\"> buffer_size=</span><span style=\"color:#79B8FF\">8192</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check current value</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/module/hello/parameters/buffer_size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Output: 8192</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># If permissions allow writing, modify at runtime</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> 16384</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> sudo</span><span style=\"color:#9ECBFF\"> tee</span><span style=\"color:#9ECBFF\"> /sys/module/hello/parameters/buffer_size</span></span></code></pre></div>\n<p>The sysfs attribute is directly backed by the <code>buffer_size</code> variable â€” reading it returns the current value, and (if writable) writing it updates the variable in the running kernel. This is the same mechanism that exposes hardware topology under <code>/sys/class</code> and <code>/sys/bus</code> â€” module parameters are first-class sysfs citizens, not a special case.</p>\n<blockquote>\n<p><strong>Design note</strong>: Module parameters are a double-edged sword. They make modules flexible, but they add code paths that depend on runtime values rather than compile-time constants. A module that worked correctly with <code>buffer_size=4096</code> might behave pathologically with <code>buffer_size=0</code> or <code>buffer_size=INT_MAX</code> if you don&#39;t validate. Always validate parameters in your init function.</p>\n</blockquote>\n<hr>\n<h2 id=\"the-module-metadata-flow\">The Module Metadata Flow</h2>\n<p>Let&#39;s trace exactly how the <code>MODULE_LICENSE</code>, <code>MODULE_AUTHOR</code>, and <code>MODULE_DESCRIPTION</code> macros become visible in <code>modinfo</code> output.</p>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiag-m1-modinfo-metadata.svg\" alt=\"Module Metadata: From Macros to ELF Sections to modinfo\"></p>\n<p>The macros expand to <code>__attribute__((section(&quot;.modinfo&quot;)))</code> annotated string arrays. For example, <code>MODULE_LICENSE(&quot;GPL&quot;)</code> roughly expands to:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\"> __UNIQUE_ID_license</span><span style=\"color:#F97583\">[]</span><span style=\"color:#B392F0\"> __attribute__</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#B392F0\">section</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\".modinfo\"</span><span style=\"color:#E1E4E8\">),used))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    =</span><span style=\"color:#9ECBFF\"> \"license=GPL\"</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n<p>The Kbuild system also injects additional metadata into <code>.modinfo</code>: the kernel version the module was compiled against (<code>vermagic</code>), the module dependencies, and any <code>module_param</code> descriptions.\nWhen you run <code>modinfo hello.ko</code>, it reads the <code>.modinfo</code> ELF section and prints the key-value pairs:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>filename:       /path/to/hello.ko\nversion:        1.0\ndescription:    A minimal kernel module demonstrating load/unload lifecycle\nauthor:         Your Name\nlicense:        GPL\nsrcversion:     A3B2C1D4E5F6A7B8C9D0E1F\ndepends:        \nretpoline:      Y\nname:           hello\nvermagic:       6.8.0-47-generic SMP preempt mod_unload modversions\nparm:           buffer_size:Size of the device buffer in bytes (default: 4096) (int)</code></pre></div>\n<h2 id=\"the-vermagic-field-is-the-kernel39s-version-check-mechanism-when-insmod-loads-the-ko-the-kernel-compares-the-embedded-vermagic-string-against-the-running-kernel39s-own-version-string-if-they-don39t-match-loading-fails-with-disagrees-about-version-of-symbol-module_layout-this-is-the-safety-guard-that-prevents-you-from-loading-a-module-compiled-against-kernel-67-into-a-kernel-running-68\">The <code>vermagic</code> field is the kernel&#39;s version check mechanism: when <code>insmod</code> loads the <code>.ko</code>, the kernel compares the embedded <code>vermagic</code> string against the running kernel&#39;s own version string. If they don&#39;t match, loading fails with <code>disagrees about version of symbol module_layout</code>. This is the safety guard that prevents you from loading a module compiled against kernel 6.7 into a kernel running 6.8.</h2>\n<h2 id=\"the-complete-module-putting-it-together\">The Complete Module: Putting It Together</h2>\n<p>Here is the full module source with parameter validation and proper cleanup structure:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// hello.c â€” Hello World kernel module with parameter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/module.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/kernel.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/init.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/moduleparam.h></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_LICENSE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"GPL\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_AUTHOR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Your Name &#x3C;you@example.com>\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_DESCRIPTION</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Hello World kernel module with buffer_size parameter\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_VERSION</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"1.0\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Module parameter: buffer size with default of 4096 bytes */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> buffer_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 4096</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">module_param</span><span style=\"color:#E1E4E8\">(buffer_size, </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">644</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_PARM_DESC</span><span style=\"color:#E1E4E8\">(buffer_size, </span><span style=\"color:#9ECBFF\">\"Size of the device buffer in bytes (default: 4096)\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> __init </span><span style=\"color:#B392F0\">hello_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Validate the parameter before using it */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (buffer_size </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> buffer_size </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"hello: invalid buffer_size </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (must be 1 to 1048576)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               buffer_size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"hello: module loaded, buffer_size=</span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, buffer_size);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"hello: parameter visible at \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">           \"/sys/module/hello/parameters/buffer_size</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* 0 = success; negative = failure */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#E1E4E8\"> __exit </span><span style=\"color:#B392F0\">hello_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"hello: module unloaded</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">module_init</span><span style=\"color:#E1E4E8\">(hello_init);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">module_exit</span><span style=\"color:#E1E4E8\">(hello_exit);</span></span></code></pre></div>\n<h3 id=\"building-it\">Building It</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># In the directory containing hello.c and Makefile:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">make</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output (abbreviated):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># make -C /lib/modules/6.8.0-47-generic/build M=/home/user/hello modules</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#   CC [M]  /home/user/hello/hello.o</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#   MODPOST /home/user/hello/Module.symvers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#   CC [M]  /home/user/hello/hello.mod.o</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#   LD [M]  /home/user/hello/hello.ko</span></span></code></pre></div>\n<p>The build produces several files, but <code>hello.ko</code> is the one you load. The <code>.mod.c</code> file is auto-generated by Kbuild and contains metadata; <code>.symvers</code> records the symbols your module references and their CRC values (used for module versioning checks).</p>\n<h3 id=\"loading-and-verifying\">Loading and Verifying</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Load the module</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> insmod</span><span style=\"color:#9ECBFF\"> hello.ko</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify it's loaded</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">lsmod</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> hello</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Output: hello    16384  0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check dmesg for init message</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dmesg</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tail</span><span style=\"color:#79B8FF\"> -3</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [12345.678901] hello: module loaded, buffer_size=4096</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [12345.678923] hello: parameter visible at /sys/module/hello/parameters/buffer_size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check module metadata</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">modinfo</span><span style=\"color:#9ECBFF\"> hello.ko</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check parameter in sysfs</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/module/hello/parameters/buffer_size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 4096</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Load with custom parameter</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> rmmod</span><span style=\"color:#9ECBFF\"> hello</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> insmod</span><span style=\"color:#9ECBFF\"> hello.ko</span><span style=\"color:#9ECBFF\"> buffer_size=</span><span style=\"color:#79B8FF\">8192</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/module/hello/parameters/buffer_size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 8192</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Unload</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> rmmod</span><span style=\"color:#9ECBFF\"> hello</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dmesg</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tail</span><span style=\"color:#79B8FF\"> -1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [12367.891234] hello: module unloaded</span></span></code></pre></div>\n<h3 id=\"the-verification-script\">The Verification Script</h3>\n<p>A repeatable verification script is better than manual commands:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">#!/bin/bash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># verify.sh â€” automated load/unload verification for hello module</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">set</span><span style=\"color:#79B8FF\"> -e</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">MODULE_NAME</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"hello\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">KO_FILE</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"./hello.ko\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[1] Building module...\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">make</span><span style=\"color:#79B8FF\"> -s</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[2] Checking modinfo metadata...\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">modinfo</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$KO_FILE</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -E</span><span style=\"color:#9ECBFF\"> \"^(license|author|description|parm):\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify GPL license, author, description, and parameter are present</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[3] Loading module with default parameter...\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> insmod</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$KO_FILE</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[4] Verifying module is listed in lsmod...\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">lsmod</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -q</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MODULE_NAME</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"  PASS: module visible in lsmod\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[5] Verifying init message in dmesg...\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dmesg</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tail</span><span style=\"color:#79B8FF\"> -5</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -q</span><span style=\"color:#9ECBFF\"> \"${</span><span style=\"color:#E1E4E8\">MODULE_NAME</span><span style=\"color:#9ECBFF\">}: module loaded\"</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"  PASS: init message in dmesg\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[6] Verifying parameter in /sys...\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">PARAM_PATH</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"/sys/module/${</span><span style=\"color:#E1E4E8\">MODULE_NAME</span><span style=\"color:#9ECBFF\">}/parameters/buffer_size\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">[ </span><span style=\"color:#F97583\">-f</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$PARAM_PATH</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> ] &#x26;&#x26; </span><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"  PASS: parameter file exists\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$PARAM_PATH</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -q</span><span style=\"color:#9ECBFF\"> \"4096\"</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"  PASS: default value is 4096\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[7] Unloading module...\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> rmmod</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MODULE_NAME</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[8] Verifying exit message in dmesg...\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dmesg</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tail</span><span style=\"color:#79B8FF\"> -3</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -q</span><span style=\"color:#9ECBFF\"> \"${</span><span style=\"color:#E1E4E8\">MODULE_NAME</span><span style=\"color:#9ECBFF\">}: module unloaded\"</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"  PASS: exit message in dmesg\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[9] Loading with custom parameter...\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> insmod</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$KO_FILE</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\"> buffer_size=</span><span style=\"color:#79B8FF\">8192</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$PARAM_PATH</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -q</span><span style=\"color:#9ECBFF\"> \"8192\"</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"  PASS: custom parameter accepted\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> rmmod</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$MODULE_NAME</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"All checks passed.\"</span></span></code></pre></div>\n<hr>\n<h2 id=\"common-pitfalls-and-their-consequences\">Common Pitfalls and Their Consequences</h2>\n<p>This section covers the mistakes that will cost you time â€” and in some cases, machine reboots.</p>\n<h3 id=\"missing-module_licensequotgplquot-tainted-kernel-missing-symbols\">Missing <code>MODULE_LICENSE(&quot;GPL&quot;)</code> â€” Tainted Kernel, Missing Symbols</h3>\n<p>If you omit <code>MODULE_LICENSE</code>, the kernel marks itself as &quot;tainted&quot; upon loading your module and prints a warning:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>hello: module license 'unspecified' taints kernel.\nDisabling lock debugging due to kernel taint</code></pre></div>\n<p>Beyond the warning, any <code>EXPORT_SYMBOL_GPL</code> symbol your module tries to use will fail to resolve at load time:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>hello: Unknown symbol __alloc_pages (err -13)\ninsmod: ERROR: could not insert module hello.ko: Unknown symbol in module</code></pre></div>\n<h3 id=\"mismatched-kernel-headers-silent-abi-corruption\">Mismatched Kernel Headers â€” Silent ABI Corruption</h3>\n<p>Building against <code>linux-headers-6.7.x</code> and loading into a <code>6.8.x</code> kernel (or vice versa) will fail with the <code>vermagic</code> check in most cases. But if someone bypasses this check (with <code>insmod --force</code>), they invite silent struct layout mismatches. Always use <code>uname -r</code> in your Makefile to ensure you build against the right headers.</p>\n<h3 id=\"printk-without-log-level-invisible-messages\"><code>printk</code> Without Log Level â€” Invisible Messages</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">printk</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"hello: this might be invisible</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // BAD: no log level</span></span></code></pre></div>\n<p>Without a log level prefix, the message defaults to <code>KERN_DEFAULT</code>, which maps to the kernel&#39;s default message level. If the current console log level is lower than the message level, the message won&#39;t appear on the console (though it&#39;s still in the ring buffer). Always specify a log level.</p>\n<h3 id=\"module-parameter-permissions-0666-security-vulnerability\">Module Parameter Permissions <code>0666</code> â€” Security Vulnerability</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">module_param</span><span style=\"color:#E1E4E8\">(buffer_size, </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">666</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // BAD: world-writable</span></span></code></pre></div>\n<p>This allows any unprivileged user to <code>echo 0 &gt; /sys/module/hello/parameters/buffer_size</code> and potentially put the module into an invalid state. Use <code>0644</code> (owner write, world read) or <code>0444</code> (world read, no write) for most parameters.</p>\n<h3 id=\"returning-positive-value-from-module_init-undefined-behavior\">Returning Positive Value From <code>module_init</code> â€” Undefined Behavior</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> __init </span><span style=\"color:#B392F0\">hello_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // BAD: positive return from init</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>The convention is strict: <code>0</code> for success, negative <code>errno</code> code for failure. Positive values are not a valid success indicator and will confuse the kernel&#39;s module loader.</p>\n<h3 id=\"failing-to-compile-with-werror\">Failing to Compile With <code>-Werror</code></h3>\n<p>The kernel&#39;s Kbuild system can be configured to treat warnings as errors. If you&#39;re developing on a system where this isn&#39;t the default, enable it explicitly to catch issues early. In your Makefile:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">makefile</span><pre class=\"arch-pre shiki-highlighted\"><code>ccflags-y := -Werror</code></pre></div>\n<h2 id=\"a-warning-free-build-is-a-requirement-for-any-kernel-code-that-might-be-submitted-upstream-and-it39s-a-good-discipline-even-for-local-modules-warnings-in-kernel-code-are-frequently-indicators-of-real-bugs-not-style-issues\">A warning-free build is a requirement for any kernel code that might be submitted upstream, and it&#39;s a good discipline even for local modules. Warnings in kernel code are frequently indicators of real bugs, not style issues.</h2>\n<h2 id=\"three-level-view-what-happens-during-insmod\">Three-Level View: What Happens During <code>insmod</code></h2>\n<p>When you run <code>sudo insmod hello.ko</code>, more happens than just &quot;the kernel loads your module.&quot; Here&#39;s the full picture:\n<strong>Level 1 â€” User Command</strong>:\n<code>insmod</code> reads <code>hello.ko</code> into memory, calls the <code>init_module()</code> system call (or the newer <code>finit_module()</code> with a file descriptor), passing the raw ELF data to the kernel.\n<strong>Level 2 â€” Kernel Module Loader</strong>:\nThe kernel&#39;s <code>load_module()</code> function (in <code>kernel/module/main.c</code>) performs these steps:</p>\n<ol>\n<li>Validates the ELF header and sections</li>\n<li>Allocates executable memory for the module using the module allocator (backed by <code>vmalloc</code>-range memory on most architectures)</li>\n<li>Copies code and data sections to the allocated memory</li>\n<li>Applies relocations â€” fills in the addresses of kernel symbols your module references (e.g., resolves <code>printk</code> to its actual kernel address)</li>\n<li>Verifies <code>vermagic</code> and (if CONFIG_MODVERSIONS) CRC checksums for each symbol</li>\n<li>Checks that <code>MODULE_LICENSE</code> doesn&#39;t taint for GPL-only symbols needed</li>\n<li>Calls your <code>module_init</code> function in the context of the <code>insmod</code> process</li>\n<li>If init returns 0: adds module to the kernel&#39;s module list, makes it visible in <code>/proc/modules</code> and <code>lsmod</code></li>\n<li>If init returns non-zero: frees the module memory, propagates error to <code>insmod</code>\n<strong>Level 3 â€” Hardware</strong>:\nThe module code and data land in the <strong>kernel&#39;s virtual address space</strong> â€” on x86_64, this is the upper half of the 64-bit address space (above <code>0xffff800000000000</code> approximately, depending on KASLR). The CPU&#39;s page tables are updated to map these new pages as <strong>kernel-mode executable</strong> â€” setting the <code>U/S</code> bit to 0 (supervisor-only) and <code>NX</code> bit to 0 (executable). Any attempt by userspace code to access these addresses triggers a page fault and kills the process. Any bug in your module code that causes a fault in these pages triggers a kernel oops.</li>\n</ol>\n<hr>\n<h2 id=\"knowledge-cascade-what-you39ve-just-unlocked\">Knowledge Cascade: What You&#39;ve Just Unlocked</h2>\n<h2 id=\"completing-this-milestone-doesn39t-just-teach-you-how-to-write-quothello-worldquot-in-the-kernel-it-unlocks-a-constellation-of-related-concepts-elf-section-mechanics-same-domain-the-__init-__exit-and-modinfo-annotations-you-used-are-instances-of-a-general-elf-mechanism-placing-data-in-named-sections-the-linker-script-that-produces-vmlinux-the-kernel-binary-uses-the-same-mechanism-to-organize-init-callbacks-exception-tables-and-system-call-tables-when-you-later-encounter-__attribute__sectionquotdataoncequot-or-similar-in-kernel-source-you39ll-recognize-the-pattern-symbol-export-and-gpl-enforcement-cross-domain-licensing-meets-abi-the-fact-that-module_licensequotgplquot-technically-controls-api-access-not-just-as-a-legal-statement-but-as-a-runtime-enforcement-mechanism-is-a-fascinating-intersection-of-intellectual-property-policy-and-systems-design-the-kernel-uses-export_symbol-vs-export_symbol_gpl-as-a-technical-implementation-of-the-gpl39s-copyleft-requirement-this-is-the-same-design-philosophy-as-quotcapabilitiesquot-in-security-enforcement-at-the-technical-layer-not-just-the-policy-layer-sysfs-as-universal-control-plane-cross-domain-same-pattern-as-prometheus-the-sysmoduleltnamegtparameters-interface-you-just-created-is-an-instance-of-the-sysfs-virtual-filesystem-a-tree-of-kernel-objects-exposed-as-files-the-same-infrastructure-exposes-cpu-frequency-scaling-under-sysdevicessystemcpu-usb-device-properties-under-sysbususb-and-block-device-queue-parameters-under-sysblockltdevgtqueue-when-you-look-at-a-kubernetes-node39s-sys-tree-or-a-prometheus-node-exporter-scraping-hardware-metrics-they39re-reading-the-same-virtual-files-you-just-learned-to-write-the-mental-model-quotmake-kernel-state-accessible-as-filesystem-entriesquot-is-one-of-linux39s-most-powerful-design-patterns-printk-ring-buffer-you39re-building-a-character-device-forward-the-dmesg-command-reads-devkmsg-which-is-a-character-device-the-ring-buffer-architecture-a-fixed-size-circular-buffer-in-kernel-memory-with-a-reader-that-advances-through-it-is-structurally-identical-to-what-you39ll-implement-in-milestone-2-when-you-implement-your-read-file-operation-and-manage-a-buf_pos-offset-you39re-implementing-the-same-mechanism-that-dmesg-uses-to-read-the-printk-ring-buffer-module-parameters-kernel-configuration-philosophy-the-sysfs-backed-parameter-you-created-is-a-micro-example-of-the-kernel39s-general-configuration-philosophy-separate-the-policy-what-values-mean-from-the-mechanism-how-they39re-stored-and-accessed-the-same-philosophy-appears-in-the-kernel39s-sysctl-interface-procsys-in-device-tree-overlays-and-in-runtime-kernel-configuration-via-kconfig-knowing-one-you-understand-the-pattern-behind-all-of-them\">Completing this milestone doesn&#39;t just teach you how to write &quot;Hello World&quot; in the kernel. It unlocks a constellation of related concepts:\n<strong>â†’ ELF Section Mechanics (same domain)</strong>: The <code>__init</code>, <code>__exit</code>, and <code>.modinfo</code> annotations you used are instances of a general ELF mechanism â€” placing data in named sections. The linker script that produces <code>vmlinux</code> (the kernel binary) uses the same mechanism to organize init callbacks, exception tables, and system call tables. When you later encounter <code>__attribute__((section(&quot;.data.once&quot;)))</code> or similar in kernel source, you&#39;ll recognize the pattern.\n<strong>â†’ Symbol Export and GPL Enforcement (cross-domain: licensing meets ABI)</strong>: The fact that <code>MODULE_LICENSE(&quot;GPL&quot;)</code> <em>technically controls API access</em> â€” not just as a legal statement but as a runtime enforcement mechanism â€” is a fascinating intersection of intellectual property policy and systems design. The kernel uses <code>EXPORT_SYMBOL</code> vs <code>EXPORT_SYMBOL_GPL</code> as a technical implementation of the GPL&#39;s copyleft requirement. This is the same design philosophy as &quot;capabilities&quot; in security: enforcement at the technical layer, not just the policy layer.\n<strong>â†’ sysfs as Universal Control Plane (cross-domain: same pattern as Prometheus)</strong>: The <code>/sys/module/&lt;name&gt;/parameters/</code> interface you just created is an instance of the sysfs virtual filesystem â€” a tree of kernel objects exposed as files. The same infrastructure exposes CPU frequency scaling under <code>/sys/devices/system/cpu/</code>, USB device properties under <code>/sys/bus/usb/</code>, and block device queue parameters under <code>/sys/block/&lt;dev&gt;/queue/</code>. When you look at a Kubernetes node&#39;s <code>/sys</code> tree or a Prometheus node exporter scraping hardware metrics, they&#39;re reading the same virtual files you just learned to write. The mental model â€” &quot;make kernel state accessible as filesystem entries&quot; â€” is one of Linux&#39;s most powerful design patterns.\n<strong>â†’ printk Ring Buffer â†’ You&#39;re Building a Character Device (forward)</strong>: The <code>dmesg</code> command reads <code>/dev/kmsg</code>, which is a character device. The ring buffer architecture â€” a fixed-size circular buffer in kernel memory, with a reader that advances through it â€” is structurally identical to what you&#39;ll implement in Milestone 2. When you implement your <code>read</code> file operation and manage a <code>buf_pos</code> offset, you&#39;re implementing the same mechanism that <code>dmesg</code> uses to read the printk ring buffer.\n<strong>â†’ Module Parameters â†’ Kernel Configuration Philosophy</strong>: The sysfs-backed parameter you created is a micro-example of the kernel&#39;s general configuration philosophy: separate the policy (what values mean) from the mechanism (how they&#39;re stored and accessed). The same philosophy appears in the kernel&#39;s <code>sysctl</code> interface (<code>/proc/sys/</code>), in device tree overlays, and in runtime kernel configuration via <code>kconfig</code>. Knowing one, you understand the pattern behind all of them.</h2>\n<h2 id=\"acceptance-criteria-checkpoint\">Acceptance Criteria Checkpoint</h2>\n<p>Before moving to Milestone 2, verify:</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> <code>make</code> completes without warnings using Kbuild against the running kernel headers</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>modinfo hello.ko</code> shows <code>license: GPL</code>, <code>author:</code>, <code>description:</code>, and <code>parm: buffer_size</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>sudo insmod hello.ko</code> succeeds and <code>dmesg | tail</code> shows the init message with <code>KERN_INFO</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>lsmod | grep hello</code> shows the module as loaded</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>/sys/module/hello/parameters/buffer_size</code> exists and reads <code>4096</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>sudo insmod hello.ko buffer_size=8192</code> produces <code>8192</code> in the sysfs attribute</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>sudo insmod hello.ko buffer_size=-1</code> returns an error (init validates and returns <code>-EINVAL</code>)</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>sudo rmmod hello</code> succeeds and <code>dmesg | tail</code> shows the exit message</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>make</code> with <code>ccflags-y := -Werror</code> produces zero warnings\nIf any of these fail, use <code>dmesg -w</code> in a separate terminal while running <code>insmod</code>/<code>rmmod</code> to see kernel messages in real time. If <code>insmod</code> fails with &quot;Operation not permitted&quot;, you need <code>sudo</code>. If it fails with &quot;File exists&quot;, the module is already loaded â€” run <code>rmmod</code> first.</li>\n</ul>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-kernel-module-m2 -->\n<!-- MS_ID: build-kernel-module-m2 -->\n<h1 id=\"milestone-2-character-device-driver\">Milestone 2: Character Device Driver</h1>\n<h2 id=\"the-revelation-user-pointers-are-traps\">The Revelation: User Pointers Are Traps</h2>\n<p>You&#39;ve just loaded a kernel module. Now a process is going to call <code>write(fd, buf, 4096)</code> and your driver needs to receive those 4096 bytes. The user hands you a pointer. Why can&#39;t you just do this?</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* THIS IS WRONG. DO NOT DO THIS. */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydev_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                           size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">loff_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">f_pos</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(kernel_buffer, buf, count);</span><span style=\"color:#6A737D\">  /* â† WRONG: direct dereference of user pointer */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> count;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Your instinct says: &quot;The kernel can access <em>all</em> memory â€” it&#39;s in ring 0, it has the highest privilege. If the user gives me a pointer to their buffer at address <code>0x7fff1234</code>, I can just read from <code>0x7fff1234</code>.&quot;\nThis instinct is half right and fully dangerous. The kernel <em>can</em> access that address in a mechanical sense â€” the CPU won&#39;t fault on privilege. But consider what happens when:</p>\n<ol>\n<li>The user passes a <strong>completely bogus pointer</strong>: <code>write(fd, (void*)0xdeadbeef, 100)</code>. There&#39;s no page mapped at <code>0xdeadbeef</code> in the user&#39;s page tables. A direct <code>memcpy</code> from <code>0xdeadbeef</code> generates a page fault. In userspace, a page fault in process context just delivers SIGSEGV. But this page fault happens <em>in kernel context</em> â€” during your driver&#39;s write handler â€” and it kills the kernel.</li>\n<li>The user passes a <strong>pointer to a memory-mapped device register</strong> and your driver blindly reads from it. Now you&#39;ve let a userspace program trigger arbitrary hardware I/O through your driver.</li>\n<li>The user passes a <strong>valid pointer at the moment of the call</strong>, but the page gets swapped out between your check and your copy. Classic TOCTOU â€” time-of-check/time-of-use race condition.</li>\n<li>A 32-bit process running on a 64-bit kernel passes a pointer that looks valid but falls in the kernel&#39;s own address space. Direct dereference now reads kernel memory on behalf of a userspace program.\nThe solution is <code>copy_from_user()</code> and <code>copy_to_user()</code>. But these functions don&#39;t solve the problem by <em>checking</em> the pointer first and then copying. They solve it by <strong>installing a temporary exception handler before the copy</strong>. Here&#39;s the real mechanism:</li>\n</ol>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiag-m2-copy-user-mechanism.svg\" alt=\"copy_from_user / copy_to_user: Exception Table Mechanism\"></p>\n<p>The kernel maintains an <strong>exception table</strong> â€” a sorted array of <code>(faulting_address, fixup_address)</code> pairs in a <code>.ex_table</code> ELF section. The assembly code inside <code>copy_from_user()</code> is annotated so that every load instruction has a corresponding entry in this table. When a page fault occurs anywhere in the kernel:</p>\n<ol>\n<li>The page fault handler checks: <em>is this fault address in the exception table?</em></li>\n<li>If yes: instead of panicking, it jumps to the <code>fixup_address</code> â€” a small stub that sets the return value to indicate failure, zeroes the destination buffer, and returns gracefully.</li>\n<li>If no: it&#39;s an unexpected kernel bug â€” oops/panic.\nThis means <code>copy_from_user()</code> is a <strong>trap-and-recover</strong> mechanism, not a check-then-copy mechanism. The copy proceeds optimistically. If it faults, the kernel recovers cleanly and returns <code>-EFAULT</code> to your driver, which returns <code>-EFAULT</code> to the user process. The kernel never crashes. The user process gets an error code and continues (or not â€” their choice).</li>\n</ol>\n<h2 id=\"this-is-one-of-the-most-important-pieces-of-kernel-api-design-you39ll-encounter-every-single-data-transfer-path-in-your-driver-now-and-forever-goes-through-copy_from_user-or-copy_to_user-there-are-no-exceptions-not-for-quottrustedquot-programs-not-for-root-processes-not-for-quotsmallquot-copies-the-exception-table-mechanism-exists-to-guarantee-that-even-hostile-or-buggy-userspace-cannot-crash-the-kernel-through-your-driver\">This is one of the most important pieces of kernel API design you&#39;ll encounter. Every single data transfer path in your driver â€” now and forever â€” goes through <code>copy_from_user</code> or <code>copy_to_user</code>. There are no exceptions. Not for &quot;trusted&quot; programs. Not for root processes. Not for &quot;small&quot; copies. The exception table mechanism exists to guarantee that even hostile or buggy userspace cannot crash the kernel through your driver.</h2>\n<h2 id=\"the-architecture-before-the-code\">The Architecture Before the Code</h2>\n<p>Before writing a single line, you need to see the full picture of what you&#39;re building.</p>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiag-m2-major-minor-registration.svg\" alt=\"Device Registration: From alloc_chrdev_region to /dev/ Node\"></p>\n<p>When a userspace program opens <code>/dev/mydevice</code>, a chain of kernel machinery fires:</p>\n<ol>\n<li>The VFS (Virtual File System â€” the kernel&#39;s unified interface over all filesystems and device files) looks at the device file&#39;s inode.</li>\n<li>The inode contains a <strong>device number</strong> (<code>dev_t</code>) â€” a 32-bit integer encoding two values: the <strong>major number</strong> (identifies the driver) and the <strong>minor number</strong> (identifies which instance of that driver).</li>\n<li>The kernel looks up the major number in a character device table, finds your <code>cdev</code> structure, and calls your <code>.open</code> function pointer.</li>\n<li>From there, every <code>read()</code>, <code>write()</code>, <code>ioctl()</code>, and <code>close()</code> on that file descriptor routes through the function pointers in your <code>file_operations</code> struct.\n[[EXPLAIN:major/minor-numbers-and-the-vfs-layer|Major/minor numbers and the VFS layer]]\nThis dispatch chain â€” from system call number to your function â€” is the VFS vtable pattern:</li>\n</ol>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiag-m2-file-operations-vtable.svg\" alt=\"file_operations: The Kernel's Virtual Method Table\"></p>\n<blockquote>\n<p><strong>ðŸ”‘ Foundation: The file_operations vtable pattern</strong></p>\n<p><strong>What it IS</strong>\nThe <code>struct file_operations</code> is a dispatch table (or Virtual Method Table) used by the Linux kernel to implement polymorphism in C. It is a structure filled with function pointersâ€”such as <code>.read</code>, <code>.write</code>, <code>.open</code>, and <code>.release</code>â€”that link generic system calls to your specific driverâ€™s implementation. When a userspace program calls <code>read()</code> on a file descriptor, the kernel looks up the <code>file_operations</code> struct associated with that file and executes the function pointed to by the <code>.read</code> member.</p>\n</blockquote>\n<p><strong>WHY you need it right now</strong>\nIn a character device driver, this is your primary interface. The kernel treats &quot;everything as a file,&quot; but the kernel doesn&#39;t know what &quot;reading&quot; means for your specific hardware or virtual device. You must fill this struct to map standard POSIX API calls to your custom logic. Without it, your device exists in the system but remains unreachable and non-functional to userspace.</p>\n<p><strong>ONE key insight or mental model</strong>\nThink of the <code>file_operations</code> struct as a <strong>Contract</strong>: The kernel provides the &quot;Interface&quot; (the names of the functions), and you provide the &quot;Implementation&quot; (the actual logic). It decouples the VFS (Virtual File System) from the hardware-specific details.</p>\n<h2 id=\"the-struct-file_operations-is-the-kernel39s-equivalent-of-a-c-vtable-or-a-go-interface-a-struct-of-function-pointers-where-each-pointer-implements-one-operation-your-driver-fills-in-the-ones-it-cares-about-the-ones-left-null-get-default-behavior-or-return-enosys-for-quotnot-implementedquot\">The <code>struct file_operations</code> is the kernel&#39;s equivalent of a C++ vtable or a Go interface: a struct of function pointers where each pointer implements one operation. Your driver fills in the ones it cares about; the ones left <code>NULL</code> get default behavior (or return <code>-ENOSYS</code> for &quot;not implemented&quot;).</h2>\n<h2 id=\"how-write2-becomes-your-function\">How <code>write(2)</code> Becomes Your Function</h2>\n<p>Let&#39;s trace the full path from a userspace <code>write()</code> call to your driver&#39;s write handler. This path demystifies why the function signatures look the way they do.</p>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiag-m2-syscall-to-driver.svg\" alt=\"The Full Path: write(fd, buf, n) â†’ Your Driver's Write Handler\"></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>User Process                 Kernel                          Your Driver\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nwrite(fd, buf, n)\n  â”‚\n  â”‚  (syscall instruction\n  â”‚   triggers privilege\n  â”‚   elevation to ring 0)\n  â”‚\n  â–¼\nsys_write(fd, buf, n)        â† kernel entry point\n  â”‚\n  â–¼\nksys_write(fd, buf, n)\n  â”‚  looks up fd in\n  â”‚  current-&gt;files-&gt;fdt\n  â”‚  finds struct file *f\n  â–¼\nvfs_write(f, buf, n, &amp;f-&gt;f_pos)\n  â”‚\n  â–¼\nf-&gt;f_op-&gt;write(f, buf, n, &amp;f-&gt;f_pos)  â† vtable dispatch\n                                                â”‚\n                                                â–¼\n                                       mydev_write(filp, buf, n, f_pos)\n                                                â”‚\n                                                â–¼\n                                       copy_from_user(kernel_buf, buf, n)</code></pre></div>\n<p><strong>The function signature is dictated by this call chain.</strong> Your write handler receives:</p>\n<ul>\n<li><code>struct file *filp</code> â€” the kernel&#39;s representation of the open file; carries state like <code>f_pos</code>, <code>f_flags</code>, and a pointer to your device-private data</li>\n<li><code>const char __user *buf</code> â€” the userspace buffer address (annotated with <code>__user</code> to help Sparse, the kernel&#39;s static analysis tool, catch direct dereferences)</li>\n<li><code>size_t count</code> â€” bytes requested</li>\n<li><code>loff_t *f_pos</code> â€” pointer to the file position; you update this in read to advance the position\nThe <code>__user</code> annotation is parsed by <strong>Sparse</strong> (the kernel&#39;s static checker, invoked with <code>make C=1</code>). It doesn&#39;t affect compiled code, but Sparse will warn if you pass a <code>__user</code>-annotated pointer to a function expecting a kernel pointer (like <code>memcpy</code>). This turns potential runtime crashes into compile-time warnings.</li>\n</ul>\n<hr>\n<h2 id=\"device-numbers-dynamic-allocation\">Device Numbers: Dynamic Allocation</h2>\n<p>In the early days of Unix, device major numbers were statically assigned. The kernel source file <code>Documentation/admin-guide/devices.txt</code> lists these historical allocations â€” major 1 is <code>mem</code> (for <code>/dev/null</code>, <code>/dev/zero</code>, etc.), major 4 is <code>tty</code>, major 8 is SCSI disk. There are only 4096 major numbers, and they were running out.\nModern practice: <strong>always use dynamic allocation</strong>. The kernel picks an unused major number at load time:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> dev_t</span><span style=\"color:#E1E4E8\"> dev_num;</span><span style=\"color:#6A737D\">           /* will hold our major+minor after allocation */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> cdev my_cdev;</span><span style=\"color:#6A737D\">     /* kernel's char device structure */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> class </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">my_class;</span><span style=\"color:#6A737D\">  /* for automatic /dev/ node creation */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* In module_init: */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_chrdev_region</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">dev_num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"mydevice\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*                         ^         ^  ^   ^</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *                         |         |  |   device name in /proc/devices</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *                         |         |  number of minors to reserve</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *                         |         first minor number</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *                         output: dev_t with major+minor                */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydev: failed to allocate device number: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ret);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydev: allocated major=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, minor=</span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">       MAJOR</span><span style=\"color:#E1E4E8\">(dev_num), </span><span style=\"color:#B392F0\">MINOR</span><span style=\"color:#E1E4E8\">(dev_num));</span></span></code></pre></div>\n<p><code>MAJOR(dev_num)</code> and <code>MINOR(dev_num)</code> are macros that extract the respective fields from the 32-bit <code>dev_t</code>. The encoding on Linux: top 12 bits are major, bottom 20 bits are minor. <code>MKDEV(major, minor)</code> constructs a <code>dev_t</code> from components.\nAfter this call succeeds, you&#39;ve reserved a device number. The device doesn&#39;t exist yet â€” there&#39;s no <code>cdev</code> connected, no <code>/dev/</code> node. You&#39;ve just claimed the number. You can verify it:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">grep</span><span style=\"color:#9ECBFF\"> mydevice</span><span style=\"color:#9ECBFF\"> /proc/devices</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Output: 240 mydevice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># (240 is an example; actual number varies)</span></span></code></pre></div>\n<h2 id=\"critical-cleanup-rule-every-successful-alloc_chrdev_region-must-be-paired-with-unregister_chrdev_region-in-your-exit-path-and-error-paths-the-kernel-does-not-automatically-reclaim-device-numbers-when-a-module-exits-without-cleanup\"><strong>Critical cleanup rule</strong>: every successful <code>alloc_chrdev_region()</code> must be paired with <code>unregister_chrdev_region()</code> in your exit path and error paths. The kernel does <em>not</em> automatically reclaim device numbers when a module exits without cleanup.</h2>\n<h2 id=\"the-cdev-structure-connecting-numbers-to-operations\">The <code>cdev</code> Structure: Connecting Numbers to Operations</h2>\n<p>Allocating a number isn&#39;t enough. You need to tell the kernel: &quot;when something opens the device with this number, use <em>these</em> file operations.&quot; That&#39;s the job of <code>struct cdev</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> file_operations mydev_fops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .owner   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> THIS_MODULE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .open    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_open,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .release </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_release,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .read    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_read,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .write   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_write,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* In module_init, after alloc_chrdev_region: */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cdev_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">my_cdev</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">mydev_fops</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">my_cdev.owner </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> THIS_MODULE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> cdev_add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">my_cdev</span><span style=\"color:#E1E4E8\">, dev_num, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*              ^          ^       ^</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *              cdev       dev_t   number of minors this cdev handles */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydev: cdev_add failed: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ret);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    goto</span><span style=\"color:#E1E4E8\"> err_cdev;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"cdev_add-makes-the-device-live-from-this-point-if-anything-opens-the-device-number-the-kernel-will-dispatch-to-your-mydev_fops-this-is-why-error-handling-order-matters-you-don39t-want-the-device-reachable-before-it39s-fully-initialized-the-owner-this_module-field-prevents-the-module-from-being-unloaded-while-the-device-has-open-file-descriptors-this_module-is-a-pointer-to-the-struct-module-that-represents-your-module-the-vfs-increments-the-module39s-reference-count-when-a-file-is-opened-and-decrements-it-on-close-if-you-omit-owner-rmmod-can-unload-your-module-while-a-process-still-has-an-open-file-descriptor-the-next-read-call-would-jump-to-the-now-unmapped-function-and-crash-the-kernel\"><code>cdev_add()</code> makes the device <strong>live</strong> â€” from this point, if anything opens the device number, the kernel will dispatch to your <code>mydev_fops</code>. This is why error handling order matters: you don&#39;t want the device reachable before it&#39;s fully initialized.\nThe <code>.owner = THIS_MODULE</code> field prevents the module from being unloaded while the device has open file descriptors. <code>THIS_MODULE</code> is a pointer to the <code>struct module</code> that represents your module. The VFS increments the module&#39;s reference count when a file is opened and decrements it on close. If you omit <code>.owner</code>, <code>rmmod</code> can unload your module while a process still has an open file descriptor â€” the next <code>read()</code> call would jump to the now-unmapped function and crash the kernel.</h2>\n<h2 id=\"automatic-dev-nodes-class_create-and-device_create\">Automatic <code>/dev/</code> Nodes: class_create and device_create</h2>\n<p>You&#39;ve allocated a number and registered a cdev. But there&#39;s still no <code>/dev/mydevice</code> file. In ancient times you&#39;d run <code>mknod /dev/mydevice c 240 0</code> manually. Modern Linux uses <strong>udev</strong> â€” a userspace daemon that listens for hotplug events from the kernel and automatically creates device nodes.</p>\n<blockquote>\n<p><strong>ðŸ”‘ Foundation: udev and the kernel uevent mechanism: how device_create triggers /dev/ node creation</strong></p>\n<p><strong>What it IS</strong>\nThe kernel <code>uevent</code> mechanism is a notification system where the kernel broadcasts &quot;user events&quot; to userspace whenever a device state changes (e.g., a device is created, removed, or changed). <code>udev</code> is a userspace daemon that listens for these events via a netlink socket. When you call <code>device_create()</code> in your driver, the kernel sends a uevent; <code>udev</code> catches it, looks up its rules (usually in <code>/etc/udev/rules.d/</code>), and automatically creates a corresponding device node in the <code>/dev/</code> directory with the correct permissions.</p>\n</blockquote>\n<p><strong>WHY you need it right now</strong>\nManually creating device files using the <code>mknod</code> command is error-prone and tedious. By using the <code>class_create()</code> and <code>device_create()</code> functions in your module, you trigger the uevent mechanism. This ensures that as soon as your module is loaded (<code>insmod</code>), the device file (e.g., <code>/dev/mydevice</code>) appears instantly and automatically for the user, and disappears when the module is unloaded.</p>\n<p><strong>ONE key insight or mental model</strong>\nThe kernel is the <strong>Broadcaster</strong> and <code>udev</code> is the <strong>Assistant</strong>. The kernel shouts &quot;I&#39;ve added a new device!&quot; into a megaphone, and <code>udev</code> hears it and quickly runs to the <code>/dev/</code> folder to put a new &quot;doorway&quot; (device node) there for userspace to use.</p>\n<p>The kernel sends udev events through the <strong>device model</strong> â€” a hierarchical tree of <code>struct device</code> objects that represents all hardware and virtual devices in the system. <code>class_create()</code> and <code>device_create()</code> are your entry points into this system:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Create a device class â€” appears as /sys/class/&#x3C;name> */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">my_class </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> class_create</span><span style=\"color:#E1E4E8\">(THIS_MODULE, </span><span style=\"color:#9ECBFF\">\"mydevice\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">IS_ERR</span><span style=\"color:#E1E4E8\">(my_class)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> PTR_ERR</span><span style=\"color:#E1E4E8\">(my_class);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydev: class_create failed: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ret);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    goto</span><span style=\"color:#E1E4E8\"> err_class;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Create the device â€” triggers udev to create /dev/mydevice */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">my_device </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> device_create</span><span style=\"color:#E1E4E8\">(my_class, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, dev_num, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"mydevice\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">IS_ERR</span><span style=\"color:#E1E4E8\">(my_device)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> PTR_ERR</span><span style=\"color:#E1E4E8\">(my_device);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydev: device_create failed: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ret);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    goto</span><span style=\"color:#E1E4E8\"> err_device;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong><code>IS_ERR()</code> and <code>PTR_ERR()</code> â€” kernel error pointers</strong>: The kernel uses a trick where error codes are encoded as pointer values in the high portion of the address space. <code>IS_ERR(ptr)</code> checks if the pointer is actually an error code (a value between <code>-MAX_ERRNO</code> and 0, cast to a pointer). <code>PTR_ERR(ptr)</code> extracts the integer error code. This allows functions that return pointers to signal errors without a separate output parameter. You&#39;ll see this pattern everywhere in kernel code for functions that return <code>struct *</code>.\n<code>device_create()</code> registers a <code>struct device</code> in the kernel&#39;s device tree and emits a <strong>uevent</strong> with the device&#39;s class, major/minor numbers, and name. udev (or systemd-udevd) receives this event and creates <code>/dev/mydevice</code> with the correct major/minor and permissions. You can watch this happen:</p>\n</blockquote>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># In one terminal, watch udev events:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">udevadm</span><span style=\"color:#9ECBFF\"> monitor</span><span style=\"color:#79B8FF\"> --kernel</span><span style=\"color:#79B8FF\"> --udev</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># In another terminal, load your module:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> insmod</span><span style=\"color:#9ECBFF\"> mydevice.ko</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># You'll see: add /class/mydevice/mydevice (class)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># And udev creates /dev/mydevice automatically</span></span></code></pre></div>\n<hr>\n<h2 id=\"the-kernel-buffer-kmalloc-and-the-slab-allocator\">The Kernel Buffer: kmalloc and the SLAB Allocator</h2>\n<p>Your device needs a place to store data. In userspace you&#39;d call <code>malloc()</code>. In the kernel you call <code>kmalloc()</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">kernel_buffer;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#E1E4E8\"> buffer_size_bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 4096</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* In module_init: */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">kernel_buffer </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kzalloc</span><span style=\"color:#E1E4E8\">(buffer_size_bytes, GFP_KERNEL);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*              ^         ^                ^</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *              zero-fills the allocation  |</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *              (k + zalloc = malloc+memset(0))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *                            allocation size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *                                         allocation flags */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">kernel_buffer) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydev: failed to allocate kernel buffer</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOMEM;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    goto</span><span style=\"color:#E1E4E8\"> err_buffer;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiag-m2-kernel-buffer-layout.svg\" alt=\"Kernel Buffer: kmalloc, SLAB Allocator, and Memory Layout\"></p>\n<p><code>kmalloc</code> draws from the <strong>SLAB/SLUB allocator</strong> â€” not a heap in the traditional sense.</p>\n<blockquote>\n<p><strong>ðŸ”‘ Foundation: kmalloc and the SLAB/SLUB allocator: how kernel memory allocation differs from malloc</strong></p>\n<p><strong>What it IS</strong>\n<code>kmalloc</code> is the kernel equivalent of userspace <code>malloc()</code>, used for allocating physically contiguous memory. Under the hood, it doesn&#39;t just grab raw pages; it uses the <strong>SLAB</strong> (or the more modern <strong>SLUB</strong>) allocator. This system manages &quot;caches&quot; of commonly used object sizes. Instead of constantly searching for free memory of arbitrary sizes, the SLUB allocator maintains lists of pre-allocated &quot;slabs&quot; (blocks of memory) divided into small, equal-sized &quot;slots.&quot;</p>\n</blockquote>\n<p><strong>WHY you need it right now</strong>\nKernel memory is a finite, precious resource that cannot be &quot;swapped&quot; to disk like userspace memory. When you need to store driver state or buffers, you use <code>kmalloc</code>. However, you must specify a <strong>GFP (Get Free Page) flag</strong>: usually <code>GFP_KERNEL</code> (which can sleep if memory is tight) or <code>GFP_ATOMIC</code> (which cannot sleep, used inside interrupt handlers). Understanding that <code>kmalloc</code> is backed by the SLUB allocator helps you realize why it is highly efficient for small, frequent allocations but can fail if you request massive, contiguous chunks.</p>\n<p><strong>ONE key insight or mental model</strong>\nThe SLUB allocator is like a <strong>Bento Box shop</strong>. Instead of cooking every meal from scratch (searching raw memory), they have pre-portioned boxes for 32-byte, 64-byte, and 128-byte meals. When you call <code>kmalloc(40)</code>, the kernel just hands you a 64-byte &quot;box&quot; because itâ€™s the fastest way to serve you.</p>\n<p>The <code>GFP_KERNEL</code> flag is the most important argument to understand right now. GFP stands for &quot;Get Free Pages&quot; â€” it describes the allocation context. <code>GFP_KERNEL</code> means:</p>\n<ul>\n<li><strong>Can sleep</strong>: the allocator may block the current process if memory is scarce, waiting for pages to be freed or swapped out</li>\n<li><strong>Can reclaim</strong>: the kernel may try to free other caches to satisfy this allocation</li>\n<li><strong>Can use all memory zones</strong>: the allocator has access to all physical memory\nThis is correct for your <code>module_init</code> context â€” init runs in process context (the <code>insmod</code> process), so sleeping is fine.\n<strong>The critical rule</strong>: if you&#39;re ever in <strong>interrupt context</strong> (inside an interrupt handler) or holding a <strong>spinlock</strong> (a non-sleeping lock), you must use <code>GFP_ATOMIC</code> instead of <code>GFP_KERNEL</code>. <code>GFP_ATOMIC</code> cannot sleep, cannot reclaim, and may fail more often. Using <code>GFP_KERNEL</code> in atomic context causes the kernel to print a warning and potentially deadlock. For this milestone, you&#39;re only allocating in <code>module_init</code> where <code>GFP_KERNEL</code> is always correct.<blockquote>\n<p><strong>Hardware Soul â€” kmalloc memory placement</strong>:</p>\n<ul>\n<li><code>kmalloc</code> returns <strong>physically contiguous</strong> memory (pages from the buddy allocator, managed by SLAB/SLUB)</li>\n<li>This memory is in the <strong>kernel&#39;s direct mapping</strong> (on x86_64: the <code>0xffff888000000000</code> region, directly mapped to physical memory). This means kernel virtual address and physical address differ by a fixed offset â€” <code>virt_to_phys()</code> computes this.</li>\n<li>Your 4KB buffer fits in one page. For the L1 cache (typically 32KB, 8-way set-associative, 64-byte cache lines), a 4KB buffer occupies 64 cache lines and fits comfortably. Sequential access by your write/read handlers will be cache-friendly â€” hardware prefetcher will pull ahead as you access bytes in order.</li>\n<li><code>kzalloc</code> (zero-filling variant) is marginally slower than <code>kmalloc</code> for the first use but ensures no data leakage from previously freed memory â€” a security property.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h2 id=\"implementing-file_operations-open-and-release\">Implementing <code>file_operations</code>: Open and Release</h2>\n<p>Now for the actual file operations. Start with the simplest pair â€” open and release:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> atomic_t</span><span style=\"color:#E1E4E8\"> open_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ATOMIC_INIT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydev_open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> inode </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    atomic_inc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydev: opened (count=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">           atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydev_release</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> inode </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    atomic_dec</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydev: released (count=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">           atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Why <code>atomic_t</code> instead of a plain <code>int</code>? Because <code>open</code> and <code>release</code> can be called concurrently from multiple processes. Incrementing a plain integer is a read-modify-write operation â€” three machine instructions. Two CPUs doing it simultaneously can read the same value, both increment it to the same result, and write the same value back (both get <code>count+1</code> when the correct result is <code>count+2</code>). <code>atomic_inc</code> generates an atomic increment instruction (<code>lock xadd</code> on x86) that the CPU&#39;s bus lock makes indivisible.</p>\n<blockquote>\n<p><strong>ðŸ”‘ Foundation: Linux atomic operations: atomic_t</strong></p>\n<p><strong>What it IS</strong>\nAtomic operations are low-level instructions that are guaranteed to execute as a single, indivisible unit. The Linux kernel provides the <code>atomic_t</code> type (an opaque structure wrapping an integer) and functions like <code>atomic_inc()</code>, <code>atomic_dec()</code>, and <code>atomic_read()</code>. These use CPU-specific instructions (like <code>LOCK</code> prefixes on x86) to ensure that if two CPU cores try to increment the same variable simultaneously, one will strictly happen after the other, and no data will be lost.</p>\n</blockquote>\n<p><strong>WHY you need it right now</strong>\nIn a multi-core kernel environment, a simple <code>i++</code> is dangerous. It involves three steps: read from memory, increment in register, write back to memory. If an interrupt occurs or another CPU accesses the variable mid-way, you get a &quot;race condition&quot; and corrupted data. In your driver, if you are counting how many processes have opened your device or tracking a shared resource, you must use <code>atomic_t</code> to ensure thread safety without the heavy performance overhead of a Mutex or Spinlock.</p>\n<p><strong>ONE key insight or mental model</strong>\nAn atomic operation is <strong>Indivisible</strong>. To the rest of the system, the variable jumps from <code>A</code> to <code>B</code> instantly; there is no &quot;middle&quot; state where the variable is being processed, making it immune to being interrupted by other tasks.</p>\n<p><strong><code>struct inode</code> vs <code>struct file</code></strong>: The inode represents the device file itself â€” it&#39;s shared between all processes and persists as long as the file exists. The <code>struct file</code> represents a single <em>open instance</em> â€” it&#39;s created fresh for each <code>open()</code> call and destroyed on the last <code>close()</code>. If three processes open <code>/dev/mydevice</code> simultaneously, they share one inode but have three distinct <code>struct file</code> instances. This is where <code>filp-&gt;f_pos</code> lives â€” per-file-descriptor, not per-device.\n<strong>Private data pattern</strong>: For more complex drivers, you&#39;d store a pointer to your device-private struct in <code>filp-&gt;private_data</code> during open:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydev_open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> inode </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filp->private_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">my_device_state;</span><span style=\"color:#6A737D\">  /* accessible in read/write/ioctl */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    atomic_inc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"this-is-crucial-for-drivers-that-manage-multiple-device-instances-each-minor-number-maps-to-a-different-device-state-and-you-need-to-find-the-right-one-in-your-handlers\">This is crucial for drivers that manage multiple device instances â€” each minor number maps to a different device state, and you need to find the right one in your handlers.</h2>\n<h2 id=\"implementing-write-copy_from_user-in-practice\">Implementing Write: copy_from_user in Practice</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#E1E4E8\"> buffer_used </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   /* bytes currently in the buffer */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydev_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                           size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">loff_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">f_pos</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> space_available;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> not_copied;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* How much space remains in the buffer? */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    space_available </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> buffer_size_bytes </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> buffer_used;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (space_available </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOSPC;</span><span style=\"color:#6A737D\">  /* buffer full */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Don't copy more than we have space for */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes_to_copy </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> min</span><span style=\"color:#E1E4E8\">(count, space_available);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * copy_from_user(to, from, n):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *   to   = kernel destination address</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *   from = userspace source address (__user pointer)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *   n    = bytes to copy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Returns: number of bytes NOT copied (0 on success).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Non-zero means a fault occurred; return -EFAULT.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    not_copied </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> copy_from_user</span><span style=\"color:#E1E4E8\">(kernel_buffer </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> buffer_used, buf, bytes_to_copy);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (not_copied </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Partial copy: some bytes got through before the fault.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * We must account for the bytes that DID make it.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * bytes_copied = bytes_to_copy - not_copied</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * But for simplicity in this milestone, treat any copy failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * as -EFAULT. More complex drivers handle partial copies.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buffer_used </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Note: we do NOT update *f_pos here.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Write position tracking in this device uses buffer_used, not f_pos.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * f_pos is updated by the VFS for regular files; for character devices</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * the semantics are driver-defined. */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_DEBUG </span><span style=\"color:#9ECBFF\">\"mydev: write </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes (buffer now </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           bytes_to_copy, buffer_used, buffer_size_bytes);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> bytes_to_copy;</span><span style=\"color:#6A737D\">  /* return number of bytes accepted */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><strong>Return value semantics for write handlers</strong>:</p>\n<ul>\n<li>Positive: bytes successfully written. The VFS may call your handler again if the user requested more than you returned.</li>\n<li><code>0</code>: nothing written but no error (unusual for write, but valid for non-blocking when buffer is full â€” we&#39;ll use <code>-ENOSPC</code> here for clarity)</li>\n<li>Negative: error code. <code>-EFAULT</code> for bad user pointer. <code>-ENOSPC</code> for no space. <code>-EINTR</code> for interrupted. The error propagates to the userspace <code>write()</code> return value.\n<strong><code>min()</code> vs <code>min_t()</code></strong>: The kernel defines <code>min(a, b)</code> as a type-safe macro that warns if <code>a</code> and <code>b</code> have different types. If you&#39;re comparing values of different types (say <code>size_t</code> and <code>ssize_t</code>), use <code>min_t(type, a, b)</code> to specify the comparison type explicitly. Mismatched signed/unsigned comparisons are a source of subtle bugs (a negative <code>ssize_t</code> compared to a <code>size_t</code> compares as very large, not negative).</li>\n</ul>\n<hr>\n<h2 id=\"implementing-read-f_pos-tracking-and-the-eof-contract\">Implementing Read: f_pos Tracking and the EOF Contract</h2>\n<p>The read handler is where developers most often make the mistake of returning wrong values and creating infinite loops. Let&#39;s understand why this happens before writing the code.</p>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiag-m2-fpos-read-behavior.svg\" alt=\"f_pos Tracking: Why cat Terminates But Naive Reads Loop Forever\"></p>\n<p>When you run <code>cat /dev/mydevice</code>, <code>cat</code> calls <code>read(fd, buf, BUFSIZ)</code> in a loop until it gets a return value of <code>0</code> (EOF). This is the universal Unix contract: <strong>read returns 0 to signal end of file, not an error</strong>. \nIf your read handler always returns a positive number (even 1 byte), <code>cat</code> will loop forever, generating an infinite stream of whatever data you return. This is the most common read handler bug in beginner kernel modules.\nThe <code>f_pos</code> (file position) tracks how far into the &quot;file&quot; the reader has consumed. For your character device, it&#39;s tracking how far into <code>kernel_buffer</code> the current reader has gotten:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydev_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                          size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">loff_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">f_pos</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_available;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> not_copied;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * *f_pos is the current read position within the buffer.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * If f_pos >= buffer_used, the reader has consumed all data: EOF.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">f_pos </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> buffer_used)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* EOF: no more data â€” cat and read() loops terminate here */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* How many unread bytes remain? */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes_available </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> buffer_used </span><span style=\"color:#F97583\">-</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">f_pos;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Give the caller at most 'count' bytes */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes_to_copy </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> min</span><span style=\"color:#E1E4E8\">(count, bytes_available);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * copy_to_user(to, from, n):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *   to   = userspace destination address (__user pointer)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *   from = kernel source address</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *   n    = bytes to copy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Returns: number of bytes NOT copied (0 on full success).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    not_copied </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> copy_to_user</span><span style=\"color:#E1E4E8\">(buf, kernel_buffer </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">f_pos, bytes_to_copy);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (not_copied </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Advance the file position by the number of bytes we copied */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">f_pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_DEBUG </span><span style=\"color:#9ECBFF\">\"mydev: read </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes (f_pos now </span><span style=\"color:#79B8FF\">%lld</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           bytes_to_copy, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">f_pos, buffer_used);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><strong>The f_pos dance</strong>:</p>\n<ul>\n<li><code>*f_pos</code> starts at 0 when the file is first opened</li>\n<li>Each successful read advances <code>*f_pos</code> by the number of bytes returned</li>\n<li>When <code>*f_pos == buffer_used</code>, the next read returns 0 (EOF)</li>\n<li>After EOF, <code>cat</code> exits its read loop\n<strong>Why <code>f_pos</code> is a pointer parameter</strong>: The kernel stores <code>f_pos</code> in <code>filp-&gt;f_pos</code>. But for <code>pread()</code> (positional read), the VFS passes a <em>different</em> offset than <code>filp-&gt;f_pos</code> â€” it passes the caller&#39;s requested offset directly, without modifying the file&#39;s stored position. By taking a <code>loff_t *f_pos</code> parameter, your handler works correctly for both <code>read()</code> and <code>pread()</code> without modification.\n<strong>The &quot;two-process independence&quot; property</strong>: If process A and process B both open <code>/dev/mydevice</code>, they get separate <code>struct file</code> instances, each with its own <code>f_pos</code>. Process A reading doesn&#39;t advance process B&#39;s position. This is the correct semantics â€” it mirrors how two processes reading the same regular file maintain independent positions.</li>\n</ul>\n<hr>\n<h2 id=\"the-complete-device-putting-it-all-together\">The Complete Device: Putting It All Together</h2>\n<p>Now let&#39;s write the full, complete driver. This is the production-quality reference you&#39;ll build and verify:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* mydevice.c â€” Character device driver with read/write, f_pos tracking */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/module.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/kernel.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/init.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/fs.h></span><span style=\"color:#6A737D\">           /* file_operations, alloc_chrdev_region */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/cdev.h></span><span style=\"color:#6A737D\">         /* cdev_init, cdev_add */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/device.h></span><span style=\"color:#6A737D\">       /* class_create, device_create */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/uaccess.h></span><span style=\"color:#6A737D\">      /* copy_to_user, copy_from_user */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/slab.h></span><span style=\"color:#6A737D\">         /* kmalloc, kfree */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/atomic.h></span><span style=\"color:#6A737D\">       /* atomic_t */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_LICENSE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"GPL\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_AUTHOR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Your Name &#x3C;you@example.com>\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_DESCRIPTION</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Character device driver: read/write with kernel buffer\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_VERSION</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"1.0\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* â”€â”€â”€ Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEVICE_NAME</span><span style=\"color:#9ECBFF\">     \"mydevice\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CLASS_NAME</span><span style=\"color:#9ECBFF\">      \"mydevice_class\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BUFFER_SIZE</span><span style=\"color:#79B8FF\">     4096</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* â”€â”€â”€ Module state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> dev_t</span><span style=\"color:#E1E4E8\">         dev_num;</span><span style=\"color:#6A737D\">           /* major + minor, set by alloc_chrdev_region */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> cdev   my_cdev;</span><span style=\"color:#6A737D\">           /* kernel char device structure              */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> class </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">my_class;</span><span style=\"color:#6A737D\">          /* device class for udev                     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> device </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">my_device;</span><span style=\"color:#6A737D\">        /* device object                             */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\">         *</span><span style=\"color:#E1E4E8\">kernel_buffer;</span><span style=\"color:#6A737D\">     /* 4KB buffer for data storage               */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#E1E4E8\">        buffer_used </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   /* bytes currently stored                    */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> atomic_t</span><span style=\"color:#E1E4E8\">      open_count  </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ATOMIC_INIT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* â”€â”€â”€ File Operations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydev_open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> inode </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    atomic_inc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydev: open (count now </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">           atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydev_release</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> inode </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    atomic_dec</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydev: release (count now </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">           atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydev_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                          size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">loff_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">f_pos</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_available;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> not_copied;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">f_pos </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> buffer_used)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   /* EOF */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes_available </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> buffer_used </span><span style=\"color:#F97583\">-</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">f_pos;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes_to_copy   </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> min</span><span style=\"color:#E1E4E8\">(count, bytes_available);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    not_copied </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> copy_to_user</span><span style=\"color:#E1E4E8\">(buf, kernel_buffer </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">f_pos, bytes_to_copy);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (not_copied </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">f_pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#E1E4E8\">)bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydev_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                           size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">loff_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">f_pos</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> space_available;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> not_copied;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    space_available </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BUFFER_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> buffer_used;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (space_available </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOSPC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes_to_copy </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> min</span><span style=\"color:#E1E4E8\">(count, space_available);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    not_copied </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> copy_from_user</span><span style=\"color:#E1E4E8\">(kernel_buffer </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> buffer_used, buf, bytes_to_copy);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (not_copied </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buffer_used </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#E1E4E8\">)bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> file_operations mydev_fops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .owner   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> THIS_MODULE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .open    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_open,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .release </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_release,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .read    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_read,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .write   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_write,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* â”€â”€â”€ Init / Exit â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Initialization uses goto-based error handling â€” the kernel idiom</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * for unwinding partial initialization in reverse order.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Order of init:  buffer â†’ chrdev_region â†’ cdev â†’ class â†’ device</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Order of cleanup (exit and error paths): reverse</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> __init </span><span style=\"color:#B392F0\">mydev_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* 1. Allocate kernel buffer */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    kernel_buffer </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kzalloc</span><span style=\"color:#E1E4E8\">(BUFFER_SIZE, GFP_KERNEL);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">kernel_buffer) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydev: failed to allocate buffer</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOMEM;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* 2. Reserve a character device number dynamically */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_chrdev_region</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_num, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, DEVICE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydev: alloc_chrdev_region failed: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ret);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> err_alloc_region;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydev: registered major=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> minor=</span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">           MAJOR</span><span style=\"color:#E1E4E8\">(dev_num), </span><span style=\"color:#B392F0\">MINOR</span><span style=\"color:#E1E4E8\">(dev_num));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* 3. Initialize and add the cdev */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cdev_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">my_cdev, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">mydev_fops);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    my_cdev.owner </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> THIS_MODULE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> cdev_add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">my_cdev, dev_num, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydev: cdev_add failed: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ret);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> err_cdev_add;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* 4. Create device class (appears in /sys/class/) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    my_class </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> class_create</span><span style=\"color:#E1E4E8\">(THIS_MODULE, CLASS_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">IS_ERR</span><span style=\"color:#E1E4E8\">(my_class)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> PTR_ERR</span><span style=\"color:#E1E4E8\">(my_class);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydev: class_create failed: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ret);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> err_class;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* 5. Create device â€” triggers udev to create /dev/mydevice */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    my_device </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> device_create</span><span style=\"color:#E1E4E8\">(my_class, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, dev_num, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, DEVICE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">IS_ERR</span><span style=\"color:#E1E4E8\">(my_device)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> PTR_ERR</span><span style=\"color:#E1E4E8\">(my_device);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydev: device_create failed: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ret);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> err_device;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydev: initialized â€” /dev/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> created</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, DEVICE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Error unwind â€” reverse order of init */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">err_device:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    class_destroy</span><span style=\"color:#E1E4E8\">(my_class);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">err_class:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cdev_del</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">my_cdev);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">err_cdev_add:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    unregister_chrdev_region</span><span style=\"color:#E1E4E8\">(dev_num, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">err_alloc_region:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kfree</span><span style=\"color:#E1E4E8\">(kernel_buffer);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#E1E4E8\"> __exit </span><span style=\"color:#B392F0\">mydev_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    device_destroy</span><span style=\"color:#E1E4E8\">(my_class, dev_num);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    class_destroy</span><span style=\"color:#E1E4E8\">(my_class);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cdev_del</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">my_cdev);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    unregister_chrdev_region</span><span style=\"color:#E1E4E8\">(dev_num, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kfree</span><span style=\"color:#E1E4E8\">(kernel_buffer);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydev: exited cleanly</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">module_init</span><span style=\"color:#E1E4E8\">(mydev_init);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">module_exit</span><span style=\"color:#E1E4E8\">(mydev_exit);</span></span></code></pre></div>\n<h3 id=\"the-goto-error-handling-pattern\">The Goto Error Handling Pattern</h3>\n<h2 id=\"notice-the-goto-labels-in-mydev_init-this-is-not-sloppy-code-it-is-the-canonical-kernel-idiom-for-error-handling-with-multiple-resources-the-structure-ensures-that-if-step-n-fails-steps-1-through-n-1-are-cleaned-up-in-reverse-order-without-this-a-failure-in-class_create-would-leak-the-cdev-and-device-number-the-alternative-nested-if-else-chains-produces-deeply-indented-hard-to-read-code-the-goto-pattern-keeps-the-success-path-reading-top-to-bottom-with-the-cleanup-code-separated-at-the-bottom-every-experienced-kernel-developer-uses-this-pattern-if-you-see-a-kernel-function-without-it-that-function-probably-has-a-resource-leak\">Notice the <code>goto</code> labels in <code>mydev_init</code>. This is not sloppy code â€” it is the <strong>canonical kernel idiom</strong> for error handling with multiple resources. The structure ensures that if step N fails, steps 1 through N-1 are cleaned up in reverse order. Without this, a failure in <code>class_create</code> would leak the cdev and device number.\nThe alternative â€” nested if-else chains â€” produces deeply indented, hard-to-read code. The goto pattern keeps the success path reading top-to-bottom, with the cleanup code separated at the bottom. Every experienced kernel developer uses this pattern. If you see a kernel function without it, that function probably has a resource leak.</h2>\n<h2 id=\"the-kbuild-makefile-for-this-module\">The Kbuild Makefile for This Module</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">makefile</span><pre class=\"arch-pre shiki-highlighted\"><code># Makefile\nobj-m += mydevice.o\nccflags-y := -Werror\nall:\n\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\nclean:\n\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean</code></pre></div>\n<hr>\n<h2 id=\"verification-the-echocat-round-trip\">Verification: The echo/cat Round Trip</h2>\n<p>Build, load, and verify:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Build</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">make</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Load</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> insmod</span><span style=\"color:#9ECBFF\"> mydevice.ko</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify device number and class</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">grep</span><span style=\"color:#9ECBFF\"> mydevice</span><span style=\"color:#9ECBFF\"> /proc/devices</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Example: 240 mydevice</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /dev/mydevice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># crw------- 1 root root 240, 0 Mar 1 12:00 /dev/mydevice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Write data (echo appends a newline, so \"hello\\n\" = 6 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"hello\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> sudo</span><span style=\"color:#9ECBFF\"> tee</span><span style=\"color:#9ECBFF\"> /dev/mydevice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Output: hello</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Read data back</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> cat</span><span style=\"color:#9ECBFF\"> /dev/mydevice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Output: hello</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify open_count via dmesg</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dmesg</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tail</span><span style=\"color:#79B8FF\"> -10</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [  ...] mydev: open (count now 1)       â† from tee's open</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [  ...] mydev: release (count now 0)    â† from tee's close</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [  ...] mydev: open (count now 1)       â† from cat's open</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [  ...] mydev: release (count now 0)    â† from cat's close</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Unload</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> rmmod</span><span style=\"color:#9ECBFF\"> mydevice</span></span></code></pre></div>\n<h2 id=\"why-does-cat-terminate-when-cat-opens-the-device-f_pos-starts-at-0-the-first-read-call-returns-quothellonquot-6-bytes-and-advances-f_pos-to-6-since-buffer_used-is-also-6-the-second-read-call-hits-f_pos-gt-buffer_used-and-returns-0-eof-cat-sees-eof-and-exits-why-does-a-second-cat-read-nothing-after-the-first-cat-finishes-buffer_used-is-still-6-but-f_pos-for-the-new-open-is-0-so-a-second-cat-would-read-quothellonquot-again-the-buffer-persists-until-overwritten-or-the-module-is-unloaded-this-is-the-intended-behavior-for-a-simple-device\"><strong>Why does <code>cat</code> terminate?</strong> When <code>cat</code> opens the device, <code>*f_pos</code> starts at 0. The first <code>read()</code> call returns &quot;hello\\n&quot; (6 bytes) and advances <code>*f_pos</code> to 6. Since <code>buffer_used</code> is also 6, the second <code>read()</code> call hits <code>*f_pos &gt;= buffer_used</code> and returns 0 (EOF). <code>cat</code> sees EOF and exits.\n<strong>Why does a second <code>cat</code> read nothing?</strong> After the first <code>cat</code> finishes, <code>buffer_used</code> is still 6, but <code>*f_pos</code> for the <em>new</em> open is 0. So a second <code>cat</code> would read &quot;hello\\n&quot; again. The buffer persists until overwritten or the module is unloaded. This is the intended behavior for a simple device.</h2>\n<h2 id=\"three-level-view-what-happens-during-echo-quothelloquot-gt-devmydevice\">Three-Level View: What Happens During <code>echo &quot;hello&quot; &gt; /dev/mydevice</code></h2>\n<h2 id=\"level-1-shelluserspace-the-shell-forks-execs-echo-which-writes-quothellonquot-6-bytes-to-stdout-the-shell-has-already-redirected-stdout-to-devmydevice-via-openquotdevmydevicequot-o_wronly-the-writefd-quothellonquot-6-syscall-fires-level-2-kernelvfs-sys_write-ksys_write-vfs_write-vfs-looks-up-the-struct-file-for-fd-retrieves-f-gtf_op-gtwrite-which-is-your-mydev_write-your-handler-runs-in-the-context-of-the-echo-process-copy_from_user-copies-the-6-bytes-from-the-echo-process39s-stack-where-quothellonquot-lives-into-kernel_buffer-the-exception-table-ensures-that-if-echo39s-mapping-disappears-mid-copy-the-kernel-recovers-with-efault-level-3-hardware-the-copy-involves-two-tlb-lookups-one-for-the-userspace-source-address-in-echo39s-page-tables-and-one-for-the-kernel-destination-address-in-the-direct-mapped-region-the-cpu39s-hardware-page-walker-traverses-the-page-table-hierarchy-for-the-user-address-the-6-bytes-fit-in-a-single-64-byte-cache-line-the-copy-itself-is-handled-by-optimized-cpu-instructions-in-the-copy_from_user-implementation-on-x86_64-this-uses-rep-movsb-or-simd-instructions-depending-on-size-the-kernel-buffer39s-cache-line-is-brought-into-l1l2-cache-dirty-it-will-be-evicted-to-dram-eventually-but-for-read-back-soon-after-it39s-likely-still-hot\"><strong>Level 1 â€” Shell/Userspace</strong>:\nThe shell forks, execs <code>echo</code>, which writes <code>&quot;hello\\n&quot;</code> (6 bytes) to stdout. The shell has already redirected stdout to <code>/dev/mydevice</code> via <code>open(&quot;/dev/mydevice&quot;, O_WRONLY)</code>. The <code>write(fd, &quot;hello\\n&quot;, 6)</code> syscall fires.\n<strong>Level 2 â€” Kernel/VFS</strong>:\n<code>sys_write</code> â†’ <code>ksys_write</code> â†’ <code>vfs_write</code>. VFS looks up the <code>struct file</code> for <code>fd</code>, retrieves <code>f-&gt;f_op-&gt;write</code>, which is your <code>mydev_write</code>. Your handler runs in the context of the <code>echo</code> process. <code>copy_from_user</code> copies the 6 bytes from the <code>echo</code> process&#39;s stack (where <code>&quot;hello\\n&quot;</code> lives) into <code>kernel_buffer</code>. The exception table ensures that if <code>echo</code>&#39;s mapping disappears mid-copy, the kernel recovers with <code>-EFAULT</code>.\n<strong>Level 3 â€” Hardware</strong>:\nThe copy involves two TLB lookups: one for the userspace source address (in <code>echo</code>&#39;s page tables) and one for the kernel destination address (in the direct-mapped region). The CPU&#39;s hardware page walker traverses the page table hierarchy for the user address. The 6 bytes fit in a single 64-byte cache line. The copy itself is handled by optimized CPU instructions in the <code>copy_from_user</code> implementation â€” on x86_64, this uses <code>rep movsb</code> or SIMD instructions depending on size. The kernel buffer&#39;s cache line is brought into L1/L2 cache dirty; it will be evicted to DRAM eventually but for read-back soon after, it&#39;s likely still hot.</h2>\n<h2 id=\"common-pitfalls-and-their-consequences\">Common Pitfalls and Their Consequences</h2>\n<h3 id=\"direct-dereference-of-user-pointer\">Direct Dereference of User Pointer</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG â€” crashes kernel on bad pointer */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">memcpy</span><span style=\"color:#E1E4E8\">(kernel_buffer, buf, count);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* RIGHT â€” recovers gracefully */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">not_copied </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> copy_from_user</span><span style=\"color:#E1E4E8\">(kernel_buffer, buf, count);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (not_copied) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span></code></pre></div>\n<p>The compiler won&#39;t catch this. The static checker Sparse will (<code>make C=1</code> during build). At runtime, a malicious or buggy program passing a bad pointer will kernel-panic without <code>copy_from_user</code>.</p>\n<h3 id=\"returning-bytes-written-without-checking-copy_from_user-return\">Returning Bytes Written Without Checking copy_from_user Return</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG â€” ignores partial copy */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">copy_from_user</span><span style=\"color:#E1E4E8\">(kernel_buffer, buf, count);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> count;</span><span style=\"color:#6A737D\">   /* wrong: may have only copied count - not_copied bytes */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* RIGHT */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">not_copied </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> copy_from_user</span><span style=\"color:#E1E4E8\">(kernel_buffer, buf, count);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (not_copied) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> count;</span></span></code></pre></div>\n<p><code>copy_from_user</code> returns the number of bytes <em>not</em> copied â€” zero means full success. Treating a non-zero return as success tells the caller &quot;I wrote N bytes&quot; when you actually wrote fewer.</p>\n<h3 id=\"not-returning-0-at-eof-infinite-read-loop\">Not Returning 0 at EOF â€” Infinite read Loop</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG â€” cat loops forever */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydev_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                          size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">loff_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">f_pos</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy_to_user</span><span style=\"color:#E1E4E8\">(buf, kernel_buffer, buffer_used);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> buffer_used;</span><span style=\"color:#6A737D\">  /* never returns 0, cat never terminates */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* RIGHT â€” returns 0 when f_pos reaches end */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">f_pos </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> buffer_used)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n<p>This is the single most common beginner read handler bug. If you ever find <code>cat /dev/yourdevice</code> hanging, this is why.</p>\n<h3 id=\"not-updating-f_pos-after-read\">Not Updating <code>*f_pos</code> After Read</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG â€” f_pos never advances, infinite loop of same data */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">f_pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   /* or just not updating it */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* RIGHT */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">f_pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> bytes_to_copy;</span></span></code></pre></div>\n<p>Without advancing <code>f_pos</code>, every read call returns the same data from the same offset. <code>cat</code> sees a non-zero return value forever.</p>\n<h3 id=\"forgetting-cleanup-in-reverse-order\">Forgetting Cleanup in Reverse Order</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG â€” unregister before destroy leaves dangling references */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">unregister_chrdev_region</span><span style=\"color:#E1E4E8\">(dev_num, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  /* removes device number */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">device_destroy</span><span style=\"color:#E1E4E8\">(my_class, dev_num);</span><span style=\"color:#6A737D\">     /* tries to use the now-gone number */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* RIGHT â€” destroy in reverse order of creation */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">device_destroy</span><span style=\"color:#E1E4E8\">(my_class, dev_num);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">class_destroy</span><span style=\"color:#E1E4E8\">(my_class);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cdev_del</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">my_cdev</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">unregister_chrdev_region</span><span style=\"color:#E1E4E8\">(dev_num, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kfree</span><span style=\"color:#E1E4E8\">(kernel_buffer);</span></span></code></pre></div>\n<p>Out-of-order cleanup causes use-after-free in kernel data structures. The kernel may not crash immediately â€” the corruption may surface later as a mysterious oops in unrelated code.</p>\n<h3 id=\"missing-owner-this_module-in-file_operations\">Missing <code>.owner = THIS_MODULE</code> in file_operations</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG â€” module can be unloaded while device is open */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> file_operations mydev_fops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .open    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_open,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .read    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_read,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* .owner missing */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* RIGHT */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> file_operations mydev_fops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .owner   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> THIS_MODULE,</span><span style=\"color:#6A737D\">  /* prevents rmmod while files are open */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .open    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_open,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .read    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_read,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n<h2 id=\"without-owner-rmmod-succeeds-while-a-process-has-the-device-open-the-next-read-jumps-to-a-now-freed-code-address-instant-kernel-panic\">Without <code>.owner</code>, <code>rmmod</code> succeeds while a process has the device open. The next <code>read()</code> jumps to a now-freed code address â€” instant kernel panic.</h2>\n<h2 id=\"knowledge-cascade-what-you39ve-just-unlocked\">Knowledge Cascade: What You&#39;ve Just Unlocked</h2>\n<h2 id=\"-vfs-dispatch-pattern-interfaces-everywhere-cross-domain-the-file_operations-vtable-you-just-filled-in-is-the-kernel39s-implementation-of-dynamic-dispatch-the-same-pattern-as-c-virtual-methods-go-interfaces-and-rust-trait-objects-the-call-f-gtf_op-gtreadfilp-buf-count-f_pos-is-structurally-identical-to-a-c-virtual-void-read-call-that-dispatches-through-a-vtable-pointer-when-you-next-see-a-go-interface-dispatch-a-rust-dyn-trait-or-a-java-abstract-class-you39re-looking-at-the-same-solution-to-the-same-problem-dispatch-to-the-right-implementation-at-runtime-without-knowing-the-concrete-type-at-compile-time-the-kernel39s-vtable-approach-is-the-primordial-form-f_pos-and-preadpwrite-atomicity-same-domain-forward-the-fact-that-f_pos-is-per-struct-file-not-per-inode-is-why-preadfd-buf-n-offset-and-pwrite-exist-pread-passes-a-separate-offset-without-modifying-filp-gtf_pos-allowing-concurrent-reads-from-different-offsets-without-races-databases-use-pread-exclusively-for-this-reason-sqlite-postgresql-rocksdb-all-call-pread-into-their-data-files-the-character-device-mechanism-you-just-built-is-the-same-mechanism-enabling-atomic-positioned-io-at-scale-udev-hotplug-universal-device-discovery-cross-domain-device_create-sending-a-uevent-is-the-same-mechanism-that-fires-when-you-plug-in-a-usb-drive-and-devsdb-appears-or-when-the-kernel-probes-a-pcie-device-at-boot-and-devnvme0n1-materializes-android39s-vold-volume-daemon-systemd-udevd-and-the-kernel39s-own-kobject_uevent-are-all-operating-the-same-infrastructure-you39ve-just-written-code-that-participates-in-linux39s-universal-device-discovery-protocol-exception-table-speculative-execution-safety-net-same-domain-the-ex_table-mechanism-behind-copy_from_user-is-conceptually-related-to-how-cpus-handle-speculative-execution-faults-execute-optimistically-recover-if-something-goes-wrong-the-x86-gp-and-pf-exception-handlers-consult-the-exception-table-the-same-way-a-cpu39s-microcode-consults-its-own-internal-fault-tables-more-practically-this-same-mechanism-powers-get_user-put_user-and-the-__copy_-family-understanding-it-means-you-understand-the-safety-foundation-of-the-entire-kernel-userspace-boundary-kmalloc-to-slab-allocator-to-memory-pressure-forward-the-kzalloc4096-gfp_kernel-call-you-made-is-trivial-here-but-it-connects-to-one-of-the-most-important-kernel-subsystems-the-memory-reclaim-path-under-memory-pressure-gfp_kernel-allocations-can-block-while-kswapd-runs-pages-are-writeback-to-swap-slab-caches-are-shrunk-and-the-oom-killer-considers-victims-in-milestone-3-when-you-add-an-ioctl-for-runtime-buffer-resize-you39ll-call-kfree-and-kmalloc-while-the-device-is-live-a-perfect-opportunity-to-think-about-what-happens-if-the-resize-allocation-fails-at-a-moment-when-memory-is-under-pressure-this-is-devnull-structural-equivalence-devnull39s-write-handler-is-return-count-accept-all-bytes-store-nothing-its-read-handler-is-return-0-always-eof-your-device-is-more-capable-devzero39s-read-handler-fills-the-user-buffer-with-zeros-via-clear_user-a-copy_to_user-variant-for-zero-fill-devrandom-and-devurandom-read-from-an-entropy-pool-the-architecture-is-identical-to-what-you-just-built-the-only-difference-is-what-the-read-and-write-handlers-actually-do-with-the-data\"><strong>â†’ VFS Dispatch Pattern = Interfaces Everywhere (cross-domain)</strong>:\nThe <code>file_operations</code> vtable you just filled in is the kernel&#39;s implementation of dynamic dispatch â€” the same pattern as C++ virtual methods, Go interfaces, and Rust trait objects. The call <code>f-&gt;f_op-&gt;read(filp, buf, count, f_pos)</code> is structurally identical to a C++ <code>virtual void read()</code> call that dispatches through a vtable pointer. When you next see a Go interface dispatch, a Rust <code>dyn Trait</code>, or a Java abstract class, you&#39;re looking at the same solution to the same problem: <em>dispatch to the right implementation at runtime without knowing the concrete type at compile time</em>. The kernel&#39;s vtable approach is the primordial form.\n<strong>â†’ f_pos and pread/pwrite Atomicity (same domain, forward)</strong>:\nThe fact that <code>f_pos</code> is per-<code>struct file</code> (not per-inode) is <em>why</em> <code>pread(fd, buf, n, offset)</code> and <code>pwrite</code> exist. <code>pread</code> passes a separate offset without modifying <code>filp-&gt;f_pos</code>, allowing concurrent reads from different offsets without races â€” databases use <code>pread</code> exclusively for this reason. SQLite, PostgreSQL, RocksDB all call <code>pread</code> into their data files. The character device mechanism you just built is the same mechanism enabling atomic positioned I/O at scale.\n<strong>â†’ udev Hotplug = Universal Device Discovery (cross-domain)</strong>:\n<code>device_create()</code> sending a uevent is the same mechanism that fires when you plug in a USB drive and <code>/dev/sdb</code> appears, or when the kernel probes a PCIe device at boot and <code>/dev/nvme0n1</code> materializes. Android&#39;s <code>vold</code> (volume daemon), systemd-udevd, and the kernel&#39;s own <code>kobject_uevent</code> are all operating the same infrastructure. You&#39;ve just written code that participates in Linux&#39;s universal device discovery protocol.\n<strong>â†’ Exception Table = Speculative Execution Safety Net (same domain)</strong>:\nThe <code>.ex_table</code> mechanism behind <code>copy_from_user</code> is conceptually related to how CPUs handle speculative execution faults: execute optimistically, recover if something goes wrong. The x86 <code>#GP</code> and <code>#PF</code> exception handlers consult the exception table the same way a CPU&#39;s microcode consults its own internal fault tables. More practically: this same mechanism powers <code>get_user()</code>, <code>put_user()</code>, and the <code>__copy_*</code> family â€” understanding it means you understand the safety foundation of the entire kernel-userspace boundary.\n<strong>â†’ kmalloc to Slab Allocator to Memory Pressure (forward)</strong>:\nThe <code>kzalloc(4096, GFP_KERNEL)</code> call you made is trivial here, but it connects to one of the most important kernel subsystems: the memory reclaim path. Under memory pressure, <code>GFP_KERNEL</code> allocations can block while <code>kswapd</code> runs, pages are writeback to swap, slab caches are shrunk, and the OOM killer considers victims. In Milestone 3, when you add an ioctl for runtime buffer resize, you&#39;ll call <code>kfree</code> and <code>kmalloc</code> while the device is live â€” a perfect opportunity to think about what happens if the resize allocation fails at a moment when memory is under pressure.\n<strong>â†’ This Is /dev/null (structural equivalence)</strong>:\n<code>/dev/null</code>&#39;s write handler is <code>return count</code> â€” accept all bytes, store nothing. Its read handler is <code>return 0</code> â€” always EOF. Your device is more capable. <code>/dev/zero</code>&#39;s read handler fills the user buffer with zeros via <code>clear_user()</code> (a <code>copy_to_user</code> variant for zero-fill). <code>/dev/random</code> and <code>/dev/urandom</code> read from an entropy pool. The architecture is identical to what you just built â€” the only difference is what the read and write handlers actually do with the data.</h2>\n<h2 id=\"acceptance-criteria-checkpoint\">Acceptance Criteria Checkpoint</h2>\n<p>Before moving to Milestone 3, verify every item:</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> <code>make</code> completes without warnings (<code>ccflags-y := -Werror</code> active)</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>sudo insmod mydevice.ko</code> succeeds; <code>dmesg | tail</code> shows <code>registered major=&lt;N&gt; minor=0</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>grep mydevice /proc/devices</code> shows the major number</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>ls -la /dev/mydevice</code> shows the device node (created by udev, no manual <code>mknod</code>)</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>ls /sys/class/mydevice_class/</code> shows the device entry</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>echo &quot;hello&quot; | sudo tee /dev/mydevice</code> succeeds with output <code>hello</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>sudo cat /dev/mydevice</code> outputs <code>hello</code> and terminates (no infinite loop)</li>\n<li><input disabled=\"\" type=\"checkbox\"> A second <code>sudo cat /dev/mydevice</code> also outputs <code>hello</code> (buffer persists between opens)</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>dmesg</code> shows open count increment and decrement for each <code>tee</code> and <code>cat</code> invocation</li>\n<li><input disabled=\"\" type=\"checkbox\"> Test with a malicious pointer: verify <code>-EFAULT</code> is returned and kernel does not panic</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>sudo rmmod mydevice</code> succeeds; <code>dmesg</code> shows clean exit message</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>/dev/mydevice</code> is removed after rmmod (udev responds to the remove uevent)</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>make C=1</code> (Sparse check) produces no warnings about <code>__user</code> annotation violations</li>\n</ul>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-kernel-module-m3 -->\n<h1 id=\"milestone-3-ioctl-and-proc-interface\">Milestone 3: ioctl and /proc Interface</h1>\n<h2 id=\"the-revelation-ioctl-is-a-binary-protocol-not-a-switch-statement\">The Revelation: ioctl Is a Binary Protocol, Not a Switch Statement</h2>\n<p>You&#39;ve built a character device that can read and write data. Now a process wants to <em>control</em> that device â€” resize its buffer, clear its contents, query its statistics. Your first instinct: add another write command with a special prefix. Write <code>&quot;RESIZE:8192\\n&quot;</code> to the device and parse it in the write handler.\nThis approach is used in production. Redis parses text commands over a socket. HTTP parses method strings. But it has a cost: you&#39;re multiplexing control and data through the same channel, which means your write handler now needs to answer &quot;is this a data write or a control command?&quot; before it can do anything. You&#39;ve contaminated the data plane with control logic.\nUnix solved this problem in 1971 with <code>ioctl</code> â€” <em>input/output control</em>. The name is old; the insight is permanent. <code>ioctl</code> is a <strong>separate system call</strong> specifically for out-of-band device control, completely independent of the read/write data path. When a process calls <code>ioctl(fd, MYDEV_RESIZE, &amp;new_size)</code>, it bypasses the VFS data path entirely and routes to your <code>unlocked_ioctl</code> handler with a structured command number and an argument.\nHere&#39;s where developers go wrong: they treat the command number as an arbitrary integer. They write <code>#define CMD_RESIZE 1</code>, <code>#define CMD_CLEAR 2</code>, and implement a <code>switch(cmd)</code> statement. This works â€” until it doesn&#39;t.\n<strong>The problem with raw integers</strong>: <code>ioctl(fd, 1, &amp;new_size)</code> â€” is <code>1</code> a resize command for your driver? Or is it a terminal control command meant for the TTY layer? The kernel&#39;s ioctl dispatch has no way to know. If your device wraps another device (a common pattern), the wrong driver might handle the wrong commands. Worse, <code>strace</code> will display your ioctl calls as <code>ioctl(3, 0x1, 0x7fff...)</code> â€” completely opaque.\nThe solution is that <strong>ioctl command numbers are encoded 32-bit values</strong> â€” a binary protocol, not an enum. Every bit field has meaning:</p>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiag-m3-ioctl-command-encoding.svg\" alt=\"ioctl Command Number Bit Encoding\"></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code> 31      16 15     8 7       2 1 0\n â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”\n â”‚   NR    â”‚  TYPE  â”‚  SIZE   â”‚DIRâ”‚\n â”‚(cmd seq)â”‚(magic) â”‚(arg sz) â”‚   â”‚\n â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”˜\n  bits 31:16  15:8    13:2     1:0\nDIR (bits 1:0):\n  00 = _IO   (no argument)\n  01 = _IOW  (userspace â†’ kernel, write to kernel)\n  10 = _IOR  (kernel â†’ userspace, read from kernel)\n  11 = _IOWR (bidirectional)\nTYPE (bits 15:8): your unique magic number (e.g., 'M' = 0x4D)\nNR (bits 31:16): sequential command number (0, 1, 2, ...)\nSIZE (bits 13:2): sizeof(argument type), max 256 bytes</code></pre></div>\n<p>[[EXPLAIN:ioctl-command-number-encoding-(_iow/_ior-direction,-type,-nr,-size)|ioctl command number encoding (_IOW/_IOR direction, type, nr, size)]]\nThe four macros that construct these values:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">_IO</span><span style=\"color:#E1E4E8\">(type, nr)</span><span style=\"color:#6A737D\">              /* no argument */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">_IOW</span><span style=\"color:#E1E4E8\">(type, nr, argtype)</span><span style=\"color:#6A737D\">    /* userspace writes TO kernel: ioctl(fd, cmd, &#x26;data) passes data in */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">_IOR</span><span style=\"color:#E1E4E8\">(type, nr, argtype)</span><span style=\"color:#6A737D\">    /* kernel writes TO userspace: ioctl(fd, cmd, &#x26;data) fills data out */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">_IOWR</span><span style=\"color:#E1E4E8\">(type, nr, argtype)</span><span style=\"color:#6A737D\">   /* bidirectional */</span></span></code></pre></div>\n<p>Each macro encodes the direction bits, your magic number, the command sequence number, and <code>sizeof(argtype)</code> into a single 32-bit constant. <code>_IOW(&#39;M&#39;, 0, int)</code> and <code>_IOW(&#39;N&#39;, 0, int)</code> produce <em>different</em> 32-bit values â€” a command from a different driver with a different magic number will never accidentally match yours.\nThis encoding exists because:</p>\n<ol>\n<li><strong><code>strace</code> decodes it symbolically</strong>: with the right header, <code>strace</code> translates <code>ioctl(3, MYDEV_RESIZE, 0x7fff12340)</code> instead of <code>ioctl(3, 0xc0044d00, 0x7fff12340)</code>.</li>\n<li><strong>The kernel can validate direction and size</strong>: before your handler runs, the ioctl infrastructure knows whether the argument is incoming data, outgoing data, or both â€” and how large it is.</li>\n<li><strong>Collision prevention</strong>: your magic number namespaces your commands. <code>Documentation/userspace-api/ioctl/ioctl-number.rst</code> in the kernel tree is a registry of allocated magic numbers. Pick one that&#39;s not taken.\nNow let&#39;s build it.</li>\n</ol>\n<hr>\n<h2 id=\"the-architecture-control-plane-meets-data-plane\">The Architecture: Control Plane Meets Data Plane</h2>\n<p>Before writing code, look at the full picture of what you&#39;re adding to your existing driver.</p>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiag-m3-ioctl-vs-read-write.svg\" alt=\"Control Plane vs Data Plane: read/write vs ioctl\"></p>\n<p>Your device now has two distinct interfaces:</p>\n<ul>\n<li><strong>Data plane</strong> (<code>read</code>/<code>write</code>): streams of bytes through the kernel buffer â€” the pipe</li>\n<li><strong>Control plane</strong> (<code>ioctl</code>): structured commands that change device behavior â€” the remote control\nThis separation isn&#39;t arbitrary. It mirrors the same pattern across the entire systems stack:<blockquote>\n<p>TCP has a data stream (<code>send</code>/<code>recv</code>) and out-of-band control (socket options via <code>setsockopt</code>). HTTP has a body and headers. gRPC has streaming RPCs and unary control calls. Your character device has <code>read</code>/<code>write</code> and <code>ioctl</code>. The architectural pattern is identical: keep structured control commands out of the data stream so both can be reasoned about independently.\nThe <code>/proc</code> entry you&#39;re adding is a third interface â€” <strong>introspection</strong>. It&#39;s read-only, always human-readable, and doesn&#39;t affect device state. It&#39;s the observability window into your driver&#39;s internals.</p>\n</blockquote>\n</li>\n</ul>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiag-m3-ioctl-dispatch-flow.svg\" alt=\"ioctl Dispatch: From Userspace ioctl() to Your Handler\"></p>\n<hr>\n<h2 id=\"the-shared-header-one-definition-two-worlds\">The Shared Header: One Definition, Two Worlds</h2>\n<p>The fundamental challenge of ioctl design is that the command definitions must be <strong>identical</strong> in kernel code and userspace code. If the kernel defines <code>MYDEV_RESIZE</code> as <code>0xc0044d00</code> and userspace computes <code>0xc0084d00</code> (because someone changed the argument size), the ioctl call silently fails â€” or worse, passes but transfers the wrong number of bytes.\nThe solution: a single header file included by both.</p>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiag-m3-shared-header.svg\" alt=\"Shared Header: One Definition, Two Worlds\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* mydevice_ioctl.h â€” shared between kernel module and userspace programs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This file defines the ioctl interface for mydevice. It is the ABI contract:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * once userspace programs link against these definitions, changing them</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * breaks binary compatibility.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Include guards prevent double-inclusion in both environments.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> MYDEVICE_IOCTL_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOCTL_H</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Guard against kernel-only headers when this file is included by userspace */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifdef</span><span style=\"color:#B392F0\"> __KERNEL__</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#  include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/ioctl.h></span><span style=\"color:#6A737D\">     /* _IOW, _IOR, _IOWR macros */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#  include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/types.h></span><span style=\"color:#6A737D\">     /* __u32, __u64, etc. */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#else</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#  include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/ioctl.h></span><span style=\"color:#6A737D\">       /* userspace ioctl definitions */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#  include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   typedef</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> __u32;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   typedef</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#E1E4E8\"> __u64;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Magic number: uniquely identifies this driver's ioctl namespace.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * 'M' (0x4D) is used here for illustration.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * In production: check Documentation/userspace-api/ioctl/ioctl-number.rst</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * and pick an unregistered value.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEV_MAGIC</span><span style=\"color:#9ECBFF\">  'M'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Argument struct for status query.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This struct is part of the ABI: fields CANNOT be reordered or removed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * without breaking userspace programs that compiled against this header.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydev_status {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    __u32 buffer_size;</span><span style=\"color:#6A737D\">    /* total allocated buffer size in bytes */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    __u32 bytes_used;</span><span style=\"color:#6A737D\">     /* bytes currently stored in buffer     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    __u32 open_count;</span><span style=\"color:#6A737D\">     /* number of processes with device open */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    __u32 read_count;</span><span style=\"color:#6A737D\">     /* total number of successful reads     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    __u32 write_count;</span><span style=\"color:#6A737D\">    /* total number of successful writes    */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    __u32 _reserved;</span><span style=\"color:#6A737D\">      /* explicit padding for future use      */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * ioctl command definitions.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * MYDEV_CLEAR:  _IO  â€” no argument; clears buffer contents</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * MYDEV_RESIZE: _IOW â€” userspace sends new size (uint32); kernel resizes buffer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * MYDEV_STATUS: _IOR â€” kernel fills struct mydev_status; userspace reads it</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEV_CLEAR</span><span style=\"color:#B392F0\">   _IO</span><span style=\"color:#E1E4E8\">(MYDEV_MAGIC,  </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEV_RESIZE</span><span style=\"color:#B392F0\">  _IOW</span><span style=\"color:#E1E4E8\">(MYDEV_MAGIC, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, __u32)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEV_STATUS</span><span style=\"color:#B392F0\">  _IOR</span><span style=\"color:#E1E4E8\">(MYDEV_MAGIC, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydev_status)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> /* MYDEVICE_IOCTL_H */</span></span></code></pre></div>\n<h2 id=\"study-this-header-carefully-every-design-choice-is-deliberate-__u32-instead-of-uint32_t-or-unsigned-int-on-different-architectures-and-compilation-environments-unsigned-int-might-be-16-or-32-bits-__u32-is-guaranteed-32-bit-everywhere-in-linux-kernel-headers-in-userspace-we-typedef-it-to-uint32_t-from-ltstdinthgt-which-has-the-same-guarantee-the-header-conditionally-provides-whichever-definition-is-appropriate-__kernel__-guard-the-kbuild-system-defines-__kernel__-when-compiling-kernel-code-userspace-compilers-don39t-define-it-this-lets-you-use-one-file-in-both-contexts-the-kernel-side-gets-ltlinuxioctlhgt-kernel-macros-the-userspace-side-gets-ltsysioctlhgt-posix-definitions-the-underlying-math-is-the-same-the-macros-produce-identical-bit-patterns-_reserved-in-mydev_status-abi-stability-practice-if-you-later-add-a-field-you-can-replace-_reserved-instead-of-growing-the-struct-which-would-break-the-size-encoding-in-_ior-explicit-padding-documents-that-you-thought-about-future-extensibility-the-abi-contract-once-mydev_status-is-released-and-userspace-programs-link-against-it-the-layout-of-this-struct-is-frozen-the-kernel39s-guarantee-of-stable-userspace-abi-means-that-a-userspace-binary-compiled-against-this-header-in-2026-must-still-work-with-a-kernel-driver-in-2036-even-if-the-driver39s-internal-representation-changes-this-is-why-the-kernel39s-internal-structs-change-freely-they39re-not-abi-but-the-ioctl-structs-in-public-headers-do-not-this-is-the-same-concern-that-makes-protocol-buffer-field-numbers-immutable-and-that-governs-json-api-versioning\">Study this header carefully. Every design choice is deliberate:\n<strong><code>__u32</code> instead of <code>uint32_t</code> or <code>unsigned int</code></strong>: On different architectures and compilation environments, <code>unsigned int</code> might be 16 or 32 bits. <code>__u32</code> is guaranteed 32-bit everywhere in Linux kernel headers. In userspace, we typedef it to <code>uint32_t</code> from <code>&lt;stdint.h&gt;</code> which has the same guarantee. The header conditionally provides whichever definition is appropriate.\n<strong><code>__KERNEL__</code> guard</strong>: The Kbuild system defines <code>__KERNEL__</code> when compiling kernel code. Userspace compilers don&#39;t define it. This lets you use one file in both contexts: the kernel side gets <code>&lt;linux/ioctl.h&gt;</code> (kernel macros), the userspace side gets <code>&lt;sys/ioctl.h&gt;</code> (POSIX definitions). The underlying math is the same â€” the macros produce identical bit patterns.\n<strong><code>_reserved</code> in <code>mydev_status</code></strong>: ABI stability practice. If you later add a field, you can replace <code>_reserved</code> instead of growing the struct (which would break the size encoding in <code>_IOR</code>). Explicit padding documents that you thought about future extensibility.\n<strong>The ABI contract</strong>: Once <code>mydev_status</code> is released and userspace programs link against it, the <strong>layout of this struct is frozen</strong>. The kernel&#39;s guarantee of stable userspace ABI means that a userspace binary compiled against this header in 2026 must still work with a kernel driver in 2036 â€” even if the driver&#39;s internal representation changes. This is why the kernel&#39;s internal structs change freely (they&#39;re not ABI) but the ioctl structs in public headers do not. This is the same concern that makes Protocol Buffer field numbers immutable and that governs JSON API versioning.</h2>\n<h2 id=\"implementing-unlocked_ioctl\">Implementing <code>unlocked_ioctl</code></h2>\n<p>Add the ioctl handler to your driver. First, add the new fields to your device state:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Additional state in the kernel module â€” add to module-level globals */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> atomic_t</span><span style=\"color:#E1E4E8\"> read_count  </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ATOMIC_INIT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> atomic_t</span><span style=\"color:#E1E4E8\"> write_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ATOMIC_INIT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<p>Now the ioctl handler:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"mydevice_ioctl.h\"</span><span style=\"color:#6A737D\">   /* shared definitions */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/uaccess.h></span><span style=\"color:#6A737D\">    /* copy_from_user, copy_to_user */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/slab.h></span><span style=\"color:#6A737D\">       /* kmalloc, kfree */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> long</span><span style=\"color:#B392F0\"> mydev_ioctl</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> int</span><span style=\"color:#FFAB70\"> cmd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> arg</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Validate the magic number before processing any command.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * _IOC_TYPE(cmd) extracts bits [15:8] â€” the magic number.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * If it doesn't match MYDEV_MAGIC, this command wasn't meant for us.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Return -ENOTTY: \"inappropriate ioctl for device\" â€” the POSIX standard</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * error for an unsupported ioctl command. NOT -EINVAL, NOT -ENOENT.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Tools like strace rely on -ENOTTY to identify unsupported commands.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">_IOC_TYPE</span><span style=\"color:#E1E4E8\">(cmd) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> MYDEV_MAGIC)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTTY;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Validate the command number is within our range.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * _IOC_NR(cmd) extracts bits [31:16] â€” the sequence number.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * We've defined commands 0, 1, 2; reject anything above 2.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">_IOC_NR</span><span style=\"color:#E1E4E8\">(cmd) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTTY;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> (cmd) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* â”€â”€ MYDEV_CLEAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MYDEV_CLEAR:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * _IO: no argument. The 'arg' parameter is unused.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Zero out the buffer contents and reset the usage counter.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * memset is safe here: kernel_buffer is a kernel pointer,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * memset operates only in kernel address space.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memset</span><span style=\"color:#E1E4E8\">(kernel_buffer, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, buffer_size_bytes);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buffer_used </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydev: ioctl CLEAR â€” buffer cleared</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* â”€â”€ MYDEV_RESIZE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MYDEV_RESIZE: {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * _IOW: userspace writes a __u32 to the kernel.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * 'arg' is the userspace address of the __u32 new size value.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * We must use copy_from_user to read it safely.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        __u32 new_size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">new_buffer;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * copy_from_user(kernel_dst, user_src, n)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Copies n bytes from userspace address 'arg' into kernel variable 'new_size'.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Returns bytes NOT copied; non-zero means fault â†’ -EFAULT.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">copy_from_user</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">new_size, (__u32 __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)arg, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(__u32)))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Validate the requested size */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (new_size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> new_size </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 20</span><span style=\"color:#E1E4E8\">)) {</span><span style=\"color:#6A737D\">  /* 0 to 1MB limit */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printk</span><span style=\"color:#E1E4E8\">(KERN_WARNING </span><span style=\"color:#9ECBFF\">\"mydev: ioctl RESIZE: invalid size </span><span style=\"color:#79B8FF\">%u\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, new_size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Allocate the new buffer before freeing the old one.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * This is the \"allocate-then-swap\" pattern: if the new allocation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * fails, we still have the old buffer intact â€” the device keeps working.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        new_buffer </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kzalloc</span><span style=\"color:#E1E4E8\">(new_size, GFP_KERNEL);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">new_buffer)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOMEM;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * If new_size is smaller than current content, we must truncate.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Copy only min(buffer_used, new_size) bytes to preserve existing data.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (buffer_used </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> new_size) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printk</span><span style=\"color:#E1E4E8\">(KERN_WARNING </span><span style=\"color:#9ECBFF\">\"mydev: RESIZE truncating </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes to </span><span style=\"color:#79B8FF\">%u\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                   buffer_used, new_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            buffer_used </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memcpy</span><span style=\"color:#E1E4E8\">(new_buffer, kernel_buffer, buffer_used);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Swap: free old, install new */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kfree</span><span style=\"color:#E1E4E8\">(kernel_buffer);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        kernel_buffer     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_buffer;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buffer_size_bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_size;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydev: ioctl RESIZE â€” buffer resized to </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, new_size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* â”€â”€ MYDEV_STATUS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MYDEV_STATUS: {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * _IOR: kernel writes a struct mydev_status TO userspace.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * 'arg' is the userspace address where we should write the struct.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        struct</span><span style=\"color:#E1E4E8\"> mydev_status status;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Fill the status struct from current device state */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        status.buffer_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (u32)buffer_size_bytes;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        status.bytes_used  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (u32)buffer_used;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        status.open_count  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (u32)</span><span style=\"color:#B392F0\">atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        status.read_count  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (u32)</span><span style=\"color:#B392F0\">atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">read_count);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        status.write_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (u32)</span><span style=\"color:#B392F0\">atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">write_count);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        status._reserved   </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * copy_to_user(user_dst, kernel_src, n)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Copies n bytes from kernel struct 'status' to userspace address 'arg'.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Returns bytes NOT copied; non-zero â†’ -EFAULT.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">copy_to_user</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydev_status __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)arg,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         &#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydev_status)))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * This should not be reached if the magic number and NR checks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * above are correct. But defensive programming demands a default.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTTY;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Register this handler in your <code>file_operations</code> struct:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> file_operations mydev_fops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .owner          </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> THIS_MODULE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .open           </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_open,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .release        </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_release,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .read           </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_read,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .write          </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_write,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .unlocked_ioctl </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_ioctl,</span><span style=\"color:#6A737D\">   /* â† add this */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n<h3 id=\"why-unlocked_ioctl-not-ioctl\">Why <code>unlocked_ioctl</code>, not <code>ioctl</code>?</h3>\n<p>If you look at older kernel code (pre-2.6.36), you&#39;ll see a <code>.ioctl</code> field in <code>file_operations</code>. This has been removed. The historical <code>.ioctl</code> handler was called with the <strong>Big Kernel Lock</strong> (BKL) held â€” a global mutex that serialized all ioctl calls across the entire kernel. The BKL was a performance disaster removed in Linux 2.6.39.\n<code>unlocked_ioctl</code> means &quot;your ioctl handler, without any BKL.&quot; You are responsible for your own locking (which we&#39;ll add in Milestone 4). For a single-buffer device, the operations in our three commands are simple enough that races are benign for now â€” but we&#39;ll tighten this in the concurrency milestone.\nThere&#39;s also <code>.compat_ioctl</code> â€” called when a 32-bit process runs on a 64-bit kernel and makes an ioctl call. Pointer sizes differ between 32-bit and 64-bit, so struct layouts may differ. For our <code>mydev_status</code> (all <code>__u32</code> fields), layout is identical across architectures. If you had 64-bit fields or pointers in your struct, you&#39;d need <code>.compat_ioctl</code> to handle the translation.</p>\n<h3 id=\"the-enotty-contract\">The <code>-ENOTTY</code> Contract</h3>\n<h2 id=\"the-choice-of-enotty-for-unknown-commands-is-not-arbitrary-it39s-the-posix-mandated-error-for-quotthis-ioctl-is-not-applicable-to-this-file-descriptorquot-the-name-comes-from-quotnot-a-ttyquot-the-first-ioctl-commands-were-tty-specific-so-the-error-for-quotwrong-device-typequot-was-named-for-the-original-use-case-today-it-means-quotthis-device-doesn39t-support-that-commandquot-using-einval-instead-as-many-drivers-do-incorrectly-is-technically-wrong-per-posix-and-confuses-tools-that-inspect-ioctl-return-codes\">The choice of <code>-ENOTTY</code> for unknown commands is not arbitrary â€” it&#39;s the POSIX-mandated error for &quot;this ioctl is not applicable to this file descriptor.&quot; The name comes from &quot;not a TTY&quot; â€” the first <code>ioctl</code> commands were TTY-specific, so the error for &quot;wrong device type&quot; was named for the original use case. Today it means &quot;this device doesn&#39;t support that command.&quot; Using <code>-EINVAL</code> instead (as many drivers do incorrectly) is technically wrong per POSIX and confuses tools that inspect ioctl return codes.</h2>\n<h2 id=\"validating-direction-and-size-before-your-handler-runs\">Validating Direction and Size Before Your Handler Runs</h2>\n<p>The <code>_IOC_DIR</code> and <code>_IOC_SIZE</code> fields in the encoded command number enable a useful pre-validation pattern. Before dispatching to your <code>switch</code>, you can verify that the userspace pointer is valid for the expected access:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Optional but recommended: verify userspace pointer accessibility</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * based on the encoded direction and size.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * access_ok(addr, size) returns true if the address range [addr, addr+size)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * is a valid userspace address. It does NOT guarantee the pages are present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * (copy_from_user handles faults), but it catches obvious errors like</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * kernel addresses passed as userspace pointers.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">_IOC_DIR</span><span style=\"color:#E1E4E8\">(cmd) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> _IOC_READ) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Kernel will READ from user â€” user buffer must be writable by us */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">access_ok</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)arg, </span><span style=\"color:#B392F0\">_IOC_SIZE</span><span style=\"color:#E1E4E8\">(cmd)))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">_IOC_DIR</span><span style=\"color:#E1E4E8\">(cmd) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> _IOC_WRITE) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Kernel will WRITE from user â€” user buffer must be readable by us */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">access_ok</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)arg, </span><span style=\"color:#B392F0\">_IOC_SIZE</span><span style=\"color:#E1E4E8\">(cmd)))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>Note on direction naming confusion</strong>: The <code>_IOC_READ</code> and <code>_IOC_WRITE</code> bits in the command number describe the <strong>userspace perspective</strong>. <code>_IOC_READ</code> means &quot;userspace is reading from the kernel&quot; â€” which means the kernel writes to the user buffer. This is the _IOR direction. <code>_IOC_WRITE</code> means &quot;userspace is writing to the kernel&quot; â€” the _IOW direction. This reversal from the kernel&#39;s perspective trips up many developers. When in doubt, think from the userspace side.\n<code>access_ok()</code> is a fast, architecture-specific check that verifies the address doesn&#39;t fall in kernel space. On x86_64, it checks that <code>arg + size &lt;= TASK_SIZE_MAX</code> (the upper bound of user address space). Note that modern kernels (5.x+) have simplified <code>access_ok</code> â€” it no longer takes a type parameter (it was <code>access_ok(VERIFY_READ, addr, size)</code> in older kernels). Update your code for the kernel version you&#39;re targeting.</p>\n</blockquote>\n<hr>\n<h2 id=\"the-proc-entry-runtime-introspection\">The <code>/proc</code> Entry: Runtime Introspection</h2>\n<p>While ioctl gives processes <em>control</em> over the device, <code>/proc</code> gives <em>humans</em> (and monitoring tools) a window into the device&#39;s runtime state. The key insight:</p>\n<blockquote>\n<p><code>/proc</code> entries don&#39;t exist on disk. When you <code>cat /proc/mydevice</code>, the kernel calls your function to generate the content on-the-fly. The file system is a user interface metaphor, not actual storage.\nThis is the virtual filesystem trick: the same VFS that dispatches <code>open</code>/<code>read</code> on real files dispatches them on <code>/proc</code> entries â€” but instead of reading from disk, it calls a kernel function. <code>cat /proc/cpuinfo</code> doesn&#39;t read a file; it calls a function that queries each CPU&#39;s registers and formats the result as text. You&#39;re now building the same mechanism.</p>\n</blockquote>\n<h3 id=\"the-problem-with-raw-proc-callbacks\">The Problem with Raw proc Callbacks</h3>\n<p>Before <code>seq_file</code> existed, drivers implemented a <code>.read_proc</code> callback that was handed a <code>char *page</code> buffer and had to write into it. This was simple â€” until the data exceeded one page (4KB). A <code>/proc</code> entry with more than 4KB of content had to implement complex offset tracking manually. Most drivers got it wrong: they&#39;d return the same content on every read (infinite loop) or miss content on reads that started mid-page.</p>\n<blockquote>\n<p><strong>ðŸ”‘ Foundation: seq_file abstraction and iterator pattern</strong></p>\n<h3 id=\"what-it-is\">What it IS</h3>\n<p>The <code>seq_file</code> API is a standard Linux kernel abstraction designed to simplify the creation of virtual files (typically found in <code>/proc</code> or <code>/sys</code>) that output sequences of data. When a user-space program reads a file, the kernel must provide data in chunks. If the data is a long listâ€”such as a list of all active network connections or loaded modulesâ€”managing the buffer offsets, multi-page reads, and partial transfers manually is complex and error-prone.</p>\n</blockquote>\n<p>The <code>seq_file</code> interface uses the <strong>Iterator Pattern</strong>. It hides the &quot;plumbing&quot; of the filesystem (offsets, buffer sizes, and <code>read()</code> syscall mechanics) and asks the developer to provide only four functional callbacks:</p>\n<ol>\n<li><strong><code>start</code></strong>: Move to the beginning of the sequence or a specific position.</li>\n<li><strong><code>next</code></strong>: Move to the next item in the sequence.</li>\n<li><strong><code>show</code></strong>: Format the current item into the output buffer (usually using <code>seq_printf</code>).</li>\n<li><strong><code>stop</code></strong>: Clean up after the sequence is finished.</li>\n</ol>\n<h3 id=\"why-the-reader-needs-it-right-now\">WHY the reader needs it right now</h3>\n<p>If you are writing a kernel module that needs to &quot;leak&quot; information to user spaceâ€”like a list of custom device states or a debugging logâ€”you shouldn&#39;t use the raw <code>file_operations.read</code> handler. Doing so requires you to track how many bytes the user has already read and handle cases where a single record is split across two separate <code>read()</code> calls.</p>\n<p>By using <code>seq_file</code>, you focus entirely on your data structure (e.g., a linked list or an array). The kernel handles the &quot;bookkeeping&quot;: it manages a temporary buffer, calls your <code>show</code> function until the buffer is full, stops, and resumes exactly where it left off when the user asks for more data. It ensures that even if a user-space tool like <code>cat</code> reads your 50KB list in 4KB chunks, the data remains consistent and the code remains simple.</p>\n<h3 id=\"one-key-insight-or-mental-model\">ONE key insight or mental model</h3>\n<p><strong>The &quot;Stateful Cursor&quot; Model.</strong> \nThink of <code>seq_file</code> as a cursor moving through a database. You don&#39;t tell the kernel &quot;give me bytes 4096 to 8192 of this file.&quot; Instead, you tell the kernel, &quot;I am currently at item #50 in my list; show it, then increment the cursor to #51.&quot; </p>\n<p>The <code>seq_file</code> layer translates the user&#39;s <strong>byte-based requests</strong> (e.g., &quot;I want the next 1KB&quot;) into <strong>object-based iterations</strong> (e.g., &quot;Give me the next three items in your list&quot;). This decoupling ensures that you never have to worry about a &quot;partial print&quot; cutting an integer or a string in half between two system calls.</p>\n<p><code>seq_file</code> solves this properly with an <strong>iterator pattern</strong>: your driver implements four functions (<code>start</code>, <code>next</code>, <code>stop</code>, <code>show</code>) that the seq_file infrastructure calls in a controlled loop, handling buffering, offset tracking, and partial reads correctly.</p>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiag-m3-seq-file-iteration.svg\" alt=\"seq_file: The Iterator Behind /proc Reads\"></p>\n<p>For simple single-record <code>/proc</code> entries (like device statistics), you use an even simpler helper that wraps seq_file into a single-function interface.</p>\n<h3 id=\"implementation\">Implementation</h3>\n<p>Add the proc implementation to your module:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/proc_fs.h></span><span style=\"color:#6A737D\">     /* proc_create, proc_remove */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/seq_file.h></span><span style=\"color:#6A737D\">    /* seq_file, seq_printf, single_open */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PROC_NAME</span><span style=\"color:#9ECBFF\"> \"mydevice\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * seq_show: called by the seq_file infrastructure to generate content.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * For a single-record /proc entry (all data fits in one logical \"show\"),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * single_open() wraps this into a minimal seq_file iterator:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   start() returns a non-NULL pointer (signaling \"data exists\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   show()  calls this function to write content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   next()  returns NULL (only one record)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   stop()  does nothing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * seq_printf(m, fmt, ...) writes formatted text into the seq_file buffer.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * It handles buffer management, overflow detection, and partial reads.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Never use sprintf or printk inside a seq_show function.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydev_proc_show</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> seq_file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">m</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">v</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    seq_printf</span><span style=\"color:#E1E4E8\">(m, </span><span style=\"color:#9ECBFF\">\"=== mydevice statistics ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    seq_printf</span><span style=\"color:#E1E4E8\">(m, </span><span style=\"color:#9ECBFF\">\"buffer_size:  </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, buffer_size_bytes);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    seq_printf</span><span style=\"color:#E1E4E8\">(m, </span><span style=\"color:#9ECBFF\">\"bytes_used:   </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, buffer_used);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    seq_printf</span><span style=\"color:#E1E4E8\">(m, </span><span style=\"color:#9ECBFF\">\"open_count:   </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,       </span><span style=\"color:#B392F0\">atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    seq_printf</span><span style=\"color:#E1E4E8\">(m, </span><span style=\"color:#9ECBFF\">\"read_count:   </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,       </span><span style=\"color:#B392F0\">atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">read_count));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    seq_printf</span><span style=\"color:#E1E4E8\">(m, </span><span style=\"color:#9ECBFF\">\"write_count:  </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,       </span><span style=\"color:#B392F0\">atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">write_count));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * mydev_proc_open: called when a process opens /proc/mydevice.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * single_open(file, show_fn, data) sets up the seq_file machinery</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * with a one-shot iterator that calls mydev_proc_show exactly once.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * The 'data' pointer is available as m->private inside show_fn.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydev_proc_open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> inode </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">file</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> single_open</span><span style=\"color:#E1E4E8\">(file, mydev_proc_show, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * proc_fops: file operations for the /proc entry.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * We implement open with our wrapper, and delegate read, llseek,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * and release to the seq_file infrastructure. These seq_* functions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * know how to handle partial reads, seeks, and cleanup for seq_file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> proc_ops mydev_proc_ops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .proc_open    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_proc_open,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .proc_read    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> seq_read,</span><span style=\"color:#6A737D\">      /* seq_file's read handler */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .proc_lseek   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> seq_lseek,</span><span style=\"color:#6A737D\">     /* seq_file's lseek handler */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .proc_release </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> single_release,</span><span style=\"color:#6A737D\">/* cleans up single_open state */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> proc_dir_entry </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">proc_entry;</span></span></code></pre></div>\n<blockquote>\n<p><strong><code>proc_ops</code> vs <code>file_operations</code></strong>: In kernels 5.6+, <code>/proc</code> entries use <code>struct proc_ops</code> instead of <code>struct file_operations</code>. The fields are similar (<code>proc_open</code>, <code>proc_read</code>, etc.) but <code>proc_ops</code> omits some fields that don&#39;t apply to proc entries and uses different defaults. If your target kernel is older than 5.6, use <code>file_operations</code> with a <code>.owner = THIS_MODULE</code> field.\nRegister and remove the proc entry in your init/exit:</p>\n</blockquote>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* In mydev_init, after device_create succeeds: */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">proc_entry </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> proc_create</span><span style=\"color:#E1E4E8\">(PROC_NAME, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">444</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">mydev_proc_ops</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*                        ^          ^     ^      ^</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *                        name       mode  parent  ops</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * mode 0444: world-readable, nobody can write</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * parent NULL: create in /proc/ root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns NULL on failure (not IS_ERR â€” different error convention!) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">proc_entry) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydev: proc_create failed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOMEM;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    goto</span><span style=\"color:#E1E4E8\"> err_proc;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydev: /proc/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> created</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, PROC_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Add to error unwind: */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">err_proc:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    device_destroy</span><span style=\"color:#E1E4E8\">(my_class, dev_num);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ... rest of error chain ... */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* In mydev_exit, before device_destroy: */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">proc_remove</span><span style=\"color:#E1E4E8\">(proc_entry);</span></span></code></pre></div>\n<p>Note the different error-checking convention for <code>proc_create</code>: it returns <code>NULL</code> on failure, not an <code>ERR_PTR()</code> value. You check <code>if (!proc_entry)</code>, not <code>if (IS_ERR(proc_entry))</code>. The kernel API is not perfectly consistent â€” this is one of those inconsistencies you have to memorize.\nNow wire up the read/write counters in your existing handlers:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydev_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                          size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">loff_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">f_pos</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ... existing read logic ... */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* After a successful copy_to_user: */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    atomic_inc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">read_count);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#E1E4E8\">)bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydev_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                           size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">loff_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">f_pos</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ... existing write logic ... */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* After a successful copy_from_user: */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    atomic_inc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">write_count);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#E1E4E8\">)bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"how-seq_file-actually-works-under-the-hood\">How seq_file Actually Works Under the Hood</h2>\n<p>Understanding <code>seq_file</code> internally is worth a few minutes â€” it explains why it exists and why rolling your own offset tracking is a bad idea.\nWhen <code>cat /proc/mydevice</code> calls <code>read(fd, buf, 65536)</code>, the kernel calls your <code>proc_read</code> handler â€” which is <code>seq_read</code> from the seq_file library. Here&#39;s what seq_read does internally:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>seq_read(filp, user_buf, count, f_pos):\n  1. If seq_file buffer is empty (first call or after exhaustion):\n       call start(m, &amp;m-&gt;index)   â†’ get first record (or NULL if done)\n       if not NULL:\n         call show(m, record)     â†’ write content into m-&gt;buf\n         call next(m, record, &amp;m-&gt;index)  â†’ advance to next record\n         loop until done or m-&gt;buf is full\n       call stop(m, record)\n  2. Copy min(m-&gt;buf used, count) bytes â†’ copy_to_user(user_buf, m-&gt;buf, ...)\n  3. If m-&gt;buf has remaining content: update f_pos, return bytes copied\n  4. If m-&gt;buf exhausted: return 0 (EOF)</code></pre></div>\n<h2 id=\"for-single_open-the-iterator-is-trivially-simple-start-returns-a-non-null-dummy-pointer-once-next-returns-null-immediately-stop-does-nothing-the-show-function-yours-mydev_proc_show-is-called-exactly-once-and-writes-all-content-seq_read-handles-paging-the-output-into-userspace-even-if-your-output-exceeds-the-kernel39s-internal-buffer-it-calls-startshownextstop-again-from-where-it-left-off-this-is-why-seq_printf-is-safe-to-call-with-arbitrarily-large-output-the-seq_file-infrastructure-handles-the-case-where-your-content-doesn39t-fit-in-one-read-call-by-maintaining-position-state-internally-a-hand-rolled-proc-callback-that-writes-to-a-fixed-page-buffer-and-returns-would-truncate-silently\">For <code>single_open</code>, the iterator is trivially simple: <code>start</code> returns a non-NULL dummy pointer once, <code>next</code> returns NULL immediately, <code>stop</code> does nothing. The <code>show</code> function (yours: <code>mydev_proc_show</code>) is called exactly once and writes all content. <code>seq_read</code> handles paging the output into userspace even if your output exceeds the kernel&#39;s internal buffer â€” it calls <code>start</code>/<code>show</code>/<code>next</code>/<code>stop</code> again from where it left off.\nThis is why <code>seq_printf</code> is safe to call with arbitrarily large output: the seq_file infrastructure handles the case where your content doesn&#39;t fit in one <code>read()</code> call by maintaining position state internally. A hand-rolled proc callback that writes to a fixed <code>page</code> buffer and returns would truncate silently.</h2>\n<h2 id=\"the-complete-updated-module\">The Complete Updated Module</h2>\n<p>Here is the full module combining Milestone 2&#39;s character device with Milestone 3&#39;s ioctl and proc additions. This is the reference implementation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* mydevice.c â€” Character device with ioctl and /proc interface */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/module.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/kernel.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/init.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/fs.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/cdev.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/device.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/uaccess.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/slab.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/atomic.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/proc_fs.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/seq_file.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"mydevice_ioctl.h\"</span><span style=\"color:#6A737D\">    /* shared ioctl definitions */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_LICENSE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"GPL\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_AUTHOR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Your Name &#x3C;you@example.com>\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_DESCRIPTION</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Character device: read/write, ioctl control, /proc introspection\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_VERSION</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"2.0\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* â”€â”€â”€ Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEVICE_NAME</span><span style=\"color:#9ECBFF\">  \"mydevice\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CLASS_NAME</span><span style=\"color:#9ECBFF\">   \"mydevice_class\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PROC_NAME</span><span style=\"color:#9ECBFF\">    \"mydevice\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* â”€â”€â”€ Device State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> dev_t</span><span style=\"color:#E1E4E8\">          dev_num;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> cdev    my_cdev;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> class  </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">my_class;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> device </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">my_device;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> proc_dir_entry </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">proc_entry;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\">   *</span><span style=\"color:#E1E4E8\">kernel_buffer;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#E1E4E8\">  buffer_size_bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 4096</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#E1E4E8\">  buffer_used       </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> atomic_t</span><span style=\"color:#E1E4E8\"> open_count  </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ATOMIC_INIT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> atomic_t</span><span style=\"color:#E1E4E8\"> read_count  </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ATOMIC_INIT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> atomic_t</span><span style=\"color:#E1E4E8\"> write_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ATOMIC_INIT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* â”€â”€â”€ File Operations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydev_open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> inode </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    atomic_inc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydev: open (count=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydev_release</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> inode </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    atomic_dec</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydev: release (count=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydev_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                          size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">loff_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">f_pos</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_available, bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> not_copied;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">f_pos </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> buffer_used)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* EOF */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes_available </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> buffer_used </span><span style=\"color:#F97583\">-</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">f_pos;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes_to_copy   </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> min</span><span style=\"color:#E1E4E8\">(count, bytes_available);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    not_copied </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> copy_to_user</span><span style=\"color:#E1E4E8\">(buf, kernel_buffer </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">f_pos, bytes_to_copy);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (not_copied)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">f_pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    atomic_inc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">read_count);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#E1E4E8\">)bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydev_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                           size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">loff_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">f_pos</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> space_available, bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> not_copied;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    space_available </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> buffer_size_bytes </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> buffer_used;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (space_available </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOSPC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes_to_copy </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> min</span><span style=\"color:#E1E4E8\">(count, space_available);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    not_copied </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> copy_from_user</span><span style=\"color:#E1E4E8\">(kernel_buffer </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> buffer_used, buf, bytes_to_copy);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (not_copied)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buffer_used </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    atomic_inc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">write_count);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#E1E4E8\">)bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> long</span><span style=\"color:#B392F0\"> mydev_ioctl</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> int</span><span style=\"color:#FFAB70\"> cmd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> arg</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">_IOC_TYPE</span><span style=\"color:#E1E4E8\">(cmd) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> MYDEV_MAGIC)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTTY;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">_IOC_NR</span><span style=\"color:#E1E4E8\">(cmd) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTTY;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> (cmd) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MYDEV_CLEAR:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memset</span><span style=\"color:#E1E4E8\">(kernel_buffer, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, buffer_size_bytes);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buffer_used </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydev: ioctl CLEAR</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MYDEV_RESIZE: {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        __u32 new_size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">new_buffer;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">copy_from_user</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">new_size, (__u32 __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)arg, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(__u32)))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (new_size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> new_size </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 20</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        new_buffer </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kzalloc</span><span style=\"color:#E1E4E8\">(new_size, GFP_KERNEL);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">new_buffer)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOMEM;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (buffer_used </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> new_size)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            buffer_used </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_size;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memcpy</span><span style=\"color:#E1E4E8\">(new_buffer, kernel_buffer, buffer_used);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kfree</span><span style=\"color:#E1E4E8\">(kernel_buffer);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        kernel_buffer     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_buffer;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buffer_size_bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_size;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydev: ioctl RESIZE to </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, new_size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MYDEV_STATUS: {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        struct</span><span style=\"color:#E1E4E8\"> mydev_status status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            .buffer_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (__u32)buffer_size_bytes,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            .bytes_used  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (__u32)buffer_used,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            .open_count  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (__u32)</span><span style=\"color:#B392F0\">atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            .read_count  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (__u32)</span><span style=\"color:#B392F0\">atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">read_count),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            .write_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (__u32)</span><span style=\"color:#B392F0\">atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">write_count),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ._reserved   </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">copy_to_user</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydev_status __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)arg,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         &#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(status)))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTTY;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* â”€â”€â”€ /proc Interface â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydev_proc_show</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> seq_file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">m</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">v</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    seq_printf</span><span style=\"color:#E1E4E8\">(m, </span><span style=\"color:#9ECBFF\">\"=== mydevice statistics ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    seq_printf</span><span style=\"color:#E1E4E8\">(m, </span><span style=\"color:#9ECBFF\">\"buffer_size:  </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,   buffer_size_bytes);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    seq_printf</span><span style=\"color:#E1E4E8\">(m, </span><span style=\"color:#9ECBFF\">\"bytes_used:   </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,   buffer_used);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    seq_printf</span><span style=\"color:#E1E4E8\">(m, </span><span style=\"color:#9ECBFF\">\"open_count:   </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,           </span><span style=\"color:#B392F0\">atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    seq_printf</span><span style=\"color:#E1E4E8\">(m, </span><span style=\"color:#9ECBFF\">\"read_count:   </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,           </span><span style=\"color:#B392F0\">atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">read_count));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    seq_printf</span><span style=\"color:#E1E4E8\">(m, </span><span style=\"color:#9ECBFF\">\"write_count:  </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,           </span><span style=\"color:#B392F0\">atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">write_count));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydev_proc_open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> inode </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">file</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> single_open</span><span style=\"color:#E1E4E8\">(file, mydev_proc_show, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> proc_ops mydev_proc_ops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .proc_open    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_proc_open,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .proc_read    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> seq_read,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .proc_lseek   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> seq_lseek,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .proc_release </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> single_release,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* â”€â”€â”€ file_operations table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> file_operations mydev_fops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .owner          </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> THIS_MODULE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .open           </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_open,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .release        </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_release,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .read           </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_read,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .write          </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_write,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .unlocked_ioctl </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_ioctl,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* â”€â”€â”€ Init / Exit â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> __init </span><span style=\"color:#B392F0\">mydev_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    kernel_buffer </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kzalloc</span><span style=\"color:#E1E4E8\">(buffer_size_bytes, GFP_KERNEL);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">kernel_buffer) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOMEM;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_chrdev_region</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_num, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, DEVICE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydev: alloc_chrdev_region failed: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ret);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> err_region;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cdev_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">my_cdev, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">mydev_fops);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    my_cdev.owner </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> THIS_MODULE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> cdev_add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">my_cdev, dev_num, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydev: cdev_add failed: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ret);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> err_cdev;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    my_class </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> class_create</span><span style=\"color:#E1E4E8\">(THIS_MODULE, CLASS_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">IS_ERR</span><span style=\"color:#E1E4E8\">(my_class)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> PTR_ERR</span><span style=\"color:#E1E4E8\">(my_class);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> err_class;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    my_device </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> device_create</span><span style=\"color:#E1E4E8\">(my_class, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, dev_num, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, DEVICE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">IS_ERR</span><span style=\"color:#E1E4E8\">(my_device)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> PTR_ERR</span><span style=\"color:#E1E4E8\">(my_device);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> err_device;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc_entry </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> proc_create</span><span style=\"color:#E1E4E8\">(PROC_NAME, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">444</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">mydev_proc_ops);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">proc_entry) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOMEM;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydev: proc_create failed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> err_proc;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydev: initialized â€” /dev/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> and /proc/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> created</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           DEVICE_NAME, PROC_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">err_proc:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    device_destroy</span><span style=\"color:#E1E4E8\">(my_class, dev_num);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">err_device:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    class_destroy</span><span style=\"color:#E1E4E8\">(my_class);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">err_class:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cdev_del</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">my_cdev);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">err_cdev:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    unregister_chrdev_region</span><span style=\"color:#E1E4E8\">(dev_num, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">err_region:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kfree</span><span style=\"color:#E1E4E8\">(kernel_buffer);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#E1E4E8\"> __exit </span><span style=\"color:#B392F0\">mydev_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    proc_remove</span><span style=\"color:#E1E4E8\">(proc_entry);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    device_destroy</span><span style=\"color:#E1E4E8\">(my_class, dev_num);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    class_destroy</span><span style=\"color:#E1E4E8\">(my_class);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cdev_del</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">my_cdev);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    unregister_chrdev_region</span><span style=\"color:#E1E4E8\">(dev_num, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kfree</span><span style=\"color:#E1E4E8\">(kernel_buffer);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydev: exited cleanly</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">module_init</span><span style=\"color:#E1E4E8\">(mydev_init);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">module_exit</span><span style=\"color:#E1E4E8\">(mydev_exit);</span></span></code></pre></div>\n<hr>\n<h2 id=\"the-userspace-test-program\">The Userspace Test Program</h2>\n<p>The test program lives in userspace but includes the shared header. This is the duality that makes the shared header design essential:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* test_mydevice.c â€” Userspace test for ioctl and /proc interfaces */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;fcntl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/ioctl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Include the shared header. The __KERNEL__ guard is NOT defined by</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * the userspace compiler (gcc/clang), so this pulls in sys/ioctl.h</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * and stdint.h on the userspace side.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"mydevice_ioctl.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEVICE_PATH</span><span style=\"color:#9ECBFF\"> \"/dev/mydevice\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PROC_PATH</span><span style=\"color:#9ECBFF\">   \"/proc/mydevice\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> print_separator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">label</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">â”€â”€â”€â”€ </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> â”€â”€â”€â”€</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, label);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> read_proc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FILE </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">f </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fopen</span><span style=\"color:#E1E4E8\">(PROC_PATH, </span><span style=\"color:#9ECBFF\">\"r\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">f) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"fopen /proc/mydevice\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Content of </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, PROC_PATH);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">fgets</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(line), f))</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, line);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fclose</span><span style=\"color:#E1E4E8\">(f);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd, ret;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Open the device */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(DEVICE_PATH, O_RDWR);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"open \"</span><span style=\"color:#E1E4E8\"> DEVICE_PATH);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> EXIT_FAILURE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Opened </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> (fd=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, DEVICE_PATH, fd);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* â”€â”€ Test 1: Write some data, check status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    print_separator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Test 1: Write and STATUS ioctl\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">msg </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"Hello from userspace!\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> write</span><span style=\"color:#E1E4E8\">(fd, msg, </span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(msg));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"write\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> out;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Wrote </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> bytes: </span><span style=\"color:#79B8FF\">\\\"%s\\\"\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ret, msg);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> mydev_status status;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * MYDEV_STATUS is _IOR: kernel writes status TO us.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * We pass a pointer to our local struct; ioctl fills it.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ioctl</span><span style=\"color:#E1E4E8\">(fd, MYDEV_STATUS, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ioctl MYDEV_STATUS\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> out;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Status: buffer_size=</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">, bytes_used=</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">, open_count=</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">, \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">           \"reads=</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">, writes=</span><span style=\"color:#79B8FF\">%u\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           status.buffer_size, status.bytes_used, status.open_count,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           status.read_count, status.write_count);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* â”€â”€ Test 2: CLEAR ioctl â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    print_separator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Test 2: CLEAR ioctl\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ioctl</span><span style=\"color:#E1E4E8\">(fd, MYDEV_CLEAR);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ioctl MYDEV_CLEAR\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> out;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Buffer cleared.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ioctl</span><span style=\"color:#E1E4E8\">(fd, MYDEV_STATUS, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ioctl MYDEV_STATUS\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">goto</span><span style=\"color:#E1E4E8\"> out; }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"After clear: bytes_used=</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> (expected 0)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, status.bytes_used);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* â”€â”€ Test 3: RESIZE ioctl â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    print_separator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Test 3: RESIZE ioctl\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    __u32 new_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 8192</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * MYDEV_RESIZE is _IOW: we write new_size TO the kernel.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Pass pointer to new_size; ioctl copies it into the kernel.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ioctl</span><span style=\"color:#E1E4E8\">(fd, MYDEV_RESIZE, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">new_size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ioctl MYDEV_RESIZE\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> out;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Resized buffer to </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> bytes.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, new_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ioctl</span><span style=\"color:#E1E4E8\">(fd, MYDEV_STATUS, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ioctl MYDEV_STATUS\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">goto</span><span style=\"color:#E1E4E8\"> out; }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"After resize: buffer_size=</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> (expected 8192)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, status.buffer_size);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* â”€â”€ Test 4: Invalid ioctl returns -ENOTTY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    print_separator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Test 4: Unknown ioctl â†’ ENOTTY\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ioctl</span><span style=\"color:#E1E4E8\">(fd, </span><span style=\"color:#B392F0\">_IO</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Z'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">99</span><span style=\"color:#E1E4E8\">));</span><span style=\"color:#6A737D\">  /* wrong magic number, unknown command */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ENOTTY)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PASS: unknown ioctl returned ENOTTY (errno=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, errno);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"FAIL: expected ENOTTY, got ret=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> errno=</span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ret, errno);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* â”€â”€ Test 5: Read /proc entry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    print_separator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Test 5: /proc entry\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    read_proc</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">out:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> EXIT_FAILURE </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> EXIT_SUCCESS;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Compile the test program with the shared header accessible:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Compile: note we include the current directory for the shared header</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -Wall</span><span style=\"color:#79B8FF\"> -Werror</span><span style=\"color:#79B8FF\"> -I.</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> test_mydevice</span><span style=\"color:#9ECBFF\"> test_mydevice.c</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Or with a Makefile target:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># test: test_mydevice.c mydevice_ioctl.h</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># \tgcc -Wall -Werror -I. -o test_mydevice test_mydevice.c</span></span></code></pre></div>\n<p>Run the full sequence:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Build module</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">make</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Load</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> insmod</span><span style=\"color:#9ECBFF\"> mydevice.ko</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run tests (requires root for device access, or set device permissions)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./test_mydevice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check /proc directly</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/mydevice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify strace decodes our ioctl (requires header in include path)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> strace</span><span style=\"color:#9ECBFF\"> ./test_mydevice</span><span style=\"color:#F97583\"> 2>&#x26;1</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> ioctl</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Unload</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> rmmod</span><span style=\"color:#9ECBFF\"> mydevice</span></span></code></pre></div>\n<p>Expected <code>strace</code> output for the ioctl calls (with the header visible to strace â€” usually automatic if symbols match):</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ioctl(3, MYDEV_STATUS, 0x7fff...) = 0\nioctl(3, MYDEV_CLEAR) = 0\nioctl(3, MYDEV_RESIZE, 0x7fff...) = 0</code></pre></div>\n<hr>\n<h2 id=\"three-level-view-what-happens-during-ioctlfd-mydev_status-ampstatus\">Three-Level View: What Happens During <code>ioctl(fd, MYDEV_STATUS, &amp;status)</code></h2>\n<h2 id=\"level-1-userspace-your-test-program-calls-ioctlfd-mydev_status-ampstatus-the-c-library-wraps-this-as-the-ioctl2-syscall-the-cmd-argument-is-the-32-bit-encoded-value-produced-by-_ior39m39-2-struct-mydev_status-approximately-0x80184d02-directionread2-size24-bytes-type39m39-nr2-the-arg-is-the-stack-address-of-status-level-2-kernelvfs-sys_ioctl-do_vfs_ioctl-checks-if-cmd-is-a-known-vfs-level-command-like-fionread-or-fioclex-it39s-not-calls-vfs_ioctl-filp-gtf_op-gtunlocked_ioctlfilp-cmd-arg-your-mydev_ioctl-your-handler-reads-open_count-read_count-write_count-from-atomic_t-variables-fills-struct-mydev_status-on-the-kernel-stack-and-calls-copy_to_user-the-copy-places-the-struct-into-the-userspace-stack-frame-level-3-hardware-the-copy_to_user-for-a-24-byte-struct-is-a-fast-path-on-x86_64-the-struct-fits-in-three-cache-lines-24-bytes-lt-64-bytes-one-cache-line-in-fact-the-cpu-executes-the-copy-with-a-few-mov-instructions-and-potential-rep-movsb-for-safety-the-userspace-page-is-likely-hot-in-l1l2-cache-since-the-test-program-just-passed-its-address-the-atomic_read-calls-generate-mov-instructions-with-appropriate-memory-barriers-atomic_read-on-x86-is-just-a-regular-load-x8639s-memory-model-provides-the-necessary-ordering-guarantees-without-explicit-barrier-instructions-in-most-cases-the-total-cost-maybe-200ns-dominated-by-the-syscall-overhead-100ns-and-cache-accesses-not-the-copy-itself\"><strong>Level 1 â€” Userspace</strong>:\nYour test program calls <code>ioctl(fd, MYDEV_STATUS, &amp;status)</code>. The C library wraps this as the <code>ioctl(2)</code> syscall. The <code>cmd</code> argument is the 32-bit encoded value produced by <code>_IOR(&#39;M&#39;, 2, struct mydev_status)</code> â€” approximately <code>0x80184d02</code> (direction=read=2, size=24 bytes, type=&#39;M&#39;, nr=2). The <code>arg</code> is the stack address of <code>status</code>.\n<strong>Level 2 â€” Kernel/VFS</strong>:\n<code>sys_ioctl</code> â†’ <code>do_vfs_ioctl</code> â†’ checks if <code>cmd</code> is a known VFS-level command (like <code>FIONREAD</code> or <code>FIOCLEX</code>) â€” it&#39;s not â€” â†’ calls <code>vfs_ioctl</code> â†’ <code>filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg)</code> â†’ your <code>mydev_ioctl</code>. Your handler reads <code>open_count</code>, <code>read_count</code>, <code>write_count</code> from <code>atomic_t</code> variables, fills <code>struct mydev_status</code> on the kernel stack, and calls <code>copy_to_user</code>. The copy places the struct into the userspace stack frame.\n<strong>Level 3 â€” Hardware</strong>:\nThe <code>copy_to_user</code> for a 24-byte struct is a fast path. On x86_64, the struct fits in three cache lines (24 bytes &lt; 64 bytes = one cache line, in fact). The CPU executes the copy with a few <code>mov</code> instructions and potential <code>rep movsb</code> for safety. The userspace page is likely hot in L1/L2 cache since the test program just passed its address. The <code>atomic_read</code> calls generate <code>mov</code> instructions with appropriate memory barriers â€” <code>atomic_read</code> on x86 is just a regular load (x86&#39;s memory model provides the necessary ordering guarantees without explicit barrier instructions in most cases). The total cost: maybe 200ns, dominated by the syscall overhead (~100ns) and cache accesses, not the copy itself.</h2>\n<h2 id=\"hardware-soul-the-ioctl-path39s-cache-footprint\">Hardware Soul: The ioctl Path&#39;s Cache Footprint</h2>\n<p>When your ioctl handler runs, consider what memory it touches:</p>\n<ul>\n<li><strong><code>kernel_buffer</code> pointer</strong>: one word in the global data section â€” L1 hot after the first access</li>\n<li><strong><code>buffer_size_bytes</code>, <code>buffer_used</code></strong>: adjacent <code>size_t</code> values in BSS â€” two cache lines apart at most, likely in the same 64-byte cache line if laid out consecutively by the compiler</li>\n<li><strong><code>open_count</code>, <code>read_count</code>, <code>write_count</code></strong>: three <code>atomic_t</code> values (each a 4-byte <code>int</code>). If they&#39;re adjacent in memory, they share a cache line â€” 12 bytes total, fits in one 64-byte line. <strong>Critical</strong>: if multiple CPUs atomically increment these counters from different cores, each <code>atomic_inc</code> requires exclusive cache line ownership (the MESI cache coherency protocol&#39;s &quot;M&quot; (Modified) state). This is cache line bouncing â€” the line has to transfer between CPU caches on each write. For simple counters this is acceptable. For high-throughput code (thousands of operations per second), you&#39;d use per-CPU counters and aggregate them on read. This is exactly how the kernel&#39;s own <code>percpu_counter</code> works.\nThe <code>struct mydev_status</code> that you fill and copy:</li>\n</ul>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>struct mydev_status {  /* total: 6 Ã— 4 = 24 bytes */\n    __u32 buffer_size;    /* offset  0 */\n    __u32 bytes_used;     /* offset  4 */\n    __u32 open_count;     /* offset  8 */\n    __u32 read_count;     /* offset 12 */\n    __u32 write_count;    /* offset 16 */\n    __u32 _reserved;      /* offset 20 */\n};                        /* total: 24 bytes = 3/8 of one cache line */</code></pre></div>\n<h2 id=\"24-bytes-one-cache-line-64-bytes-is-more-than-enough-the-copy_to_user-for-24-bytes-doesn39t-even-need-loop-unrolling-the-compiler-generates-a-small-sequence-of-register-stores-the-bottleneck-in-this-ioctl-is-not-the-copy-it39s-the-atomic-reads-and-the-syscall-overhead\">24 bytes. One cache line (64 bytes) is more than enough. The <code>copy_to_user</code> for 24 bytes doesn&#39;t even need loop unrolling â€” the compiler generates a small sequence of register stores. The bottleneck in this ioctl is not the copy; it&#39;s the atomic reads and the syscall overhead.</h2>\n<h2 id=\"pitfalls-what-goes-wrong-and-why\">Pitfalls: What Goes Wrong and Why</h2>\n<h3 id=\"using-wrong-magic-number-silent-mismatch\">Using Wrong Magic Number â€” Silent Mismatch</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG â€” using a magic number someone else uses */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEV_MAGIC</span><span style=\"color:#9ECBFF\">  't'</span><span style=\"color:#6A737D\">   /* 't' is used by linux/tty.h TCGETS, TCSETS, etc. */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* RIGHT â€” pick one from Documentation/userspace-api/ioctl/ioctl-number.rst */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEV_MAGIC</span><span style=\"color:#9ECBFF\">  'M'</span><span style=\"color:#6A737D\">   /* or whichever is unregistered */</span></span></code></pre></div>\n<p>If your magic number collides with a TTY magic number, a program calling your ioctl on a TTY might accidentally trigger your handler (or vice versa) when the numbers align. The magic number is the first line of defense.</p>\n<h3 id=\"returning-wrong-error-for-unknown-command\">Returning Wrong Error for Unknown Command</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG â€” standard violation */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span><span style=\"color:#6A737D\">    /* \"invalid argument\" â€” ambiguous */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* RIGHT â€” POSIX-mandated for unsupported ioctl */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTTY;</span><span style=\"color:#6A737D\">    /* \"inappropriate ioctl for device\" */</span></span></code></pre></div>\n<p>Programs testing for supported commands use the return code to distinguish &quot;command not supported&quot; (<code>-ENOTTY</code>) from &quot;command supported but argument invalid&quot; (<code>-EINVAL</code>). Returning <code>-EINVAL</code> for unknown commands breaks this distinction.</p>\n<h3 id=\"resize-without-protecting-existing-data\">RESIZE Without Protecting Existing Data</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG â€” frees old buffer before copying to new */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kfree</span><span style=\"color:#E1E4E8\">(kernel_buffer);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">kernel_buffer </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(new_size, GFP_KERNEL);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">kernel_buffer) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* original data is gone! kernel_buffer is now NULL! */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOMEM;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* RIGHT â€” allocate first, copy, then free */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">new_buffer </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kzalloc</span><span style=\"color:#E1E4E8\">(new_size, GFP_KERNEL);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">new_buffer) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOMEM;</span><span style=\"color:#6A737D\">   /* original buffer untouched */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">memcpy</span><span style=\"color:#E1E4E8\">(new_buffer, kernel_buffer, </span><span style=\"color:#B392F0\">min</span><span style=\"color:#E1E4E8\">(buffer_used, (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">new_size</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kfree</span><span style=\"color:#E1E4E8\">(kernel_buffer);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">kernel_buffer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_buffer;</span></span></code></pre></div>\n<p>The &quot;allocate-then-swap&quot; pattern is a fundamental technique for making operations resilient to allocation failure. It applies equally to kernel code and userspace code (it&#39;s how <code>realloc</code> is supposed to be implemented for safety).</p>\n<h3 id=\"not-handling-truncation-on-resize-down\">Not Handling Truncation on RESIZE-Down</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG â€” bytes_used may exceed new_size */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">memcpy</span><span style=\"color:#E1E4E8\">(new_buffer, kernel_buffer, buffer_used);</span><span style=\"color:#6A737D\">  /* writes past new_buffer end! */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* RIGHT â€” truncate first */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (buffer_used </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> new_size)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buffer_used </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_size;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">memcpy</span><span style=\"color:#E1E4E8\">(new_buffer, kernel_buffer, buffer_used);</span></span></code></pre></div>\n<p>Writing <code>buffer_used</code> bytes into a <code>new_size</code>-byte buffer when <code>buffer_used &gt; new_size</code> is a classic buffer overflow. In the kernel, this corrupts adjacent kernel memory â€” the consequences range from silent data corruption to immediate kernel panic, depending on what lives next to your buffer.</p>\n<h3 id=\"proc_create-error-check-with-is_err\">proc_create Error Check with IS_ERR</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG â€” proc_create returns NULL on error, not ERR_PTR */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">IS_ERR</span><span style=\"color:#E1E4E8\">(proc_entry)) {</span><span style=\"color:#6A737D\">          /* always false! NULL != IS_ERR(NULL) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> PTR_ERR</span><span style=\"color:#E1E4E8\">(proc_entry);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    goto</span><span style=\"color:#E1E4E8\"> err_proc;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* RIGHT */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">proc_entry) {</span><span style=\"color:#6A737D\">                  /* NULL check */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOMEM;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    goto</span><span style=\"color:#E1E4E8\"> err_proc;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><code>IS_ERR(NULL)</code> returns false because <code>NULL</code> (0) is not in the error pointer range. The <code>proc_create</code> inconsistency (returning NULL vs ERR_PTR) is a historical accident in the kernel API. Always check the documentation for which convention a function uses.</p>\n<h3 id=\"modifying-buffer_size_bytes-without-updating-proc-show\">Modifying buffer_size_bytes Without Updating /proc Show</h3>\n<h2 id=\"if-your-proc-show-function-reads-buffer_size_bytes-and-your-ioctl-resize-modifies-it-you-need-no-extra-work-both-see-the-same-global-variable-but-if-you-cache-values-eg-save-buffer_size_bytes-to-a-local-at-init-time-your-proc-entry-will-show-stale-data-after-a-resize-always-read-live-state-in-proc-show-handlers\">If your proc show function reads <code>buffer_size_bytes</code> and your ioctl RESIZE modifies it, you need no extra work â€” both see the same global variable. But if you cache values (e.g., save <code>buffer_size_bytes</code> to a local at init time), your proc entry will show stale data after a resize. Always read live state in proc show handlers.</h2>\n<h2 id=\"knowledge-cascade-what-you39ve-just-unlocked\">Knowledge Cascade: What You&#39;ve Just Unlocked</h2>\n<h2 id=\"-ioctl-control-plane-data-plane-separation-cross-domain-network-protocol-design-the-readwrite-vs-ioctl-split-you-just-implemented-is-the-same-architectural-pattern-as-tcp39s-data-stream-vs-socket-options-setsockoptgetsockopt-http-separates-body-data-plane-from-headers-control-plane-quic-separates-stream-data-from-connection-level-signals-grpc-offers-streaming-rpcs-high-throughput-data-alongside-unary-calls-control-the-insight-quotdon39t-mix-control-and-data-in-the-same-channelquot-appears-everywhere-because-mixing-them-forces-both-sides-to-parse-combined-traffic-adding-latency-and-complexity-when-you-next-design-a-protocol-or-api-and-find-yourself-tempted-to-embed-commands-in-the-data-stream-remember-tcp-http-and-your-kernel-driver-all-chose-not-to-seq_file39s-iterator-language-level-iterators-cross-domain-language-design-the-startnextstopshow-interface-seq_file-gives-you-is-structurally-identical-to-python39s-__iter____next__-generator-protocol-rust39s-iterator-trait-with-its-next-gt-optionltitemgt-method-and-database-cursor-iteration-the-fundamental-problem-is-the-same-quotproduce-a-potentially-large-sequence-lazily-without-materializing-it-all-at-oncequot-python-generators-solve-it-with-yield-rust-iterators-solve-it-with-next-seq_file-solves-it-with-startnextstop-when-you-write-a-python-generator-that-yields-database-rows-you39re-implementing-the-same-pattern-as-the-seq_file-infrastructure-you-just-wired-up-proc-virtual-filesystem-everything-is-a-file-philosophy-cross-domain-os-design-procmydevice-has-no-backing-file-on-disk-its-quotcontentquot-is-generated-by-your-mydev_proc_show-function-every-time-someone-reads-it-this-is-the-same-trick-as-proccpuinfo-calls-into-the-cpu-topology-code-procmeminfo-queries-the-page-allocator-and-procltpidgtstatus-reads-the-task-struct-for-that-process-plan-9-os-linux39s-philosophical-ancestor-in-many-ways-took-this-idea-to-its-logical-extreme-everything-is-a-file-including-network-connections-open-nettcp0data-to-make-a-tcp-connection-fuse-filesystem-in-userspace-implements-the-same-idea-in-userspace-your-code-generates-quotfile-contentquot-on-read-understanding-proc-means-you-understand-fuse-plan-9-sys-and-the-entire-quotvirtual-filesystem-as-control-interfacequot-philosophy-shared-header-abi-wire-format-stability-cross-domain-distributed-systems-the-mydevice_ioctlh-you-just-created-is-an-abi-contract-struct-mydev_status39s-layout-field-order-sizes-offsets-is-now-frozen-any-userspace-binary-compiled-against-this-header-must-keep-working-against-future-kernel-drivers-this-is-identical-to-protocol-buffers-field-numbers-are-immutable-once-assigned-because-removing-or-reusing-them-breaks-binary-compatibility-with-old-serialized-data-it39s-the-same-as-json-api-versioning-don39t-remove-fields-only-add-the-linux-kernel39s-guarantee-of-stable-userspace-abi-is-explicitly-documented-in-documentationprocessstable-api-nonsenserst-the-internal-kernel-api-changes-freely-but-the-userspace-abi-what-you-exposed-in-your-header-is-guaranteed-stable-when-you-design-any-serialized-format-or-shared-interface-you39re-facing-the-same-problem-your-ioctl-header-just-solved-separate-the-mutable-internals-from-the-immutable-external-contract-atomic-counters-per-cpu-counters-scalability-forward-your-atomic_t-read_count-increments-on-every-read-with-a-single-cpu-this-is-fine-with-16-cpus-all-reading-simultaneously-each-atomic_inc-causes-the-cache-line-holding-read_count-to-bounce-between-cpu-caches-a-cache-coherency-round-trip-that-takes-100-cpu-cycles-per-operation-at-16-concurrent-readers-your-counter-becomes-a-bottleneck-the-kernel39s-solution-percpu_counter-each-cpu-maintains-its-own-counter-in-cpu-local-memory-no-cache-bouncing-and-reads-aggregate-all-cpu-local-values-this-is-the-same-idea-as-go39s-syncpool-per-goroutine-allocation-to-avoid-contention-or-partitioned-lock-tables-one-lock-per-shard-not-one-global-lock-the-pattern-quotreplace-one-shared-resource-with-n-per-cpuper-thread-resources-aggregate-on-readquot-you39ll-see-it-everywhere-high-performance-code-needs-shared-counters\"><strong>â†’ ioctl = Control Plane / data-plane separation (cross-domain: network protocol design)</strong>\nThe read/write vs. ioctl split you just implemented is the same architectural pattern as TCP&#39;s data stream vs. socket options (<code>setsockopt</code>/<code>getsockopt</code>). HTTP separates body (data plane) from headers (control plane). QUIC separates stream data from connection-level signals. gRPC offers streaming RPCs (high-throughput data) alongside unary calls (control). The insight â€” &quot;don&#39;t mix control and data in the same channel&quot; â€” appears everywhere because mixing them forces both sides to parse combined traffic, adding latency and complexity. When you next design a protocol or API and find yourself tempted to embed commands in the data stream, remember: TCP, HTTP, and your kernel driver all chose not to.\n<strong>â†’ seq_file&#39;s iterator = Language-level iterators (cross-domain: language design)</strong>\nThe <code>start</code>/<code>next</code>/<code>stop</code>/<code>show</code> interface seq_file gives you is structurally identical to Python&#39;s <code>__iter__</code>/<code>__next__</code> generator protocol, Rust&#39;s <code>Iterator</code> trait with its <code>next() -&gt; Option&lt;Item&gt;</code> method, and database cursor iteration. The fundamental problem is the same: &quot;produce a potentially large sequence lazily, without materializing it all at once.&quot; Python generators solve it with <code>yield</code>. Rust iterators solve it with <code>next()</code>. seq_file solves it with <code>start</code>/<code>next</code>/<code>stop</code>. When you write a Python generator that yields database rows, you&#39;re implementing the same pattern as the seq_file infrastructure you just wired up.\n<strong>â†’ /proc virtual filesystem = Everything-is-a-file philosophy (cross-domain: OS design)</strong>\n<code>/proc/mydevice</code> has no backing file on disk. Its &quot;content&quot; is generated by your <code>mydev_proc_show</code> function every time someone reads it. This is the same trick as <code>/proc/cpuinfo</code> (calls into the CPU topology code), <code>/proc/meminfo</code> (queries the page allocator), and <code>/proc/&lt;pid&gt;/status</code> (reads the task struct for that process). Plan 9 OS â€” Linux&#39;s philosophical ancestor in many ways â€” took this idea to its logical extreme: <em>everything</em> is a file, including network connections (open <code>/net/tcp/0/data</code> to make a TCP connection). FUSE (Filesystem in Userspace) implements the same idea in userspace: your code generates &quot;file content&quot; on-read. Understanding <code>/proc</code> means you understand FUSE, Plan 9, <code>/sys</code>, and the entire &quot;virtual filesystem as control interface&quot; philosophy.\n<strong>â†’ Shared header ABI = Wire format stability (cross-domain: distributed systems)</strong>\nThe <code>mydevice_ioctl.h</code> you just created is an ABI contract. <code>struct mydev_status</code>&#39;s layout â€” field order, sizes, offsets â€” is now frozen. Any userspace binary compiled against this header must keep working against future kernel drivers. This is identical to Protocol Buffers: field numbers are immutable once assigned, because removing or reusing them breaks binary compatibility with old serialized data. It&#39;s the same as JSON API versioning (don&#39;t remove fields, only add). The Linux kernel&#39;s guarantee of stable userspace ABI is explicitly documented in <code>Documentation/process/stable-api-nonsense.rst</code> â€” the <em>internal</em> kernel API changes freely, but the userspace ABI (what you exposed in your header) is guaranteed stable. When you design any serialized format or shared interface, you&#39;re facing the same problem your ioctl header just solved: separate the mutable internals from the immutable external contract.\n<strong>â†’ Atomic counters â†’ per-CPU counters â†’ scalability (forward)</strong>\nYour <code>atomic_t read_count</code> increments on every read. With a single CPU, this is fine. With 16 CPUs all reading simultaneously, each <code>atomic_inc</code> causes the cache line holding <code>read_count</code> to bounce between CPU caches â€” a cache coherency round-trip that takes ~100 CPU cycles per operation. At 16 concurrent readers, your counter becomes a bottleneck. The kernel&#39;s solution: <code>percpu_counter</code> â€” each CPU maintains its own counter in CPU-local memory (no cache bouncing), and reads aggregate all CPU-local values. This is the same idea as Go&#39;s <code>sync.Pool</code> (per-goroutine allocation to avoid contention), or partitioned lock tables (one lock per shard, not one global lock). The pattern: &quot;replace one shared resource with N per-CPU/per-thread resources, aggregate on read.&quot; You&#39;ll see it everywhere high-performance code needs shared counters.</h2>\n<h2 id=\"acceptance-criteria-checkpoint\">Acceptance Criteria Checkpoint</h2>\n<p>Before moving to Milestone 4, verify every item:</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> <code>mydevice_ioctl.h</code> compiles correctly when included in both kernel module (with <code>__KERNEL__</code> defined) and userspace C program (without <code>__KERNEL__</code>)</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>MYDEV_CLEAR</code>, <code>MYDEV_RESIZE</code>, <code>MYDEV_STATUS</code> produce distinct non-zero 32-bit values; verify by printing them in the test program</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>make</code> compiles the module with <code>ccflags-y := -Werror</code> and zero warnings</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>ioctl(fd, MYDEV_CLEAR)</code> zeroes the buffer; subsequent read returns 0 bytes (EOF immediately)</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>ioctl(fd, MYDEV_RESIZE, &amp;new_size)</code> with <code>new_size=8192</code> changes buffer capacity; <code>MYDEV_STATUS</code> reports <code>buffer_size=8192</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>ioctl(fd, MYDEV_RESIZE, &amp;new_size)</code> with <code>new_size=0</code> returns <code>-EINVAL</code> (not a crash)</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>ioctl(fd, MYDEV_RESIZE, &amp;new_size)</code> with content larger than new_size truncates safely (no overflow, no panic)</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>ioctl(fd, MYDEV_STATUS, &amp;status)</code> fills all fields of <code>struct mydev_status</code> correctly; <code>read_count</code> and <code>write_count</code> increment after each read/write operation</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>ioctl(fd, _IO(&#39;Z&#39;, 99))</code> (wrong magic number) returns <code>-1</code> with <code>errno == ENOTTY</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>cat /proc/mydevice</code> outputs all five statistics fields (buffer_size, bytes_used, open_count, read_count, write_count)</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>cat /proc/mydevice</code> called twice returns consistent data without hanging or double-printing</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>sudo rmmod mydevice</code> after <code>proc_create</code> removes <code>/proc/mydevice</code> cleanly (no stale proc entry)</li>\n<li><input disabled=\"\" type=\"checkbox\"> Test program <code>test_mydevice</code> compiles with <code>gcc -Wall -Werror -I. test_mydevice.c</code> and runs all four test cases without failure</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>strace ./test_mydevice 2&gt;&amp;1 | grep ioctl</code> shows ioctl calls with recognizable command names (not raw hex) when symbols are available</li>\n</ul>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-kernel-module-m4 -->\n<!-- MS_ID: build-kernel-module-m4 -->\n<h1 id=\"milestone-4-concurrent-access-blocking-io-and-poll-support\">Milestone 4: Concurrent Access, Blocking I/O, and Poll Support</h1>\n<h2 id=\"the-revelation-the-kernel-is-not-a-thread-it39s-a-state-machine\">The Revelation: The Kernel Is Not a Thread â€” It&#39;s a State Machine</h2>\n<p>You&#39;ve built a character device that works perfectly when one process uses it at a time. Now imagine four processes all calling <code>read()</code> simultaneously, three of them finding the buffer empty, and a fourth calling <code>write()</code> to fill it. In userspace, you&#39;d reach for <code>pthread_mutex_lock()</code> and a condition variable. You&#39;d think: &quot;The reader locks the mutex, finds the buffer empty, calls <code>pthread_cond_wait()</code>, sleeps, wakes when the writer signals.&quot; Clean. Familiar.\nHere&#39;s the misconception that kernel newcomers carry from that model: they assume that &quot;blocking&quot; in the kernel works the same way, that <code>mutex_lock</code> in the kernel is just <code>pthread_mutex_lock</code> with a different name, and that <code>poll()</code> is just a kernel function that checks a boolean and returns &quot;yes&quot; or &quot;no.&quot;\nEvery part of that model needs surgery.\n<strong>The first operation</strong>: <code>mutex_lock()</code> in the kernel <em>does</em> sleep. But &quot;sleeping&quot; in the kernel is not a private affair between two threads. It is a state change on the <strong>current process</strong> â€” the actual Linux task (identified by its <code>struct task_struct</code>) that is executing your driver&#39;s code on behalf of the syscall. When your read handler calls <code>mutex_lock()</code> and the mutex is contended, the current process transitions from <code>TASK_RUNNING</code> (scheduled, consuming CPU cycles) to <code>TASK_INTERRUPTIBLE</code> (sleeping, removed from the run queue, not scheduled). The scheduler picks a different process to run. Your code is literally paused mid-function, in the kernel, and a completely different process starts running on that CPU. When the mutex becomes available, your process is placed back on the run queue and eventually resumes exactly where it paused â€” but potentially hundreds of milliseconds later, on a different CPU core.\nThis is only safe in <strong>process context</strong> â€” code executing as part of a syscall from a user process. It is catastrophically illegal in <strong>interrupt context</strong> â€” code executing inside a hardware interrupt handler or a software interrupt (softirq, tasklet). In interrupt context, there is no &quot;current process&quot; to sleep. The CPU is responding to a hardware event, not running on behalf of any process. If you call <code>mutex_lock()</code> and sleep in interrupt context, you corrupt the interrupt stack, the scheduler panics, and your machine halts.\n[[EXPLAIN:kernel-sleeping-primitives-vs-spinlocks-(process-context-vs-interrupt-context)|Kernel sleeping primitives vs spinlocks (process context vs interrupt context)]]\n<strong>The second operation</strong>: <code>wait_event_interruptible()</code> is not a function that loops until something is true. It does something architecturally remarkable. It:</p>\n<ol>\n<li>Adds the current process to a <strong>wait queue</strong> â€” a linked list of sleeping processes waiting for a condition</li>\n<li>Sets the process state to <code>TASK_INTERRUPTIBLE</code></li>\n<li>Calls <code>schedule()</code> â€” voluntarily yields the CPU</li>\n<li>Wakes up when another process calls <code>wake_up_interruptible()</code> on the wait queue</li>\n<li>Re-checks the condition (spurious wakeup protection)</li>\n<li>If condition is true: removes itself from the wait queue and returns 0</li>\n<li>If a signal arrived: returns <code>-ERESTARTSYS</code>\nThe writer calling <code>wake_up_interruptible()</code> doesn&#39;t resume the reader <em>immediately</em>. It transitions the reader from the wait queue back to the run queue and marks it <code>TASK_RUNNING</code>. The scheduler then decides when the reader actually gets CPU time â€” maybe microseconds later, maybe milliseconds. The writer continues running, finishes its write, releases the mutex, and returns. Only then does the scheduler get to pick the reader.\n<strong>The third operation</strong> â€” and this is the one that surprises everyone â€” <code>poll()</code> does not sleep inside your driver. Your <code>.poll</code> handler is called by the kernel&#39;s poll infrastructure, but it must return <em>immediately</em> with a readiness mask. It must never block. The sleeping happens <em>outside</em> your driver, in the VFS poll infrastructure. Your job is not to wait for readiness â€” your job is to <strong>register your wait queue</strong> with the poll table and <strong>report current readiness</strong>. The kernel&#39;s poll loop does the sleeping, wakes up when your wait queue fires, and calls your <code>.poll</code> handler again to re-check readiness.\nThese three revelations reframe everything you&#39;re about to build. Let&#39;s build it.</li>\n</ol>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiag-m4-complete-device-struct.svg\" alt=\"Final Device Structure: All Fields at Byte-Level\"></p>\n<hr>\n<h2 id=\"the-foundation-what-you39re-actually-building\">The Foundation: What You&#39;re Actually Building</h2>\n<p>Before any code, look at the structural transformation this milestone makes. In Milestone 3, your device had two unsynchronized global variables (<code>buffer_used</code>, <code>kernel_buffer</code>) accessed by handlers that could run simultaneously on different CPUs. Any concurrent access was undefined behavior â€” a data race that worked most of the time and produced subtle corruption the rest.\nThis milestone adds:</p>\n<ul>\n<li>A <code>struct mutex dev_mutex</code> that serializes all access to <code>kernel_buffer</code> and <code>buffer_used</code></li>\n<li>A <code>wait_queue_head_t read_queue</code> for blocking readers waiting for data</li>\n<li>A <code>wait_queue_head_t write_queue</code> for blocking writers waiting for space</li>\n<li>Logic to check <code>filp-&gt;f_flags &amp; O_NONBLOCK</code> to implement non-blocking I/O</li>\n<li>A <code>.poll</code> file operation that uses <code>poll_wait()</code> to participate in <code>select</code>/<code>poll</code>/<code>epoll</code>\nThe device&#39;s behavior changes fundamentally:<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Before (M3)</th>\n<th>After (M4)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Two concurrent writes</td>\n<td>Data race, corruption</td>\n<td>Serialized by mutex</td>\n</tr>\n<tr>\n<td>Read with empty buffer</td>\n<td>Returns 0 (EOF) immediately</td>\n<td>Blocks until data arrives</td>\n</tr>\n<tr>\n<td>Read with O_NONBLOCK + empty</td>\n<td>Returns 0 (EOF)</td>\n<td>Returns -EAGAIN</td>\n</tr>\n<tr>\n<td>Write with full buffer</td>\n<td>Returns -ENOSPC</td>\n<td>Blocks until space available</td>\n</tr>\n<tr>\n<td>poll() on the fd</td>\n<td>Not supported</td>\n<td>Returns POLLIN when data exists</td>\n</tr>\n<tr>\n<td>Ctrl+C during blocking read</td>\n<td>Hangs forever (pre-M4)</td>\n<td>Returns -EINTR/-ERESTARTSYS</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiag-m4-mutex-protection.svg\" alt=\"Mutex-Protected Buffer: Critical Sections in Read and Write\"></p>\n<hr>\n<h2 id=\"kernel-mutexes-the-right-lock-for-process-context\">Kernel Mutexes: The Right Lock for Process Context</h2>\n<h3 id=\"what-a-mutex-actually-is\">What a Mutex Actually Is</h3>\n<p>The kernel has multiple locking primitives, each suited to a different context. Understanding <em>which</em> lock to use requires understanding what &quot;context&quot; means in the kernel.\n<strong>Process context</strong> is any code that executes as part of a system call on behalf of a user process. Your <code>mydev_read</code>, <code>mydev_write</code>, <code>mydev_ioctl</code>, and <code>mydev_open</code> handlers all run in process context â€” there is a <code>current</code> task, it has a process address space, and it can sleep.\n<strong>Interrupt context</strong> is any code that executes in response to a hardware interrupt, softirq, or tasklet. There is no <code>current</code> task in the meaningful sense, no process address space, and <strong>sleeping is forbidden</strong> â€” the CPU must finish handling the interrupt and return to whatever it was doing before.\nThe primitive you want for process context is <code>struct mutex</code>. It is a <strong>sleeping lock</strong>:</p>\n<ul>\n<li>If the mutex is available: <code>mutex_lock()</code> acquires it instantly (one atomic operation)</li>\n<li>If the mutex is contended: <code>mutex_lock()</code> puts the current process to sleep until the mutex becomes available\nThe primitive for interrupt context (or any context where sleeping is forbidden) is <code>struct spinlock</code>. A spinlock <strong>busy-waits</strong> â€” it loops in a tight loop reading the lock variable until it becomes available. No sleeping, no schedule() call. But holding a spinlock while doing anything that sleeps (including <code>kmalloc(GFP_KERNEL)</code>, <code>copy_from_user</code>, <code>mutex_lock</code>) is catastrophic â€” it holds the CPU hostage.\nFor your character device, <strong>mutex is the correct choice</strong>. Your file operation handlers run in process context. They may sleep. They copy data from/to userspace, which can fault and sleep. <code>GFP_KERNEL</code> allocations in ioctl handlers can sleep. Mutex handles all of this correctly.</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/mutex.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#B392F0\"> DEFINE_MUTEX</span><span style=\"color:#E1E4E8\">(dev_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * DEFINE_MUTEX(name) statically defines and initializes a mutex.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Equivalent to:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   struct mutex dev_mutex;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   mutex_init(&#x26;dev_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Use for module-level mutexes. For dynamically allocated structs,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * use mutex_init(&#x26;obj->lock) in your allocation/init code.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span></code></pre></div>\n<p>The mutex API is small:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">dev_mutex</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">          /* acquire; sleep if contended */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">dev_mutex</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">        /* release */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mutex_lock_interruptible</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">dev_mutex</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\"> /* acquire; return -EINTR if signal arrives */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mutex_trylock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">dev_mutex</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">       /* acquire if available; return 0 if not */</span></span></code></pre></div>\n<p>For blocking I/O, use <code>mutex_lock_interruptible()</code> â€” it returns <code>-EINTR</code> if a signal arrives while the process is sleeping waiting for the mutex. This allows <code>Ctrl+C</code> to interrupt a write even if the mutex is contended.</p>\n<blockquote>\n<p><strong>Lock Ordering</strong>: if your driver ever needs two mutexes simultaneously (you won&#39;t here, but this principle is fundamental), you must acquire them in a consistent global order across all code paths. Acquiring A then B in one path and B then A in another path is a classic deadlock. Since this driver has one mutex, deadlock is only possible if your code calls <code>mutex_lock(&amp;dev_mutex)</code> while already holding it â€” which deadlocks immediately because the kernel&#39;s mutex is not reentrant. You will see <code>WARNING: possible recursive locking detected</code> in dmesg if this happens.</p>\n</blockquote>\n<hr>\n<h2 id=\"wait-queues-the-sleeping-heart-of-blocking-io\">Wait Queues: The Sleeping Heart of Blocking I/O</h2>\n<h3 id=\"the-data-structure\">The Data Structure</h3>\n<p>A <strong>wait queue head</strong> (<code>wait_queue_head_t</code>) is a linked list of sleeping processes, each waiting for a condition to become true. The list is protected by its own internal spinlock (which is why wait queue operations are safe to call from anywhere, including while holding your mutex â€” the internal spinlock protects the queue structure itself, and you release it before sleeping).</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/wait.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#B392F0\"> DECLARE_WAIT_QUEUE_HEAD</span><span style=\"color:#E1E4E8\">(read_queue);</span><span style=\"color:#6A737D\">   /* for readers waiting on empty buffer */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#B392F0\"> DECLARE_WAIT_QUEUE_HEAD</span><span style=\"color:#E1E4E8\">(write_queue);</span><span style=\"color:#6A737D\">  /* for writers waiting on full buffer  */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * DECLARE_WAIT_QUEUE_HEAD(name) statically defines and initializes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * For dynamic allocation: init_waitqueue_head(&#x26;obj->wait_queue);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span></code></pre></div>\n\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiag-m4-wait-queue-blocking-read.svg\" alt=\"Blocking Read: wait_event_interruptible Internals\"></p>\n<h3 id=\"wait_event_interruptible-the-full-mechanism\"><code>wait_event_interruptible</code>: The Full Mechanism</h3>\n<p>The macro <code>wait_event_interruptible(queue, condition)</code> is the standard pattern for blocking a process until a condition becomes true. Here is what it expands to, conceptually:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>wait_event_interruptible(wq, condition):\n  1. Check condition â€” if true, return 0 immediately (fast path, no sleeping)\n  2. Prepare a wait_queue_entry: allocate a struct, set it to point to current task\n  3. add_wait_queue(wq, &amp;entry)        â€” insert into the wait queue\n  4. set_current_state(TASK_INTERRUPTIBLE) â€” mark process as sleeping\n  5. Check condition AGAIN (re-check after state change, before schedule)\n     â€” this closes the TOCTOU window between adding to queue and sleeping\n  6. If condition false AND no signal pending:\n       schedule()                      â€” yield CPU; sleep here\n       set_current_state(TASK_INTERRUPTIBLE)  â€” re-arm for next iteration\n       goto step 5\n  7. set_current_state(TASK_RUNNING)   â€” re-arm as runnable\n  8. remove_wait_queue(wq, &amp;entry)     â€” remove from wait queue\n  9. If signal_pending(current): return -ERESTARTSYS\n  10. Return 0 (condition became true)</code></pre></div>\n<p>The double-check at step 5 is critical. Between step 3 (adding to wait queue) and step 6 (calling schedule), a writer might already have written data and called <code>wake_up_interruptible()</code>. Without the re-check, the reader would sleep on a now-non-empty buffer, potentially forever. This is the <strong>lost wakeup problem</strong>, and <code>wait_event_interruptible</code> handles it correctly.\n[[EXPLAIN:wait-queue-internals-and-the-thundering-herd-problem|Wait queue internals and the thundering herd problem]]</p>\n<h3 id=\"the-condition-and-the-mutex-a-critical-pattern\">The Condition and the Mutex: A Critical Pattern</h3>\n<p>There&#39;s a subtle interaction between the mutex and the wait queue that confuses many developers. Your read handler:</p>\n<ol>\n<li><strong>Acquires the mutex</strong> (to safely check <code>buffer_used</code>)</li>\n<li><strong>Checks the condition</strong> (<code>buffer_used == 0</code>)</li>\n<li>If empty: <strong>must release the mutex before sleeping</strong>\nYou cannot hold the mutex while calling <code>wait_event_interruptible()</code> â€” that would block all writers from acquiring the mutex to add data, causing a deadlock where the reader sleeps holding the lock that writers need.\nThe pattern looks like this:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG â€” deadlock: holds mutex while sleeping */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">dev_mutex</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">wait_event_interruptible</span><span style=\"color:#E1E4E8\">(read_queue, buffer_used </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  /* writers can't lock! */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* ... read ... */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">dev_mutex</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* RIGHT â€” release mutex before sleeping, re-acquire after waking */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">dev_mutex</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (buffer_used </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">wait_event_interruptible</span><span style=\"color:#E1E4E8\">(read_queue, buffer_used </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ERESTARTSYS;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* now holding mutex and buffer_used > 0 */</span></span></code></pre></div>\n<p>But wait â€” is there a race between releasing the mutex and adding ourselves to the wait queue? <strong>No</strong> â€” <code>wait_event_interruptible</code> checks the condition <em>before</em> sleeping. The sequence is:</p>\n<ol>\n<li>Check <code>buffer_used == 0</code> with mutex held â€” yes, empty</li>\n<li>Release mutex</li>\n<li><code>wait_event_interruptible</code> checks <code>buffer_used &gt; 0</code> â€” still empty (writer hasn&#39;t run yet)</li>\n<li>Adds to wait queue, sets <code>TASK_INTERRUPTIBLE</code>, calls <code>schedule()</code></li>\n<li>Writer acquires mutex, adds data, calls <code>wake_up_interruptible()</code></li>\n<li>Reader wakes, re-acquires mutex</li>\n<li>Condition is now true â€” reader proceeds\nIf the writer runs between steps 2 and 3 (after mutex release but before <code>wait_event_interruptible</code>), the writer adds data and calls <code>wake_up_interruptible()</code> on an empty wait queue (reader hasn&#39;t added itself yet). Then in step 3, <code>wait_event_interruptible</code> checks the condition â€” <code>buffer_used &gt; 0</code> is now true â€” and returns immediately without sleeping. No lost wakeup.</li>\n</ol>\n<hr>\n<h2 id=\"-erestartsys-the-signal-that-travels-through-time\">-ERESTARTSYS: The Signal That Travels Through Time</h2>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiag-m4-signal-erestartsys.svg\" alt=\"Signal Delivery During Wait: -ERESTARTSYS Flow\"></p>\n<p>When a user presses <code>Ctrl+C</code> while a process is blocked in <code>read()</code> on your device, a <code>SIGINT</code> signal is delivered. Here is the chain of events:</p>\n<ol>\n<li>The kernel delivers <code>SIGINT</code> to the sleeping process by setting a flag in its <code>task_struct</code> and calling <code>wake_up_process(task)</code></li>\n<li>The process transitions from <code>TASK_INTERRUPTIBLE</code> to <code>TASK_RUNNING</code></li>\n<li><code>wait_event_interruptible</code> detects a pending signal via <code>signal_pending(current)</code> and returns <code>-ERESTARTSYS</code> instead of 0</li>\n<li>Your read handler propagates this: <code>if (ret == -ERESTARTSYS) return -ERESTARTSYS;</code></li>\n<li>The kernel&#39;s signal handling code intercepts the <code>-ERESTARTSYS</code> return from your syscall\nHere&#39;s the subtle part: <code>-ERESTARTSYS</code> is <strong>not</strong> <code>-EINTR</code>. The kernel uses <code>-ERESTARTSYS</code> as an internal signal to its own syscall restart machinery. The kernel then checks the signal handler:</li>\n</ol>\n<ul>\n<li>If the signal handler was installed with <code>SA_RESTART</code> flag: the syscall is <strong>automatically restarted</strong> â€” the process calls <code>read()</code> again transparently, the user process never sees the interruption</li>\n<li>If the signal handler was installed without <code>SA_RESTART</code> (or the signal has default disposition): the kernel converts <code>-ERESTARTSYS</code> to <code>-EINTR</code> and returns that to the user process, which sees <code>errno == EINTR</code>\nThis is exactly why <code>read()</code> sometimes returns <code>-1</code> with <code>errno == EINTR</code> in userspace programs â€” the signal handler interrupted the blocking syscall, and the SA_RESTART flag was not set. Your <code>signal-handler</code> prerequisite project encountered this behavior; now you&#39;re seeing the kernel mechanism that produces it.<blockquote>\n<p><strong>Why not return <code>-EINTR</code> directly from your driver?</strong> Because <code>-EINTR</code> prevents syscall restart entirely. <code>-ERESTARTSYS</code> gives the kernel&#39;s signal machinery the opportunity to restart the syscall if <code>SA_RESTART</code> allows it. Returning <code>-ERESTARTSYS</code> from your handler is the correct, SA_RESTART-aware approach. The kernel translates it to <code>-EINTR</code> for userspace if restart isn&#39;t appropriate.</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h2 id=\"o_nonblock-two-universes-of-io-behavior\">O_NONBLOCK: Two Universes of I/O Behavior</h2>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiag-m4-nonblock-vs-blocking.svg\" alt=\"O_NONBLOCK: Two Universes of I/O Behavior\"></p>\n<p>When a process opens your device with <code>O_NONBLOCK</code> (e.g., <code>open(&quot;/dev/mydevice&quot;, O_RDWR | O_NONBLOCK)</code>), it is making a contract with your driver: <strong>&quot;Never block me. If the operation can&#39;t complete immediately, return an error.&quot;</strong>\nThe flag is stored in <code>filp-&gt;f_flags</code> and remains for the lifetime of the open file descriptor. You check it in your read and write handlers:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Check for O_NONBLOCK before sleeping */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (filp</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">f_flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> O_NONBLOCK) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Can't complete immediately â€” return -EAGAIN */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EAGAIN;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><code>-EAGAIN</code> means &quot;try again&quot; â€” the operation failed not because of an error but because it would have blocked. The POSIX error is often referred to as <code>EWOULDBLOCK</code> (which on Linux has the same value as <code>EAGAIN</code>). The caller is expected to either retry later, use <code>poll()</code>/<code>select()</code> to wait for readiness, or handle the condition gracefully.\nThe complete non-blocking contract for your device:</p>\n<table>\n<thead>\n<tr>\n<th>Condition</th>\n<th>Blocking (default)</th>\n<th>Non-blocking (O_NONBLOCK)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Read, buffer empty</td>\n<td>Sleep until data available</td>\n<td>Return -EAGAIN</td>\n</tr>\n<tr>\n<td>Read, buffer has data</td>\n<td>Return data immediately</td>\n<td>Return data immediately</td>\n</tr>\n<tr>\n<td>Write, buffer full</td>\n<td>Sleep until space available</td>\n<td>Return -EAGAIN</td>\n</tr>\n<tr>\n<td>Write, buffer has space</td>\n<td>Write and return count</td>\n<td>Write and return count</td>\n</tr>\n<tr>\n<td>O_NONBLOCK is the foundation of <strong>event-driven I/O</strong>. The <code>select()</code>, <code>poll()</code>, and <code>epoll()</code> system calls use O_NONBLOCK internally â€” they mark fds as non-blocking, check readiness via your <code>.poll</code> handler, sleep if nothing is ready, and then call <code>read()</code>/<code>write()</code> only when the poll says the operation won&#39;t block. If your driver doesn&#39;t implement O_NONBLOCK correctly, the entire event-driven I/O machinery breaks for your device.</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"the-poll-file-operation-not-what-you-think\">The <code>.poll</code> File Operation: Not What You Think</h2>\n<h3 id=\"the-architectural-insight\">The Architectural Insight</h3>\n<p>The biggest conceptual mistake people make with the kernel&#39;s <code>.poll</code> handler is thinking it works like this:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>// WRONG mental model\npoll_handler():\n  while (buffer_empty):\n    sleep(10ms)\n  return POLLIN</code></pre></div>\n<p>It actually works like this:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>// CORRECT mental model\npoll_handler():\n  register_interest(caller, my_wait_queue)  // &quot;wake me if this queue fires&quot;\n  return current_readiness_mask             // what's ready RIGHT NOW</code></pre></div>\n<p>Your <code>.poll</code> handler is not responsible for sleeping. It is responsible for two things:</p>\n<ol>\n<li>Registering the caller&#39;s interest in your wait queue via <code>poll_wait()</code></li>\n<li>Returning a bitmask of currently-ready events\nThe sleeping happens in the VFS poll infrastructure (in <code>fs/select.c</code> for <code>select</code>/<code>poll</code>, in <code>fs/eventpoll.c</code> for <code>epoll</code>). That infrastructure calls your <code>.poll</code> handler, inspects the returned mask, and if nothing is ready, sleeps on the wait queues you registered. When your <code>wake_up_interruptible()</code> fires (from a write), it wakes the infrastructure, which calls your <code>.poll</code> handler again to get the new mask.\n[[EXPLAIN:poll/select/epoll-kernel-side-protocol|poll/select/epoll kernel-side protocol]]</li>\n</ol>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiag-m4-poll-mechanism.svg\" alt=\"poll() File Operation: Registration and Mask Protocol\"></p>\n<h3 id=\"poll_wait-the-registration-function\"><code>poll_wait()</code>: The Registration Function</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/poll.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> __poll_t</span><span style=\"color:#B392F0\"> mydev_poll</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, poll_table </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">wait</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    __poll_t</span><span style=\"color:#E1E4E8\"> mask </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * poll_wait(file, wait_queue_head, poll_table)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Registers this file's wait queue with the poll_table.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * When the wait queue is woken (by wake_up_interruptible),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * the poll infrastructure wakes the sleeping poll/select/epoll</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * and re-checks readiness by calling this .poll handler again.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * CRITICAL: poll_wait() does NOT sleep. It returns immediately.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * The sleeping is done by the poll infrastructure, not by your driver.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    poll_wait</span><span style=\"color:#E1E4E8\">(filp, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">read_queue,  wait);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    poll_wait</span><span style=\"color:#E1E4E8\">(filp, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">write_queue, wait);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * After registering interest, report CURRENT readiness.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * This must be checked after poll_wait() to avoid a race:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * data might have arrived between the poll() call and poll_wait().</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * If we checked before poll_wait and found empty, then data arrived</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * before the registration, we'd miss the wakeup and wait forever.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (buffer_used </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mask </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> POLLIN </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> POLLRDNORM;</span><span style=\"color:#6A737D\">    /* data available for reading */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (buffer_used </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> buffer_size_bytes)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mask </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> POLLOUT </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> POLLWRNORM;</span><span style=\"color:#6A737D\">   /* space available for writing */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> mask;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"the-mask-bits-a-quick-reference\">The Mask Bits: A Quick Reference</h3>\n<table>\n<thead>\n<tr>\n<th>Bit</th>\n<th>Meaning</th>\n<th>When to set</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>POLLIN</code></td>\n<td>Data available to read</td>\n<td><code>buffer_used &gt; 0</code></td>\n</tr>\n<tr>\n<td><code>POLLRDNORM</code></td>\n<td>Normal data readable (same as POLLIN for most devices)</td>\n<td>Same as POLLIN</td>\n</tr>\n<tr>\n<td><code>POLLOUT</code></td>\n<td>Space available to write</td>\n<td><code>buffer_used &lt; buffer_size_bytes</code></td>\n</tr>\n<tr>\n<td><code>POLLWRNORM</code></td>\n<td>Normal data writable (same as POLLOUT for most devices)</td>\n<td>Same as POLLOUT</td>\n</tr>\n<tr>\n<td><code>POLLERR</code></td>\n<td>Error condition</td>\n<td>On error state</td>\n</tr>\n<tr>\n<td><code>POLLHUP</code></td>\n<td>Hangup (device disconnected)</td>\n<td>On device removal</td>\n</tr>\n<tr>\n<td><code>POLLPRI</code></td>\n<td>Urgent data (OOB for TCP, etc.)</td>\n<td>Rarely needed</td>\n</tr>\n<tr>\n<td>Always return both `POLLIN</td>\n<td>POLLRDNORM<code>together and</code>POLLOUT</td>\n<td>POLLWRNORM<code>together. Some applications check for</code>POLLRDNORM<code>specifically (POSIX portable code), others check</code>POLLIN`. Returning both costs nothing and maximizes compatibility.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>The race that poll_wait() prevents</strong>: Imagine a sequence without proper registration: (1) you check <code>buffer_used == 0</code> â€” empty. (2) A writer adds data and calls <code>wake_up_interruptible()</code>. (3) You call <code>poll_wait()</code> â€” but the wakeup already happened, nobody was on the queue. (4) The poll infrastructure sleeps â€” forever. By calling <code>poll_wait()</code> <em>before</em> checking the condition, you register interest first. If a wakeup fires between the registration and the condition check, the infrastructure sees the wakeup and re-checks. No events can be missed.</p>\n</blockquote>\n<hr>\n<h2 id=\"the-complete-implementation\">The Complete Implementation</h2>\n<p>Now let&#39;s assemble the full driver. This is the complete, production-quality reference combining everything from milestones 2, 3, and 4.</p>\n<h3 id=\"updated-device-state\">Updated Device State</h3>\n<p>The device state grows to include the mutex and wait queues:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* mydevice.c â€” Complete character device with concurrency support */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/module.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/kernel.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/init.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/fs.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/cdev.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/device.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/uaccess.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/slab.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/atomic.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/proc_fs.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/seq_file.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/mutex.h></span><span style=\"color:#6A737D\">       /* mutex_lock, mutex_unlock */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/wait.h></span><span style=\"color:#6A737D\">        /* wait_event_interruptible, wake_up_interruptible */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/poll.h></span><span style=\"color:#6A737D\">        /* poll_wait, __poll_t, POLLIN, POLLOUT */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"mydevice_ioctl.h\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_LICENSE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"GPL\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_AUTHOR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Your Name &#x3C;you@example.com>\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_DESCRIPTION</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Character device: mutex protection, blocking I/O, poll support\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_VERSION</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"3.0\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* â”€â”€â”€ Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEVICE_NAME</span><span style=\"color:#9ECBFF\">  \"mydevice\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CLASS_NAME</span><span style=\"color:#9ECBFF\">   \"mydevice_class\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PROC_NAME</span><span style=\"color:#9ECBFF\">    \"mydevice\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BUFFER_SIZE</span><span style=\"color:#79B8FF\">  4096</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* â”€â”€â”€ Device State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> dev_t</span><span style=\"color:#E1E4E8\">          dev_num;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> cdev    my_cdev;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> class  </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">my_class;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> device </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">my_device;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> proc_dir_entry </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">proc_entry;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\">   *</span><span style=\"color:#E1E4E8\">kernel_buffer;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#E1E4E8\">  buffer_size_bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BUFFER_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#E1E4E8\">  buffer_used       </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Synchronization primitives:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * dev_mutex:   protects kernel_buffer, buffer_used, buffer_size_bytes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *              Must be held for any read or write of these fields.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * read_queue:  blocking readers sleep here when buffer_used == 0.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *              Woken by write handler after adding data.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * write_queue: blocking writers sleep here when buffer is full.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *              Woken by read handler after consuming data.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#B392F0\"> DEFINE_MUTEX</span><span style=\"color:#E1E4E8\">(dev_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#B392F0\"> DECLARE_WAIT_QUEUE_HEAD</span><span style=\"color:#E1E4E8\">(read_queue);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#B392F0\"> DECLARE_WAIT_QUEUE_HEAD</span><span style=\"color:#E1E4E8\">(write_queue);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> atomic_t</span><span style=\"color:#E1E4E8\"> open_count  </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ATOMIC_INIT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> atomic_t</span><span style=\"color:#E1E4E8\"> read_count  </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ATOMIC_INIT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> atomic_t</span><span style=\"color:#E1E4E8\"> write_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ATOMIC_INIT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<h3 id=\"open-and-release\">Open and Release</h3>\n<p>Open and release remain simple â€” the open count is atomic and needs no mutex:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydev_open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> inode </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    atomic_inc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydev: open (count=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydev_release</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> inode </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    atomic_dec</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydev: release (count=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"the-write-handler-producer-with-wake-up\">The Write Handler: Producer with Wake-up</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydev_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                           size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">loff_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">f_pos</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> space_available, bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> not_copied;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Acquire the mutex before checking or modifying buffer state.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Use mutex_lock_interruptible so Ctrl+C can interrupt even the</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * mutex acquisition phase (if the mutex is contended and we're sleeping</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * waiting to acquire it).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mutex_lock_interruptible</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_mutex))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ERESTARTSYS;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Wait until there is space in the buffer.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * This loop handles:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *   - O_NONBLOCK: return -EAGAIN immediately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *   - Blocking: sleep until space available or signal arrives</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *   - Spurious wakeups: re-check condition after waking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (buffer_used </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> buffer_size_bytes) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Buffer is full */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (filp->f_flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> O_NONBLOCK) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EAGAIN;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            goto</span><span style=\"color:#E1E4E8\"> out_unlock;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Must release the mutex before sleeping.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * If we slept holding it, no reader could ever consume data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * to free space â€” classic deadlock.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * wait_event_interruptible(queue, condition):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         *   Sleep until (buffer_used &#x3C; buffer_size_bytes) becomes true,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         *   or until a signal arrives (returns -ERESTARTSYS).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * The condition is re-evaluated inside the macro before sleeping â€”</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * this prevents lost wakeups if a reader freed space between our</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * mutex_unlock and this call.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">wait_event_interruptible</span><span style=\"color:#E1E4E8\">(write_queue,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                     buffer_used </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> buffer_size_bytes)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ERESTARTSYS;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Re-acquire mutex to re-check condition safely */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mutex_lock_interruptible</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_mutex))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ERESTARTSYS;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Now holding mutex, buffer has space */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    space_available </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> buffer_size_bytes </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> buffer_used;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes_to_copy   </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> min</span><span style=\"color:#E1E4E8\">(count, space_available);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    not_copied </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> copy_from_user</span><span style=\"color:#E1E4E8\">(kernel_buffer </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> buffer_used, buf, bytes_to_copy);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (not_copied) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> out_unlock;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buffer_used </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    atomic_inc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">write_count);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#E1E4E8\">)bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Wake up any sleeping readers.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * wake_up_interruptible() wakes all TASK_INTERRUPTIBLE waiters on</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * read_queue. They will re-check buffer_used > 0 and, if true,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * proceed to read. If multiple readers wake, only the one that</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * acquires the mutex first will find data; others re-sleep.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * The wake happens while we still hold dev_mutex. This is intentional</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * and safe: the woken reader cannot acquire dev_mutex until we release</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * it below, so there is no race on buffer_used between the wake and</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * the unlock.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    wake_up_interruptible</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">read_queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">out_unlock:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"the-read-handler-consumer-with-blocking\">The Read Handler: Consumer with Blocking</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydev_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                          size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">loff_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">f_pos</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_available, bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> not_copied;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mutex_lock_interruptible</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_mutex))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ERESTARTSYS;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Wait until there is data to read.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * NOTE: This driver uses the buffer as a FIFO stream, not a</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * seekable file. The f_pos tracks position within current content.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * When buffer_used reaches f_pos (all written content consumed),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * the reader blocks waiting for more content.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * If the device is used as a pipe (write then read), *f_pos starts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * at 0 and advances. When *f_pos == buffer_used, we block.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">f_pos </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> buffer_used) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (filp->f_flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> O_NONBLOCK) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * Non-blocking: return -EAGAIN (not 0/EOF) when no data is</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * available yet. 0 would mean \"end of stream, no more data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * ever\" â€” which is wrong for a device that might get writes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * -EAGAIN means \"try again, data might come later.\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EAGAIN;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            goto</span><span style=\"color:#E1E4E8\"> out_unlock;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">wait_event_interruptible</span><span style=\"color:#E1E4E8\">(read_queue, buffer_used </span><span style=\"color:#F97583\">></span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">f_pos)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ERESTARTSYS;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mutex_lock_interruptible</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_mutex))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ERESTARTSYS;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Now holding mutex, buffer has data past *f_pos */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes_available </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> buffer_used </span><span style=\"color:#F97583\">-</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">f_pos;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes_to_copy   </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> min</span><span style=\"color:#E1E4E8\">(count, bytes_available);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    not_copied </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> copy_to_user</span><span style=\"color:#E1E4E8\">(buf, kernel_buffer </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">f_pos, bytes_to_copy);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (not_copied) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> out_unlock;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">f_pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    atomic_inc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">read_count);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#E1E4E8\">)bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Wake up waiting writers now that we've consumed data and freed space.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    wake_up_interruptible</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">write_queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">out_unlock:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"the-poll-handler\">The Poll Handler</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> __poll_t</span><span style=\"color:#B392F0\"> mydev_poll</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, poll_table </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">wait</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    __poll_t</span><span style=\"color:#E1E4E8\"> mask </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Register this file's wait queues with the poll infrastructure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * This MUST happen before checking the condition.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Sequence with proper registration:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * 1. poll_wait registers read_queue and write_queue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * 2. We check conditions and find nothing ready</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * 3. poll infrastructure sleeps on these queues</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * 4. Write handler adds data, calls wake_up_interruptible(read_queue)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * 5. poll infrastructure wakes, calls .poll again â€” we return POLLIN</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Without step 1, step 4's wakeup would have no registered waiter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * and step 5 would never happen.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    poll_wait</span><span style=\"color:#E1E4E8\">(filp, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">read_queue,  wait);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    poll_wait</span><span style=\"color:#E1E4E8\">(filp, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">write_queue, wait);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Now check current readiness. Hold the mutex to get a consistent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * view of buffer_used and buffer_size_bytes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * NOTE: We use mutex_lock() here, NOT mutex_lock_interruptible().</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * The .poll handler should not return -ERESTARTSYS or similar â€” the</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * poll infrastructure does not handle those return codes from .poll.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * The .poll handler must complete and return a mask.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * This means .poll can block briefly on the mutex (until the read or</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * write handler finishes its critical section), but this is acceptable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * because the critical section is short.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (buffer_used </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mask </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> POLLIN </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> POLLRDNORM;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (buffer_used </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> buffer_size_bytes)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mask </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> POLLOUT </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> POLLWRNORM;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> mask;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"updated-file_operations-table\">Updated <code>file_operations</code> Table</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> file_operations mydev_fops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .owner          </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> THIS_MODULE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .open           </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_open,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .release        </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_release,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .read           </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_read,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .write          </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_write,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .unlocked_ioctl </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_ioctl,</span><span style=\"color:#6A737D\">   /* unchanged from M3 */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .poll           </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydev_poll,</span><span style=\"color:#6A737D\">    /* new in M4 */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n<h3 id=\"init-and-exit-updated\">Init and Exit (Updated)</h3>\n<h2 id=\"the-initexit-structure-from-milestone-3-doesn39t-change-the-mutex-and-wait-queues-are-statically-initialized-and-don39t-need-explicit-initcleanup-define_mutex-and-declare_wait_queue_head-do-all-the-initialization-at-compile-time\">The init/exit structure from Milestone 3 doesn&#39;t change â€” the mutex and wait queues are statically initialized and don&#39;t need explicit init/cleanup. <code>DEFINE_MUTEX</code> and <code>DECLARE_WAIT_QUEUE_HEAD</code> do all the initialization at compile time.</h2>\n<h2 id=\"process-states-and-the-scheduler-the-big-picture\">Process States and the Scheduler: The Big Picture</h2>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiag-m4-process-states-waitqueue.svg\" alt=\"Linux Process States: How Wait Queues Map to ps Output\"></p>\n<p>Understanding what <code>wait_event_interruptible</code> does to the Linux scheduler demystifies a lot of &quot;why does my server behave this way&quot; questions. Linux processes have several states visible in <code>ps</code> and <code>top</code>:</p>\n<table>\n<thead>\n<tr>\n<th>State</th>\n<th><code>ps</code> Code</th>\n<th>Meaning</th>\n<th>Kernel State</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Running</td>\n<td><code>R</code></td>\n<td>On a CPU or runnable, on the run queue</td>\n<td><code>TASK_RUNNING</code></td>\n</tr>\n<tr>\n<td>Interruptible sleep</td>\n<td><code>S</code></td>\n<td>Sleeping, can be woken by signals</td>\n<td><code>TASK_INTERRUPTIBLE</code></td>\n</tr>\n<tr>\n<td>Uninterruptible sleep</td>\n<td><code>D</code></td>\n<td>Sleeping, signals can NOT wake it</td>\n<td><code>TASK_UNINTERRUPTIBLE</code></td>\n</tr>\n<tr>\n<td>Stopped</td>\n<td><code>T</code></td>\n<td>SIGSTOP or ptrace</td>\n<td><code>TASK_STOPPED</code></td>\n</tr>\n<tr>\n<td>Zombie</td>\n<td><code>Z</code></td>\n<td>Exited, waiting for parent to reap</td>\n<td><code>EXIT_ZOMBIE</code></td>\n</tr>\n<tr>\n<td>When your read handler calls <code>wait_event_interruptible()</code>, the process transitions to <strong><code>S</code> (interruptible sleep)</strong>. This is the normal, healthy blocking state â€” <code>Ctrl+C</code> can wake it.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>The <code>D</code> state (uninterruptible sleep) is used for I/O waits that cannot be interrupted mid-operation â€” for example, waiting for a disk read to complete. Processes in <code>D</code> state do not respond to <code>SIGKILL</code>. This is why a hung NFS mount can produce unkillable processes: they&#39;re in <code>D</code> state waiting for network I/O that never completes.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>This directly explains Linux load average behavior</strong>: Linux load average counts <em>both</em> <code>R</code> (running/runnable) and <code>D</code> (uninterruptible sleep) processes. A server with 8 CPUs can have a load average of 64 if 64 processes are simultaneously blocked in <code>D</code> state on disk I/O â€” all 64 are &quot;waiting for the CPU to be able to do useful work for them,&quot; even though none are consuming CPU cycles right now. A database that shows 0% CPU but load average of 20 is I/O-bound, not CPU-bound. Your <code>wait_event_interruptible</code> produces <code>S</code> state processes â€” they contribute 0 to load average when sleeping. <code>wait_event</code> (uninterruptible variant) produces <code>D</code> state â€” it contributes to load average.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"the-thundering-herd-problem\">The Thundering Herd Problem</h2>\n<h2 id=\"imagine-100-reader-processes-are-sleeping-on-read_queue-all-waiting-for-data-one-writer-calls-write-and-adds-100-bytes-the-writer-calls-wake_up_interruptibleampread_queue-wake_up_interruptible-wakes-all-sleeping-processes-on-the-queue-all-100-readers-transition-to-task_running-and-compete-to-acquire-dev_mutex-the-one-that-wins-reads-all-100-bytes-and-releases-the-mutex-the-other-99-acquire-the-mutex-in-turn-find-buffer_used-0-and-go-back-to-sleep-this-is-the-thundering-herd-problem-a-single-wakeup-event-causes-on-processes-to-wake-contend-and-re-sleep-for-n100-with-a-fast-mutex-this-is-99-unnecessary-context-switches-and-99-unnecessary-mutex-acquisitions-the-kernel-provides-wake_up_interruptible_nrqueue-nr-to-wake-at-most-nr-waiters-and-wq_flag_exclusive-to-designate-certain-waiters-as-quotexclusivequot-wake_up_interruptible-wakes-exclusive-waiters-one-at-a-time-for-your-single-buffer-device-this-optimization-isn39t-necessary-the-buffer-either-has-data-for-all-readers-stream-device-or-for-one-reader-pipe-like-device-but-knowing-this-exists-tells-you-why-nginx39s-accept_mutex-exists-to-prevent-all-workers-from-thundering-on-a-new-connection-and-why-epoll-with-epollet-epolloneshot-is-useful-for-high-connection-servers-for-your-driver-since-the-buffer-can-hold-multiple-bytes-and-multiple-readers-can-each-read-different-portions-wake_up_interruptible-waking-all-readers-is-actually-correct-behavior-each-reader-that-wakes-finds-some-data-available-the-quotunnecessary-wakeupquot-scenario-only-occurs-when-readers-compete-for-the-same-bytes-which-doesn39t-happen-with-your-f_pos-per-file-design\">Imagine 100 reader processes are sleeping on <code>read_queue</code>, all waiting for data. One writer calls <code>write()</code> and adds 100 bytes. The writer calls <code>wake_up_interruptible(&amp;read_queue)</code>.\n<code>wake_up_interruptible</code> wakes <strong>all</strong> sleeping processes on the queue. All 100 readers transition to <code>TASK_RUNNING</code> and compete to acquire <code>dev_mutex</code>. The one that wins reads all 100 bytes and releases the mutex. The other 99 acquire the mutex in turn, find <code>buffer_used == 0</code>, and go back to sleep.\nThis is the <strong>thundering herd problem</strong>: a single wakeup event causes O(N) processes to wake, contend, and re-sleep. For N=100 with a fast mutex, this is 99 unnecessary context switches and 99 unnecessary mutex acquisitions.\nThe kernel provides <code>wake_up_interruptible_nr(queue, nr)</code> to wake at most <code>nr</code> waiters, and <code>WQ_FLAG_EXCLUSIVE</code> to designate certain waiters as &quot;exclusive&quot; â€” <code>wake_up_interruptible</code> wakes exclusive waiters one at a time. For your single-buffer device, this optimization isn&#39;t necessary â€” the buffer either has data for all readers (stream device) or for one reader (pipe-like device). But knowing this exists tells you why <code>nginx</code>&#39;s <code>accept_mutex</code> exists (to prevent all workers from thundering on a new connection) and why <code>epoll</code> with <code>EPOLLET | EPOLLONESHOT</code> is useful for high-connection servers.\nFor your driver: since the buffer can hold multiple bytes and multiple readers can each read different portions, <code>wake_up_interruptible</code> waking all readers is actually correct behavior â€” each reader that wakes finds some data available. The &quot;unnecessary wakeup&quot; scenario only occurs when readers compete for the same bytes, which doesn&#39;t happen with your f_pos-per-file design.</h2>\n<h2 id=\"updating-ioctl-for-thread-safety\">Updating ioctl for Thread Safety</h2>\n<p>The ioctl handler from Milestone 3 accesses <code>kernel_buffer</code>, <code>buffer_used</code>, and <code>buffer_size_bytes</code> without holding the mutex. Now that concurrent access is possible, every access to shared state needs the lock:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> long</span><span style=\"color:#B392F0\"> mydev_ioctl</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> int</span><span style=\"color:#FFAB70\"> cmd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> arg</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">_IOC_TYPE</span><span style=\"color:#E1E4E8\">(cmd) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> MYDEV_MAGIC)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTTY;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">_IOC_NR</span><span style=\"color:#E1E4E8\">(cmd) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTTY;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> (cmd) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MYDEV_CLEAR:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mutex_lock_interruptible</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">dev_mutex</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ERESTARTSYS;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memset</span><span style=\"color:#E1E4E8\">(kernel_buffer, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, buffer_size_bytes);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buffer_used </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * After clearing, wake writers: the buffer now has maximum space.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * No need to wake readers: clear reduces bytes_used, not increases it.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        wake_up_interruptible</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">write_queue</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">dev_mutex</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MYDEV_RESIZE: {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        __u32 new_size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">new_buffer;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">copy_from_user</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">new_size, (__u32 __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)arg, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(__u32)))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (new_size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> new_size </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 20</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        new_buffer </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kzalloc</span><span style=\"color:#E1E4E8\">(new_size, GFP_KERNEL);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">new_buffer)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOMEM;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mutex_lock_interruptible</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_mutex)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            kfree</span><span style=\"color:#E1E4E8\">(new_buffer);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ERESTARTSYS;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (buffer_used </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> new_size)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            buffer_used </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_size;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memcpy</span><span style=\"color:#E1E4E8\">(new_buffer, kernel_buffer, buffer_used);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kfree</span><span style=\"color:#E1E4E8\">(kernel_buffer);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        kernel_buffer     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_buffer;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buffer_size_bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_size;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * A resize might free space (if shrinking, content was truncated)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * or add space (if growing). Wake both queues to let waiters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * re-evaluate their conditions.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        wake_up_interruptible</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">read_queue);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        wake_up_interruptible</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">write_queue);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MYDEV_STATUS: {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        struct</span><span style=\"color:#E1E4E8\"> mydev_status status;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mutex_lock_interruptible</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_mutex))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ERESTARTSYS;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        status.buffer_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (__u32)buffer_size_bytes;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        status.bytes_used  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (__u32)buffer_used;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        status.open_count  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (__u32)</span><span style=\"color:#B392F0\">atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">open_count);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        status.read_count  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (__u32)</span><span style=\"color:#B392F0\">atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">read_count);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        status.write_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (__u32)</span><span style=\"color:#B392F0\">atomic_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">write_count);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        status._reserved   </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">copy_to_user</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydev_status __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)arg,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         &#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(status)))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTTY;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"note-the-pattern-for-mydev_status-we-copy-the-data-under-the-mutex-then-call-copy_to_user-outside-the-mutex-why-because-copy_to_user-can-sleep-if-the-user-page-is-not-present-and-needs-to-be-faulted-in-sleeping-while-holding-a-mutex-is-legal-in-process-context-but-it-holds-the-mutex-longer-than-necessary-increasing-contention-copy-to-a-local-stack-struct-under-the-mutex-then-copy-to-userspace-without-the-mutex-this-is-the-canonical-pattern\">Note the pattern for <code>MYDEV_STATUS</code>: we copy the data under the mutex, then call <code>copy_to_user</code> <em>outside</em> the mutex. Why? Because <code>copy_to_user</code> can sleep (if the user page is not present and needs to be faulted in). Sleeping while holding a mutex is legal in process context, but it holds the mutex longer than necessary, increasing contention. Copy to a local stack struct under the mutex, then copy to userspace without the mutex â€” this is the canonical pattern.</h2>\n<h2 id=\"userspace-poll-test\">Userspace Poll Test</h2>\n<p>Let&#39;s write a userspace test that exercises the poll functionality:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* poll_test.c â€” Test poll() on /dev/mydevice */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;fcntl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;poll.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEVICE</span><span style=\"color:#9ECBFF\"> \"/dev/mydevice\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> pollfd pfd;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(DEVICE, O_RDWR </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> O_NONBLOCK);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"open\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pfd.fd     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> fd;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pfd.events </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> POLLIN </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> POLLOUT;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* â”€â”€ Test 1: Initial state â€” should be writable, not readable â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> poll</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pfd, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   /* timeout=0: immediate check, no sleep */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Initial poll: revents=0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, pfd.revents);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (pfd.revents </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> POLLOUT)  </span><span style=\"color:#B392F0\">printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  PASS: POLLOUT set (buffer has space)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(pfd.revents </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> POLLIN)) </span><span style=\"color:#B392F0\">printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  PASS: POLLIN clear (buffer is empty)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* â”€â”€ Test 2: Write data, then poll â€” should become readable â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write</span><span style=\"color:#E1E4E8\">(fd, </span><span style=\"color:#9ECBFF\">\"hello world\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">11</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> poll</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pfd, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"After write poll: revents=0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, pfd.revents);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (pfd.revents </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> POLLIN)  </span><span style=\"color:#B392F0\">printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  PASS: POLLIN set (data available)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (pfd.revents </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> POLLOUT) </span><span style=\"color:#B392F0\">printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  PASS: POLLOUT set (still has space)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* â”€â”€ Test 3: Non-blocking read â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> read</span><span style=\"color:#E1E4E8\">(fd, buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(buf));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        buf</span><span style=\"color:#E1E4E8\">[ret] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Read </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> bytes: </span><span style=\"color:#79B8FF\">\\\"%s\\\"\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ret, buf);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* â”€â”€ Test 4: poll with timeout â€” wait for data from another process */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Waiting for data (5s timeout)...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Run in another terminal: echo test | sudo tee /dev/mydevice</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pfd.events </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> POLLIN;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> poll</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pfd, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">5000</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   /* 5 second timeout */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Timed out â€” no data arrived</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> (pfd.revents </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> POLLIN)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> read</span><span style=\"color:#E1E4E8\">(fd, buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(buf));</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        buf</span><span style=\"color:#E1E4E8\">[ret </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ?</span><span style=\"color:#E1E4E8\"> ret </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Data arrived: </span><span style=\"color:#79B8FF\">\\\"%s\\\"\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, buf);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Compile and run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -Wall</span><span style=\"color:#79B8FF\"> -Werror</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> poll_test</span><span style=\"color:#9ECBFF\"> poll_test.c</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./poll_test</span></span></code></pre></div>\n<hr>\n<h2 id=\"the-stress-test-4-writers-4-readers\">The Stress Test: 4 Writers + 4 Readers</h2>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiag-m4-concurrent-stress-test.svg\" alt=\"Stress Test: 4 Writers + 4 Readers Data Flow\"></p>\n<p>The acceptance criteria require a stress test with 4 concurrent writer processes and 4 concurrent reader processes, with data integrity verified by checksums. Here is a complete test harness:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">#!/bin/bash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># stress_test.sh â€” Concurrent stress test for mydevice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Architecture:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#   4 writer processes: each writes N chunks of fixed-size data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#   4 reader processes: each reads until it has collected N*chunk_size bytes total</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Data integrity: each writer generates deterministic data (byte pattern</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># based on writer ID + sequence number). All written bytes are checksummed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># with CRC or sum. All read bytes are checksummed. Totals must match.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Limitations of this simple test: because multiple writers interleave their</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># writes, the ORDER of bytes in the buffer is non-deterministic. This test</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># verifies that no bytes are lost or corrupted (checksum of all written</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># data == checksum of all read data), not that they arrive in order.</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">set</span><span style=\"color:#79B8FF\"> -e</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">DEVICE</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"/dev/mydevice\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">NUM_WRITERS</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">NUM_READERS</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">WRITES_PER_WRITER</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">100</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">CHUNK_SIZE</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">64</span><span style=\"color:#6A737D\">        # 64 bytes per write â€” fits in buffer without constant blocking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">WRITE_DIR</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">mktemp</span><span style=\"color:#79B8FF\"> -d</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">READ_DIR</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">mktemp</span><span style=\"color:#79B8FF\"> -d</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[stress] Device: </span><span style=\"color:#E1E4E8\">$DEVICE</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[stress] Writers: </span><span style=\"color:#E1E4E8\">$NUM_WRITERS</span><span style=\"color:#9ECBFF\">, Readers: </span><span style=\"color:#E1E4E8\">$NUM_READERS</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[stress] Each writer: </span><span style=\"color:#E1E4E8\">$WRITES_PER_WRITER</span><span style=\"color:#9ECBFF\"> writes Ã— </span><span style=\"color:#E1E4E8\">$CHUNK_SIZE</span><span style=\"color:#9ECBFF\"> bytes\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">TOTAL_BYTES</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$((</span><span style=\"color:#B392F0\">NUM_WRITERS</span><span style=\"color:#79B8FF\"> *</span><span style=\"color:#9ECBFF\"> WRITES_PER_WRITER</span><span style=\"color:#79B8FF\"> *</span><span style=\"color:#9ECBFF\"> CHUNK_SIZE</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[stress] Total bytes: </span><span style=\"color:#E1E4E8\">$TOTAL_BYTES</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># â”€â”€ Writer function â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">writer</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> id</span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\">$1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> outfile</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$WRITE_DIR</span><span style=\"color:#9ECBFF\">/writer_${</span><span style=\"color:#E1E4E8\">id</span><span style=\"color:#9ECBFF\">}.dat\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Generate deterministic data: writer_id repeated as bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Each writer uses a unique byte value (0x41='A', 0x42='B', etc.)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> byte_val</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$((</span><span style=\"color:#B392F0\">0x41</span><span style=\"color:#9ECBFF\"> +</span><span style=\"color:#9ECBFF\"> id</span><span style=\"color:#E1E4E8\">))   </span><span style=\"color:#6A737D\"># 'A', 'B', 'C', 'D'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> byte_char</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    byte_char</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#79B8FF\">printf</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\\\</span><span style=\"color:#9ECBFF\">$(</span><span style=\"color:#79B8FF\">printf</span><span style=\"color:#9ECBFF\"> '%03o' </span><span style=\"color:#E1E4E8\">$byte_val</span><span style=\"color:#9ECBFF\">)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">seq</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> $WRITES_PER_WRITER); </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Create a chunk: CHUNK_SIZE bytes all equal to byte_val</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        printf</span><span style=\"color:#9ECBFF\"> \"${</span><span style=\"color:#E1E4E8\">byte_char</span><span style=\"color:#9ECBFF\">}%.0s\"</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">seq</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> $CHUNK_SIZE) </span><span style=\"color:#F97583\">|</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            sudo</span><span style=\"color:#9ECBFF\"> tee</span><span style=\"color:#79B8FF\"> -a</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$outfile</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> >></span><span style=\"color:#9ECBFF\"> /dev/null</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        printf</span><span style=\"color:#9ECBFF\"> \"${</span><span style=\"color:#E1E4E8\">byte_char</span><span style=\"color:#9ECBFF\">}%.0s\"</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">seq</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> $CHUNK_SIZE) </span><span style=\"color:#F97583\">|</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            sudo</span><span style=\"color:#9ECBFF\"> tee</span><span style=\"color:#79B8FF\"> -a</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$DEVICE</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Small delay to increase interleaving</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        sleep</span><span style=\"color:#9ECBFF\"> 0.</span><span style=\"color:#E1E4E8\">$((</span><span style=\"color:#B392F0\">RANDOM</span><span style=\"color:#9ECBFF\"> %</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    done</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"[writer </span><span style=\"color:#E1E4E8\">$id</span><span style=\"color:#9ECBFF\">] done (${</span><span style=\"color:#E1E4E8\">WRITES_PER_WRITER</span><span style=\"color:#9ECBFF\">} writes Ã— ${</span><span style=\"color:#E1E4E8\">CHUNK_SIZE</span><span style=\"color:#9ECBFF\">} bytes)\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># â”€â”€ Reader function â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">reader</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> id</span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\">$1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> outfile</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$READ_DIR</span><span style=\"color:#9ECBFF\">/reader_${</span><span style=\"color:#E1E4E8\">id</span><span style=\"color:#9ECBFF\">}.dat\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> bytes_per_reader</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$((</span><span style=\"color:#B392F0\">TOTAL_BYTES</span><span style=\"color:#9ECBFF\"> /</span><span style=\"color:#9ECBFF\"> NUM_READERS</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    local</span><span style=\"color:#E1E4E8\"> collected</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> [ $collected </span><span style=\"color:#F97583\">-lt</span><span style=\"color:#E1E4E8\"> $bytes_per_reader ]; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Read whatever is available (blocks until data present)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        local</span><span style=\"color:#E1E4E8\"> chunk</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        chunk</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> dd</span><span style=\"color:#9ECBFF\"> if=\"</span><span style=\"color:#E1E4E8\">$DEVICE</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\"> bs=</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#9ECBFF\"> count=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> [ </span><span style=\"color:#F97583\">-n</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$chunk</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            printf</span><span style=\"color:#9ECBFF\"> \"%s\"</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$chunk</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> >></span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$outfile</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            collected</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$((</span><span style=\"color:#B392F0\">collected</span><span style=\"color:#9ECBFF\"> +</span><span style=\"color:#E1E4E8\"> ${</span><span style=\"color:#F97583\">#</span><span style=\"color:#E1E4E8\">chunk}))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        fi</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    done</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"[reader </span><span style=\"color:#E1E4E8\">$id</span><span style=\"color:#9ECBFF\">] done (${</span><span style=\"color:#E1E4E8\">collected</span><span style=\"color:#9ECBFF\">} bytes collected)\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># â”€â”€ Run stress test â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[stress] Starting writers and readers...\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Start readers first (they'll block waiting for data)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">seq</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> $((</span><span style=\"color:#B392F0\">NUM_READERS-1</span><span style=\"color:#E1E4E8\">))); </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    reader</span><span style=\"color:#E1E4E8\"> $i &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Start writers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">seq</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> $((</span><span style=\"color:#B392F0\">NUM_WRITERS-1</span><span style=\"color:#E1E4E8\">))); </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    writer</span><span style=\"color:#E1E4E8\"> $i &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Wait for all background jobs</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[stress] All processes completed\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># â”€â”€ Checksum verification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[stress] Computing checksums...\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Checksum of all written data (concatenate all writer output files)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">WRITE_CHECKSUM</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$WRITE_DIR</span><span style=\"color:#9ECBFF\">\"/writer_</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#9ECBFF\">.dat</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> md5sum</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> cut</span><span style=\"color:#79B8FF\"> -d</span><span style=\"color:#9ECBFF\">' '</span><span style=\"color:#79B8FF\"> -f1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">READ_CHECKSUM</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$READ_DIR</span><span style=\"color:#9ECBFF\">\"/reader_</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#9ECBFF\">.dat</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> md5sum</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> cut</span><span style=\"color:#79B8FF\"> -d</span><span style=\"color:#9ECBFF\">' '</span><span style=\"color:#79B8FF\"> -f1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[stress] Written data MD5: </span><span style=\"color:#E1E4E8\">$WRITE_CHECKSUM</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[stress] Read data MD5:    </span><span style=\"color:#E1E4E8\">$READ_CHECKSUM</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">WRITE_TOTAL</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$WRITE_DIR</span><span style=\"color:#9ECBFF\">\"/writer_</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#9ECBFF\">.dat</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> wc</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">READ_TOTAL</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$READ_DIR</span><span style=\"color:#9ECBFF\">\"/reader_</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#9ECBFF\">.dat</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> wc</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[stress] Written bytes: </span><span style=\"color:#E1E4E8\">$WRITE_TOTAL</span><span style=\"color:#9ECBFF\"> (expected </span><span style=\"color:#E1E4E8\">$TOTAL_BYTES</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[stress] Read bytes:    </span><span style=\"color:#E1E4E8\">$READ_TOTAL</span><span style=\"color:#9ECBFF\"> (expected </span><span style=\"color:#E1E4E8\">$TOTAL_BYTES</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> [ </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$WRITE_TOTAL</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> -eq</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$READ_TOTAL</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"[stress] PASS: byte counts match\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"[stress] FAIL: byte count mismatch!\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    rm</span><span style=\"color:#79B8FF\"> -rf</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$WRITE_DIR</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$READ_DIR</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    exit</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Note: due to interleaving, the exact byte ordering may differ between</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># written and read streams. The meaningful verification is:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 1. No bytes are lost: total written == total read</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 2. No kernel oops, warnings, or panics in dmesg during the test</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 3. dmesg shows no mutex warnings, deadlock warnings, or data corruption</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[stress] Checking dmesg for kernel warnings...\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#B392F0\"> dmesg</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tail</span><span style=\"color:#79B8FF\"> -50</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -iE</span><span style=\"color:#9ECBFF\"> \"(BUG|WARNING|OOPS|panic|deadlock|corruption)\"</span><span style=\"color:#E1E4E8\"> ; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"[stress] FAIL: kernel warnings detected\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    exit</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"[stress] PASS: no kernel warnings\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">rm</span><span style=\"color:#79B8FF\"> -rf</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$WRITE_DIR</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$READ_DIR</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"[stress] All tests PASSED\"</span></span></code></pre></div>\n<p>For a more rigorous byte-level integrity check (verifying that every specific byte written by writer N is received by some reader, with no mutations), use this C test program:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* stress_c.c â€” C-based stress test with per-byte verification */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;fcntl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;pthread.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/types.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEVICE</span><span style=\"color:#9ECBFF\">         \"/dev/mydevice\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> NUM_WRITERS</span><span style=\"color:#79B8FF\">    4</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> NUM_READERS</span><span style=\"color:#79B8FF\">    4</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> WRITES_PER_W</span><span style=\"color:#79B8FF\">   200</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CHUNK_SIZE</span><span style=\"color:#79B8FF\">     32</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Verification strategy:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Each writer writes a recognizable 4-byte header (0xWW + seq number)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * followed by (CHUNK_SIZE - 4) bytes of the writer's fill byte.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Readers collect all bytes and verify structure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Simpler approach: each writer writes N*CHUNK_SIZE bytes of a unique</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * fill value. Total written per writer-value is tracked. Total read</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * per value must match. This proves no bytes are added or lost.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#FFAB70\"> bytes_written</span><span style=\"color:#E1E4E8\">[NUM_WRITERS] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#FFAB70\"> bytes_read_by_value</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">]   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> pthread_mutex_t</span><span style=\"color:#E1E4E8\"> stats_mutex         </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PTHREAD_MUTEX_INITIALIZER;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">writer_thread</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">arg</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int*</span><span style=\"color:#E1E4E8\">)arg;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(DEVICE, O_WRONLY);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"open writer\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> fill </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#9ECBFF\">'A'</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> id);</span><span style=\"color:#6A737D\">   /* each writer uses unique byte */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> chunk</span><span style=\"color:#E1E4E8\">[CHUNK_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(chunk, fill, CHUNK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> written </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> WRITES_PER_W; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        ssize_t</span><span style=\"color:#E1E4E8\"> n;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        do</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> write</span><span style=\"color:#E1E4E8\">(fd, chunk </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> (CHUNK_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> (written </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> CHUNK_SIZE)),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                      CHUNK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> EAGAIN) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"write\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">goto</span><span style=\"color:#E1E4E8\"> done; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        written </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">done:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">stats_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    bytes_written</span><span style=\"color:#E1E4E8\">[id] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> written;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">stats_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Writer </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> done: </span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\"> bytes of 0x</span><span style=\"color:#79B8FF\">%02X\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, id, (</span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\">)written, fill);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">reader_thread</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">arg</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)arg;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(DEVICE, O_RDONLY);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"open reader\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> target </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)NUM_WRITERS </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> WRITES_PER_W </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> CHUNK_SIZE </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> NUM_READERS;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> collected </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#FFAB70\"> local_count</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (collected </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> target) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        ssize_t</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> read</span><span style=\"color:#E1E4E8\">(fd, buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(buf));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EINTR) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"read\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> n; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            local_count</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">[i]]</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        collected </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">stats_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 256</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        bytes_read_by_value</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">+=</span><span style=\"color:#FFAB70\"> local_count</span><span style=\"color:#E1E4E8\">[i];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">stats_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_t</span><span style=\"color:#FFAB70\"> writers</span><span style=\"color:#E1E4E8\">[NUM_WRITERS], </span><span style=\"color:#FFAB70\">readers</span><span style=\"color:#E1E4E8\">[NUM_READERS];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#FFAB70\"> ids</span><span style=\"color:#E1E4E8\">[NUM_WRITERS];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Stress test: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> writers, </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> readers, </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> writes each of </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           NUM_WRITERS, NUM_READERS, WRITES_PER_W, CHUNK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> NUM_READERS; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">readers</span><span style=\"color:#E1E4E8\">[i], </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, reader_thread, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> NUM_WRITERS; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        ids</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">writers</span><span style=\"color:#E1E4E8\">[i], </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, writer_thread, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">ids</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> NUM_WRITERS; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">pthread_join</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">writers</span><span style=\"color:#E1E4E8\">[i], </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> NUM_READERS; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">pthread_join</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">readers</span><span style=\"color:#E1E4E8\">[i], </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">=== Verification ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> pass </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> NUM_WRITERS; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint8_t</span><span style=\"color:#E1E4E8\"> fill </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#9ECBFF\">'A'</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> i);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Writer </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (0x</span><span style=\"color:#79B8FF\">%02X</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">%c</span><span style=\"color:#9ECBFF\">'): wrote </span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\">, read </span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\"> â€” </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               i, fill, (</span><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\">)fill,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               (</span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">bytes_written</span><span style=\"color:#E1E4E8\">[i],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               (</span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">bytes_read_by_value</span><span style=\"color:#E1E4E8\">[fill],</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">               bytes_written</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#FFAB70\"> bytes_read_by_value</span><span style=\"color:#E1E4E8\">[fill] </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"PASS\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"FAIL\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bytes_written</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#FFAB70\"> bytes_read_by_value</span><span style=\"color:#E1E4E8\">[fill]) pass </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, pass </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"ALL CHECKS PASSED\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"SOME CHECKS FAILED\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> pass </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> :</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Compile and run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -Wall</span><span style=\"color:#79B8FF\"> -Werror</span><span style=\"color:#79B8FF\"> -pthread</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> stress_c</span><span style=\"color:#9ECBFF\"> stress_c.c</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> insmod</span><span style=\"color:#9ECBFF\"> mydevice.ko</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> chmod</span><span style=\"color:#79B8FF\"> 666</span><span style=\"color:#9ECBFF\"> /dev/mydevice</span><span style=\"color:#6A737D\">   # or run as root</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./stress_c</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Watch for kernel panics/oops during the test:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dmesg</span><span style=\"color:#79B8FF\"> -w</span><span style=\"color:#E1E4E8\"> &#x26;</span></span></code></pre></div>\n<hr>\n<h2 id=\"three-level-view-blocking-read-in-depth\">Three-Level View: Blocking Read in Depth</h2>\n<h2 id=\"when-process-a-calls-read-on-your-empty-device-and-blocks-while-process-b-writes-data-level-1-applications-process-a-calls-readfd-buf-100-blocks-process-b-calls-writefd-data-50-completes-immediately-process-a39s-read-returns-50-bytes-level-2-kernel-scheduler-process-a-calls-sys_read-mydev_read-finds-buffer_used-0-releases-dev_mutex-calls-wait_event_interruptibleread_queue-sets-state-task_interruptible-calls-schedule-the-scheduler-removes-a-from-the-run-queue-and-runs-another-task-process-b-calls-sys_write-mydev_write-acquires-dev_mutex-copies-50-bytes-sets-buffer_used-50-calls-wake_up_interruptibleampread_queue-this-sets-a39s-state-back-to-task_running-and-places-a-on-the-run-queue-b-releases-the-mutex-and-returns-the-scheduler-eventually-selects-a-to-run-a-resumes-inside-wait_event_interruptible-re-acquires-dev_mutex-re-checks-buffer_used-gt-0-now-true-exits-the-wait-loop-copies-50-bytes-to-userspace-via-copy_to_user-returns-50-level-3-hardware-when-schedule-is-called-the-cpu-performs-a-context-switch-saves-the-current-register-state-instruction-pointer-stack-pointer-general-purpose-registers-fpu-state-if-dirty-to-process-a39s-thread_struct-in-its-task_struct-loads-process-b39s-saved-register-state-switches-the-page-table-base-register-cr3-on-x86_64-to-b39s-page-directory-the-tlb-is-largely-flushed-with-pcid-optimization-partially-invalidated-process-b39s-code-now-runs-from-where-it-last-left-off-the-wake_up_interruptible-call-generates-a-store-release-memory-barrier-before-adding-a-back-to-the-run-queue-ensuring-the-buffer_used-50-write-is-visible-to-all-cpus-before-a-might-observe-it-on-x86-this-is-a-lock-prefixed-instruction-on-arm64-it39s-an-explicit-stlr-store-release-or-dmb-data-memory-barrier-without-this-a-might-wake-up-and-read-a-stale-buffer_used-value-from-its-cache\">When process A calls <code>read()</code> on your empty device and blocks, while process B writes data:\n<strong>Level 1 â€” Applications</strong>:\nProcess A calls <code>read(fd, buf, 100)</code> â€” blocks. Process B calls <code>write(fd, data, 50)</code> â€” completes immediately. Process A&#39;s <code>read()</code> returns 50 bytes.\n<strong>Level 2 â€” Kernel / Scheduler</strong>:\nProcess A calls <code>sys_read</code> â†’ <code>mydev_read</code> â†’ finds <code>buffer_used == 0</code> â†’ releases <code>dev_mutex</code> â†’ calls <code>wait_event_interruptible(read_queue, ...)</code> â†’ sets state <code>TASK_INTERRUPTIBLE</code> â†’ calls <code>schedule()</code>. The scheduler removes A from the run queue and runs another task.\nProcess B calls <code>sys_write</code> â†’ <code>mydev_write</code> â†’ acquires <code>dev_mutex</code> â†’ copies 50 bytes â†’ sets <code>buffer_used = 50</code> â†’ calls <code>wake_up_interruptible(&amp;read_queue)</code>. This sets A&#39;s state back to <code>TASK_RUNNING</code> and places A on the run queue. B releases the mutex and returns.\nThe scheduler eventually selects A to run. A resumes inside <code>wait_event_interruptible</code>, re-acquires <code>dev_mutex</code>, re-checks <code>buffer_used &gt; 0</code> (now true), exits the wait loop, copies 50 bytes to userspace via <code>copy_to_user</code>, returns 50.\n<strong>Level 3 â€” Hardware</strong>:\nWhen <code>schedule()</code> is called, the CPU performs a <strong>context switch</strong>: saves the current register state (instruction pointer, stack pointer, general-purpose registers, FPU state if dirty) to process A&#39;s <code>thread_struct</code> in its <code>task_struct</code>. Loads process B&#39;s saved register state. Switches the page table base register (<code>CR3</code> on x86_64) to B&#39;s page directory. The TLB is largely flushed (with PCID optimization, partially invalidated). Process B&#39;s code now runs from where it last left off.\nThe <code>wake_up_interruptible()</code> call generates a <strong>store-release</strong> memory barrier before adding A back to the run queue, ensuring the <code>buffer_used = 50</code> write is visible to all CPUs before A might observe it. On x86, this is a <code>LOCK</code> prefixed instruction; on ARM64, it&#39;s an explicit <code>stlr</code> (store-release) or <code>dmb</code> (data memory barrier). Without this, A might wake up and read a stale <code>buffer_used</code> value from its cache.</h2>\n<h2 id=\"hardware-soul-the-cache-line-dance\">Hardware Soul: The Cache Line Dance</h2>\n<p>Every time your write handler executes <code>buffer_used += bytes_to_copy</code> and then calls <code>wake_up_interruptible</code>, a specific sequence of cache events fires:\n<strong><code>buffer_used</code> access</strong> (a <code>size_t</code> at some address in BSS):</p>\n<ul>\n<li>Write handler running on CPU 0 has the cache line containing <code>buffer_used</code> in <strong>M (Modified) state</strong> in CPU 0&#39;s L1 cache</li>\n<li>If CPU 1 is simultaneously in the read handler checking <code>buffer_used</code>, the MESI protocol requires CPU 0&#39;s L1 to supply the value to CPU 1 via the L3 (shared last-level cache) or inter-processor communication. This cache line invalidation and transfer costs ~40-100 ns on modern x86 â€” cheap for one access, expensive if done millions of times per second\n<strong><code>kernel_buffer</code> writes</strong> (the actual data bytes):</li>\n<li>Sequential writes to <code>kernel_buffer + buffer_used</code> at offsets 0, 32, 64, etc. are perfectly cache-friendly â€” the hardware prefetcher detects the sequential access pattern and brings cache lines ahead of the write pointer. With a 4KB buffer, the entire buffer fits in L1 cache (typically 32KB, so 1/8 full)</li>\n<li><code>copy_from_user</code> on x86_64 uses <code>rep movsb</code> for this size, which the hardware optimizes as a fast string copy with near-peak memory bandwidth\n<strong><code>wake_up_interruptible</code></strong> accesses the wait queue head (<code>read_queue</code>):</li>\n<li>The spinlock inside the wait queue head must be acquired. On a multicore system where many processes might be calling <code>read()</code> simultaneously, this spinlock is a potential contention point. The lock acquisition uses <code>lock xchg</code> or <code>lock cmpxchg</code>, requiring exclusive cache line ownership â€” this bounces the cache line between cores if multiple cores try to acquire it simultaneously</li>\n<li>For your driver at moderate concurrency (4-8 processes), this is negligible. At thousands of operations per second on 64 cores, this would be the bottleneck\n<strong>Context switches</strong> (when a reader goes to sleep and a writer wakes it):</li>\n<li>A context switch saves/restores ~200 bytes of register state to the <code>task_struct</code>. The <code>task_struct</code> itself is typically in L2 or L3 cache for recently-active tasks. A full context switch costs ~2-4 Âµs on modern hardware, dominated by cache pollution from loading the new process&#39;s working set, TLB refill (even with PCID, some entries are invalidated), and pipeline flushing</li>\n</ul>\n<hr>\n<h2 id=\"common-pitfalls-in-concurrent-kernel-code\">Common Pitfalls in Concurrent Kernel Code</h2>\n<h3 id=\"holding-a-mutex-while-sleeping-in-wait_event_interruptible\">Holding a Mutex While Sleeping in <code>wait_event_interruptible</code></h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* DEADLY DEADLOCK â€” do not do this */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">dev_mutex</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">wait_event_interruptible</span><span style=\"color:#E1E4E8\">(read_queue, buffer_used </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* The writer needs dev_mutex to update buffer_used.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   The writer calls mutex_lock(&#x26;dev_mutex) â€” blocks.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   Reader waits for buffer_used to change â€” which requires writer to run.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   Writer waits for mutex â€” which reader holds.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   Classic circular wait = deadlock. Machine hangs. */</span></span></code></pre></div>\n<p>The fix is always: release the mutex before waiting, reacquire after.</p>\n<h3 id=\"not-re-checking-the-condition-after-waking-manual-wait-loop\">Not Re-checking the Condition After Waking (Manual Wait Loop)</h3>\n<p>If you implement a manual wait loop instead of <code>wait_event_interruptible</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* BUGGY â€” spurious wakeup not handled */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">dev_mutex</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">wait_event_interruptible</span><span style=\"color:#E1E4E8\">(read_queue, buffer_used </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">dev_mutex</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* WARNING: another reader might have consumed all data between</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   the wakeup and our mutex_lock. buffer_used might now be 0 again.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   We must re-check! */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* CORRECT */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">dev_mutex</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">wait_event_interruptible</span><span style=\"color:#E1E4E8\">(read_queue, buffer_used </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ERESTARTSYS;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">dev_mutex</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* wait_event_interruptible guarantees the condition is true when it</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   returns 0, because it re-checks under the wait queue's internal lock. */</span></span></code></pre></div>\n<h3 id=\"returning-0-instead-of-eagain-for-non-blocking-empty-read\">Returning 0 Instead of -EAGAIN for Non-Blocking Empty Read</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG â€” 0 signals EOF; programs like cat will exit normally */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (filp</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">f_flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> O_NONBLOCK)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   /* wrong! cat thinks the \"file\" is done */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* CORRECT */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (filp</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">f_flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> O_NONBLOCK)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EAGAIN;</span><span style=\"color:#6A737D\">  /* \"no data now, try later\" */</span></span></code></pre></div>\n<p><code>0</code> from <code>read()</code> means <strong>end of file</strong> â€” there will never be more data. <code>-EAGAIN</code> (as <code>errno = EAGAIN</code>) means &quot;no data now, but there might be later.&quot; These have completely different semantics to userspace programs. Returning 0 for an empty device means <code>cat</code> exits, poll-based event loops deregister the fd, and <code>read()</code> loops terminate. <code>-EAGAIN</code> means &quot;keep the fd alive, check again.&quot;</p>\n<h3 id=\"calling-poll_wait-after-the-condition-check\">Calling <code>poll_wait()</code> After the Condition Check</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG â€” race window between condition check and registration */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">dev_mutex</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (buffer_used </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mask </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> POLLIN;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">dev_mutex</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">poll_wait</span><span style=\"color:#E1E4E8\">(filp, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">read_queue</span><span style=\"color:#E1E4E8\">, wait);</span><span style=\"color:#6A737D\">  /* â† too late! wakeup could have been missed */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> mask;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* CORRECT â€” register first, then check */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">poll_wait</span><span style=\"color:#E1E4E8\">(filp, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">read_queue</span><span style=\"color:#E1E4E8\">, wait);</span><span style=\"color:#6A737D\">  /* register interest first */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">dev_mutex</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (buffer_used </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mask </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> POLLIN;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">dev_mutex</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> mask;</span></span></code></pre></div>\n<h3 id=\"not-using-mutex_lock-non-interruptible-in-poll\">Not Using <code>mutex_lock()</code> (Non-Interruptible) in <code>.poll</code></h3>\n<p>The <code>.poll</code> handler must return a mask â€” it cannot return an error code like <code>-ERESTARTSYS</code>. If you use <code>mutex_lock_interruptible()</code> in <code>.poll</code> and a signal arrives, you can&#39;t correctly signal this to the caller. Use <code>mutex_lock()</code> (non-interruptible) in <code>.poll</code>. The critical section in <code>.poll</code> is intentionally short (just reading two variables), so the wait should be microseconds at most.</p>\n<h3 id=\"forgetting-to-wake-write_queue-after-read\">Forgetting to Wake <code>write_queue</code> After Read</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* INCOMPLETE â€” writers sleeping on a full buffer never wake after a read */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydev_read</span><span style=\"color:#E1E4E8\">(...)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ... read bytes ... */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    atomic_inc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">read_count);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev_mutex);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> bytes_to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* MISSING: wake_up_interruptible(&#x26;write_queue) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"if-the-buffer-was-full-before-the-read-writers-are-sleeping-on-write_queue-after-the-read-frees-space-you-must-call-wake_up_interruptibleampwrite_queue-or-writers-remain-asleep-indefinitely-always-wake-the-opposite-queue-after-modifying-buffer_used\">If the buffer was full before the read, writers are sleeping on <code>write_queue</code>. After the read frees space, you must call <code>wake_up_interruptible(&amp;write_queue)</code> or writers remain asleep indefinitely. Always wake the opposite queue after modifying <code>buffer_used</code>.</h2>\n<h2 id=\"knowledge-cascade-what-you39ve-just-unlocked\">Knowledge Cascade: What You&#39;ve Just Unlocked</h2>\n<h2 id=\"-process-states-explain-load-average-cross-domain-system-administration-now-you-understand-that-wait_event_interruptible-puts-processes-in-task_interruptible-s-state-while-wait_event-uninterruptible-uses-task_uninterruptible-d-state-linux39s-load-average-counts-both-r-and-d-processes-which-is-why-a-disk-bound-server-shows-high-load-average-at-0-cpu-when-top-shows-many-d-processes-they39re-waiting-in-uninterruptible-sleep-typically-for-disk-or-network-io-when-top-shows-many-s-processes-like-your-readers-sleeping-on-an-empty-device-they-contribute-0-to-load-average-because-they39re-interruptibly-sleeping-this-is-a-subtle-but-important-distinction-a-server-running-your-blocking-read-device-will-show-s-state-processes-during-blocking-reads-not-d-state-so-it-won39t-inflate-load-average-a-disk-driver-using-wait_event-uninterruptible-will-inflate-load-average-erestartsys-connects-to-the-signal-handler-prerequisite-same-domain-kernel-signal-path-in-your-signal-handler-prerequisite-project-you-encountered-errno-eintr-when-a-signal-interrupted-a-syscall-now-you-know-the-mechanism-your-driver-returned-erestartsys-the-kernel39s-syscall-exit-path-detected-a-pending-signal-and-if-sa_restart-wasn39t-set-on-the-signal-handler-it-converted-erestartsys-to-eintr-before-returning-to-userspace-this-is-why-eintr-safe-loops-in-c-wrapping-read-in-a-do-n-read-while-n-lt-0-ampamp-errno-eintr-are-necessary-your-driver-is-correctly-propagating-signal-interruption-and-userspace-needs-to-decide-whether-to-restart-or-handle-it-your-poll-handler-is-the-foundation-of-every-event-loop-cross-domain-nodejs-nginx-go-the-poll_wait-registration-mechanism-you-just-implemented-is-exactly-what-epoll-uses-internally-when-an-epoll-fd-monitors-your-device-with-epoll_ctlepfd-epoll_ctl_add-devfd-the-kernel-calls-your-poll-handler-via-ep_item_poll-your-poll_wait-registers-epoll39s-internal-wait-queue-callback-with-read_queue-and-write_queue-when-your-write-handler-calls-wake_up_interruptibleampread_queue-it-fires-the-epoll-callback-which-wakes-the-epoll_wait-call-which-returns-the-device-fd-as-ready-this-is-the-o1-event-notification-that-makes-epoll-scale-to-millions-of-file-descriptors-no-polling-loop-just-wait-queue-callbacks-nodejs39s-libuv-go39s-netpoller-and-nginx-all-sit-on-top-of-this-exact-mechanism-the-poll-handler-you-just-wrote-is-the-leaf-node-in-a-chain-that-enables-all-modern-high-performance-io-your-driver-is-now-a-go-channel-cross-domain-concurrent-programming-the-bounded-buffer-you-just-built-with-a-mutex-protecting-shared-state-blocking-producers-when-full-blocking-consumers-when-empty-and-waking-the-other-side-on-state-change-is-the-exact-implementation-of-a-go-buffered-channel-makechan-t-n-the-go-runtime-implements-channels-with-a-mutex-a-wait-queue-for-senders-your-write_queue-and-a-wait-queue-for-receivers-your-read_queue-java39s-arrayblockingqueue-python39s-queuequeue-and-posix-pipes-all-implement-this-same-producer-consumer-pattern-when-you-next-read-go39s-channel-implementation-in-runtimechango-you39ll-see-sudog-waiting-goroutine-descriptors-in-a-sendreceive-queue-the-go-level-equivalent-of-your-wait_queue_entry_t-instances-in-read_queue-and-write_queue-the-kernel-c-implementation-you-just-wrote-is-the-conceptual-ancestor-of-all-of-them-thundering-herd-explains-nginx39s-accept_mutex-and-linux-4539s-epollexclusive-cross-domain-web-servers-the-thundering-herd-you-encountered-with-wake_up_interruptible-waking-all-readers-is-the-exact-problem-that-afflicted-early-multi-process-web-servers-when-a-new-tcp-connection-arrives-all-worker-processes-sleeping-in-accept-wake-up-but-only-one-gets-the-connection-the-others-re-sleep-after-doing-useless-work-nginx-added-accept_mutex-to-serialize-connection-acceptance-linux-45-added-epollexclusive-to-epoll-when-multiple-processes-epoll-wait-on-the-same-fd-with-epollexclusive-only-one-is-woken-per-event-for-your-device-wake_up_interruptible_nrampread_queue-1-would-wake-exactly-one-reader-appropriate-if-the-device-is-pipe-like-one-reader-gets-all-the-bytes-wake_up_interruptible-all-waiters-is-appropriate-if-the-device-is-broadcast-like-the-choice-of-which-wake-mechanism-to-use-is-an-architectural-decision-about-your-device39s-concurrency-semantics-kernel-synchronization-patterns-database-locking-cross-domain-databases-the-pattern-you-just-implemented-quotacquire-lock-check-condition-release-lock-sleep-re-acquire-lock-re-check-conditionquot-is-identical-to-how-database-engines-implement-row-level-blocking-waits-postgresql39s-lockacquire-function-uses-a-heavyweight-lock-mechanism-with-a-wait-list-lockrelease-calls-procwakeup-to-wake-a-waiting-process-exactly-your-wake_up_interruptible-after-modifying-buffer_used-mysql39s-innodb-uses-a-similar-structure-with-lock_wait_suspend_thread-corresponding-to-your-wait_event_interruptible-the-concurrency-primitives-you-just-implemented-in-200-lines-of-c-are-the-conceptual-foundation-of-mvcc-row-locking-and-deadlock-detection-in-every-major-database\"><strong>â†’ Process States Explain Load Average (cross-domain: system administration)</strong>\nNow you understand that <code>wait_event_interruptible</code> puts processes in <code>TASK_INTERRUPTIBLE</code> (<code>S</code> state), while <code>wait_event</code> (uninterruptible) uses <code>TASK_UNINTERRUPTIBLE</code> (<code>D</code> state). Linux&#39;s load average counts both <code>R</code> and <code>D</code> processes â€” which is why a disk-bound server shows high load average at 0% CPU. When <code>top</code> shows many <code>D</code> processes, they&#39;re waiting in uninterruptible sleep (typically for disk or network I/O). When <code>top</code> shows many <code>S</code> processes (like your readers sleeping on an empty device), they contribute 0 to load average because they&#39;re interruptibly sleeping. This is a subtle but important distinction: a server running your blocking-read device will show <code>S</code>-state processes during blocking reads, not <code>D</code>-state, so it won&#39;t inflate load average. A disk driver using <code>wait_event</code> (uninterruptible) <em>will</em> inflate load average.\n<strong>â†’ -ERESTARTSYS Connects to the signal-handler Prerequisite (same domain: kernel signal path)</strong>\nIn your <code>signal-handler</code> prerequisite project, you encountered <code>errno == EINTR</code> when a signal interrupted a syscall. Now you know the mechanism: your driver returned <code>-ERESTARTSYS</code>, the kernel&#39;s syscall exit path detected a pending signal, and if <code>SA_RESTART</code> wasn&#39;t set on the signal handler, it converted <code>-ERESTARTSYS</code> to <code>-EINTR</code> before returning to userspace. This is why <code>EINTR</code>-safe loops in C (wrapping <code>read()</code> in a <code>do { n = read(...); } while (n &lt; 0 &amp;&amp; errno == EINTR)</code>) are necessary: your driver is correctly propagating signal interruption, and userspace needs to decide whether to restart or handle it.\n<strong>â†’ Your .poll Handler Is the Foundation of Every Event Loop (cross-domain: Node.js, nginx, Go)</strong>\nThe <code>poll_wait()</code> registration mechanism you just implemented is exactly what <code>epoll</code> uses internally. When an epoll fd monitors your device with <code>epoll_ctl(epfd, EPOLL_CTL_ADD, devfd, ...)</code>, the kernel calls your <code>.poll</code> handler via <code>ep_item_poll()</code>. Your <code>poll_wait()</code> registers epoll&#39;s internal wait queue callback with <code>read_queue</code> and <code>write_queue</code>. When your write handler calls <code>wake_up_interruptible(&amp;read_queue)</code>, it fires the epoll callback, which wakes the <code>epoll_wait()</code> call, which returns the device fd as ready. This is the O(1) event notification that makes <code>epoll</code> scale to millions of file descriptors: no polling loop, just wait queue callbacks. Node.js&#39;s <code>libuv</code>, Go&#39;s <code>netpoller</code>, and nginx all sit on top of this exact mechanism. The <code>.poll</code> handler you just wrote is the leaf node in a chain that enables all modern high-performance I/O.\n<strong>â†’ Your Driver Is Now a Go Channel (cross-domain: concurrent programming)</strong>\nThe bounded buffer you just built â€” with a mutex protecting shared state, blocking producers when full, blocking consumers when empty, and waking the other side on state change â€” is the exact implementation of a <strong>Go buffered channel</strong> (<code>make(chan T, N)</code>). The Go runtime implements channels with a mutex, a wait queue for senders (your <code>write_queue</code>), and a wait queue for receivers (your <code>read_queue</code>). Java&#39;s <code>ArrayBlockingQueue</code>, Python&#39;s <code>queue.Queue</code>, and POSIX pipes all implement this same producer-consumer pattern. When you next read Go&#39;s channel implementation in <code>runtime/chan.go</code>, you&#39;ll see <code>sudog</code> (waiting goroutine descriptors) in a send/receive queue â€” the Go-level equivalent of your <code>wait_queue_entry_t</code> instances in <code>read_queue</code> and <code>write_queue</code>. The kernel C implementation you just wrote is the conceptual ancestor of all of them.\n<strong>â†’ Thundering Herd Explains nginx&#39;s accept_mutex and Linux 4.5&#39;s EPOLLEXCLUSIVE (cross-domain: web servers)</strong>\nThe thundering herd you encountered with <code>wake_up_interruptible</code> waking all readers is the exact problem that afflicted early multi-process web servers: when a new TCP connection arrives, all worker processes (sleeping in <code>accept()</code>) wake up, but only one gets the connection. The others re-sleep after doing useless work. nginx added <code>accept_mutex</code> to serialize connection acceptance. Linux 4.5 added <code>EPOLLEXCLUSIVE</code> to epoll â€” when multiple processes epoll-wait on the same fd with <code>EPOLLEXCLUSIVE</code>, only one is woken per event. For your device, <code>wake_up_interruptible_nr(&amp;read_queue, 1)</code> would wake exactly one reader â€” appropriate if the device is pipe-like (one reader gets all the bytes). <code>wake_up_interruptible</code> (all waiters) is appropriate if the device is broadcast-like. The choice of which wake mechanism to use is an architectural decision about your device&#39;s concurrency semantics.\n<strong>â†’ Kernel Synchronization Patterns â†’ Database Locking (cross-domain: databases)</strong>\nThe pattern you just implemented â€” &quot;acquire lock, check condition, release lock, sleep, re-acquire lock, re-check condition&quot; â€” is identical to how database engines implement row-level blocking waits. PostgreSQL&#39;s <code>LockAcquire()</code> function uses a heavyweight lock mechanism with a wait list; <code>LockRelease()</code> calls <code>ProcWakeup()</code> to wake a waiting process â€” exactly your <code>wake_up_interruptible</code> after modifying <code>buffer_used</code>. MySQL&#39;s InnoDB uses a similar structure with <code>lock_wait_suspend_thread()</code> corresponding to your <code>wait_event_interruptible</code>. The concurrency primitives you just implemented in 200 lines of C are the conceptual foundation of MVCC, row locking, and deadlock detection in every major database.</h2>\n<h2 id=\"acceptance-criteria-checkpoint\">Acceptance Criteria Checkpoint</h2>\n<p>Before declaring this milestone complete, verify every item:</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> <code>make</code> completes with zero warnings (<code>ccflags-y := -Werror</code>)</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>DEFINE_MUTEX(dev_mutex)</code> declared at module level; <code>DECLARE_WAIT_QUEUE_HEAD(read_queue)</code> and <code>DECLARE_WAIT_QUEUE_HEAD(write_queue)</code> declared</li>\n<li><input disabled=\"\" type=\"checkbox\"> Every access to <code>kernel_buffer</code>, <code>buffer_used</code>, <code>buffer_size_bytes</code> in read/write/ioctl handlers is protected by <code>mutex_lock</code>/<code>mutex_unlock</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> Write handler calls <code>mutex_lock_interruptible</code> and propagates <code>-ERESTARTSYS</code> on signal during mutex wait</li>\n<li><input disabled=\"\" type=\"checkbox\"> Read handler blocks with <code>wait_event_interruptible(read_queue, buffer_used &gt; *f_pos)</code> when buffer has no unread data</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>wait_event_interruptible</code> return value checked; <code>-ERESTARTSYS</code> propagated to userspace</li>\n<li><input disabled=\"\" type=\"checkbox\"> Write handler calls <code>wake_up_interruptible(&amp;read_queue)</code> after adding data</li>\n<li><input disabled=\"\" type=\"checkbox\"> Read handler calls <code>wake_up_interruptible(&amp;write_queue)</code> after consuming data</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>filp-&gt;f_flags &amp; O_NONBLOCK</code> checked in both read and write handlers before blocking</li>\n<li><input disabled=\"\" type=\"checkbox\"> Non-blocking read returns <code>-EAGAIN</code> (not 0, not -EINTR) when buffer has no unread data</li>\n<li><input disabled=\"\" type=\"checkbox\"> Non-blocking write returns <code>-EAGAIN</code> when buffer is full</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>.poll</code> file operation implemented with <code>poll_wait()</code> called before condition checks</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>.poll</code> registers both <code>read_queue</code> and <code>write_queue</code> with <code>poll_wait()</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>.poll</code> returns <code>POLLIN | POLLRDNORM</code> when <code>buffer_used &gt; 0</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>.poll</code> returns <code>POLLOUT | POLLWRNORM</code> when <code>buffer_used &lt; buffer_size_bytes</code></li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>poll()</code> or <code>select()</code> in userspace correctly detects readiness transitions (emptyâ†’data, fullâ†’space)</li>\n<li><input disabled=\"\" type=\"checkbox\"> Stress test with 4 concurrent writers and 4 concurrent readers completes without kernel oops, panics, or dmesg warnings</li>\n<li><input disabled=\"\" type=\"checkbox\"> Stress test verifies byte counts: total bytes written by all writers equals total bytes read by all readers</li>\n<li><input disabled=\"\" type=\"checkbox\"> <code>Ctrl+C</code> during a blocking read terminates the process cleanly (read returns -EINTR to userspace) without leaving the device in a corrupted state</li>\n<li><input disabled=\"\" type=\"checkbox\"> After <code>rmmod</code> during active polling: device removal does not panic; polling processes receive an error and exit cleanly</li>\n</ul>\n<!-- END_MS -->\n\n\n<h2 id=\"system-overview\">System Overview</h2>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fsystem-overview.svg\" alt=\"System Overview\"></p>\n<h1 id=\"tdd\">TDD</h1>\n<p>A progressive, four-milestone build of a production-quality Linux character device driver. Each module compiles independently yet feeds the next. The architecture centers on the kernel-userspace boundary: every struct layout, every lock ordering, every syscall dispatch path, and every cache line touched must be explicitly specified. Hardware soul analysis is mandatory for all I/O paths. The final driver supports concurrent multi-process access with mutex serialization, wait-queue blocking, O_NONBLOCK semantics, and poll/select integrationâ€”matching the architecture of /dev/tty, /dev/random, and real hardware drivers.</p>\n<!-- TDD_MOD_ID: build-kernel-module-m1 -->\n<h1 id=\"module-specification-hello-world-kernel-module-build-kernel-module-m1\">MODULE SPECIFICATION: Hello World Kernel Module (build-kernel-module-m1)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>This module establishes the foundational execution environment for a Linux kernel driver. It implements a Loadable Kernel Module (LKM) capable of being dynamically linked into the running kernel image. The module provides a lifecycle skeleton using the <code>module_init</code> and <code>module_exit</code> macros, handles kernel-level logging via the <code>printk</code> ring buffer, and exposes configurable state through the <code>module_param</code> system.</p>\n<p><strong>What it DOES:</strong></p>\n<ul>\n<li>Defines the entry and exit points for the kernel&#39;s module loader.</li>\n<li>Declares critical metadata (License, Author, Description) required for symbol resolution and <code>modinfo</code> inspection.</li>\n<li>Implements a sysfs-backed parameter (<code>buffer_size</code>) with load-time and runtime visibility.</li>\n<li>Performs input validation on module parameters during the initialization phase.</li>\n<li>Utilizes section annotations (<code>__init</code>, <code>__exit</code>) to optimize kernel memory footprint.</li>\n</ul>\n<p><strong>What it does NOT do:</strong></p>\n<ul>\n<li>It does not register a character device or allocate major/minor numbers (reserved for M2).</li>\n<li>It does not perform any userspace data transfer (no <code>copy_to_user</code>).</li>\n<li>It does not interact with hardware interrupts or DMA.</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>The module must never return a positive value from the initialization function.</li>\n<li>The <code>MODULE_LICENSE</code> must be set to a GPL-compatible string to ensure access to <code>EXPORT_SYMBOL_GPL</code> symbols in subsequent milestones.</li>\n<li>The module must be compiled against headers exactly matching the target kernel&#39;s <code>vermagic</code>.</li>\n</ul>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>The project follows the standard Linux out-of-tree module structure.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>build-kernel-module/\nâ”œâ”€â”€ 1. Makefile            # Kbuild delegation file\nâ”œâ”€â”€ 2. hello.c             # Primary module source\nâ””â”€â”€ 3. verify.sh           # Automated verification script (bash)</code></pre></div>\n\n<h2 id=\"3-complete-data-model\">3. Complete Data Model</h2>\n<h3 id=\"31-module-parameters\">3.1 Module Parameters</h3>\n<p>The module manages a single piece of global state exposed via <code>module_param</code>.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Variable Name</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Size</th>\n<th align=\"left\">Permissions</th>\n<th align=\"left\">Default</th>\n<th align=\"left\">Constraints</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>buffer_size</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">4 Bytes</td>\n<td align=\"left\"><code>0644</code> (S_IRUGO | S_IWUSR)</td>\n<td align=\"left\"><code>4096</code></td>\n<td align=\"left\"><code>1 &lt;= val &lt;= 1048576</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"32-elf-section-layout-internal\">3.2 ELF Section Layout (Internal)</h3>\n<p>The compiler and linker will organize the module&#39;s object code into specific sections. Understanding these is mandatory for systems-level debugging.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Section Name</th>\n<th align=\"left\">Content Type</th>\n<th align=\"left\">Alignment</th>\n<th align=\"left\">Lifecycle Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>.text</code></td>\n<td align=\"left\">Exit and helper code</td>\n<td align=\"left\">16B</td>\n<td align=\"left\">Resident for module lifetime</td>\n</tr>\n<tr>\n<td align=\"left\"><code>.init.text</code></td>\n<td align=\"left\"><code>hello_init</code> function</td>\n<td align=\"left\">16B</td>\n<td align=\"left\"><strong>Freed</strong> by kernel after successful init</td>\n</tr>\n<tr>\n<td align=\"left\"><code>.exit.text</code></td>\n<td align=\"left\"><code>hello_exit</code> function</td>\n<td align=\"left\">16B</td>\n<td align=\"left\">Discarded if module is built-in (non-LKM)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>.data</code></td>\n<td align=\"left\"><code>buffer_size</code> variable</td>\n<td align=\"left\">8B/64B</td>\n<td align=\"left\">Resident; modified via sysfs</td>\n</tr>\n<tr>\n<td align=\"left\"><code>.modinfo</code></td>\n<td align=\"left\">Metadata strings</td>\n<td align=\"left\">1B</td>\n<td align=\"left\">Read by <code>modinfo</code> and kernel loader</td>\n</tr>\n<tr>\n<td align=\"left\"><code>__param</code></td>\n<td align=\"left\"><code>kernel_param</code> structs</td>\n<td align=\"left\">8B (64-bit)</td>\n<td align=\"left\">Metadata for <code>module_param</code> linking</td>\n</tr>\n</tbody></table>\n<h3 id=\"33-hardware-soul-memory-amp-cache\">3.3 Hardware Soul: Memory &amp; Cache</h3>\n<ul>\n<li><strong>Memory Residency</strong>: The <code>.init.text</code> section is placed in a temporary page range. Upon <code>hello_init</code> returning 0, the kernel calls <code>free_initmem()</code> (or equivalent module-level cleanup), marking these pages as available. Any attempt to jump to the init function address after this results in an invalid instruction fault.</li>\n<li><strong>Cache Alignment</strong>: While this module is small, the <code>buffer_size</code> variable is stored in the <code>.data</code> section. In a high-concurrency environment (multi-core), this variable would occupy a single 64-byte cache line. Access via sysfs (<code>cat /sys/module/...</code>) requires a cross-CPU cache invalidation if the value was recently modified on another core.</li>\n<li><strong>TLB Impact</strong>: Loading a module requires allocating pages in the kernel&#39;s virtual address space (above <code>PAGE_OFFSET</code>). This populates the Kernel Page Tables, potentially requiring a TLB flush on older hardware or an update to the global kernel page directory.</li>\n</ul>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-module-entry-point\">4.1 Module Entry Point</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> __init </span><span style=\"color:#B392F0\">hello_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<ul>\n<li><strong>Purpose</strong>: Validates environment and parameters; registers the module with the kernel.</li>\n<li><strong>Constraints</strong>: Must be marked <code>static</code> and <code>__init</code>.</li>\n<li><strong>Input</strong>: Implicitly reads the global <code>buffer_size</code> (populated by the module loader from <code>insmod</code> arguments).</li>\n<li><strong>Returns</strong>: <ul>\n<li><code>0</code>: Success.</li>\n<li><code>-EINVAL</code>: <code>buffer_size</code> is out of bounds (&lt;= 0 or &gt; 1MB).</li>\n<li>Other negative <code>errno</code> codes if internal registration (not present in M1) fails.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"42-module-exit-point\">4.2 Module Exit Point</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#E1E4E8\"> __exit </span><span style=\"color:#B392F0\">hello_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<ul>\n<li><strong>Purpose</strong>: Cleans up resources. In M1, only emits a log message.</li>\n<li><strong>Constraints</strong>: Must be marked <code>static</code> and <code>__exit</code>.</li>\n<li><strong>Pre-condition</strong>: Only called if <code>hello_init</code> returned <code>0</code>.</li>\n<li><strong>Post-condition</strong>: The module is removed from the <code>modules</code> list and its memory is unmapped.</li>\n</ul>\n<h3 id=\"43-kernel-logging-printk\">4.3 Kernel Logging (<code>printk</code>)</h3>\n<ul>\n<li><strong>Mechanism</strong>: Writes to the <code>log_buf</code> circular buffer.</li>\n<li><strong>Log Level</strong>: <code>KERN_INFO</code> (<code>&quot;\\0016&quot;</code>) must be used for standard messages.</li>\n<li><strong>Log Level</strong>: <code>KERN_ERR</code> (<code>&quot;\\0013&quot;</code>) must be used for parameter validation failures.</li>\n</ul>\n<h2 id=\"5-kbuild-makefile-specification\">5. Kbuild Makefile Specification</h2>\n<p>Standard Makefiles cannot build kernel modules because specific flags (e.g., <code>-D__KERNEL__</code>, <code>-fno-pic</code>, <code>-mno-red-zone</code>) are required to prevent userspace ABI pollution.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">makefile</span><pre class=\"arch-pre shiki-highlighted\"><code># Variables\nOBJ_NAME := hello\nKDIR := /lib/modules/$(shell uname -r)/build\nPWD := $(shell pwd)\n\n# Kbuild logic: obj-m defines the module to be built\nobj-m += $(OBJ_NAME).o\n\nall:\n\t$(MAKE) -C $(KDIR) M=$(PWD) modules\n\nclean:\n\t$(MAKE) -C $(KDIR) M=$(PWD) clean\n\n# Prevent warnings from being ignored\nccflags-y := -Werror -Wall</code></pre></div>\n\n<h2 id=\"6-algorithm-specification-module-lifecycle\">6. Algorithm Specification: Module Lifecycle</h2>\n<h3 id=\"61-initialization-and-validation-loop\">6.1 Initialization and Validation Loop</h3>\n<ol>\n<li><strong>Entry</strong>: The kernel module loader (<code>kernel/module.c</code>) maps the <code>.ko</code> file into kernel memory.</li>\n<li><strong>Symbol Resolution</strong>: The loader resolves the address of <code>printk</code> and other kernel symbols.</li>\n<li><strong>Param Population</strong>: The loader parses the command line string (e.g., <code>buffer_size=8192</code>) and writes the value to the <code>buffer_size</code> variable in the module&#39;s <code>.data</code> section.</li>\n<li><strong>Init Call</strong>: The loader executes the function registered via <code>module_init()</code>.</li>\n<li><strong>Validation Step</strong>:<ul>\n<li><code>IF (buffer_size &lt;= 0 OR buffer_size &gt; 1048576)</code>:<ul>\n<li>Call <code>printk(KERN_ERR &quot;hello: Invalid buffer_size %d\\n&quot;, buffer_size);</code></li>\n<li><code>RETURN -EINVAL;</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Success Step</strong>:<ul>\n<li>Call <code>printk(KERN_INFO &quot;hello: Module loaded with buffer_size=%d\\n&quot;, buffer_size);</code></li>\n<li><code>RETURN 0;</code></li>\n</ul>\n</li>\n<li><strong>Post-Init</strong>: The kernel looks at the <code>.init.text</code> section and frees it.</li>\n</ol>\n<h3 id=\"62-exit-sequence\">6.2 Exit Sequence</h3>\n<ol>\n<li><strong>Trigger</strong>: User executes <code>rmmod hello</code>.</li>\n<li><strong>Refcount Check</strong>: The kernel checks if any other module or process depends on <code>hello</code>. If count &gt; 0, return <code>-EBUSY</code>.</li>\n<li><strong>Exit Call</strong>: The kernel executes the function registered via <code>module_exit()</code>.</li>\n<li><strong>Logging</strong>: Call <code>printk(KERN_INFO &quot;hello: Module unloaded\\n&quot;);</code>.</li>\n<li><strong>Unlinking</strong>: The kernel removes the module from the sysfs hierarchy and unmaps the memory pages.</li>\n</ol>\n<h2 id=\"7-error-handling-matrix\">7. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error Condition</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery Action</th>\n<th align=\"left\">User-Visible Effect</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>buffer_size &lt; 1</code></td>\n<td align=\"left\"><code>hello_init</code></td>\n<td align=\"left\">Return <code>-EINVAL</code></td>\n<td align=\"left\"><code>insmod</code> fails; error in <code>dmesg</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>buffer_size &gt; 1M</code></td>\n<td align=\"left\"><code>hello_init</code></td>\n<td align=\"left\">Return <code>-EINVAL</code></td>\n<td align=\"left\"><code>insmod</code> fails; error in <code>dmesg</code></td>\n</tr>\n<tr>\n<td align=\"left\">Missing <code>MODULE_LICENSE</code></td>\n<td align=\"left\">Kernel Loader</td>\n<td align=\"left\">Taint kernel; block GPL symbols</td>\n<td align=\"left\">Warning in <code>dmesg</code>; load may fail later</td>\n</tr>\n<tr>\n<td align=\"left\">Version Mismatch</td>\n<td align=\"left\"><code>modpost</code> / Loader</td>\n<td align=\"left\">Refuse load</td>\n<td align=\"left\"><code>Exec format error</code> / <code>vermagic</code> mismatch</td>\n</tr>\n<tr>\n<td align=\"left\"><code>kmalloc</code> failure (future)</td>\n<td align=\"left\"><code>hello_init</code></td>\n<td align=\"left\">Return <code>-ENOMEM</code></td>\n<td align=\"left\"><code>insmod</code> fails</td>\n</tr>\n</tbody></table>\n<h2 id=\"8-implementation-sequence-with-checkpoints\">8. Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-skeleton-amp-kbuild-10-hours\">Phase 1: Skeleton &amp; Kbuild (1.0 Hours)</h3>\n<ol>\n<li>Install kernel headers: <code>sudo apt install linux-headers-$(uname -r)</code>.</li>\n<li>Create <code>Makefile</code> with <code>obj-m</code>.</li>\n<li>Create <code>hello.c</code> with empty <code>module_init</code>/<code>module_exit</code>.</li>\n<li><strong>Checkpoint</strong>: Run <code>make</code>. <code>hello.ko</code> should be generated. Run <code>modinfo hello.ko</code> and verify it shows as a kernel object.</li>\n</ol>\n<h3 id=\"phase-2-metadata-amp-logging-10-hours\">Phase 2: Metadata &amp; Logging (1.0 Hours)</h3>\n<ol>\n<li>Add <code>MODULE_LICENSE(&quot;GPL&quot;)</code>, <code>MODULE_AUTHOR</code>, and <code>MODULE_DESCRIPTION</code>.</li>\n<li>Add <code>printk(KERN_INFO ...)</code> to init and exit functions.</li>\n<li><strong>Checkpoint</strong>: <code>sudo insmod hello.ko</code>. Run <code>dmesg | tail</code>. You should see the &quot;Module loaded&quot; message. Run <code>sudo rmmod hello</code> and check <code>dmesg</code> for the &quot;unloaded&quot; message.</li>\n</ol>\n<h3 id=\"phase-3-parameters-amp-validation-10-hours\">Phase 3: Parameters &amp; Validation (1.0 Hours)</h3>\n<ol>\n<li>Define <code>static int buffer_size = 4096;</code>.</li>\n<li>Add <code>module_param(buffer_size, int, 0644);</code> and <code>MODULE_PARM_DESC</code>.</li>\n<li>Implement the range check (1 to 1MB) in <code>hello_init</code>.</li>\n<li><strong>Checkpoint</strong>: <code>sudo insmod hello.ko buffer_size=1024</code>. Check <code>/sys/module/hello/parameters/buffer_size</code>. It should read <code>1024</code>. Try <code>sudo insmod hello.ko buffer_size=0</code>; it should fail with <code>Invalid argument</code>.</li>\n</ol>\n<h3 id=\"phase-4-verification-automation-10-hours\">Phase 4: Verification Automation (1.0 Hours)</h3>\n<ol>\n<li>Write <code>verify.sh</code> to automate the tests in Phase 3.</li>\n<li>Ensure script checks <code>dmesg</code> output and sysfs presence.</li>\n<li><strong>Checkpoint</strong>: <code>./verify.sh</code> returns &quot;All tests passed.&quot;</li>\n</ol>\n<h2 id=\"9-test-specification\">9. Test Specification</h2>\n<h3 id=\"91-functional-tests\">9.1 Functional Tests</h3>\n<ul>\n<li><strong>Happy Path 1</strong>: Load with default params.<ul>\n<li><code>insmod hello.ko</code> -&gt; success.</li>\n<li><code>dmesg</code> contains &quot;loaded&quot;.</li>\n<li><code>/sys/.../buffer_size</code> is 4096.</li>\n</ul>\n</li>\n<li><strong>Happy Path 2</strong>: Load with custom param.<ul>\n<li><code>insmod hello.ko buffer_size=8192</code> -&gt; success.</li>\n<li><code>/sys/.../buffer_size</code> is 8192.</li>\n</ul>\n</li>\n<li><strong>Edge Case</strong>: Maximum value.<ul>\n<li><code>insmod hello.ko buffer_size=1048576</code> -&gt; success.</li>\n</ul>\n</li>\n<li><strong>Failure Case 1</strong>: Below minimum.<ul>\n<li><code>insmod hello.ko buffer_size=0</code> -&gt; returns <code>1</code> (errno <code>EINVAL</code>).</li>\n</ul>\n</li>\n<li><strong>Failure Case 2</strong>: Above maximum.<ul>\n<li><code>insmod hello.ko buffer_size=2000000</code> -&gt; returns <code>1</code> (errno <code>EINVAL</code>).</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"92-metadata-validation\">9.2 Metadata Validation</h3>\n<ul>\n<li>Run <code>modinfo hello.ko</code>.</li>\n<li>Verify <code>license</code> is <code>GPL</code>.</li>\n<li>Verify <code>parm</code> description is present.</li>\n</ul>\n<h2 id=\"10-performance-targets\">10. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target Metric</th>\n<th align=\"left\">Measurement Tool</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Load Latency</td>\n<td align=\"left\">&lt; 10ms</td>\n<td align=\"left\"><code>time sudo insmod hello.ko</code></td>\n</tr>\n<tr>\n<td align=\"left\">Memory Footprint</td>\n<td align=\"left\">&lt; 4KB (after init)</td>\n<td align=\"left\"><code>lsmod</code> (size column)</td>\n</tr>\n<tr>\n<td align=\"left\">Log Latency</td>\n<td align=\"left\">&lt; 500ns per printk</td>\n<td align=\"left\">Kernel ftrace / timestamp diff</td>\n</tr>\n<tr>\n<td align=\"left\">Build Time</td>\n<td align=\"left\">&lt; 2s</td>\n<td align=\"left\"><code>time make</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"11-state-machine-module-lifecycle\">11. State Machine: Module Lifecycle</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>[ UNLOADED ] \n      |\n      | (insmod / finit_module syscall)\n      v\n[ LOADING ] --&gt; (Validation Fails) --&gt; [ UNLOADED (+ dmesg error) ]\n      |\n      | (Validation Passes, init returns 0)\n      v\n[ RUNNING ] \n      |\n      | (rmmod / delete_module syscall)\n      v\n[ UNLOADING ] \n      |\n      | (exit function finishes)\n      v\n[ UNLOADED ]</code></pre></div>\n\n<h2 id=\"12-security-amp-constraints\">12. Security &amp; Constraints</h2>\n<ul>\n<li><strong>Parameter Permissions</strong>: <code>0644</code> is used. This allows root to change the parameter at runtime via <code>echo X &gt; /sys/...</code>. The module must be prepared for this variable to change (though in M1, no logic depends on it after init). In production drivers, runtime changes often require a <code>mutex</code> or <code>notifier</code> to handle state transition safely.</li>\n<li><strong>Kernel Tainting</strong>: Omitting <code>MODULE_LICENSE(&quot;GPL&quot;)</code> will mark the kernel as &quot;Tainted: P&quot;. This prevents the kernel community from debugging any oops your module might cause and limits API access.</li>\n</ul>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-kernel-module-m2 -->\n<h1 id=\"module-specification-character-device-driver-build-kernel-module-m2\">MODULE SPECIFICATION: Character Device Driver (build-kernel-module-m2)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>This module implements a Linux character device driver, providing a structured gateway between userspace processes and kernel memory. It transitions the project from a simple &quot;Hello World&quot; module to a functional system component that adheres to the Virtual File System (VFS) interface.</p>\n<p><strong>What it DOES:</strong></p>\n<ul>\n<li>Dynamically reserves a character device major/minor number range via <code>alloc_chrdev_region</code>.</li>\n<li>Connects kernel logic to the standard filesystem namespace using <code>struct cdev</code> and <code>file_operations</code>.</li>\n<li>Triggers automatic <code>/dev/node</code> creation using the kernel&#39;s class and device uevent infrastructure (udev integration).</li>\n<li>Manages a physically contiguous 4KB kernel buffer via the SLUB allocator.</li>\n<li>Enforces strict memory safety at the kernel-userspace boundary using <code>copy_to_user</code> and <code>copy_from_user</code> (exception-table based crossing).</li>\n<li>Tracks file positions (<code>f_pos</code>) to support sequential reading and end-of-file (EOF) semantics.</li>\n<li>Maintains a thread-safe (SMP-safe) open-instance counter using <code>atomic_t</code>.</li>\n</ul>\n<p><strong>What it does NOT do:</strong></p>\n<ul>\n<li>It does NOT implement custom control codes (ioctl), which are reserved for Milestone 3.</li>\n<li>It does NOT implement process synchronization or blocking I/O (mutexes/wait queues), which are reserved for Milestone 4.</li>\n<li>It does NOT support <code>llseek</code> (random access is ignored; sequential only).</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li><strong>Safety</strong>: Userspace pointers MUST NEVER be directly dereferenced.</li>\n<li><strong>Cleanup</strong>: Every successful kernel resource allocation (region, cdev, class, device, memory) must be explicitly undone in reverse order during module exit or error unwinding.</li>\n<li><strong>Boundary</strong>: The <code>read</code> handler must return <code>0</code> when <code>*f_pos</code> reaches the current buffer usage to prevent userspace infinite loops.</li>\n</ul>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>The implementation follows the Linux Kernel Coding Style (Tabs, 8-character width).</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>build-kernel-module/\nâ”œâ”€â”€ 1. Makefile            # Kbuild delegation with ccflags-y := -Werror\nâ”œâ”€â”€ 2. mychar_dev.c        # Main driver implementation\nâ”œâ”€â”€ 3. test_driver.sh      # Shell-based verification (echo/cat/dd)\nâ””â”€â”€ 4. mychar_dev.h        # Internal driver constants and structure definitions</code></pre></div>\n\n<h2 id=\"3-complete-data-model\">3. Complete Data Model</h2>\n<h3 id=\"31-device-private-structure-struct-my_device_data\">3.1 Device Private Structure (<code>struct my_device_data</code>)</h3>\n<p>To avoid global variable sprawl and prepare for multi-device support, we encapsulate the device state in a single structure.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field Name</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Size</th>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>cdev</code></td>\n<td align=\"left\"><code>struct cdev</code></td>\n<td align=\"left\">~104B</td>\n<td align=\"left\">0x00</td>\n<td align=\"left\">The kernel&#39;s character device abstraction (vtable holder).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>buffer</code></td>\n<td align=\"left\"><code>char *</code></td>\n<td align=\"left\">8B</td>\n<td align=\"left\">0x68</td>\n<td align=\"left\">Pointer to the 4KB kernel-resident data buffer.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>buffer_used</code></td>\n<td align=\"left\"><code>size_t</code></td>\n<td align=\"left\">8B</td>\n<td align=\"left\">0x70</td>\n<td align=\"left\">Current number of valid bytes stored in the buffer.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>open_count</code></td>\n<td align=\"left\"><code>atomic_t</code></td>\n<td align=\"left\">4B</td>\n<td align=\"left\">0x78</td>\n<td align=\"left\">SMP-safe counter of active file descriptors.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>device_major</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">4B</td>\n<td align=\"left\">0x7C</td>\n<td align=\"left\">Major number assigned by the kernel.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>class</code></td>\n<td align=\"left\"><code>struct class *</code></td>\n<td align=\"left\">8B</td>\n<td align=\"left\">0x80</td>\n<td align=\"left\">Pointer to the sysfs class for udev node creation.</td>\n</tr>\n</tbody></table>\n<p><strong>Hardware Soul: Cache Line Analysis (64B)</strong></p>\n<ul>\n<li>The <code>struct my_device_data</code> spans approximately 136 bytes (roughly 2.1 cache lines).</li>\n<li><strong>False Sharing Alert</strong>: In M2, we do not use a mutex, but <code>open_count</code> is modified frequently. On a multi-core system, if <code>open_count</code> resides on the same cache line as <code>buffer_used</code>, an <code>atomic_inc</code> on one core will invalidate the cache line for a core attempting to read <code>buffer_used</code>.</li>\n<li><strong>Packing</strong>: We place <code>atomic_t</code> near the end. <code>struct cdev</code> is large and contains its own internal locks/pointers.</li>\n</ul>\n<h3 id=\"32-vfs-interaction-model-the-vtable\">3.2 VFS Interaction Model (The VTable)</h3>\n<p>The <code>struct file_operations</code> maps the system call interface to our internal functions.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> file_operations my_fops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .owner   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> THIS_MODULE,</span><span style=\"color:#6A737D\">      // Prevents module unloading while in use</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .open    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> my_open,</span><span style=\"color:#6A737D\">          // Called on open(\"/dev/mydevice\", ...)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .release </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> my_release,</span><span style=\"color:#6A737D\">       // Called on close(fd)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .read    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> my_read,</span><span style=\"color:#6A737D\">          // Called on read(fd, ...)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .write   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> my_write,</span><span style=\"color:#6A737D\">         // Called on write(fd, ...)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h3 id=\"33-memory-layout-the-4kb-buffer\">3.3 Memory Layout: The 4KB Buffer</h3>\n<ul>\n<li><strong>Allocator</strong>: <code>kzalloc(4096, GFP_KERNEL)</code>.</li>\n<li><strong>Alignment</strong>: The SLUB allocator returns 8-byte aligned memory. 4096 bytes corresponds exactly to one hardware page (<code>PAGE_SIZE</code>) on x86_64.</li>\n<li><strong>Physically Contiguous</strong>: <code>kmalloc</code> memory is physically contiguous, making it friendly to future DMA operations (though not used here).</li>\n</ul>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-system-call-handlers-kernel-context\">4.1 System Call Handlers (Kernel Context)</h3>\n<h4 id=\"int-my_openstruct-inode-inode-struct-file-filp\"><code>int my_open(struct inode *inode, struct file *filp)</code></h4>\n<ul>\n<li><strong>Contract</strong>: Called when a process opens the device node.</li>\n<li><strong>Action</strong>: Increments <code>open_count</code>. Associates the <code>struct my_device_data</code> with <code>filp-&gt;private_data</code>.</li>\n<li><strong>Return</strong>: <code>0</code> (Success).</li>\n</ul>\n<h4 id=\"int-my_releasestruct-inode-inode-struct-file-filp\"><code>int my_release(struct inode *inode, struct file *filp)</code></h4>\n<ul>\n<li><strong>Contract</strong>: Called when the last reference to a file descriptor is closed.</li>\n<li><strong>Action</strong>: Decrements <code>open_count</code>.</li>\n<li><strong>Return</strong>: <code>0</code>.</li>\n</ul>\n<h4 id=\"ssize_t-my_readstruct-file-filp-char-__user-buf-size_t-count-loff_t-f_pos\"><code>ssize_t my_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)</code></h4>\n<ul>\n<li><strong>Contract</strong>: Transfer data from kernel buffer to userspace.</li>\n<li><strong>Parameters</strong>: <ul>\n<li><code>buf</code>: Userspace target address (MUST NOT dereference directly).</li>\n<li><code>count</code>: Requested bytes.</li>\n<li><code>f_pos</code>: Pointer to the current file offset.</li>\n</ul>\n</li>\n<li><strong>Constraint</strong>: If <code>*f_pos &gt;= buffer_used</code>, return <code>0</code> (EOF).</li>\n<li><strong>Logic</strong>: <code>bytes_to_read = min(count, buffer_used - *f_pos)</code>.</li>\n<li><strong>Return</strong>: Number of bytes successfully copied, or <code>-EFAULT</code> on copy failure.</li>\n</ul>\n<h4 id=\"ssize_t-my_writestruct-file-filp-const-char-__user-buf-size_t-count-loff_t-f_pos\"><code>ssize_t my_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)</code></h4>\n<ul>\n<li><strong>Contract</strong>: Transfer data from userspace to kernel buffer.</li>\n<li><strong>Constraint</strong>: If <code>buffer_used == 4096</code>, return <code>-ENOSPC</code>.</li>\n<li><strong>Logic</strong>: <code>bytes_to_write = min(count, 4096 - buffer_used)</code>.</li>\n<li><strong>Return</strong>: Number of bytes successfully copied, or <code>-EFAULT</code> on copy failure.</li>\n</ul>\n<h2 id=\"5-algorithm-specification-the-implementation-path\">5. Algorithm Specification: The Implementation Path</h2>\n<h3 id=\"51-module-initialization-sequence-the-goto-unwind\">5.1 Module Initialization Sequence (The Goto Unwind)</h3>\n<p>The kernel requires deterministic cleanup for partial failures.</p>\n<ol>\n<li><strong>Allocate Region</strong>: <code>alloc_chrdev_region(&amp;dev_num, 0, 1, &quot;mydevice&quot;)</code>.<ul>\n<li>Failure -&gt; <code>return ret</code>.</li>\n</ul>\n</li>\n<li><strong>Allocate Buffer</strong>: <code>kzalloc(4096, GFP_KERNEL)</code>.<ul>\n<li>Failure -&gt; <code>unregister_chrdev_region</code>; <code>return -ENOMEM</code>.</li>\n</ul>\n</li>\n<li><strong>Initialize Cdev</strong>: <code>cdev_init(&amp;my_cdev, &amp;my_fops)</code>.</li>\n<li><strong>Add Cdev</strong>: <code>cdev_add(&amp;my_cdev, dev_num, 1)</code>.<ul>\n<li>Failure -&gt; <code>kfree(buffer)</code>; <code>unregister_chrdev_region</code>.</li>\n</ul>\n</li>\n<li><strong>Create Class</strong>: <code>class_create(THIS_MODULE, &quot;my_class&quot;)</code>.<ul>\n<li>Failure -&gt; <code>cdev_del</code>; <code>kfree</code>; <code>unregister</code>.</li>\n</ul>\n</li>\n<li><strong>Create Device</strong>: <code>device_create(my_class, NULL, dev_num, NULL, &quot;mydevice&quot;)</code>.<ul>\n<li>Failure -&gt; <code>class_destroy</code>; <code>cdev_del</code>; <code>kfree</code>; <code>unregister</code>.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"52-read-handler-algorithm\">5.2 Read Handler Algorithm</h3>\n<ol>\n<li><strong>Check Position</strong>: <code>IF *f_pos &gt;= buffer_used THEN RETURN 0</code>.</li>\n<li><strong>Calculate Limit</strong>: <code>available = buffer_used - *f_pos</code>.</li>\n<li><strong>Bound Count</strong>: <code>to_copy = (count &lt; available) ? count : available</code>.</li>\n<li><strong>Copy</strong>: <code>not_copied = copy_to_user(buf, kernel_buffer + *f_pos, to_copy)</code>.</li>\n<li><strong>Fault Check</strong>: <code>IF not_copied != 0 THEN RETURN -EFAULT</code>.</li>\n<li><strong>Update State</strong>: <code>*f_pos += to_copy</code>.</li>\n<li><strong>Return</strong>: <code>to_copy</code>.</li>\n</ol>\n<h3 id=\"53-write-handler-algorithm\">5.3 Write Handler Algorithm</h3>\n<ol>\n<li><strong>Check Space</strong>: <code>IF buffer_used &gt;= 4096 THEN RETURN -ENOSPC</code>.</li>\n<li><strong>Calculate Space</strong>: <code>available = 4096 - buffer_used</code>.</li>\n<li><strong>Bound Count</strong>: <code>to_copy = (count &lt; available) ? count : available</code>.</li>\n<li><strong>Copy</strong>: <code>not_copied = copy_from_user(kernel_buffer + buffer_used, buf, to_copy)</code>.</li>\n<li><strong>Fault Check</strong>: <code>IF not_copied != 0 THEN RETURN -EFAULT</code>.</li>\n<li><strong>Update State</strong>: <code>buffer_used += to_copy</code>.</li>\n<li><strong>Return</strong>: <code>to_copy</code>.</li>\n</ol>\n<h2 id=\"6-three-level-view-hardware-soul\">6. Three-Level View: Hardware Soul</h2>\n<h3 id=\"level-1-application-user\">Level 1 â€” Application (User)</h3>\n<p>Process calls <code>write(fd, &quot;data&quot;, 4)</code>. This triggers the <code>syscall</code> instruction (x86_64), switching the CPU to CPL 0 (Kernel Mode) and jumping to the system call entry point.</p>\n<h3 id=\"level-2-oskernel-vfs\">Level 2 â€” OS/Kernel (VFS)</h3>\n<p>The VFS looks up the file descriptor in the process&#39;s file table, finds the <code>struct file</code>, and invokes <code>file-&gt;f_op-&gt;write</code>. Our <code>my_write</code> handler executes. It calls <code>copy_from_user</code>.</p>\n<h3 id=\"level-3-hardware-cpummu\">Level 3 â€” Hardware (CPU/MMU)</h3>\n<ol>\n<li><strong>Exception Table</strong>: The <code>copy_from_user</code> assembly contains instructions registered in the kernel&#39;s <code>.ex_table</code>. </li>\n<li><strong>TLB Lookup</strong>: The CPU looks up the virtual address of the userspace <code>buf</code> in the current CR3 (Page Table Base). </li>\n<li><strong>Cache Lines</strong>: The kernel buffer (kmalloc&#39;d) is likely in L1/L2. Data is moved in 8-byte or 16-byte chunks (or <code>rep movsb</code> optimization).</li>\n<li><strong>Page Faults</strong>: If the userspace page is swapped out, <code>copy_from_user</code> triggers a page fault. The kernel&#39;s fault handler swaps the page in and resumes the copy. If the address is invalid, the exception table logic forces <code>copy_from_user</code> to return a non-zero value, and we return <code>-EFAULT</code>.</li>\n</ol>\n<h2 id=\"7-error-handling-matrix\">7. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error Condition</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery Action</th>\n<th align=\"left\">User-Visible Effect</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">SLUB out of memory</td>\n<td align=\"left\"><code>kzalloc</code></td>\n<td align=\"left\">Jump to <code>err_region</code> (unwind)</td>\n<td align=\"left\"><code>insmod</code> returns <code>-ENOMEM</code></td>\n</tr>\n<tr>\n<td align=\"left\">Bad Userspace Pointer</td>\n<td align=\"left\"><code>copy_to_user</code></td>\n<td align=\"left\">Return <code>-EFAULT</code></td>\n<td align=\"left\"><code>read()</code> returns -1, <code>errno=EFAULT</code></td>\n</tr>\n<tr>\n<td align=\"left\">Buffer Full</td>\n<td align=\"left\"><code>my_write</code></td>\n<td align=\"left\">Return <code>-ENOSPC</code></td>\n<td align=\"left\"><code>write()</code> returns -1, <code>errno=ENOSPC</code></td>\n</tr>\n<tr>\n<td align=\"left\">Partial Write</td>\n<td align=\"left\"><code>copy_from_user</code></td>\n<td align=\"left\">Adjust <code>buffer_used</code> by partial</td>\n<td align=\"left\"><code>write()</code> returns fewer bytes than requested</td>\n</tr>\n<tr>\n<td align=\"left\">Device Node Collision</td>\n<td align=\"left\"><code>device_create</code></td>\n<td align=\"left\">Jump to <code>err_class</code> (unwind)</td>\n<td align=\"left\"><code>insmod</code> fails, node not in <code>/dev</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"8-implementation-sequence-with-checkpoints\">8. Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-dynamic-allocation-amp-cdev-2-hours\">Phase 1: Dynamic Allocation &amp; Cdev (2 Hours)</h3>\n<ol>\n<li>Implement <code>alloc_chrdev_region</code>. </li>\n<li>Log the Major/Minor in <code>dmesg</code>.</li>\n<li>Initialize <code>struct cdev</code> and link to <code>file_operations</code>.</li>\n<li><strong>Checkpoint</strong>: <code>insmod</code> the module. <code>grep mydevice /proc/devices</code> should show the major number.</li>\n</ol>\n<h3 id=\"phase-2-udev-integration-15-hours\">Phase 2: Udev Integration (1.5 Hours)</h3>\n<ol>\n<li>Add <code>class_create</code> and <code>device_create</code>.</li>\n<li>Verify cleanup with <code>class_destroy</code> and <code>device_destroy</code>.</li>\n<li><strong>Checkpoint</strong>: <code>insmod</code> the module. Verify <code>/dev/mydevice</code> exists and has <code>crw-------</code> permissions (default).</li>\n</ol>\n<h3 id=\"phase-3-memory-amp-ops-3-hours\">Phase 3: Memory &amp; Ops (3 Hours)</h3>\n<ol>\n<li>Implement <code>kzalloc</code> in init.</li>\n<li>Implement <code>open</code>/<code>release</code> with <code>atomic_inc</code>/<code>atomic_dec</code>.</li>\n<li>Implement <code>read</code> and <code>write</code> with <code>copy_user</code> functions.</li>\n<li><strong>Checkpoint</strong>: <code>echo &quot;test&quot; &gt; /dev/mydevice</code>. <code>dmesg</code> should show write logs. <code>cat /dev/mydevice</code> should show &quot;test&quot;.</li>\n</ol>\n<h3 id=\"phase-4-position-amp-bounds-15-hours\">Phase 4: Position &amp; Bounds (1.5 Hours)</h3>\n<ol>\n<li>Verify <code>*f_pos</code> updates correctly.</li>\n<li>Test <code>ENOSPC</code> by writing &gt;4096 bytes.</li>\n<li><strong>Checkpoint</strong>: <code>dd if=/dev/zero of=/dev/mydevice bs=5000 count=1</code>. Verify <code>dd</code> reports &quot;No space left on device&quot; after 4096 bytes.</li>\n</ol>\n<h2 id=\"9-test-specification\">9. Test Specification</h2>\n<h3 id=\"91-functional-tests\">9.1 Functional Tests</h3>\n<ul>\n<li><strong>T1 (Round Trip)</strong>: <ul>\n<li>Command: <code>echo &quot;kernel&quot; &gt; /dev/mydevice &amp;&amp; cat /dev/mydevice</code></li>\n<li>Expected: Output &quot;kernel&quot;.</li>\n</ul>\n</li>\n<li><strong>T2 (Positioning)</strong>:<ul>\n<li>Command: <code>echo &quot;12345678&quot; &gt; /dev/mydevice &amp;&amp; dd if=/dev/mydevice bs=1 skip=4</code></li>\n<li>Expected: Output &quot;5678&quot;.</li>\n</ul>\n</li>\n<li><strong>T3 (Persistence)</strong>:<ul>\n<li>Command: Open the device, write, close. Open again, read.</li>\n<li>Expected: Data persists between opens (device-level buffer).</li>\n</ul>\n</li>\n<li><strong>T4 (EOF)</strong>:<ul>\n<li>Command: <code>cat /dev/mydevice</code> (twice).</li>\n<li>Expected: Both calls return the full buffer and terminate.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"92-boundary-tests\">9.2 Boundary Tests</h3>\n<ul>\n<li><strong>T5 (Bad Pointer)</strong>: Use a small C program to pass <code>(char*)0xdeadbeef</code> to <code>read()</code>.<ul>\n<li>Expected: <code>read</code> returns <code>-1</code>, <code>errno</code> is <code>EFAULT</code>. <strong>NO KERNEL OOPS</strong>.</li>\n</ul>\n</li>\n<li><strong>T6 (Overflow)</strong>: <code>python3 -c &quot;print(&#39;A&#39;*5000)&quot; &gt; /dev/mydevice</code>.<ul>\n<li>Expected: Returns error, buffer contains exactly 4096 &#39;A&#39;s.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"10-performance-targets\">10. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target Metric</th>\n<th align=\"left\">How to Measure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Sequential Write Throughput</td>\n<td align=\"left\">&gt; 2.0 GB/s</td>\n<td align=\"left\"><code>dd if=/dev/zero of=/dev/mydevice bs=4k count=100000</code></td>\n</tr>\n<tr>\n<td align=\"left\">Sequential Read Throughput</td>\n<td align=\"left\">&gt; 2.0 GB/s</td>\n<td align=\"left\"><code>dd if=/dev/mydevice of=/dev/null bs=4k count=100000</code></td>\n</tr>\n<tr>\n<td align=\"left\">Latency (Single 64B Write)</td>\n<td align=\"left\">&lt; 1.5 Âµs</td>\n<td align=\"left\">Userspace clock_gettime() around write()</td>\n</tr>\n<tr>\n<td align=\"left\">Syscall Overhead</td>\n<td align=\"left\">&lt; 400 ns</td>\n<td align=\"left\"><code>strace -T</code> on open()</td>\n</tr>\n</tbody></table>\n<h2 id=\"11-concurrency-specification-milestone-2-context\">11. Concurrency Specification (Milestone 2 Context)</h2>\n<ul>\n<li><strong>Shared Resource</strong>: <code>kernel_buffer</code> and <code>buffer_used</code>.</li>\n<li><strong>Strategy</strong>: No locks are implemented in M2 for data.</li>\n<li><strong>Risk</strong>: Two processes writing simultaneously will corrupt <code>buffer_used</code> and potentially overwrite data.</li>\n<li><strong>Mitigation</strong>: In M2, we use <code>atomic_t</code> for <code>open_count</code> only to demonstrate SMP-safe primitives. Data synchronization is deferred to Milestone 4.</li>\n</ul>\n<h2 id=\"12-verification-script-verify_m2sh\">12. Verification Script (<code>verify_m2.sh</code>)</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">#!/bin/bash</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">set</span><span style=\"color:#79B8FF\"> -e</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">MOD</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"mychar_dev\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">DEV</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"/dev/mydevice\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Rebuilding...\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">make</span><span style=\"color:#9ECBFF\"> clean</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#B392F0\">make</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Loading module...\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> insmod</span><span style=\"color:#E1E4E8\"> ${MOD}</span><span style=\"color:#9ECBFF\">.ko</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify Major Allocation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">MAJOR</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">awk</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\$</span><span style=\"color:#9ECBFF\">2==</span><span style=\"color:#79B8FF\">\\\"</span><span style=\"color:#9ECBFF\">mydevice</span><span style=\"color:#79B8FF\">\\\"</span><span style=\"color:#9ECBFF\"> {print </span><span style=\"color:#79B8FF\">\\$</span><span style=\"color:#9ECBFF\">1}\"</span><span style=\"color:#9ECBFF\"> /proc/devices</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Major assigned: </span><span style=\"color:#E1E4E8\">$MAJOR</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify Udev Node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> [ </span><span style=\"color:#F97583\">!</span><span style=\"color:#F97583\"> -c</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$DEV</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"ERROR: /dev node not found!\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    exit</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Testing data integrity...\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">DATA</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"SystemLowLevelProgramming\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$DATA</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$DEV</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">RESULT</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$DEV</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> [ </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$DATA</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$RESULT</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"PASS: Data Round-trip successful.\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"FAIL: Expected </span><span style=\"color:#E1E4E8\">$DATA</span><span style=\"color:#9ECBFF\">, got </span><span style=\"color:#E1E4E8\">$RESULT</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Testing ENOSPC...\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">set</span><span style=\"color:#9ECBFF\"> +e</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python3</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"print('X'*5000)\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$DEV</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\"> err.txt</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -q</span><span style=\"color:#9ECBFF\"> \"No space left on device\"</span><span style=\"color:#9ECBFF\"> err.txt</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"PASS: ENOSPC handled.\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"FAIL: Overflow allowed or wrong error.\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">set</span><span style=\"color:#79B8FF\"> -e</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Unloading...\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> rmmod</span><span style=\"color:#E1E4E8\"> ${MOD}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dmesg</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tail</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#79B8FF\"> 5</span></span></code></pre></div>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-kernel-module-m3 -->\n<h1 id=\"module-specification-ioctl-and-proc-interface-build-kernel-module-m3\">MODULE SPECIFICATION: ioctl and /proc Interface (build-kernel-module-m3)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>This module implements the control and introspection planes for the character device driver. While Milestone 2 established the data plane (read/write), Milestone 3 provides structured mechanisms for device management and observability. It introduces an <code>ioctl</code> (Input/Output Control) interface for binary command execution and a <code>/proc</code> filesystem entry for human-readable state inspection.</p>\n<p><strong>What it DOES:</strong></p>\n<ul>\n<li>Defines a stable Application Binary Interface (ABI) via a shared header file.</li>\n<li>Implements <code>unlocked_ioctl</code> to handle out-of-band control commands (Clear, Resize, Status).</li>\n<li>Utilizes the kernel&#39;s command encoding macros (<code>_IO</code>, <code>_IOW</code>, <code>_IOR</code>) to ensure namespace safety and direction validation.</li>\n<li>Implements a safe &quot;allocate-then-swap&quot; pattern for runtime memory reallocation.</li>\n<li>Provides a virtual file in <code>/proc</code> using the <code>seq_file</code> abstraction to export driver statistics.</li>\n<li>Maintains counters for successful read/write operations using <code>atomic_t</code>.</li>\n</ul>\n<p><strong>What it does NOT do:</strong></p>\n<ul>\n<li>It does NOT implement concurrency primitives (mutexes/spinlocks); data races between <code>ioctl</code> and <code>read</code>/<code>write</code> are tolerated in this milestone (resolved in M4).</li>\n<li>It does NOT support <code>compat_ioctl</code> for 32-bit processes on 64-bit kernels (assumes 64-bit parity).</li>\n<li>It does NOT support multi-page <code>/proc</code> output manually; it delegates this to the <code>seq_file</code> iterator.</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li><strong>ABI Stability</strong>: The <code>struct mydev_status</code> layout must be identical in kernel and userspace.</li>\n<li><strong>Command Validation</strong>: Any <code>ioctl</code> command with a non-matching magic number or out-of-range sequence number must return <code>-ENOTTY</code>.</li>\n<li><strong>Memory Safety</strong>: A failed <code>RESIZE</code> allocation must leave the original buffer and data intact (Atomic-like failure).</li>\n</ul>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>The project structure expands to include the shared ABI header and a dedicated userspace test suite.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>build-kernel-module/\nâ”œâ”€â”€ 1. Makefile              # Updated Kbuild to include new objects\nâ”œâ”€â”€ 2. mydevice_ioctl.h      # SHARED: ABI definitions (Magic 'M')\nâ”œâ”€â”€ 3. mychar_dev.c          # UPDATED: ioctl and proc handlers\nâ”œâ”€â”€ 4. test_ioctl.c          # NEW: Userspace test program\nâ””â”€â”€ 5. verify_m3.sh          # NEW: Verification script for control plane</code></pre></div>\n\n<h2 id=\"3-complete-data-model\">3. Complete Data Model</h2>\n<h3 id=\"31-ioctl-command-encoding-wire-format\">3.1 ioctl Command Encoding (Wire Format)</h3>\n<p>Commands are 32-bit integers. We use Magic Number <code>&#39;M&#39;</code> (0x4D).</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field</th>\n<th align=\"left\">Bits</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Direction</strong></td>\n<td align=\"left\">30-31</td>\n<td align=\"left\">00: None (<code>_IO</code>), 01: Write (<code>_IOW</code>), 10: Read (<code>_IOR</code>)</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Size</strong></td>\n<td align=\"left\">16-29</td>\n<td align=\"left\"><code>sizeof()</code> the argument type.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Type</strong></td>\n<td align=\"left\">08-15</td>\n<td align=\"left\">Magic Number: <code>0x4D</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Number</strong></td>\n<td align=\"left\">00-07</td>\n<td align=\"left\">Command sequence (0: Clear, 1: Resize, 2: Status).</td>\n</tr>\n</tbody></table>\n<h3 id=\"32-abi-structure-struct-mydev_status\">3.2 ABI Structure: <code>struct mydev_status</code></h3>\n<p>This structure is passed from kernel to userspace via <code>MYDEV_STATUS</code>.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Size</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0x00</td>\n<td align=\"left\"><code>buffer_size</code></td>\n<td align=\"left\"><code>__u32</code></td>\n<td align=\"left\">4B</td>\n<td align=\"left\">Total capacity of kernel buffer.</td>\n</tr>\n<tr>\n<td align=\"left\">0x04</td>\n<td align=\"left\"><code>bytes_used</code></td>\n<td align=\"left\"><code>__u32</code></td>\n<td align=\"left\">4B</td>\n<td align=\"left\">Currently occupied bytes.</td>\n</tr>\n<tr>\n<td align=\"left\">0x08</td>\n<td align=\"left\"><code>open_count</code></td>\n<td align=\"left\"><code>__u32</code></td>\n<td align=\"left\">4B</td>\n<td align=\"left\">Active file descriptors.</td>\n</tr>\n<tr>\n<td align=\"left\">0x0C</td>\n<td align=\"left\"><code>read_count</code></td>\n<td align=\"left\"><code>__u32</code></td>\n<td align=\"left\">4B</td>\n<td align=\"left\">Total successful <code>read()</code> calls.</td>\n</tr>\n<tr>\n<td align=\"left\">0x10</td>\n<td align=\"left\"><code>write_count</code></td>\n<td align=\"left\"><code>__u32</code></td>\n<td align=\"left\">4B</td>\n<td align=\"left\">Total successful <code>write()</code> calls.</td>\n</tr>\n<tr>\n<td align=\"left\">0x14</td>\n<td align=\"left\"><code>_reserved</code></td>\n<td align=\"left\"><code>__u32</code></td>\n<td align=\"left\">4B</td>\n<td align=\"left\">Padding for 8-byte alignment/future use.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Total</strong></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"><strong>24B</strong></td>\n<td align=\"left\"><strong>Fits in one 64B cache line.</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"33-hardware-soul-cache-amp-alignment\">3.3 Hardware Soul: Cache &amp; Alignment</h3>\n<ul>\n<li><strong>Cache Line Residency</strong>: <code>struct mydev_status</code> is 24 bytes. When the kernel fills this on the stack and calls <code>copy_to_user</code>, the entire struct likely resides in a single L1 cache line.</li>\n<li><strong>Atomic vs Non-Atomic</strong>: <code>read_count</code> and <code>write_count</code> are <code>atomic_t</code>. On x86_64, <code>atomic_read</code> is a simple <code>mov</code> instruction, but the <code>atomic_inc</code> in the data path (M2) ensures that the values seen by <code>MYDEV_STATUS</code> are coherent across CPU cores without requiring a heavy mutex in this milestone.</li>\n</ul>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-header-contract-mydevice_ioctlh\">4.1 Header Contract: <code>mydevice_ioctl.h</code></h3>\n<p>Must use the <code>__KERNEL__</code> guard to switch between kernel-space headers (<code>linux/types.h</code>) and userspace headers (<code>stdint.h</code>).</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> MYDEVICE_IOCTL_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOCTL_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifdef</span><span style=\"color:#B392F0\"> __KERNEL__</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/ioctl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/types.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#else</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/ioctl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> __u32;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEV_MAGIC</span><span style=\"color:#9ECBFF\"> 'M'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEV_CLEAR</span><span style=\"color:#B392F0\">  _IO</span><span style=\"color:#E1E4E8\">(MYDEV_MAGIC, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEV_RESIZE</span><span style=\"color:#B392F0\"> _IOW</span><span style=\"color:#E1E4E8\">(MYDEV_MAGIC, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, __u32)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEV_STATUS</span><span style=\"color:#B392F0\"> _IOR</span><span style=\"color:#E1E4E8\">(MYDEV_MAGIC, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydev_status)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span></code></pre></div>\n\n<h3 id=\"42-ioctl-handler-mydev_ioctl\">4.2 ioctl Handler: <code>mydev_ioctl</code></h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">long</span><span style=\"color:#B392F0\"> mydev_ioctl</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> int</span><span style=\"color:#FFAB70\"> cmd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> arg</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<ul>\n<li><strong>Input</strong>: <code>cmd</code> (the encoded request), <code>arg</code> (address of userspace data).</li>\n<li><strong>Validation</strong>: <ul>\n<li>If <code>_IOC_TYPE(cmd) != MYDEV_MAGIC</code> return <code>-ENOTTY</code>.</li>\n<li>If <code>_IOC_NR(cmd) &gt; 2</code> return <code>-ENOTTY</code>.</li>\n</ul>\n</li>\n<li><strong>Commands</strong>:<ul>\n<li><code>MYDEV_CLEAR</code>: <code>memset(buffer, 0, size)</code>, <code>buffer_used = 0</code>.</li>\n<li><code>MYDEV_RESIZE</code>: See Algorithm 5.1.</li>\n<li><code>MYDEV_STATUS</code>: Fills <code>struct mydev_status</code>, <code>copy_to_user</code>.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"43-proc-interface-seq_file\">4.3 /proc Interface: <code>seq_file</code></h3>\n<p>Utilizes the <code>single_open</code> helper for simple output.</p>\n<ul>\n<li><strong>File</strong>: <code>/proc/mydevice</code>.</li>\n<li><strong>Ops</strong>: <code>struct proc_ops</code> (Kernel 5.6+).</li>\n<li><strong>Output</strong>:</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>    buffer_size: 4096\n    bytes_used: 128\n    open_count: 1\n    read_count: 42\n    write_count: 10</code></pre></div>\n\n<h2 id=\"5-algorithm-specification\">5. Algorithm Specification</h2>\n<h3 id=\"51-allocate-then-swap-buffer-resize\">5.1 Allocate-Then-Swap Buffer Resize</h3>\n<p>This algorithm ensures that a failed memory allocation does not corrupt the existing device state.</p>\n<ol>\n<li><strong>Input</strong>: Userspace pointer <code>arg</code> containing <code>__u32 new_size</code>.</li>\n<li><strong>Fetch</strong>: <code>copy_from_user(&amp;new_size, (__u32 __user *)arg, sizeof(new_size))</code>.<ul>\n<li>On failure: <code>RETURN -EFAULT</code>.</li>\n</ul>\n</li>\n<li><strong>Validate</strong>: <code>IF new_size == 0 OR new_size &gt; 1048576 THEN RETURN -EINVAL</code>.</li>\n<li><strong>Allocate</strong>: <code>tmp_buf = kzalloc(new_size, GFP_KERNEL)</code>.<ul>\n<li>On failure: <code>RETURN -ENOMEM</code>. (Existing buffer/data remains untouched).</li>\n</ul>\n</li>\n<li><strong>Truncate</strong>: <code>copy_len = (buffer_used &lt; new_size) ? buffer_used : new_size</code>.<ul>\n<li><em>Invariant</em>: If shrinking, data beyond <code>new_size</code> is discarded.</li>\n</ul>\n</li>\n<li><strong>Migrate</strong>: <code>memcpy(tmp_buf, old_buffer, copy_len)</code>.</li>\n<li><strong>Finalize</strong>:<ul>\n<li><code>kfree(old_buffer)</code>.</li>\n<li><code>buffer = tmp_buf</code>.</li>\n<li><code>buffer_size = new_size</code>.</li>\n<li><code>buffer_used = copy_len</code>.</li>\n</ul>\n</li>\n<li><strong>Return</strong>: <code>0</code>.</li>\n</ol>\n<h3 id=\"52-seq_file-iteration-logic\">5.2 seq_file Iteration (Logic)</h3>\n<ol>\n<li><strong>Open</strong>: <code>single_open</code> is called. It allocates a <code>struct seq_file</code>.</li>\n<li><strong>Read</strong>: <code>seq_read</code> is called.</li>\n<li><strong>Show</strong>: The kernel calls our <code>my_proc_show</code> function.</li>\n<li><strong>Formatting</strong>: We use <code>seq_printf</code> to write into the kernel-managed buffer. <code>seq_file</code> handles the cases where the output might span multiple 4KB pages by managing an internal offset.</li>\n</ol>\n<h2 id=\"6-error-handling-matrix\">6. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Condition</th>\n<th align=\"left\">User Effect</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>ENOTTY</strong></td>\n<td align=\"left\"><code>mydev_ioctl</code></td>\n<td align=\"left\">Magic mismatch or NR &gt; 2</td>\n<td align=\"left\"><code>ioctl</code> returns -1, <code>errno=ENOTTY</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>EFAULT</strong></td>\n<td align=\"left\"><code>copy_to_user</code></td>\n<td align=\"left\">Bad output pointer in <code>STATUS</code></td>\n<td align=\"left\"><code>ioctl</code> returns -1, <code>errno=EFAULT</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>EINVAL</strong></td>\n<td align=\"left\"><code>mydev_ioctl</code></td>\n<td align=\"left\"><code>RESIZE</code> arg is 0 or &gt; 1MB</td>\n<td align=\"left\"><code>ioctl</code> returns -1, <code>errno=EINVAL</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>ENOMEM</strong></td>\n<td align=\"left\"><code>kzalloc</code></td>\n<td align=\"left\">Kernel cannot find contiguous memory</td>\n<td align=\"left\">Buffer remains at old size</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>NULL Ptr</strong></td>\n<td align=\"left\"><code>proc_create</code></td>\n<td align=\"left\">Internal <code>/proc</code> registration failure</td>\n<td align=\"left\"><code>/proc/mydevice</code> does not appear</td>\n</tr>\n</tbody></table>\n<h2 id=\"7-implementation-sequence-with-checkpoints\">7. Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-shared-header-amp-skeleton-1-hour\">Phase 1: Shared Header &amp; Skeleton (1 Hour)</h3>\n<ol>\n<li>Create <code>mydevice_ioctl.h</code> with direction macros.</li>\n<li>In <code>mychar_dev.c</code>, add <code>unlocked_ioctl</code> to <code>struct file_operations</code>.</li>\n<li>Implement the Magic Number and Command NR range check.</li>\n<li><strong>Checkpoint</strong>: Compile and <code>insmod</code>. Use a dummy C program to call <code>ioctl</code> with magic &#39;Z&#39;. Verify it returns <code>ENOTTY</code>.</li>\n</ol>\n<h3 id=\"phase-2-clear-amp-status-commands-2-hours\">Phase 2: CLEAR &amp; STATUS Commands (2 Hours)</h3>\n<ol>\n<li>Add <code>MYDEV_CLEAR</code> using <code>memset</code>.</li>\n<li>Add <code>MYDEV_STATUS</code>. Implement <code>atomic_inc</code> for <code>read_count</code> and <code>write_count</code> in the M2 handlers.</li>\n<li>Implement <code>copy_to_user</code> for the status struct.</li>\n<li><strong>Checkpoint</strong>: Run test program. Verify <code>STATUS</code> returns <code>buffer_size=4096</code> and <code>open_count=1</code>.</li>\n</ol>\n<h3 id=\"phase-3-resize-implementation-25-hours\">Phase 3: RESIZE Implementation (2.5 Hours)</h3>\n<ol>\n<li>Implement the Allocate-then-swap logic.</li>\n<li>Add truncation logic (handle <code>buffer_used &gt; new_size</code>).</li>\n<li>Verify that <code>new_size &gt; 1MB</code> returns <code>EINVAL</code>.</li>\n<li><strong>Checkpoint</strong>: Resize to 8192. Write data. Resize back to 10. Verify that only 10 bytes remain.</li>\n</ol>\n<h3 id=\"phase-4-proc-filesystem-15-hours\">Phase 4: /proc Filesystem (1.5 Hours)</h3>\n<ol>\n<li>Implement <code>my_proc_show</code> with <code>seq_printf</code>.</li>\n<li>Use <code>proc_create</code> in <code>module_init</code>. Ensure <code>proc_remove</code> in <code>module_exit</code>.</li>\n<li><strong>Checkpoint</strong>: <code>cat /proc/mydevice</code>. Verify all counters increment as you perform reads/writes.</li>\n</ol>\n<h2 id=\"8-test-specification\">8. Test Specification</h2>\n<h3 id=\"81-ioctl-functional-tests\">8.1 ioctl Functional Tests</h3>\n<ul>\n<li><strong>IO-1 (Status Correctness)</strong>:<ul>\n<li>Action: Perform 5 reads, 3 writes. Call <code>MYDEV_STATUS</code>.</li>\n<li>Verify: <code>status.read_count == 5</code>, <code>status.write_count == 3</code>.</li>\n</ul>\n</li>\n<li><strong>IO-2 (Resize Growth)</strong>:<ul>\n<li>Action: Resize to 10000. Write 5000 bytes.</li>\n<li>Verify: <code>write</code> succeeds for all 5000 bytes.</li>\n</ul>\n</li>\n<li><strong>IO-3 (Resize Shrink)</strong>:<ul>\n<li>Action: Write &quot;1234567890&quot; (10 bytes). Resize to 5. Read device.</li>\n<li>Verify: Output is &quot;12345&quot;.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"82-observability-tests\">8.2 Observability Tests</h3>\n<ul>\n<li><strong>P1 (Proc Visibility)</strong>:<ul>\n<li>Action: <code>cat /proc/mydevice</code>.</li>\n<li>Verify: Values match the <code>MYDEV_STATUS</code> ioctl exactly.</li>\n</ul>\n</li>\n<li><strong>P2 (Persistence)</strong>:<ul>\n<li>Action: Close device, <code>cat /proc/mydevice</code>.</li>\n<li>Verify: <code>open_count</code> is 0, but <code>read_count</code>/<code>write_count</code> persist.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"9-performance-targets\">9. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>STATUS Latency</strong></td>\n<td align=\"left\">&lt; 400ns</td>\n<td align=\"left\"><code>clock_gettime</code> around 10k ioctls</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>RESIZE (4K-&gt;8K)</strong></td>\n<td align=\"left\">&lt; 5Âµs</td>\n<td align=\"left\">Kernel <code>ktime_get()</code> timestamps</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>PROC Read</strong></td>\n<td align=\"left\">&lt; 100Âµs</td>\n<td align=\"left\"><code>time cat /proc/mydevice</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Memory usage</strong></td>\n<td align=\"left\">24B struct</td>\n<td align=\"left\"><code>sizeof(struct mydev_status)</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"10-concurrency-specification-m3-context\">10. Concurrency Specification (M3 Context)</h2>\n<p>In this milestone, we acknowledge a <strong>Race Condition</strong> between <code>RESIZE</code> and <code>read/write</code>. </p>\n<ul>\n<li><strong>The Risk</strong>: If one thread is executing <code>memcpy</code> during a <code>RESIZE</code> while another thread is executing <code>copy_to_user</code> in <code>read</code>, the <code>old_buffer</code> may be freed while the reader is accessing it.</li>\n<li><strong>M3 Policy</strong>: For the purposes of this milestone, we accept this race to focus on the ioctl/proc mechanics.</li>\n<li><strong>M4 Preview</strong>: A <code>mutex</code> will be introduced in Milestone 4 to serialize all buffer and size access.</li>\n</ul>\n<h2 id=\"11-three-level-view-resize\">11. Three-Level View: <code>RESIZE</code></h2>\n<ol>\n<li><strong>Application</strong>: <code>ioctl(fd, MYDEV_RESIZE, &amp;val)</code> is called.</li>\n<li><strong>Kernel</strong>: <code>unlocked_ioctl</code> validates the command. It allocates a new page from the SLUB allocator. It copies the user <code>val</code> to the stack.</li>\n<li><strong>Hardware</strong>: The MMU maps the new physical page into the kernel&#39;s virtual address space. <code>memcpy</code> triggers cache line fills for the old buffer and writes to the new buffer&#39;s cache lines.</li>\n</ol>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-kernel-module-m4 -->\n<h1 id=\"module-specification-concurrent-access-blocking-io-and-poll-support-build-kernel-module-m4\">MODULE SPECIFICATION: Concurrent Access, Blocking I/O, and Poll Support (build-kernel-module-m4)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>This module implements the final, production-grade concurrency and synchronization logic for the character device driver. It transforms a simple memory buffer into a thread-safe, multi-process synchronized resource. It provides full support for blocking I/O (where readers sleep until data is available) and non-blocking I/O (returning <code>-EAGAIN</code> via <code>O_NONBLOCK</code>). Crucially, it integrates with the kernel&#39;s event-multiplexing subsystem (<code>poll</code>/<code>select</code>/<code>epoll</code>) by implementing a <code>.poll</code> handler. The module ensures data integrity under heavy contention using <code>struct mutex</code> for serialization and <code>wait_queue_head_t</code> for scheduler-managed task suspension. It does NOT handle hardware interrupts or asynchronous I/O (AIO), focusing entirely on process-context synchronization and POSIX-compliant file semantics.</p>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li><code>dev_mutex</code> must be held during any modification or read of <code>buffer_used</code>, <code>kernel_buffer</code>, or <code>buffer_size_bytes</code>.</li>\n<li><code>dev_mutex</code> MUST be released before calling <code>schedule()</code> or <code>wait_event_interruptible()</code> to prevent producer-consumer deadlocks.</li>\n<li>The <code>.poll</code> handler must never sleep and must return a bitmask of readiness.</li>\n<li><code>wake_up_interruptible()</code> must be called after every state change that could potentially satisfy a waiter&#39;s condition.</li>\n</ul>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>The project files are updated and created in the following order:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>build-kernel-module/\nâ”œâ”€â”€ 1. mydevice_ioctl.h      # (Updated) Unchanged from M3\nâ”œâ”€â”€ 2. mychar_dev.c          # (Updated) Core logic with mutex, waitqueues, and poll\nâ”œâ”€â”€ 3. Makefile              # (Updated) Kbuild targeting new stress test binary\nâ”œâ”€â”€ 4. stress_test.c         # (New) Multi-threaded C validation tool\nâ””â”€â”€ 5. verify_m4.sh          # (New) Automated test runner for concurrency</code></pre></div>\n\n<h2 id=\"3-complete-data-model\">3. Complete Data Model</h2>\n<h3 id=\"31-device-private-structure-struct-my_device_data\">3.1 Device Private Structure (<code>struct my_device_data</code>)</h3>\n<p>We explicitly define the byte-level layout for an x86_64 architecture. The <code>struct mutex</code> and <code>wait_queue_head_t</code> sizes are significant.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Size</th>\n<th align=\"left\">Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0x00</td>\n<td align=\"left\"><code>cdev</code></td>\n<td align=\"left\"><code>struct cdev</code></td>\n<td align=\"left\">104B</td>\n<td align=\"left\">VFS character device backlink.</td>\n</tr>\n<tr>\n<td align=\"left\">0x68</td>\n<td align=\"left\"><code>lock</code></td>\n<td align=\"left\"><code>struct mutex</code></td>\n<td align=\"left\">32B</td>\n<td align=\"left\">Serialization lock for buffer and metadata.</td>\n</tr>\n<tr>\n<td align=\"left\">0x88</td>\n<td align=\"left\"><code>read_queue</code></td>\n<td align=\"left\"><code>wait_queue_head_t</code></td>\n<td align=\"left\">24B</td>\n<td align=\"left\">Queue for readers blocked on empty buffer.</td>\n</tr>\n<tr>\n<td align=\"left\">0xA0</td>\n<td align=\"left\"><code>write_queue</code></td>\n<td align=\"left\"><code>wait_queue_head_t</code></td>\n<td align=\"left\">24B</td>\n<td align=\"left\">Queue for writers blocked on full buffer.</td>\n</tr>\n<tr>\n<td align=\"left\">0xB8</td>\n<td align=\"left\"><code>buffer</code></td>\n<td align=\"left\"><code>char *</code></td>\n<td align=\"left\">8B</td>\n<td align=\"left\">Pointer to the heap-allocated data buffer.</td>\n</tr>\n<tr>\n<td align=\"left\">0xC0</td>\n<td align=\"left\"><code>size</code></td>\n<td align=\"left\"><code>size_t</code></td>\n<td align=\"left\">8B</td>\n<td align=\"left\">Total capacity of the buffer.</td>\n</tr>\n<tr>\n<td align=\"left\">0xC8</td>\n<td align=\"left\"><code>used</code></td>\n<td align=\"left\"><code>size_t</code></td>\n<td align=\"left\">8B</td>\n<td align=\"left\">Bytes currently stored.</td>\n</tr>\n<tr>\n<td align=\"left\">0xD0</td>\n<td align=\"left\"><code>open_count</code></td>\n<td align=\"left\"><code>atomic_t</code></td>\n<td align=\"left\">4B</td>\n<td align=\"left\">SMP-safe open instance counter.</td>\n</tr>\n<tr>\n<td align=\"left\">0xD4</td>\n<td align=\"left\"><code>read_ops</code></td>\n<td align=\"left\"><code>atomic_t</code></td>\n<td align=\"left\">4B</td>\n<td align=\"left\">Statistics: Total successful reads.</td>\n</tr>\n<tr>\n<td align=\"left\">0xD8</td>\n<td align=\"left\"><code>write_ops</code></td>\n<td align=\"left\"><code>atomic_t</code></td>\n<td align=\"left\">4B</td>\n<td align=\"left\">Statistics: Total successful writes.</td>\n</tr>\n<tr>\n<td align=\"left\">0xDC</td>\n<td align=\"left\">(Padding)</td>\n<td align=\"left\"></td>\n<td align=\"left\">4B</td>\n<td align=\"left\">Alignment to 8-byte boundary.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Total</strong></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"><strong>224B</strong></td>\n<td align=\"left\"><strong>Spans ~3.5 Cache Lines (64B each).</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"32-hardware-soul-cache-and-lock-contention\">3.2 Hardware Soul: Cache and Lock Contention</h3>\n<ul>\n<li><strong>Cache Line Bouncing</strong>: The <code>lock</code> (mutex) and <code>used</code> (size_t) reside in close proximity. When CPU 0 acquires the mutex, it takes exclusive (M) ownership of the cache line at <code>0x68</code>. When CPU 1 attempts to check <code>used</code> in the <code>.poll</code> handler, it must request that cache line from CPU 0, causing a &quot;bounce.&quot;</li>\n<li><strong>MESI Protocol</strong>: Frequent <code>atomic_inc</code> on <code>read_ops</code> and <code>write_ops</code> will trigger cache-invalidation signals across the interconnect (UPI/QPI) if multiple CPUs are reading/writing simultaneously.</li>\n<li><strong>Context Switch Overhead</strong>: Transitioning from <code>TASK_INTERRUPTIBLE</code> to <code>TASK_RUNNING</code> requires the scheduler to perform a context switch (~2-4Âµs), which involves saving/restoring registers and partially flushing the TLB (Translation Lookaside Buffer).</li>\n</ul>\n<p>{{DIAGRAM:tdd-diag-21|Device Data Layout|Visualization of the struct my_device_data spanning cache lines}}</p>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-blocking-read-handler\">4.1 Blocking Read Handler</h3>\n<p><code>ssize_t my_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)</code></p>\n<ul>\n<li><strong>Wait Condition</strong>: <code>*f_pos &lt; dev-&gt;used</code>.</li>\n<li><strong>Signal Handling</strong>: If <code>wait_event_interruptible</code> is interrupted by a signal, it returns <code>-ERESTARTSYS</code>. The handler MUST propagate this value to the VFS.</li>\n<li><strong>Non-Blocking</strong>: If <code>O_NONBLOCK</code> is set and no data is available, return <code>-EAGAIN</code>.</li>\n</ul>\n<h3 id=\"42-blocking-write-handler\">4.2 Blocking Write Handler</h3>\n<p><code>ssize_t my_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)</code></p>\n<ul>\n<li><strong>Wait Condition</strong>: <code>dev-&gt;used &lt; dev-&gt;size</code>.</li>\n<li><strong>Side Effect</strong>: Upon successful write, calls <code>wake_up_interruptible(&amp;dev-&gt;read_queue)</code>.</li>\n</ul>\n<h3 id=\"43-poll-handler\">4.3 Poll Handler</h3>\n<p><code>__poll_t my_poll(struct file *filp, poll_table *wait)</code></p>\n<ul>\n<li><strong>Requirement</strong>: MUST call <code>poll_wait()</code> for both <code>read_queue</code> and <code>write_queue</code>.</li>\n<li><strong>Constraint</strong>: Must use <code>mutex_lock()</code> (non-interruptible) for the internal readiness check because <code>.poll</code> cannot return <code>-ERESTARTSYS</code>.</li>\n</ul>\n<h2 id=\"5-algorithm-specification\">5. Algorithm Specification</h2>\n<h3 id=\"51-the-mutex-release-before-sleep-pattern-read\">5.1 The Mutex-Release-Before-Sleep Pattern (Read)</h3>\n<p>This algorithm prevents deadlocks where a reader holds the lock that a producer needs to satisfy the sleep condition.</p>\n<ol>\n<li><strong>Entry</strong>: <code>mutex_lock_interruptible(&amp;dev-&gt;lock)</code>. If interrupted, return <code>-ERESTARTSYS</code>.</li>\n<li><strong>Condition Loop</strong>:<ul>\n<li><code>WHILE (*f_pos &gt;= dev-&gt;used)</code>:<ul>\n<li><code>IF (filp-&gt;f_flags &amp; O_NONBLOCK)</code>: <code>mutex_unlock(&amp;dev-&gt;lock)</code>; <code>RETURN -EAGAIN</code>.</li>\n<li><code>mutex_unlock(&amp;dev-&gt;lock)</code>.</li>\n<li><code>ret = wait_event_interruptible(dev-&gt;read_queue, (dev-&gt;used &gt; *f_pos))</code>.</li>\n<li><code>IF (ret != 0)</code>: <code>RETURN -ERESTARTSYS</code>.</li>\n<li><code>mutex_lock_interruptible(&amp;dev-&gt;lock)</code>. If interrupted, return <code>-ERESTARTSYS</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Critical Section</strong>: Perform <code>copy_to_user</code> and increment <code>read_ops</code>.</li>\n<li><strong>Notification</strong>: <code>wake_up_interruptible(&amp;dev-&gt;write_queue)</code>.</li>\n<li><strong>Exit</strong>: <code>mutex_unlock(&amp;dev-&gt;lock)</code>.</li>\n</ol>\n<p>{{DIAGRAM:tdd-diag-22|Blocking Read Sequence|Sequence diagram of mutex management during wait_event}}</p>\n<h3 id=\"52-poll-implementation-logic\">5.2 Poll Implementation Logic</h3>\n<ol>\n<li><strong>Registration</strong>: <code>poll_wait(filp, &amp;dev-&gt;read_queue, wait)</code>.</li>\n<li><strong>Registration</strong>: <code>poll_wait(filp, &amp;dev-&gt;write_queue, wait)</code>.</li>\n<li><strong>Check</strong>: <code>mutex_lock(&amp;dev-&gt;lock)</code>.</li>\n<li><strong>Evaluate</strong>:<ul>\n<li><code>IF (dev-&gt;used &gt; 0)</code>: <code>mask |= (POLLIN | POLLRDNORM)</code>.</li>\n<li><code>IF (dev-&gt;used &lt; dev-&gt;size)</code>: <code>mask |= (POLLOUT | POLLWRNORM)</code>.</li>\n</ul>\n</li>\n<li><strong>Unlock</strong>: <code>mutex_unlock(&amp;dev-&gt;lock)</code>.</li>\n<li><strong>Return</strong>: <code>mask</code>.</li>\n</ol>\n<h2 id=\"6-error-handling-matrix\">6. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery Action</th>\n<th align=\"left\">User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>-ERESTARTSYS</strong></td>\n<td align=\"left\"><code>wait_event_interruptible</code></td>\n<td align=\"left\">Propagate to VFS; do not convert to <code>EINTR</code>.</td>\n<td align=\"left\">No (converted by VFS/Signal logic).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>-EAGAIN</strong></td>\n<td align=\"left\"><code>my_read</code> / <code>my_write</code></td>\n<td align=\"left\">Return immediately if <code>O_NONBLOCK</code> is set.</td>\n<td align=\"left\">Yes (<code>errno = EAGAIN</code>).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>-EDEADLK</strong></td>\n<td align=\"left\">Kernel Lockdep</td>\n<td align=\"left\">Ensure strict lock ordering (though only one mutex used).</td>\n<td align=\"left\">Yes (Kernel Oops/Console).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Partial Copy</strong></td>\n<td align=\"left\"><code>copy_to_user</code></td>\n<td align=\"left\">Update <code>f_pos</code> by bytes actually copied; return count.</td>\n<td align=\"left\">Yes (Short read).</td>\n</tr>\n</tbody></table>\n<h2 id=\"7-implementation-sequence-with-checkpoints\">7. Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-serialization-15-hours\">Phase 1: Serialization (1.5 Hours)</h3>\n<ol>\n<li>Add <code>DEFINE_MUTEX(dev_mutex)</code> and <code>DECLARE_WAIT_QUEUE_HEAD</code> for both queues.</li>\n<li>Wrap the existing <code>read</code>/<code>write</code>/<code>ioctl</code> logic in <code>mutex_lock_interruptible</code>.</li>\n<li><strong>Checkpoint</strong>: Run the M3 test program. It should still work perfectly, but now serialized.</li>\n</ol>\n<h3 id=\"phase-2-blocking-read-2-hours\">Phase 2: Blocking Read (2 Hours)</h3>\n<ol>\n<li>Implement the <code>WHILE</code> loop in <code>my_read</code>.</li>\n<li>Integrate <code>wait_event_interruptible</code> with the mutex release/reacquire pattern.</li>\n<li><strong>Checkpoint</strong>: Open terminal 1: <code>cat /dev/mydevice</code> (should hang). Open terminal 2: <code>echo &quot;data&quot; &gt; /dev/mydevice</code>. Terminal 1 should immediately print &quot;data&quot; and continue hanging.</li>\n</ol>\n<h3 id=\"phase-3-blocking-write-amp-wakeups-15-hours\">Phase 3: Blocking Write &amp; Wakeups (1.5 Hours)</h3>\n<ol>\n<li>Implement blocking logic in <code>my_write</code> for full buffers.</li>\n<li>Add <code>wake_up_interruptible</code> calls to both handlers.</li>\n<li><strong>Checkpoint</strong>: Fill the 4KB buffer. A subsequent <code>echo &quot;more&quot; &gt; /dev/mydevice</code> should hang until a reader consumes data.</li>\n</ol>\n<h3 id=\"phase-4-o_nonblock-amp-poll-2-hours\">Phase 4: O_NONBLOCK &amp; Poll (2 Hours)</h3>\n<ol>\n<li>Add <code>O_NONBLOCK</code> checks.</li>\n<li>Implement the <code>.poll</code> handler.</li>\n<li><strong>Checkpoint</strong>: Run <code>poll_test.c</code>. Verify that <code>poll()</code> returns <code>POLLOUT</code> when empty and <code>POLLIN</code> when data is added.</li>\n</ol>\n<h3 id=\"phase-5-concurrent-stress-test-25-hours\">Phase 5: Concurrent Stress Test (2.5 Hours)</h3>\n<ol>\n<li>Develop <code>stress_test.c</code> with <code>pthread</code> for 4 writers and 4 readers.</li>\n<li>Implement per-thread byte counting and total checksumming.</li>\n<li><strong>Checkpoint</strong>: Run <code>./stress_test</code>. Verify total bytes written == total bytes read. Check <code>dmesg</code> for Oops.</li>\n</ol>\n<h2 id=\"8-test-specification\">8. Test Specification</h2>\n<h3 id=\"81-unit-tests\">8.1 Unit Tests</h3>\n<ul>\n<li><strong>UT-1 (Signal Interruption)</strong>: Block a reader with <code>cat</code>. Send <code>SIGINT</code> (Ctrl+C).<ul>\n<li>Expected: <code>cat</code> exits cleanly. <code>dmesg</code> shows <code>-ERESTARTSYS</code> or handled exit.</li>\n</ul>\n</li>\n<li><strong>UT-2 (Non-blocking Entry)</strong>: <code>open(&quot;/dev/mydevice&quot;, O_RDONLY | O_NONBLOCK)</code>. Read immediately.<ul>\n<li>Expected: <code>read</code> returns <code>-1</code>, <code>errno</code> is <code>EAGAIN</code>.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"82-stress-test-the-quotcruciblequot\">8.2 Stress Test (The &quot;Crucible&quot;)</h3>\n<ul>\n<li><strong>Setup</strong>: <ul>\n<li><code>Writers[0-3]</code>: Each writes 10,000 chunks of 32 bytes.</li>\n<li><code>Readers[0-3]</code>: Each reads in a loop until 80,000 bytes total are collected.</li>\n</ul>\n</li>\n<li><strong>Validation</strong>: <ul>\n<li><code>Sum(Writers.written) == Sum(Readers.read)</code>.</li>\n<li><code>grep -i &quot;oops&quot; /var/log/syslog</code> -&gt; Zero results.</li>\n<li><code>grep -i &quot;warning&quot; /var/log/syslog</code> -&gt; Zero results.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"9-performance-targets\">9. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement Tool</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Uncontended Lock</strong></td>\n<td align=\"left\">~12ns</td>\n<td align=\"left\"><code>perf stat</code> (instructions per cycle)</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Context Switch</strong></td>\n<td align=\"left\">&lt; 5Âµs</td>\n<td align=\"left\"><code>lat_ctx</code> from lmbench</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Wait Queue Fast Path</strong></td>\n<td align=\"left\">&lt; 100ns</td>\n<td align=\"left\"><code>ftrace</code> (function graph)</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Throughput (Concurrent)</strong></td>\n<td align=\"left\">&gt; 500 MB/s</td>\n<td align=\"left\"><code>dd</code> with multiple processes</td>\n</tr>\n</tbody></table>\n<h2 id=\"10-state-machine-reader-lifecycle\">10. State Machine: Reader Lifecycle</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>[ RUNNING ] \n     |\n     | (read() called, buffer empty)\n     v\n[ MUTEX_WAIT ] --&gt; (acquired) --&gt; [ CHECK_CONDITION ]\n                                         |\n                                         | (empty)\n                                         v\n[ TASK_INTERRUPTIBLE ] &lt;---------- [ RELEASE_MUTEX ]\n     |\n     | (wake_up_interruptible)\n     v\n[ TASK_RUNNING (Pending Mutex) ]\n     |\n     | (mutex acquired)\n     v\n[ COPY_TO_USER ] --&gt; [ RELEASE_MUTEX ] --&gt; [ RETURN ]</code></pre></div>\n\n<h2 id=\"11-security-amp-constraints\">11. Security &amp; Constraints</h2>\n<ul>\n<li><strong>Unkillable Processes</strong>: If <code>wait_event</code> (uninterruptible) were used instead of <code>wait_event_interruptible</code>, a process waiting for data that never arrives would be unkillable even by <code>SIGKILL</code> (appearing as <code>D</code> state in <code>ps</code>). We strictly use the <code>_interruptible</code> variant.</li>\n<li><strong>Buffer Overflow</strong>: The <code>dev_mutex</code> protects against two writers incrementing <code>buffer_used</code> simultaneously, which would have allowed writes past the 4096-byte boundary.</li>\n</ul>\n<!-- END_TDD_MOD -->\n\n\n<h1 id=\"project-structure-linux-kernel-module\">Project Structure: Linux Kernel Module</h1>\n<h2 id=\"directory-tree\">Directory Tree</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>build-kernel-module/\nâ”œâ”€â”€ Makefile                # Kbuild system (Delegates to kernel build logic)\nâ”œâ”€â”€ mychar_dev.c            # Main driver source (M1: Skeleton -&gt; M4: Full Sync)\nâ”œâ”€â”€ mychar_dev.h            # Internal driver structure &amp; constants (M2)\nâ”œâ”€â”€ mydevice_ioctl.h        # SHARED ABI: Magic numbers &amp; ioctl structs (M3)\nâ”œâ”€â”€ tests/                  # Userspace test suite\nâ”‚   â”œâ”€â”€ test_ioctl.c        # Userspace binary for control plane (M3)\nâ”‚   â”œâ”€â”€ stress_test.c       # Multi-threaded concurrency crucible (M4)\nâ”‚   â”œâ”€â”€ verify_m1.sh        # M1: Lifecycle &amp; parameter verification\nâ”‚   â”œâ”€â”€ test_driver.sh      # M2: Round-trip data integrity (echo/cat)\nâ”‚   â”œâ”€â”€ verify_m3.sh        # M3: ioctl &amp; /proc validation\nâ”‚   â””â”€â”€ verify_m4.sh        # M4: Blocking I/O &amp; signal handling tests\nâ”œâ”€â”€ .gitignore              # Standard kernel build artifacts (e.g., *.ko, *.mod.c)\nâ””â”€â”€ README.md               # Project documentation</code></pre></div>\n\n<h2 id=\"creation-order\">Creation Order</h2>\n<ol>\n<li><p><strong>Environment &amp; Build Setup</strong> (M1)</p>\n<ul>\n<li>Install linux-headers for <code>uname -r</code>.</li>\n<li>Create <code>Makefile</code> using the <code>obj-m</code> Kbuild pattern.</li>\n</ul>\n</li>\n<li><p><strong>Basic Module Skeleton</strong> (M1)</p>\n<ul>\n<li>Create <code>mychar_dev.c</code> (initially <code>hello.c</code>).</li>\n<li>Implement <code>module_init</code>, <code>module_exit</code>, and <code>module_param</code>.</li>\n<li>Verify with <code>tests/verify_m1.sh</code>.</li>\n</ul>\n</li>\n<li><p><strong>Character Device &amp; VFS Implementation</strong> (M2)</p>\n<ul>\n<li>Create <code>mychar_dev.h</code> for <code>struct my_device_data</code>.</li>\n<li>Implement <code>alloc_chrdev_region</code> and <code>cdev_add</code> in <code>mychar_dev.c</code>.</li>\n<li>Implement <code>device_create</code> for automatic <code>/dev/</code> node.</li>\n<li>Implement <code>read</code> and <code>write</code> with <code>copy_to_user</code> and <code>copy_from_user</code>.</li>\n<li>Verify with <code>tests/test_driver.sh</code>.</li>\n</ul>\n</li>\n<li><p><strong>The Control Plane (ioctl &amp; /proc)</strong> (M3)</p>\n<ul>\n<li>Create <code>mydevice_ioctl.h</code> (Shared ABI).</li>\n<li>Implement <code>unlocked_ioctl</code> handler in <code>mychar_dev.c</code> (RESIZE, CLEAR, STATUS).</li>\n<li>Implement <code>/proc/mydevice</code> using the <code>seq_file</code> interface.</li>\n<li>Create <code>tests/test_ioctl.c</code> to exercise the ABI.</li>\n<li>Verify with <code>tests/verify_m3.sh</code>.</li>\n</ul>\n</li>\n<li><p><strong>Concurrency &amp; Event Multiplexing</strong> (M4)</p>\n<ul>\n<li>Update <code>mychar_dev.c</code> to include <code>struct mutex</code> and <code>wait_queue_head_t</code>.</li>\n<li>Implement blocking <code>read</code> and <code>write</code> (Sleep/Wake pattern).</li>\n<li>Implement the <code>.poll</code> handler for <code>select/epoll</code> integration.</li>\n<li>Handle <code>O_NONBLOCK</code> and <code>-ERESTARTSYS</code> for signals.</li>\n</ul>\n</li>\n<li><p><strong>Stress Testing</strong> (M4)</p>\n<ul>\n<li>Create <code>tests/stress_test.c</code> (pthreads).</li>\n<li>Execute <code>tests/verify_m4.sh</code> for final production sign-off.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"file-count-summary\">File Count Summary</h2>\n<ul>\n<li><strong>Total files</strong>: 10</li>\n<li><strong>Directories</strong>: 2</li>\n<li><strong>Estimated lines of code</strong>: ~850-1,000 LOC<ul>\n<li><em>Kernel-side</em>: ~500 LOC</li>\n<li><em>Userspace tests</em>: ~400 LOC</li>\n</ul>\n</li>\n<li><strong>Build Output</strong>: <code>mychar_dev.ko</code> (Kernel Object)</li>\n</ul>\n","toc":[{"level":1,"text":"ðŸŽ¯ Project Charter: Linux Kernel Module","id":"-project-charter-linux-kernel-module"},{"level":2,"text":"What You Are Building","id":"what-you-are-building"},{"level":2,"text":"Why This Project Exists","id":"why-this-project-exists"},{"level":2,"text":"What You Will Be Able to Do When Done","id":"what-you-will-be-able-to-do-when-done"},{"level":2,"text":"Final Deliverable","id":"final-deliverable"},{"level":2,"text":"Is This Project For You?","id":"is-this-project-for-you"},{"level":2,"text":"Estimated Effort","id":"estimated-effort"},{"level":2,"text":"Definition of Done","id":"definition-of-done"},{"level":2,"text":"Writing the Minimal Module","id":"writing-the-minimal-module"},{"level":3,"text":"Include Headers â€” The Kernel&#39;s Standard Library","id":"include-headers-the-kernel39s-standard-library"},{"level":3,"text":"Module Metadata Macros","id":"module-metadata-macros"},{"level":3,"text":"__init and __exit â€” Section Annotations","id":"__init-and-__exit-section-annotations"},{"level":3,"text":"module_init() and module_exit() â€” Registration","id":"module_init-and-module_exit-registration"},{"level":2,"text":"These macros register your init and exit functions with the kernel&#39;s module framework. They don&#39;t call the functions â€” they tell the kernel loader &quot;when this module is loaded, call hello_init; when it&#39;s unloaded, call hello_exit.&quot;\nThe return value of the init function is critical: returning 0 means success, returning a negative error code (like -ENOMEM for out-of-memory, or -EBUSY for a resource conflict) causes insmod to fail and the module to not be loaded. The error code propagates back to the insmod process as the exit status. Never return a positive value from init â€” positive values have undefined behavior in this context.\nIf init returns an error, the kernel guarantees that exit will not be called. This means your init function must clean up any resources it already allocated before returning the error â€” a partial initialization that returns an error but leaves resources allocated will leak them permanently.","id":"these-macros-register-your-init-and-exit-functions-with-the-kernel39s-module-framework-they-don39t-call-the-functions-they-tell-the-kernel-loader-quotwhen-this-module-is-loaded-call-hello_init-when-it39s-unloaded-call-hello_exitquot-the-return-value-of-the-init-function-is-critical-returning-0-means-success-returning-a-negative-error-code-like-enomem-for-out-of-memory-or-ebusy-for-a-resource-conflict-causes-insmod-to-fail-and-the-module-to-not-be-loaded-the-error-code-propagates-back-to-the-insmod-process-as-the-exit-status-never-return-a-positive-value-from-init-positive-values-have-undefined-behavior-in-this-context-if-init-returns-an-error-the-kernel-guarantees-that-exit-will-not-be-called-this-means-your-init-function-must-clean-up-any-resources-it-already-allocated-before-returning-the-error-a-partial-initialization-that-returns-an-error-but-leaves-resources-allocated-will-leak-them-permanently"},{"level":2,"text":"printk â€” Logging Without a Terminal","id":"printk-logging-without-a-terminal"},{"level":2,"text":"The timestamp format in dmesg output ([12345.678901]) is seconds since boot, not wall clock time. Use dmesg -T to convert to human-readable timestamps.","id":"the-timestamp-format-in-dmesg-output-12345678901-is-seconds-since-boot-not-wall-clock-time-use-dmesg-t-to-convert-to-human-readable-timestamps"},{"level":2,"text":"Module Parameters: Runtime Configurability","id":"module-parameters-runtime-configurability"},{"level":2,"text":"The Module Metadata Flow","id":"the-module-metadata-flow"},{"level":2,"text":"The vermagic field is the kernel&#39;s version check mechanism: when insmod loads the .ko, the kernel compares the embedded vermagic string against the running kernel&#39;s own version string. If they don&#39;t match, loading fails with disagrees about version of symbol module_layout. This is the safety guard that prevents you from loading a module compiled against kernel 6.7 into a kernel running 6.8.","id":"the-vermagic-field-is-the-kernel39s-version-check-mechanism-when-insmod-loads-the-ko-the-kernel-compares-the-embedded-vermagic-string-against-the-running-kernel39s-own-version-string-if-they-don39t-match-loading-fails-with-disagrees-about-version-of-symbol-module_layout-this-is-the-safety-guard-that-prevents-you-from-loading-a-module-compiled-against-kernel-67-into-a-kernel-running-68"},{"level":2,"text":"The Complete Module: Putting It Together","id":"the-complete-module-putting-it-together"},{"level":3,"text":"Building It","id":"building-it"},{"level":3,"text":"Loading and Verifying","id":"loading-and-verifying"},{"level":3,"text":"The Verification Script","id":"the-verification-script"},{"level":2,"text":"Common Pitfalls and Their Consequences","id":"common-pitfalls-and-their-consequences"},{"level":3,"text":"Missing MODULE_LICENSE(&quot;GPL&quot;) â€” Tainted Kernel, Missing Symbols","id":"missing-module_licensequotgplquot-tainted-kernel-missing-symbols"},{"level":3,"text":"Mismatched Kernel Headers â€” Silent ABI Corruption","id":"mismatched-kernel-headers-silent-abi-corruption"},{"level":3,"text":"printk Without Log Level â€” Invisible Messages","id":"printk-without-log-level-invisible-messages"},{"level":3,"text":"Module Parameter Permissions 0666 â€” Security Vulnerability","id":"module-parameter-permissions-0666-security-vulnerability"},{"level":3,"text":"Returning Positive Value From module_init â€” Undefined Behavior","id":"returning-positive-value-from-module_init-undefined-behavior"},{"level":3,"text":"Failing to Compile With -Werror","id":"failing-to-compile-with-werror"},{"level":2,"text":"A warning-free build is a requirement for any kernel code that might be submitted upstream, and it&#39;s a good discipline even for local modules. Warnings in kernel code are frequently indicators of real bugs, not style issues.","id":"a-warning-free-build-is-a-requirement-for-any-kernel-code-that-might-be-submitted-upstream-and-it39s-a-good-discipline-even-for-local-modules-warnings-in-kernel-code-are-frequently-indicators-of-real-bugs-not-style-issues"},{"level":2,"text":"Three-Level View: What Happens During insmod","id":"three-level-view-what-happens-during-insmod"},{"level":2,"text":"Knowledge Cascade: What You&#39;ve Just Unlocked","id":"knowledge-cascade-what-you39ve-just-unlocked"},{"level":2,"text":"Completing this milestone doesn&#39;t just teach you how to write &quot;Hello World&quot; in the kernel. It unlocks a constellation of related concepts:\nâ†’ ELF Section Mechanics (same domain): The __init, __exit, and .modinfo annotations you used are instances of a general ELF mechanism â€” placing data in named sections. The linker script that produces vmlinux (the kernel binary) uses the same mechanism to organize init callbacks, exception tables, and system call tables. When you later encounter __attribute__((section(&quot;.data.once&quot;))) or similar in kernel source, you&#39;ll recognize the pattern.\nâ†’ Symbol Export and GPL Enforcement (cross-domain: licensing meets ABI): The fact that MODULE_LICENSE(&quot;GPL&quot;) technically controls API access â€” not just as a legal statement but as a runtime enforcement mechanism â€” is a fascinating intersection of intellectual property policy and systems design. The kernel uses EXPORT_SYMBOL vs EXPORT_SYMBOL_GPL as a technical implementation of the GPL&#39;s copyleft requirement. This is the same design philosophy as &quot;capabilities&quot; in security: enforcement at the technical layer, not just the policy layer.\nâ†’ sysfs as Universal Control Plane (cross-domain: same pattern as Prometheus): The /sys/module/&lt;name&gt;/parameters/ interface you just created is an instance of the sysfs virtual filesystem â€” a tree of kernel objects exposed as files. The same infrastructure exposes CPU frequency scaling under /sys/devices/system/cpu/, USB device properties under /sys/bus/usb/, and block device queue parameters under /sys/block/&lt;dev&gt;/queue/. When you look at a Kubernetes node&#39;s /sys tree or a Prometheus node exporter scraping hardware metrics, they&#39;re reading the same virtual files you just learned to write. The mental model â€” &quot;make kernel state accessible as filesystem entries&quot; â€” is one of Linux&#39;s most powerful design patterns.\nâ†’ printk Ring Buffer â†’ You&#39;re Building a Character Device (forward): The dmesg command reads /dev/kmsg, which is a character device. The ring buffer architecture â€” a fixed-size circular buffer in kernel memory, with a reader that advances through it â€” is structurally identical to what you&#39;ll implement in Milestone 2. When you implement your read file operation and manage a buf_pos offset, you&#39;re implementing the same mechanism that dmesg uses to read the printk ring buffer.\nâ†’ Module Parameters â†’ Kernel Configuration Philosophy: The sysfs-backed parameter you created is a micro-example of the kernel&#39;s general configuration philosophy: separate the policy (what values mean) from the mechanism (how they&#39;re stored and accessed). The same philosophy appears in the kernel&#39;s sysctl interface (/proc/sys/), in device tree overlays, and in runtime kernel configuration via kconfig. Knowing one, you understand the pattern behind all of them.","id":"completing-this-milestone-doesn39t-just-teach-you-how-to-write-quothello-worldquot-in-the-kernel-it-unlocks-a-constellation-of-related-concepts-elf-section-mechanics-same-domain-the-__init-__exit-and-modinfo-annotations-you-used-are-instances-of-a-general-elf-mechanism-placing-data-in-named-sections-the-linker-script-that-produces-vmlinux-the-kernel-binary-uses-the-same-mechanism-to-organize-init-callbacks-exception-tables-and-system-call-tables-when-you-later-encounter-__attribute__sectionquotdataoncequot-or-similar-in-kernel-source-you39ll-recognize-the-pattern-symbol-export-and-gpl-enforcement-cross-domain-licensing-meets-abi-the-fact-that-module_licensequotgplquot-technically-controls-api-access-not-just-as-a-legal-statement-but-as-a-runtime-enforcement-mechanism-is-a-fascinating-intersection-of-intellectual-property-policy-and-systems-design-the-kernel-uses-export_symbol-vs-export_symbol_gpl-as-a-technical-implementation-of-the-gpl39s-copyleft-requirement-this-is-the-same-design-philosophy-as-quotcapabilitiesquot-in-security-enforcement-at-the-technical-layer-not-just-the-policy-layer-sysfs-as-universal-control-plane-cross-domain-same-pattern-as-prometheus-the-sysmoduleltnamegtparameters-interface-you-just-created-is-an-instance-of-the-sysfs-virtual-filesystem-a-tree-of-kernel-objects-exposed-as-files-the-same-infrastructure-exposes-cpu-frequency-scaling-under-sysdevicessystemcpu-usb-device-properties-under-sysbususb-and-block-device-queue-parameters-under-sysblockltdevgtqueue-when-you-look-at-a-kubernetes-node39s-sys-tree-or-a-prometheus-node-exporter-scraping-hardware-metrics-they39re-reading-the-same-virtual-files-you-just-learned-to-write-the-mental-model-quotmake-kernel-state-accessible-as-filesystem-entriesquot-is-one-of-linux39s-most-powerful-design-patterns-printk-ring-buffer-you39re-building-a-character-device-forward-the-dmesg-command-reads-devkmsg-which-is-a-character-device-the-ring-buffer-architecture-a-fixed-size-circular-buffer-in-kernel-memory-with-a-reader-that-advances-through-it-is-structurally-identical-to-what-you39ll-implement-in-milestone-2-when-you-implement-your-read-file-operation-and-manage-a-buf_pos-offset-you39re-implementing-the-same-mechanism-that-dmesg-uses-to-read-the-printk-ring-buffer-module-parameters-kernel-configuration-philosophy-the-sysfs-backed-parameter-you-created-is-a-micro-example-of-the-kernel39s-general-configuration-philosophy-separate-the-policy-what-values-mean-from-the-mechanism-how-they39re-stored-and-accessed-the-same-philosophy-appears-in-the-kernel39s-sysctl-interface-procsys-in-device-tree-overlays-and-in-runtime-kernel-configuration-via-kconfig-knowing-one-you-understand-the-pattern-behind-all-of-them"},{"level":2,"text":"Acceptance Criteria Checkpoint","id":"acceptance-criteria-checkpoint"},{"level":1,"text":"Milestone 2: Character Device Driver","id":"milestone-2-character-device-driver"},{"level":2,"text":"The Revelation: User Pointers Are Traps","id":"the-revelation-user-pointers-are-traps"},{"level":2,"text":"This is one of the most important pieces of kernel API design you&#39;ll encounter. Every single data transfer path in your driver â€” now and forever â€” goes through copy_from_user or copy_to_user. There are no exceptions. Not for &quot;trusted&quot; programs. Not for root processes. Not for &quot;small&quot; copies. The exception table mechanism exists to guarantee that even hostile or buggy userspace cannot crash the kernel through your driver.","id":"this-is-one-of-the-most-important-pieces-of-kernel-api-design-you39ll-encounter-every-single-data-transfer-path-in-your-driver-now-and-forever-goes-through-copy_from_user-or-copy_to_user-there-are-no-exceptions-not-for-quottrustedquot-programs-not-for-root-processes-not-for-quotsmallquot-copies-the-exception-table-mechanism-exists-to-guarantee-that-even-hostile-or-buggy-userspace-cannot-crash-the-kernel-through-your-driver"},{"level":2,"text":"The Architecture Before the Code","id":"the-architecture-before-the-code"},{"level":2,"text":"The struct file_operations is the kernel&#39;s equivalent of a C++ vtable or a Go interface: a struct of function pointers where each pointer implements one operation. Your driver fills in the ones it cares about; the ones left NULL get default behavior (or return -ENOSYS for &quot;not implemented&quot;).","id":"the-struct-file_operations-is-the-kernel39s-equivalent-of-a-c-vtable-or-a-go-interface-a-struct-of-function-pointers-where-each-pointer-implements-one-operation-your-driver-fills-in-the-ones-it-cares-about-the-ones-left-null-get-default-behavior-or-return-enosys-for-quotnot-implementedquot"},{"level":2,"text":"How write(2) Becomes Your Function","id":"how-write2-becomes-your-function"},{"level":2,"text":"Device Numbers: Dynamic Allocation","id":"device-numbers-dynamic-allocation"},{"level":2,"text":"Critical cleanup rule: every successful alloc_chrdev_region() must be paired with unregister_chrdev_region() in your exit path and error paths. The kernel does not automatically reclaim device numbers when a module exits without cleanup.","id":"critical-cleanup-rule-every-successful-alloc_chrdev_region-must-be-paired-with-unregister_chrdev_region-in-your-exit-path-and-error-paths-the-kernel-does-not-automatically-reclaim-device-numbers-when-a-module-exits-without-cleanup"},{"level":2,"text":"The cdev Structure: Connecting Numbers to Operations","id":"the-cdev-structure-connecting-numbers-to-operations"},{"level":2,"text":"cdev_add() makes the device live â€” from this point, if anything opens the device number, the kernel will dispatch to your mydev_fops. This is why error handling order matters: you don&#39;t want the device reachable before it&#39;s fully initialized.\nThe .owner = THIS_MODULE field prevents the module from being unloaded while the device has open file descriptors. THIS_MODULE is a pointer to the struct module that represents your module. The VFS increments the module&#39;s reference count when a file is opened and decrements it on close. If you omit .owner, rmmod can unload your module while a process still has an open file descriptor â€” the next read() call would jump to the now-unmapped function and crash the kernel.","id":"cdev_add-makes-the-device-live-from-this-point-if-anything-opens-the-device-number-the-kernel-will-dispatch-to-your-mydev_fops-this-is-why-error-handling-order-matters-you-don39t-want-the-device-reachable-before-it39s-fully-initialized-the-owner-this_module-field-prevents-the-module-from-being-unloaded-while-the-device-has-open-file-descriptors-this_module-is-a-pointer-to-the-struct-module-that-represents-your-module-the-vfs-increments-the-module39s-reference-count-when-a-file-is-opened-and-decrements-it-on-close-if-you-omit-owner-rmmod-can-unload-your-module-while-a-process-still-has-an-open-file-descriptor-the-next-read-call-would-jump-to-the-now-unmapped-function-and-crash-the-kernel"},{"level":2,"text":"Automatic /dev/ Nodes: class_create and device_create","id":"automatic-dev-nodes-class_create-and-device_create"},{"level":2,"text":"The Kernel Buffer: kmalloc and the SLAB Allocator","id":"the-kernel-buffer-kmalloc-and-the-slab-allocator"},{"level":2,"text":"Implementing file_operations: Open and Release","id":"implementing-file_operations-open-and-release"},{"level":2,"text":"This is crucial for drivers that manage multiple device instances â€” each minor number maps to a different device state, and you need to find the right one in your handlers.","id":"this-is-crucial-for-drivers-that-manage-multiple-device-instances-each-minor-number-maps-to-a-different-device-state-and-you-need-to-find-the-right-one-in-your-handlers"},{"level":2,"text":"Implementing Write: copy_from_user in Practice","id":"implementing-write-copy_from_user-in-practice"},{"level":2,"text":"Implementing Read: f_pos Tracking and the EOF Contract","id":"implementing-read-f_pos-tracking-and-the-eof-contract"},{"level":2,"text":"The Complete Device: Putting It All Together","id":"the-complete-device-putting-it-all-together"},{"level":3,"text":"The Goto Error Handling Pattern","id":"the-goto-error-handling-pattern"},{"level":2,"text":"Notice the goto labels in mydev_init. This is not sloppy code â€” it is the canonical kernel idiom for error handling with multiple resources. The structure ensures that if step N fails, steps 1 through N-1 are cleaned up in reverse order. Without this, a failure in class_create would leak the cdev and device number.\nThe alternative â€” nested if-else chains â€” produces deeply indented, hard-to-read code. The goto pattern keeps the success path reading top-to-bottom, with the cleanup code separated at the bottom. Every experienced kernel developer uses this pattern. If you see a kernel function without it, that function probably has a resource leak.","id":"notice-the-goto-labels-in-mydev_init-this-is-not-sloppy-code-it-is-the-canonical-kernel-idiom-for-error-handling-with-multiple-resources-the-structure-ensures-that-if-step-n-fails-steps-1-through-n-1-are-cleaned-up-in-reverse-order-without-this-a-failure-in-class_create-would-leak-the-cdev-and-device-number-the-alternative-nested-if-else-chains-produces-deeply-indented-hard-to-read-code-the-goto-pattern-keeps-the-success-path-reading-top-to-bottom-with-the-cleanup-code-separated-at-the-bottom-every-experienced-kernel-developer-uses-this-pattern-if-you-see-a-kernel-function-without-it-that-function-probably-has-a-resource-leak"},{"level":2,"text":"The Kbuild Makefile for This Module","id":"the-kbuild-makefile-for-this-module"},{"level":2,"text":"Verification: The echo/cat Round Trip","id":"verification-the-echocat-round-trip"},{"level":2,"text":"Why does cat terminate? When cat opens the device, *f_pos starts at 0. The first read() call returns &quot;hello\\n&quot; (6 bytes) and advances *f_pos to 6. Since buffer_used is also 6, the second read() call hits *f_pos &gt;= buffer_used and returns 0 (EOF). cat sees EOF and exits.\nWhy does a second cat read nothing? After the first cat finishes, buffer_used is still 6, but *f_pos for the new open is 0. So a second cat would read &quot;hello\\n&quot; again. The buffer persists until overwritten or the module is unloaded. This is the intended behavior for a simple device.","id":"why-does-cat-terminate-when-cat-opens-the-device-f_pos-starts-at-0-the-first-read-call-returns-quothellonquot-6-bytes-and-advances-f_pos-to-6-since-buffer_used-is-also-6-the-second-read-call-hits-f_pos-gt-buffer_used-and-returns-0-eof-cat-sees-eof-and-exits-why-does-a-second-cat-read-nothing-after-the-first-cat-finishes-buffer_used-is-still-6-but-f_pos-for-the-new-open-is-0-so-a-second-cat-would-read-quothellonquot-again-the-buffer-persists-until-overwritten-or-the-module-is-unloaded-this-is-the-intended-behavior-for-a-simple-device"},{"level":2,"text":"Three-Level View: What Happens During echo &quot;hello&quot; &gt; /dev/mydevice","id":"three-level-view-what-happens-during-echo-quothelloquot-gt-devmydevice"},{"level":2,"text":"Level 1 â€” Shell/Userspace:\nThe shell forks, execs echo, which writes &quot;hello\\n&quot; (6 bytes) to stdout. The shell has already redirected stdout to /dev/mydevice via open(&quot;/dev/mydevice&quot;, O_WRONLY). The write(fd, &quot;hello\\n&quot;, 6) syscall fires.\nLevel 2 â€” Kernel/VFS:\nsys_write â†’ ksys_write â†’ vfs_write. VFS looks up the struct file for fd, retrieves f-&gt;f_op-&gt;write, which is your mydev_write. Your handler runs in the context of the echo process. copy_from_user copies the 6 bytes from the echo process&#39;s stack (where &quot;hello\\n&quot; lives) into kernel_buffer. The exception table ensures that if echo&#39;s mapping disappears mid-copy, the kernel recovers with -EFAULT.\nLevel 3 â€” Hardware:\nThe copy involves two TLB lookups: one for the userspace source address (in echo&#39;s page tables) and one for the kernel destination address (in the direct-mapped region). The CPU&#39;s hardware page walker traverses the page table hierarchy for the user address. The 6 bytes fit in a single 64-byte cache line. The copy itself is handled by optimized CPU instructions in the copy_from_user implementation â€” on x86_64, this uses rep movsb or SIMD instructions depending on size. The kernel buffer&#39;s cache line is brought into L1/L2 cache dirty; it will be evicted to DRAM eventually but for read-back soon after, it&#39;s likely still hot.","id":"level-1-shelluserspace-the-shell-forks-execs-echo-which-writes-quothellonquot-6-bytes-to-stdout-the-shell-has-already-redirected-stdout-to-devmydevice-via-openquotdevmydevicequot-o_wronly-the-writefd-quothellonquot-6-syscall-fires-level-2-kernelvfs-sys_write-ksys_write-vfs_write-vfs-looks-up-the-struct-file-for-fd-retrieves-f-gtf_op-gtwrite-which-is-your-mydev_write-your-handler-runs-in-the-context-of-the-echo-process-copy_from_user-copies-the-6-bytes-from-the-echo-process39s-stack-where-quothellonquot-lives-into-kernel_buffer-the-exception-table-ensures-that-if-echo39s-mapping-disappears-mid-copy-the-kernel-recovers-with-efault-level-3-hardware-the-copy-involves-two-tlb-lookups-one-for-the-userspace-source-address-in-echo39s-page-tables-and-one-for-the-kernel-destination-address-in-the-direct-mapped-region-the-cpu39s-hardware-page-walker-traverses-the-page-table-hierarchy-for-the-user-address-the-6-bytes-fit-in-a-single-64-byte-cache-line-the-copy-itself-is-handled-by-optimized-cpu-instructions-in-the-copy_from_user-implementation-on-x86_64-this-uses-rep-movsb-or-simd-instructions-depending-on-size-the-kernel-buffer39s-cache-line-is-brought-into-l1l2-cache-dirty-it-will-be-evicted-to-dram-eventually-but-for-read-back-soon-after-it39s-likely-still-hot"},{"level":2,"text":"Common Pitfalls and Their Consequences","id":"common-pitfalls-and-their-consequences"},{"level":3,"text":"Direct Dereference of User Pointer","id":"direct-dereference-of-user-pointer"},{"level":3,"text":"Returning Bytes Written Without Checking copy_from_user Return","id":"returning-bytes-written-without-checking-copy_from_user-return"},{"level":3,"text":"Not Returning 0 at EOF â€” Infinite read Loop","id":"not-returning-0-at-eof-infinite-read-loop"},{"level":3,"text":"Not Updating *f_pos After Read","id":"not-updating-f_pos-after-read"},{"level":3,"text":"Forgetting Cleanup in Reverse Order","id":"forgetting-cleanup-in-reverse-order"},{"level":3,"text":"Missing .owner = THIS_MODULE in file_operations","id":"missing-owner-this_module-in-file_operations"},{"level":2,"text":"Without .owner, rmmod succeeds while a process has the device open. The next read() jumps to a now-freed code address â€” instant kernel panic.","id":"without-owner-rmmod-succeeds-while-a-process-has-the-device-open-the-next-read-jumps-to-a-now-freed-code-address-instant-kernel-panic"},{"level":2,"text":"Knowledge Cascade: What You&#39;ve Just Unlocked","id":"knowledge-cascade-what-you39ve-just-unlocked"},{"level":2,"text":"â†’ VFS Dispatch Pattern = Interfaces Everywhere (cross-domain):\nThe file_operations vtable you just filled in is the kernel&#39;s implementation of dynamic dispatch â€” the same pattern as C++ virtual methods, Go interfaces, and Rust trait objects. The call f-&gt;f_op-&gt;read(filp, buf, count, f_pos) is structurally identical to a C++ virtual void read() call that dispatches through a vtable pointer. When you next see a Go interface dispatch, a Rust dyn Trait, or a Java abstract class, you&#39;re looking at the same solution to the same problem: dispatch to the right implementation at runtime without knowing the concrete type at compile time. The kernel&#39;s vtable approach is the primordial form.\nâ†’ f_pos and pread/pwrite Atomicity (same domain, forward):\nThe fact that f_pos is per-struct file (not per-inode) is why pread(fd, buf, n, offset) and pwrite exist. pread passes a separate offset without modifying filp-&gt;f_pos, allowing concurrent reads from different offsets without races â€” databases use pread exclusively for this reason. SQLite, PostgreSQL, RocksDB all call pread into their data files. The character device mechanism you just built is the same mechanism enabling atomic positioned I/O at scale.\nâ†’ udev Hotplug = Universal Device Discovery (cross-domain):\ndevice_create() sending a uevent is the same mechanism that fires when you plug in a USB drive and /dev/sdb appears, or when the kernel probes a PCIe device at boot and /dev/nvme0n1 materializes. Android&#39;s vold (volume daemon), systemd-udevd, and the kernel&#39;s own kobject_uevent are all operating the same infrastructure. You&#39;ve just written code that participates in Linux&#39;s universal device discovery protocol.\nâ†’ Exception Table = Speculative Execution Safety Net (same domain):\nThe .ex_table mechanism behind copy_from_user is conceptually related to how CPUs handle speculative execution faults: execute optimistically, recover if something goes wrong. The x86 #GP and #PF exception handlers consult the exception table the same way a CPU&#39;s microcode consults its own internal fault tables. More practically: this same mechanism powers get_user(), put_user(), and the __copy_* family â€” understanding it means you understand the safety foundation of the entire kernel-userspace boundary.\nâ†’ kmalloc to Slab Allocator to Memory Pressure (forward):\nThe kzalloc(4096, GFP_KERNEL) call you made is trivial here, but it connects to one of the most important kernel subsystems: the memory reclaim path. Under memory pressure, GFP_KERNEL allocations can block while kswapd runs, pages are writeback to swap, slab caches are shrunk, and the OOM killer considers victims. In Milestone 3, when you add an ioctl for runtime buffer resize, you&#39;ll call kfree and kmalloc while the device is live â€” a perfect opportunity to think about what happens if the resize allocation fails at a moment when memory is under pressure.\nâ†’ This Is /dev/null (structural equivalence):\n/dev/null&#39;s write handler is return count â€” accept all bytes, store nothing. Its read handler is return 0 â€” always EOF. Your device is more capable. /dev/zero&#39;s read handler fills the user buffer with zeros via clear_user() (a copy_to_user variant for zero-fill). /dev/random and /dev/urandom read from an entropy pool. The architecture is identical to what you just built â€” the only difference is what the read and write handlers actually do with the data.","id":"-vfs-dispatch-pattern-interfaces-everywhere-cross-domain-the-file_operations-vtable-you-just-filled-in-is-the-kernel39s-implementation-of-dynamic-dispatch-the-same-pattern-as-c-virtual-methods-go-interfaces-and-rust-trait-objects-the-call-f-gtf_op-gtreadfilp-buf-count-f_pos-is-structurally-identical-to-a-c-virtual-void-read-call-that-dispatches-through-a-vtable-pointer-when-you-next-see-a-go-interface-dispatch-a-rust-dyn-trait-or-a-java-abstract-class-you39re-looking-at-the-same-solution-to-the-same-problem-dispatch-to-the-right-implementation-at-runtime-without-knowing-the-concrete-type-at-compile-time-the-kernel39s-vtable-approach-is-the-primordial-form-f_pos-and-preadpwrite-atomicity-same-domain-forward-the-fact-that-f_pos-is-per-struct-file-not-per-inode-is-why-preadfd-buf-n-offset-and-pwrite-exist-pread-passes-a-separate-offset-without-modifying-filp-gtf_pos-allowing-concurrent-reads-from-different-offsets-without-races-databases-use-pread-exclusively-for-this-reason-sqlite-postgresql-rocksdb-all-call-pread-into-their-data-files-the-character-device-mechanism-you-just-built-is-the-same-mechanism-enabling-atomic-positioned-io-at-scale-udev-hotplug-universal-device-discovery-cross-domain-device_create-sending-a-uevent-is-the-same-mechanism-that-fires-when-you-plug-in-a-usb-drive-and-devsdb-appears-or-when-the-kernel-probes-a-pcie-device-at-boot-and-devnvme0n1-materializes-android39s-vold-volume-daemon-systemd-udevd-and-the-kernel39s-own-kobject_uevent-are-all-operating-the-same-infrastructure-you39ve-just-written-code-that-participates-in-linux39s-universal-device-discovery-protocol-exception-table-speculative-execution-safety-net-same-domain-the-ex_table-mechanism-behind-copy_from_user-is-conceptually-related-to-how-cpus-handle-speculative-execution-faults-execute-optimistically-recover-if-something-goes-wrong-the-x86-gp-and-pf-exception-handlers-consult-the-exception-table-the-same-way-a-cpu39s-microcode-consults-its-own-internal-fault-tables-more-practically-this-same-mechanism-powers-get_user-put_user-and-the-__copy_-family-understanding-it-means-you-understand-the-safety-foundation-of-the-entire-kernel-userspace-boundary-kmalloc-to-slab-allocator-to-memory-pressure-forward-the-kzalloc4096-gfp_kernel-call-you-made-is-trivial-here-but-it-connects-to-one-of-the-most-important-kernel-subsystems-the-memory-reclaim-path-under-memory-pressure-gfp_kernel-allocations-can-block-while-kswapd-runs-pages-are-writeback-to-swap-slab-caches-are-shrunk-and-the-oom-killer-considers-victims-in-milestone-3-when-you-add-an-ioctl-for-runtime-buffer-resize-you39ll-call-kfree-and-kmalloc-while-the-device-is-live-a-perfect-opportunity-to-think-about-what-happens-if-the-resize-allocation-fails-at-a-moment-when-memory-is-under-pressure-this-is-devnull-structural-equivalence-devnull39s-write-handler-is-return-count-accept-all-bytes-store-nothing-its-read-handler-is-return-0-always-eof-your-device-is-more-capable-devzero39s-read-handler-fills-the-user-buffer-with-zeros-via-clear_user-a-copy_to_user-variant-for-zero-fill-devrandom-and-devurandom-read-from-an-entropy-pool-the-architecture-is-identical-to-what-you-just-built-the-only-difference-is-what-the-read-and-write-handlers-actually-do-with-the-data"},{"level":2,"text":"Acceptance Criteria Checkpoint","id":"acceptance-criteria-checkpoint"},{"level":1,"text":"Milestone 3: ioctl and /proc Interface","id":"milestone-3-ioctl-and-proc-interface"},{"level":2,"text":"The Revelation: ioctl Is a Binary Protocol, Not a Switch Statement","id":"the-revelation-ioctl-is-a-binary-protocol-not-a-switch-statement"},{"level":2,"text":"The Architecture: Control Plane Meets Data Plane","id":"the-architecture-control-plane-meets-data-plane"},{"level":2,"text":"The Shared Header: One Definition, Two Worlds","id":"the-shared-header-one-definition-two-worlds"},{"level":2,"text":"Study this header carefully. Every design choice is deliberate:\n__u32 instead of uint32_t or unsigned int: On different architectures and compilation environments, unsigned int might be 16 or 32 bits. __u32 is guaranteed 32-bit everywhere in Linux kernel headers. In userspace, we typedef it to uint32_t from &lt;stdint.h&gt; which has the same guarantee. The header conditionally provides whichever definition is appropriate.\n__KERNEL__ guard: The Kbuild system defines __KERNEL__ when compiling kernel code. Userspace compilers don&#39;t define it. This lets you use one file in both contexts: the kernel side gets &lt;linux/ioctl.h&gt; (kernel macros), the userspace side gets &lt;sys/ioctl.h&gt; (POSIX definitions). The underlying math is the same â€” the macros produce identical bit patterns.\n_reserved in mydev_status: ABI stability practice. If you later add a field, you can replace _reserved instead of growing the struct (which would break the size encoding in _IOR). Explicit padding documents that you thought about future extensibility.\nThe ABI contract: Once mydev_status is released and userspace programs link against it, the layout of this struct is frozen. The kernel&#39;s guarantee of stable userspace ABI means that a userspace binary compiled against this header in 2026 must still work with a kernel driver in 2036 â€” even if the driver&#39;s internal representation changes. This is why the kernel&#39;s internal structs change freely (they&#39;re not ABI) but the ioctl structs in public headers do not. This is the same concern that makes Protocol Buffer field numbers immutable and that governs JSON API versioning.","id":"study-this-header-carefully-every-design-choice-is-deliberate-__u32-instead-of-uint32_t-or-unsigned-int-on-different-architectures-and-compilation-environments-unsigned-int-might-be-16-or-32-bits-__u32-is-guaranteed-32-bit-everywhere-in-linux-kernel-headers-in-userspace-we-typedef-it-to-uint32_t-from-ltstdinthgt-which-has-the-same-guarantee-the-header-conditionally-provides-whichever-definition-is-appropriate-__kernel__-guard-the-kbuild-system-defines-__kernel__-when-compiling-kernel-code-userspace-compilers-don39t-define-it-this-lets-you-use-one-file-in-both-contexts-the-kernel-side-gets-ltlinuxioctlhgt-kernel-macros-the-userspace-side-gets-ltsysioctlhgt-posix-definitions-the-underlying-math-is-the-same-the-macros-produce-identical-bit-patterns-_reserved-in-mydev_status-abi-stability-practice-if-you-later-add-a-field-you-can-replace-_reserved-instead-of-growing-the-struct-which-would-break-the-size-encoding-in-_ior-explicit-padding-documents-that-you-thought-about-future-extensibility-the-abi-contract-once-mydev_status-is-released-and-userspace-programs-link-against-it-the-layout-of-this-struct-is-frozen-the-kernel39s-guarantee-of-stable-userspace-abi-means-that-a-userspace-binary-compiled-against-this-header-in-2026-must-still-work-with-a-kernel-driver-in-2036-even-if-the-driver39s-internal-representation-changes-this-is-why-the-kernel39s-internal-structs-change-freely-they39re-not-abi-but-the-ioctl-structs-in-public-headers-do-not-this-is-the-same-concern-that-makes-protocol-buffer-field-numbers-immutable-and-that-governs-json-api-versioning"},{"level":2,"text":"Implementing unlocked_ioctl","id":"implementing-unlocked_ioctl"},{"level":3,"text":"Why unlocked_ioctl, not ioctl?","id":"why-unlocked_ioctl-not-ioctl"},{"level":3,"text":"The -ENOTTY Contract","id":"the-enotty-contract"},{"level":2,"text":"The choice of -ENOTTY for unknown commands is not arbitrary â€” it&#39;s the POSIX-mandated error for &quot;this ioctl is not applicable to this file descriptor.&quot; The name comes from &quot;not a TTY&quot; â€” the first ioctl commands were TTY-specific, so the error for &quot;wrong device type&quot; was named for the original use case. Today it means &quot;this device doesn&#39;t support that command.&quot; Using -EINVAL instead (as many drivers do incorrectly) is technically wrong per POSIX and confuses tools that inspect ioctl return codes.","id":"the-choice-of-enotty-for-unknown-commands-is-not-arbitrary-it39s-the-posix-mandated-error-for-quotthis-ioctl-is-not-applicable-to-this-file-descriptorquot-the-name-comes-from-quotnot-a-ttyquot-the-first-ioctl-commands-were-tty-specific-so-the-error-for-quotwrong-device-typequot-was-named-for-the-original-use-case-today-it-means-quotthis-device-doesn39t-support-that-commandquot-using-einval-instead-as-many-drivers-do-incorrectly-is-technically-wrong-per-posix-and-confuses-tools-that-inspect-ioctl-return-codes"},{"level":2,"text":"Validating Direction and Size Before Your Handler Runs","id":"validating-direction-and-size-before-your-handler-runs"},{"level":2,"text":"The /proc Entry: Runtime Introspection","id":"the-proc-entry-runtime-introspection"},{"level":3,"text":"The Problem with Raw proc Callbacks","id":"the-problem-with-raw-proc-callbacks"},{"level":3,"text":"What it IS","id":"what-it-is"},{"level":3,"text":"WHY the reader needs it right now","id":"why-the-reader-needs-it-right-now"},{"level":3,"text":"ONE key insight or mental model","id":"one-key-insight-or-mental-model"},{"level":3,"text":"Implementation","id":"implementation"},{"level":2,"text":"How seq_file Actually Works Under the Hood","id":"how-seq_file-actually-works-under-the-hood"},{"level":2,"text":"For single_open, the iterator is trivially simple: start returns a non-NULL dummy pointer once, next returns NULL immediately, stop does nothing. The show function (yours: mydev_proc_show) is called exactly once and writes all content. seq_read handles paging the output into userspace even if your output exceeds the kernel&#39;s internal buffer â€” it calls start/show/next/stop again from where it left off.\nThis is why seq_printf is safe to call with arbitrarily large output: the seq_file infrastructure handles the case where your content doesn&#39;t fit in one read() call by maintaining position state internally. A hand-rolled proc callback that writes to a fixed page buffer and returns would truncate silently.","id":"for-single_open-the-iterator-is-trivially-simple-start-returns-a-non-null-dummy-pointer-once-next-returns-null-immediately-stop-does-nothing-the-show-function-yours-mydev_proc_show-is-called-exactly-once-and-writes-all-content-seq_read-handles-paging-the-output-into-userspace-even-if-your-output-exceeds-the-kernel39s-internal-buffer-it-calls-startshownextstop-again-from-where-it-left-off-this-is-why-seq_printf-is-safe-to-call-with-arbitrarily-large-output-the-seq_file-infrastructure-handles-the-case-where-your-content-doesn39t-fit-in-one-read-call-by-maintaining-position-state-internally-a-hand-rolled-proc-callback-that-writes-to-a-fixed-page-buffer-and-returns-would-truncate-silently"},{"level":2,"text":"The Complete Updated Module","id":"the-complete-updated-module"},{"level":2,"text":"The Userspace Test Program","id":"the-userspace-test-program"},{"level":2,"text":"Three-Level View: What Happens During ioctl(fd, MYDEV_STATUS, &amp;status)","id":"three-level-view-what-happens-during-ioctlfd-mydev_status-ampstatus"},{"level":2,"text":"Level 1 â€” Userspace:\nYour test program calls ioctl(fd, MYDEV_STATUS, &amp;status). The C library wraps this as the ioctl(2) syscall. The cmd argument is the 32-bit encoded value produced by _IOR(&#39;M&#39;, 2, struct mydev_status) â€” approximately 0x80184d02 (direction=read=2, size=24 bytes, type=&#39;M&#39;, nr=2). The arg is the stack address of status.\nLevel 2 â€” Kernel/VFS:\nsys_ioctl â†’ do_vfs_ioctl â†’ checks if cmd is a known VFS-level command (like FIONREAD or FIOCLEX) â€” it&#39;s not â€” â†’ calls vfs_ioctl â†’ filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg) â†’ your mydev_ioctl. Your handler reads open_count, read_count, write_count from atomic_t variables, fills struct mydev_status on the kernel stack, and calls copy_to_user. The copy places the struct into the userspace stack frame.\nLevel 3 â€” Hardware:\nThe copy_to_user for a 24-byte struct is a fast path. On x86_64, the struct fits in three cache lines (24 bytes &lt; 64 bytes = one cache line, in fact). The CPU executes the copy with a few mov instructions and potential rep movsb for safety. The userspace page is likely hot in L1/L2 cache since the test program just passed its address. The atomic_read calls generate mov instructions with appropriate memory barriers â€” atomic_read on x86 is just a regular load (x86&#39;s memory model provides the necessary ordering guarantees without explicit barrier instructions in most cases). The total cost: maybe 200ns, dominated by the syscall overhead (~100ns) and cache accesses, not the copy itself.","id":"level-1-userspace-your-test-program-calls-ioctlfd-mydev_status-ampstatus-the-c-library-wraps-this-as-the-ioctl2-syscall-the-cmd-argument-is-the-32-bit-encoded-value-produced-by-_ior39m39-2-struct-mydev_status-approximately-0x80184d02-directionread2-size24-bytes-type39m39-nr2-the-arg-is-the-stack-address-of-status-level-2-kernelvfs-sys_ioctl-do_vfs_ioctl-checks-if-cmd-is-a-known-vfs-level-command-like-fionread-or-fioclex-it39s-not-calls-vfs_ioctl-filp-gtf_op-gtunlocked_ioctlfilp-cmd-arg-your-mydev_ioctl-your-handler-reads-open_count-read_count-write_count-from-atomic_t-variables-fills-struct-mydev_status-on-the-kernel-stack-and-calls-copy_to_user-the-copy-places-the-struct-into-the-userspace-stack-frame-level-3-hardware-the-copy_to_user-for-a-24-byte-struct-is-a-fast-path-on-x86_64-the-struct-fits-in-three-cache-lines-24-bytes-lt-64-bytes-one-cache-line-in-fact-the-cpu-executes-the-copy-with-a-few-mov-instructions-and-potential-rep-movsb-for-safety-the-userspace-page-is-likely-hot-in-l1l2-cache-since-the-test-program-just-passed-its-address-the-atomic_read-calls-generate-mov-instructions-with-appropriate-memory-barriers-atomic_read-on-x86-is-just-a-regular-load-x8639s-memory-model-provides-the-necessary-ordering-guarantees-without-explicit-barrier-instructions-in-most-cases-the-total-cost-maybe-200ns-dominated-by-the-syscall-overhead-100ns-and-cache-accesses-not-the-copy-itself"},{"level":2,"text":"Hardware Soul: The ioctl Path&#39;s Cache Footprint","id":"hardware-soul-the-ioctl-path39s-cache-footprint"},{"level":2,"text":"24 bytes. One cache line (64 bytes) is more than enough. The copy_to_user for 24 bytes doesn&#39;t even need loop unrolling â€” the compiler generates a small sequence of register stores. The bottleneck in this ioctl is not the copy; it&#39;s the atomic reads and the syscall overhead.","id":"24-bytes-one-cache-line-64-bytes-is-more-than-enough-the-copy_to_user-for-24-bytes-doesn39t-even-need-loop-unrolling-the-compiler-generates-a-small-sequence-of-register-stores-the-bottleneck-in-this-ioctl-is-not-the-copy-it39s-the-atomic-reads-and-the-syscall-overhead"},{"level":2,"text":"Pitfalls: What Goes Wrong and Why","id":"pitfalls-what-goes-wrong-and-why"},{"level":3,"text":"Using Wrong Magic Number â€” Silent Mismatch","id":"using-wrong-magic-number-silent-mismatch"},{"level":3,"text":"Returning Wrong Error for Unknown Command","id":"returning-wrong-error-for-unknown-command"},{"level":3,"text":"RESIZE Without Protecting Existing Data","id":"resize-without-protecting-existing-data"},{"level":3,"text":"Not Handling Truncation on RESIZE-Down","id":"not-handling-truncation-on-resize-down"},{"level":3,"text":"proc_create Error Check with IS_ERR","id":"proc_create-error-check-with-is_err"},{"level":3,"text":"Modifying buffer_size_bytes Without Updating /proc Show","id":"modifying-buffer_size_bytes-without-updating-proc-show"},{"level":2,"text":"If your proc show function reads buffer_size_bytes and your ioctl RESIZE modifies it, you need no extra work â€” both see the same global variable. But if you cache values (e.g., save buffer_size_bytes to a local at init time), your proc entry will show stale data after a resize. Always read live state in proc show handlers.","id":"if-your-proc-show-function-reads-buffer_size_bytes-and-your-ioctl-resize-modifies-it-you-need-no-extra-work-both-see-the-same-global-variable-but-if-you-cache-values-eg-save-buffer_size_bytes-to-a-local-at-init-time-your-proc-entry-will-show-stale-data-after-a-resize-always-read-live-state-in-proc-show-handlers"},{"level":2,"text":"Knowledge Cascade: What You&#39;ve Just Unlocked","id":"knowledge-cascade-what-you39ve-just-unlocked"},{"level":2,"text":"â†’ ioctl = Control Plane / data-plane separation (cross-domain: network protocol design)\nThe read/write vs. ioctl split you just implemented is the same architectural pattern as TCP&#39;s data stream vs. socket options (setsockopt/getsockopt). HTTP separates body (data plane) from headers (control plane). QUIC separates stream data from connection-level signals. gRPC offers streaming RPCs (high-throughput data) alongside unary calls (control). The insight â€” &quot;don&#39;t mix control and data in the same channel&quot; â€” appears everywhere because mixing them forces both sides to parse combined traffic, adding latency and complexity. When you next design a protocol or API and find yourself tempted to embed commands in the data stream, remember: TCP, HTTP, and your kernel driver all chose not to.\nâ†’ seq_file&#39;s iterator = Language-level iterators (cross-domain: language design)\nThe start/next/stop/show interface seq_file gives you is structurally identical to Python&#39;s __iter__/__next__ generator protocol, Rust&#39;s Iterator trait with its next() -&gt; Option&lt;Item&gt; method, and database cursor iteration. The fundamental problem is the same: &quot;produce a potentially large sequence lazily, without materializing it all at once.&quot; Python generators solve it with yield. Rust iterators solve it with next(). seq_file solves it with start/next/stop. When you write a Python generator that yields database rows, you&#39;re implementing the same pattern as the seq_file infrastructure you just wired up.\nâ†’ /proc virtual filesystem = Everything-is-a-file philosophy (cross-domain: OS design)\n/proc/mydevice has no backing file on disk. Its &quot;content&quot; is generated by your mydev_proc_show function every time someone reads it. This is the same trick as /proc/cpuinfo (calls into the CPU topology code), /proc/meminfo (queries the page allocator), and /proc/&lt;pid&gt;/status (reads the task struct for that process). Plan 9 OS â€” Linux&#39;s philosophical ancestor in many ways â€” took this idea to its logical extreme: everything is a file, including network connections (open /net/tcp/0/data to make a TCP connection). FUSE (Filesystem in Userspace) implements the same idea in userspace: your code generates &quot;file content&quot; on-read. Understanding /proc means you understand FUSE, Plan 9, /sys, and the entire &quot;virtual filesystem as control interface&quot; philosophy.\nâ†’ Shared header ABI = Wire format stability (cross-domain: distributed systems)\nThe mydevice_ioctl.h you just created is an ABI contract. struct mydev_status&#39;s layout â€” field order, sizes, offsets â€” is now frozen. Any userspace binary compiled against this header must keep working against future kernel drivers. This is identical to Protocol Buffers: field numbers are immutable once assigned, because removing or reusing them breaks binary compatibility with old serialized data. It&#39;s the same as JSON API versioning (don&#39;t remove fields, only add). The Linux kernel&#39;s guarantee of stable userspace ABI is explicitly documented in Documentation/process/stable-api-nonsense.rst â€” the internal kernel API changes freely, but the userspace ABI (what you exposed in your header) is guaranteed stable. When you design any serialized format or shared interface, you&#39;re facing the same problem your ioctl header just solved: separate the mutable internals from the immutable external contract.\nâ†’ Atomic counters â†’ per-CPU counters â†’ scalability (forward)\nYour atomic_t read_count increments on every read. With a single CPU, this is fine. With 16 CPUs all reading simultaneously, each atomic_inc causes the cache line holding read_count to bounce between CPU caches â€” a cache coherency round-trip that takes ~100 CPU cycles per operation. At 16 concurrent readers, your counter becomes a bottleneck. The kernel&#39;s solution: percpu_counter â€” each CPU maintains its own counter in CPU-local memory (no cache bouncing), and reads aggregate all CPU-local values. This is the same idea as Go&#39;s sync.Pool (per-goroutine allocation to avoid contention), or partitioned lock tables (one lock per shard, not one global lock). The pattern: &quot;replace one shared resource with N per-CPU/per-thread resources, aggregate on read.&quot; You&#39;ll see it everywhere high-performance code needs shared counters.","id":"-ioctl-control-plane-data-plane-separation-cross-domain-network-protocol-design-the-readwrite-vs-ioctl-split-you-just-implemented-is-the-same-architectural-pattern-as-tcp39s-data-stream-vs-socket-options-setsockoptgetsockopt-http-separates-body-data-plane-from-headers-control-plane-quic-separates-stream-data-from-connection-level-signals-grpc-offers-streaming-rpcs-high-throughput-data-alongside-unary-calls-control-the-insight-quotdon39t-mix-control-and-data-in-the-same-channelquot-appears-everywhere-because-mixing-them-forces-both-sides-to-parse-combined-traffic-adding-latency-and-complexity-when-you-next-design-a-protocol-or-api-and-find-yourself-tempted-to-embed-commands-in-the-data-stream-remember-tcp-http-and-your-kernel-driver-all-chose-not-to-seq_file39s-iterator-language-level-iterators-cross-domain-language-design-the-startnextstopshow-interface-seq_file-gives-you-is-structurally-identical-to-python39s-__iter____next__-generator-protocol-rust39s-iterator-trait-with-its-next-gt-optionltitemgt-method-and-database-cursor-iteration-the-fundamental-problem-is-the-same-quotproduce-a-potentially-large-sequence-lazily-without-materializing-it-all-at-oncequot-python-generators-solve-it-with-yield-rust-iterators-solve-it-with-next-seq_file-solves-it-with-startnextstop-when-you-write-a-python-generator-that-yields-database-rows-you39re-implementing-the-same-pattern-as-the-seq_file-infrastructure-you-just-wired-up-proc-virtual-filesystem-everything-is-a-file-philosophy-cross-domain-os-design-procmydevice-has-no-backing-file-on-disk-its-quotcontentquot-is-generated-by-your-mydev_proc_show-function-every-time-someone-reads-it-this-is-the-same-trick-as-proccpuinfo-calls-into-the-cpu-topology-code-procmeminfo-queries-the-page-allocator-and-procltpidgtstatus-reads-the-task-struct-for-that-process-plan-9-os-linux39s-philosophical-ancestor-in-many-ways-took-this-idea-to-its-logical-extreme-everything-is-a-file-including-network-connections-open-nettcp0data-to-make-a-tcp-connection-fuse-filesystem-in-userspace-implements-the-same-idea-in-userspace-your-code-generates-quotfile-contentquot-on-read-understanding-proc-means-you-understand-fuse-plan-9-sys-and-the-entire-quotvirtual-filesystem-as-control-interfacequot-philosophy-shared-header-abi-wire-format-stability-cross-domain-distributed-systems-the-mydevice_ioctlh-you-just-created-is-an-abi-contract-struct-mydev_status39s-layout-field-order-sizes-offsets-is-now-frozen-any-userspace-binary-compiled-against-this-header-must-keep-working-against-future-kernel-drivers-this-is-identical-to-protocol-buffers-field-numbers-are-immutable-once-assigned-because-removing-or-reusing-them-breaks-binary-compatibility-with-old-serialized-data-it39s-the-same-as-json-api-versioning-don39t-remove-fields-only-add-the-linux-kernel39s-guarantee-of-stable-userspace-abi-is-explicitly-documented-in-documentationprocessstable-api-nonsenserst-the-internal-kernel-api-changes-freely-but-the-userspace-abi-what-you-exposed-in-your-header-is-guaranteed-stable-when-you-design-any-serialized-format-or-shared-interface-you39re-facing-the-same-problem-your-ioctl-header-just-solved-separate-the-mutable-internals-from-the-immutable-external-contract-atomic-counters-per-cpu-counters-scalability-forward-your-atomic_t-read_count-increments-on-every-read-with-a-single-cpu-this-is-fine-with-16-cpus-all-reading-simultaneously-each-atomic_inc-causes-the-cache-line-holding-read_count-to-bounce-between-cpu-caches-a-cache-coherency-round-trip-that-takes-100-cpu-cycles-per-operation-at-16-concurrent-readers-your-counter-becomes-a-bottleneck-the-kernel39s-solution-percpu_counter-each-cpu-maintains-its-own-counter-in-cpu-local-memory-no-cache-bouncing-and-reads-aggregate-all-cpu-local-values-this-is-the-same-idea-as-go39s-syncpool-per-goroutine-allocation-to-avoid-contention-or-partitioned-lock-tables-one-lock-per-shard-not-one-global-lock-the-pattern-quotreplace-one-shared-resource-with-n-per-cpuper-thread-resources-aggregate-on-readquot-you39ll-see-it-everywhere-high-performance-code-needs-shared-counters"},{"level":2,"text":"Acceptance Criteria Checkpoint","id":"acceptance-criteria-checkpoint"},{"level":1,"text":"Milestone 4: Concurrent Access, Blocking I/O, and Poll Support","id":"milestone-4-concurrent-access-blocking-io-and-poll-support"},{"level":2,"text":"The Revelation: The Kernel Is Not a Thread â€” It&#39;s a State Machine","id":"the-revelation-the-kernel-is-not-a-thread-it39s-a-state-machine"},{"level":2,"text":"The Foundation: What You&#39;re Actually Building","id":"the-foundation-what-you39re-actually-building"},{"level":2,"text":"Kernel Mutexes: The Right Lock for Process Context","id":"kernel-mutexes-the-right-lock-for-process-context"},{"level":3,"text":"What a Mutex Actually Is","id":"what-a-mutex-actually-is"},{"level":2,"text":"Wait Queues: The Sleeping Heart of Blocking I/O","id":"wait-queues-the-sleeping-heart-of-blocking-io"},{"level":3,"text":"The Data Structure","id":"the-data-structure"},{"level":3,"text":"wait_event_interruptible: The Full Mechanism","id":"wait_event_interruptible-the-full-mechanism"},{"level":3,"text":"The Condition and the Mutex: A Critical Pattern","id":"the-condition-and-the-mutex-a-critical-pattern"},{"level":2,"text":"-ERESTARTSYS: The Signal That Travels Through Time","id":"-erestartsys-the-signal-that-travels-through-time"},{"level":2,"text":"O_NONBLOCK: Two Universes of I/O Behavior","id":"o_nonblock-two-universes-of-io-behavior"},{"level":2,"text":"The .poll File Operation: Not What You Think","id":"the-poll-file-operation-not-what-you-think"},{"level":3,"text":"The Architectural Insight","id":"the-architectural-insight"},{"level":3,"text":"poll_wait(): The Registration Function","id":"poll_wait-the-registration-function"},{"level":3,"text":"The Mask Bits: A Quick Reference","id":"the-mask-bits-a-quick-reference"},{"level":2,"text":"The Complete Implementation","id":"the-complete-implementation"},{"level":3,"text":"Updated Device State","id":"updated-device-state"},{"level":3,"text":"Open and Release","id":"open-and-release"},{"level":3,"text":"The Write Handler: Producer with Wake-up","id":"the-write-handler-producer-with-wake-up"},{"level":3,"text":"The Read Handler: Consumer with Blocking","id":"the-read-handler-consumer-with-blocking"},{"level":3,"text":"The Poll Handler","id":"the-poll-handler"},{"level":3,"text":"Updated file_operations Table","id":"updated-file_operations-table"},{"level":3,"text":"Init and Exit (Updated)","id":"init-and-exit-updated"},{"level":2,"text":"The init/exit structure from Milestone 3 doesn&#39;t change â€” the mutex and wait queues are statically initialized and don&#39;t need explicit init/cleanup. DEFINE_MUTEX and DECLARE_WAIT_QUEUE_HEAD do all the initialization at compile time.","id":"the-initexit-structure-from-milestone-3-doesn39t-change-the-mutex-and-wait-queues-are-statically-initialized-and-don39t-need-explicit-initcleanup-define_mutex-and-declare_wait_queue_head-do-all-the-initialization-at-compile-time"},{"level":2,"text":"Process States and the Scheduler: The Big Picture","id":"process-states-and-the-scheduler-the-big-picture"},{"level":2,"text":"The Thundering Herd Problem","id":"the-thundering-herd-problem"},{"level":2,"text":"Imagine 100 reader processes are sleeping on read_queue, all waiting for data. One writer calls write() and adds 100 bytes. The writer calls wake_up_interruptible(&amp;read_queue).\nwake_up_interruptible wakes all sleeping processes on the queue. All 100 readers transition to TASK_RUNNING and compete to acquire dev_mutex. The one that wins reads all 100 bytes and releases the mutex. The other 99 acquire the mutex in turn, find buffer_used == 0, and go back to sleep.\nThis is the thundering herd problem: a single wakeup event causes O(N) processes to wake, contend, and re-sleep. For N=100 with a fast mutex, this is 99 unnecessary context switches and 99 unnecessary mutex acquisitions.\nThe kernel provides wake_up_interruptible_nr(queue, nr) to wake at most nr waiters, and WQ_FLAG_EXCLUSIVE to designate certain waiters as &quot;exclusive&quot; â€” wake_up_interruptible wakes exclusive waiters one at a time. For your single-buffer device, this optimization isn&#39;t necessary â€” the buffer either has data for all readers (stream device) or for one reader (pipe-like device). But knowing this exists tells you why nginx&#39;s accept_mutex exists (to prevent all workers from thundering on a new connection) and why epoll with EPOLLET | EPOLLONESHOT is useful for high-connection servers.\nFor your driver: since the buffer can hold multiple bytes and multiple readers can each read different portions, wake_up_interruptible waking all readers is actually correct behavior â€” each reader that wakes finds some data available. The &quot;unnecessary wakeup&quot; scenario only occurs when readers compete for the same bytes, which doesn&#39;t happen with your f_pos-per-file design.","id":"imagine-100-reader-processes-are-sleeping-on-read_queue-all-waiting-for-data-one-writer-calls-write-and-adds-100-bytes-the-writer-calls-wake_up_interruptibleampread_queue-wake_up_interruptible-wakes-all-sleeping-processes-on-the-queue-all-100-readers-transition-to-task_running-and-compete-to-acquire-dev_mutex-the-one-that-wins-reads-all-100-bytes-and-releases-the-mutex-the-other-99-acquire-the-mutex-in-turn-find-buffer_used-0-and-go-back-to-sleep-this-is-the-thundering-herd-problem-a-single-wakeup-event-causes-on-processes-to-wake-contend-and-re-sleep-for-n100-with-a-fast-mutex-this-is-99-unnecessary-context-switches-and-99-unnecessary-mutex-acquisitions-the-kernel-provides-wake_up_interruptible_nrqueue-nr-to-wake-at-most-nr-waiters-and-wq_flag_exclusive-to-designate-certain-waiters-as-quotexclusivequot-wake_up_interruptible-wakes-exclusive-waiters-one-at-a-time-for-your-single-buffer-device-this-optimization-isn39t-necessary-the-buffer-either-has-data-for-all-readers-stream-device-or-for-one-reader-pipe-like-device-but-knowing-this-exists-tells-you-why-nginx39s-accept_mutex-exists-to-prevent-all-workers-from-thundering-on-a-new-connection-and-why-epoll-with-epollet-epolloneshot-is-useful-for-high-connection-servers-for-your-driver-since-the-buffer-can-hold-multiple-bytes-and-multiple-readers-can-each-read-different-portions-wake_up_interruptible-waking-all-readers-is-actually-correct-behavior-each-reader-that-wakes-finds-some-data-available-the-quotunnecessary-wakeupquot-scenario-only-occurs-when-readers-compete-for-the-same-bytes-which-doesn39t-happen-with-your-f_pos-per-file-design"},{"level":2,"text":"Updating ioctl for Thread Safety","id":"updating-ioctl-for-thread-safety"},{"level":2,"text":"Note the pattern for MYDEV_STATUS: we copy the data under the mutex, then call copy_to_user outside the mutex. Why? Because copy_to_user can sleep (if the user page is not present and needs to be faulted in). Sleeping while holding a mutex is legal in process context, but it holds the mutex longer than necessary, increasing contention. Copy to a local stack struct under the mutex, then copy to userspace without the mutex â€” this is the canonical pattern.","id":"note-the-pattern-for-mydev_status-we-copy-the-data-under-the-mutex-then-call-copy_to_user-outside-the-mutex-why-because-copy_to_user-can-sleep-if-the-user-page-is-not-present-and-needs-to-be-faulted-in-sleeping-while-holding-a-mutex-is-legal-in-process-context-but-it-holds-the-mutex-longer-than-necessary-increasing-contention-copy-to-a-local-stack-struct-under-the-mutex-then-copy-to-userspace-without-the-mutex-this-is-the-canonical-pattern"},{"level":2,"text":"Userspace Poll Test","id":"userspace-poll-test"},{"level":2,"text":"The Stress Test: 4 Writers + 4 Readers","id":"the-stress-test-4-writers-4-readers"},{"level":2,"text":"Three-Level View: Blocking Read in Depth","id":"three-level-view-blocking-read-in-depth"},{"level":2,"text":"When process A calls read() on your empty device and blocks, while process B writes data:\nLevel 1 â€” Applications:\nProcess A calls read(fd, buf, 100) â€” blocks. Process B calls write(fd, data, 50) â€” completes immediately. Process A&#39;s read() returns 50 bytes.\nLevel 2 â€” Kernel / Scheduler:\nProcess A calls sys_read â†’ mydev_read â†’ finds buffer_used == 0 â†’ releases dev_mutex â†’ calls wait_event_interruptible(read_queue, ...) â†’ sets state TASK_INTERRUPTIBLE â†’ calls schedule(). The scheduler removes A from the run queue and runs another task.\nProcess B calls sys_write â†’ mydev_write â†’ acquires dev_mutex â†’ copies 50 bytes â†’ sets buffer_used = 50 â†’ calls wake_up_interruptible(&amp;read_queue). This sets A&#39;s state back to TASK_RUNNING and places A on the run queue. B releases the mutex and returns.\nThe scheduler eventually selects A to run. A resumes inside wait_event_interruptible, re-acquires dev_mutex, re-checks buffer_used &gt; 0 (now true), exits the wait loop, copies 50 bytes to userspace via copy_to_user, returns 50.\nLevel 3 â€” Hardware:\nWhen schedule() is called, the CPU performs a context switch: saves the current register state (instruction pointer, stack pointer, general-purpose registers, FPU state if dirty) to process A&#39;s thread_struct in its task_struct. Loads process B&#39;s saved register state. Switches the page table base register (CR3 on x86_64) to B&#39;s page directory. The TLB is largely flushed (with PCID optimization, partially invalidated). Process B&#39;s code now runs from where it last left off.\nThe wake_up_interruptible() call generates a store-release memory barrier before adding A back to the run queue, ensuring the buffer_used = 50 write is visible to all CPUs before A might observe it. On x86, this is a LOCK prefixed instruction; on ARM64, it&#39;s an explicit stlr (store-release) or dmb (data memory barrier). Without this, A might wake up and read a stale buffer_used value from its cache.","id":"when-process-a-calls-read-on-your-empty-device-and-blocks-while-process-b-writes-data-level-1-applications-process-a-calls-readfd-buf-100-blocks-process-b-calls-writefd-data-50-completes-immediately-process-a39s-read-returns-50-bytes-level-2-kernel-scheduler-process-a-calls-sys_read-mydev_read-finds-buffer_used-0-releases-dev_mutex-calls-wait_event_interruptibleread_queue-sets-state-task_interruptible-calls-schedule-the-scheduler-removes-a-from-the-run-queue-and-runs-another-task-process-b-calls-sys_write-mydev_write-acquires-dev_mutex-copies-50-bytes-sets-buffer_used-50-calls-wake_up_interruptibleampread_queue-this-sets-a39s-state-back-to-task_running-and-places-a-on-the-run-queue-b-releases-the-mutex-and-returns-the-scheduler-eventually-selects-a-to-run-a-resumes-inside-wait_event_interruptible-re-acquires-dev_mutex-re-checks-buffer_used-gt-0-now-true-exits-the-wait-loop-copies-50-bytes-to-userspace-via-copy_to_user-returns-50-level-3-hardware-when-schedule-is-called-the-cpu-performs-a-context-switch-saves-the-current-register-state-instruction-pointer-stack-pointer-general-purpose-registers-fpu-state-if-dirty-to-process-a39s-thread_struct-in-its-task_struct-loads-process-b39s-saved-register-state-switches-the-page-table-base-register-cr3-on-x86_64-to-b39s-page-directory-the-tlb-is-largely-flushed-with-pcid-optimization-partially-invalidated-process-b39s-code-now-runs-from-where-it-last-left-off-the-wake_up_interruptible-call-generates-a-store-release-memory-barrier-before-adding-a-back-to-the-run-queue-ensuring-the-buffer_used-50-write-is-visible-to-all-cpus-before-a-might-observe-it-on-x86-this-is-a-lock-prefixed-instruction-on-arm64-it39s-an-explicit-stlr-store-release-or-dmb-data-memory-barrier-without-this-a-might-wake-up-and-read-a-stale-buffer_used-value-from-its-cache"},{"level":2,"text":"Hardware Soul: The Cache Line Dance","id":"hardware-soul-the-cache-line-dance"},{"level":2,"text":"Common Pitfalls in Concurrent Kernel Code","id":"common-pitfalls-in-concurrent-kernel-code"},{"level":3,"text":"Holding a Mutex While Sleeping in wait_event_interruptible","id":"holding-a-mutex-while-sleeping-in-wait_event_interruptible"},{"level":3,"text":"Not Re-checking the Condition After Waking (Manual Wait Loop)","id":"not-re-checking-the-condition-after-waking-manual-wait-loop"},{"level":3,"text":"Returning 0 Instead of -EAGAIN for Non-Blocking Empty Read","id":"returning-0-instead-of-eagain-for-non-blocking-empty-read"},{"level":3,"text":"Calling poll_wait() After the Condition Check","id":"calling-poll_wait-after-the-condition-check"},{"level":3,"text":"Not Using mutex_lock() (Non-Interruptible) in .poll","id":"not-using-mutex_lock-non-interruptible-in-poll"},{"level":3,"text":"Forgetting to Wake write_queue After Read","id":"forgetting-to-wake-write_queue-after-read"},{"level":2,"text":"If the buffer was full before the read, writers are sleeping on write_queue. After the read frees space, you must call wake_up_interruptible(&amp;write_queue) or writers remain asleep indefinitely. Always wake the opposite queue after modifying buffer_used.","id":"if-the-buffer-was-full-before-the-read-writers-are-sleeping-on-write_queue-after-the-read-frees-space-you-must-call-wake_up_interruptibleampwrite_queue-or-writers-remain-asleep-indefinitely-always-wake-the-opposite-queue-after-modifying-buffer_used"},{"level":2,"text":"Knowledge Cascade: What You&#39;ve Just Unlocked","id":"knowledge-cascade-what-you39ve-just-unlocked"},{"level":2,"text":"â†’ Process States Explain Load Average (cross-domain: system administration)\nNow you understand that wait_event_interruptible puts processes in TASK_INTERRUPTIBLE (S state), while wait_event (uninterruptible) uses TASK_UNINTERRUPTIBLE (D state). Linux&#39;s load average counts both R and D processes â€” which is why a disk-bound server shows high load average at 0% CPU. When top shows many D processes, they&#39;re waiting in uninterruptible sleep (typically for disk or network I/O). When top shows many S processes (like your readers sleeping on an empty device), they contribute 0 to load average because they&#39;re interruptibly sleeping. This is a subtle but important distinction: a server running your blocking-read device will show S-state processes during blocking reads, not D-state, so it won&#39;t inflate load average. A disk driver using wait_event (uninterruptible) will inflate load average.\nâ†’ -ERESTARTSYS Connects to the signal-handler Prerequisite (same domain: kernel signal path)\nIn your signal-handler prerequisite project, you encountered errno == EINTR when a signal interrupted a syscall. Now you know the mechanism: your driver returned -ERESTARTSYS, the kernel&#39;s syscall exit path detected a pending signal, and if SA_RESTART wasn&#39;t set on the signal handler, it converted -ERESTARTSYS to -EINTR before returning to userspace. This is why EINTR-safe loops in C (wrapping read() in a do { n = read(...); } while (n &lt; 0 &amp;&amp; errno == EINTR)) are necessary: your driver is correctly propagating signal interruption, and userspace needs to decide whether to restart or handle it.\nâ†’ Your .poll Handler Is the Foundation of Every Event Loop (cross-domain: Node.js, nginx, Go)\nThe poll_wait() registration mechanism you just implemented is exactly what epoll uses internally. When an epoll fd monitors your device with epoll_ctl(epfd, EPOLL_CTL_ADD, devfd, ...), the kernel calls your .poll handler via ep_item_poll(). Your poll_wait() registers epoll&#39;s internal wait queue callback with read_queue and write_queue. When your write handler calls wake_up_interruptible(&amp;read_queue), it fires the epoll callback, which wakes the epoll_wait() call, which returns the device fd as ready. This is the O(1) event notification that makes epoll scale to millions of file descriptors: no polling loop, just wait queue callbacks. Node.js&#39;s libuv, Go&#39;s netpoller, and nginx all sit on top of this exact mechanism. The .poll handler you just wrote is the leaf node in a chain that enables all modern high-performance I/O.\nâ†’ Your Driver Is Now a Go Channel (cross-domain: concurrent programming)\nThe bounded buffer you just built â€” with a mutex protecting shared state, blocking producers when full, blocking consumers when empty, and waking the other side on state change â€” is the exact implementation of a Go buffered channel (make(chan T, N)). The Go runtime implements channels with a mutex, a wait queue for senders (your write_queue), and a wait queue for receivers (your read_queue). Java&#39;s ArrayBlockingQueue, Python&#39;s queue.Queue, and POSIX pipes all implement this same producer-consumer pattern. When you next read Go&#39;s channel implementation in runtime/chan.go, you&#39;ll see sudog (waiting goroutine descriptors) in a send/receive queue â€” the Go-level equivalent of your wait_queue_entry_t instances in read_queue and write_queue. The kernel C implementation you just wrote is the conceptual ancestor of all of them.\nâ†’ Thundering Herd Explains nginx&#39;s accept_mutex and Linux 4.5&#39;s EPOLLEXCLUSIVE (cross-domain: web servers)\nThe thundering herd you encountered with wake_up_interruptible waking all readers is the exact problem that afflicted early multi-process web servers: when a new TCP connection arrives, all worker processes (sleeping in accept()) wake up, but only one gets the connection. The others re-sleep after doing useless work. nginx added accept_mutex to serialize connection acceptance. Linux 4.5 added EPOLLEXCLUSIVE to epoll â€” when multiple processes epoll-wait on the same fd with EPOLLEXCLUSIVE, only one is woken per event. For your device, wake_up_interruptible_nr(&amp;read_queue, 1) would wake exactly one reader â€” appropriate if the device is pipe-like (one reader gets all the bytes). wake_up_interruptible (all waiters) is appropriate if the device is broadcast-like. The choice of which wake mechanism to use is an architectural decision about your device&#39;s concurrency semantics.\nâ†’ Kernel Synchronization Patterns â†’ Database Locking (cross-domain: databases)\nThe pattern you just implemented â€” &quot;acquire lock, check condition, release lock, sleep, re-acquire lock, re-check condition&quot; â€” is identical to how database engines implement row-level blocking waits. PostgreSQL&#39;s LockAcquire() function uses a heavyweight lock mechanism with a wait list; LockRelease() calls ProcWakeup() to wake a waiting process â€” exactly your wake_up_interruptible after modifying buffer_used. MySQL&#39;s InnoDB uses a similar structure with lock_wait_suspend_thread() corresponding to your wait_event_interruptible. The concurrency primitives you just implemented in 200 lines of C are the conceptual foundation of MVCC, row locking, and deadlock detection in every major database.","id":"-process-states-explain-load-average-cross-domain-system-administration-now-you-understand-that-wait_event_interruptible-puts-processes-in-task_interruptible-s-state-while-wait_event-uninterruptible-uses-task_uninterruptible-d-state-linux39s-load-average-counts-both-r-and-d-processes-which-is-why-a-disk-bound-server-shows-high-load-average-at-0-cpu-when-top-shows-many-d-processes-they39re-waiting-in-uninterruptible-sleep-typically-for-disk-or-network-io-when-top-shows-many-s-processes-like-your-readers-sleeping-on-an-empty-device-they-contribute-0-to-load-average-because-they39re-interruptibly-sleeping-this-is-a-subtle-but-important-distinction-a-server-running-your-blocking-read-device-will-show-s-state-processes-during-blocking-reads-not-d-state-so-it-won39t-inflate-load-average-a-disk-driver-using-wait_event-uninterruptible-will-inflate-load-average-erestartsys-connects-to-the-signal-handler-prerequisite-same-domain-kernel-signal-path-in-your-signal-handler-prerequisite-project-you-encountered-errno-eintr-when-a-signal-interrupted-a-syscall-now-you-know-the-mechanism-your-driver-returned-erestartsys-the-kernel39s-syscall-exit-path-detected-a-pending-signal-and-if-sa_restart-wasn39t-set-on-the-signal-handler-it-converted-erestartsys-to-eintr-before-returning-to-userspace-this-is-why-eintr-safe-loops-in-c-wrapping-read-in-a-do-n-read-while-n-lt-0-ampamp-errno-eintr-are-necessary-your-driver-is-correctly-propagating-signal-interruption-and-userspace-needs-to-decide-whether-to-restart-or-handle-it-your-poll-handler-is-the-foundation-of-every-event-loop-cross-domain-nodejs-nginx-go-the-poll_wait-registration-mechanism-you-just-implemented-is-exactly-what-epoll-uses-internally-when-an-epoll-fd-monitors-your-device-with-epoll_ctlepfd-epoll_ctl_add-devfd-the-kernel-calls-your-poll-handler-via-ep_item_poll-your-poll_wait-registers-epoll39s-internal-wait-queue-callback-with-read_queue-and-write_queue-when-your-write-handler-calls-wake_up_interruptibleampread_queue-it-fires-the-epoll-callback-which-wakes-the-epoll_wait-call-which-returns-the-device-fd-as-ready-this-is-the-o1-event-notification-that-makes-epoll-scale-to-millions-of-file-descriptors-no-polling-loop-just-wait-queue-callbacks-nodejs39s-libuv-go39s-netpoller-and-nginx-all-sit-on-top-of-this-exact-mechanism-the-poll-handler-you-just-wrote-is-the-leaf-node-in-a-chain-that-enables-all-modern-high-performance-io-your-driver-is-now-a-go-channel-cross-domain-concurrent-programming-the-bounded-buffer-you-just-built-with-a-mutex-protecting-shared-state-blocking-producers-when-full-blocking-consumers-when-empty-and-waking-the-other-side-on-state-change-is-the-exact-implementation-of-a-go-buffered-channel-makechan-t-n-the-go-runtime-implements-channels-with-a-mutex-a-wait-queue-for-senders-your-write_queue-and-a-wait-queue-for-receivers-your-read_queue-java39s-arrayblockingqueue-python39s-queuequeue-and-posix-pipes-all-implement-this-same-producer-consumer-pattern-when-you-next-read-go39s-channel-implementation-in-runtimechango-you39ll-see-sudog-waiting-goroutine-descriptors-in-a-sendreceive-queue-the-go-level-equivalent-of-your-wait_queue_entry_t-instances-in-read_queue-and-write_queue-the-kernel-c-implementation-you-just-wrote-is-the-conceptual-ancestor-of-all-of-them-thundering-herd-explains-nginx39s-accept_mutex-and-linux-4539s-epollexclusive-cross-domain-web-servers-the-thundering-herd-you-encountered-with-wake_up_interruptible-waking-all-readers-is-the-exact-problem-that-afflicted-early-multi-process-web-servers-when-a-new-tcp-connection-arrives-all-worker-processes-sleeping-in-accept-wake-up-but-only-one-gets-the-connection-the-others-re-sleep-after-doing-useless-work-nginx-added-accept_mutex-to-serialize-connection-acceptance-linux-45-added-epollexclusive-to-epoll-when-multiple-processes-epoll-wait-on-the-same-fd-with-epollexclusive-only-one-is-woken-per-event-for-your-device-wake_up_interruptible_nrampread_queue-1-would-wake-exactly-one-reader-appropriate-if-the-device-is-pipe-like-one-reader-gets-all-the-bytes-wake_up_interruptible-all-waiters-is-appropriate-if-the-device-is-broadcast-like-the-choice-of-which-wake-mechanism-to-use-is-an-architectural-decision-about-your-device39s-concurrency-semantics-kernel-synchronization-patterns-database-locking-cross-domain-databases-the-pattern-you-just-implemented-quotacquire-lock-check-condition-release-lock-sleep-re-acquire-lock-re-check-conditionquot-is-identical-to-how-database-engines-implement-row-level-blocking-waits-postgresql39s-lockacquire-function-uses-a-heavyweight-lock-mechanism-with-a-wait-list-lockrelease-calls-procwakeup-to-wake-a-waiting-process-exactly-your-wake_up_interruptible-after-modifying-buffer_used-mysql39s-innodb-uses-a-similar-structure-with-lock_wait_suspend_thread-corresponding-to-your-wait_event_interruptible-the-concurrency-primitives-you-just-implemented-in-200-lines-of-c-are-the-conceptual-foundation-of-mvcc-row-locking-and-deadlock-detection-in-every-major-database"},{"level":2,"text":"Acceptance Criteria Checkpoint","id":"acceptance-criteria-checkpoint"},{"level":2,"text":"System Overview","id":"system-overview"},{"level":1,"text":"TDD","id":"tdd"},{"level":1,"text":"MODULE SPECIFICATION: Hello World Kernel Module (build-kernel-module-m1)","id":"module-specification-hello-world-kernel-module-build-kernel-module-m1"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Complete Data Model","id":"3-complete-data-model"},{"level":3,"text":"3.1 Module Parameters","id":"31-module-parameters"},{"level":3,"text":"3.2 ELF Section Layout (Internal)","id":"32-elf-section-layout-internal"},{"level":3,"text":"3.3 Hardware Soul: Memory &amp; Cache","id":"33-hardware-soul-memory-amp-cache"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1 Module Entry Point","id":"41-module-entry-point"},{"level":3,"text":"4.2 Module Exit Point","id":"42-module-exit-point"},{"level":3,"text":"4.3 Kernel Logging (printk)","id":"43-kernel-logging-printk"},{"level":2,"text":"5. Kbuild Makefile Specification","id":"5-kbuild-makefile-specification"},{"level":2,"text":"6. Algorithm Specification: Module Lifecycle","id":"6-algorithm-specification-module-lifecycle"},{"level":3,"text":"6.1 Initialization and Validation Loop","id":"61-initialization-and-validation-loop"},{"level":3,"text":"6.2 Exit Sequence","id":"62-exit-sequence"},{"level":2,"text":"7. Error Handling Matrix","id":"7-error-handling-matrix"},{"level":2,"text":"8. Implementation Sequence with Checkpoints","id":"8-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Skeleton &amp; Kbuild (1.0 Hours)","id":"phase-1-skeleton-amp-kbuild-10-hours"},{"level":3,"text":"Phase 2: Metadata &amp; Logging (1.0 Hours)","id":"phase-2-metadata-amp-logging-10-hours"},{"level":3,"text":"Phase 3: Parameters &amp; Validation (1.0 Hours)","id":"phase-3-parameters-amp-validation-10-hours"},{"level":3,"text":"Phase 4: Verification Automation (1.0 Hours)","id":"phase-4-verification-automation-10-hours"},{"level":2,"text":"9. Test Specification","id":"9-test-specification"},{"level":3,"text":"9.1 Functional Tests","id":"91-functional-tests"},{"level":3,"text":"9.2 Metadata Validation","id":"92-metadata-validation"},{"level":2,"text":"10. Performance Targets","id":"10-performance-targets"},{"level":2,"text":"11. State Machine: Module Lifecycle","id":"11-state-machine-module-lifecycle"},{"level":2,"text":"12. Security &amp; Constraints","id":"12-security-amp-constraints"},{"level":1,"text":"MODULE SPECIFICATION: Character Device Driver (build-kernel-module-m2)","id":"module-specification-character-device-driver-build-kernel-module-m2"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Complete Data Model","id":"3-complete-data-model"},{"level":3,"text":"3.1 Device Private Structure (struct my_device_data)","id":"31-device-private-structure-struct-my_device_data"},{"level":3,"text":"3.2 VFS Interaction Model (The VTable)","id":"32-vfs-interaction-model-the-vtable"},{"level":3,"text":"3.3 Memory Layout: The 4KB Buffer","id":"33-memory-layout-the-4kb-buffer"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1 System Call Handlers (Kernel Context)","id":"41-system-call-handlers-kernel-context"},{"level":4,"text":"int my_open(struct inode *inode, struct file *filp)","id":"int-my_openstruct-inode-inode-struct-file-filp"},{"level":4,"text":"int my_release(struct inode *inode, struct file *filp)","id":"int-my_releasestruct-inode-inode-struct-file-filp"},{"level":4,"text":"ssize_t my_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)","id":"ssize_t-my_readstruct-file-filp-char-__user-buf-size_t-count-loff_t-f_pos"},{"level":4,"text":"ssize_t my_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)","id":"ssize_t-my_writestruct-file-filp-const-char-__user-buf-size_t-count-loff_t-f_pos"},{"level":2,"text":"5. Algorithm Specification: The Implementation Path","id":"5-algorithm-specification-the-implementation-path"},{"level":3,"text":"5.1 Module Initialization Sequence (The Goto Unwind)","id":"51-module-initialization-sequence-the-goto-unwind"},{"level":3,"text":"5.2 Read Handler Algorithm","id":"52-read-handler-algorithm"},{"level":3,"text":"5.3 Write Handler Algorithm","id":"53-write-handler-algorithm"},{"level":2,"text":"6. Three-Level View: Hardware Soul","id":"6-three-level-view-hardware-soul"},{"level":3,"text":"Level 1 â€” Application (User)","id":"level-1-application-user"},{"level":3,"text":"Level 2 â€” OS/Kernel (VFS)","id":"level-2-oskernel-vfs"},{"level":3,"text":"Level 3 â€” Hardware (CPU/MMU)","id":"level-3-hardware-cpummu"},{"level":2,"text":"7. Error Handling Matrix","id":"7-error-handling-matrix"},{"level":2,"text":"8. Implementation Sequence with Checkpoints","id":"8-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Dynamic Allocation &amp; Cdev (2 Hours)","id":"phase-1-dynamic-allocation-amp-cdev-2-hours"},{"level":3,"text":"Phase 2: Udev Integration (1.5 Hours)","id":"phase-2-udev-integration-15-hours"},{"level":3,"text":"Phase 3: Memory &amp; Ops (3 Hours)","id":"phase-3-memory-amp-ops-3-hours"},{"level":3,"text":"Phase 4: Position &amp; Bounds (1.5 Hours)","id":"phase-4-position-amp-bounds-15-hours"},{"level":2,"text":"9. Test Specification","id":"9-test-specification"},{"level":3,"text":"9.1 Functional Tests","id":"91-functional-tests"},{"level":3,"text":"9.2 Boundary Tests","id":"92-boundary-tests"},{"level":2,"text":"10. Performance Targets","id":"10-performance-targets"},{"level":2,"text":"11. Concurrency Specification (Milestone 2 Context)","id":"11-concurrency-specification-milestone-2-context"},{"level":2,"text":"12. Verification Script (verify_m2.sh)","id":"12-verification-script-verify_m2sh"},{"level":1,"text":"MODULE SPECIFICATION: ioctl and /proc Interface (build-kernel-module-m3)","id":"module-specification-ioctl-and-proc-interface-build-kernel-module-m3"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Complete Data Model","id":"3-complete-data-model"},{"level":3,"text":"3.1 ioctl Command Encoding (Wire Format)","id":"31-ioctl-command-encoding-wire-format"},{"level":3,"text":"3.2 ABI Structure: struct mydev_status","id":"32-abi-structure-struct-mydev_status"},{"level":3,"text":"3.3 Hardware Soul: Cache &amp; Alignment","id":"33-hardware-soul-cache-amp-alignment"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1 Header Contract: mydevice_ioctl.h","id":"41-header-contract-mydevice_ioctlh"},{"level":3,"text":"4.2 ioctl Handler: mydev_ioctl","id":"42-ioctl-handler-mydev_ioctl"},{"level":3,"text":"4.3 /proc Interface: seq_file","id":"43-proc-interface-seq_file"},{"level":2,"text":"5. Algorithm Specification","id":"5-algorithm-specification"},{"level":3,"text":"5.1 Allocate-Then-Swap Buffer Resize","id":"51-allocate-then-swap-buffer-resize"},{"level":3,"text":"5.2 seq_file Iteration (Logic)","id":"52-seq_file-iteration-logic"},{"level":2,"text":"6. Error Handling Matrix","id":"6-error-handling-matrix"},{"level":2,"text":"7. Implementation Sequence with Checkpoints","id":"7-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Shared Header &amp; Skeleton (1 Hour)","id":"phase-1-shared-header-amp-skeleton-1-hour"},{"level":3,"text":"Phase 2: CLEAR &amp; STATUS Commands (2 Hours)","id":"phase-2-clear-amp-status-commands-2-hours"},{"level":3,"text":"Phase 3: RESIZE Implementation (2.5 Hours)","id":"phase-3-resize-implementation-25-hours"},{"level":3,"text":"Phase 4: /proc Filesystem (1.5 Hours)","id":"phase-4-proc-filesystem-15-hours"},{"level":2,"text":"8. Test Specification","id":"8-test-specification"},{"level":3,"text":"8.1 ioctl Functional Tests","id":"81-ioctl-functional-tests"},{"level":3,"text":"8.2 Observability Tests","id":"82-observability-tests"},{"level":2,"text":"9. Performance Targets","id":"9-performance-targets"},{"level":2,"text":"10. Concurrency Specification (M3 Context)","id":"10-concurrency-specification-m3-context"},{"level":2,"text":"11. Three-Level View: RESIZE","id":"11-three-level-view-resize"},{"level":1,"text":"MODULE SPECIFICATION: Concurrent Access, Blocking I/O, and Poll Support (build-kernel-module-m4)","id":"module-specification-concurrent-access-blocking-io-and-poll-support-build-kernel-module-m4"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Complete Data Model","id":"3-complete-data-model"},{"level":3,"text":"3.1 Device Private Structure (struct my_device_data)","id":"31-device-private-structure-struct-my_device_data"},{"level":3,"text":"3.2 Hardware Soul: Cache and Lock Contention","id":"32-hardware-soul-cache-and-lock-contention"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1 Blocking Read Handler","id":"41-blocking-read-handler"},{"level":3,"text":"4.2 Blocking Write Handler","id":"42-blocking-write-handler"},{"level":3,"text":"4.3 Poll Handler","id":"43-poll-handler"},{"level":2,"text":"5. Algorithm Specification","id":"5-algorithm-specification"},{"level":3,"text":"5.1 The Mutex-Release-Before-Sleep Pattern (Read)","id":"51-the-mutex-release-before-sleep-pattern-read"},{"level":3,"text":"5.2 Poll Implementation Logic","id":"52-poll-implementation-logic"},{"level":2,"text":"6. Error Handling Matrix","id":"6-error-handling-matrix"},{"level":2,"text":"7. Implementation Sequence with Checkpoints","id":"7-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Serialization (1.5 Hours)","id":"phase-1-serialization-15-hours"},{"level":3,"text":"Phase 2: Blocking Read (2 Hours)","id":"phase-2-blocking-read-2-hours"},{"level":3,"text":"Phase 3: Blocking Write &amp; Wakeups (1.5 Hours)","id":"phase-3-blocking-write-amp-wakeups-15-hours"},{"level":3,"text":"Phase 4: O_NONBLOCK &amp; Poll (2 Hours)","id":"phase-4-o_nonblock-amp-poll-2-hours"},{"level":3,"text":"Phase 5: Concurrent Stress Test (2.5 Hours)","id":"phase-5-concurrent-stress-test-25-hours"},{"level":2,"text":"8. Test Specification","id":"8-test-specification"},{"level":3,"text":"8.1 Unit Tests","id":"81-unit-tests"},{"level":3,"text":"8.2 Stress Test (The &quot;Crucible&quot;)","id":"82-stress-test-the-quotcruciblequot"},{"level":2,"text":"9. Performance Targets","id":"9-performance-targets"},{"level":2,"text":"10. State Machine: Reader Lifecycle","id":"10-state-machine-reader-lifecycle"},{"level":2,"text":"11. Security &amp; Constraints","id":"11-security-amp-constraints"},{"level":1,"text":"Project Structure: Linux Kernel Module","id":"project-structure-linux-kernel-module"},{"level":2,"text":"Directory Tree","id":"directory-tree"},{"level":2,"text":"Creation Order","id":"creation-order"},{"level":2,"text":"File Count Summary","id":"file-count-summary"}],"title":"ðŸŽ¯ Project Charter: Linux Kernel Module","markdown":"# ðŸŽ¯ Project Charter: Linux Kernel Module\n\n## What You Are Building\nYou are building a production-grade Linux character device driverâ€”a loadable kernel module (`.ko`) that acts as a bridge between the Linux kernel and userspace. This isn't a simple \"Hello World\"; you will build a virtual device that manages a kernel-space buffer, exposes a `/dev/` file interface for data transfer, implements a custom `ioctl` control protocol, and provides a `/proc` entry for live system introspection. By the end, your driver will safely handle concurrent access from multiple processes using kernel synchronization primitives.\n\n## Why This Project Exists\nMost developers interact with the operating system through high-level abstractions, treating the kernel as a \"black box.\" Building a kernel module from scratch is the only way to truly understand the \"everything is a file\" philosophy. You will confront the hardware-enforced boundary between userspace and kernelspace, learning why direct pointer dereferencing is fatal and how the kernel manages memory, scheduling, and concurrency at the highest privilege level (Ring 0).\n\n## What You Will Be Able to Do When Done\n- **Develop and Debug LKMs:** Compile, load, and unload out-of-tree modules using the Kbuild system and inspect logs via `dmesg`.\n- **Bridge the Memory Divide:** Use `copy_to_user` and `copy_from_user` to safely move data across the kernel-userspace boundary.\n- **Implement VFS Operations:** Write handlers for standard system calls like `open()`, `read()`, `write()`, and `close()`.\n- **Design Binary Protocols:** Create custom control interfaces using `ioctl` with unique magic numbers and encoded command structures.\n- **Master Kernel Concurrency:** Use `mutexes` to prevent race conditions and `wait queues` to implement blocking I/O and process sleeping.\n- **Support Multiplexed I/O:** Implement the `.poll` operation to make your device compatible with `select()`, `poll()`, and `epoll()`.\n\n## Final Deliverable\nA robust C source file (approx. 500 lines) and a Kbuild-compatible `Makefile`. The final module creates `/dev/mydevice` (for data) and `/proc/mydevice` (for stats). It must pass a concurrent stress test where 8 processes (4 readers, 4 writers) access the device simultaneously without data corruption, deadlocks, or a \"Kernel Oops.\"\n\n## Is This Project For You?\n**You should start this if you:**\n- Are proficient in C (specifically pointers, structs, and manual memory management).\n- Understand basic concurrency concepts like race conditions and locks.\n- Are comfortable working in a Linux terminal and using `sudo` privileges.\n\n**Come back after you've learned:**\n- [C Programming Pointers & Structs](https://en.cppreference.com/w/c/language/pointer)\n- [Basic Linux Signal Handling](https://man7.org/linux/man-pages/man7/signal.7.html) (If you don't know why `read()` might be interrupted).\n\n## Estimated Effort\n| Phase | Time |\n|-------|------|\n| **M1: Hello World & Metadata** (Setup, Kbuild, and Params) | ~4 hours |\n| **M2: Character Device Core** (Read/Write & /dev creation) | ~8 hours |\n| **M3: Control & Introspection** (ioctl and /proc seq_file) | ~8 hours |\n| **M4: Concurrency & Poll** (Mutex, Wait Queues, and Poll) | ~10 hours |\n| **Total** | **~30 hours** |\n\n## Definition of Done\nThe project is complete when:\n- The module compiles with `-Werror` and loads without \"tainting\" the kernel (proper GPL license).\n- A userspace `echo` can write data to `/dev/mydevice` and `cat` can read it back.\n- Custom `ioctl` commands successfully resize the internal kernel buffer at runtime.\n- `/proc/mydevice` displays real-time, accurate counts of total bytes read and written.\n- The driver survives the \"Thundering Herd\" stress test (multiple concurrent readers/writers) without a kernel panic or data loss.\n```\n\n---\n\n# ðŸ“š Before You Read This: Prerequisites & Further Reading\n\n> **Read these first.** The Atlas assumes you are familiar with the foundations below.\n> Resources are ordered by when you should encounter them â€” some before you start, some at specific milestones.\n\n### 1. The Kernel-Userspace Boundary\n**Topic: System Call Architecture & Memory Protection**\n\n*   **Paper**: P. J. Braam, 2003, \"The Linux Virtual File System.\"\n*   **Code**: `arch/x86/entry/entry_64.S` â€” The raw assembly handling the transition from ring 3 to ring 0.\n*   **Best Explanation**: *Linux Kernel Development* (3rd Ed) by Robert Love, Chapter 5: \"System Calls.\"\n*   **Why**: It provides the most readable explanation of how the processor physically switches privilege levels and how the kernel validates the syscall table.\n*   **Timing**: Read **BEFORE Milestone 1** to understand the \"physics\" of the environment you are entering.\n\n*   **Spec**: POSIX.1-2017, Section 2.9.7: \"Thread-Safety\" and \"Memory Sanity.\"\n*   **Code**: `arch/x86/lib/copy_user_64.S` â€” Look for the `_copy_to_user` implementation and the `.fixup` section.\n*   **Best Explanation**: LWN.net, \"Accessing user-space memory\" by Jonathan Corbet.\n*   **Why**: This article explains the \"Trap and Recover\" mechanism (exception tables) that makes `copy_from_user` safe without pre-checking pointers.\n*   **Timing**: Read **during Milestone 2** after your first kernel panic to understand why your direct pointer dereference failed.\n\n---\n\n### 2. Character Device Architecture\n**Topic: VFS & Device Registration**\n\n*   **Code**: `fs/char_dev.c` â€” The core implementation of the major/minor number registry.\n*   **Best Explanation**: *Linux Device Drivers* (3rd Ed) by Corbet, Rubini, & Kroah-Hartman, Chapter 3: \"Char Drivers.\"\n*   **Why**: Though written for older kernels, the architectural pattern of `struct cdev` and the VFS dispatch remains the definitive pedagogical map.\n*   **Timing**: Read **at the start of Milestone 2** to see the \"contract\" you are about to fulfill.\n\n*   **Spec**: Linux Kernel Documentation: `admin-guide/devices.txt`.\n*   **Code**: `include/linux/fs.h` â€” Focus on the `struct file_operations` definition.\n*   **Best Explanation**: \"The Linux VFS\" by Neil Brown (LWN series).\n*   **Why**: It explains how the VFS provides polymorphism in C, allowing a socket, a file, and your driver to share the same `read()` interface.\n*   **Timing**: Read **after Milestone 2** to appreciate how your driver fits into the global Linux filesystem tree.\n\n---\n\n### 3. Memory Management\n**Topic: SLUB Allocator & Kernel Paging**\n\n*   **Paper**: Jeff Bonwick, 1994, \"The Slab Allocator: An Object-Caching Kernel Memory Allocator.\"\n*   **Code**: `mm/slub.c` â€” Specifically the `slab_alloc_node` function.\n*   **Best Explanation**: *Understanding the Linux Kernel* by Bovet & Cesati, Chapter 8: \"Memory Management.\"\n*   **Why**: It explains the \"Bento Box\" model of memory allocation and why `kmalloc` is faster than `malloc`.\n*   **Timing**: Read **during Milestone 2** when you call `kzalloc()` for the first time.\n\n---\n\n### 4. Control Plane & Introspection\n**Topic: ioctl Design & Virtual Filesystems**\n\n*   **Spec**: Linux Kernel Documentation: `userspace-api/ioctl/ioctl-number.rst`.\n*   **Code**: `include/uapi/asm-generic/ioctl.h` â€” The macros that define the 32-bit command encoding.\n*   **Best Explanation**: \"The new way of doing ioctl()\" (LWN) regarding the transition to `unlocked_ioctl`.\n*   **Why**: Essential for understanding why the Big Kernel Lock was removed and how modern ioctl dispatch works.\n*   **Timing**: Read **at the start of Milestone 3** to avoid defining \"garbage\" ioctl numbers that conflict with other drivers.\n\n*   **Code**: `fs/seq_file.c` â€” The implementation of the iterator pattern for `/proc`.\n*   **Best Explanation**: Linux Kernel Documentation: \"The seq_file Interface.\"\n*   **Why**: It is the only resource that correctly explains why you don't need to worry about 4KB buffer limits when using `seq_printf`.\n*   **Timing**: Read **during Milestone 3** while implementing your `/proc` entry.\n\n---\n\n### 5. Concurrency & Synchronization\n**Topic: Mutexes, Wait Queues, and Scheduling**\n\n*   **Code**: `kernel/locking/mutex.c` â€” Look for the \"Fast path\" vs \"Slow path\" logic.\n*   **Best Explanation**: *Linux Kernel Development* by Robert Love, Chapter 9: \"Kernel Synchronization Methods.\"\n*   **Why**: Love differentiates between spinlocks and mutexes based on \"context,\" which is the single most important concept for kernel stability.\n*   **Timing**: Read **BEFORE starting Milestone 4**; it is required knowledge to prevent deadlocks.\n\n*   **Paper**: S. Molloy, 2006, \"The 'Thundering Herd' Problem in Network Servers.\"\n*   **Code**: `kernel/sched/wait.c` â€” The `prepare_to_wait` and `finish_wait` functions.\n*   **Best Explanation**: \"Wait queues in the Linux kernel\" (KernelNewbies Wiki).\n*   **Why**: It provides a line-by-line breakdown of how `sleep()` actually informs the scheduler to stop running a task.\n*   **Timing**: Read **during Milestone 4** while debugging why your reader process won't wake up.\n\n---\n\n### 6. Event Multiplexing\n**Topic: Poll, Select, and Epoll**\n\n*   **Code**: `fs/select.c` â€” The `do_poll` function loop.\n*   **Best Explanation**: \"The Implementation of epoll (1)\" by Marek Majkowski.\n*   **Why**: It traces the `poll_wait` callback from your driver all the way up to the `epoll_wait` system call in userspace.\n*   **Timing**: Read **at the end of Milestone 4** to understand how your driver enables high-performance servers (Nginx/Node.js).\n\n---\n\n### 7. Reliability & Debugging\n**Topic: Tainting & Oops Analysis**\n\n*   **Best Explanation**: Linux Kernel Documentation: `admin-guide/tainted-kernels.rst`.\n*   **Why**: You need to know what the letters in `Tainted: P  G      W` mean when your kernel crashes.\n*   **Timing**: Read **the first time you see a \"Kernel Oops\"** in your dmesg logs.\n\n*   **Code**: `scripts/decode_stacktrace.sh` in the Linux source tree.\n*   **Best Explanation**: \"Kernel Address Space Layout Randomization (KASLR)\" (LWN).\n*   **Why**: It explains why your crash addresses look different every time you reboot.\n*   **Timing**: Read **after Milestone 4** to transition from a student to a professional systems engineer.\n\n---\n\n# Linux Kernel Module: Interactive Atlas\n\nThis project builds a fully functional Linux character device driver from scratch â€” starting with a minimal loadable kernel module and progressively adding file operations, ioctl control interfaces, /proc introspection, and concurrent access handling with wait queues and poll support. The journey traverses the most fundamental boundary in modern computing: the line between kernel space and user space. Every system call you've ever made â€” read(), write(), open() â€” terminates in code that looks exactly like what you'll write here.\n\nBy the end, you'll have a character device that multiple processes can open, read, write, and poll concurrently, with proper mutex synchronization, blocking/non-blocking I/O semantics, and runtime introspection via /proc. This isn't a toy: it's the same architecture used by /dev/null, /dev/random, /dev/tty, and every hardware driver in the Linux kernel.\n\nThe real learning isn't just the API â€” it's understanding WHY the API looks the way it does. Why does copy_to_user() exist instead of memcpy()? Why does wait_event_interruptible() return -ERESTARTSYS? Why must poll() both register a wait queue AND return a mask? Each answer reveals a deep design constraint that ripples across all of systems programming.\n\n\n\n<!-- MS_ID: build-kernel-module-m1 -->\n# Milestone 1: Hello World Kernel Module\n## The Ground Beneath Your Feet\nBefore you write a single line of kernel code, you need to confront a misconception that trips up nearly every developer coming to kernel programming for the first time. It's worth addressing head-on because getting it wrong doesn't just cause bugs â€” it causes *kernel panics*.\n---\n### The Revelation: You Are Not Writing a Library\nYou probably know that Linux supports dynamically loaded shared libraries â€” `.so` files that a process loads at runtime via `dlopen()`. The mental model is clean: the library gets mapped into the process's address space, the dynamic linker resolves symbols, the library runs in the same process context as the caller, and if the library crashes, it crashes the process (not the whole system). You've worked with this model before.\nWhen you hear \"loadable kernel module,\" your brain reaches for this analogy: *it's probably like a kernel-side .so file, loaded on demand, running in some contained kernel process, debuggable with gdb.*\n**Every part of that model is wrong.**\nA kernel module is not loaded *into* a process. It is injected *into the kernel itself* â€” the same 40-million-line entity that manages every process, every memory mapping, every hardware interrupt on your machine. There is no isolation. There is no \"kernel process\" running your module's code in a sandbox.\nWhen your module's `init` function runs, it runs with **ring 0 CPU privilege** â€” the highest privilege level the hardware supports. It can access any physical memory address. It can execute any hardware instruction. It can corrupt the kernel's own data structures. When your module's functions are called later (by processes making system calls), they run directly in the kernel's address space, on whatever CPU the calling process happened to be scheduled on, with no process boundary separating them from the kernel's internals.\nThe consequence: a NULL pointer dereference in your module doesn't produce a segmentation fault. It produces a **kernel oops** â€” a diagnostic dump showing the CPU state, register values, and stack trace at the moment of the crash â€” and potentially a kernel panic that halts the machine. There is no signal handler to catch this, no garbage collector to save you, no memory-safe language to interpose. You are the kernel.\n\n![Kernel vs User Address Space Layout](./diagrams/diag-m1-address-space-split.svg)\n\n\n> **ðŸ”‘ Foundation: Kernel vs userspace address spaces**\n> \n> **1. What it IS**\nIn a modern operating system, the CPU uses virtual memory to isolate processes. This virtual memory is split into two primary regions: **Userspace** and **Kernelspace**. \n*   **Userspace** is the restricted sandbox where your applications (like `ls`, `web browsers`, or `python`) run. They cannot touch hardware directly and have a limited view of memory.\n*   **Kernelspace** is the privileged area where the core operating system resides. It has full access to the CPU instructions and all physical hardware.\n\n**2. WHY you need it right now**\nIf you are writing a device driver or a kernel module, you are operating in Kernelspace. You cannot simply \"pass a pointer\" from a user application to the kernel and dereference it. Because each user process has its own isolated address space, the address `0x400500` in a user program might point to a string, but in the kernel, that same address could point to something entirely differentâ€”or nothing at all. You must use specific functions (like `copy_from_user`) to safely bridge this gap.\n\n**3. Key Insight: The \"One-Way Mirror\" Mental Model**\nThink of the Kernel as the landlord of an apartment building and Userspace processes as the tenants. Each tenant lives in their own apartment (Address Space) and canâ€™t see inside others. The landlord lives in a private office (Kernelspace). The landlord can look into any apartment to move furniture or fix pipes, but the tenants can only interact with the landlord through a specific mail slot (System Calls). They can never walk into the landlord's office uninvited.\n\nThis isn't meant to frighten you â€” it's meant to orient you. Kernel development has a different *physics* than userspace development. The same discipline that makes you check every `malloc()` return value in userspace needs to be applied with ten times the rigor here, because the cost of failure is ten times higher. Once you internalize this, the entire design of the kernel API â€” the strange-looking macros, the mandatory error checks, the careful memory barriers â€” starts making sense. Every API is designed the way it is because someone suffered the alternative.\n---\n## What a Module Actually Is\n\n![Module Lifecycle: Load â†’ Init â†’ Running â†’ Exit â†’ Unload](./diagrams/diag-m1-module-lifecycle.svg)\n\nA kernel module is an **ELF object file** (`.ko` extension, for \"kernel object\") that the kernel's module loader reads, relocates, and links into the live kernel image at runtime.\n[[EXPLAIN:how-the-kernel-loads-and-links-modules-(.ko-files,-symbol-resolution)|How the kernel loads and links modules (.ko files, symbol resolution)]]\nThe `.ko` file is structurally similar to a `.o` file from your compiler â€” it has code sections, data sections, relocation entries, and a symbol table. The critical difference is what it links *against*: not libc, not any userspace library, but the **kernel's own symbol table** â€” the list of all functions and variables the running kernel has explicitly exported for module use. Functions like `printk`, `kmalloc`, `class_create` â€” these are kernel symbols that your module will reference, and they get resolved at load time against the kernel that's actually running.\nThis is why the kernel headers you compile against must **exactly match** the running kernel. If your headers say `struct file_operations` has 25 fields but the running kernel's struct has 26 fields, your module will write to wrong memory offsets when it fills that struct. The result is not a compile error â€” it's silent data corruption that may not manifest until some seemingly unrelated kernel path trips over your corrupted data.\n---\n## The Kbuild System: Compiling Into the Kernel\nYou won't use a plain `Makefile` with `gcc` directly. The Linux kernel uses its own build system, **Kbuild**, which knows how to compile code that will be linked against the kernel. Kbuild handles the complex flags required to build kernel code correctly â€” position-independent code settings, stack protector flags, no standard library includes, kernel-specific warning flags, and more.\n{{DIAGRAM:diag-m1-kbuild-flow}}\nFor an out-of-tree module (one that lives outside the kernel source tree), you write a two-line `Makefile` that delegates to Kbuild:\n```makefile\n# Makefile â€” out-of-tree kernel module build\nobj-m += hello.o\nall:\n\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\nclean:\n\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\n```\nLet's read this carefully:\n- `obj-m += hello.o` â€” tells Kbuild to compile `hello.c` and link it as a module (the `-m` suffix means \"module\", as opposed to `-y` which means \"built into the kernel image\"). Kbuild automatically maps `hello.o` to `hello.c` as the source.\n- `-C /lib/modules/$(shell uname -r)/build` â€” changes to the kernel build directory for the **currently running kernel** (`uname -r` returns something like `6.8.0-47-generic`). The kernel build directory contains the Kbuild infrastructure and the kernel configuration used to build the running kernel.\n- `M=$(PWD) modules` â€” tells Kbuild that the module source lives in the current directory (`$(PWD)`), and to build the `modules` target (which compiles out-of-tree modules).\nThe practical implication: you must have the **kernel headers** installed for your running kernel. On Ubuntu/Debian:\n```bash\nsudo apt install linux-headers-$(uname -r)\n```\nOn Fedora/RHEL:\n```bash\nsudo dnf install kernel-devel-$(uname -r)\n```\nIf the headers aren't installed, the build directory won't exist and `make` will fail immediately.\n> **Hardware Soul**: Compiling kernel code requires disabling features like stack canaries in certain contexts, enabling specific code model flags (`-mcmodel=kernel` on x86_64) that constrain how code addresses memory, and ensuring no floating-point instructions are emitted (the kernel doesn't save/restore FPU state except when explicitly crossing to/from userspace). Kbuild applies all of these automatically. If you tried to compile with `gcc hello.c -o hello.ko` directly, you'd produce an object that *looks* correct but would corrupt the kernel when loaded.\n---\n## Writing the Minimal Module\nHere is the smallest valid kernel module:\n```c\n// hello.c â€” minimal kernel module\n#include <linux/module.h>   /* MODULE_LICENSE, MODULE_AUTHOR, etc. */\n#include <linux/kernel.h>   /* printk, KERN_INFO */\n#include <linux/init.h>     /* __init, __exit */\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"A minimal kernel module demonstrating load/unload lifecycle\");\nMODULE_VERSION(\"1.0\");\nstatic int __init hello_init(void)\n{\n    printk(KERN_INFO \"hello: module loaded\\n\");\n    return 0;\n}\nstatic void __exit hello_exit(void)\n{\n    printk(KERN_INFO \"hello: module unloaded\\n\");\n}\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n```\nEvery line here does something specific. Let's walk through each piece.\n### Include Headers â€” The Kernel's Standard Library\n```c\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n```\nThese are not the headers from `/usr/include` that your userspace programs use. They come from the kernel source tree under `include/linux/`. Crucially, you **never** include `<stdio.h>`, `<stdlib.h>`, `<string.h>`, or any other C standard library header. The C standard library is a userspace library â€” it doesn't exist in the kernel. The kernel has its own implementations of common utilities (`strlen`, `memcpy`, `sprintf`) in `<linux/string.h>`, `<linux/kernel.h>`, etc.\nIf you accidentally include `<stdio.h>` in kernel code, the compiler will fail in spectacular ways â€” the standard library headers include syscall wrappers and type definitions that conflict with kernel type definitions.\n### Module Metadata Macros\n```c\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"A minimal kernel module demonstrating load/unload lifecycle\");\nMODULE_VERSION(\"1.0\");\n```\nThese macros don't generate function calls or runtime initialization code. They inject **strings into dedicated ELF sections** in the `.ko` file. The `modinfo` tool reads these sections directly from the file, and the kernel's module loader reads `MODULE_LICENSE` to decide whether to grant access to GPL-only symbols.\n`MODULE_LICENSE(\"GPL\")` is not a legal formality â€” it is **functionally required**. The Linux kernel uses the GNU Public License \n> **ðŸ”‘ Foundation: GPL symbol export mechanism: how EXPORT_SYMBOL_GPL works and what \"tainting\" means**\n> \n> **1. What it IS**\nThe Linux kernel is modular. To allow one module to use functions (symbols) from another, the kernel uses the `EXPORT_SYMBOL` macro. There are two tiers:\n*   **EXPORT_SYMBOL:** Makes a function available to any module, regardless of license.\n*   **EXPORT_SYMBOL_GPL:** Makes a function available *only* to modules that declare a GPL-compatible license.\n\n**Tainting** is a state flag in the kernel. If you load a module that is proprietary (non-GPL) or if the kernel encounters a catastrophic hardware error, the kernel marks itself as \"Tainted.\"\n\n**2. WHY you need it right now**\nWhen developing a kernel module, your choice of license (`MODULE_LICENSE(\"GPL\")`) determines which internal APIs you can access. If you try to use a function exported via `EXPORT_SYMBOL_GPL` in a non-GPL module, the kernel will refuse to load your module. Furthermore, if you are debugging a crash and your kernel is \"Tainted,\" kernel developers will often ignore your bug report because proprietary code makes it impossible to verify the kernel's internal state.\n\n**3. Key Insight: The \"Void if Seal Broken\" Sticker**\nThink of \"Tainting\" like the warranty sticker on a piece of electronics. Loading a non-GPL module or forcing a module into the kernel is like peeling that sticker off. The device (the kernel) might still work perfectly fine, but the \"manufacturer\" (the Linux community) will no longer support it because they can't be sure what happened inside the box once the \"seal\" was broken.\n to gate access to certain symbols. Functions like `__alloc_pages`, most of the crypto API, and many driver APIs are exported only to GPL-licensed modules via `EXPORT_SYMBOL_GPL()`. If your module declares any other license (or omits the macro), loading it will \"taint\" the kernel â€” marking it as running non-GPL code â€” and the symbol resolution for any `EXPORT_SYMBOL_GPL` symbol your module needs will fail with an `Unknown symbol` error.\nThe accepted values for `MODULE_LICENSE` are: `\"GPL\"`, `\"GPL v2\"`, `\"GPL and additional rights\"`, `\"Dual BSD/GPL\"`, `\"Dual MIT/GPL\"`, `\"Dual MPL/GPL\"`, and `\"Proprietary\"`. The last one taints the kernel and blocks GPL-only symbols.\n### `__init` and `__exit` â€” Section Annotations\n```c\nstatic int __init hello_init(void) { ... }\nstatic void __exit hello_exit(void) { ... }\n```\nThe `__init` and `__exit` macros are **section annotations** that place the decorated functions into special ELF sections (`.init.text` and `.exit.text` respectively).\nFor functions in `.init.text`: after the module successfully initializes, the kernel **frees the memory** occupied by those functions. The init code runs exactly once â€” never again after initialization â€” so keeping it resident wastes RAM. On resource-constrained systems (embedded, server with thousands of modules), this matters.\nFor functions in `.exit.text`: if the module is compiled as a built-in (not loadable, but baked into the kernel image at compile time), the exit functions are discarded entirely â€” a built-in module can never be unloaded, so the exit function is dead code.\nThe `static` keyword matters too: it prevents these functions from being exported as global symbols, which keeps the module's symbol footprint minimal and prevents accidental name collisions with other kernel symbols.\n### `module_init()` and `module_exit()` â€” Registration\n```c\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n```\nThese macros register your init and exit functions with the kernel's module framework. They don't *call* the functions â€” they tell the kernel loader \"when this module is loaded, call `hello_init`; when it's unloaded, call `hello_exit`.\"\nThe return value of the init function is critical: returning `0` means success, returning a negative error code (like `-ENOMEM` for out-of-memory, or `-EBUSY` for a resource conflict) causes `insmod` to fail and the module to not be loaded. The error code propagates back to the `insmod` process as the exit status. **Never return a positive value from init** â€” positive values have undefined behavior in this context.\nIf init returns an error, the kernel guarantees that exit will **not** be called. This means your init function must clean up any resources it already allocated before returning the error â€” a partial initialization that returns an error but leaves resources allocated will leak them permanently.\n---\n## `printk` â€” Logging Without a Terminal\nYour first instinct when debugging might be to reach for `printf`. In the kernel, `printf` doesn't exist. Instead you use `printk`:\n```c\nprintk(KERN_INFO \"hello: module loaded\\n\");\n```\nNote the unusual syntax: `KERN_INFO` is not a separate argument separated by a comma â€” it's a string **concatenated** with the format string at compile time. `KERN_INFO` expands to the string `\"\\001\\006\"` (SOH followed by '6', the log level number), and the C compiler concatenates adjacent string literals. The result is a single string: `\"\\001\\006hello: module loaded\\n\"`.\n\n![printk Ring Buffer and dmesg](./diagrams/diag-m1-printk-ring-buffer.svg)\n\nThe log levels in order from most to least severe:\n| Macro | Level | Numeric | Meaning |\n|-------|-------|---------|---------|\n| `KERN_EMERG` | 0 | Emergency | System is unusable |\n| `KERN_ALERT` | 1 | Alert | Immediate action required |\n| `KERN_CRIT` | 2 | Critical | Critical condition |\n| `KERN_ERR` | 3 | Error | Error condition |\n| `KERN_WARNING` | 4 | Warning | Warning condition |\n| `KERN_NOTICE` | 5 | Notice | Normal but significant |\n| `KERN_INFO` | 6 | Info | Informational |\n| `KERN_DEBUG` | 7 | Debug | Debug-level message |\n`printk` writes its output to the **kernel ring buffer** â€” a circular buffer in kernel memory (typically 512KB to 4MB, configurable). The `dmesg` command reads this buffer by reading `/dev/kmsg` (which is itself a character device â€” you'll be building something structurally similar in Milestone 2). Because the buffer is circular, old messages get overwritten when the buffer fills up.\n> **The ring buffer is not stdout.** `printk` doesn't write to a terminal. If the console log level is high enough (controlled by `/proc/sys/kernel/printk`), messages may also appear on the system console, but the primary output path is the ring buffer accessible via `dmesg`.\n```bash\n# After insmod hello.ko, check dmesg for your message\ndmesg | tail -5\n# Or follow in real-time with -w (like tail -f)\ndmesg -w\n```\nThe timestamp format in dmesg output (`[12345.678901]`) is seconds since boot, not wall clock time. Use `dmesg -T` to convert to human-readable timestamps.\n---\n## Module Parameters: Runtime Configurability\nA static module is limited. Real modules need to be tunable: buffer sizes, timeout values, debug levels, device addresses. The `module_param()` macro system exposes module-level variables as parameters settable at load time and (optionally) at runtime via `/sys`.\n```c\n#include <linux/moduleparam.h>\nstatic int buffer_size = 4096;  /* default: 4KB */\nmodule_param(buffer_size, int, 0644);\nMODULE_PARM_DESC(buffer_size, \"Size of the device buffer in bytes (default: 4096)\");\n```\nThe `module_param(name, type, permissions)` macro takes three arguments:\n1. **`name`**: The variable name. Must be a static module-level variable â€” this is **not** a copy; the macro makes the variable itself accessible through sysfs.\n2. **`type`**: The kernel's type tag for the parameter. Common types:\n   - `int`, `uint`, `long`, `ulong` â€” integer types\n   - `bool` â€” boolean (accepts `y`/`n`/`1`/`0`)\n   - `charp` â€” char pointer (string, kernel allocates memory)\n   - `byte` â€” unsigned char\n3. **`permissions`**: The filesystem permission bits for the sysfs attribute. `0644` means owner can read/write, everyone else can read. Use `0` to make the parameter not appear in sysfs at all (load-time only). **Never use `0666`** â€” that lets any unprivileged user modify kernel state, which is a security vulnerability.\nAfter loading, the parameter appears at:\n```\n/sys/module/<module_name>/parameters/<parameter_name>\n```\nSo for our module:\n```bash\n# Load with non-default parameter\nsudo insmod hello.ko buffer_size=8192\n# Check current value\ncat /sys/module/hello/parameters/buffer_size\n# Output: 8192\n# If permissions allow writing, modify at runtime\necho 16384 | sudo tee /sys/module/hello/parameters/buffer_size\n```\nThe sysfs attribute is directly backed by the `buffer_size` variable â€” reading it returns the current value, and (if writable) writing it updates the variable in the running kernel. This is the same mechanism that exposes hardware topology under `/sys/class` and `/sys/bus` â€” module parameters are first-class sysfs citizens, not a special case.\n> **Design note**: Module parameters are a double-edged sword. They make modules flexible, but they add code paths that depend on runtime values rather than compile-time constants. A module that worked correctly with `buffer_size=4096` might behave pathologically with `buffer_size=0` or `buffer_size=INT_MAX` if you don't validate. Always validate parameters in your init function.\n---\n## The Module Metadata Flow\nLet's trace exactly how the `MODULE_LICENSE`, `MODULE_AUTHOR`, and `MODULE_DESCRIPTION` macros become visible in `modinfo` output.\n\n![Module Metadata: From Macros to ELF Sections to modinfo](./diagrams/diag-m1-modinfo-metadata.svg)\n\nThe macros expand to `__attribute__((section(\".modinfo\")))` annotated string arrays. For example, `MODULE_LICENSE(\"GPL\")` roughly expands to:\n```c\nstatic const char __UNIQUE_ID_license[] __attribute__((section(\".modinfo\"),used))\n    = \"license=GPL\";\n```\nThe Kbuild system also injects additional metadata into `.modinfo`: the kernel version the module was compiled against (`vermagic`), the module dependencies, and any `module_param` descriptions.\nWhen you run `modinfo hello.ko`, it reads the `.modinfo` ELF section and prints the key-value pairs:\n```\nfilename:       /path/to/hello.ko\nversion:        1.0\ndescription:    A minimal kernel module demonstrating load/unload lifecycle\nauthor:         Your Name\nlicense:        GPL\nsrcversion:     A3B2C1D4E5F6A7B8C9D0E1F\ndepends:        \nretpoline:      Y\nname:           hello\nvermagic:       6.8.0-47-generic SMP preempt mod_unload modversions\nparm:           buffer_size:Size of the device buffer in bytes (default: 4096) (int)\n```\nThe `vermagic` field is the kernel's version check mechanism: when `insmod` loads the `.ko`, the kernel compares the embedded `vermagic` string against the running kernel's own version string. If they don't match, loading fails with `disagrees about version of symbol module_layout`. This is the safety guard that prevents you from loading a module compiled against kernel 6.7 into a kernel running 6.8.\n---\n## The Complete Module: Putting It Together\nHere is the full module source with parameter validation and proper cleanup structure:\n```c\n// hello.c â€” Hello World kernel module with parameter\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/moduleparam.h>\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name <you@example.com>\");\nMODULE_DESCRIPTION(\"Hello World kernel module with buffer_size parameter\");\nMODULE_VERSION(\"1.0\");\n/* Module parameter: buffer size with default of 4096 bytes */\nstatic int buffer_size = 4096;\nmodule_param(buffer_size, int, 0644);\nMODULE_PARM_DESC(buffer_size, \"Size of the device buffer in bytes (default: 4096)\");\nstatic int __init hello_init(void)\n{\n    /* Validate the parameter before using it */\n    if (buffer_size <= 0 || buffer_size > (1024 * 1024)) {\n        printk(KERN_ERR \"hello: invalid buffer_size %d (must be 1 to 1048576)\\n\",\n               buffer_size);\n        return -EINVAL;\n    }\n    printk(KERN_INFO \"hello: module loaded, buffer_size=%d\\n\", buffer_size);\n    printk(KERN_INFO \"hello: parameter visible at \"\n           \"/sys/module/hello/parameters/buffer_size\\n\");\n    return 0;  /* 0 = success; negative = failure */\n}\nstatic void __exit hello_exit(void)\n{\n    printk(KERN_INFO \"hello: module unloaded\\n\");\n}\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n```\n### Building It\n```bash\n# In the directory containing hello.c and Makefile:\nmake\n# Expected output (abbreviated):\n# make -C /lib/modules/6.8.0-47-generic/build M=/home/user/hello modules\n#   CC [M]  /home/user/hello/hello.o\n#   MODPOST /home/user/hello/Module.symvers\n#   CC [M]  /home/user/hello/hello.mod.o\n#   LD [M]  /home/user/hello/hello.ko\n```\nThe build produces several files, but `hello.ko` is the one you load. The `.mod.c` file is auto-generated by Kbuild and contains metadata; `.symvers` records the symbols your module references and their CRC values (used for module versioning checks).\n### Loading and Verifying\n```bash\n# Load the module\nsudo insmod hello.ko\n# Verify it's loaded\nlsmod | grep hello\n# Output: hello    16384  0\n# Check dmesg for init message\ndmesg | tail -3\n# [12345.678901] hello: module loaded, buffer_size=4096\n# [12345.678923] hello: parameter visible at /sys/module/hello/parameters/buffer_size\n# Check module metadata\nmodinfo hello.ko\n# Check parameter in sysfs\ncat /sys/module/hello/parameters/buffer_size\n# 4096\n# Load with custom parameter\nsudo rmmod hello\nsudo insmod hello.ko buffer_size=8192\ncat /sys/module/hello/parameters/buffer_size\n# 8192\n# Unload\nsudo rmmod hello\ndmesg | tail -1\n# [12367.891234] hello: module unloaded\n```\n### The Verification Script\nA repeatable verification script is better than manual commands:\n```bash\n#!/bin/bash\n# verify.sh â€” automated load/unload verification for hello module\nset -e\nMODULE_NAME=\"hello\"\nKO_FILE=\"./hello.ko\"\necho \"[1] Building module...\"\nmake -s\necho \"[2] Checking modinfo metadata...\"\nmodinfo \"$KO_FILE\" | grep -E \"^(license|author|description|parm):\"\n# Verify GPL license, author, description, and parameter are present\necho \"[3] Loading module with default parameter...\"\nsudo insmod \"$KO_FILE\"\necho \"[4] Verifying module is listed in lsmod...\"\nlsmod | grep -q \"$MODULE_NAME\" && echo \"  PASS: module visible in lsmod\"\necho \"[5] Verifying init message in dmesg...\"\ndmesg | tail -5 | grep -q \"${MODULE_NAME}: module loaded\" && \\\n    echo \"  PASS: init message in dmesg\"\necho \"[6] Verifying parameter in /sys...\"\nPARAM_PATH=\"/sys/module/${MODULE_NAME}/parameters/buffer_size\"\n[ -f \"$PARAM_PATH\" ] && echo \"  PASS: parameter file exists\"\ncat \"$PARAM_PATH\" | grep -q \"4096\" && echo \"  PASS: default value is 4096\"\necho \"[7] Unloading module...\"\nsudo rmmod \"$MODULE_NAME\"\necho \"[8] Verifying exit message in dmesg...\"\ndmesg | tail -3 | grep -q \"${MODULE_NAME}: module unloaded\" && \\\n    echo \"  PASS: exit message in dmesg\"\necho \"[9] Loading with custom parameter...\"\nsudo insmod \"$KO_FILE\" buffer_size=8192\ncat \"$PARAM_PATH\" | grep -q \"8192\" && echo \"  PASS: custom parameter accepted\"\nsudo rmmod \"$MODULE_NAME\"\necho \"\"\necho \"All checks passed.\"\n```\n---\n## Common Pitfalls and Their Consequences\nThis section covers the mistakes that will cost you time â€” and in some cases, machine reboots.\n### Missing `MODULE_LICENSE(\"GPL\")` â€” Tainted Kernel, Missing Symbols\nIf you omit `MODULE_LICENSE`, the kernel marks itself as \"tainted\" upon loading your module and prints a warning:\n```\nhello: module license 'unspecified' taints kernel.\nDisabling lock debugging due to kernel taint\n```\nBeyond the warning, any `EXPORT_SYMBOL_GPL` symbol your module tries to use will fail to resolve at load time:\n```\nhello: Unknown symbol __alloc_pages (err -13)\ninsmod: ERROR: could not insert module hello.ko: Unknown symbol in module\n```\n### Mismatched Kernel Headers â€” Silent ABI Corruption\nBuilding against `linux-headers-6.7.x` and loading into a `6.8.x` kernel (or vice versa) will fail with the `vermagic` check in most cases. But if someone bypasses this check (with `insmod --force`), they invite silent struct layout mismatches. Always use `uname -r` in your Makefile to ensure you build against the right headers.\n### `printk` Without Log Level â€” Invisible Messages\n```c\nprintk(\"hello: this might be invisible\\n\");  // BAD: no log level\n```\nWithout a log level prefix, the message defaults to `KERN_DEFAULT`, which maps to the kernel's default message level. If the current console log level is lower than the message level, the message won't appear on the console (though it's still in the ring buffer). Always specify a log level.\n### Module Parameter Permissions `0666` â€” Security Vulnerability\n```c\nmodule_param(buffer_size, int, 0666);  // BAD: world-writable\n```\nThis allows any unprivileged user to `echo 0 > /sys/module/hello/parameters/buffer_size` and potentially put the module into an invalid state. Use `0644` (owner write, world read) or `0444` (world read, no write) for most parameters.\n### Returning Positive Value From `module_init` â€” Undefined Behavior\n```c\nstatic int __init hello_init(void)\n{\n    return 1;  // BAD: positive return from init\n}\n```\nThe convention is strict: `0` for success, negative `errno` code for failure. Positive values are not a valid success indicator and will confuse the kernel's module loader.\n### Failing to Compile With `-Werror`\nThe kernel's Kbuild system can be configured to treat warnings as errors. If you're developing on a system where this isn't the default, enable it explicitly to catch issues early. In your Makefile:\n```makefile\nccflags-y := -Werror\n```\nA warning-free build is a requirement for any kernel code that might be submitted upstream, and it's a good discipline even for local modules. Warnings in kernel code are frequently indicators of real bugs, not style issues.\n---\n## Three-Level View: What Happens During `insmod`\nWhen you run `sudo insmod hello.ko`, more happens than just \"the kernel loads your module.\" Here's the full picture:\n**Level 1 â€” User Command**:\n`insmod` reads `hello.ko` into memory, calls the `init_module()` system call (or the newer `finit_module()` with a file descriptor), passing the raw ELF data to the kernel.\n**Level 2 â€” Kernel Module Loader**:\nThe kernel's `load_module()` function (in `kernel/module/main.c`) performs these steps:\n1. Validates the ELF header and sections\n2. Allocates executable memory for the module using the module allocator (backed by `vmalloc`-range memory on most architectures)\n3. Copies code and data sections to the allocated memory\n4. Applies relocations â€” fills in the addresses of kernel symbols your module references (e.g., resolves `printk` to its actual kernel address)\n5. Verifies `vermagic` and (if CONFIG_MODVERSIONS) CRC checksums for each symbol\n6. Checks that `MODULE_LICENSE` doesn't taint for GPL-only symbols needed\n7. Calls your `module_init` function in the context of the `insmod` process\n8. If init returns 0: adds module to the kernel's module list, makes it visible in `/proc/modules` and `lsmod`\n9. If init returns non-zero: frees the module memory, propagates error to `insmod`\n**Level 3 â€” Hardware**:\nThe module code and data land in the **kernel's virtual address space** â€” on x86_64, this is the upper half of the 64-bit address space (above `0xffff800000000000` approximately, depending on KASLR). The CPU's page tables are updated to map these new pages as **kernel-mode executable** â€” setting the `U/S` bit to 0 (supervisor-only) and `NX` bit to 0 (executable). Any attempt by userspace code to access these addresses triggers a page fault and kills the process. Any bug in your module code that causes a fault in these pages triggers a kernel oops.\n---\n## Knowledge Cascade: What You've Just Unlocked\nCompleting this milestone doesn't just teach you how to write \"Hello World\" in the kernel. It unlocks a constellation of related concepts:\n**â†’ ELF Section Mechanics (same domain)**: The `__init`, `__exit`, and `.modinfo` annotations you used are instances of a general ELF mechanism â€” placing data in named sections. The linker script that produces `vmlinux` (the kernel binary) uses the same mechanism to organize init callbacks, exception tables, and system call tables. When you later encounter `__attribute__((section(\".data.once\")))` or similar in kernel source, you'll recognize the pattern.\n**â†’ Symbol Export and GPL Enforcement (cross-domain: licensing meets ABI)**: The fact that `MODULE_LICENSE(\"GPL\")` *technically controls API access* â€” not just as a legal statement but as a runtime enforcement mechanism â€” is a fascinating intersection of intellectual property policy and systems design. The kernel uses `EXPORT_SYMBOL` vs `EXPORT_SYMBOL_GPL` as a technical implementation of the GPL's copyleft requirement. This is the same design philosophy as \"capabilities\" in security: enforcement at the technical layer, not just the policy layer.\n**â†’ sysfs as Universal Control Plane (cross-domain: same pattern as Prometheus)**: The `/sys/module/<name>/parameters/` interface you just created is an instance of the sysfs virtual filesystem â€” a tree of kernel objects exposed as files. The same infrastructure exposes CPU frequency scaling under `/sys/devices/system/cpu/`, USB device properties under `/sys/bus/usb/`, and block device queue parameters under `/sys/block/<dev>/queue/`. When you look at a Kubernetes node's `/sys` tree or a Prometheus node exporter scraping hardware metrics, they're reading the same virtual files you just learned to write. The mental model â€” \"make kernel state accessible as filesystem entries\" â€” is one of Linux's most powerful design patterns.\n**â†’ printk Ring Buffer â†’ You're Building a Character Device (forward)**: The `dmesg` command reads `/dev/kmsg`, which is a character device. The ring buffer architecture â€” a fixed-size circular buffer in kernel memory, with a reader that advances through it â€” is structurally identical to what you'll implement in Milestone 2. When you implement your `read` file operation and manage a `buf_pos` offset, you're implementing the same mechanism that `dmesg` uses to read the printk ring buffer.\n**â†’ Module Parameters â†’ Kernel Configuration Philosophy**: The sysfs-backed parameter you created is a micro-example of the kernel's general configuration philosophy: separate the policy (what values mean) from the mechanism (how they're stored and accessed). The same philosophy appears in the kernel's `sysctl` interface (`/proc/sys/`), in device tree overlays, and in runtime kernel configuration via `kconfig`. Knowing one, you understand the pattern behind all of them.\n---\n## Acceptance Criteria Checkpoint\nBefore moving to Milestone 2, verify:\n- [ ] `make` completes without warnings using Kbuild against the running kernel headers\n- [ ] `modinfo hello.ko` shows `license: GPL`, `author:`, `description:`, and `parm: buffer_size`\n- [ ] `sudo insmod hello.ko` succeeds and `dmesg | tail` shows the init message with `KERN_INFO`\n- [ ] `lsmod | grep hello` shows the module as loaded\n- [ ] `/sys/module/hello/parameters/buffer_size` exists and reads `4096`\n- [ ] `sudo insmod hello.ko buffer_size=8192` produces `8192` in the sysfs attribute\n- [ ] `sudo insmod hello.ko buffer_size=-1` returns an error (init validates and returns `-EINVAL`)\n- [ ] `sudo rmmod hello` succeeds and `dmesg | tail` shows the exit message\n- [ ] `make` with `ccflags-y := -Werror` produces zero warnings\nIf any of these fail, use `dmesg -w` in a separate terminal while running `insmod`/`rmmod` to see kernel messages in real time. If `insmod` fails with \"Operation not permitted\", you need `sudo`. If it fails with \"File exists\", the module is already loaded â€” run `rmmod` first.\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-kernel-module-m2 -->\n<!-- MS_ID: build-kernel-module-m2 -->\n# Milestone 2: Character Device Driver\n## The Revelation: User Pointers Are Traps\nYou've just loaded a kernel module. Now a process is going to call `write(fd, buf, 4096)` and your driver needs to receive those 4096 bytes. The user hands you a pointer. Why can't you just do this?\n```c\n/* THIS IS WRONG. DO NOT DO THIS. */\nstatic ssize_t mydev_write(struct file *filp, const char __user *buf,\n                           size_t count, loff_t *f_pos)\n{\n    memcpy(kernel_buffer, buf, count);  /* â† WRONG: direct dereference of user pointer */\n    return count;\n}\n```\nYour instinct says: \"The kernel can access *all* memory â€” it's in ring 0, it has the highest privilege. If the user gives me a pointer to their buffer at address `0x7fff1234`, I can just read from `0x7fff1234`.\"\nThis instinct is half right and fully dangerous. The kernel *can* access that address in a mechanical sense â€” the CPU won't fault on privilege. But consider what happens when:\n1. The user passes a **completely bogus pointer**: `write(fd, (void*)0xdeadbeef, 100)`. There's no page mapped at `0xdeadbeef` in the user's page tables. A direct `memcpy` from `0xdeadbeef` generates a page fault. In userspace, a page fault in process context just delivers SIGSEGV. But this page fault happens *in kernel context* â€” during your driver's write handler â€” and it kills the kernel.\n2. The user passes a **pointer to a memory-mapped device register** and your driver blindly reads from it. Now you've let a userspace program trigger arbitrary hardware I/O through your driver.\n3. The user passes a **valid pointer at the moment of the call**, but the page gets swapped out between your check and your copy. Classic TOCTOU â€” time-of-check/time-of-use race condition.\n4. A 32-bit process running on a 64-bit kernel passes a pointer that looks valid but falls in the kernel's own address space. Direct dereference now reads kernel memory on behalf of a userspace program.\nThe solution is `copy_from_user()` and `copy_to_user()`. But these functions don't solve the problem by *checking* the pointer first and then copying. They solve it by **installing a temporary exception handler before the copy**. Here's the real mechanism:\n\n![copy_from_user / copy_to_user: Exception Table Mechanism](./diagrams/diag-m2-copy-user-mechanism.svg)\n\nThe kernel maintains an **exception table** â€” a sorted array of `(faulting_address, fixup_address)` pairs in a `.ex_table` ELF section. The assembly code inside `copy_from_user()` is annotated so that every load instruction has a corresponding entry in this table. When a page fault occurs anywhere in the kernel:\n1. The page fault handler checks: *is this fault address in the exception table?*\n2. If yes: instead of panicking, it jumps to the `fixup_address` â€” a small stub that sets the return value to indicate failure, zeroes the destination buffer, and returns gracefully.\n3. If no: it's an unexpected kernel bug â€” oops/panic.\nThis means `copy_from_user()` is a **trap-and-recover** mechanism, not a check-then-copy mechanism. The copy proceeds optimistically. If it faults, the kernel recovers cleanly and returns `-EFAULT` to your driver, which returns `-EFAULT` to the user process. The kernel never crashes. The user process gets an error code and continues (or not â€” their choice).\n\nThis is one of the most important pieces of kernel API design you'll encounter. Every single data transfer path in your driver â€” now and forever â€” goes through `copy_from_user` or `copy_to_user`. There are no exceptions. Not for \"trusted\" programs. Not for root processes. Not for \"small\" copies. The exception table mechanism exists to guarantee that even hostile or buggy userspace cannot crash the kernel through your driver.\n---\n## The Architecture Before the Code\nBefore writing a single line, you need to see the full picture of what you're building.\n\n![Device Registration: From alloc_chrdev_region to /dev/ Node](./diagrams/diag-m2-major-minor-registration.svg)\n\nWhen a userspace program opens `/dev/mydevice`, a chain of kernel machinery fires:\n1. The VFS (Virtual File System â€” the kernel's unified interface over all filesystems and device files) looks at the device file's inode.\n2. The inode contains a **device number** (`dev_t`) â€” a 32-bit integer encoding two values: the **major number** (identifies the driver) and the **minor number** (identifies which instance of that driver).\n3. The kernel looks up the major number in a character device table, finds your `cdev` structure, and calls your `.open` function pointer.\n4. From there, every `read()`, `write()`, `ioctl()`, and `close()` on that file descriptor routes through the function pointers in your `file_operations` struct.\n[[EXPLAIN:major/minor-numbers-and-the-vfs-layer|Major/minor numbers and the VFS layer]]\nThis dispatch chain â€” from system call number to your function â€” is the VFS vtable pattern:\n\n![file_operations: The Kernel's Virtual Method Table](./diagrams/diag-m2-file-operations-vtable.svg)\n\n\n> **ðŸ”‘ Foundation: The file_operations vtable pattern**\n> \n> **What it IS**\nThe `struct file_operations` is a dispatch table (or Virtual Method Table) used by the Linux kernel to implement polymorphism in C. It is a structure filled with function pointersâ€”such as `.read`, `.write`, `.open`, and `.release`â€”that link generic system calls to your specific driverâ€™s implementation. When a userspace program calls `read()` on a file descriptor, the kernel looks up the `file_operations` struct associated with that file and executes the function pointed to by the `.read` member.\n\n**WHY you need it right now**\nIn a character device driver, this is your primary interface. The kernel treats \"everything as a file,\" but the kernel doesn't know what \"reading\" means for your specific hardware or virtual device. You must fill this struct to map standard POSIX API calls to your custom logic. Without it, your device exists in the system but remains unreachable and non-functional to userspace.\n\n**ONE key insight or mental model**\nThink of the `file_operations` struct as a **Contract**: The kernel provides the \"Interface\" (the names of the functions), and you provide the \"Implementation\" (the actual logic). It decouples the VFS (Virtual File System) from the hardware-specific details.\n\nThe `struct file_operations` is the kernel's equivalent of a C++ vtable or a Go interface: a struct of function pointers where each pointer implements one operation. Your driver fills in the ones it cares about; the ones left `NULL` get default behavior (or return `-ENOSYS` for \"not implemented\").\n---\n## How `write(2)` Becomes Your Function\nLet's trace the full path from a userspace `write()` call to your driver's write handler. This path demystifies why the function signatures look the way they do.\n\n![The Full Path: write(fd, buf, n) â†’ Your Driver's Write Handler](./diagrams/diag-m2-syscall-to-driver.svg)\n\n```\nUser Process                 Kernel                          Your Driver\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nwrite(fd, buf, n)\n  â”‚\n  â”‚  (syscall instruction\n  â”‚   triggers privilege\n  â”‚   elevation to ring 0)\n  â”‚\n  â–¼\nsys_write(fd, buf, n)        â† kernel entry point\n  â”‚\n  â–¼\nksys_write(fd, buf, n)\n  â”‚  looks up fd in\n  â”‚  current->files->fdt\n  â”‚  finds struct file *f\n  â–¼\nvfs_write(f, buf, n, &f->f_pos)\n  â”‚\n  â–¼\nf->f_op->write(f, buf, n, &f->f_pos)  â† vtable dispatch\n                                                â”‚\n                                                â–¼\n                                       mydev_write(filp, buf, n, f_pos)\n                                                â”‚\n                                                â–¼\n                                       copy_from_user(kernel_buf, buf, n)\n```\n**The function signature is dictated by this call chain.** Your write handler receives:\n- `struct file *filp` â€” the kernel's representation of the open file; carries state like `f_pos`, `f_flags`, and a pointer to your device-private data\n- `const char __user *buf` â€” the userspace buffer address (annotated with `__user` to help Sparse, the kernel's static analysis tool, catch direct dereferences)\n- `size_t count` â€” bytes requested\n- `loff_t *f_pos` â€” pointer to the file position; you update this in read to advance the position\nThe `__user` annotation is parsed by **Sparse** (the kernel's static checker, invoked with `make C=1`). It doesn't affect compiled code, but Sparse will warn if you pass a `__user`-annotated pointer to a function expecting a kernel pointer (like `memcpy`). This turns potential runtime crashes into compile-time warnings.\n---\n## Device Numbers: Dynamic Allocation\nIn the early days of Unix, device major numbers were statically assigned. The kernel source file `Documentation/admin-guide/devices.txt` lists these historical allocations â€” major 1 is `mem` (for `/dev/null`, `/dev/zero`, etc.), major 4 is `tty`, major 8 is SCSI disk. There are only 4096 major numbers, and they were running out.\nModern practice: **always use dynamic allocation**. The kernel picks an unused major number at load time:\n```c\nstatic dev_t dev_num;           /* will hold our major+minor after allocation */\nstatic struct cdev my_cdev;     /* kernel's char device structure */\nstatic struct class *my_class;  /* for automatic /dev/ node creation */\n/* In module_init: */\nret = alloc_chrdev_region(&dev_num, 0, 1, \"mydevice\");\n/*                         ^         ^  ^   ^\n *                         |         |  |   device name in /proc/devices\n *                         |         |  number of minors to reserve\n *                         |         first minor number\n *                         output: dev_t with major+minor                */\nif (ret < 0) {\n    printk(KERN_ERR \"mydev: failed to allocate device number: %d\\n\", ret);\n    return ret;\n}\nprintk(KERN_INFO \"mydev: allocated major=%d, minor=%d\\n\",\n       MAJOR(dev_num), MINOR(dev_num));\n```\n`MAJOR(dev_num)` and `MINOR(dev_num)` are macros that extract the respective fields from the 32-bit `dev_t`. The encoding on Linux: top 12 bits are major, bottom 20 bits are minor. `MKDEV(major, minor)` constructs a `dev_t` from components.\nAfter this call succeeds, you've reserved a device number. The device doesn't exist yet â€” there's no `cdev` connected, no `/dev/` node. You've just claimed the number. You can verify it:\n```bash\ngrep mydevice /proc/devices\n# Output: 240 mydevice\n# (240 is an example; actual number varies)\n```\n**Critical cleanup rule**: every successful `alloc_chrdev_region()` must be paired with `unregister_chrdev_region()` in your exit path and error paths. The kernel does *not* automatically reclaim device numbers when a module exits without cleanup.\n---\n## The `cdev` Structure: Connecting Numbers to Operations\nAllocating a number isn't enough. You need to tell the kernel: \"when something opens the device with this number, use *these* file operations.\" That's the job of `struct cdev`:\n```c\nstatic const struct file_operations mydev_fops = {\n    .owner   = THIS_MODULE,\n    .open    = mydev_open,\n    .release = mydev_release,\n    .read    = mydev_read,\n    .write   = mydev_write,\n};\n/* In module_init, after alloc_chrdev_region: */\ncdev_init(&my_cdev, &mydev_fops);\nmy_cdev.owner = THIS_MODULE;\nret = cdev_add(&my_cdev, dev_num, 1);\n/*              ^          ^       ^\n *              cdev       dev_t   number of minors this cdev handles */\nif (ret < 0) {\n    printk(KERN_ERR \"mydev: cdev_add failed: %d\\n\", ret);\n    goto err_cdev;\n}\n```\n`cdev_add()` makes the device **live** â€” from this point, if anything opens the device number, the kernel will dispatch to your `mydev_fops`. This is why error handling order matters: you don't want the device reachable before it's fully initialized.\nThe `.owner = THIS_MODULE` field prevents the module from being unloaded while the device has open file descriptors. `THIS_MODULE` is a pointer to the `struct module` that represents your module. The VFS increments the module's reference count when a file is opened and decrements it on close. If you omit `.owner`, `rmmod` can unload your module while a process still has an open file descriptor â€” the next `read()` call would jump to the now-unmapped function and crash the kernel.\n---\n## Automatic `/dev/` Nodes: class_create and device_create\nYou've allocated a number and registered a cdev. But there's still no `/dev/mydevice` file. In ancient times you'd run `mknod /dev/mydevice c 240 0` manually. Modern Linux uses **udev** â€” a userspace daemon that listens for hotplug events from the kernel and automatically creates device nodes.\n\n> **ðŸ”‘ Foundation: udev and the kernel uevent mechanism: how device_create triggers /dev/ node creation**\n> \n> **What it IS**\nThe kernel `uevent` mechanism is a notification system where the kernel broadcasts \"user events\" to userspace whenever a device state changes (e.g., a device is created, removed, or changed). `udev` is a userspace daemon that listens for these events via a netlink socket. When you call `device_create()` in your driver, the kernel sends a uevent; `udev` catches it, looks up its rules (usually in `/etc/udev/rules.d/`), and automatically creates a corresponding device node in the `/dev/` directory with the correct permissions.\n\n**WHY you need it right now**\nManually creating device files using the `mknod` command is error-prone and tedious. By using the `class_create()` and `device_create()` functions in your module, you trigger the uevent mechanism. This ensures that as soon as your module is loaded (`insmod`), the device file (e.g., `/dev/mydevice`) appears instantly and automatically for the user, and disappears when the module is unloaded.\n\n**ONE key insight or mental model**\nThe kernel is the **Broadcaster** and `udev` is the **Assistant**. The kernel shouts \"I've added a new device!\" into a megaphone, and `udev` hears it and quickly runs to the `/dev/` folder to put a new \"doorway\" (device node) there for userspace to use.\n\nThe kernel sends udev events through the **device model** â€” a hierarchical tree of `struct device` objects that represents all hardware and virtual devices in the system. `class_create()` and `device_create()` are your entry points into this system:\n```c\n/* Create a device class â€” appears as /sys/class/<name> */\nmy_class = class_create(THIS_MODULE, \"mydevice\");\nif (IS_ERR(my_class)) {\n    ret = PTR_ERR(my_class);\n    printk(KERN_ERR \"mydev: class_create failed: %d\\n\", ret);\n    goto err_class;\n}\n/* Create the device â€” triggers udev to create /dev/mydevice */\nmy_device = device_create(my_class, NULL, dev_num, NULL, \"mydevice\");\nif (IS_ERR(my_device)) {\n    ret = PTR_ERR(my_device);\n    printk(KERN_ERR \"mydev: device_create failed: %d\\n\", ret);\n    goto err_device;\n}\n```\n> **`IS_ERR()` and `PTR_ERR()` â€” kernel error pointers**: The kernel uses a trick where error codes are encoded as pointer values in the high portion of the address space. `IS_ERR(ptr)` checks if the pointer is actually an error code (a value between `-MAX_ERRNO` and 0, cast to a pointer). `PTR_ERR(ptr)` extracts the integer error code. This allows functions that return pointers to signal errors without a separate output parameter. You'll see this pattern everywhere in kernel code for functions that return `struct *`.\n`device_create()` registers a `struct device` in the kernel's device tree and emits a **uevent** with the device's class, major/minor numbers, and name. udev (or systemd-udevd) receives this event and creates `/dev/mydevice` with the correct major/minor and permissions. You can watch this happen:\n```bash\n# In one terminal, watch udev events:\nudevadm monitor --kernel --udev\n# In another terminal, load your module:\nsudo insmod mydevice.ko\n# You'll see: add /class/mydevice/mydevice (class)\n# And udev creates /dev/mydevice automatically\n```\n---\n## The Kernel Buffer: kmalloc and the SLAB Allocator\nYour device needs a place to store data. In userspace you'd call `malloc()`. In the kernel you call `kmalloc()`:\n```c\nstatic char *kernel_buffer;\nstatic size_t buffer_size_bytes = 4096;\n/* In module_init: */\nkernel_buffer = kzalloc(buffer_size_bytes, GFP_KERNEL);\n/*              ^         ^                ^\n *              zero-fills the allocation  |\n *              (k + zalloc = malloc+memset(0))\n *                            allocation size\n *                                         allocation flags */\nif (!kernel_buffer) {\n    printk(KERN_ERR \"mydev: failed to allocate kernel buffer\\n\");\n    ret = -ENOMEM;\n    goto err_buffer;\n}\n```\n\n![Kernel Buffer: kmalloc, SLAB Allocator, and Memory Layout](./diagrams/diag-m2-kernel-buffer-layout.svg)\n\n`kmalloc` draws from the **SLAB/SLUB allocator** â€” not a heap in the traditional sense.\n\n> **ðŸ”‘ Foundation: kmalloc and the SLAB/SLUB allocator: how kernel memory allocation differs from malloc**\n> \n> **What it IS**\n`kmalloc` is the kernel equivalent of userspace `malloc()`, used for allocating physically contiguous memory. Under the hood, it doesn't just grab raw pages; it uses the **SLAB** (or the more modern **SLUB**) allocator. This system manages \"caches\" of commonly used object sizes. Instead of constantly searching for free memory of arbitrary sizes, the SLUB allocator maintains lists of pre-allocated \"slabs\" (blocks of memory) divided into small, equal-sized \"slots.\"\n\n**WHY you need it right now**\nKernel memory is a finite, precious resource that cannot be \"swapped\" to disk like userspace memory. When you need to store driver state or buffers, you use `kmalloc`. However, you must specify a **GFP (Get Free Page) flag**: usually `GFP_KERNEL` (which can sleep if memory is tight) or `GFP_ATOMIC` (which cannot sleep, used inside interrupt handlers). Understanding that `kmalloc` is backed by the SLUB allocator helps you realize why it is highly efficient for small, frequent allocations but can fail if you request massive, contiguous chunks.\n\n**ONE key insight or mental model**\nThe SLUB allocator is like a **Bento Box shop**. Instead of cooking every meal from scratch (searching raw memory), they have pre-portioned boxes for 32-byte, 64-byte, and 128-byte meals. When you call `kmalloc(40)`, the kernel just hands you a 64-byte \"box\" because itâ€™s the fastest way to serve you.\n\nThe `GFP_KERNEL` flag is the most important argument to understand right now. GFP stands for \"Get Free Pages\" â€” it describes the allocation context. `GFP_KERNEL` means:\n- **Can sleep**: the allocator may block the current process if memory is scarce, waiting for pages to be freed or swapped out\n- **Can reclaim**: the kernel may try to free other caches to satisfy this allocation\n- **Can use all memory zones**: the allocator has access to all physical memory\nThis is correct for your `module_init` context â€” init runs in process context (the `insmod` process), so sleeping is fine.\n**The critical rule**: if you're ever in **interrupt context** (inside an interrupt handler) or holding a **spinlock** (a non-sleeping lock), you must use `GFP_ATOMIC` instead of `GFP_KERNEL`. `GFP_ATOMIC` cannot sleep, cannot reclaim, and may fail more often. Using `GFP_KERNEL` in atomic context causes the kernel to print a warning and potentially deadlock. For this milestone, you're only allocating in `module_init` where `GFP_KERNEL` is always correct.\n> **Hardware Soul â€” kmalloc memory placement**:\n> - `kmalloc` returns **physically contiguous** memory (pages from the buddy allocator, managed by SLAB/SLUB)\n> - This memory is in the **kernel's direct mapping** (on x86_64: the `0xffff888000000000` region, directly mapped to physical memory). This means kernel virtual address and physical address differ by a fixed offset â€” `virt_to_phys()` computes this.\n> - Your 4KB buffer fits in one page. For the L1 cache (typically 32KB, 8-way set-associative, 64-byte cache lines), a 4KB buffer occupies 64 cache lines and fits comfortably. Sequential access by your write/read handlers will be cache-friendly â€” hardware prefetcher will pull ahead as you access bytes in order.\n> - `kzalloc` (zero-filling variant) is marginally slower than `kmalloc` for the first use but ensures no data leakage from previously freed memory â€” a security property.\n---\n## Implementing `file_operations`: Open and Release\nNow for the actual file operations. Start with the simplest pair â€” open and release:\n```c\nstatic atomic_t open_count = ATOMIC_INIT(0);\nstatic int mydev_open(struct inode *inode, struct file *filp)\n{\n    atomic_inc(&open_count);\n    printk(KERN_INFO \"mydev: opened (count=%d)\\n\",\n           atomic_read(&open_count));\n    return 0;\n}\nstatic int mydev_release(struct inode *inode, struct file *filp)\n{\n    atomic_dec(&open_count);\n    printk(KERN_INFO \"mydev: released (count=%d)\\n\",\n           atomic_read(&open_count));\n    return 0;\n}\n```\nWhy `atomic_t` instead of a plain `int`? Because `open` and `release` can be called concurrently from multiple processes. Incrementing a plain integer is a read-modify-write operation â€” three machine instructions. Two CPUs doing it simultaneously can read the same value, both increment it to the same result, and write the same value back (both get `count+1` when the correct result is `count+2`). `atomic_inc` generates an atomic increment instruction (`lock xadd` on x86) that the CPU's bus lock makes indivisible.\n\n> **ðŸ”‘ Foundation: Linux atomic operations: atomic_t**\n> \n> **What it IS**\nAtomic operations are low-level instructions that are guaranteed to execute as a single, indivisible unit. The Linux kernel provides the `atomic_t` type (an opaque structure wrapping an integer) and functions like `atomic_inc()`, `atomic_dec()`, and `atomic_read()`. These use CPU-specific instructions (like `LOCK` prefixes on x86) to ensure that if two CPU cores try to increment the same variable simultaneously, one will strictly happen after the other, and no data will be lost.\n\n**WHY you need it right now**\nIn a multi-core kernel environment, a simple `i++` is dangerous. It involves three steps: read from memory, increment in register, write back to memory. If an interrupt occurs or another CPU accesses the variable mid-way, you get a \"race condition\" and corrupted data. In your driver, if you are counting how many processes have opened your device or tracking a shared resource, you must use `atomic_t` to ensure thread safety without the heavy performance overhead of a Mutex or Spinlock.\n\n**ONE key insight or mental model**\nAn atomic operation is **Indivisible**. To the rest of the system, the variable jumps from `A` to `B` instantly; there is no \"middle\" state where the variable is being processed, making it immune to being interrupted by other tasks.\n\n**`struct inode` vs `struct file`**: The inode represents the device file itself â€” it's shared between all processes and persists as long as the file exists. The `struct file` represents a single *open instance* â€” it's created fresh for each `open()` call and destroyed on the last `close()`. If three processes open `/dev/mydevice` simultaneously, they share one inode but have three distinct `struct file` instances. This is where `filp->f_pos` lives â€” per-file-descriptor, not per-device.\n**Private data pattern**: For more complex drivers, you'd store a pointer to your device-private struct in `filp->private_data` during open:\n```c\nstatic int mydev_open(struct inode *inode, struct file *filp)\n{\n    filp->private_data = &my_device_state;  /* accessible in read/write/ioctl */\n    atomic_inc(&open_count);\n    return 0;\n}\n```\nThis is crucial for drivers that manage multiple device instances â€” each minor number maps to a different device state, and you need to find the right one in your handlers.\n---\n## Implementing Write: copy_from_user in Practice\n```c\nstatic size_t buffer_used = 0;   /* bytes currently in the buffer */\nstatic ssize_t mydev_write(struct file *filp, const char __user *buf,\n                           size_t count, loff_t *f_pos)\n{\n    size_t space_available;\n    size_t bytes_to_copy;\n    unsigned long not_copied;\n    /* How much space remains in the buffer? */\n    space_available = buffer_size_bytes - buffer_used;\n    if (space_available == 0)\n        return -ENOSPC;  /* buffer full */\n    /* Don't copy more than we have space for */\n    bytes_to_copy = min(count, space_available);\n    /*\n     * copy_from_user(to, from, n):\n     *   to   = kernel destination address\n     *   from = userspace source address (__user pointer)\n     *   n    = bytes to copy\n     *\n     * Returns: number of bytes NOT copied (0 on success).\n     * Non-zero means a fault occurred; return -EFAULT.\n     */\n    not_copied = copy_from_user(kernel_buffer + buffer_used, buf, bytes_to_copy);\n    if (not_copied != 0) {\n        /*\n         * Partial copy: some bytes got through before the fault.\n         * We must account for the bytes that DID make it.\n         * bytes_copied = bytes_to_copy - not_copied\n         *\n         * But for simplicity in this milestone, treat any copy failure\n         * as -EFAULT. More complex drivers handle partial copies.\n         */\n        return -EFAULT;\n    }\n    buffer_used += bytes_to_copy;\n    /* Note: we do NOT update *f_pos here.\n     * Write position tracking in this device uses buffer_used, not f_pos.\n     * f_pos is updated by the VFS for regular files; for character devices\n     * the semantics are driver-defined. */\n    printk(KERN_DEBUG \"mydev: write %zu bytes (buffer now %zu/%zu)\\n\",\n           bytes_to_copy, buffer_used, buffer_size_bytes);\n    return bytes_to_copy;  /* return number of bytes accepted */\n}\n```\n**Return value semantics for write handlers**:\n- Positive: bytes successfully written. The VFS may call your handler again if the user requested more than you returned.\n- `0`: nothing written but no error (unusual for write, but valid for non-blocking when buffer is full â€” we'll use `-ENOSPC` here for clarity)\n- Negative: error code. `-EFAULT` for bad user pointer. `-ENOSPC` for no space. `-EINTR` for interrupted. The error propagates to the userspace `write()` return value.\n**`min()` vs `min_t()`**: The kernel defines `min(a, b)` as a type-safe macro that warns if `a` and `b` have different types. If you're comparing values of different types (say `size_t` and `ssize_t`), use `min_t(type, a, b)` to specify the comparison type explicitly. Mismatched signed/unsigned comparisons are a source of subtle bugs (a negative `ssize_t` compared to a `size_t` compares as very large, not negative).\n---\n## Implementing Read: f_pos Tracking and the EOF Contract\nThe read handler is where developers most often make the mistake of returning wrong values and creating infinite loops. Let's understand why this happens before writing the code.\n\n![f_pos Tracking: Why cat Terminates But Naive Reads Loop Forever](./diagrams/diag-m2-fpos-read-behavior.svg)\n\nWhen you run `cat /dev/mydevice`, `cat` calls `read(fd, buf, BUFSIZ)` in a loop until it gets a return value of `0` (EOF). This is the universal Unix contract: **read returns 0 to signal end of file, not an error**. \nIf your read handler always returns a positive number (even 1 byte), `cat` will loop forever, generating an infinite stream of whatever data you return. This is the most common read handler bug in beginner kernel modules.\nThe `f_pos` (file position) tracks how far into the \"file\" the reader has consumed. For your character device, it's tracking how far into `kernel_buffer` the current reader has gotten:\n```c\nstatic ssize_t mydev_read(struct file *filp, char __user *buf,\n                          size_t count, loff_t *f_pos)\n{\n    size_t bytes_available;\n    size_t bytes_to_copy;\n    unsigned long not_copied;\n    /*\n     * *f_pos is the current read position within the buffer.\n     * If f_pos >= buffer_used, the reader has consumed all data: EOF.\n     */\n    if (*f_pos >= buffer_used)\n        return 0;  /* EOF: no more data â€” cat and read() loops terminate here */\n    /* How many unread bytes remain? */\n    bytes_available = buffer_used - *f_pos;\n    /* Give the caller at most 'count' bytes */\n    bytes_to_copy = min(count, bytes_available);\n    /*\n     * copy_to_user(to, from, n):\n     *   to   = userspace destination address (__user pointer)\n     *   from = kernel source address\n     *   n    = bytes to copy\n     *\n     * Returns: number of bytes NOT copied (0 on full success).\n     */\n    not_copied = copy_to_user(buf, kernel_buffer + *f_pos, bytes_to_copy);\n    if (not_copied != 0)\n        return -EFAULT;\n    /* Advance the file position by the number of bytes we copied */\n    *f_pos += bytes_to_copy;\n    printk(KERN_DEBUG \"mydev: read %zu bytes (f_pos now %lld/%zu)\\n\",\n           bytes_to_copy, *f_pos, buffer_used);\n    return bytes_to_copy;\n}\n```\n**The f_pos dance**:\n- `*f_pos` starts at 0 when the file is first opened\n- Each successful read advances `*f_pos` by the number of bytes returned\n- When `*f_pos == buffer_used`, the next read returns 0 (EOF)\n- After EOF, `cat` exits its read loop\n**Why `f_pos` is a pointer parameter**: The kernel stores `f_pos` in `filp->f_pos`. But for `pread()` (positional read), the VFS passes a *different* offset than `filp->f_pos` â€” it passes the caller's requested offset directly, without modifying the file's stored position. By taking a `loff_t *f_pos` parameter, your handler works correctly for both `read()` and `pread()` without modification.\n**The \"two-process independence\" property**: If process A and process B both open `/dev/mydevice`, they get separate `struct file` instances, each with its own `f_pos`. Process A reading doesn't advance process B's position. This is the correct semantics â€” it mirrors how two processes reading the same regular file maintain independent positions.\n---\n## The Complete Device: Putting It All Together\nNow let's write the full, complete driver. This is the production-quality reference you'll build and verify:\n```c\n/* mydevice.c â€” Character device driver with read/write, f_pos tracking */\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>           /* file_operations, alloc_chrdev_region */\n#include <linux/cdev.h>         /* cdev_init, cdev_add */\n#include <linux/device.h>       /* class_create, device_create */\n#include <linux/uaccess.h>      /* copy_to_user, copy_from_user */\n#include <linux/slab.h>         /* kmalloc, kfree */\n#include <linux/atomic.h>       /* atomic_t */\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name <you@example.com>\");\nMODULE_DESCRIPTION(\"Character device driver: read/write with kernel buffer\");\nMODULE_VERSION(\"1.0\");\n/* â”€â”€â”€ Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n#define DEVICE_NAME     \"mydevice\"\n#define CLASS_NAME      \"mydevice_class\"\n#define BUFFER_SIZE     4096\n/* â”€â”€â”€ Module state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\nstatic dev_t         dev_num;           /* major + minor, set by alloc_chrdev_region */\nstatic struct cdev   my_cdev;           /* kernel char device structure              */\nstatic struct class *my_class;          /* device class for udev                     */\nstatic struct device *my_device;        /* device object                             */\nstatic char         *kernel_buffer;     /* 4KB buffer for data storage               */\nstatic size_t        buffer_used = 0;   /* bytes currently stored                    */\nstatic atomic_t      open_count  = ATOMIC_INIT(0);\n/* â”€â”€â”€ File Operations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\nstatic int mydev_open(struct inode *inode, struct file *filp)\n{\n    atomic_inc(&open_count);\n    printk(KERN_INFO \"mydev: open (count now %d)\\n\",\n           atomic_read(&open_count));\n    return 0;\n}\nstatic int mydev_release(struct inode *inode, struct file *filp)\n{\n    atomic_dec(&open_count);\n    printk(KERN_INFO \"mydev: release (count now %d)\\n\",\n           atomic_read(&open_count));\n    return 0;\n}\nstatic ssize_t mydev_read(struct file *filp, char __user *buf,\n                          size_t count, loff_t *f_pos)\n{\n    size_t bytes_available;\n    size_t bytes_to_copy;\n    unsigned long not_copied;\n    if (*f_pos >= buffer_used)\n        return 0;   /* EOF */\n    bytes_available = buffer_used - *f_pos;\n    bytes_to_copy   = min(count, bytes_available);\n    not_copied = copy_to_user(buf, kernel_buffer + *f_pos, bytes_to_copy);\n    if (not_copied != 0)\n        return -EFAULT;\n    *f_pos += bytes_to_copy;\n    return (ssize_t)bytes_to_copy;\n}\nstatic ssize_t mydev_write(struct file *filp, const char __user *buf,\n                           size_t count, loff_t *f_pos)\n{\n    size_t space_available;\n    size_t bytes_to_copy;\n    unsigned long not_copied;\n    space_available = BUFFER_SIZE - buffer_used;\n    if (space_available == 0)\n        return -ENOSPC;\n    bytes_to_copy = min(count, space_available);\n    not_copied = copy_from_user(kernel_buffer + buffer_used, buf, bytes_to_copy);\n    if (not_copied != 0)\n        return -EFAULT;\n    buffer_used += bytes_to_copy;\n    return (ssize_t)bytes_to_copy;\n}\nstatic const struct file_operations mydev_fops = {\n    .owner   = THIS_MODULE,\n    .open    = mydev_open,\n    .release = mydev_release,\n    .read    = mydev_read,\n    .write   = mydev_write,\n};\n/* â”€â”€â”€ Init / Exit â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n/*\n * Initialization uses goto-based error handling â€” the kernel idiom\n * for unwinding partial initialization in reverse order.\n *\n * Order of init:  buffer â†’ chrdev_region â†’ cdev â†’ class â†’ device\n * Order of cleanup (exit and error paths): reverse\n */\nstatic int __init mydev_init(void)\n{\n    int ret;\n    /* 1. Allocate kernel buffer */\n    kernel_buffer = kzalloc(BUFFER_SIZE, GFP_KERNEL);\n    if (!kernel_buffer) {\n        printk(KERN_ERR \"mydev: failed to allocate buffer\\n\");\n        return -ENOMEM;\n    }\n    /* 2. Reserve a character device number dynamically */\n    ret = alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        printk(KERN_ERR \"mydev: alloc_chrdev_region failed: %d\\n\", ret);\n        goto err_alloc_region;\n    }\n    printk(KERN_INFO \"mydev: registered major=%d minor=%d\\n\",\n           MAJOR(dev_num), MINOR(dev_num));\n    /* 3. Initialize and add the cdev */\n    cdev_init(&my_cdev, &mydev_fops);\n    my_cdev.owner = THIS_MODULE;\n    ret = cdev_add(&my_cdev, dev_num, 1);\n    if (ret < 0) {\n        printk(KERN_ERR \"mydev: cdev_add failed: %d\\n\", ret);\n        goto err_cdev_add;\n    }\n    /* 4. Create device class (appears in /sys/class/) */\n    my_class = class_create(THIS_MODULE, CLASS_NAME);\n    if (IS_ERR(my_class)) {\n        ret = PTR_ERR(my_class);\n        printk(KERN_ERR \"mydev: class_create failed: %d\\n\", ret);\n        goto err_class;\n    }\n    /* 5. Create device â€” triggers udev to create /dev/mydevice */\n    my_device = device_create(my_class, NULL, dev_num, NULL, DEVICE_NAME);\n    if (IS_ERR(my_device)) {\n        ret = PTR_ERR(my_device);\n        printk(KERN_ERR \"mydev: device_create failed: %d\\n\", ret);\n        goto err_device;\n    }\n    printk(KERN_INFO \"mydev: initialized â€” /dev/%s created\\n\", DEVICE_NAME);\n    return 0;\n    /* Error unwind â€” reverse order of init */\nerr_device:\n    class_destroy(my_class);\nerr_class:\n    cdev_del(&my_cdev);\nerr_cdev_add:\n    unregister_chrdev_region(dev_num, 1);\nerr_alloc_region:\n    kfree(kernel_buffer);\n    return ret;\n}\nstatic void __exit mydev_exit(void)\n{\n    device_destroy(my_class, dev_num);\n    class_destroy(my_class);\n    cdev_del(&my_cdev);\n    unregister_chrdev_region(dev_num, 1);\n    kfree(kernel_buffer);\n    printk(KERN_INFO \"mydev: exited cleanly\\n\");\n}\nmodule_init(mydev_init);\nmodule_exit(mydev_exit);\n```\n### The Goto Error Handling Pattern\nNotice the `goto` labels in `mydev_init`. This is not sloppy code â€” it is the **canonical kernel idiom** for error handling with multiple resources. The structure ensures that if step N fails, steps 1 through N-1 are cleaned up in reverse order. Without this, a failure in `class_create` would leak the cdev and device number.\nThe alternative â€” nested if-else chains â€” produces deeply indented, hard-to-read code. The goto pattern keeps the success path reading top-to-bottom, with the cleanup code separated at the bottom. Every experienced kernel developer uses this pattern. If you see a kernel function without it, that function probably has a resource leak.\n---\n## The Kbuild Makefile for This Module\n```makefile\n# Makefile\nobj-m += mydevice.o\nccflags-y := -Werror\nall:\n\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\nclean:\n\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\n```\n---\n## Verification: The echo/cat Round Trip\nBuild, load, and verify:\n```bash\n# Build\nmake\n# Load\nsudo insmod mydevice.ko\n# Verify device number and class\ngrep mydevice /proc/devices\n# Example: 240 mydevice\nls -la /dev/mydevice\n# crw------- 1 root root 240, 0 Mar 1 12:00 /dev/mydevice\n# Write data (echo appends a newline, so \"hello\\n\" = 6 bytes)\necho \"hello\" | sudo tee /dev/mydevice\n# Output: hello\n# Read data back\nsudo cat /dev/mydevice\n# Output: hello\n# Verify open_count via dmesg\ndmesg | tail -10\n# [  ...] mydev: open (count now 1)       â† from tee's open\n# [  ...] mydev: release (count now 0)    â† from tee's close\n# [  ...] mydev: open (count now 1)       â† from cat's open\n# [  ...] mydev: release (count now 0)    â† from cat's close\n# Unload\nsudo rmmod mydevice\n```\n**Why does `cat` terminate?** When `cat` opens the device, `*f_pos` starts at 0. The first `read()` call returns \"hello\\n\" (6 bytes) and advances `*f_pos` to 6. Since `buffer_used` is also 6, the second `read()` call hits `*f_pos >= buffer_used` and returns 0 (EOF). `cat` sees EOF and exits.\n**Why does a second `cat` read nothing?** After the first `cat` finishes, `buffer_used` is still 6, but `*f_pos` for the *new* open is 0. So a second `cat` would read \"hello\\n\" again. The buffer persists until overwritten or the module is unloaded. This is the intended behavior for a simple device.\n---\n## Three-Level View: What Happens During `echo \"hello\" > /dev/mydevice`\n**Level 1 â€” Shell/Userspace**:\nThe shell forks, execs `echo`, which writes `\"hello\\n\"` (6 bytes) to stdout. The shell has already redirected stdout to `/dev/mydevice` via `open(\"/dev/mydevice\", O_WRONLY)`. The `write(fd, \"hello\\n\", 6)` syscall fires.\n**Level 2 â€” Kernel/VFS**:\n`sys_write` â†’ `ksys_write` â†’ `vfs_write`. VFS looks up the `struct file` for `fd`, retrieves `f->f_op->write`, which is your `mydev_write`. Your handler runs in the context of the `echo` process. `copy_from_user` copies the 6 bytes from the `echo` process's stack (where `\"hello\\n\"` lives) into `kernel_buffer`. The exception table ensures that if `echo`'s mapping disappears mid-copy, the kernel recovers with `-EFAULT`.\n**Level 3 â€” Hardware**:\nThe copy involves two TLB lookups: one for the userspace source address (in `echo`'s page tables) and one for the kernel destination address (in the direct-mapped region). The CPU's hardware page walker traverses the page table hierarchy for the user address. The 6 bytes fit in a single 64-byte cache line. The copy itself is handled by optimized CPU instructions in the `copy_from_user` implementation â€” on x86_64, this uses `rep movsb` or SIMD instructions depending on size. The kernel buffer's cache line is brought into L1/L2 cache dirty; it will be evicted to DRAM eventually but for read-back soon after, it's likely still hot.\n---\n## Common Pitfalls and Their Consequences\n### Direct Dereference of User Pointer\n```c\n/* WRONG â€” crashes kernel on bad pointer */\nmemcpy(kernel_buffer, buf, count);\n/* RIGHT â€” recovers gracefully */\nnot_copied = copy_from_user(kernel_buffer, buf, count);\nif (not_copied) return -EFAULT;\n```\nThe compiler won't catch this. The static checker Sparse will (`make C=1` during build). At runtime, a malicious or buggy program passing a bad pointer will kernel-panic without `copy_from_user`.\n### Returning Bytes Written Without Checking copy_from_user Return\n```c\n/* WRONG â€” ignores partial copy */\ncopy_from_user(kernel_buffer, buf, count);\nreturn count;   /* wrong: may have only copied count - not_copied bytes */\n/* RIGHT */\nnot_copied = copy_from_user(kernel_buffer, buf, count);\nif (not_copied) return -EFAULT;\nreturn count;\n```\n`copy_from_user` returns the number of bytes *not* copied â€” zero means full success. Treating a non-zero return as success tells the caller \"I wrote N bytes\" when you actually wrote fewer.\n### Not Returning 0 at EOF â€” Infinite read Loop\n```c\n/* WRONG â€” cat loops forever */\nstatic ssize_t mydev_read(struct file *filp, char __user *buf,\n                          size_t count, loff_t *f_pos)\n{\n    copy_to_user(buf, kernel_buffer, buffer_used);\n    return buffer_used;  /* never returns 0, cat never terminates */\n}\n/* RIGHT â€” returns 0 when f_pos reaches end */\nif (*f_pos >= buffer_used)\n    return 0;\n```\nThis is the single most common beginner read handler bug. If you ever find `cat /dev/yourdevice` hanging, this is why.\n### Not Updating `*f_pos` After Read\n```c\n/* WRONG â€” f_pos never advances, infinite loop of same data */\n*f_pos = 0;   /* or just not updating it */\n/* RIGHT */\n*f_pos += bytes_to_copy;\n```\nWithout advancing `f_pos`, every read call returns the same data from the same offset. `cat` sees a non-zero return value forever.\n### Forgetting Cleanup in Reverse Order\n```c\n/* WRONG â€” unregister before destroy leaves dangling references */\nunregister_chrdev_region(dev_num, 1);  /* removes device number */\ndevice_destroy(my_class, dev_num);     /* tries to use the now-gone number */\n/* RIGHT â€” destroy in reverse order of creation */\ndevice_destroy(my_class, dev_num);\nclass_destroy(my_class);\ncdev_del(&my_cdev);\nunregister_chrdev_region(dev_num, 1);\nkfree(kernel_buffer);\n```\nOut-of-order cleanup causes use-after-free in kernel data structures. The kernel may not crash immediately â€” the corruption may surface later as a mysterious oops in unrelated code.\n### Missing `.owner = THIS_MODULE` in file_operations\n```c\n/* WRONG â€” module can be unloaded while device is open */\nstatic const struct file_operations mydev_fops = {\n    .open    = mydev_open,\n    .read    = mydev_read,\n    /* .owner missing */\n};\n/* RIGHT */\nstatic const struct file_operations mydev_fops = {\n    .owner   = THIS_MODULE,  /* prevents rmmod while files are open */\n    .open    = mydev_open,\n    .read    = mydev_read,\n};\n```\nWithout `.owner`, `rmmod` succeeds while a process has the device open. The next `read()` jumps to a now-freed code address â€” instant kernel panic.\n---\n## Knowledge Cascade: What You've Just Unlocked\n**â†’ VFS Dispatch Pattern = Interfaces Everywhere (cross-domain)**:\nThe `file_operations` vtable you just filled in is the kernel's implementation of dynamic dispatch â€” the same pattern as C++ virtual methods, Go interfaces, and Rust trait objects. The call `f->f_op->read(filp, buf, count, f_pos)` is structurally identical to a C++ `virtual void read()` call that dispatches through a vtable pointer. When you next see a Go interface dispatch, a Rust `dyn Trait`, or a Java abstract class, you're looking at the same solution to the same problem: *dispatch to the right implementation at runtime without knowing the concrete type at compile time*. The kernel's vtable approach is the primordial form.\n**â†’ f_pos and pread/pwrite Atomicity (same domain, forward)**:\nThe fact that `f_pos` is per-`struct file` (not per-inode) is *why* `pread(fd, buf, n, offset)` and `pwrite` exist. `pread` passes a separate offset without modifying `filp->f_pos`, allowing concurrent reads from different offsets without races â€” databases use `pread` exclusively for this reason. SQLite, PostgreSQL, RocksDB all call `pread` into their data files. The character device mechanism you just built is the same mechanism enabling atomic positioned I/O at scale.\n**â†’ udev Hotplug = Universal Device Discovery (cross-domain)**:\n`device_create()` sending a uevent is the same mechanism that fires when you plug in a USB drive and `/dev/sdb` appears, or when the kernel probes a PCIe device at boot and `/dev/nvme0n1` materializes. Android's `vold` (volume daemon), systemd-udevd, and the kernel's own `kobject_uevent` are all operating the same infrastructure. You've just written code that participates in Linux's universal device discovery protocol.\n**â†’ Exception Table = Speculative Execution Safety Net (same domain)**:\nThe `.ex_table` mechanism behind `copy_from_user` is conceptually related to how CPUs handle speculative execution faults: execute optimistically, recover if something goes wrong. The x86 `#GP` and `#PF` exception handlers consult the exception table the same way a CPU's microcode consults its own internal fault tables. More practically: this same mechanism powers `get_user()`, `put_user()`, and the `__copy_*` family â€” understanding it means you understand the safety foundation of the entire kernel-userspace boundary.\n**â†’ kmalloc to Slab Allocator to Memory Pressure (forward)**:\nThe `kzalloc(4096, GFP_KERNEL)` call you made is trivial here, but it connects to one of the most important kernel subsystems: the memory reclaim path. Under memory pressure, `GFP_KERNEL` allocations can block while `kswapd` runs, pages are writeback to swap, slab caches are shrunk, and the OOM killer considers victims. In Milestone 3, when you add an ioctl for runtime buffer resize, you'll call `kfree` and `kmalloc` while the device is live â€” a perfect opportunity to think about what happens if the resize allocation fails at a moment when memory is under pressure.\n**â†’ This Is /dev/null (structural equivalence)**:\n`/dev/null`'s write handler is `return count` â€” accept all bytes, store nothing. Its read handler is `return 0` â€” always EOF. Your device is more capable. `/dev/zero`'s read handler fills the user buffer with zeros via `clear_user()` (a `copy_to_user` variant for zero-fill). `/dev/random` and `/dev/urandom` read from an entropy pool. The architecture is identical to what you just built â€” the only difference is what the read and write handlers actually do with the data.\n---\n## Acceptance Criteria Checkpoint\nBefore moving to Milestone 3, verify every item:\n- [ ] `make` completes without warnings (`ccflags-y := -Werror` active)\n- [ ] `sudo insmod mydevice.ko` succeeds; `dmesg | tail` shows `registered major=<N> minor=0`\n- [ ] `grep mydevice /proc/devices` shows the major number\n- [ ] `ls -la /dev/mydevice` shows the device node (created by udev, no manual `mknod`)\n- [ ] `ls /sys/class/mydevice_class/` shows the device entry\n- [ ] `echo \"hello\" | sudo tee /dev/mydevice` succeeds with output `hello`\n- [ ] `sudo cat /dev/mydevice` outputs `hello` and terminates (no infinite loop)\n- [ ] A second `sudo cat /dev/mydevice` also outputs `hello` (buffer persists between opens)\n- [ ] `dmesg` shows open count increment and decrement for each `tee` and `cat` invocation\n- [ ] Test with a malicious pointer: verify `-EFAULT` is returned and kernel does not panic\n- [ ] `sudo rmmod mydevice` succeeds; `dmesg` shows clean exit message\n- [ ] `/dev/mydevice` is removed after rmmod (udev responds to the remove uevent)\n- [ ] `make C=1` (Sparse check) produces no warnings about `__user` annotation violations\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-kernel-module-m3 -->\n# Milestone 3: ioctl and /proc Interface\n## The Revelation: ioctl Is a Binary Protocol, Not a Switch Statement\nYou've built a character device that can read and write data. Now a process wants to *control* that device â€” resize its buffer, clear its contents, query its statistics. Your first instinct: add another write command with a special prefix. Write `\"RESIZE:8192\\n\"` to the device and parse it in the write handler.\nThis approach is used in production. Redis parses text commands over a socket. HTTP parses method strings. But it has a cost: you're multiplexing control and data through the same channel, which means your write handler now needs to answer \"is this a data write or a control command?\" before it can do anything. You've contaminated the data plane with control logic.\nUnix solved this problem in 1971 with `ioctl` â€” *input/output control*. The name is old; the insight is permanent. `ioctl` is a **separate system call** specifically for out-of-band device control, completely independent of the read/write data path. When a process calls `ioctl(fd, MYDEV_RESIZE, &new_size)`, it bypasses the VFS data path entirely and routes to your `unlocked_ioctl` handler with a structured command number and an argument.\nHere's where developers go wrong: they treat the command number as an arbitrary integer. They write `#define CMD_RESIZE 1`, `#define CMD_CLEAR 2`, and implement a `switch(cmd)` statement. This works â€” until it doesn't.\n**The problem with raw integers**: `ioctl(fd, 1, &new_size)` â€” is `1` a resize command for your driver? Or is it a terminal control command meant for the TTY layer? The kernel's ioctl dispatch has no way to know. If your device wraps another device (a common pattern), the wrong driver might handle the wrong commands. Worse, `strace` will display your ioctl calls as `ioctl(3, 0x1, 0x7fff...)` â€” completely opaque.\nThe solution is that **ioctl command numbers are encoded 32-bit values** â€” a binary protocol, not an enum. Every bit field has meaning:\n\n![ioctl Command Number Bit Encoding](./diagrams/diag-m3-ioctl-command-encoding.svg)\n\n```\n 31      16 15     8 7       2 1 0\n â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”\n â”‚   NR    â”‚  TYPE  â”‚  SIZE   â”‚DIRâ”‚\n â”‚(cmd seq)â”‚(magic) â”‚(arg sz) â”‚   â”‚\n â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”˜\n  bits 31:16  15:8    13:2     1:0\nDIR (bits 1:0):\n  00 = _IO   (no argument)\n  01 = _IOW  (userspace â†’ kernel, write to kernel)\n  10 = _IOR  (kernel â†’ userspace, read from kernel)\n  11 = _IOWR (bidirectional)\nTYPE (bits 15:8): your unique magic number (e.g., 'M' = 0x4D)\nNR (bits 31:16): sequential command number (0, 1, 2, ...)\nSIZE (bits 13:2): sizeof(argument type), max 256 bytes\n```\n[[EXPLAIN:ioctl-command-number-encoding-(_iow/_ior-direction,-type,-nr,-size)|ioctl command number encoding (_IOW/_IOR direction, type, nr, size)]]\nThe four macros that construct these values:\n```c\n_IO(type, nr)              /* no argument */\n_IOW(type, nr, argtype)    /* userspace writes TO kernel: ioctl(fd, cmd, &data) passes data in */\n_IOR(type, nr, argtype)    /* kernel writes TO userspace: ioctl(fd, cmd, &data) fills data out */\n_IOWR(type, nr, argtype)   /* bidirectional */\n```\nEach macro encodes the direction bits, your magic number, the command sequence number, and `sizeof(argtype)` into a single 32-bit constant. `_IOW('M', 0, int)` and `_IOW('N', 0, int)` produce *different* 32-bit values â€” a command from a different driver with a different magic number will never accidentally match yours.\nThis encoding exists because:\n1. **`strace` decodes it symbolically**: with the right header, `strace` translates `ioctl(3, MYDEV_RESIZE, 0x7fff12340)` instead of `ioctl(3, 0xc0044d00, 0x7fff12340)`.\n2. **The kernel can validate direction and size**: before your handler runs, the ioctl infrastructure knows whether the argument is incoming data, outgoing data, or both â€” and how large it is.\n3. **Collision prevention**: your magic number namespaces your commands. `Documentation/userspace-api/ioctl/ioctl-number.rst` in the kernel tree is a registry of allocated magic numbers. Pick one that's not taken.\nNow let's build it.\n---\n## The Architecture: Control Plane Meets Data Plane\nBefore writing code, look at the full picture of what you're adding to your existing driver.\n\n![Control Plane vs Data Plane: read/write vs ioctl](./diagrams/diag-m3-ioctl-vs-read-write.svg)\n\nYour device now has two distinct interfaces:\n- **Data plane** (`read`/`write`): streams of bytes through the kernel buffer â€” the pipe\n- **Control plane** (`ioctl`): structured commands that change device behavior â€” the remote control\nThis separation isn't arbitrary. It mirrors the same pattern across the entire systems stack:\n> TCP has a data stream (`send`/`recv`) and out-of-band control (socket options via `setsockopt`). HTTP has a body and headers. gRPC has streaming RPCs and unary control calls. Your character device has `read`/`write` and `ioctl`. The architectural pattern is identical: keep structured control commands out of the data stream so both can be reasoned about independently.\nThe `/proc` entry you're adding is a third interface â€” **introspection**. It's read-only, always human-readable, and doesn't affect device state. It's the observability window into your driver's internals.\n\n![ioctl Dispatch: From Userspace ioctl() to Your Handler](./diagrams/diag-m3-ioctl-dispatch-flow.svg)\n\n---\n## The Shared Header: One Definition, Two Worlds\nThe fundamental challenge of ioctl design is that the command definitions must be **identical** in kernel code and userspace code. If the kernel defines `MYDEV_RESIZE` as `0xc0044d00` and userspace computes `0xc0084d00` (because someone changed the argument size), the ioctl call silently fails â€” or worse, passes but transfers the wrong number of bytes.\nThe solution: a single header file included by both.\n\n![Shared Header: One Definition, Two Worlds](./diagrams/diag-m3-shared-header.svg)\n\n```c\n/* mydevice_ioctl.h â€” shared between kernel module and userspace programs\n *\n * This file defines the ioctl interface for mydevice. It is the ABI contract:\n * once userspace programs link against these definitions, changing them\n * breaks binary compatibility.\n *\n * Include guards prevent double-inclusion in both environments.\n */\n#ifndef MYDEVICE_IOCTL_H\n#define MYDEVICE_IOCTL_H\n/* Guard against kernel-only headers when this file is included by userspace */\n#ifdef __KERNEL__\n#  include <linux/ioctl.h>     /* _IOW, _IOR, _IOWR macros */\n#  include <linux/types.h>     /* __u32, __u64, etc. */\n#else\n#  include <sys/ioctl.h>       /* userspace ioctl definitions */\n#  include <stdint.h>\n   typedef uint32_t __u32;\n   typedef uint64_t __u64;\n#endif\n/*\n * Magic number: uniquely identifies this driver's ioctl namespace.\n * 'M' (0x4D) is used here for illustration.\n * In production: check Documentation/userspace-api/ioctl/ioctl-number.rst\n * and pick an unregistered value.\n */\n#define MYDEV_MAGIC  'M'\n/*\n * Argument struct for status query.\n * This struct is part of the ABI: fields CANNOT be reordered or removed\n * without breaking userspace programs that compiled against this header.\n */\nstruct mydev_status {\n    __u32 buffer_size;    /* total allocated buffer size in bytes */\n    __u32 bytes_used;     /* bytes currently stored in buffer     */\n    __u32 open_count;     /* number of processes with device open */\n    __u32 read_count;     /* total number of successful reads     */\n    __u32 write_count;    /* total number of successful writes    */\n    __u32 _reserved;      /* explicit padding for future use      */\n};\n/*\n * ioctl command definitions.\n *\n * MYDEV_CLEAR:  _IO  â€” no argument; clears buffer contents\n * MYDEV_RESIZE: _IOW â€” userspace sends new size (uint32); kernel resizes buffer\n * MYDEV_STATUS: _IOR â€” kernel fills struct mydev_status; userspace reads it\n */\n#define MYDEV_CLEAR   _IO(MYDEV_MAGIC,  0)\n#define MYDEV_RESIZE  _IOW(MYDEV_MAGIC, 1, __u32)\n#define MYDEV_STATUS  _IOR(MYDEV_MAGIC, 2, struct mydev_status)\n#endif /* MYDEVICE_IOCTL_H */\n```\nStudy this header carefully. Every design choice is deliberate:\n**`__u32` instead of `uint32_t` or `unsigned int`**: On different architectures and compilation environments, `unsigned int` might be 16 or 32 bits. `__u32` is guaranteed 32-bit everywhere in Linux kernel headers. In userspace, we typedef it to `uint32_t` from `<stdint.h>` which has the same guarantee. The header conditionally provides whichever definition is appropriate.\n**`__KERNEL__` guard**: The Kbuild system defines `__KERNEL__` when compiling kernel code. Userspace compilers don't define it. This lets you use one file in both contexts: the kernel side gets `<linux/ioctl.h>` (kernel macros), the userspace side gets `<sys/ioctl.h>` (POSIX definitions). The underlying math is the same â€” the macros produce identical bit patterns.\n**`_reserved` in `mydev_status`**: ABI stability practice. If you later add a field, you can replace `_reserved` instead of growing the struct (which would break the size encoding in `_IOR`). Explicit padding documents that you thought about future extensibility.\n**The ABI contract**: Once `mydev_status` is released and userspace programs link against it, the **layout of this struct is frozen**. The kernel's guarantee of stable userspace ABI means that a userspace binary compiled against this header in 2026 must still work with a kernel driver in 2036 â€” even if the driver's internal representation changes. This is why the kernel's internal structs change freely (they're not ABI) but the ioctl structs in public headers do not. This is the same concern that makes Protocol Buffer field numbers immutable and that governs JSON API versioning.\n---\n## Implementing `unlocked_ioctl`\nAdd the ioctl handler to your driver. First, add the new fields to your device state:\n```c\n/* Additional state in the kernel module â€” add to module-level globals */\nstatic atomic_t read_count  = ATOMIC_INIT(0);\nstatic atomic_t write_count = ATOMIC_INIT(0);\n```\nNow the ioctl handler:\n```c\n#include \"mydevice_ioctl.h\"   /* shared definitions */\n#include <linux/uaccess.h>    /* copy_from_user, copy_to_user */\n#include <linux/slab.h>       /* kmalloc, kfree */\nstatic long mydev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n    int ret = 0;\n    /*\n     * Validate the magic number before processing any command.\n     *\n     * _IOC_TYPE(cmd) extracts bits [15:8] â€” the magic number.\n     * If it doesn't match MYDEV_MAGIC, this command wasn't meant for us.\n     * Return -ENOTTY: \"inappropriate ioctl for device\" â€” the POSIX standard\n     * error for an unsupported ioctl command. NOT -EINVAL, NOT -ENOENT.\n     * Tools like strace rely on -ENOTTY to identify unsupported commands.\n     */\n    if (_IOC_TYPE(cmd) != MYDEV_MAGIC)\n        return -ENOTTY;\n    /*\n     * Validate the command number is within our range.\n     * _IOC_NR(cmd) extracts bits [31:16] â€” the sequence number.\n     * We've defined commands 0, 1, 2; reject anything above 2.\n     */\n    if (_IOC_NR(cmd) > 2)\n        return -ENOTTY;\n    switch (cmd) {\n    /* â”€â”€ MYDEV_CLEAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n    case MYDEV_CLEAR:\n        /*\n         * _IO: no argument. The 'arg' parameter is unused.\n         * Zero out the buffer contents and reset the usage counter.\n         *\n         * memset is safe here: kernel_buffer is a kernel pointer,\n         * memset operates only in kernel address space.\n         */\n        memset(kernel_buffer, 0, buffer_size_bytes);\n        buffer_used = 0;\n        printk(KERN_INFO \"mydev: ioctl CLEAR â€” buffer cleared\\n\");\n        break;\n    /* â”€â”€ MYDEV_RESIZE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n    case MYDEV_RESIZE: {\n        /*\n         * _IOW: userspace writes a __u32 to the kernel.\n         * 'arg' is the userspace address of the __u32 new size value.\n         * We must use copy_from_user to read it safely.\n         */\n        __u32 new_size;\n        char *new_buffer;\n        /*\n         * copy_from_user(kernel_dst, user_src, n)\n         * Copies n bytes from userspace address 'arg' into kernel variable 'new_size'.\n         * Returns bytes NOT copied; non-zero means fault â†’ -EFAULT.\n         */\n        if (copy_from_user(&new_size, (__u32 __user *)arg, sizeof(__u32)))\n            return -EFAULT;\n        /* Validate the requested size */\n        if (new_size == 0 || new_size > (1U << 20)) {  /* 0 to 1MB limit */\n            printk(KERN_WARNING \"mydev: ioctl RESIZE: invalid size %u\\n\", new_size);\n            return -EINVAL;\n        }\n        /*\n         * Allocate the new buffer before freeing the old one.\n         * This is the \"allocate-then-swap\" pattern: if the new allocation\n         * fails, we still have the old buffer intact â€” the device keeps working.\n         */\n        new_buffer = kzalloc(new_size, GFP_KERNEL);\n        if (!new_buffer)\n            return -ENOMEM;\n        /*\n         * If new_size is smaller than current content, we must truncate.\n         * Copy only min(buffer_used, new_size) bytes to preserve existing data.\n         */\n        if (buffer_used > new_size) {\n            printk(KERN_WARNING \"mydev: RESIZE truncating %zu bytes to %u\\n\",\n                   buffer_used, new_size);\n            buffer_used = new_size;\n        }\n        memcpy(new_buffer, kernel_buffer, buffer_used);\n        /* Swap: free old, install new */\n        kfree(kernel_buffer);\n        kernel_buffer     = new_buffer;\n        buffer_size_bytes = new_size;\n        printk(KERN_INFO \"mydev: ioctl RESIZE â€” buffer resized to %u bytes\\n\", new_size);\n        break;\n    }\n    /* â”€â”€ MYDEV_STATUS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n    case MYDEV_STATUS: {\n        /*\n         * _IOR: kernel writes a struct mydev_status TO userspace.\n         * 'arg' is the userspace address where we should write the struct.\n         */\n        struct mydev_status status;\n        /* Fill the status struct from current device state */\n        status.buffer_size = (u32)buffer_size_bytes;\n        status.bytes_used  = (u32)buffer_used;\n        status.open_count  = (u32)atomic_read(&open_count);\n        status.read_count  = (u32)atomic_read(&read_count);\n        status.write_count = (u32)atomic_read(&write_count);\n        status._reserved   = 0;\n        /*\n         * copy_to_user(user_dst, kernel_src, n)\n         * Copies n bytes from kernel struct 'status' to userspace address 'arg'.\n         * Returns bytes NOT copied; non-zero â†’ -EFAULT.\n         */\n        if (copy_to_user((struct mydev_status __user *)arg,\n                         &status, sizeof(struct mydev_status)))\n            return -EFAULT;\n        break;\n    }\n    default:\n        /*\n         * This should not be reached if the magic number and NR checks\n         * above are correct. But defensive programming demands a default.\n         */\n        return -ENOTTY;\n    }\n    return ret;\n}\n```\nRegister this handler in your `file_operations` struct:\n```c\nstatic const struct file_operations mydev_fops = {\n    .owner          = THIS_MODULE,\n    .open           = mydev_open,\n    .release        = mydev_release,\n    .read           = mydev_read,\n    .write          = mydev_write,\n    .unlocked_ioctl = mydev_ioctl,   /* â† add this */\n};\n```\n### Why `unlocked_ioctl`, not `ioctl`?\nIf you look at older kernel code (pre-2.6.36), you'll see a `.ioctl` field in `file_operations`. This has been removed. The historical `.ioctl` handler was called with the **Big Kernel Lock** (BKL) held â€” a global mutex that serialized all ioctl calls across the entire kernel. The BKL was a performance disaster removed in Linux 2.6.39.\n`unlocked_ioctl` means \"your ioctl handler, without any BKL.\" You are responsible for your own locking (which we'll add in Milestone 4). For a single-buffer device, the operations in our three commands are simple enough that races are benign for now â€” but we'll tighten this in the concurrency milestone.\nThere's also `.compat_ioctl` â€” called when a 32-bit process runs on a 64-bit kernel and makes an ioctl call. Pointer sizes differ between 32-bit and 64-bit, so struct layouts may differ. For our `mydev_status` (all `__u32` fields), layout is identical across architectures. If you had 64-bit fields or pointers in your struct, you'd need `.compat_ioctl` to handle the translation.\n### The `-ENOTTY` Contract\nThe choice of `-ENOTTY` for unknown commands is not arbitrary â€” it's the POSIX-mandated error for \"this ioctl is not applicable to this file descriptor.\" The name comes from \"not a TTY\" â€” the first `ioctl` commands were TTY-specific, so the error for \"wrong device type\" was named for the original use case. Today it means \"this device doesn't support that command.\" Using `-EINVAL` instead (as many drivers do incorrectly) is technically wrong per POSIX and confuses tools that inspect ioctl return codes.\n---\n## Validating Direction and Size Before Your Handler Runs\nThe `_IOC_DIR` and `_IOC_SIZE` fields in the encoded command number enable a useful pre-validation pattern. Before dispatching to your `switch`, you can verify that the userspace pointer is valid for the expected access:\n```c\n/*\n * Optional but recommended: verify userspace pointer accessibility\n * based on the encoded direction and size.\n *\n * access_ok(addr, size) returns true if the address range [addr, addr+size)\n * is a valid userspace address. It does NOT guarantee the pages are present\n * (copy_from_user handles faults), but it catches obvious errors like\n * kernel addresses passed as userspace pointers.\n */\nif (_IOC_DIR(cmd) & _IOC_READ) {\n    /* Kernel will READ from user â€” user buffer must be writable by us */\n    if (!access_ok((void __user *)arg, _IOC_SIZE(cmd)))\n        return -EFAULT;\n}\nif (_IOC_DIR(cmd) & _IOC_WRITE) {\n    /* Kernel will WRITE from user â€” user buffer must be readable by us */\n    if (!access_ok((void __user *)arg, _IOC_SIZE(cmd)))\n        return -EFAULT;\n}\n```\n> **Note on direction naming confusion**: The `_IOC_READ` and `_IOC_WRITE` bits in the command number describe the **userspace perspective**. `_IOC_READ` means \"userspace is reading from the kernel\" â€” which means the kernel writes to the user buffer. This is the _IOR direction. `_IOC_WRITE` means \"userspace is writing to the kernel\" â€” the _IOW direction. This reversal from the kernel's perspective trips up many developers. When in doubt, think from the userspace side.\n`access_ok()` is a fast, architecture-specific check that verifies the address doesn't fall in kernel space. On x86_64, it checks that `arg + size <= TASK_SIZE_MAX` (the upper bound of user address space). Note that modern kernels (5.x+) have simplified `access_ok` â€” it no longer takes a type parameter (it was `access_ok(VERIFY_READ, addr, size)` in older kernels). Update your code for the kernel version you're targeting.\n---\n## The `/proc` Entry: Runtime Introspection\nWhile ioctl gives processes *control* over the device, `/proc` gives *humans* (and monitoring tools) a window into the device's runtime state. The key insight:\n> `/proc` entries don't exist on disk. When you `cat /proc/mydevice`, the kernel calls your function to generate the content on-the-fly. The file system is a user interface metaphor, not actual storage.\nThis is the virtual filesystem trick: the same VFS that dispatches `open`/`read` on real files dispatches them on `/proc` entries â€” but instead of reading from disk, it calls a kernel function. `cat /proc/cpuinfo` doesn't read a file; it calls a function that queries each CPU's registers and formats the result as text. You're now building the same mechanism.\n### The Problem with Raw proc Callbacks\nBefore `seq_file` existed, drivers implemented a `.read_proc` callback that was handed a `char *page` buffer and had to write into it. This was simple â€” until the data exceeded one page (4KB). A `/proc` entry with more than 4KB of content had to implement complex offset tracking manually. Most drivers got it wrong: they'd return the same content on every read (infinite loop) or miss content on reads that started mid-page.\n\n> **ðŸ”‘ Foundation: seq_file abstraction and iterator pattern**\n> \n> ### What it IS\nThe `seq_file` API is a standard Linux kernel abstraction designed to simplify the creation of virtual files (typically found in `/proc` or `/sys`) that output sequences of data. When a user-space program reads a file, the kernel must provide data in chunks. If the data is a long listâ€”such as a list of all active network connections or loaded modulesâ€”managing the buffer offsets, multi-page reads, and partial transfers manually is complex and error-prone.\n\nThe `seq_file` interface uses the **Iterator Pattern**. It hides the \"plumbing\" of the filesystem (offsets, buffer sizes, and `read()` syscall mechanics) and asks the developer to provide only four functional callbacks:\n1.  **`start`**: Move to the beginning of the sequence or a specific position.\n2.  **`next`**: Move to the next item in the sequence.\n3.  **`show`**: Format the current item into the output buffer (usually using `seq_printf`).\n4.  **`stop`**: Clean up after the sequence is finished.\n\n### WHY the reader needs it right now\nIf you are writing a kernel module that needs to \"leak\" information to user spaceâ€”like a list of custom device states or a debugging logâ€”you shouldn't use the raw `file_operations.read` handler. Doing so requires you to track how many bytes the user has already read and handle cases where a single record is split across two separate `read()` calls.\n\nBy using `seq_file`, you focus entirely on your data structure (e.g., a linked list or an array). The kernel handles the \"bookkeeping\": it manages a temporary buffer, calls your `show` function until the buffer is full, stops, and resumes exactly where it left off when the user asks for more data. It ensures that even if a user-space tool like `cat` reads your 50KB list in 4KB chunks, the data remains consistent and the code remains simple.\n\n### ONE key insight or mental model\n**The \"Stateful Cursor\" Model.** \nThink of `seq_file` as a cursor moving through a database. You don't tell the kernel \"give me bytes 4096 to 8192 of this file.\" Instead, you tell the kernel, \"I am currently at item #50 in my list; show it, then increment the cursor to #51.\" \n\nThe `seq_file` layer translates the user's **byte-based requests** (e.g., \"I want the next 1KB\") into **object-based iterations** (e.g., \"Give me the next three items in your list\"). This decoupling ensures that you never have to worry about a \"partial print\" cutting an integer or a string in half between two system calls.\n\n`seq_file` solves this properly with an **iterator pattern**: your driver implements four functions (`start`, `next`, `stop`, `show`) that the seq_file infrastructure calls in a controlled loop, handling buffering, offset tracking, and partial reads correctly.\n\n![seq_file: The Iterator Behind /proc Reads](./diagrams/diag-m3-seq-file-iteration.svg)\n\nFor simple single-record `/proc` entries (like device statistics), you use an even simpler helper that wraps seq_file into a single-function interface.\n### Implementation\nAdd the proc implementation to your module:\n```c\n#include <linux/proc_fs.h>     /* proc_create, proc_remove */\n#include <linux/seq_file.h>    /* seq_file, seq_printf, single_open */\n#define PROC_NAME \"mydevice\"\n/*\n * seq_show: called by the seq_file infrastructure to generate content.\n *\n * For a single-record /proc entry (all data fits in one logical \"show\"),\n * single_open() wraps this into a minimal seq_file iterator:\n *   start() returns a non-NULL pointer (signaling \"data exists\")\n *   show()  calls this function to write content\n *   next()  returns NULL (only one record)\n *   stop()  does nothing\n *\n * seq_printf(m, fmt, ...) writes formatted text into the seq_file buffer.\n * It handles buffer management, overflow detection, and partial reads.\n * Never use sprintf or printk inside a seq_show function.\n */\nstatic int mydev_proc_show(struct seq_file *m, void *v)\n{\n    seq_printf(m, \"=== mydevice statistics ===\\n\");\n    seq_printf(m, \"buffer_size:  %zu bytes\\n\", buffer_size_bytes);\n    seq_printf(m, \"bytes_used:   %zu bytes\\n\", buffer_used);\n    seq_printf(m, \"open_count:   %d\\n\",       atomic_read(&open_count));\n    seq_printf(m, \"read_count:   %d\\n\",       atomic_read(&read_count));\n    seq_printf(m, \"write_count:  %d\\n\",       atomic_read(&write_count));\n    return 0;\n}\n/*\n * mydev_proc_open: called when a process opens /proc/mydevice.\n *\n * single_open(file, show_fn, data) sets up the seq_file machinery\n * with a one-shot iterator that calls mydev_proc_show exactly once.\n * The 'data' pointer is available as m->private inside show_fn.\n */\nstatic int mydev_proc_open(struct inode *inode, struct file *file)\n{\n    return single_open(file, mydev_proc_show, NULL);\n}\n/*\n * proc_fops: file operations for the /proc entry.\n *\n * We implement open with our wrapper, and delegate read, llseek,\n * and release to the seq_file infrastructure. These seq_* functions\n * know how to handle partial reads, seeks, and cleanup for seq_file.\n */\nstatic const struct proc_ops mydev_proc_ops = {\n    .proc_open    = mydev_proc_open,\n    .proc_read    = seq_read,      /* seq_file's read handler */\n    .proc_lseek   = seq_lseek,     /* seq_file's lseek handler */\n    .proc_release = single_release,/* cleans up single_open state */\n};\nstatic struct proc_dir_entry *proc_entry;\n```\n> **`proc_ops` vs `file_operations`**: In kernels 5.6+, `/proc` entries use `struct proc_ops` instead of `struct file_operations`. The fields are similar (`proc_open`, `proc_read`, etc.) but `proc_ops` omits some fields that don't apply to proc entries and uses different defaults. If your target kernel is older than 5.6, use `file_operations` with a `.owner = THIS_MODULE` field.\nRegister and remove the proc entry in your init/exit:\n```c\n/* In mydev_init, after device_create succeeds: */\nproc_entry = proc_create(PROC_NAME, 0444, NULL, &mydev_proc_ops);\n/*                        ^          ^     ^      ^\n *                        name       mode  parent  ops\n *\n * mode 0444: world-readable, nobody can write\n * parent NULL: create in /proc/ root\n * Returns NULL on failure (not IS_ERR â€” different error convention!) */\nif (!proc_entry) {\n    printk(KERN_ERR \"mydev: proc_create failed\\n\");\n    ret = -ENOMEM;\n    goto err_proc;\n}\nprintk(KERN_INFO \"mydev: /proc/%s created\\n\", PROC_NAME);\n/* Add to error unwind: */\nerr_proc:\n    device_destroy(my_class, dev_num);\n    /* ... rest of error chain ... */\n/* In mydev_exit, before device_destroy: */\nproc_remove(proc_entry);\n```\nNote the different error-checking convention for `proc_create`: it returns `NULL` on failure, not an `ERR_PTR()` value. You check `if (!proc_entry)`, not `if (IS_ERR(proc_entry))`. The kernel API is not perfectly consistent â€” this is one of those inconsistencies you have to memorize.\nNow wire up the read/write counters in your existing handlers:\n```c\nstatic ssize_t mydev_read(struct file *filp, char __user *buf,\n                          size_t count, loff_t *f_pos)\n{\n    /* ... existing read logic ... */\n    /* After a successful copy_to_user: */\n    atomic_inc(&read_count);\n    return (ssize_t)bytes_to_copy;\n}\nstatic ssize_t mydev_write(struct file *filp, const char __user *buf,\n                           size_t count, loff_t *f_pos)\n{\n    /* ... existing write logic ... */\n    /* After a successful copy_from_user: */\n    atomic_inc(&write_count);\n    return (ssize_t)bytes_to_copy;\n}\n```\n---\n## How seq_file Actually Works Under the Hood\nUnderstanding `seq_file` internally is worth a few minutes â€” it explains why it exists and why rolling your own offset tracking is a bad idea.\nWhen `cat /proc/mydevice` calls `read(fd, buf, 65536)`, the kernel calls your `proc_read` handler â€” which is `seq_read` from the seq_file library. Here's what seq_read does internally:\n```\nseq_read(filp, user_buf, count, f_pos):\n  1. If seq_file buffer is empty (first call or after exhaustion):\n       call start(m, &m->index)   â†’ get first record (or NULL if done)\n       if not NULL:\n         call show(m, record)     â†’ write content into m->buf\n         call next(m, record, &m->index)  â†’ advance to next record\n         loop until done or m->buf is full\n       call stop(m, record)\n  2. Copy min(m->buf used, count) bytes â†’ copy_to_user(user_buf, m->buf, ...)\n  3. If m->buf has remaining content: update f_pos, return bytes copied\n  4. If m->buf exhausted: return 0 (EOF)\n```\nFor `single_open`, the iterator is trivially simple: `start` returns a non-NULL dummy pointer once, `next` returns NULL immediately, `stop` does nothing. The `show` function (yours: `mydev_proc_show`) is called exactly once and writes all content. `seq_read` handles paging the output into userspace even if your output exceeds the kernel's internal buffer â€” it calls `start`/`show`/`next`/`stop` again from where it left off.\nThis is why `seq_printf` is safe to call with arbitrarily large output: the seq_file infrastructure handles the case where your content doesn't fit in one `read()` call by maintaining position state internally. A hand-rolled proc callback that writes to a fixed `page` buffer and returns would truncate silently.\n---\n## The Complete Updated Module\nHere is the full module combining Milestone 2's character device with Milestone 3's ioctl and proc additions. This is the reference implementation:\n```c\n/* mydevice.c â€” Character device with ioctl and /proc interface */\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include \"mydevice_ioctl.h\"    /* shared ioctl definitions */\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name <you@example.com>\");\nMODULE_DESCRIPTION(\"Character device: read/write, ioctl control, /proc introspection\");\nMODULE_VERSION(\"2.0\");\n/* â”€â”€â”€ Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n#define DEVICE_NAME  \"mydevice\"\n#define CLASS_NAME   \"mydevice_class\"\n#define PROC_NAME    \"mydevice\"\n/* â”€â”€â”€ Device State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\nstatic dev_t          dev_num;\nstatic struct cdev    my_cdev;\nstatic struct class  *my_class;\nstatic struct device *my_device;\nstatic struct proc_dir_entry *proc_entry;\nstatic char   *kernel_buffer;\nstatic size_t  buffer_size_bytes = 4096;\nstatic size_t  buffer_used       = 0;\nstatic atomic_t open_count  = ATOMIC_INIT(0);\nstatic atomic_t read_count  = ATOMIC_INIT(0);\nstatic atomic_t write_count = ATOMIC_INIT(0);\n/* â”€â”€â”€ File Operations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\nstatic int mydev_open(struct inode *inode, struct file *filp)\n{\n    atomic_inc(&open_count);\n    printk(KERN_INFO \"mydev: open (count=%d)\\n\", atomic_read(&open_count));\n    return 0;\n}\nstatic int mydev_release(struct inode *inode, struct file *filp)\n{\n    atomic_dec(&open_count);\n    printk(KERN_INFO \"mydev: release (count=%d)\\n\", atomic_read(&open_count));\n    return 0;\n}\nstatic ssize_t mydev_read(struct file *filp, char __user *buf,\n                          size_t count, loff_t *f_pos)\n{\n    size_t bytes_available, bytes_to_copy;\n    unsigned long not_copied;\n    if (*f_pos >= buffer_used)\n        return 0;  /* EOF */\n    bytes_available = buffer_used - *f_pos;\n    bytes_to_copy   = min(count, bytes_available);\n    not_copied = copy_to_user(buf, kernel_buffer + *f_pos, bytes_to_copy);\n    if (not_copied)\n        return -EFAULT;\n    *f_pos += bytes_to_copy;\n    atomic_inc(&read_count);\n    return (ssize_t)bytes_to_copy;\n}\nstatic ssize_t mydev_write(struct file *filp, const char __user *buf,\n                           size_t count, loff_t *f_pos)\n{\n    size_t space_available, bytes_to_copy;\n    unsigned long not_copied;\n    space_available = buffer_size_bytes - buffer_used;\n    if (space_available == 0)\n        return -ENOSPC;\n    bytes_to_copy = min(count, space_available);\n    not_copied = copy_from_user(kernel_buffer + buffer_used, buf, bytes_to_copy);\n    if (not_copied)\n        return -EFAULT;\n    buffer_used += bytes_to_copy;\n    atomic_inc(&write_count);\n    return (ssize_t)bytes_to_copy;\n}\nstatic long mydev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n    if (_IOC_TYPE(cmd) != MYDEV_MAGIC)\n        return -ENOTTY;\n    if (_IOC_NR(cmd) > 2)\n        return -ENOTTY;\n    switch (cmd) {\n    case MYDEV_CLEAR:\n        memset(kernel_buffer, 0, buffer_size_bytes);\n        buffer_used = 0;\n        printk(KERN_INFO \"mydev: ioctl CLEAR\\n\");\n        break;\n    case MYDEV_RESIZE: {\n        __u32 new_size;\n        char *new_buffer;\n        if (copy_from_user(&new_size, (__u32 __user *)arg, sizeof(__u32)))\n            return -EFAULT;\n        if (new_size == 0 || new_size > (1U << 20))\n            return -EINVAL;\n        new_buffer = kzalloc(new_size, GFP_KERNEL);\n        if (!new_buffer)\n            return -ENOMEM;\n        if (buffer_used > new_size)\n            buffer_used = new_size;\n        memcpy(new_buffer, kernel_buffer, buffer_used);\n        kfree(kernel_buffer);\n        kernel_buffer     = new_buffer;\n        buffer_size_bytes = new_size;\n        printk(KERN_INFO \"mydev: ioctl RESIZE to %u bytes\\n\", new_size);\n        break;\n    }\n    case MYDEV_STATUS: {\n        struct mydev_status status = {\n            .buffer_size = (__u32)buffer_size_bytes,\n            .bytes_used  = (__u32)buffer_used,\n            .open_count  = (__u32)atomic_read(&open_count),\n            .read_count  = (__u32)atomic_read(&read_count),\n            .write_count = (__u32)atomic_read(&write_count),\n            ._reserved   = 0,\n        };\n        if (copy_to_user((struct mydev_status __user *)arg,\n                         &status, sizeof(status)))\n            return -EFAULT;\n        break;\n    }\n    default:\n        return -ENOTTY;\n    }\n    return 0;\n}\n/* â”€â”€â”€ /proc Interface â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\nstatic int mydev_proc_show(struct seq_file *m, void *v)\n{\n    seq_printf(m, \"=== mydevice statistics ===\\n\");\n    seq_printf(m, \"buffer_size:  %zu bytes\\n\",   buffer_size_bytes);\n    seq_printf(m, \"bytes_used:   %zu bytes\\n\",   buffer_used);\n    seq_printf(m, \"open_count:   %d\\n\",           atomic_read(&open_count));\n    seq_printf(m, \"read_count:   %d\\n\",           atomic_read(&read_count));\n    seq_printf(m, \"write_count:  %d\\n\",           atomic_read(&write_count));\n    return 0;\n}\nstatic int mydev_proc_open(struct inode *inode, struct file *file)\n{\n    return single_open(file, mydev_proc_show, NULL);\n}\nstatic const struct proc_ops mydev_proc_ops = {\n    .proc_open    = mydev_proc_open,\n    .proc_read    = seq_read,\n    .proc_lseek   = seq_lseek,\n    .proc_release = single_release,\n};\n/* â”€â”€â”€ file_operations table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\nstatic const struct file_operations mydev_fops = {\n    .owner          = THIS_MODULE,\n    .open           = mydev_open,\n    .release        = mydev_release,\n    .read           = mydev_read,\n    .write          = mydev_write,\n    .unlocked_ioctl = mydev_ioctl,\n};\n/* â”€â”€â”€ Init / Exit â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\nstatic int __init mydev_init(void)\n{\n    int ret;\n    kernel_buffer = kzalloc(buffer_size_bytes, GFP_KERNEL);\n    if (!kernel_buffer) {\n        return -ENOMEM;\n    }\n    ret = alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        printk(KERN_ERR \"mydev: alloc_chrdev_region failed: %d\\n\", ret);\n        goto err_region;\n    }\n    cdev_init(&my_cdev, &mydev_fops);\n    my_cdev.owner = THIS_MODULE;\n    ret = cdev_add(&my_cdev, dev_num, 1);\n    if (ret < 0) {\n        printk(KERN_ERR \"mydev: cdev_add failed: %d\\n\", ret);\n        goto err_cdev;\n    }\n    my_class = class_create(THIS_MODULE, CLASS_NAME);\n    if (IS_ERR(my_class)) {\n        ret = PTR_ERR(my_class);\n        goto err_class;\n    }\n    my_device = device_create(my_class, NULL, dev_num, NULL, DEVICE_NAME);\n    if (IS_ERR(my_device)) {\n        ret = PTR_ERR(my_device);\n        goto err_device;\n    }\n    proc_entry = proc_create(PROC_NAME, 0444, NULL, &mydev_proc_ops);\n    if (!proc_entry) {\n        ret = -ENOMEM;\n        printk(KERN_ERR \"mydev: proc_create failed\\n\");\n        goto err_proc;\n    }\n    printk(KERN_INFO \"mydev: initialized â€” /dev/%s and /proc/%s created\\n\",\n           DEVICE_NAME, PROC_NAME);\n    return 0;\nerr_proc:\n    device_destroy(my_class, dev_num);\nerr_device:\n    class_destroy(my_class);\nerr_class:\n    cdev_del(&my_cdev);\nerr_cdev:\n    unregister_chrdev_region(dev_num, 1);\nerr_region:\n    kfree(kernel_buffer);\n    return ret;\n}\nstatic void __exit mydev_exit(void)\n{\n    proc_remove(proc_entry);\n    device_destroy(my_class, dev_num);\n    class_destroy(my_class);\n    cdev_del(&my_cdev);\n    unregister_chrdev_region(dev_num, 1);\n    kfree(kernel_buffer);\n    printk(KERN_INFO \"mydev: exited cleanly\\n\");\n}\nmodule_init(mydev_init);\nmodule_exit(mydev_exit);\n```\n---\n## The Userspace Test Program\nThe test program lives in userspace but includes the shared header. This is the duality that makes the shared header design essential:\n```c\n/* test_mydevice.c â€” Userspace test for ioctl and /proc interfaces */\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <errno.h>\n#include <string.h>\n/*\n * Include the shared header. The __KERNEL__ guard is NOT defined by\n * the userspace compiler (gcc/clang), so this pulls in sys/ioctl.h\n * and stdint.h on the userspace side.\n */\n#include \"mydevice_ioctl.h\"\n#define DEVICE_PATH \"/dev/mydevice\"\n#define PROC_PATH   \"/proc/mydevice\"\nstatic void print_separator(const char *label)\n{\n    printf(\"\\nâ”€â”€â”€â”€ %s â”€â”€â”€â”€\\n\", label);\n}\nstatic void read_proc(void)\n{\n    FILE *f = fopen(PROC_PATH, \"r\");\n    char line[256];\n    if (!f) {\n        perror(\"fopen /proc/mydevice\");\n        return;\n    }\n    printf(\"Content of %s:\\n\", PROC_PATH);\n    while (fgets(line, sizeof(line), f))\n        printf(\"  %s\", line);\n    fclose(f);\n}\nint main(void)\n{\n    int fd, ret;\n    /* Open the device */\n    fd = open(DEVICE_PATH, O_RDWR);\n    if (fd < 0) {\n        perror(\"open \" DEVICE_PATH);\n        return EXIT_FAILURE;\n    }\n    printf(\"Opened %s (fd=%d)\\n\", DEVICE_PATH, fd);\n    /* â”€â”€ Test 1: Write some data, check status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n    print_separator(\"Test 1: Write and STATUS ioctl\");\n    const char *msg = \"Hello from userspace!\";\n    ret = write(fd, msg, strlen(msg));\n    if (ret < 0) {\n        perror(\"write\");\n        goto out;\n    }\n    printf(\"Wrote %d bytes: \\\"%s\\\"\\n\", ret, msg);\n    struct mydev_status status;\n    /*\n     * MYDEV_STATUS is _IOR: kernel writes status TO us.\n     * We pass a pointer to our local struct; ioctl fills it.\n     */\n    ret = ioctl(fd, MYDEV_STATUS, &status);\n    if (ret < 0) {\n        perror(\"ioctl MYDEV_STATUS\");\n        goto out;\n    }\n    printf(\"Status: buffer_size=%u, bytes_used=%u, open_count=%u, \"\n           \"reads=%u, writes=%u\\n\",\n           status.buffer_size, status.bytes_used, status.open_count,\n           status.read_count, status.write_count);\n    /* â”€â”€ Test 2: CLEAR ioctl â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n    print_separator(\"Test 2: CLEAR ioctl\");\n    ret = ioctl(fd, MYDEV_CLEAR);\n    if (ret < 0) {\n        perror(\"ioctl MYDEV_CLEAR\");\n        goto out;\n    }\n    printf(\"Buffer cleared.\\n\");\n    ret = ioctl(fd, MYDEV_STATUS, &status);\n    if (ret < 0) { perror(\"ioctl MYDEV_STATUS\"); goto out; }\n    printf(\"After clear: bytes_used=%u (expected 0)\\n\", status.bytes_used);\n    /* â”€â”€ Test 3: RESIZE ioctl â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n    print_separator(\"Test 3: RESIZE ioctl\");\n    __u32 new_size = 8192;\n    /*\n     * MYDEV_RESIZE is _IOW: we write new_size TO the kernel.\n     * Pass pointer to new_size; ioctl copies it into the kernel.\n     */\n    ret = ioctl(fd, MYDEV_RESIZE, &new_size);\n    if (ret < 0) {\n        perror(\"ioctl MYDEV_RESIZE\");\n        goto out;\n    }\n    printf(\"Resized buffer to %u bytes.\\n\", new_size);\n    ret = ioctl(fd, MYDEV_STATUS, &status);\n    if (ret < 0) { perror(\"ioctl MYDEV_STATUS\"); goto out; }\n    printf(\"After resize: buffer_size=%u (expected 8192)\\n\", status.buffer_size);\n    /* â”€â”€ Test 4: Invalid ioctl returns -ENOTTY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n    print_separator(\"Test 4: Unknown ioctl â†’ ENOTTY\");\n    ret = ioctl(fd, _IO('Z', 99));  /* wrong magic number, unknown command */\n    if (ret < 0 && errno == ENOTTY)\n        printf(\"PASS: unknown ioctl returned ENOTTY (errno=%d)\\n\", errno);\n    else\n        printf(\"FAIL: expected ENOTTY, got ret=%d errno=%d\\n\", ret, errno);\n    /* â”€â”€ Test 5: Read /proc entry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n    print_separator(\"Test 5: /proc entry\");\n    read_proc();\nout:\n    close(fd);\n    return (ret < 0) ? EXIT_FAILURE : EXIT_SUCCESS;\n}\n```\nCompile the test program with the shared header accessible:\n```bash\n# Compile: note we include the current directory for the shared header\ngcc -Wall -Werror -I. -o test_mydevice test_mydevice.c\n# Or with a Makefile target:\n# test: test_mydevice.c mydevice_ioctl.h\n# \tgcc -Wall -Werror -I. -o test_mydevice test_mydevice.c\n```\nRun the full sequence:\n```bash\n# Build module\nmake\n# Load\nsudo insmod mydevice.ko\n# Run tests (requires root for device access, or set device permissions)\nsudo ./test_mydevice\n# Check /proc directly\ncat /proc/mydevice\n# Verify strace decodes our ioctl (requires header in include path)\nsudo strace ./test_mydevice 2>&1 | grep ioctl\n# Unload\nsudo rmmod mydevice\n```\nExpected `strace` output for the ioctl calls (with the header visible to strace â€” usually automatic if symbols match):\n```\nioctl(3, MYDEV_STATUS, 0x7fff...) = 0\nioctl(3, MYDEV_CLEAR) = 0\nioctl(3, MYDEV_RESIZE, 0x7fff...) = 0\n```\n---\n## Three-Level View: What Happens During `ioctl(fd, MYDEV_STATUS, &status)`\n**Level 1 â€” Userspace**:\nYour test program calls `ioctl(fd, MYDEV_STATUS, &status)`. The C library wraps this as the `ioctl(2)` syscall. The `cmd` argument is the 32-bit encoded value produced by `_IOR('M', 2, struct mydev_status)` â€” approximately `0x80184d02` (direction=read=2, size=24 bytes, type='M', nr=2). The `arg` is the stack address of `status`.\n**Level 2 â€” Kernel/VFS**:\n`sys_ioctl` â†’ `do_vfs_ioctl` â†’ checks if `cmd` is a known VFS-level command (like `FIONREAD` or `FIOCLEX`) â€” it's not â€” â†’ calls `vfs_ioctl` â†’ `filp->f_op->unlocked_ioctl(filp, cmd, arg)` â†’ your `mydev_ioctl`. Your handler reads `open_count`, `read_count`, `write_count` from `atomic_t` variables, fills `struct mydev_status` on the kernel stack, and calls `copy_to_user`. The copy places the struct into the userspace stack frame.\n**Level 3 â€” Hardware**:\nThe `copy_to_user` for a 24-byte struct is a fast path. On x86_64, the struct fits in three cache lines (24 bytes < 64 bytes = one cache line, in fact). The CPU executes the copy with a few `mov` instructions and potential `rep movsb` for safety. The userspace page is likely hot in L1/L2 cache since the test program just passed its address. The `atomic_read` calls generate `mov` instructions with appropriate memory barriers â€” `atomic_read` on x86 is just a regular load (x86's memory model provides the necessary ordering guarantees without explicit barrier instructions in most cases). The total cost: maybe 200ns, dominated by the syscall overhead (~100ns) and cache accesses, not the copy itself.\n---\n## Hardware Soul: The ioctl Path's Cache Footprint\nWhen your ioctl handler runs, consider what memory it touches:\n- **`kernel_buffer` pointer**: one word in the global data section â€” L1 hot after the first access\n- **`buffer_size_bytes`, `buffer_used`**: adjacent `size_t` values in BSS â€” two cache lines apart at most, likely in the same 64-byte cache line if laid out consecutively by the compiler\n- **`open_count`, `read_count`, `write_count`**: three `atomic_t` values (each a 4-byte `int`). If they're adjacent in memory, they share a cache line â€” 12 bytes total, fits in one 64-byte line. **Critical**: if multiple CPUs atomically increment these counters from different cores, each `atomic_inc` requires exclusive cache line ownership (the MESI cache coherency protocol's \"M\" (Modified) state). This is cache line bouncing â€” the line has to transfer between CPU caches on each write. For simple counters this is acceptable. For high-throughput code (thousands of operations per second), you'd use per-CPU counters and aggregate them on read. This is exactly how the kernel's own `percpu_counter` works.\nThe `struct mydev_status` that you fill and copy:\n```\nstruct mydev_status {  /* total: 6 Ã— 4 = 24 bytes */\n    __u32 buffer_size;    /* offset  0 */\n    __u32 bytes_used;     /* offset  4 */\n    __u32 open_count;     /* offset  8 */\n    __u32 read_count;     /* offset 12 */\n    __u32 write_count;    /* offset 16 */\n    __u32 _reserved;      /* offset 20 */\n};                        /* total: 24 bytes = 3/8 of one cache line */\n```\n24 bytes. One cache line (64 bytes) is more than enough. The `copy_to_user` for 24 bytes doesn't even need loop unrolling â€” the compiler generates a small sequence of register stores. The bottleneck in this ioctl is not the copy; it's the atomic reads and the syscall overhead.\n---\n## Pitfalls: What Goes Wrong and Why\n### Using Wrong Magic Number â€” Silent Mismatch\n```c\n/* WRONG â€” using a magic number someone else uses */\n#define MYDEV_MAGIC  't'   /* 't' is used by linux/tty.h TCGETS, TCSETS, etc. */\n/* RIGHT â€” pick one from Documentation/userspace-api/ioctl/ioctl-number.rst */\n#define MYDEV_MAGIC  'M'   /* or whichever is unregistered */\n```\nIf your magic number collides with a TTY magic number, a program calling your ioctl on a TTY might accidentally trigger your handler (or vice versa) when the numbers align. The magic number is the first line of defense.\n### Returning Wrong Error for Unknown Command\n```c\n/* WRONG â€” standard violation */\nreturn -EINVAL;    /* \"invalid argument\" â€” ambiguous */\n/* RIGHT â€” POSIX-mandated for unsupported ioctl */\nreturn -ENOTTY;    /* \"inappropriate ioctl for device\" */\n```\nPrograms testing for supported commands use the return code to distinguish \"command not supported\" (`-ENOTTY`) from \"command supported but argument invalid\" (`-EINVAL`). Returning `-EINVAL` for unknown commands breaks this distinction.\n### RESIZE Without Protecting Existing Data\n```c\n/* WRONG â€” frees old buffer before copying to new */\nkfree(kernel_buffer);\nkernel_buffer = kmalloc(new_size, GFP_KERNEL);\nif (!kernel_buffer) {\n    /* original data is gone! kernel_buffer is now NULL! */\n    return -ENOMEM;\n}\n/* RIGHT â€” allocate first, copy, then free */\nnew_buffer = kzalloc(new_size, GFP_KERNEL);\nif (!new_buffer) return -ENOMEM;   /* original buffer untouched */\nmemcpy(new_buffer, kernel_buffer, min(buffer_used, (size_t)new_size));\nkfree(kernel_buffer);\nkernel_buffer = new_buffer;\n```\nThe \"allocate-then-swap\" pattern is a fundamental technique for making operations resilient to allocation failure. It applies equally to kernel code and userspace code (it's how `realloc` is supposed to be implemented for safety).\n### Not Handling Truncation on RESIZE-Down\n```c\n/* WRONG â€” bytes_used may exceed new_size */\nmemcpy(new_buffer, kernel_buffer, buffer_used);  /* writes past new_buffer end! */\n/* RIGHT â€” truncate first */\nif (buffer_used > new_size)\n    buffer_used = new_size;\nmemcpy(new_buffer, kernel_buffer, buffer_used);\n```\nWriting `buffer_used` bytes into a `new_size`-byte buffer when `buffer_used > new_size` is a classic buffer overflow. In the kernel, this corrupts adjacent kernel memory â€” the consequences range from silent data corruption to immediate kernel panic, depending on what lives next to your buffer.\n### proc_create Error Check with IS_ERR\n```c\n/* WRONG â€” proc_create returns NULL on error, not ERR_PTR */\nif (IS_ERR(proc_entry)) {          /* always false! NULL != IS_ERR(NULL) */\n    ret = PTR_ERR(proc_entry);\n    goto err_proc;\n}\n/* RIGHT */\nif (!proc_entry) {                  /* NULL check */\n    ret = -ENOMEM;\n    goto err_proc;\n}\n```\n`IS_ERR(NULL)` returns false because `NULL` (0) is not in the error pointer range. The `proc_create` inconsistency (returning NULL vs ERR_PTR) is a historical accident in the kernel API. Always check the documentation for which convention a function uses.\n### Modifying buffer_size_bytes Without Updating /proc Show\nIf your proc show function reads `buffer_size_bytes` and your ioctl RESIZE modifies it, you need no extra work â€” both see the same global variable. But if you cache values (e.g., save `buffer_size_bytes` to a local at init time), your proc entry will show stale data after a resize. Always read live state in proc show handlers.\n---\n## Knowledge Cascade: What You've Just Unlocked\n**â†’ ioctl = Control Plane / data-plane separation (cross-domain: network protocol design)**\nThe read/write vs. ioctl split you just implemented is the same architectural pattern as TCP's data stream vs. socket options (`setsockopt`/`getsockopt`). HTTP separates body (data plane) from headers (control plane). QUIC separates stream data from connection-level signals. gRPC offers streaming RPCs (high-throughput data) alongside unary calls (control). The insight â€” \"don't mix control and data in the same channel\" â€” appears everywhere because mixing them forces both sides to parse combined traffic, adding latency and complexity. When you next design a protocol or API and find yourself tempted to embed commands in the data stream, remember: TCP, HTTP, and your kernel driver all chose not to.\n**â†’ seq_file's iterator = Language-level iterators (cross-domain: language design)**\nThe `start`/`next`/`stop`/`show` interface seq_file gives you is structurally identical to Python's `__iter__`/`__next__` generator protocol, Rust's `Iterator` trait with its `next() -> Option<Item>` method, and database cursor iteration. The fundamental problem is the same: \"produce a potentially large sequence lazily, without materializing it all at once.\" Python generators solve it with `yield`. Rust iterators solve it with `next()`. seq_file solves it with `start`/`next`/`stop`. When you write a Python generator that yields database rows, you're implementing the same pattern as the seq_file infrastructure you just wired up.\n**â†’ /proc virtual filesystem = Everything-is-a-file philosophy (cross-domain: OS design)**\n`/proc/mydevice` has no backing file on disk. Its \"content\" is generated by your `mydev_proc_show` function every time someone reads it. This is the same trick as `/proc/cpuinfo` (calls into the CPU topology code), `/proc/meminfo` (queries the page allocator), and `/proc/<pid>/status` (reads the task struct for that process). Plan 9 OS â€” Linux's philosophical ancestor in many ways â€” took this idea to its logical extreme: *everything* is a file, including network connections (open `/net/tcp/0/data` to make a TCP connection). FUSE (Filesystem in Userspace) implements the same idea in userspace: your code generates \"file content\" on-read. Understanding `/proc` means you understand FUSE, Plan 9, `/sys`, and the entire \"virtual filesystem as control interface\" philosophy.\n**â†’ Shared header ABI = Wire format stability (cross-domain: distributed systems)**\nThe `mydevice_ioctl.h` you just created is an ABI contract. `struct mydev_status`'s layout â€” field order, sizes, offsets â€” is now frozen. Any userspace binary compiled against this header must keep working against future kernel drivers. This is identical to Protocol Buffers: field numbers are immutable once assigned, because removing or reusing them breaks binary compatibility with old serialized data. It's the same as JSON API versioning (don't remove fields, only add). The Linux kernel's guarantee of stable userspace ABI is explicitly documented in `Documentation/process/stable-api-nonsense.rst` â€” the *internal* kernel API changes freely, but the userspace ABI (what you exposed in your header) is guaranteed stable. When you design any serialized format or shared interface, you're facing the same problem your ioctl header just solved: separate the mutable internals from the immutable external contract.\n**â†’ Atomic counters â†’ per-CPU counters â†’ scalability (forward)**\nYour `atomic_t read_count` increments on every read. With a single CPU, this is fine. With 16 CPUs all reading simultaneously, each `atomic_inc` causes the cache line holding `read_count` to bounce between CPU caches â€” a cache coherency round-trip that takes ~100 CPU cycles per operation. At 16 concurrent readers, your counter becomes a bottleneck. The kernel's solution: `percpu_counter` â€” each CPU maintains its own counter in CPU-local memory (no cache bouncing), and reads aggregate all CPU-local values. This is the same idea as Go's `sync.Pool` (per-goroutine allocation to avoid contention), or partitioned lock tables (one lock per shard, not one global lock). The pattern: \"replace one shared resource with N per-CPU/per-thread resources, aggregate on read.\" You'll see it everywhere high-performance code needs shared counters.\n---\n## Acceptance Criteria Checkpoint\nBefore moving to Milestone 4, verify every item:\n- [ ] `mydevice_ioctl.h` compiles correctly when included in both kernel module (with `__KERNEL__` defined) and userspace C program (without `__KERNEL__`)\n- [ ] `MYDEV_CLEAR`, `MYDEV_RESIZE`, `MYDEV_STATUS` produce distinct non-zero 32-bit values; verify by printing them in the test program\n- [ ] `make` compiles the module with `ccflags-y := -Werror` and zero warnings\n- [ ] `ioctl(fd, MYDEV_CLEAR)` zeroes the buffer; subsequent read returns 0 bytes (EOF immediately)\n- [ ] `ioctl(fd, MYDEV_RESIZE, &new_size)` with `new_size=8192` changes buffer capacity; `MYDEV_STATUS` reports `buffer_size=8192`\n- [ ] `ioctl(fd, MYDEV_RESIZE, &new_size)` with `new_size=0` returns `-EINVAL` (not a crash)\n- [ ] `ioctl(fd, MYDEV_RESIZE, &new_size)` with content larger than new_size truncates safely (no overflow, no panic)\n- [ ] `ioctl(fd, MYDEV_STATUS, &status)` fills all fields of `struct mydev_status` correctly; `read_count` and `write_count` increment after each read/write operation\n- [ ] `ioctl(fd, _IO('Z', 99))` (wrong magic number) returns `-1` with `errno == ENOTTY`\n- [ ] `cat /proc/mydevice` outputs all five statistics fields (buffer_size, bytes_used, open_count, read_count, write_count)\n- [ ] `cat /proc/mydevice` called twice returns consistent data without hanging or double-printing\n- [ ] `sudo rmmod mydevice` after `proc_create` removes `/proc/mydevice` cleanly (no stale proc entry)\n- [ ] Test program `test_mydevice` compiles with `gcc -Wall -Werror -I. test_mydevice.c` and runs all four test cases without failure\n- [ ] `strace ./test_mydevice 2>&1 | grep ioctl` shows ioctl calls with recognizable command names (not raw hex) when symbols are available\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-kernel-module-m4 -->\n<!-- MS_ID: build-kernel-module-m4 -->\n# Milestone 4: Concurrent Access, Blocking I/O, and Poll Support\n## The Revelation: The Kernel Is Not a Thread â€” It's a State Machine\nYou've built a character device that works perfectly when one process uses it at a time. Now imagine four processes all calling `read()` simultaneously, three of them finding the buffer empty, and a fourth calling `write()` to fill it. In userspace, you'd reach for `pthread_mutex_lock()` and a condition variable. You'd think: \"The reader locks the mutex, finds the buffer empty, calls `pthread_cond_wait()`, sleeps, wakes when the writer signals.\" Clean. Familiar.\nHere's the misconception that kernel newcomers carry from that model: they assume that \"blocking\" in the kernel works the same way, that `mutex_lock` in the kernel is just `pthread_mutex_lock` with a different name, and that `poll()` is just a kernel function that checks a boolean and returns \"yes\" or \"no.\"\nEvery part of that model needs surgery.\n**The first operation**: `mutex_lock()` in the kernel *does* sleep. But \"sleeping\" in the kernel is not a private affair between two threads. It is a state change on the **current process** â€” the actual Linux task (identified by its `struct task_struct`) that is executing your driver's code on behalf of the syscall. When your read handler calls `mutex_lock()` and the mutex is contended, the current process transitions from `TASK_RUNNING` (scheduled, consuming CPU cycles) to `TASK_INTERRUPTIBLE` (sleeping, removed from the run queue, not scheduled). The scheduler picks a different process to run. Your code is literally paused mid-function, in the kernel, and a completely different process starts running on that CPU. When the mutex becomes available, your process is placed back on the run queue and eventually resumes exactly where it paused â€” but potentially hundreds of milliseconds later, on a different CPU core.\nThis is only safe in **process context** â€” code executing as part of a syscall from a user process. It is catastrophically illegal in **interrupt context** â€” code executing inside a hardware interrupt handler or a software interrupt (softirq, tasklet). In interrupt context, there is no \"current process\" to sleep. The CPU is responding to a hardware event, not running on behalf of any process. If you call `mutex_lock()` and sleep in interrupt context, you corrupt the interrupt stack, the scheduler panics, and your machine halts.\n[[EXPLAIN:kernel-sleeping-primitives-vs-spinlocks-(process-context-vs-interrupt-context)|Kernel sleeping primitives vs spinlocks (process context vs interrupt context)]]\n**The second operation**: `wait_event_interruptible()` is not a function that loops until something is true. It does something architecturally remarkable. It:\n1. Adds the current process to a **wait queue** â€” a linked list of sleeping processes waiting for a condition\n2. Sets the process state to `TASK_INTERRUPTIBLE`\n3. Calls `schedule()` â€” voluntarily yields the CPU\n4. Wakes up when another process calls `wake_up_interruptible()` on the wait queue\n5. Re-checks the condition (spurious wakeup protection)\n6. If condition is true: removes itself from the wait queue and returns 0\n7. If a signal arrived: returns `-ERESTARTSYS`\nThe writer calling `wake_up_interruptible()` doesn't resume the reader *immediately*. It transitions the reader from the wait queue back to the run queue and marks it `TASK_RUNNING`. The scheduler then decides when the reader actually gets CPU time â€” maybe microseconds later, maybe milliseconds. The writer continues running, finishes its write, releases the mutex, and returns. Only then does the scheduler get to pick the reader.\n**The third operation** â€” and this is the one that surprises everyone â€” `poll()` does not sleep inside your driver. Your `.poll` handler is called by the kernel's poll infrastructure, but it must return *immediately* with a readiness mask. It must never block. The sleeping happens *outside* your driver, in the VFS poll infrastructure. Your job is not to wait for readiness â€” your job is to **register your wait queue** with the poll table and **report current readiness**. The kernel's poll loop does the sleeping, wakes up when your wait queue fires, and calls your `.poll` handler again to re-check readiness.\nThese three revelations reframe everything you're about to build. Let's build it.\n\n![Final Device Structure: All Fields at Byte-Level](./diagrams/diag-m4-complete-device-struct.svg)\n\n---\n## The Foundation: What You're Actually Building\nBefore any code, look at the structural transformation this milestone makes. In Milestone 3, your device had two unsynchronized global variables (`buffer_used`, `kernel_buffer`) accessed by handlers that could run simultaneously on different CPUs. Any concurrent access was undefined behavior â€” a data race that worked most of the time and produced subtle corruption the rest.\nThis milestone adds:\n- A `struct mutex dev_mutex` that serializes all access to `kernel_buffer` and `buffer_used`\n- A `wait_queue_head_t read_queue` for blocking readers waiting for data\n- A `wait_queue_head_t write_queue` for blocking writers waiting for space\n- Logic to check `filp->f_flags & O_NONBLOCK` to implement non-blocking I/O\n- A `.poll` file operation that uses `poll_wait()` to participate in `select`/`poll`/`epoll`\nThe device's behavior changes fundamentally:\n| Scenario | Before (M3) | After (M4) |\n|---|---|---|\n| Two concurrent writes | Data race, corruption | Serialized by mutex |\n| Read with empty buffer | Returns 0 (EOF) immediately | Blocks until data arrives |\n| Read with O_NONBLOCK + empty | Returns 0 (EOF) | Returns -EAGAIN |\n| Write with full buffer | Returns -ENOSPC | Blocks until space available |\n| poll() on the fd | Not supported | Returns POLLIN when data exists |\n| Ctrl+C during blocking read | Hangs forever (pre-M4) | Returns -EINTR/-ERESTARTSYS |\n\n![Mutex-Protected Buffer: Critical Sections in Read and Write](./diagrams/diag-m4-mutex-protection.svg)\n\n---\n## Kernel Mutexes: The Right Lock for Process Context\n### What a Mutex Actually Is\nThe kernel has multiple locking primitives, each suited to a different context. Understanding *which* lock to use requires understanding what \"context\" means in the kernel.\n**Process context** is any code that executes as part of a system call on behalf of a user process. Your `mydev_read`, `mydev_write`, `mydev_ioctl`, and `mydev_open` handlers all run in process context â€” there is a `current` task, it has a process address space, and it can sleep.\n**Interrupt context** is any code that executes in response to a hardware interrupt, softirq, or tasklet. There is no `current` task in the meaningful sense, no process address space, and **sleeping is forbidden** â€” the CPU must finish handling the interrupt and return to whatever it was doing before.\nThe primitive you want for process context is `struct mutex`. It is a **sleeping lock**:\n- If the mutex is available: `mutex_lock()` acquires it instantly (one atomic operation)\n- If the mutex is contended: `mutex_lock()` puts the current process to sleep until the mutex becomes available\nThe primitive for interrupt context (or any context where sleeping is forbidden) is `struct spinlock`. A spinlock **busy-waits** â€” it loops in a tight loop reading the lock variable until it becomes available. No sleeping, no schedule() call. But holding a spinlock while doing anything that sleeps (including `kmalloc(GFP_KERNEL)`, `copy_from_user`, `mutex_lock`) is catastrophic â€” it holds the CPU hostage.\nFor your character device, **mutex is the correct choice**. Your file operation handlers run in process context. They may sleep. They copy data from/to userspace, which can fault and sleep. `GFP_KERNEL` allocations in ioctl handlers can sleep. Mutex handles all of this correctly.\n```c\n#include <linux/mutex.h>\nstatic DEFINE_MUTEX(dev_mutex);\n/*\n * DEFINE_MUTEX(name) statically defines and initializes a mutex.\n * Equivalent to:\n *   struct mutex dev_mutex;\n *   mutex_init(&dev_mutex);\n *\n * Use for module-level mutexes. For dynamically allocated structs,\n * use mutex_init(&obj->lock) in your allocation/init code.\n */\n```\nThe mutex API is small:\n```c\nmutex_lock(&dev_mutex);          /* acquire; sleep if contended */\nmutex_unlock(&dev_mutex);        /* release */\nmutex_lock_interruptible(&dev_mutex); /* acquire; return -EINTR if signal arrives */\nmutex_trylock(&dev_mutex);       /* acquire if available; return 0 if not */\n```\nFor blocking I/O, use `mutex_lock_interruptible()` â€” it returns `-EINTR` if a signal arrives while the process is sleeping waiting for the mutex. This allows `Ctrl+C` to interrupt a write even if the mutex is contended.\n> **Lock Ordering**: if your driver ever needs two mutexes simultaneously (you won't here, but this principle is fundamental), you must acquire them in a consistent global order across all code paths. Acquiring A then B in one path and B then A in another path is a classic deadlock. Since this driver has one mutex, deadlock is only possible if your code calls `mutex_lock(&dev_mutex)` while already holding it â€” which deadlocks immediately because the kernel's mutex is not reentrant. You will see `WARNING: possible recursive locking detected` in dmesg if this happens.\n---\n## Wait Queues: The Sleeping Heart of Blocking I/O\n### The Data Structure\nA **wait queue head** (`wait_queue_head_t`) is a linked list of sleeping processes, each waiting for a condition to become true. The list is protected by its own internal spinlock (which is why wait queue operations are safe to call from anywhere, including while holding your mutex â€” the internal spinlock protects the queue structure itself, and you release it before sleeping).\n```c\n#include <linux/wait.h>\nstatic DECLARE_WAIT_QUEUE_HEAD(read_queue);   /* for readers waiting on empty buffer */\nstatic DECLARE_WAIT_QUEUE_HEAD(write_queue);  /* for writers waiting on full buffer  */\n/*\n * DECLARE_WAIT_QUEUE_HEAD(name) statically defines and initializes.\n * For dynamic allocation: init_waitqueue_head(&obj->wait_queue);\n */\n```\n\n![Blocking Read: wait_event_interruptible Internals](./diagrams/diag-m4-wait-queue-blocking-read.svg)\n\n### `wait_event_interruptible`: The Full Mechanism\nThe macro `wait_event_interruptible(queue, condition)` is the standard pattern for blocking a process until a condition becomes true. Here is what it expands to, conceptually:\n```\nwait_event_interruptible(wq, condition):\n  1. Check condition â€” if true, return 0 immediately (fast path, no sleeping)\n  2. Prepare a wait_queue_entry: allocate a struct, set it to point to current task\n  3. add_wait_queue(wq, &entry)        â€” insert into the wait queue\n  4. set_current_state(TASK_INTERRUPTIBLE) â€” mark process as sleeping\n  5. Check condition AGAIN (re-check after state change, before schedule)\n     â€” this closes the TOCTOU window between adding to queue and sleeping\n  6. If condition false AND no signal pending:\n       schedule()                      â€” yield CPU; sleep here\n       set_current_state(TASK_INTERRUPTIBLE)  â€” re-arm for next iteration\n       goto step 5\n  7. set_current_state(TASK_RUNNING)   â€” re-arm as runnable\n  8. remove_wait_queue(wq, &entry)     â€” remove from wait queue\n  9. If signal_pending(current): return -ERESTARTSYS\n  10. Return 0 (condition became true)\n```\nThe double-check at step 5 is critical. Between step 3 (adding to wait queue) and step 6 (calling schedule), a writer might already have written data and called `wake_up_interruptible()`. Without the re-check, the reader would sleep on a now-non-empty buffer, potentially forever. This is the **lost wakeup problem**, and `wait_event_interruptible` handles it correctly.\n[[EXPLAIN:wait-queue-internals-and-the-thundering-herd-problem|Wait queue internals and the thundering herd problem]]\n### The Condition and the Mutex: A Critical Pattern\nThere's a subtle interaction between the mutex and the wait queue that confuses many developers. Your read handler:\n1. **Acquires the mutex** (to safely check `buffer_used`)\n2. **Checks the condition** (`buffer_used == 0`)\n3. If empty: **must release the mutex before sleeping**\nYou cannot hold the mutex while calling `wait_event_interruptible()` â€” that would block all writers from acquiring the mutex to add data, causing a deadlock where the reader sleeps holding the lock that writers need.\nThe pattern looks like this:\n```c\n/* WRONG â€” deadlock: holds mutex while sleeping */\nmutex_lock(&dev_mutex);\nwait_event_interruptible(read_queue, buffer_used > 0);  /* writers can't lock! */\n/* ... read ... */\nmutex_unlock(&dev_mutex);\n/* RIGHT â€” release mutex before sleeping, re-acquire after waking */\nmutex_lock(&dev_mutex);\nwhile (buffer_used == 0) {\n    mutex_unlock(&dev_mutex);\n    if (wait_event_interruptible(read_queue, buffer_used > 0))\n        return -ERESTARTSYS;\n    mutex_lock(&dev_mutex);\n}\n/* now holding mutex and buffer_used > 0 */\n```\nBut wait â€” is there a race between releasing the mutex and adding ourselves to the wait queue? **No** â€” `wait_event_interruptible` checks the condition *before* sleeping. The sequence is:\n1. Check `buffer_used == 0` with mutex held â€” yes, empty\n2. Release mutex\n3. `wait_event_interruptible` checks `buffer_used > 0` â€” still empty (writer hasn't run yet)\n4. Adds to wait queue, sets `TASK_INTERRUPTIBLE`, calls `schedule()`\n5. Writer acquires mutex, adds data, calls `wake_up_interruptible()`\n6. Reader wakes, re-acquires mutex\n7. Condition is now true â€” reader proceeds\nIf the writer runs between steps 2 and 3 (after mutex release but before `wait_event_interruptible`), the writer adds data and calls `wake_up_interruptible()` on an empty wait queue (reader hasn't added itself yet). Then in step 3, `wait_event_interruptible` checks the condition â€” `buffer_used > 0` is now true â€” and returns immediately without sleeping. No lost wakeup.\n---\n## -ERESTARTSYS: The Signal That Travels Through Time\n\n![Signal Delivery During Wait: -ERESTARTSYS Flow](./diagrams/diag-m4-signal-erestartsys.svg)\n\nWhen a user presses `Ctrl+C` while a process is blocked in `read()` on your device, a `SIGINT` signal is delivered. Here is the chain of events:\n1. The kernel delivers `SIGINT` to the sleeping process by setting a flag in its `task_struct` and calling `wake_up_process(task)`\n2. The process transitions from `TASK_INTERRUPTIBLE` to `TASK_RUNNING`\n3. `wait_event_interruptible` detects a pending signal via `signal_pending(current)` and returns `-ERESTARTSYS` instead of 0\n4. Your read handler propagates this: `if (ret == -ERESTARTSYS) return -ERESTARTSYS;`\n5. The kernel's signal handling code intercepts the `-ERESTARTSYS` return from your syscall\nHere's the subtle part: `-ERESTARTSYS` is **not** `-EINTR`. The kernel uses `-ERESTARTSYS` as an internal signal to its own syscall restart machinery. The kernel then checks the signal handler:\n- If the signal handler was installed with `SA_RESTART` flag: the syscall is **automatically restarted** â€” the process calls `read()` again transparently, the user process never sees the interruption\n- If the signal handler was installed without `SA_RESTART` (or the signal has default disposition): the kernel converts `-ERESTARTSYS` to `-EINTR` and returns that to the user process, which sees `errno == EINTR`\nThis is exactly why `read()` sometimes returns `-1` with `errno == EINTR` in userspace programs â€” the signal handler interrupted the blocking syscall, and the SA_RESTART flag was not set. Your `signal-handler` prerequisite project encountered this behavior; now you're seeing the kernel mechanism that produces it.\n> **Why not return `-EINTR` directly from your driver?** Because `-EINTR` prevents syscall restart entirely. `-ERESTARTSYS` gives the kernel's signal machinery the opportunity to restart the syscall if `SA_RESTART` allows it. Returning `-ERESTARTSYS` from your handler is the correct, SA_RESTART-aware approach. The kernel translates it to `-EINTR` for userspace if restart isn't appropriate.\n---\n## O_NONBLOCK: Two Universes of I/O Behavior\n\n![O_NONBLOCK: Two Universes of I/O Behavior](./diagrams/diag-m4-nonblock-vs-blocking.svg)\n\nWhen a process opens your device with `O_NONBLOCK` (e.g., `open(\"/dev/mydevice\", O_RDWR | O_NONBLOCK)`), it is making a contract with your driver: **\"Never block me. If the operation can't complete immediately, return an error.\"**\nThe flag is stored in `filp->f_flags` and remains for the lifetime of the open file descriptor. You check it in your read and write handlers:\n```c\n/* Check for O_NONBLOCK before sleeping */\nif (filp->f_flags & O_NONBLOCK) {\n    /* Can't complete immediately â€” return -EAGAIN */\n    mutex_unlock(&dev_mutex);\n    return -EAGAIN;\n}\n```\n`-EAGAIN` means \"try again\" â€” the operation failed not because of an error but because it would have blocked. The POSIX error is often referred to as `EWOULDBLOCK` (which on Linux has the same value as `EAGAIN`). The caller is expected to either retry later, use `poll()`/`select()` to wait for readiness, or handle the condition gracefully.\nThe complete non-blocking contract for your device:\n| Condition | Blocking (default) | Non-blocking (O_NONBLOCK) |\n|---|---|---|\n| Read, buffer empty | Sleep until data available | Return -EAGAIN |\n| Read, buffer has data | Return data immediately | Return data immediately |\n| Write, buffer full | Sleep until space available | Return -EAGAIN |\n| Write, buffer has space | Write and return count | Write and return count |\nO_NONBLOCK is the foundation of **event-driven I/O**. The `select()`, `poll()`, and `epoll()` system calls use O_NONBLOCK internally â€” they mark fds as non-blocking, check readiness via your `.poll` handler, sleep if nothing is ready, and then call `read()`/`write()` only when the poll says the operation won't block. If your driver doesn't implement O_NONBLOCK correctly, the entire event-driven I/O machinery breaks for your device.\n---\n## The `.poll` File Operation: Not What You Think\n### The Architectural Insight\nThe biggest conceptual mistake people make with the kernel's `.poll` handler is thinking it works like this:\n```\n// WRONG mental model\npoll_handler():\n  while (buffer_empty):\n    sleep(10ms)\n  return POLLIN\n```\nIt actually works like this:\n```\n// CORRECT mental model\npoll_handler():\n  register_interest(caller, my_wait_queue)  // \"wake me if this queue fires\"\n  return current_readiness_mask             // what's ready RIGHT NOW\n```\nYour `.poll` handler is not responsible for sleeping. It is responsible for two things:\n1. Registering the caller's interest in your wait queue via `poll_wait()`\n2. Returning a bitmask of currently-ready events\nThe sleeping happens in the VFS poll infrastructure (in `fs/select.c` for `select`/`poll`, in `fs/eventpoll.c` for `epoll`). That infrastructure calls your `.poll` handler, inspects the returned mask, and if nothing is ready, sleeps on the wait queues you registered. When your `wake_up_interruptible()` fires (from a write), it wakes the infrastructure, which calls your `.poll` handler again to get the new mask.\n[[EXPLAIN:poll/select/epoll-kernel-side-protocol|poll/select/epoll kernel-side protocol]]\n\n![poll() File Operation: Registration and Mask Protocol](./diagrams/diag-m4-poll-mechanism.svg)\n\n### `poll_wait()`: The Registration Function\n```c\n#include <linux/poll.h>\nstatic __poll_t mydev_poll(struct file *filp, poll_table *wait)\n{\n    __poll_t mask = 0;\n    /*\n     * poll_wait(file, wait_queue_head, poll_table)\n     *\n     * Registers this file's wait queue with the poll_table.\n     * When the wait queue is woken (by wake_up_interruptible),\n     * the poll infrastructure wakes the sleeping poll/select/epoll\n     * and re-checks readiness by calling this .poll handler again.\n     *\n     * CRITICAL: poll_wait() does NOT sleep. It returns immediately.\n     * The sleeping is done by the poll infrastructure, not by your driver.\n     */\n    poll_wait(filp, &read_queue,  wait);\n    poll_wait(filp, &write_queue, wait);\n    /*\n     * After registering interest, report CURRENT readiness.\n     * This must be checked after poll_wait() to avoid a race:\n     * data might have arrived between the poll() call and poll_wait().\n     * If we checked before poll_wait and found empty, then data arrived\n     * before the registration, we'd miss the wakeup and wait forever.\n     */\n    mutex_lock(&dev_mutex);\n    if (buffer_used > 0)\n        mask |= POLLIN | POLLRDNORM;    /* data available for reading */\n    if (buffer_used < buffer_size_bytes)\n        mask |= POLLOUT | POLLWRNORM;   /* space available for writing */\n    mutex_unlock(&dev_mutex);\n    return mask;\n}\n```\n### The Mask Bits: A Quick Reference\n| Bit | Meaning | When to set |\n|---|---|---|\n| `POLLIN` | Data available to read | `buffer_used > 0` |\n| `POLLRDNORM` | Normal data readable (same as POLLIN for most devices) | Same as POLLIN |\n| `POLLOUT` | Space available to write | `buffer_used < buffer_size_bytes` |\n| `POLLWRNORM` | Normal data writable (same as POLLOUT for most devices) | Same as POLLOUT |\n| `POLLERR` | Error condition | On error state |\n| `POLLHUP` | Hangup (device disconnected) | On device removal |\n| `POLLPRI` | Urgent data (OOB for TCP, etc.) | Rarely needed |\nAlways return both `POLLIN | POLLRDNORM` together and `POLLOUT | POLLWRNORM` together. Some applications check for `POLLRDNORM` specifically (POSIX portable code), others check `POLLIN`. Returning both costs nothing and maximizes compatibility.\n> **The race that poll_wait() prevents**: Imagine a sequence without proper registration: (1) you check `buffer_used == 0` â€” empty. (2) A writer adds data and calls `wake_up_interruptible()`. (3) You call `poll_wait()` â€” but the wakeup already happened, nobody was on the queue. (4) The poll infrastructure sleeps â€” forever. By calling `poll_wait()` *before* checking the condition, you register interest first. If a wakeup fires between the registration and the condition check, the infrastructure sees the wakeup and re-checks. No events can be missed.\n---\n## The Complete Implementation\nNow let's assemble the full driver. This is the complete, production-quality reference combining everything from milestones 2, 3, and 4.\n### Updated Device State\nThe device state grows to include the mutex and wait queues:\n```c\n/* mydevice.c â€” Complete character device with concurrency support */\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/atomic.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>       /* mutex_lock, mutex_unlock */\n#include <linux/wait.h>        /* wait_event_interruptible, wake_up_interruptible */\n#include <linux/poll.h>        /* poll_wait, __poll_t, POLLIN, POLLOUT */\n#include <linux/string.h>\n#include \"mydevice_ioctl.h\"\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name <you@example.com>\");\nMODULE_DESCRIPTION(\"Character device: mutex protection, blocking I/O, poll support\");\nMODULE_VERSION(\"3.0\");\n/* â”€â”€â”€ Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n#define DEVICE_NAME  \"mydevice\"\n#define CLASS_NAME   \"mydevice_class\"\n#define PROC_NAME    \"mydevice\"\n#define BUFFER_SIZE  4096\n/* â”€â”€â”€ Device State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\nstatic dev_t          dev_num;\nstatic struct cdev    my_cdev;\nstatic struct class  *my_class;\nstatic struct device *my_device;\nstatic struct proc_dir_entry *proc_entry;\nstatic char   *kernel_buffer;\nstatic size_t  buffer_size_bytes = BUFFER_SIZE;\nstatic size_t  buffer_used       = 0;\n/*\n * Synchronization primitives:\n *\n * dev_mutex:   protects kernel_buffer, buffer_used, buffer_size_bytes.\n *              Must be held for any read or write of these fields.\n *\n * read_queue:  blocking readers sleep here when buffer_used == 0.\n *              Woken by write handler after adding data.\n *\n * write_queue: blocking writers sleep here when buffer is full.\n *              Woken by read handler after consuming data.\n */\nstatic DEFINE_MUTEX(dev_mutex);\nstatic DECLARE_WAIT_QUEUE_HEAD(read_queue);\nstatic DECLARE_WAIT_QUEUE_HEAD(write_queue);\nstatic atomic_t open_count  = ATOMIC_INIT(0);\nstatic atomic_t read_count  = ATOMIC_INIT(0);\nstatic atomic_t write_count = ATOMIC_INIT(0);\n```\n### Open and Release\nOpen and release remain simple â€” the open count is atomic and needs no mutex:\n```c\nstatic int mydev_open(struct inode *inode, struct file *filp)\n{\n    atomic_inc(&open_count);\n    printk(KERN_INFO \"mydev: open (count=%d)\\n\", atomic_read(&open_count));\n    return 0;\n}\nstatic int mydev_release(struct inode *inode, struct file *filp)\n{\n    atomic_dec(&open_count);\n    printk(KERN_INFO \"mydev: release (count=%d)\\n\", atomic_read(&open_count));\n    return 0;\n}\n```\n### The Write Handler: Producer with Wake-up\n```c\nstatic ssize_t mydev_write(struct file *filp, const char __user *buf,\n                           size_t count, loff_t *f_pos)\n{\n    ssize_t ret = 0;\n    size_t space_available, bytes_to_copy;\n    unsigned long not_copied;\n    /*\n     * Acquire the mutex before checking or modifying buffer state.\n     * Use mutex_lock_interruptible so Ctrl+C can interrupt even the\n     * mutex acquisition phase (if the mutex is contended and we're sleeping\n     * waiting to acquire it).\n     */\n    if (mutex_lock_interruptible(&dev_mutex))\n        return -ERESTARTSYS;\n    /*\n     * Wait until there is space in the buffer.\n     * This loop handles:\n     *   - O_NONBLOCK: return -EAGAIN immediately\n     *   - Blocking: sleep until space available or signal arrives\n     *   - Spurious wakeups: re-check condition after waking\n     */\n    while (buffer_used >= buffer_size_bytes) {\n        /* Buffer is full */\n        if (filp->f_flags & O_NONBLOCK) {\n            ret = -EAGAIN;\n            goto out_unlock;\n        }\n        /*\n         * Must release the mutex before sleeping.\n         * If we slept holding it, no reader could ever consume data\n         * to free space â€” classic deadlock.\n         */\n        mutex_unlock(&dev_mutex);\n        /*\n         * wait_event_interruptible(queue, condition):\n         *   Sleep until (buffer_used < buffer_size_bytes) becomes true,\n         *   or until a signal arrives (returns -ERESTARTSYS).\n         *\n         * The condition is re-evaluated inside the macro before sleeping â€”\n         * this prevents lost wakeups if a reader freed space between our\n         * mutex_unlock and this call.\n         */\n        if (wait_event_interruptible(write_queue,\n                                     buffer_used < buffer_size_bytes)) {\n            return -ERESTARTSYS;\n        }\n        /* Re-acquire mutex to re-check condition safely */\n        if (mutex_lock_interruptible(&dev_mutex))\n            return -ERESTARTSYS;\n    }\n    /* Now holding mutex, buffer has space */\n    space_available = buffer_size_bytes - buffer_used;\n    bytes_to_copy   = min(count, space_available);\n    not_copied = copy_from_user(kernel_buffer + buffer_used, buf, bytes_to_copy);\n    if (not_copied) {\n        ret = -EFAULT;\n        goto out_unlock;\n    }\n    buffer_used += bytes_to_copy;\n    atomic_inc(&write_count);\n    ret = (ssize_t)bytes_to_copy;\n    /*\n     * Wake up any sleeping readers.\n     * wake_up_interruptible() wakes all TASK_INTERRUPTIBLE waiters on\n     * read_queue. They will re-check buffer_used > 0 and, if true,\n     * proceed to read. If multiple readers wake, only the one that\n     * acquires the mutex first will find data; others re-sleep.\n     *\n     * The wake happens while we still hold dev_mutex. This is intentional\n     * and safe: the woken reader cannot acquire dev_mutex until we release\n     * it below, so there is no race on buffer_used between the wake and\n     * the unlock.\n     */\n    wake_up_interruptible(&read_queue);\nout_unlock:\n    mutex_unlock(&dev_mutex);\n    return ret;\n}\n```\n### The Read Handler: Consumer with Blocking\n```c\nstatic ssize_t mydev_read(struct file *filp, char __user *buf,\n                          size_t count, loff_t *f_pos)\n{\n    ssize_t ret = 0;\n    size_t bytes_available, bytes_to_copy;\n    unsigned long not_copied;\n    if (mutex_lock_interruptible(&dev_mutex))\n        return -ERESTARTSYS;\n    /*\n     * Wait until there is data to read.\n     *\n     * NOTE: This driver uses the buffer as a FIFO stream, not a\n     * seekable file. The f_pos tracks position within current content.\n     * When buffer_used reaches f_pos (all written content consumed),\n     * the reader blocks waiting for more content.\n     *\n     * If the device is used as a pipe (write then read), *f_pos starts\n     * at 0 and advances. When *f_pos == buffer_used, we block.\n     */\n    while (*f_pos >= buffer_used) {\n        if (filp->f_flags & O_NONBLOCK) {\n            /*\n             * Non-blocking: return -EAGAIN (not 0/EOF) when no data is\n             * available yet. 0 would mean \"end of stream, no more data\n             * ever\" â€” which is wrong for a device that might get writes.\n             * -EAGAIN means \"try again, data might come later.\"\n             */\n            ret = -EAGAIN;\n            goto out_unlock;\n        }\n        mutex_unlock(&dev_mutex);\n        if (wait_event_interruptible(read_queue, buffer_used > *f_pos)) {\n            return -ERESTARTSYS;\n        }\n        if (mutex_lock_interruptible(&dev_mutex))\n            return -ERESTARTSYS;\n    }\n    /* Now holding mutex, buffer has data past *f_pos */\n    bytes_available = buffer_used - *f_pos;\n    bytes_to_copy   = min(count, bytes_available);\n    not_copied = copy_to_user(buf, kernel_buffer + *f_pos, bytes_to_copy);\n    if (not_copied) {\n        ret = -EFAULT;\n        goto out_unlock;\n    }\n    *f_pos += bytes_to_copy;\n    atomic_inc(&read_count);\n    ret = (ssize_t)bytes_to_copy;\n    /*\n     * Wake up waiting writers now that we've consumed data and freed space.\n     */\n    wake_up_interruptible(&write_queue);\nout_unlock:\n    mutex_unlock(&dev_mutex);\n    return ret;\n}\n```\n### The Poll Handler\n```c\nstatic __poll_t mydev_poll(struct file *filp, poll_table *wait)\n{\n    __poll_t mask = 0;\n    /*\n     * Register this file's wait queues with the poll infrastructure.\n     * This MUST happen before checking the condition.\n     *\n     * Sequence with proper registration:\n     * 1. poll_wait registers read_queue and write_queue\n     * 2. We check conditions and find nothing ready\n     * 3. poll infrastructure sleeps on these queues\n     * 4. Write handler adds data, calls wake_up_interruptible(read_queue)\n     * 5. poll infrastructure wakes, calls .poll again â€” we return POLLIN\n     *\n     * Without step 1, step 4's wakeup would have no registered waiter\n     * and step 5 would never happen.\n     */\n    poll_wait(filp, &read_queue,  wait);\n    poll_wait(filp, &write_queue, wait);\n    /*\n     * Now check current readiness. Hold the mutex to get a consistent\n     * view of buffer_used and buffer_size_bytes.\n     *\n     * NOTE: We use mutex_lock() here, NOT mutex_lock_interruptible().\n     * The .poll handler should not return -ERESTARTSYS or similar â€” the\n     * poll infrastructure does not handle those return codes from .poll.\n     * The .poll handler must complete and return a mask.\n     *\n     * This means .poll can block briefly on the mutex (until the read or\n     * write handler finishes its critical section), but this is acceptable\n     * because the critical section is short.\n     */\n    mutex_lock(&dev_mutex);\n    if (buffer_used > 0)\n        mask |= POLLIN | POLLRDNORM;\n    if (buffer_used < buffer_size_bytes)\n        mask |= POLLOUT | POLLWRNORM;\n    mutex_unlock(&dev_mutex);\n    return mask;\n}\n```\n### Updated `file_operations` Table\n```c\nstatic const struct file_operations mydev_fops = {\n    .owner          = THIS_MODULE,\n    .open           = mydev_open,\n    .release        = mydev_release,\n    .read           = mydev_read,\n    .write          = mydev_write,\n    .unlocked_ioctl = mydev_ioctl,   /* unchanged from M3 */\n    .poll           = mydev_poll,    /* new in M4 */\n};\n```\n### Init and Exit (Updated)\nThe init/exit structure from Milestone 3 doesn't change â€” the mutex and wait queues are statically initialized and don't need explicit init/cleanup. `DEFINE_MUTEX` and `DECLARE_WAIT_QUEUE_HEAD` do all the initialization at compile time.\n---\n## Process States and the Scheduler: The Big Picture\n\n![Linux Process States: How Wait Queues Map to ps Output](./diagrams/diag-m4-process-states-waitqueue.svg)\n\nUnderstanding what `wait_event_interruptible` does to the Linux scheduler demystifies a lot of \"why does my server behave this way\" questions. Linux processes have several states visible in `ps` and `top`:\n| State | `ps` Code | Meaning | Kernel State |\n|---|---|---|---|\n| Running | `R` | On a CPU or runnable, on the run queue | `TASK_RUNNING` |\n| Interruptible sleep | `S` | Sleeping, can be woken by signals | `TASK_INTERRUPTIBLE` |\n| Uninterruptible sleep | `D` | Sleeping, signals can NOT wake it | `TASK_UNINTERRUPTIBLE` |\n| Stopped | `T` | SIGSTOP or ptrace | `TASK_STOPPED` |\n| Zombie | `Z` | Exited, waiting for parent to reap | `EXIT_ZOMBIE` |\nWhen your read handler calls `wait_event_interruptible()`, the process transitions to **`S` (interruptible sleep)**. This is the normal, healthy blocking state â€” `Ctrl+C` can wake it.\nThe `D` state (uninterruptible sleep) is used for I/O waits that cannot be interrupted mid-operation â€” for example, waiting for a disk read to complete. Processes in `D` state do not respond to `SIGKILL`. This is why a hung NFS mount can produce unkillable processes: they're in `D` state waiting for network I/O that never completes.\n**This directly explains Linux load average behavior**: Linux load average counts *both* `R` (running/runnable) and `D` (uninterruptible sleep) processes. A server with 8 CPUs can have a load average of 64 if 64 processes are simultaneously blocked in `D` state on disk I/O â€” all 64 are \"waiting for the CPU to be able to do useful work for them,\" even though none are consuming CPU cycles right now. A database that shows 0% CPU but load average of 20 is I/O-bound, not CPU-bound. Your `wait_event_interruptible` produces `S` state processes â€” they contribute 0 to load average when sleeping. `wait_event` (uninterruptible variant) produces `D` state â€” it contributes to load average.\n---\n## The Thundering Herd Problem\nImagine 100 reader processes are sleeping on `read_queue`, all waiting for data. One writer calls `write()` and adds 100 bytes. The writer calls `wake_up_interruptible(&read_queue)`.\n`wake_up_interruptible` wakes **all** sleeping processes on the queue. All 100 readers transition to `TASK_RUNNING` and compete to acquire `dev_mutex`. The one that wins reads all 100 bytes and releases the mutex. The other 99 acquire the mutex in turn, find `buffer_used == 0`, and go back to sleep.\nThis is the **thundering herd problem**: a single wakeup event causes O(N) processes to wake, contend, and re-sleep. For N=100 with a fast mutex, this is 99 unnecessary context switches and 99 unnecessary mutex acquisitions.\nThe kernel provides `wake_up_interruptible_nr(queue, nr)` to wake at most `nr` waiters, and `WQ_FLAG_EXCLUSIVE` to designate certain waiters as \"exclusive\" â€” `wake_up_interruptible` wakes exclusive waiters one at a time. For your single-buffer device, this optimization isn't necessary â€” the buffer either has data for all readers (stream device) or for one reader (pipe-like device). But knowing this exists tells you why `nginx`'s `accept_mutex` exists (to prevent all workers from thundering on a new connection) and why `epoll` with `EPOLLET | EPOLLONESHOT` is useful for high-connection servers.\nFor your driver: since the buffer can hold multiple bytes and multiple readers can each read different portions, `wake_up_interruptible` waking all readers is actually correct behavior â€” each reader that wakes finds some data available. The \"unnecessary wakeup\" scenario only occurs when readers compete for the same bytes, which doesn't happen with your f_pos-per-file design.\n---\n## Updating ioctl for Thread Safety\nThe ioctl handler from Milestone 3 accesses `kernel_buffer`, `buffer_used`, and `buffer_size_bytes` without holding the mutex. Now that concurrent access is possible, every access to shared state needs the lock:\n```c\nstatic long mydev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n    int ret = 0;\n    if (_IOC_TYPE(cmd) != MYDEV_MAGIC)\n        return -ENOTTY;\n    if (_IOC_NR(cmd) > 2)\n        return -ENOTTY;\n    switch (cmd) {\n    case MYDEV_CLEAR:\n        if (mutex_lock_interruptible(&dev_mutex))\n            return -ERESTARTSYS;\n        memset(kernel_buffer, 0, buffer_size_bytes);\n        buffer_used = 0;\n        /*\n         * After clearing, wake writers: the buffer now has maximum space.\n         * No need to wake readers: clear reduces bytes_used, not increases it.\n         */\n        wake_up_interruptible(&write_queue);\n        mutex_unlock(&dev_mutex);\n        break;\n    case MYDEV_RESIZE: {\n        __u32 new_size;\n        char *new_buffer;\n        if (copy_from_user(&new_size, (__u32 __user *)arg, sizeof(__u32)))\n            return -EFAULT;\n        if (new_size == 0 || new_size > (1U << 20))\n            return -EINVAL;\n        new_buffer = kzalloc(new_size, GFP_KERNEL);\n        if (!new_buffer)\n            return -ENOMEM;\n        if (mutex_lock_interruptible(&dev_mutex)) {\n            kfree(new_buffer);\n            return -ERESTARTSYS;\n        }\n        if (buffer_used > new_size)\n            buffer_used = new_size;\n        memcpy(new_buffer, kernel_buffer, buffer_used);\n        kfree(kernel_buffer);\n        kernel_buffer     = new_buffer;\n        buffer_size_bytes = new_size;\n        /*\n         * A resize might free space (if shrinking, content was truncated)\n         * or add space (if growing). Wake both queues to let waiters\n         * re-evaluate their conditions.\n         */\n        wake_up_interruptible(&read_queue);\n        wake_up_interruptible(&write_queue);\n        mutex_unlock(&dev_mutex);\n        break;\n    }\n    case MYDEV_STATUS: {\n        struct mydev_status status;\n        if (mutex_lock_interruptible(&dev_mutex))\n            return -ERESTARTSYS;\n        status.buffer_size = (__u32)buffer_size_bytes;\n        status.bytes_used  = (__u32)buffer_used;\n        status.open_count  = (__u32)atomic_read(&open_count);\n        status.read_count  = (__u32)atomic_read(&read_count);\n        status.write_count = (__u32)atomic_read(&write_count);\n        status._reserved   = 0;\n        mutex_unlock(&dev_mutex);\n        if (copy_to_user((struct mydev_status __user *)arg,\n                         &status, sizeof(status)))\n            return -EFAULT;\n        break;\n    }\n    default:\n        return -ENOTTY;\n    }\n    return ret;\n}\n```\nNote the pattern for `MYDEV_STATUS`: we copy the data under the mutex, then call `copy_to_user` *outside* the mutex. Why? Because `copy_to_user` can sleep (if the user page is not present and needs to be faulted in). Sleeping while holding a mutex is legal in process context, but it holds the mutex longer than necessary, increasing contention. Copy to a local stack struct under the mutex, then copy to userspace without the mutex â€” this is the canonical pattern.\n---\n## Userspace Poll Test\nLet's write a userspace test that exercises the poll functionality:\n```c\n/* poll_test.c â€” Test poll() on /dev/mydevice */\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <string.h>\n#include <errno.h>\n#define DEVICE \"/dev/mydevice\"\nint main(void)\n{\n    int fd;\n    struct pollfd pfd;\n    int ret;\n    char buf[64];\n    fd = open(DEVICE, O_RDWR | O_NONBLOCK);\n    if (fd < 0) { perror(\"open\"); return 1; }\n    pfd.fd     = fd;\n    pfd.events = POLLIN | POLLOUT;\n    /* â”€â”€ Test 1: Initial state â€” should be writable, not readable â”€â”€â”€ */\n    ret = poll(&pfd, 1, 0);   /* timeout=0: immediate check, no sleep */\n    printf(\"Initial poll: revents=0x%x\\n\", pfd.revents);\n    if (pfd.revents & POLLOUT)  printf(\"  PASS: POLLOUT set (buffer has space)\\n\");\n    if (!(pfd.revents & POLLIN)) printf(\"  PASS: POLLIN clear (buffer is empty)\\n\");\n    /* â”€â”€ Test 2: Write data, then poll â€” should become readable â”€â”€â”€â”€ */\n    write(fd, \"hello world\", 11);\n    ret = poll(&pfd, 1, 0);\n    printf(\"After write poll: revents=0x%x\\n\", pfd.revents);\n    if (pfd.revents & POLLIN)  printf(\"  PASS: POLLIN set (data available)\\n\");\n    if (pfd.revents & POLLOUT) printf(\"  PASS: POLLOUT set (still has space)\\n\");\n    /* â”€â”€ Test 3: Non-blocking read â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */\n    ret = read(fd, buf, sizeof(buf));\n    if (ret > 0) {\n        buf[ret] = '\\0';\n        printf(\"Read %d bytes: \\\"%s\\\"\\n\", ret, buf);\n    }\n    /* â”€â”€ Test 4: poll with timeout â€” wait for data from another process */\n    printf(\"Waiting for data (5s timeout)...\\n\");\n    printf(\"Run in another terminal: echo test | sudo tee /dev/mydevice\\n\");\n    pfd.events = POLLIN;\n    ret = poll(&pfd, 1, 5000);   /* 5 second timeout */\n    if (ret == 0) {\n        printf(\"Timed out â€” no data arrived\\n\");\n    } else if (ret > 0 && (pfd.revents & POLLIN)) {\n        ret = read(fd, buf, sizeof(buf));\n        buf[ret > 0 ? ret : 0] = '\\0';\n        printf(\"Data arrived: \\\"%s\\\"\\n\", buf);\n    }\n    close(fd);\n    return 0;\n}\n```\nCompile and run:\n```bash\ngcc -Wall -Werror -o poll_test poll_test.c\nsudo ./poll_test\n```\n---\n## The Stress Test: 4 Writers + 4 Readers\n\n![Stress Test: 4 Writers + 4 Readers Data Flow](./diagrams/diag-m4-concurrent-stress-test.svg)\n\nThe acceptance criteria require a stress test with 4 concurrent writer processes and 4 concurrent reader processes, with data integrity verified by checksums. Here is a complete test harness:\n```bash\n#!/bin/bash\n# stress_test.sh â€” Concurrent stress test for mydevice\n#\n# Architecture:\n#   4 writer processes: each writes N chunks of fixed-size data\n#   4 reader processes: each reads until it has collected N*chunk_size bytes total\n#\n# Data integrity: each writer generates deterministic data (byte pattern\n# based on writer ID + sequence number). All written bytes are checksummed\n# with CRC or sum. All read bytes are checksummed. Totals must match.\n#\n# Limitations of this simple test: because multiple writers interleave their\n# writes, the ORDER of bytes in the buffer is non-deterministic. This test\n# verifies that no bytes are lost or corrupted (checksum of all written\n# data == checksum of all read data), not that they arrive in order.\nset -e\nDEVICE=\"/dev/mydevice\"\nNUM_WRITERS=4\nNUM_READERS=4\nWRITES_PER_WRITER=100\nCHUNK_SIZE=64        # 64 bytes per write â€” fits in buffer without constant blocking\nWRITE_DIR=$(mktemp -d)\nREAD_DIR=$(mktemp -d)\necho \"[stress] Device: $DEVICE\"\necho \"[stress] Writers: $NUM_WRITERS, Readers: $NUM_READERS\"\necho \"[stress] Each writer: $WRITES_PER_WRITER writes Ã— $CHUNK_SIZE bytes\"\nTOTAL_BYTES=$((NUM_WRITERS * WRITES_PER_WRITER * CHUNK_SIZE))\necho \"[stress] Total bytes: $TOTAL_BYTES\"\n# â”€â”€ Writer function â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nwriter() {\n    local id=$1\n    local outfile=\"$WRITE_DIR/writer_${id}.dat\"\n    # Generate deterministic data: writer_id repeated as bytes\n    # Each writer uses a unique byte value (0x41='A', 0x42='B', etc.)\n    local byte_val=$((0x41 + id))   # 'A', 'B', 'C', 'D'\n    local byte_char\n    byte_char=$(printf \"\\\\$(printf '%03o' $byte_val)\")\n    for i in $(seq 1 $WRITES_PER_WRITER); do\n        # Create a chunk: CHUNK_SIZE bytes all equal to byte_val\n        printf \"${byte_char}%.0s\" $(seq 1 $CHUNK_SIZE) | \\\n            sudo tee -a \"$outfile\" >> /dev/null\n        printf \"${byte_char}%.0s\" $(seq 1 $CHUNK_SIZE) | \\\n            sudo tee -a \"$DEVICE\" > /dev/null\n        # Small delay to increase interleaving\n        sleep 0.$((RANDOM % 5))\n    done\n    echo \"[writer $id] done (${WRITES_PER_WRITER} writes Ã— ${CHUNK_SIZE} bytes)\"\n}\n# â”€â”€ Reader function â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nreader() {\n    local id=$1\n    local outfile=\"$READ_DIR/reader_${id}.dat\"\n    local bytes_per_reader=$((TOTAL_BYTES / NUM_READERS))\n    local collected=0\n    while [ $collected -lt $bytes_per_reader ]; do\n        # Read whatever is available (blocks until data present)\n        local chunk\n        chunk=$(sudo dd if=\"$DEVICE\" bs=64 count=1 2>/dev/null)\n        if [ -n \"$chunk\" ]; then\n            printf \"%s\" \"$chunk\" >> \"$outfile\"\n            collected=$((collected + ${#chunk}))\n        fi\n    done\n    echo \"[reader $id] done (${collected} bytes collected)\"\n}\n# â”€â”€ Run stress test â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\necho \"[stress] Starting writers and readers...\"\n# Start readers first (they'll block waiting for data)\nfor i in $(seq 0 $((NUM_READERS-1))); do\n    reader $i &\ndone\n# Start writers\nfor i in $(seq 0 $((NUM_WRITERS-1))); do\n    writer $i &\ndone\n# Wait for all background jobs\nwait\necho \"[stress] All processes completed\"\n# â”€â”€ Checksum verification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\necho \"[stress] Computing checksums...\"\n# Checksum of all written data (concatenate all writer output files)\nWRITE_CHECKSUM=$(cat \"$WRITE_DIR\"/writer_*.dat | md5sum | cut -d' ' -f1)\nREAD_CHECKSUM=$(cat \"$READ_DIR\"/reader_*.dat | md5sum | cut -d' ' -f1)\necho \"[stress] Written data MD5: $WRITE_CHECKSUM\"\necho \"[stress] Read data MD5:    $READ_CHECKSUM\"\nWRITE_TOTAL=$(cat \"$WRITE_DIR\"/writer_*.dat | wc -c)\nREAD_TOTAL=$(cat \"$READ_DIR\"/reader_*.dat | wc -c)\necho \"[stress] Written bytes: $WRITE_TOTAL (expected $TOTAL_BYTES)\"\necho \"[stress] Read bytes:    $READ_TOTAL (expected $TOTAL_BYTES)\"\nif [ \"$WRITE_TOTAL\" -eq \"$READ_TOTAL\" ]; then\n    echo \"[stress] PASS: byte counts match\"\nelse\n    echo \"[stress] FAIL: byte count mismatch!\"\n    rm -rf \"$WRITE_DIR\" \"$READ_DIR\"\n    exit 1\nfi\n# Note: due to interleaving, the exact byte ordering may differ between\n# written and read streams. The meaningful verification is:\n# 1. No bytes are lost: total written == total read\n# 2. No kernel oops, warnings, or panics in dmesg during the test\n# 3. dmesg shows no mutex warnings, deadlock warnings, or data corruption\necho \"[stress] Checking dmesg for kernel warnings...\"\nif dmesg | tail -50 | grep -iE \"(BUG|WARNING|OOPS|panic|deadlock|corruption)\" ; then\n    echo \"[stress] FAIL: kernel warnings detected\"\n    exit 1\nelse\n    echo \"[stress] PASS: no kernel warnings\"\nfi\nrm -rf \"$WRITE_DIR\" \"$READ_DIR\"\necho \"[stress] All tests PASSED\"\n```\nFor a more rigorous byte-level integrity check (verifying that every specific byte written by writer N is received by some reader, with no mutations), use this C test program:\n```c\n/* stress_c.c â€” C-based stress test with per-byte verification */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <stdint.h>\n#include <errno.h>\n#include <sys/types.h>\n#define DEVICE         \"/dev/mydevice\"\n#define NUM_WRITERS    4\n#define NUM_READERS    4\n#define WRITES_PER_W   200\n#define CHUNK_SIZE     32\n/*\n * Verification strategy:\n * Each writer writes a recognizable 4-byte header (0xWW + seq number)\n * followed by (CHUNK_SIZE - 4) bytes of the writer's fill byte.\n * Readers collect all bytes and verify structure.\n *\n * Simpler approach: each writer writes N*CHUNK_SIZE bytes of a unique\n * fill value. Total written per writer-value is tracked. Total read\n * per value must match. This proves no bytes are added or lost.\n */\nstatic uint64_t bytes_written[NUM_WRITERS] = {0};\nstatic uint64_t bytes_read_by_value[256]   = {0};\nstatic pthread_mutex_t stats_mutex         = PTHREAD_MUTEX_INITIALIZER;\nstatic void *writer_thread(void *arg)\n{\n    int id = *(int*)arg;\n    int fd = open(DEVICE, O_WRONLY);\n    if (fd < 0) { perror(\"open writer\"); return NULL; }\n    uint8_t fill = (uint8_t)('A' + id);   /* each writer uses unique byte */\n    uint8_t chunk[CHUNK_SIZE];\n    memset(chunk, fill, CHUNK_SIZE);\n    uint64_t written = 0;\n    for (int i = 0; i < WRITES_PER_W; i++) {\n        ssize_t n;\n        do {\n            n = write(fd, chunk + (CHUNK_SIZE - (written % CHUNK_SIZE)),\n                      CHUNK_SIZE);\n            if (n < 0 && errno != EAGAIN) { perror(\"write\"); goto done; }\n        } while (n < 0);\n        written += n;\n    }\ndone:\n    close(fd);\n    pthread_mutex_lock(&stats_mutex);\n    bytes_written[id] = written;\n    pthread_mutex_unlock(&stats_mutex);\n    printf(\"Writer %d done: %lu bytes of 0x%02X\\n\", id, (unsigned long)written, fill);\n    return NULL;\n}\nstatic void *reader_thread(void *arg)\n{\n    (void)arg;\n    int fd = open(DEVICE, O_RDONLY);\n    if (fd < 0) { perror(\"open reader\"); return NULL; }\n    uint64_t target = (uint64_t)NUM_WRITERS * WRITES_PER_W * CHUNK_SIZE / NUM_READERS;\n    uint64_t collected = 0;\n    uint8_t buf[256];\n    uint64_t local_count[256] = {0};\n    while (collected < target) {\n        ssize_t n = read(fd, buf, sizeof(buf));\n        if (n < 0) {\n            if (errno == EINTR) continue;\n            perror(\"read\"); break;\n        }\n        for (ssize_t i = 0; i < n; i++)\n            local_count[buf[i]]++;\n        collected += n;\n    }\n    close(fd);\n    pthread_mutex_lock(&stats_mutex);\n    for (int i = 0; i < 256; i++)\n        bytes_read_by_value[i] += local_count[i];\n    pthread_mutex_unlock(&stats_mutex);\n    return NULL;\n}\nint main(void)\n{\n    pthread_t writers[NUM_WRITERS], readers[NUM_READERS];\n    int ids[NUM_WRITERS];\n    printf(\"Stress test: %d writers, %d readers, %d writes each of %d bytes\\n\",\n           NUM_WRITERS, NUM_READERS, WRITES_PER_W, CHUNK_SIZE);\n    for (int i = 0; i < NUM_READERS; i++)\n        pthread_create(&readers[i], NULL, reader_thread, NULL);\n    for (int i = 0; i < NUM_WRITERS; i++) {\n        ids[i] = i;\n        pthread_create(&writers[i], NULL, writer_thread, &ids[i]);\n    }\n    for (int i = 0; i < NUM_WRITERS; i++) pthread_join(writers[i], NULL);\n    for (int i = 0; i < NUM_READERS; i++) pthread_join(readers[i], NULL);\n    printf(\"\\n=== Verification ===\\n\");\n    int pass = 1;\n    for (int i = 0; i < NUM_WRITERS; i++) {\n        uint8_t fill = (uint8_t)('A' + i);\n        printf(\"Writer %d (0x%02X '%c'): wrote %lu, read %lu â€” %s\\n\",\n               i, fill, (char)fill,\n               (unsigned long)bytes_written[i],\n               (unsigned long)bytes_read_by_value[fill],\n               bytes_written[i] == bytes_read_by_value[fill] ? \"PASS\" : \"FAIL\");\n        if (bytes_written[i] != bytes_read_by_value[fill]) pass = 0;\n    }\n    printf(\"\\n%s\\n\", pass ? \"ALL CHECKS PASSED\" : \"SOME CHECKS FAILED\");\n    return pass ? 0 : 1;\n}\n```\nCompile and run:\n```bash\ngcc -Wall -Werror -pthread -o stress_c stress_c.c\nsudo insmod mydevice.ko\nsudo chmod 666 /dev/mydevice   # or run as root\nsudo ./stress_c\n# Watch for kernel panics/oops during the test:\ndmesg -w &\n```\n---\n## Three-Level View: Blocking Read in Depth\nWhen process A calls `read()` on your empty device and blocks, while process B writes data:\n**Level 1 â€” Applications**:\nProcess A calls `read(fd, buf, 100)` â€” blocks. Process B calls `write(fd, data, 50)` â€” completes immediately. Process A's `read()` returns 50 bytes.\n**Level 2 â€” Kernel / Scheduler**:\nProcess A calls `sys_read` â†’ `mydev_read` â†’ finds `buffer_used == 0` â†’ releases `dev_mutex` â†’ calls `wait_event_interruptible(read_queue, ...)` â†’ sets state `TASK_INTERRUPTIBLE` â†’ calls `schedule()`. The scheduler removes A from the run queue and runs another task.\nProcess B calls `sys_write` â†’ `mydev_write` â†’ acquires `dev_mutex` â†’ copies 50 bytes â†’ sets `buffer_used = 50` â†’ calls `wake_up_interruptible(&read_queue)`. This sets A's state back to `TASK_RUNNING` and places A on the run queue. B releases the mutex and returns.\nThe scheduler eventually selects A to run. A resumes inside `wait_event_interruptible`, re-acquires `dev_mutex`, re-checks `buffer_used > 0` (now true), exits the wait loop, copies 50 bytes to userspace via `copy_to_user`, returns 50.\n**Level 3 â€” Hardware**:\nWhen `schedule()` is called, the CPU performs a **context switch**: saves the current register state (instruction pointer, stack pointer, general-purpose registers, FPU state if dirty) to process A's `thread_struct` in its `task_struct`. Loads process B's saved register state. Switches the page table base register (`CR3` on x86_64) to B's page directory. The TLB is largely flushed (with PCID optimization, partially invalidated). Process B's code now runs from where it last left off.\nThe `wake_up_interruptible()` call generates a **store-release** memory barrier before adding A back to the run queue, ensuring the `buffer_used = 50` write is visible to all CPUs before A might observe it. On x86, this is a `LOCK` prefixed instruction; on ARM64, it's an explicit `stlr` (store-release) or `dmb` (data memory barrier). Without this, A might wake up and read a stale `buffer_used` value from its cache.\n---\n## Hardware Soul: The Cache Line Dance\nEvery time your write handler executes `buffer_used += bytes_to_copy` and then calls `wake_up_interruptible`, a specific sequence of cache events fires:\n**`buffer_used` access** (a `size_t` at some address in BSS):\n- Write handler running on CPU 0 has the cache line containing `buffer_used` in **M (Modified) state** in CPU 0's L1 cache\n- If CPU 1 is simultaneously in the read handler checking `buffer_used`, the MESI protocol requires CPU 0's L1 to supply the value to CPU 1 via the L3 (shared last-level cache) or inter-processor communication. This cache line invalidation and transfer costs ~40-100 ns on modern x86 â€” cheap for one access, expensive if done millions of times per second\n**`kernel_buffer` writes** (the actual data bytes):\n- Sequential writes to `kernel_buffer + buffer_used` at offsets 0, 32, 64, etc. are perfectly cache-friendly â€” the hardware prefetcher detects the sequential access pattern and brings cache lines ahead of the write pointer. With a 4KB buffer, the entire buffer fits in L1 cache (typically 32KB, so 1/8 full)\n- `copy_from_user` on x86_64 uses `rep movsb` for this size, which the hardware optimizes as a fast string copy with near-peak memory bandwidth\n**`wake_up_interruptible`** accesses the wait queue head (`read_queue`):\n- The spinlock inside the wait queue head must be acquired. On a multicore system where many processes might be calling `read()` simultaneously, this spinlock is a potential contention point. The lock acquisition uses `lock xchg` or `lock cmpxchg`, requiring exclusive cache line ownership â€” this bounces the cache line between cores if multiple cores try to acquire it simultaneously\n- For your driver at moderate concurrency (4-8 processes), this is negligible. At thousands of operations per second on 64 cores, this would be the bottleneck\n**Context switches** (when a reader goes to sleep and a writer wakes it):\n- A context switch saves/restores ~200 bytes of register state to the `task_struct`. The `task_struct` itself is typically in L2 or L3 cache for recently-active tasks. A full context switch costs ~2-4 Âµs on modern hardware, dominated by cache pollution from loading the new process's working set, TLB refill (even with PCID, some entries are invalidated), and pipeline flushing\n---\n## Common Pitfalls in Concurrent Kernel Code\n### Holding a Mutex While Sleeping in `wait_event_interruptible`\n```c\n/* DEADLY DEADLOCK â€” do not do this */\nmutex_lock(&dev_mutex);\nwait_event_interruptible(read_queue, buffer_used > 0);\n/* The writer needs dev_mutex to update buffer_used.\n   The writer calls mutex_lock(&dev_mutex) â€” blocks.\n   Reader waits for buffer_used to change â€” which requires writer to run.\n   Writer waits for mutex â€” which reader holds.\n   Classic circular wait = deadlock. Machine hangs. */\n```\nThe fix is always: release the mutex before waiting, reacquire after.\n### Not Re-checking the Condition After Waking (Manual Wait Loop)\nIf you implement a manual wait loop instead of `wait_event_interruptible`:\n```c\n/* BUGGY â€” spurious wakeup not handled */\nmutex_unlock(&dev_mutex);\nwait_event_interruptible(read_queue, buffer_used > 0);\nmutex_lock(&dev_mutex);\n/* WARNING: another reader might have consumed all data between\n   the wakeup and our mutex_lock. buffer_used might now be 0 again.\n   We must re-check! */\n/* CORRECT */\nmutex_unlock(&dev_mutex);\nif (wait_event_interruptible(read_queue, buffer_used > 0))\n    return -ERESTARTSYS;\nmutex_lock(&dev_mutex);\n/* wait_event_interruptible guarantees the condition is true when it\n   returns 0, because it re-checks under the wait queue's internal lock. */\n```\n### Returning 0 Instead of -EAGAIN for Non-Blocking Empty Read\n```c\n/* WRONG â€” 0 signals EOF; programs like cat will exit normally */\nif (filp->f_flags & O_NONBLOCK)\n    return 0;   /* wrong! cat thinks the \"file\" is done */\n/* CORRECT */\nif (filp->f_flags & O_NONBLOCK)\n    return -EAGAIN;  /* \"no data now, try later\" */\n```\n`0` from `read()` means **end of file** â€” there will never be more data. `-EAGAIN` (as `errno = EAGAIN`) means \"no data now, but there might be later.\" These have completely different semantics to userspace programs. Returning 0 for an empty device means `cat` exits, poll-based event loops deregister the fd, and `read()` loops terminate. `-EAGAIN` means \"keep the fd alive, check again.\"\n### Calling `poll_wait()` After the Condition Check\n```c\n/* WRONG â€” race window between condition check and registration */\nmutex_lock(&dev_mutex);\nif (buffer_used > 0)\n    mask |= POLLIN;\nmutex_unlock(&dev_mutex);\npoll_wait(filp, &read_queue, wait);  /* â† too late! wakeup could have been missed */\nreturn mask;\n/* CORRECT â€” register first, then check */\npoll_wait(filp, &read_queue, wait);  /* register interest first */\nmutex_lock(&dev_mutex);\nif (buffer_used > 0)\n    mask |= POLLIN;\nmutex_unlock(&dev_mutex);\nreturn mask;\n```\n### Not Using `mutex_lock()` (Non-Interruptible) in `.poll`\nThe `.poll` handler must return a mask â€” it cannot return an error code like `-ERESTARTSYS`. If you use `mutex_lock_interruptible()` in `.poll` and a signal arrives, you can't correctly signal this to the caller. Use `mutex_lock()` (non-interruptible) in `.poll`. The critical section in `.poll` is intentionally short (just reading two variables), so the wait should be microseconds at most.\n### Forgetting to Wake `write_queue` After Read\n```c\n/* INCOMPLETE â€” writers sleeping on a full buffer never wake after a read */\nstatic ssize_t mydev_read(...)\n{\n    /* ... read bytes ... */\n    atomic_inc(&read_count);\n    mutex_unlock(&dev_mutex);\n    return bytes_to_copy;\n    /* MISSING: wake_up_interruptible(&write_queue) */\n}\n```\nIf the buffer was full before the read, writers are sleeping on `write_queue`. After the read frees space, you must call `wake_up_interruptible(&write_queue)` or writers remain asleep indefinitely. Always wake the opposite queue after modifying `buffer_used`.\n---\n## Knowledge Cascade: What You've Just Unlocked\n**â†’ Process States Explain Load Average (cross-domain: system administration)**\nNow you understand that `wait_event_interruptible` puts processes in `TASK_INTERRUPTIBLE` (`S` state), while `wait_event` (uninterruptible) uses `TASK_UNINTERRUPTIBLE` (`D` state). Linux's load average counts both `R` and `D` processes â€” which is why a disk-bound server shows high load average at 0% CPU. When `top` shows many `D` processes, they're waiting in uninterruptible sleep (typically for disk or network I/O). When `top` shows many `S` processes (like your readers sleeping on an empty device), they contribute 0 to load average because they're interruptibly sleeping. This is a subtle but important distinction: a server running your blocking-read device will show `S`-state processes during blocking reads, not `D`-state, so it won't inflate load average. A disk driver using `wait_event` (uninterruptible) *will* inflate load average.\n**â†’ -ERESTARTSYS Connects to the signal-handler Prerequisite (same domain: kernel signal path)**\nIn your `signal-handler` prerequisite project, you encountered `errno == EINTR` when a signal interrupted a syscall. Now you know the mechanism: your driver returned `-ERESTARTSYS`, the kernel's syscall exit path detected a pending signal, and if `SA_RESTART` wasn't set on the signal handler, it converted `-ERESTARTSYS` to `-EINTR` before returning to userspace. This is why `EINTR`-safe loops in C (wrapping `read()` in a `do { n = read(...); } while (n < 0 && errno == EINTR)`) are necessary: your driver is correctly propagating signal interruption, and userspace needs to decide whether to restart or handle it.\n**â†’ Your .poll Handler Is the Foundation of Every Event Loop (cross-domain: Node.js, nginx, Go)**\nThe `poll_wait()` registration mechanism you just implemented is exactly what `epoll` uses internally. When an epoll fd monitors your device with `epoll_ctl(epfd, EPOLL_CTL_ADD, devfd, ...)`, the kernel calls your `.poll` handler via `ep_item_poll()`. Your `poll_wait()` registers epoll's internal wait queue callback with `read_queue` and `write_queue`. When your write handler calls `wake_up_interruptible(&read_queue)`, it fires the epoll callback, which wakes the `epoll_wait()` call, which returns the device fd as ready. This is the O(1) event notification that makes `epoll` scale to millions of file descriptors: no polling loop, just wait queue callbacks. Node.js's `libuv`, Go's `netpoller`, and nginx all sit on top of this exact mechanism. The `.poll` handler you just wrote is the leaf node in a chain that enables all modern high-performance I/O.\n**â†’ Your Driver Is Now a Go Channel (cross-domain: concurrent programming)**\nThe bounded buffer you just built â€” with a mutex protecting shared state, blocking producers when full, blocking consumers when empty, and waking the other side on state change â€” is the exact implementation of a **Go buffered channel** (`make(chan T, N)`). The Go runtime implements channels with a mutex, a wait queue for senders (your `write_queue`), and a wait queue for receivers (your `read_queue`). Java's `ArrayBlockingQueue`, Python's `queue.Queue`, and POSIX pipes all implement this same producer-consumer pattern. When you next read Go's channel implementation in `runtime/chan.go`, you'll see `sudog` (waiting goroutine descriptors) in a send/receive queue â€” the Go-level equivalent of your `wait_queue_entry_t` instances in `read_queue` and `write_queue`. The kernel C implementation you just wrote is the conceptual ancestor of all of them.\n**â†’ Thundering Herd Explains nginx's accept_mutex and Linux 4.5's EPOLLEXCLUSIVE (cross-domain: web servers)**\nThe thundering herd you encountered with `wake_up_interruptible` waking all readers is the exact problem that afflicted early multi-process web servers: when a new TCP connection arrives, all worker processes (sleeping in `accept()`) wake up, but only one gets the connection. The others re-sleep after doing useless work. nginx added `accept_mutex` to serialize connection acceptance. Linux 4.5 added `EPOLLEXCLUSIVE` to epoll â€” when multiple processes epoll-wait on the same fd with `EPOLLEXCLUSIVE`, only one is woken per event. For your device, `wake_up_interruptible_nr(&read_queue, 1)` would wake exactly one reader â€” appropriate if the device is pipe-like (one reader gets all the bytes). `wake_up_interruptible` (all waiters) is appropriate if the device is broadcast-like. The choice of which wake mechanism to use is an architectural decision about your device's concurrency semantics.\n**â†’ Kernel Synchronization Patterns â†’ Database Locking (cross-domain: databases)**\nThe pattern you just implemented â€” \"acquire lock, check condition, release lock, sleep, re-acquire lock, re-check condition\" â€” is identical to how database engines implement row-level blocking waits. PostgreSQL's `LockAcquire()` function uses a heavyweight lock mechanism with a wait list; `LockRelease()` calls `ProcWakeup()` to wake a waiting process â€” exactly your `wake_up_interruptible` after modifying `buffer_used`. MySQL's InnoDB uses a similar structure with `lock_wait_suspend_thread()` corresponding to your `wait_event_interruptible`. The concurrency primitives you just implemented in 200 lines of C are the conceptual foundation of MVCC, row locking, and deadlock detection in every major database.\n---\n## Acceptance Criteria Checkpoint\nBefore declaring this milestone complete, verify every item:\n- [ ] `make` completes with zero warnings (`ccflags-y := -Werror`)\n- [ ] `DEFINE_MUTEX(dev_mutex)` declared at module level; `DECLARE_WAIT_QUEUE_HEAD(read_queue)` and `DECLARE_WAIT_QUEUE_HEAD(write_queue)` declared\n- [ ] Every access to `kernel_buffer`, `buffer_used`, `buffer_size_bytes` in read/write/ioctl handlers is protected by `mutex_lock`/`mutex_unlock`\n- [ ] Write handler calls `mutex_lock_interruptible` and propagates `-ERESTARTSYS` on signal during mutex wait\n- [ ] Read handler blocks with `wait_event_interruptible(read_queue, buffer_used > *f_pos)` when buffer has no unread data\n- [ ] `wait_event_interruptible` return value checked; `-ERESTARTSYS` propagated to userspace\n- [ ] Write handler calls `wake_up_interruptible(&read_queue)` after adding data\n- [ ] Read handler calls `wake_up_interruptible(&write_queue)` after consuming data\n- [ ] `filp->f_flags & O_NONBLOCK` checked in both read and write handlers before blocking\n- [ ] Non-blocking read returns `-EAGAIN` (not 0, not -EINTR) when buffer has no unread data\n- [ ] Non-blocking write returns `-EAGAIN` when buffer is full\n- [ ] `.poll` file operation implemented with `poll_wait()` called before condition checks\n- [ ] `.poll` registers both `read_queue` and `write_queue` with `poll_wait()`\n- [ ] `.poll` returns `POLLIN | POLLRDNORM` when `buffer_used > 0`\n- [ ] `.poll` returns `POLLOUT | POLLWRNORM` when `buffer_used < buffer_size_bytes`\n- [ ] `poll()` or `select()` in userspace correctly detects readiness transitions (emptyâ†’data, fullâ†’space)\n- [ ] Stress test with 4 concurrent writers and 4 concurrent readers completes without kernel oops, panics, or dmesg warnings\n- [ ] Stress test verifies byte counts: total bytes written by all writers equals total bytes read by all readers\n- [ ] `Ctrl+C` during a blocking read terminates the process cleanly (read returns -EINTR to userspace) without leaving the device in a corrupted state\n- [ ] After `rmmod` during active polling: device removal does not panic; polling processes receive an error and exit cleanly\n<!-- END_MS -->\n\n\n## System Overview\n\n![System Overview](./diagrams/system-overview.svg)\n\n\n\n\n# TDD\n\nA progressive, four-milestone build of a production-quality Linux character device driver. Each module compiles independently yet feeds the next. The architecture centers on the kernel-userspace boundary: every struct layout, every lock ordering, every syscall dispatch path, and every cache line touched must be explicitly specified. Hardware soul analysis is mandatory for all I/O paths. The final driver supports concurrent multi-process access with mutex serialization, wait-queue blocking, O_NONBLOCK semantics, and poll/select integrationâ€”matching the architecture of /dev/tty, /dev/random, and real hardware drivers.\n\n\n\n<!-- TDD_MOD_ID: build-kernel-module-m1 -->\n# MODULE SPECIFICATION: Hello World Kernel Module (build-kernel-module-m1)\n\n## 1. Module Charter\nThis module establishes the foundational execution environment for a Linux kernel driver. It implements a Loadable Kernel Module (LKM) capable of being dynamically linked into the running kernel image. The module provides a lifecycle skeleton using the `module_init` and `module_exit` macros, handles kernel-level logging via the `printk` ring buffer, and exposes configurable state through the `module_param` system.\n\n**What it DOES:**\n*   Defines the entry and exit points for the kernel's module loader.\n*   Declares critical metadata (License, Author, Description) required for symbol resolution and `modinfo` inspection.\n*   Implements a sysfs-backed parameter (`buffer_size`) with load-time and runtime visibility.\n*   Performs input validation on module parameters during the initialization phase.\n*   Utilizes section annotations (`__init`, `__exit`) to optimize kernel memory footprint.\n\n**What it does NOT do:**\n*   It does not register a character device or allocate major/minor numbers (reserved for M2).\n*   It does not perform any userspace data transfer (no `copy_to_user`).\n*   It does not interact with hardware interrupts or DMA.\n\n**Invariants:**\n*   The module must never return a positive value from the initialization function.\n*   The `MODULE_LICENSE` must be set to a GPL-compatible string to ensure access to `EXPORT_SYMBOL_GPL` symbols in subsequent milestones.\n*   The module must be compiled against headers exactly matching the target kernel's `vermagic`.\n\n## 2. File Structure\nThe project follows the standard Linux out-of-tree module structure.\n\n```text\nbuild-kernel-module/\nâ”œâ”€â”€ 1. Makefile            # Kbuild delegation file\nâ”œâ”€â”€ 2. hello.c             # Primary module source\nâ””â”€â”€ 3. verify.sh           # Automated verification script (bash)\n```\n\n## 3. Complete Data Model\n\n### 3.1 Module Parameters\nThe module manages a single piece of global state exposed via `module_param`.\n\n| Variable Name | Type | Size | Permissions | Default | Constraints |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| `buffer_size` | `int` | 4 Bytes | `0644` (S_IRUGO \\| S_IWUSR) | `4096` | `1 <= val <= 1048576` |\n\n### 3.2 ELF Section Layout (Internal)\nThe compiler and linker will organize the module's object code into specific sections. Understanding these is mandatory for systems-level debugging.\n\n| Section Name | Content Type | Alignment | Lifecycle Notes |\n| :--- | :--- | :--- | :--- |\n| `.text` | Exit and helper code | 16B | Resident for module lifetime |\n| `.init.text` | `hello_init` function | 16B | **Freed** by kernel after successful init |\n| `.exit.text` | `hello_exit` function | 16B | Discarded if module is built-in (non-LKM) |\n| `.data` | `buffer_size` variable | 8B/64B | Resident; modified via sysfs |\n| `.modinfo` | Metadata strings | 1B | Read by `modinfo` and kernel loader |\n| `__param` | `kernel_param` structs | 8B (64-bit) | Metadata for `module_param` linking |\n\n### 3.3 Hardware Soul: Memory & Cache\n*   **Memory Residency**: The `.init.text` section is placed in a temporary page range. Upon `hello_init` returning 0, the kernel calls `free_initmem()` (or equivalent module-level cleanup), marking these pages as available. Any attempt to jump to the init function address after this results in an invalid instruction fault.\n*   **Cache Alignment**: While this module is small, the `buffer_size` variable is stored in the `.data` section. In a high-concurrency environment (multi-core), this variable would occupy a single 64-byte cache line. Access via sysfs (`cat /sys/module/...`) requires a cross-CPU cache invalidation if the value was recently modified on another core.\n*   **TLB Impact**: Loading a module requires allocating pages in the kernel's virtual address space (above `PAGE_OFFSET`). This populates the Kernel Page Tables, potentially requiring a TLB flush on older hardware or an update to the global kernel page directory.\n\n## 4. Interface Contracts\n\n### 4.1 Module Entry Point\n```c\nstatic int __init hello_init(void);\n```\n*   **Purpose**: Validates environment and parameters; registers the module with the kernel.\n*   **Constraints**: Must be marked `static` and `__init`.\n*   **Input**: Implicitly reads the global `buffer_size` (populated by the module loader from `insmod` arguments).\n*   **Returns**: \n    *   `0`: Success.\n    *   `-EINVAL`: `buffer_size` is out of bounds (<= 0 or > 1MB).\n    *   Other negative `errno` codes if internal registration (not present in M1) fails.\n\n### 4.2 Module Exit Point\n```c\nstatic void __exit hello_exit(void);\n```\n*   **Purpose**: Cleans up resources. In M1, only emits a log message.\n*   **Constraints**: Must be marked `static` and `__exit`.\n*   **Pre-condition**: Only called if `hello_init` returned `0`.\n*   **Post-condition**: The module is removed from the `modules` list and its memory is unmapped.\n\n### 4.3 Kernel Logging (`printk`)\n*   **Mechanism**: Writes to the `log_buf` circular buffer.\n*   **Log Level**: `KERN_INFO` (`\"\\0016\"`) must be used for standard messages.\n*   **Log Level**: `KERN_ERR` (`\"\\0013\"`) must be used for parameter validation failures.\n\n## 5. Kbuild Makefile Specification\nStandard Makefiles cannot build kernel modules because specific flags (e.g., `-D__KERNEL__`, `-fno-pic`, `-mno-red-zone`) are required to prevent userspace ABI pollution.\n\n```makefile\n# Variables\nOBJ_NAME := hello\nKDIR := /lib/modules/$(shell uname -r)/build\nPWD := $(shell pwd)\n\n# Kbuild logic: obj-m defines the module to be built\nobj-m += $(OBJ_NAME).o\n\nall:\n\t$(MAKE) -C $(KDIR) M=$(PWD) modules\n\nclean:\n\t$(MAKE) -C $(KDIR) M=$(PWD) clean\n\n# Prevent warnings from being ignored\nccflags-y := -Werror -Wall\n```\n\n## 6. Algorithm Specification: Module Lifecycle\n\n### 6.1 Initialization and Validation Loop\n1.  **Entry**: The kernel module loader (`kernel/module.c`) maps the `.ko` file into kernel memory.\n2.  **Symbol Resolution**: The loader resolves the address of `printk` and other kernel symbols.\n3.  **Param Population**: The loader parses the command line string (e.g., `buffer_size=8192`) and writes the value to the `buffer_size` variable in the module's `.data` section.\n4.  **Init Call**: The loader executes the function registered via `module_init()`.\n5.  **Validation Step**:\n    *   `IF (buffer_size <= 0 OR buffer_size > 1048576)`:\n        *   Call `printk(KERN_ERR \"hello: Invalid buffer_size %d\\n\", buffer_size);`\n        *   `RETURN -EINVAL;`\n6.  **Success Step**:\n    *   Call `printk(KERN_INFO \"hello: Module loaded with buffer_size=%d\\n\", buffer_size);`\n    *   `RETURN 0;`\n7.  **Post-Init**: The kernel looks at the `.init.text` section and frees it.\n\n### 6.2 Exit Sequence\n1.  **Trigger**: User executes `rmmod hello`.\n2.  **Refcount Check**: The kernel checks if any other module or process depends on `hello`. If count > 0, return `-EBUSY`.\n3.  **Exit Call**: The kernel executes the function registered via `module_exit()`.\n4.  **Logging**: Call `printk(KERN_INFO \"hello: Module unloaded\\n\");`.\n5.  **Unlinking**: The kernel removes the module from the sysfs hierarchy and unmaps the memory pages.\n\n## 7. Error Handling Matrix\n\n| Error Condition | Detected By | Recovery Action | User-Visible Effect |\n| :--- | :--- | :--- | :--- |\n| `buffer_size < 1` | `hello_init` | Return `-EINVAL` | `insmod` fails; error in `dmesg` |\n| `buffer_size > 1M` | `hello_init` | Return `-EINVAL` | `insmod` fails; error in `dmesg` |\n| Missing `MODULE_LICENSE` | Kernel Loader | Taint kernel; block GPL symbols | Warning in `dmesg`; load may fail later |\n| Version Mismatch | `modpost` / Loader | Refuse load | `Exec format error` / `vermagic` mismatch |\n| `kmalloc` failure (future) | `hello_init` | Return `-ENOMEM` | `insmod` fails |\n\n## 8. Implementation Sequence with Checkpoints\n\n### Phase 1: Skeleton & Kbuild (1.0 Hours)\n1.  Install kernel headers: `sudo apt install linux-headers-$(uname -r)`.\n2.  Create `Makefile` with `obj-m`.\n3.  Create `hello.c` with empty `module_init`/`module_exit`.\n4.  **Checkpoint**: Run `make`. `hello.ko` should be generated. Run `modinfo hello.ko` and verify it shows as a kernel object.\n\n### Phase 2: Metadata & Logging (1.0 Hours)\n1.  Add `MODULE_LICENSE(\"GPL\")`, `MODULE_AUTHOR`, and `MODULE_DESCRIPTION`.\n2.  Add `printk(KERN_INFO ...)` to init and exit functions.\n3.  **Checkpoint**: `sudo insmod hello.ko`. Run `dmesg | tail`. You should see the \"Module loaded\" message. Run `sudo rmmod hello` and check `dmesg` for the \"unloaded\" message.\n\n### Phase 3: Parameters & Validation (1.0 Hours)\n1.  Define `static int buffer_size = 4096;`.\n2.  Add `module_param(buffer_size, int, 0644);` and `MODULE_PARM_DESC`.\n3.  Implement the range check (1 to 1MB) in `hello_init`.\n4.  **Checkpoint**: `sudo insmod hello.ko buffer_size=1024`. Check `/sys/module/hello/parameters/buffer_size`. It should read `1024`. Try `sudo insmod hello.ko buffer_size=0`; it should fail with `Invalid argument`.\n\n### Phase 4: Verification Automation (1.0 Hours)\n1.  Write `verify.sh` to automate the tests in Phase 3.\n2.  Ensure script checks `dmesg` output and sysfs presence.\n3.  **Checkpoint**: `./verify.sh` returns \"All tests passed.\"\n\n## 9. Test Specification\n\n### 9.1 Functional Tests\n*   **Happy Path 1**: Load with default params.\n    *   `insmod hello.ko` -> success.\n    *   `dmesg` contains \"loaded\".\n    *   `/sys/.../buffer_size` is 4096.\n*   **Happy Path 2**: Load with custom param.\n    *   `insmod hello.ko buffer_size=8192` -> success.\n    *   `/sys/.../buffer_size` is 8192.\n*   **Edge Case**: Maximum value.\n    *   `insmod hello.ko buffer_size=1048576` -> success.\n*   **Failure Case 1**: Below minimum.\n    *   `insmod hello.ko buffer_size=0` -> returns `1` (errno `EINVAL`).\n*   **Failure Case 2**: Above maximum.\n    *   `insmod hello.ko buffer_size=2000000` -> returns `1` (errno `EINVAL`).\n\n### 9.2 Metadata Validation\n*   Run `modinfo hello.ko`.\n*   Verify `license` is `GPL`.\n*   Verify `parm` description is present.\n\n## 10. Performance Targets\n\n| Operation | Target Metric | Measurement Tool |\n| :--- | :--- | :--- |\n| Load Latency | < 10ms | `time sudo insmod hello.ko` |\n| Memory Footprint | < 4KB (after init) | `lsmod` (size column) |\n| Log Latency | < 500ns per printk | Kernel ftrace / timestamp diff |\n| Build Time | < 2s | `time make` |\n\n## 11. State Machine: Module Lifecycle\n\n```text\n[ UNLOADED ] \n      |\n      | (insmod / finit_module syscall)\n      v\n[ LOADING ] --> (Validation Fails) --> [ UNLOADED (+ dmesg error) ]\n      |\n      | (Validation Passes, init returns 0)\n      v\n[ RUNNING ] \n      |\n      | (rmmod / delete_module syscall)\n      v\n[ UNLOADING ] \n      |\n      | (exit function finishes)\n      v\n[ UNLOADED ]\n```\n\n## 12. Security & Constraints\n*   **Parameter Permissions**: `0644` is used. This allows root to change the parameter at runtime via `echo X > /sys/...`. The module must be prepared for this variable to change (though in M1, no logic depends on it after init). In production drivers, runtime changes often require a `mutex` or `notifier` to handle state transition safely.\n*   **Kernel Tainting**: Omitting `MODULE_LICENSE(\"GPL\")` will mark the kernel as \"Tainted: P\". This prevents the kernel community from debugging any oops your module might cause and limits API access.\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-kernel-module-m2 -->\n# MODULE SPECIFICATION: Character Device Driver (build-kernel-module-m2)\n\n## 1. Module Charter\nThis module implements a Linux character device driver, providing a structured gateway between userspace processes and kernel memory. It transitions the project from a simple \"Hello World\" module to a functional system component that adheres to the Virtual File System (VFS) interface.\n\n**What it DOES:**\n*   Dynamically reserves a character device major/minor number range via `alloc_chrdev_region`.\n*   Connects kernel logic to the standard filesystem namespace using `struct cdev` and `file_operations`.\n*   Triggers automatic `/dev/node` creation using the kernel's class and device uevent infrastructure (udev integration).\n*   Manages a physically contiguous 4KB kernel buffer via the SLUB allocator.\n*   Enforces strict memory safety at the kernel-userspace boundary using `copy_to_user` and `copy_from_user` (exception-table based crossing).\n*   Tracks file positions (`f_pos`) to support sequential reading and end-of-file (EOF) semantics.\n*   Maintains a thread-safe (SMP-safe) open-instance counter using `atomic_t`.\n\n**What it does NOT do:**\n*   It does NOT implement custom control codes (ioctl), which are reserved for Milestone 3.\n*   It does NOT implement process synchronization or blocking I/O (mutexes/wait queues), which are reserved for Milestone 4.\n*   It does NOT support `llseek` (random access is ignored; sequential only).\n\n**Invariants:**\n*   **Safety**: Userspace pointers MUST NEVER be directly dereferenced.\n*   **Cleanup**: Every successful kernel resource allocation (region, cdev, class, device, memory) must be explicitly undone in reverse order during module exit or error unwinding.\n*   **Boundary**: The `read` handler must return `0` when `*f_pos` reaches the current buffer usage to prevent userspace infinite loops.\n\n## 2. File Structure\nThe implementation follows the Linux Kernel Coding Style (Tabs, 8-character width).\n\n```text\nbuild-kernel-module/\nâ”œâ”€â”€ 1. Makefile            # Kbuild delegation with ccflags-y := -Werror\nâ”œâ”€â”€ 2. mychar_dev.c        # Main driver implementation\nâ”œâ”€â”€ 3. test_driver.sh      # Shell-based verification (echo/cat/dd)\nâ””â”€â”€ 4. mychar_dev.h        # Internal driver constants and structure definitions\n```\n\n## 3. Complete Data Model\n\n### 3.1 Device Private Structure (`struct my_device_data`)\nTo avoid global variable sprawl and prepare for multi-device support, we encapsulate the device state in a single structure.\n\n| Field Name | Type | Size | Offset | Purpose |\n| :--- | :--- | :--- | :--- | :--- |\n| `cdev` | `struct cdev` | ~104B | 0x00 | The kernel's character device abstraction (vtable holder). |\n| `buffer` | `char *` | 8B | 0x68 | Pointer to the 4KB kernel-resident data buffer. |\n| `buffer_used` | `size_t` | 8B | 0x70 | Current number of valid bytes stored in the buffer. |\n| `open_count` | `atomic_t` | 4B | 0x78 | SMP-safe counter of active file descriptors. |\n| `device_major` | `int` | 4B | 0x7C | Major number assigned by the kernel. |\n| `class` | `struct class *` | 8B | 0x80 | Pointer to the sysfs class for udev node creation. |\n\n**Hardware Soul: Cache Line Analysis (64B)**\n*   The `struct my_device_data` spans approximately 136 bytes (roughly 2.1 cache lines).\n*   **False Sharing Alert**: In M2, we do not use a mutex, but `open_count` is modified frequently. On a multi-core system, if `open_count` resides on the same cache line as `buffer_used`, an `atomic_inc` on one core will invalidate the cache line for a core attempting to read `buffer_used`.\n*   **Packing**: We place `atomic_t` near the end. `struct cdev` is large and contains its own internal locks/pointers.\n\n### 3.2 VFS Interaction Model (The VTable)\nThe `struct file_operations` maps the system call interface to our internal functions.\n\n```c\nstatic const struct file_operations my_fops = {\n    .owner   = THIS_MODULE,      // Prevents module unloading while in use\n    .open    = my_open,          // Called on open(\"/dev/mydevice\", ...)\n    .release = my_release,       // Called on close(fd)\n    .read    = my_read,          // Called on read(fd, ...)\n    .write   = my_write,         // Called on write(fd, ...)\n};\n```\n\n### 3.3 Memory Layout: The 4KB Buffer\n*   **Allocator**: `kzalloc(4096, GFP_KERNEL)`.\n*   **Alignment**: The SLUB allocator returns 8-byte aligned memory. 4096 bytes corresponds exactly to one hardware page (`PAGE_SIZE`) on x86_64.\n*   **Physically Contiguous**: `kmalloc` memory is physically contiguous, making it friendly to future DMA operations (though not used here).\n\n## 4. Interface Contracts\n\n### 4.1 System Call Handlers (Kernel Context)\n\n#### `int my_open(struct inode *inode, struct file *filp)`\n*   **Contract**: Called when a process opens the device node.\n*   **Action**: Increments `open_count`. Associates the `struct my_device_data` with `filp->private_data`.\n*   **Return**: `0` (Success).\n\n#### `int my_release(struct inode *inode, struct file *filp)`\n*   **Contract**: Called when the last reference to a file descriptor is closed.\n*   **Action**: Decrements `open_count`.\n*   **Return**: `0`.\n\n#### `ssize_t my_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)`\n*   **Contract**: Transfer data from kernel buffer to userspace.\n*   **Parameters**: \n    *   `buf`: Userspace target address (MUST NOT dereference directly).\n    *   `count`: Requested bytes.\n    *   `f_pos`: Pointer to the current file offset.\n*   **Constraint**: If `*f_pos >= buffer_used`, return `0` (EOF).\n*   **Logic**: `bytes_to_read = min(count, buffer_used - *f_pos)`.\n*   **Return**: Number of bytes successfully copied, or `-EFAULT` on copy failure.\n\n#### `ssize_t my_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)`\n*   **Contract**: Transfer data from userspace to kernel buffer.\n*   **Constraint**: If `buffer_used == 4096`, return `-ENOSPC`.\n*   **Logic**: `bytes_to_write = min(count, 4096 - buffer_used)`.\n*   **Return**: Number of bytes successfully copied, or `-EFAULT` on copy failure.\n\n## 5. Algorithm Specification: The Implementation Path\n\n### 5.1 Module Initialization Sequence (The Goto Unwind)\nThe kernel requires deterministic cleanup for partial failures.\n\n1.  **Allocate Region**: `alloc_chrdev_region(&dev_num, 0, 1, \"mydevice\")`.\n    *   Failure -> `return ret`.\n2.  **Allocate Buffer**: `kzalloc(4096, GFP_KERNEL)`.\n    *   Failure -> `unregister_chrdev_region`; `return -ENOMEM`.\n3.  **Initialize Cdev**: `cdev_init(&my_cdev, &my_fops)`.\n4.  **Add Cdev**: `cdev_add(&my_cdev, dev_num, 1)`.\n    *   Failure -> `kfree(buffer)`; `unregister_chrdev_region`.\n5.  **Create Class**: `class_create(THIS_MODULE, \"my_class\")`.\n    *   Failure -> `cdev_del`; `kfree`; `unregister`.\n6.  **Create Device**: `device_create(my_class, NULL, dev_num, NULL, \"mydevice\")`.\n    *   Failure -> `class_destroy`; `cdev_del`; `kfree`; `unregister`.\n\n### 5.2 Read Handler Algorithm\n1.  **Check Position**: `IF *f_pos >= buffer_used THEN RETURN 0`.\n2.  **Calculate Limit**: `available = buffer_used - *f_pos`.\n3.  **Bound Count**: `to_copy = (count < available) ? count : available`.\n4.  **Copy**: `not_copied = copy_to_user(buf, kernel_buffer + *f_pos, to_copy)`.\n5.  **Fault Check**: `IF not_copied != 0 THEN RETURN -EFAULT`.\n6.  **Update State**: `*f_pos += to_copy`.\n7.  **Return**: `to_copy`.\n\n### 5.3 Write Handler Algorithm\n1.  **Check Space**: `IF buffer_used >= 4096 THEN RETURN -ENOSPC`.\n2.  **Calculate Space**: `available = 4096 - buffer_used`.\n3.  **Bound Count**: `to_copy = (count < available) ? count : available`.\n4.  **Copy**: `not_copied = copy_from_user(kernel_buffer + buffer_used, buf, to_copy)`.\n5.  **Fault Check**: `IF not_copied != 0 THEN RETURN -EFAULT`.\n6.  **Update State**: `buffer_used += to_copy`.\n7.  **Return**: `to_copy`.\n\n## 6. Three-Level View: Hardware Soul\n\n### Level 1 â€” Application (User)\nProcess calls `write(fd, \"data\", 4)`. This triggers the `syscall` instruction (x86_64), switching the CPU to CPL 0 (Kernel Mode) and jumping to the system call entry point.\n\n### Level 2 â€” OS/Kernel (VFS)\nThe VFS looks up the file descriptor in the process's file table, finds the `struct file`, and invokes `file->f_op->write`. Our `my_write` handler executes. It calls `copy_from_user`.\n\n### Level 3 â€” Hardware (CPU/MMU)\n1.  **Exception Table**: The `copy_from_user` assembly contains instructions registered in the kernel's `.ex_table`. \n2.  **TLB Lookup**: The CPU looks up the virtual address of the userspace `buf` in the current CR3 (Page Table Base). \n3.  **Cache Lines**: The kernel buffer (kmalloc'd) is likely in L1/L2. Data is moved in 8-byte or 16-byte chunks (or `rep movsb` optimization).\n4.  **Page Faults**: If the userspace page is swapped out, `copy_from_user` triggers a page fault. The kernel's fault handler swaps the page in and resumes the copy. If the address is invalid, the exception table logic forces `copy_from_user` to return a non-zero value, and we return `-EFAULT`.\n\n## 7. Error Handling Matrix\n\n| Error Condition | Detected By | Recovery Action | User-Visible Effect |\n| :--- | :--- | :--- | :--- |\n| SLUB out of memory | `kzalloc` | Jump to `err_region` (unwind) | `insmod` returns `-ENOMEM` |\n| Bad Userspace Pointer | `copy_to_user` | Return `-EFAULT` | `read()` returns -1, `errno=EFAULT` |\n| Buffer Full | `my_write` | Return `-ENOSPC` | `write()` returns -1, `errno=ENOSPC` |\n| Partial Write | `copy_from_user` | Adjust `buffer_used` by partial | `write()` returns fewer bytes than requested |\n| Device Node Collision | `device_create` | Jump to `err_class` (unwind) | `insmod` fails, node not in `/dev` |\n\n## 8. Implementation Sequence with Checkpoints\n\n### Phase 1: Dynamic Allocation & Cdev (2 Hours)\n1.  Implement `alloc_chrdev_region`. \n2.  Log the Major/Minor in `dmesg`.\n3.  Initialize `struct cdev` and link to `file_operations`.\n4.  **Checkpoint**: `insmod` the module. `grep mydevice /proc/devices` should show the major number.\n\n### Phase 2: Udev Integration (1.5 Hours)\n1.  Add `class_create` and `device_create`.\n2.  Verify cleanup with `class_destroy` and `device_destroy`.\n3.  **Checkpoint**: `insmod` the module. Verify `/dev/mydevice` exists and has `crw-------` permissions (default).\n\n### Phase 3: Memory & Ops (3 Hours)\n1.  Implement `kzalloc` in init.\n2.  Implement `open`/`release` with `atomic_inc`/`atomic_dec`.\n3.  Implement `read` and `write` with `copy_user` functions.\n4.  **Checkpoint**: `echo \"test\" > /dev/mydevice`. `dmesg` should show write logs. `cat /dev/mydevice` should show \"test\".\n\n### Phase 4: Position & Bounds (1.5 Hours)\n1.  Verify `*f_pos` updates correctly.\n2.  Test `ENOSPC` by writing >4096 bytes.\n3.  **Checkpoint**: `dd if=/dev/zero of=/dev/mydevice bs=5000 count=1`. Verify `dd` reports \"No space left on device\" after 4096 bytes.\n\n## 9. Test Specification\n\n### 9.1 Functional Tests\n*   **T1 (Round Trip)**: \n    *   Command: `echo \"kernel\" > /dev/mydevice && cat /dev/mydevice`\n    *   Expected: Output \"kernel\".\n*   **T2 (Positioning)**:\n    *   Command: `echo \"12345678\" > /dev/mydevice && dd if=/dev/mydevice bs=1 skip=4`\n    *   Expected: Output \"5678\".\n*   **T3 (Persistence)**:\n    *   Command: Open the device, write, close. Open again, read.\n    *   Expected: Data persists between opens (device-level buffer).\n*   **T4 (EOF)**:\n    *   Command: `cat /dev/mydevice` (twice).\n    *   Expected: Both calls return the full buffer and terminate.\n\n### 9.2 Boundary Tests\n*   **T5 (Bad Pointer)**: Use a small C program to pass `(char*)0xdeadbeef` to `read()`.\n    *   Expected: `read` returns `-1`, `errno` is `EFAULT`. **NO KERNEL OOPS**.\n*   **T6 (Overflow)**: `python3 -c \"print('A'*5000)\" > /dev/mydevice`.\n    *   Expected: Returns error, buffer contains exactly 4096 'A's.\n\n## 10. Performance Targets\n\n| Operation | Target Metric | How to Measure |\n| :--- | :--- | :--- |\n| Sequential Write Throughput | > 2.0 GB/s | `dd if=/dev/zero of=/dev/mydevice bs=4k count=100000` |\n| Sequential Read Throughput | > 2.0 GB/s | `dd if=/dev/mydevice of=/dev/null bs=4k count=100000` |\n| Latency (Single 64B Write) | < 1.5 Âµs | Userspace clock_gettime() around write() |\n| Syscall Overhead | < 400 ns | `strace -T` on open() |\n\n## 11. Concurrency Specification (Milestone 2 Context)\n*   **Shared Resource**: `kernel_buffer` and `buffer_used`.\n*   **Strategy**: No locks are implemented in M2 for data.\n*   **Risk**: Two processes writing simultaneously will corrupt `buffer_used` and potentially overwrite data.\n*   **Mitigation**: In M2, we use `atomic_t` for `open_count` only to demonstrate SMP-safe primitives. Data synchronization is deferred to Milestone 4.\n\n## 12. Verification Script (`verify_m2.sh`)\n```bash\n#!/bin/bash\nset -e\nMOD=\"mychar_dev\"\nDEV=\"/dev/mydevice\"\n\necho \"Rebuilding...\"\nmake clean > /dev/null && make > /dev/null\n\necho \"Loading module...\"\nsudo insmod ${MOD}.ko\n\n# Verify Major Allocation\nMAJOR=$(awk \"\\$2==\\\"mydevice\\\" {print \\$1}\" /proc/devices)\necho \"Major assigned: $MAJOR\"\n\n# Verify Udev Node\nif [ ! -c \"$DEV\" ]; then\n    echo \"ERROR: /dev node not found!\"\n    exit 1\nfi\n\necho \"Testing data integrity...\"\nDATA=\"SystemLowLevelProgramming\"\necho \"$DATA\" > \"$DEV\"\nRESULT=$(cat \"$DEV\")\n\nif [ \"$DATA\" == \"$RESULT\" ]; then\n    echo \"PASS: Data Round-trip successful.\"\nelse\n    echo \"FAIL: Expected $DATA, got $RESULT\"\nfi\n\necho \"Testing ENOSPC...\"\nset +e\npython3 -c \"print('X'*5000)\" > \"$DEV\" 2> err.txt\nif grep -q \"No space left on device\" err.txt; then\n    echo \"PASS: ENOSPC handled.\"\nelse\n    echo \"FAIL: Overflow allowed or wrong error.\"\nfi\nset -e\n\necho \"Unloading...\"\nsudo rmmod ${MOD}\ndmesg | tail -n 5\n```\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-kernel-module-m3 -->\n# MODULE SPECIFICATION: ioctl and /proc Interface (build-kernel-module-m3)\n\n## 1. Module Charter\nThis module implements the control and introspection planes for the character device driver. While Milestone 2 established the data plane (read/write), Milestone 3 provides structured mechanisms for device management and observability. It introduces an `ioctl` (Input/Output Control) interface for binary command execution and a `/proc` filesystem entry for human-readable state inspection.\n\n**What it DOES:**\n*   Defines a stable Application Binary Interface (ABI) via a shared header file.\n*   Implements `unlocked_ioctl` to handle out-of-band control commands (Clear, Resize, Status).\n*   Utilizes the kernel's command encoding macros (`_IO`, `_IOW`, `_IOR`) to ensure namespace safety and direction validation.\n*   Implements a safe \"allocate-then-swap\" pattern for runtime memory reallocation.\n*   Provides a virtual file in `/proc` using the `seq_file` abstraction to export driver statistics.\n*   Maintains counters for successful read/write operations using `atomic_t`.\n\n**What it does NOT do:**\n*   It does NOT implement concurrency primitives (mutexes/spinlocks); data races between `ioctl` and `read`/`write` are tolerated in this milestone (resolved in M4).\n*   It does NOT support `compat_ioctl` for 32-bit processes on 64-bit kernels (assumes 64-bit parity).\n*   It does NOT support multi-page `/proc` output manually; it delegates this to the `seq_file` iterator.\n\n**Invariants:**\n*   **ABI Stability**: The `struct mydev_status` layout must be identical in kernel and userspace.\n*   **Command Validation**: Any `ioctl` command with a non-matching magic number or out-of-range sequence number must return `-ENOTTY`.\n*   **Memory Safety**: A failed `RESIZE` allocation must leave the original buffer and data intact (Atomic-like failure).\n\n## 2. File Structure\nThe project structure expands to include the shared ABI header and a dedicated userspace test suite.\n\n```text\nbuild-kernel-module/\nâ”œâ”€â”€ 1. Makefile              # Updated Kbuild to include new objects\nâ”œâ”€â”€ 2. mydevice_ioctl.h      # SHARED: ABI definitions (Magic 'M')\nâ”œâ”€â”€ 3. mychar_dev.c          # UPDATED: ioctl and proc handlers\nâ”œâ”€â”€ 4. test_ioctl.c          # NEW: Userspace test program\nâ””â”€â”€ 5. verify_m3.sh          # NEW: Verification script for control plane\n```\n\n## 3. Complete Data Model\n\n### 3.1 ioctl Command Encoding (Wire Format)\nCommands are 32-bit integers. We use Magic Number `'M'` (0x4D).\n\n| Field | Bits | Description |\n| :--- | :--- | :--- |\n| **Direction** | 30-31 | 00: None (`_IO`), 01: Write (`_IOW`), 10: Read (`_IOR`) |\n| **Size** | 16-29 | `sizeof()` the argument type. |\n| **Type** | 08-15 | Magic Number: `0x4D`. |\n| **Number** | 00-07 | Command sequence (0: Clear, 1: Resize, 2: Status). |\n\n### 3.2 ABI Structure: `struct mydev_status`\nThis structure is passed from kernel to userspace via `MYDEV_STATUS`.\n\n| Offset | Field | Type | Size | Description |\n| :--- | :--- | :--- | :--- | :--- |\n| 0x00 | `buffer_size` | `__u32` | 4B | Total capacity of kernel buffer. |\n| 0x04 | `bytes_used` | `__u32` | 4B | Currently occupied bytes. |\n| 0x08 | `open_count` | `__u32` | 4B | Active file descriptors. |\n| 0x0C | `read_count` | `__u32` | 4B | Total successful `read()` calls. |\n| 0x10 | `write_count` | `__u32` | 4B | Total successful `write()` calls. |\n| 0x14 | `_reserved` | `__u32` | 4B | Padding for 8-byte alignment/future use. |\n| **Total** | | | **24B** | **Fits in one 64B cache line.** |\n\n### 3.3 Hardware Soul: Cache & Alignment\n*   **Cache Line Residency**: `struct mydev_status` is 24 bytes. When the kernel fills this on the stack and calls `copy_to_user`, the entire struct likely resides in a single L1 cache line.\n*   **Atomic vs Non-Atomic**: `read_count` and `write_count` are `atomic_t`. On x86_64, `atomic_read` is a simple `mov` instruction, but the `atomic_inc` in the data path (M2) ensures that the values seen by `MYDEV_STATUS` are coherent across CPU cores without requiring a heavy mutex in this milestone.\n\n## 4. Interface Contracts\n\n### 4.1 Header Contract: `mydevice_ioctl.h`\nMust use the `__KERNEL__` guard to switch between kernel-space headers (`linux/types.h`) and userspace headers (`stdint.h`).\n\n```c\n#ifndef MYDEVICE_IOCTL_H\n#define MYDEVICE_IOCTL_H\n\n#ifdef __KERNEL__\n#include <linux/ioctl.h>\n#include <linux/types.h>\n#else\n#include <sys/ioctl.h>\n#include <stdint.h>\ntypedef uint32_t __u32;\n#endif\n\n#define MYDEV_MAGIC 'M'\n\n#define MYDEV_CLEAR  _IO(MYDEV_MAGIC, 0)\n#define MYDEV_RESIZE _IOW(MYDEV_MAGIC, 1, __u32)\n#define MYDEV_STATUS _IOR(MYDEV_MAGIC, 2, struct mydev_status)\n\n#endif \n```\n\n### 4.2 ioctl Handler: `mydev_ioctl`\n```c\nlong mydev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);\n```\n*   **Input**: `cmd` (the encoded request), `arg` (address of userspace data).\n*   **Validation**: \n    *   If `_IOC_TYPE(cmd) != MYDEV_MAGIC` return `-ENOTTY`.\n    *   If `_IOC_NR(cmd) > 2` return `-ENOTTY`.\n*   **Commands**:\n    *   `MYDEV_CLEAR`: `memset(buffer, 0, size)`, `buffer_used = 0`.\n    *   `MYDEV_RESIZE`: See Algorithm 5.1.\n    *   `MYDEV_STATUS`: Fills `struct mydev_status`, `copy_to_user`.\n\n### 4.3 /proc Interface: `seq_file`\nUtilizes the `single_open` helper for simple output.\n*   **File**: `/proc/mydevice`.\n*   **Ops**: `struct proc_ops` (Kernel 5.6+).\n*   **Output**: \n    ```text\n    buffer_size: 4096\n    bytes_used: 128\n    open_count: 1\n    read_count: 42\n    write_count: 10\n    ```\n\n## 5. Algorithm Specification\n\n### 5.1 Allocate-Then-Swap Buffer Resize\nThis algorithm ensures that a failed memory allocation does not corrupt the existing device state.\n\n1.  **Input**: Userspace pointer `arg` containing `__u32 new_size`.\n2.  **Fetch**: `copy_from_user(&new_size, (__u32 __user *)arg, sizeof(new_size))`.\n    *   On failure: `RETURN -EFAULT`.\n3.  **Validate**: `IF new_size == 0 OR new_size > 1048576 THEN RETURN -EINVAL`.\n4.  **Allocate**: `tmp_buf = kzalloc(new_size, GFP_KERNEL)`.\n    *   On failure: `RETURN -ENOMEM`. (Existing buffer/data remains untouched).\n5.  **Truncate**: `copy_len = (buffer_used < new_size) ? buffer_used : new_size`.\n    *   *Invariant*: If shrinking, data beyond `new_size` is discarded.\n6.  **Migrate**: `memcpy(tmp_buf, old_buffer, copy_len)`.\n7.  **Finalize**:\n    *   `kfree(old_buffer)`.\n    *   `buffer = tmp_buf`.\n    *   `buffer_size = new_size`.\n    *   `buffer_used = copy_len`.\n8.  **Return**: `0`.\n\n### 5.2 seq_file Iteration (Logic)\n1.  **Open**: `single_open` is called. It allocates a `struct seq_file`.\n2.  **Read**: `seq_read` is called.\n3.  **Show**: The kernel calls our `my_proc_show` function.\n4.  **Formatting**: We use `seq_printf` to write into the kernel-managed buffer. `seq_file` handles the cases where the output might span multiple 4KB pages by managing an internal offset.\n\n## 6. Error Handling Matrix\n\n| Error | Detected By | Condition | User Effect |\n| :--- | :--- | :--- | :--- |\n| **ENOTTY** | `mydev_ioctl` | Magic mismatch or NR > 2 | `ioctl` returns -1, `errno=ENOTTY` |\n| **EFAULT** | `copy_to_user` | Bad output pointer in `STATUS` | `ioctl` returns -1, `errno=EFAULT` |\n| **EINVAL** | `mydev_ioctl` | `RESIZE` arg is 0 or > 1MB | `ioctl` returns -1, `errno=EINVAL` |\n| **ENOMEM** | `kzalloc` | Kernel cannot find contiguous memory | Buffer remains at old size |\n| **NULL Ptr** | `proc_create` | Internal `/proc` registration failure | `/proc/mydevice` does not appear |\n\n## 7. Implementation Sequence with Checkpoints\n\n### Phase 1: Shared Header & Skeleton (1 Hour)\n1.  Create `mydevice_ioctl.h` with direction macros.\n2.  In `mychar_dev.c`, add `unlocked_ioctl` to `struct file_operations`.\n3.  Implement the Magic Number and Command NR range check.\n4.  **Checkpoint**: Compile and `insmod`. Use a dummy C program to call `ioctl` with magic 'Z'. Verify it returns `ENOTTY`.\n\n### Phase 2: CLEAR & STATUS Commands (2 Hours)\n1.  Add `MYDEV_CLEAR` using `memset`.\n2.  Add `MYDEV_STATUS`. Implement `atomic_inc` for `read_count` and `write_count` in the M2 handlers.\n3.  Implement `copy_to_user` for the status struct.\n4.  **Checkpoint**: Run test program. Verify `STATUS` returns `buffer_size=4096` and `open_count=1`.\n\n### Phase 3: RESIZE Implementation (2.5 Hours)\n1.  Implement the Allocate-then-swap logic.\n2.  Add truncation logic (handle `buffer_used > new_size`).\n3.  Verify that `new_size > 1MB` returns `EINVAL`.\n4.  **Checkpoint**: Resize to 8192. Write data. Resize back to 10. Verify that only 10 bytes remain.\n\n### Phase 4: /proc Filesystem (1.5 Hours)\n1.  Implement `my_proc_show` with `seq_printf`.\n2.  Use `proc_create` in `module_init`. Ensure `proc_remove` in `module_exit`.\n3.  **Checkpoint**: `cat /proc/mydevice`. Verify all counters increment as you perform reads/writes.\n\n## 8. Test Specification\n\n### 8.1 ioctl Functional Tests\n*   **IO-1 (Status Correctness)**:\n    *   Action: Perform 5 reads, 3 writes. Call `MYDEV_STATUS`.\n    *   Verify: `status.read_count == 5`, `status.write_count == 3`.\n*   **IO-2 (Resize Growth)**:\n    *   Action: Resize to 10000. Write 5000 bytes.\n    *   Verify: `write` succeeds for all 5000 bytes.\n*   **IO-3 (Resize Shrink)**:\n    *   Action: Write \"1234567890\" (10 bytes). Resize to 5. Read device.\n    *   Verify: Output is \"12345\".\n\n### 8.2 Observability Tests\n*   **P1 (Proc Visibility)**:\n    *   Action: `cat /proc/mydevice`.\n    *   Verify: Values match the `MYDEV_STATUS` ioctl exactly.\n*   **P2 (Persistence)**:\n    *   Action: Close device, `cat /proc/mydevice`.\n    *   Verify: `open_count` is 0, but `read_count`/`write_count` persist.\n\n## 9. Performance Targets\n\n| Operation | Target | Measurement |\n| :--- | :--- | :--- |\n| **STATUS Latency** | < 400ns | `clock_gettime` around 10k ioctls |\n| **RESIZE (4K->8K)** | < 5Âµs | Kernel `ktime_get()` timestamps |\n| **PROC Read** | < 100Âµs | `time cat /proc/mydevice` |\n| **Memory usage** | 24B struct | `sizeof(struct mydev_status)` |\n\n## 10. Concurrency Specification (M3 Context)\nIn this milestone, we acknowledge a **Race Condition** between `RESIZE` and `read/write`. \n*   **The Risk**: If one thread is executing `memcpy` during a `RESIZE` while another thread is executing `copy_to_user` in `read`, the `old_buffer` may be freed while the reader is accessing it.\n*   **M3 Policy**: For the purposes of this milestone, we accept this race to focus on the ioctl/proc mechanics.\n*   **M4 Preview**: A `mutex` will be introduced in Milestone 4 to serialize all buffer and size access.\n\n## 11. Three-Level View: `RESIZE`\n1.  **Application**: `ioctl(fd, MYDEV_RESIZE, &val)` is called.\n2.  **Kernel**: `unlocked_ioctl` validates the command. It allocates a new page from the SLUB allocator. It copies the user `val` to the stack.\n3.  **Hardware**: The MMU maps the new physical page into the kernel's virtual address space. `memcpy` triggers cache line fills for the old buffer and writes to the new buffer's cache lines.\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-kernel-module-m4 -->\n# MODULE SPECIFICATION: Concurrent Access, Blocking I/O, and Poll Support (build-kernel-module-m4)\n\n## 1. Module Charter\nThis module implements the final, production-grade concurrency and synchronization logic for the character device driver. It transforms a simple memory buffer into a thread-safe, multi-process synchronized resource. It provides full support for blocking I/O (where readers sleep until data is available) and non-blocking I/O (returning `-EAGAIN` via `O_NONBLOCK`). Crucially, it integrates with the kernel's event-multiplexing subsystem (`poll`/`select`/`epoll`) by implementing a `.poll` handler. The module ensures data integrity under heavy contention using `struct mutex` for serialization and `wait_queue_head_t` for scheduler-managed task suspension. It does NOT handle hardware interrupts or asynchronous I/O (AIO), focusing entirely on process-context synchronization and POSIX-compliant file semantics.\n\n**Invariants:**\n- `dev_mutex` must be held during any modification or read of `buffer_used`, `kernel_buffer`, or `buffer_size_bytes`.\n- `dev_mutex` MUST be released before calling `schedule()` or `wait_event_interruptible()` to prevent producer-consumer deadlocks.\n- The `.poll` handler must never sleep and must return a bitmask of readiness.\n- `wake_up_interruptible()` must be called after every state change that could potentially satisfy a waiter's condition.\n\n## 2. File Structure\nThe project files are updated and created in the following order:\n\n```text\nbuild-kernel-module/\nâ”œâ”€â”€ 1. mydevice_ioctl.h      # (Updated) Unchanged from M3\nâ”œâ”€â”€ 2. mychar_dev.c          # (Updated) Core logic with mutex, waitqueues, and poll\nâ”œâ”€â”€ 3. Makefile              # (Updated) Kbuild targeting new stress test binary\nâ”œâ”€â”€ 4. stress_test.c         # (New) Multi-threaded C validation tool\nâ””â”€â”€ 5. verify_m4.sh          # (New) Automated test runner for concurrency\n```\n\n## 3. Complete Data Model\n\n### 3.1 Device Private Structure (`struct my_device_data`)\nWe explicitly define the byte-level layout for an x86_64 architecture. The `struct mutex` and `wait_queue_head_t` sizes are significant.\n\n| Offset | Field | Type | Size | Purpose |\n| :--- | :--- | :--- | :--- | :--- |\n| 0x00 | `cdev` | `struct cdev` | 104B | VFS character device backlink. |\n| 0x68 | `lock` | `struct mutex` | 32B | Serialization lock for buffer and metadata. |\n| 0x88 | `read_queue` | `wait_queue_head_t` | 24B | Queue for readers blocked on empty buffer. |\n| 0xA0 | `write_queue` | `wait_queue_head_t` | 24B | Queue for writers blocked on full buffer. |\n| 0xB8 | `buffer` | `char *` | 8B | Pointer to the heap-allocated data buffer. |\n| 0xC0 | `size` | `size_t` | 8B | Total capacity of the buffer. |\n| 0xC8 | `used` | `size_t` | 8B | Bytes currently stored. |\n| 0xD0 | `open_count` | `atomic_t` | 4B | SMP-safe open instance counter. |\n| 0xD4 | `read_ops` | `atomic_t` | 4B | Statistics: Total successful reads. |\n| 0xD8 | `write_ops` | `atomic_t` | 4B | Statistics: Total successful writes. |\n| 0xDC | (Padding) | | 4B | Alignment to 8-byte boundary. |\n| **Total** | | | **224B** | **Spans ~3.5 Cache Lines (64B each).** |\n\n### 3.2 Hardware Soul: Cache and Lock Contention\n*   **Cache Line Bouncing**: The `lock` (mutex) and `used` (size_t) reside in close proximity. When CPU 0 acquires the mutex, it takes exclusive (M) ownership of the cache line at `0x68`. When CPU 1 attempts to check `used` in the `.poll` handler, it must request that cache line from CPU 0, causing a \"bounce.\"\n*   **MESI Protocol**: Frequent `atomic_inc` on `read_ops` and `write_ops` will trigger cache-invalidation signals across the interconnect (UPI/QPI) if multiple CPUs are reading/writing simultaneously.\n*   **Context Switch Overhead**: Transitioning from `TASK_INTERRUPTIBLE` to `TASK_RUNNING` requires the scheduler to perform a context switch (~2-4Âµs), which involves saving/restoring registers and partially flushing the TLB (Translation Lookaside Buffer).\n\n{{DIAGRAM:tdd-diag-21|Device Data Layout|Visualization of the struct my_device_data spanning cache lines}}\n\n## 4. Interface Contracts\n\n### 4.1 Blocking Read Handler\n`ssize_t my_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)`\n*   **Wait Condition**: `*f_pos < dev->used`.\n*   **Signal Handling**: If `wait_event_interruptible` is interrupted by a signal, it returns `-ERESTARTSYS`. The handler MUST propagate this value to the VFS.\n*   **Non-Blocking**: If `O_NONBLOCK` is set and no data is available, return `-EAGAIN`.\n\n### 4.2 Blocking Write Handler\n`ssize_t my_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)`\n*   **Wait Condition**: `dev->used < dev->size`.\n*   **Side Effect**: Upon successful write, calls `wake_up_interruptible(&dev->read_queue)`.\n\n### 4.3 Poll Handler\n`__poll_t my_poll(struct file *filp, poll_table *wait)`\n*   **Requirement**: MUST call `poll_wait()` for both `read_queue` and `write_queue`.\n*   **Constraint**: Must use `mutex_lock()` (non-interruptible) for the internal readiness check because `.poll` cannot return `-ERESTARTSYS`.\n\n## 5. Algorithm Specification\n\n### 5.1 The Mutex-Release-Before-Sleep Pattern (Read)\nThis algorithm prevents deadlocks where a reader holds the lock that a producer needs to satisfy the sleep condition.\n\n1.  **Entry**: `mutex_lock_interruptible(&dev->lock)`. If interrupted, return `-ERESTARTSYS`.\n2.  **Condition Loop**:\n    *   `WHILE (*f_pos >= dev->used)`:\n        *   `IF (filp->f_flags & O_NONBLOCK)`: `mutex_unlock(&dev->lock)`; `RETURN -EAGAIN`.\n        *   `mutex_unlock(&dev->lock)`.\n        *   `ret = wait_event_interruptible(dev->read_queue, (dev->used > *f_pos))`.\n        *   `IF (ret != 0)`: `RETURN -ERESTARTSYS`.\n        *   `mutex_lock_interruptible(&dev->lock)`. If interrupted, return `-ERESTARTSYS`.\n3.  **Critical Section**: Perform `copy_to_user` and increment `read_ops`.\n4.  **Notification**: `wake_up_interruptible(&dev->write_queue)`.\n5.  **Exit**: `mutex_unlock(&dev->lock)`.\n\n{{DIAGRAM:tdd-diag-22|Blocking Read Sequence|Sequence diagram of mutex management during wait_event}}\n\n### 5.2 Poll Implementation Logic\n1.  **Registration**: `poll_wait(filp, &dev->read_queue, wait)`.\n2.  **Registration**: `poll_wait(filp, &dev->write_queue, wait)`.\n3.  **Check**: `mutex_lock(&dev->lock)`.\n4.  **Evaluate**:\n    *   `IF (dev->used > 0)`: `mask |= (POLLIN | POLLRDNORM)`.\n    *   `IF (dev->used < dev->size)`: `mask |= (POLLOUT | POLLWRNORM)`.\n5.  **Unlock**: `mutex_unlock(&dev->lock)`.\n6.  **Return**: `mask`.\n\n## 6. Error Handling Matrix\n\n| Error | Detected By | Recovery Action | User-Visible? |\n| :--- | :--- | :--- | :--- |\n| **-ERESTARTSYS** | `wait_event_interruptible` | Propagate to VFS; do not convert to `EINTR`. | No (converted by VFS/Signal logic). |\n| **-EAGAIN** | `my_read` / `my_write` | Return immediately if `O_NONBLOCK` is set. | Yes (`errno = EAGAIN`). |\n| **-EDEADLK** | Kernel Lockdep | Ensure strict lock ordering (though only one mutex used). | Yes (Kernel Oops/Console). |\n| **Partial Copy** | `copy_to_user` | Update `f_pos` by bytes actually copied; return count. | Yes (Short read). |\n\n## 7. Implementation Sequence with Checkpoints\n\n### Phase 1: Serialization (1.5 Hours)\n1.  Add `DEFINE_MUTEX(dev_mutex)` and `DECLARE_WAIT_QUEUE_HEAD` for both queues.\n2.  Wrap the existing `read`/`write`/`ioctl` logic in `mutex_lock_interruptible`.\n3.  **Checkpoint**: Run the M3 test program. It should still work perfectly, but now serialized.\n\n### Phase 2: Blocking Read (2 Hours)\n1.  Implement the `WHILE` loop in `my_read`.\n2.  Integrate `wait_event_interruptible` with the mutex release/reacquire pattern.\n3.  **Checkpoint**: Open terminal 1: `cat /dev/mydevice` (should hang). Open terminal 2: `echo \"data\" > /dev/mydevice`. Terminal 1 should immediately print \"data\" and continue hanging.\n\n### Phase 3: Blocking Write & Wakeups (1.5 Hours)\n1.  Implement blocking logic in `my_write` for full buffers.\n2.  Add `wake_up_interruptible` calls to both handlers.\n3.  **Checkpoint**: Fill the 4KB buffer. A subsequent `echo \"more\" > /dev/mydevice` should hang until a reader consumes data.\n\n### Phase 4: O_NONBLOCK & Poll (2 Hours)\n1.  Add `O_NONBLOCK` checks.\n2.  Implement the `.poll` handler.\n3.  **Checkpoint**: Run `poll_test.c`. Verify that `poll()` returns `POLLOUT` when empty and `POLLIN` when data is added.\n\n### Phase 5: Concurrent Stress Test (2.5 Hours)\n1.  Develop `stress_test.c` with `pthread` for 4 writers and 4 readers.\n2.  Implement per-thread byte counting and total checksumming.\n3.  **Checkpoint**: Run `./stress_test`. Verify total bytes written == total bytes read. Check `dmesg` for Oops.\n\n## 8. Test Specification\n\n### 8.1 Unit Tests\n*   **UT-1 (Signal Interruption)**: Block a reader with `cat`. Send `SIGINT` (Ctrl+C).\n    *   Expected: `cat` exits cleanly. `dmesg` shows `-ERESTARTSYS` or handled exit.\n*   **UT-2 (Non-blocking Entry)**: `open(\"/dev/mydevice\", O_RDONLY | O_NONBLOCK)`. Read immediately.\n    *   Expected: `read` returns `-1`, `errno` is `EAGAIN`.\n\n### 8.2 Stress Test (The \"Crucible\")\n*   **Setup**: \n    *   `Writers[0-3]`: Each writes 10,000 chunks of 32 bytes.\n    *   `Readers[0-3]`: Each reads in a loop until 80,000 bytes total are collected.\n*   **Validation**: \n    *   `Sum(Writers.written) == Sum(Readers.read)`.\n    *   `grep -i \"oops\" /var/log/syslog` -> Zero results.\n    *   `grep -i \"warning\" /var/log/syslog` -> Zero results.\n\n## 9. Performance Targets\n\n| Operation | Target | Measurement Tool |\n| :--- | :--- | :--- |\n| **Uncontended Lock** | ~12ns | `perf stat` (instructions per cycle) |\n| **Context Switch** | < 5Âµs | `lat_ctx` from lmbench |\n| **Wait Queue Fast Path** | < 100ns | `ftrace` (function graph) |\n| **Throughput (Concurrent)** | > 500 MB/s | `dd` with multiple processes |\n\n## 10. State Machine: Reader Lifecycle\n\n```text\n[ RUNNING ] \n     |\n     | (read() called, buffer empty)\n     v\n[ MUTEX_WAIT ] --> (acquired) --> [ CHECK_CONDITION ]\n                                         |\n                                         | (empty)\n                                         v\n[ TASK_INTERRUPTIBLE ] <---------- [ RELEASE_MUTEX ]\n     |\n     | (wake_up_interruptible)\n     v\n[ TASK_RUNNING (Pending Mutex) ]\n     |\n     | (mutex acquired)\n     v\n[ COPY_TO_USER ] --> [ RELEASE_MUTEX ] --> [ RETURN ]\n```\n\n## 11. Security & Constraints\n- **Unkillable Processes**: If `wait_event` (uninterruptible) were used instead of `wait_event_interruptible`, a process waiting for data that never arrives would be unkillable even by `SIGKILL` (appearing as `D` state in `ps`). We strictly use the `_interruptible` variant.\n- **Buffer Overflow**: The `dev_mutex` protects against two writers incrementing `buffer_used` simultaneously, which would have allowed writes past the 4096-byte boundary.\n<!-- END_TDD_MOD -->\n\n\n# Project Structure: Linux Kernel Module\n\n## Directory Tree\n\n```text\nbuild-kernel-module/\nâ”œâ”€â”€ Makefile                # Kbuild system (Delegates to kernel build logic)\nâ”œâ”€â”€ mychar_dev.c            # Main driver source (M1: Skeleton -> M4: Full Sync)\nâ”œâ”€â”€ mychar_dev.h            # Internal driver structure & constants (M2)\nâ”œâ”€â”€ mydevice_ioctl.h        # SHARED ABI: Magic numbers & ioctl structs (M3)\nâ”œâ”€â”€ tests/                  # Userspace test suite\nâ”‚   â”œâ”€â”€ test_ioctl.c        # Userspace binary for control plane (M3)\nâ”‚   â”œâ”€â”€ stress_test.c       # Multi-threaded concurrency crucible (M4)\nâ”‚   â”œâ”€â”€ verify_m1.sh        # M1: Lifecycle & parameter verification\nâ”‚   â”œâ”€â”€ test_driver.sh      # M2: Round-trip data integrity (echo/cat)\nâ”‚   â”œâ”€â”€ verify_m3.sh        # M3: ioctl & /proc validation\nâ”‚   â””â”€â”€ verify_m4.sh        # M4: Blocking I/O & signal handling tests\nâ”œâ”€â”€ .gitignore              # Standard kernel build artifacts (e.g., *.ko, *.mod.c)\nâ””â”€â”€ README.md               # Project documentation\n```\n\n## Creation Order\n\n1.  **Environment & Build Setup** (M1)\n    *   Install linux-headers for `uname -r`.\n    *   Create `Makefile` using the `obj-m` Kbuild pattern.\n\n2.  **Basic Module Skeleton** (M1)\n    *   Create `mychar_dev.c` (initially `hello.c`).\n    *   Implement `module_init`, `module_exit`, and `module_param`.\n    *   Verify with `tests/verify_m1.sh`.\n\n3.  **Character Device & VFS Implementation** (M2)\n    *   Create `mychar_dev.h` for `struct my_device_data`.\n    *   Implement `alloc_chrdev_region` and `cdev_add` in `mychar_dev.c`.\n    *   Implement `device_create` for automatic `/dev/` node.\n    *   Implement `read` and `write` with `copy_to_user` and `copy_from_user`.\n    *   Verify with `tests/test_driver.sh`.\n\n4.  **The Control Plane (ioctl & /proc)** (M3)\n    *   Create `mydevice_ioctl.h` (Shared ABI).\n    *   Implement `unlocked_ioctl` handler in `mychar_dev.c` (RESIZE, CLEAR, STATUS).\n    *   Implement `/proc/mydevice` using the `seq_file` interface.\n    *   Create `tests/test_ioctl.c` to exercise the ABI.\n    *   Verify with `tests/verify_m3.sh`.\n\n5.  **Concurrency & Event Multiplexing** (M4)\n    *   Update `mychar_dev.c` to include `struct mutex` and `wait_queue_head_t`.\n    *   Implement blocking `read` and `write` (Sleep/Wake pattern).\n    *   Implement the `.poll` handler for `select/epoll` integration.\n    *   Handle `O_NONBLOCK` and `-ERESTARTSYS` for signals.\n\n6.  **Stress Testing** (M4)\n    *   Create `tests/stress_test.c` (pthreads).\n    *   Execute `tests/verify_m4.sh` for final production sign-off.\n\n## File Count Summary\n- **Total files**: 10\n- **Directories**: 2\n- **Estimated lines of code**: ~850-1,000 LOC\n    - *Kernel-side*: ~500 LOC\n    - *Userspace tests*: ~400 LOC\n- **Build Output**: `mychar_dev.ko` (Kernel Object)\n"}