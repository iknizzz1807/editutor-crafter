{"html":"<h1 id=\"linux-character-device-driver-design-document\">Linux Character Device Driver: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>This document describes the design of a loadable Linux kernel module that implements a simple character device driver with a <code>/dev</code> interface. The key architectural challenge is safely managing data and concurrency across the kernel/user-space boundary, which requires careful handling of memory, synchronization primitives, and driver lifecycle.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1, Milestone 2, Milestone 3, Milestone 4 (foundational concepts)</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<h3 id=\"the-kernel-as-a-secure-building\">The Kernel as a Secure Building</h3>\n<p>Think of the Linux operating system as a highly secure government building. This building has two distinct zones with strict access controls between them.</p>\n<p>The <strong>userspace zone</strong> (outside the building) is where all regular applications run. This zone is chaotic and unpredictable - thousands of programs with varying levels of trust compete for resources. Any application can crash without bringing down the entire system, much like a protest outside the building doesn&#39;t shut down government operations. Applications communicate with each other through well-defined channels, but they have limited direct access to critical resources.</p>\n<p>The <strong>kernel-space zone</strong> (inside the building) is the secure core where privileged operations happen. This is where the operating system&#39;s core services run: managing memory, scheduling processes, controlling hardware, and enforcing security policies. The kernel has complete access to all system resources, including physical memory, CPU registers, and hardware devices. A single mistake here can crash the entire system, much like a fire in the building&#39;s control room would halt all government functions.</p>\n<p>Between these two zones stands a <strong>security checkpoint</strong> with specific, controlled entrances: the <strong>system call interface</strong>. Each system call (<code>read</code>, <code>write</code>, <code>open</code>, <code>ioctl</code>, etc.) is like a designated checkpoint where userspace applications can request kernel services. When an application calls <code>write()</code> on a file, it&#39;s like submitting a form at the checkpoint - the application waits while security (the kernel) verifies the request, processes it according to strict rules, and returns a result.</p>\n<p>The security guards at these checkpoints are various kernel subsystems. The <strong>Virtual File System (VFS)</strong> guards file operations, ensuring every <code>read()</code> or <code>write()</code> follows the proper protocol. The <strong>process scheduler</strong> determines which application gets CPU time. The <strong>memory manager</strong> controls what memory each application can access. These subsystems work together to maintain system stability and security.</p>\n<blockquote>\n<p><strong>Design Insight:</strong> The fundamental rule of kernel programming is <strong>&quot;Thou shalt not trust userspace.&quot;</strong> Any pointer, buffer, or value coming from userspace must be treated as potentially malicious or erroneous. The kernel must validate everything before using it, and must never crash or leak information regardless of what userspace sends.</p>\n</blockquote>\n<p>Within this secure building, <strong>device drivers</strong> serve as specialized interpreters for hardware components. They translate generic system calls into specific hardware commands. When you type on a keyboard, the keyboard driver receives electrical signals and translates them into character data that applications can read. When you save a file, the storage driver translates file system requests into specific commands for your SSD or hard drive.</p>\n<p>Our project focuses on building a particular type of driver: a <strong>character device driver</strong>. This driver doesn&#39;t control physical hardware but creates a virtual conduit for data between userspace and kernel-space. It&#39;s like installing a secure message passing system within the building - applications can deposit messages (write) and retrieve messages (read) through controlled interfaces, with the kernel managing the storage and access rules.</p>\n<h3 id=\"the-core-challenge-safe-and-concurrent-access\">The Core Challenge: Safe and Concurrent Access</h3>\n<p>The specific problem we&#39;re solving has two interconnected dimensions that make kernel programming fundamentally different from userspace programming:</p>\n<p><strong>Dimension 1: The Kernel/User Boundary Problem</strong>\nWhen data moves between userspace and kernel-space, it crosses a fundamental architectural boundary with different memory spaces, privilege levels, and validation requirements. The kernel cannot directly access userspace memory pointers because:</p>\n<ul>\n<li>Userspace pointers are virtual addresses in the application&#39;s address space, not the kernel&#39;s</li>\n<li>Userspace memory might be swapped out, invalid, or deliberately malicious</li>\n<li>Direct access would bypass security checks and could crash the system</li>\n</ul>\n<p>Similarly, the kernel cannot directly expose its internal memory to userspace because:</p>\n<ul>\n<li>Kernel memory contains sensitive system data and other processes&#39; information</li>\n<li>Applications might accidentally or maliciously corrupt kernel data structures</li>\n<li>Different memory protection mechanisms apply (kernel memory is not swappable)</li>\n</ul>\n<p>The solution requires careful <strong>copying and validation</strong> at the boundary. Every byte transferred must be explicitly copied between address spaces using special kernel functions that handle the translation and validation automatically.</p>\n<p><strong>Dimension 2: The Concurrency Problem</strong>\nUnlike most userspace programs that handle one request at a time, the kernel is inherently <strong>concurrent</strong>. Multiple processes can simultaneously:</p>\n<ul>\n<li>Open the same device file</li>\n<li>Read from the device while another process is writing to it</li>\n<li>Issue control commands (<code>ioctl</code>) while data transfers are happening</li>\n<li>Be interrupted by hardware interrupts that might need to access the same data structures</li>\n</ul>\n<p>This creates classic synchronization problems:</p>\n<ul>\n<li><strong>Data races</strong>: Two processes writing to the same buffer location without coordination</li>\n<li><strong>Starvation</strong>: One process monopolizing access while others wait indefinitely</li>\n<li><strong>Deadlock</strong>: Multiple processes waiting for each other in a circular dependency</li>\n<li><strong>Priority inversion</strong>: A high-priority process waiting for a low-priority process</li>\n</ul>\n<p>The kernel solves these problems with <strong>synchronization primitives</strong> (mutexes, spinlocks, semaphores) and <strong>wait queues</strong> (for blocking operations). However, these must be used correctly:</p>\n<ul>\n<li>Some locks can sleep (mutexes), while others cannot (spinlocks)</li>\n<li>The wrong lock type in the wrong context can deadlock the entire system</li>\n<li>Locking too much reduces performance; locking too little causes data corruption</li>\n</ul>\n<blockquote>\n<p><strong>Design Insight:</strong> Kernel code must be <strong>reentrant</strong> and <strong>thread-safe</strong> by design. Every function must assume it can be interrupted at any point and resumed later, possibly with other threads executing the same code on different data.</p>\n</blockquote>\n<p>The table below summarizes the key differences between kernel-space and userspace programming that our driver must handle:</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Userspace Programming</th>\n<th>Kernel-space Programming</th>\n<th>Implications for Our Driver</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Memory Access</strong></td>\n<td>Direct access to process memory, can allocate/free at will</td>\n<td>Cannot directly access userspace memory; kernel memory is non-swappable</td>\n<td>Must use <code>copy_to_user()</code>/<code>copy_from_user()</code> for all data transfers</td>\n</tr>\n<tr>\n<td><strong>Error Handling</strong></td>\n<td>Process crashes on severe errors; can be restarted</td>\n<td>Kernel panic on severe errors; crashes entire system</td>\n<td>Must validate all inputs, never dereference invalid pointers, handle all error paths</td>\n</tr>\n<tr>\n<td><strong>Concurrency Model</strong></td>\n<td>Typically single-threaded or explicit threading</td>\n<td>Always concurrent - interrupts, multiple processes, SMP</td>\n<td>Every data structure must be protected with appropriate locks</td>\n</tr>\n<tr>\n<td><strong>Debugging</strong></td>\n<td>Can use debuggers, printf, core dumps</td>\n<td>Limited to <code>printk()</code>, system logs, special debugging tools</td>\n<td>Must include extensive logging with appropriate log levels</td>\n</tr>\n<tr>\n<td><strong>Libraries</strong></td>\n<td>Full standard C library available</td>\n<td>Limited to kernel API; no floating point, limited memory allocation</td>\n<td>Must use kernel functions (<code>kmalloc()</code>, <code>kfree()</code>) instead of <code>malloc()</code>/<code>free()</code></td>\n</tr>\n<tr>\n<td><strong>Execution Context</strong></td>\n<td>Always in process context</td>\n<td>Can be in process context or interrupt context</td>\n<td>Must know context to choose correct synchronization primitives</td>\n</tr>\n<tr>\n<td><strong>Module Lifecycle</strong></td>\n<td>Program starts, runs, exits</td>\n<td>Module loads, devices can be opened/closed many times, module unloads</td>\n<td>Must clean up all resources on module exit, handle reference counting</td>\n</tr>\n</tbody></table>\n<p><strong>Our Specific Implementation Challenge:</strong>\nWe&#39;re building a character device driver that provides:</p>\n<ol>\n<li>A <code>/dev/</code> interface that userspace programs can open, read, write, and close</li>\n<li>An internal buffer that stores data written from userspace</li>\n<li>Control interfaces (<code>ioctl</code> and <code>/proc</code>) for configuration and monitoring</li>\n<li>Safe concurrent access for multiple readers and writers</li>\n</ol>\n<p>The core data flow problem is illustrated in the following sequence:</p>\n<ol>\n<li><strong>Userspace Process A</strong> calls <code>write(fd, &quot;hello&quot;, 5)</code> on our device</li>\n<li>The system call enters the kernel through the VFS layer</li>\n<li>VFS routes the call to our driver&#39;s <code>write</code> handler</li>\n<li>Our handler must:<ul>\n<li>Validate the userspace pointer and length</li>\n<li>Copy &quot;hello&quot; from userspace to kernel-space using <code>copy_from_user()</code></li>\n<li>Acquire a lock to protect the buffer from concurrent access</li>\n<li>Store the data in our internal buffer</li>\n<li>Release the lock</li>\n<li>Wake up any processes waiting to read from an empty buffer</li>\n<li>Return success/failure to userspace</li>\n</ul>\n</li>\n<li>Meanwhile, <strong>Userspace Process B</strong> might be calling <code>read()</code> on the same device</li>\n<li>Our <code>read</code> handler must:<ul>\n<li>Check if data is available in the buffer</li>\n<li>If empty, put the process to sleep on a wait queue (blocking read)</li>\n<li>When woken (by the write above), acquire the lock</li>\n<li>Copy data from kernel buffer to userspace using <code>copy_to_user()</code></li>\n<li>Release the lock</li>\n<li>Return the number of bytes read</li>\n</ul>\n</li>\n</ol>\n<p>This seemingly simple flow involves nearly every challenging aspect of kernel programming: crossing the kernel/user boundary, synchronization, sleeping/waking processes, and proper error handling.</p>\n<h3 id=\"existing-approaches-and-learning-path\">Existing Approaches and Learning Path</h3>\n<p>Linux provides several mechanisms for kernel/userspace communication, each suited to different use cases. Understanding why we chose a character device driver requires comparing the alternatives:</p>\n<table>\n<thead>\n<tr>\n<th>Interface</th>\n<th>Primary Use Case</th>\n<th>Data Model</th>\n<th>Complexity</th>\n<th>Why Not for Our Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Character Device (<code>/dev/</code>)</strong></td>\n<td>Stream-oriented I/O, hardware abstraction</td>\n<td>Byte stream, sequential access</td>\n<td>Medium</td>\n<td><strong>Chosen</strong> - Perfect for learning fundamental driver concepts</td>\n</tr>\n<tr>\n<td><strong>Block Device</strong></td>\n<td>Disk storage, filesystems</td>\n<td>Block-oriented, random access</td>\n<td>High</td>\n<td>Too complex, requires request queue handling</td>\n</tr>\n<tr>\n<td><strong>Network Device</strong></td>\n<td>Network interfaces</td>\n<td>Packet-oriented, protocol stacks</td>\n<td>High</td>\n<td>Different API, requires networking stack integration</td>\n</tr>\n<tr>\n<td><strong>SysFS (<code>/sys/</code>)</strong></td>\n<td>Device configuration, attributes</td>\n<td>Key-value pairs, hierarchical</td>\n<td>Low-Medium</td>\n<td>Not for bulk data transfer, read/write semantics different</td>\n</tr>\n<tr>\n<td><strong>DebugFS (<code>/debug/</code>)</strong></td>\n<td>Debugging information</td>\n<td>Arbitrary files, often human-readable</td>\n<td>Low</td>\n<td>Not for production interfaces, may not be available</td>\n</tr>\n<tr>\n<td><strong>ProcFS (<code>/proc/</code>)</strong></td>\n<td>Process information, system statistics</td>\n<td>Mixed (text, binary)</td>\n<td>Medium</td>\n<td>We&#39;ll use it for statistics, but not as primary interface</td>\n</tr>\n<tr>\n<td><strong>Netlink Sockets</strong></td>\n<td>Kernel ↔ userspace messaging</td>\n<td>Message-based, bidirectional</td>\n<td>Medium-High</td>\n<td>Socket programming required, different paradigm</td>\n</tr>\n<tr>\n<td><strong>Memory-mapped I/O (<code>mmap</code>)</strong></td>\n<td>High-performance data sharing</td>\n<td>Direct memory access</td>\n<td>High</td>\n<td>Advanced topic, bypasses copy overhead but more complex</td>\n</tr>\n</tbody></table>\n<p><strong>Why a Character Device Driver is the Ideal Learning Vehicle:</strong></p>\n<ol>\n<li><p><strong>Historical Significance</strong>: Character devices represent the original Unix device model. Understanding them provides insight into decades of Unix/Linux design philosophy.</p>\n</li>\n<li><p><strong>Comprehensive Coverage</strong>: Implementing a character device driver requires learning:</p>\n<ul>\n<li>Module initialization and cleanup (Milestone 1)</li>\n<li>File operations and the VFS layer (Milestone 2)</li>\n<li>Kernel/userspace data transfer</li>\n<li>Device node creation and management</li>\n<li>Control interfaces (<code>ioctl</code>) (Milestone 3)</li>\n<li>Synchronization and concurrency (Milestone 4)</li>\n<li>Process sleeping/waking (wait queues)</li>\n<li>Multiple interfaces (<code>/proc</code>, <code>ioctl</code>, file ops)</li>\n</ul>\n</li>\n<li><p><strong>Practical Foundation</strong>: The skills transfer directly to:</p>\n<ul>\n<li>Real hardware drivers (USB, serial, input devices)</li>\n<li>Virtual devices (VPN interfaces, encryption devices)</li>\n<li>Kernel services that expose device-like interfaces</li>\n</ul>\n</li>\n<li><p><strong>Progressive Complexity</strong>: The character device API allows starting simple (basic read/write) and gradually adding complexity (ioctl, proc interface, concurrency) in clearly separated milestones.</p>\n</li>\n</ol>\n<p><strong>The Learning Progression Through Milestones:</strong></p>\n<p>Our project follows a carefully sequenced learning path:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">mermaid</span><pre class=\"arch-pre shiki-highlighted\"><code>graph TD\n    A[Milestone 1:&lt;br&gt;Module Lifecycle] --&gt; B[Milestone 2:&lt;br&gt;Character Device Core]\n    B --&gt; C[Milestone 3:&lt;br&gt;Control Interfaces]\n    C --&gt; D[Milestone 4:&lt;br&gt;Concurrency &amp; Synchronization]\n    \n    A --&gt; A1[Kbuild System]\n    A --&gt; A2[printk Debugging]\n    A --&gt; A3[Resource Management]\n    \n    B --&gt; B1[File Operations]\n    B --&gt; B2[copy_to/from_user]\n    B --&gt; B3[Device Node Creation]\n    \n    C --&gt; C1[ioctl Command Design]\n    C --&gt; C2[ProcFS Interface]\n    C --&gt; C3[Shared Headers]\n    \n    D --&gt; D1[Mutex Protection]\n    D --&gt; D2[Wait Queues]\n    D --&gt; D3[Poll/Select Support]</code></pre></div>\n\n<p><strong>Alternative Approaches We Considered and Rejected:</strong></p>\n<blockquote>\n<p><strong>Decision: Character Device vs. SysFS for Configuration</strong></p>\n<ul>\n<li><strong>Context</strong>: We need both data transfer (read/write) and configuration (buffer size, statistics). SysFS is commonly used for device attributes.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Pure character device with <code>ioctl</code> for all control</li>\n<li>Hybrid approach: character device for data, SysFS for attributes</li>\n<li>Pure SysFS with binary file operations</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Pure character device with <code>ioctl</code> and <code>/proc</code> interface</li>\n<li><strong>Rationale</strong>: <ul>\n<li><code>ioctl</code> provides structured, type-safe command interface</li>\n<li><code>/proc</code> interface is simpler to implement than SysFS for read-only statistics</li>\n<li>Keeping all interfaces in one driver file simplifies learning</li>\n<li>Real-world drivers often use multiple interfaces (char device + SysFS + debugfs)</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>: <ul>\n<li>Learners must understand multiple interface paradigms</li>\n<li>More code to write and test</li>\n<li>Better preparation for real driver development</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Why Rejected</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Pure Character Device</strong></td>\n<td>Single interface to learn, consistent model</td>\n<td>All control through <code>ioctl</code> can become complex</td>\n<td><strong>Chosen</strong> - Best for learning fundamentals</td>\n</tr>\n<tr>\n<td><strong>Character + SysFS</strong></td>\n<td>Proper separation of data vs. control, modern Linux practice</td>\n<td>Two different APIs to learn, more complex initialization</td>\n<td>Too advanced for initial learning</td>\n</tr>\n<tr>\n<td><strong>Pure ProcFS</strong></td>\n<td>Simple file operations, good for read-mostly data</td>\n<td>Poor for binary data transfer, not standard for devices</td>\n<td>Doesn&#39;t teach standard device driver patterns</td>\n</tr>\n<tr>\n<td><strong>Netlink Sockets</strong></td>\n<td>Bidirectional, flexible messaging</td>\n<td>Completely different paradigm from device drivers</td>\n<td>Wouldn&#39;t teach device driver concepts</td>\n</tr>\n</tbody></table>\n<p><strong>The Evolution of Linux Driver Models:</strong></p>\n<p>It&#39;s important to understand that our simple character device represents the foundation upon which more advanced driver models are built:</p>\n<ol>\n<li><strong>Legacy Model (What we&#39;re implementing)</strong>: Direct registration with <code>register_chrdev()</code>, manual device node creation</li>\n<li><strong>Device Model (Modern approach)</strong>: Integration with the kernel&#39;s device model, automatic discovery, power management</li>\n<li><strong>Platform Devices</strong>: For embedded systems with device tree description</li>\n<li><strong>USB/PCI Drivers</strong>: Bus-specific driver frameworks with hotplug support</li>\n</ol>\n<p>Our project intentionally starts with the legacy model because:</p>\n<ul>\n<li>It exposes the fundamental operations without framework abstractions</li>\n<li>The concepts map directly to the <code>file_operations</code> structure</li>\n<li>Learners understand what frameworks later automate</li>\n<li>Most educational resources use this model</li>\n</ul>\n<blockquote>\n<p><strong>Design Principle</strong>: Learn the fundamentals before the abstractions. Understanding how <code>copy_to_user()</code> works at a basic level makes you appreciate why driver frameworks exist and what problems they solve.</p>\n</blockquote>\n<p><strong>Common Misconceptions About Kernel Programming:</strong></p>\n<ol>\n<li><p><strong>&quot;Kernel programming is just C programming&quot;</strong> - While the language is C, the environment, constraints, and APIs are completely different. There&#39;s no standard library, memory management is manual and constrained, and concurrency is ever-present.</p>\n</li>\n<li><p><strong>&quot;If it compiles, it works&quot;</strong> - Kernel modules can compile cleanly but crash the system when loaded. Testing requires careful staging and recovery plans.</p>\n</li>\n<li><p><strong>&quot;Userspace debugging techniques work in kernel&quot;</strong> - No interactive debuggers (usually), no <code>printf()</code> (use <code>printk()</code> with levels), core dumps are system crashes.</p>\n</li>\n<li><p><strong>&quot;Concurrency is an advanced topic&quot;</strong> - In the kernel, concurrency is fundamental. Even a simple driver with no explicit threading must handle multiple processes accessing it simultaneously.</p>\n</li>\n</ol>\n<p>Our project structure directly addresses these misconceptions by:</p>\n<ul>\n<li>Starting with module lifecycle (Milestone 1) to learn the kernel build and loading process</li>\n<li>Progressing to data transfer (Milestone 2) with proper boundary crossing</li>\n<li>Adding control interfaces (Milestone 3) to learn kernel/userspace API design</li>\n<li>Finally addressing concurrency (Milestone 4) as a fundamental requirement</li>\n</ul>\n<p>The following diagram shows where our driver fits in the overall Linux architecture:</p>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiagram-sys-component.svg\" alt=\"System Component Diagram\"></p>\n<p>As shown, our character device driver sits between userspace applications and kernel subsystems. It interacts with:</p>\n<ul>\n<li><strong>VFS (Virtual File System)</strong>: For file operations (<code>open</code>, <code>read</code>, <code>write</code>, <code>ioctl</code>)</li>\n<li><strong>ProcFS</strong>: For our statistics interface</li>\n<li><strong>Kernel Memory Management</strong>: For buffer allocation</li>\n<li><strong>Process Scheduler</strong>: For wait queue management</li>\n</ul>\n<p>This positioning makes it an ideal vehicle for understanding the complete kernel ecosystem while focusing on manageable, incremental milestones.</p>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1, Milestone 2, Milestone 3, Milestone 4 (overarching objectives)</p>\n</blockquote>\n<p>This section establishes clear boundaries for the driver project by explicitly defining what we aim to build (Goals) and what we deliberately exclude (Non-Goals). These boundaries ensure the project remains focused on its educational purpose while managing complexity for intermediate learners. Understanding these constraints prevents scope creep and helps learners focus on core kernel programming concepts without being overwhelmed by peripheral concerns.</p>\n<h3 id=\"functional-goals-what-it-must-do\">Functional Goals (What it must do)</h3>\n<p>The driver must implement a complete character device driver that serves as a pedagogical tool for understanding kernel/user-space interaction, device driver architecture, and concurrency management in the Linux kernel. These goals are organized into four progressive milestones, each building upon the previous to create a fully functional driver.</p>\n<table>\n<thead>\n<tr>\n<th>Goal Category</th>\n<th>Specific Requirements</th>\n<th>Corresponding Milestone</th>\n<th>Educational Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Module Lifecycle Management</strong></td>\n<td>1. Compile as loadable kernel module using Kbuild system<br>2. Clean initialization and cleanup with <code>module_init</code>/<code>module_exit</code><br>3. Register proper metadata: <code>MODULE_LICENSE(&quot;GPL&quot;)</code>, <code>MODULE_AUTHOR</code>, <code>MODULE_DESCRIPTION</code><br>4. Visible via <code>modinfo</code> command<br>5. Clean unloading without resource leaks</td>\n<td>Milestone 1</td>\n<td>Teaches kernel module architecture, build system, and resource management lifecycle</td>\n</tr>\n<tr>\n<td><strong>Character Device Interface</strong></td>\n<td>1. Dynamic device number allocation via <code>alloc_chrdev_region</code><br>2. Automatic <code>/dev</code> node creation using <code>class_create</code> and <code>device_create</code><br>3. Complete <code>struct file_operations</code> with <code>open</code>, <code>release</code>, <code>read</code>, <code>write</code> handlers<br>4. Safe user/kernel data transfer via <code>copy_to_user</code>/<code>copy_from_user</code><br>5. Persistent kernel buffer for data storage between operations</td>\n<td>Milestone 2</td>\n<td>Demonstrates character device registration, VFS integration, and boundary-crossing data transfer</td>\n</tr>\n<tr>\n<td><strong>Control and Monitoring Interfaces</strong></td>\n<td>1. Custom <code>ioctl</code> commands defined with <code>_IOR</code>/<code>_IOW</code> macros in shared header<br>2. <code>unlocked_ioctl</code> handler implementing buffer resize, clear, and status queries<br>3. <code>/proc</code> filesystem entry displaying device statistics and configuration<br>4. Userspace test program exercising all control interfaces</td>\n<td>Milestone 3</td>\n<td>Teaches kernel-user communication beyond basic read/write and ProcFS integration</td>\n</tr>\n<tr>\n<td><strong>Concurrent Access Safety</strong></td>\n<td>1. Mutex-protected buffer access for thread-safe read/write operations<br>2. Blocking read via wait queue (<code>wait_event_interruptible</code>/<code>wake_up_interruptible</code>)<br>3. <code>poll</code>/<code>select</code> support implementing <code>poll</code> file operation<br>4. Stress testing with multiple concurrent readers/writers without data corruption</td>\n<td>Milestone 4</td>\n<td>Introduces kernel synchronization primitives and asynchronous I/O patterns</td>\n</tr>\n</tbody></table>\n<p>Beyond these technical requirements, the driver must fulfill specific educational objectives that transform it from a mere code exercise into a learning tool:</p>\n<ol>\n<li><p><strong>Demonstrate Safe Boundary Crossing</strong>: Every interaction between user-space and kernel-space must model proper safety practices—never dereferencing user pointers directly, always checking <code>copy_to/from_user</code> return values, and validating all inputs from untrusted user-space.</p>\n</li>\n<li><p><strong>Illustrate Kernel Concurrency Patterns</strong>: The driver must showcase realistic synchronization scenarios that kernel developers encounter: sleeping locks for operations that may block, proper wait queue usage for event-driven I/O, and correct <code>poll</code> implementation for multiplexed I/O.</p>\n</li>\n<li><p><strong>Model Clean Resource Management</strong>: From module loading to unloading, the driver must demonstrate the &quot;reverse order&quot; cleanup principle—freeing resources in the exact opposite order of allocation—to prevent resource leaks that could taint the kernel or require a reboot.</p>\n</li>\n<li><p><strong>Provide Debuggable Failure Modes</strong>: The implementation should include clear error paths with descriptive <code>printk</code> messages (using appropriate log levels like <code>KERN_INFO</code> and <code>KERN_ERR</code>) that help learners diagnose issues through <code>dmesg</code> output.</p>\n</li>\n<li><p><strong>Serve as Reference Architecture</strong>: The code structure should be modular enough that learners can extract patterns for their own future driver projects, with clear separation between device registration, I/O operations, control interfaces, and synchronization.</p>\n</li>\n</ol>\n<p>The following table maps each functional goal to specific kernel APIs and concepts that learners will master:</p>\n<table>\n<thead>\n<tr>\n<th>Kernel Concept</th>\n<th>APIs Used</th>\n<th>Learning Outcome</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Module Lifecycle</strong></td>\n<td><code>module_init</code>, <code>module_exit</code>, <code>printk</code>, <code>MODULE_*</code> macros</td>\n<td>Understanding how kernel modules integrate with the running kernel</td>\n</tr>\n<tr>\n<td><strong>Device Registration</strong></td>\n<td><code>alloc_chrdev_region</code>, <code>cdev_init</code>, <code>cdev_add</code>, <code>class_create</code>, <code>device_create</code></td>\n<td>Dynamic device number assignment and automatic device node creation</td>\n</tr>\n<tr>\n<td><strong>File Operations</strong></td>\n<td><code>struct file_operations</code>, <code>open</code>, <code>release</code>, <code>read</code>, <code>write</code> handlers</td>\n<td>VFS integration and file operation dispatch</td>\n</tr>\n<tr>\n<td><strong>User/Kernel Transfer</strong></td>\n<td><code>copy_to_user</code>, <code>copy_from_user</code>, <code>access_ok</code></td>\n<td>Safe memory access across privilege boundaries</td>\n</tr>\n<tr>\n<td><strong>Ioctl Interface</strong></td>\n<td><code>unlocked_ioctl</code>, <code>_IOR</code>/<code>_IOW</code>/<code>_IOWR</code> macros</td>\n<td>Device-specific control command implementation</td>\n</tr>\n<tr>\n<td><strong>ProcFS Integration</strong></td>\n<td><code>proc_create</code>, <code>struct proc_ops</code>, <code>single_open</code></td>\n<td>Exporting driver information via virtual filesystem</td>\n</tr>\n<tr>\n<td><strong>Synchronization</strong></td>\n<td><code>mutex_lock</code>/<code>mutex_unlock</code>, <code>DEFINE_MUTEX</code></td>\n<td>Protecting shared data from concurrent access</td>\n</tr>\n<tr>\n<td><strong>Wait Queues</strong></td>\n<td><code>wait_event_interruptible</code>, <code>wake_up_interruptible</code>, <code>DECLARE_WAIT_QUEUE_HEAD</code></td>\n<td>Implementing blocking I/O with sleep/wake mechanisms</td>\n</tr>\n<tr>\n<td><strong>Poll/Select</strong></td>\n<td><code>poll</code> file operation, <code>poll_wait</code>, mask bits (<code>POLLIN</code>, <code>POLLRDNORM</code>)</td>\n<td>Supporting asynchronous event notification</td>\n</tr>\n</tbody></table>\n<h3 id=\"non-goals-what-it-explicitly-does-not-do\">Non-Goals (What it explicitly does NOT do)</h3>\n<p>Deliberate exclusion of certain features is as important as inclusion for a focused learning project. These non-goals prevent scope creep and ensure learners concentrate on core kernel programming concepts without being sidetracked by advanced or peripheral topics.</p>\n<table>\n<thead>\n<tr>\n<th>Non-Goal Category</th>\n<th>Specific Exclusions</th>\n<th>Rationale for Exclusion</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Hardware Interaction</strong></td>\n<td>1. No physical hardware device control<br>2. No interrupt handling (IRQs)<br>3. No DMA operations<br>4. No memory-mapped I/O (MMIO)<br>5. No power management (suspend/resume)</td>\n<td>Hardware drivers introduce platform-specific complexities, interrupt context constraints, and device-specific knowledge requirements that would distract from core kernel programming concepts. This driver is purely software-based.</td>\n</tr>\n<tr>\n<td><strong>Production-Grade Robustness</strong></td>\n<td>1. No support for hotplugging (device insertion/removal at runtime)<br>2. No fine-grained error recovery beyond basic cleanup<br>3. No performance optimization (zero-copy, ring buffers)<br>4. No comprehensive security auditing or exploit mitigation<br>5. No support for <code>mmap</code> or advanced memory management</td>\n<td>Production drivers require extensive error handling, security hardening, and performance optimizations that would obscure the educational focus on fundamental patterns.</td>\n</tr>\n<tr>\n<td><strong>Advanced Kernel Features</strong></td>\n<td>1. No integration with Device Tree or ACPI<br>2. No sysfs (<code>/sys</code>) interface for device attributes<br>3. No debugfs interface for debugging<br>4. No netlink socket communication<br>5. No kernel thread creation or workqueues</td>\n<td>These advanced interfaces would introduce additional complexity without contributing to the core learning objectives of character device drivers and basic synchronization.</td>\n</tr>\n<tr>\n<td><strong>System-Wide Integration</strong></td>\n<td>1. No udev rule creation for automatic node permissions<br>2. No integration with systemd or init systems<br>3. No support for multiple device instances (minor numbers)<br>4. No namespace or container awareness<br>5. No integration with kernel events or notifications</td>\n<td>System integration aspects are important for production drivers but represent a different layer of complexity than core kernel programming.</td>\n</tr>\n<tr>\n<td><strong>User-Space Libraries</strong></td>\n<td>1. No companion userspace library (lib) for simplified access<br>2. No automatic test suite or continuous integration setup<br>3. No graphical monitoring tools or dashboards<br>4. No shell completion or CLI helper utilities</td>\n<td>While useful in production, these would shift focus from kernel programming to userspace application development.</td>\n</tr>\n</tbody></table>\n<p>The driver also explicitly avoids certain implementation patterns that, while common in production, would complicate the learning experience:</p>\n<blockquote>\n<p><strong>Design Principle: Simplicity Over Completeness</strong><br>This driver prioritizes clear, pedagogical code over feature completeness. Every line of code should serve an educational purpose, demonstrating a specific kernel concept without unnecessary abstraction or optimization that would obscure the core learning.</p>\n</blockquote>\n<p><strong>Why No Hardware Interaction?</strong><br>Real hardware drivers require understanding device datasheets, interrupt controllers, DMA controllers, and platform-specific constraints. These topics deserve their own dedicated learning path. Our pure-software driver eliminates these variables, allowing learners to focus on kernel APIs and patterns without hardware debugging complications.</p>\n<p><strong>Why Not Production-Grade?</strong><br>Production drivers require handling dozens of edge cases: power management events, surprise device removal, malicious user input, resource exhaustion, and performance under heavy load. While important, these concerns would triple the code size and obscure the fundamental patterns. Learners should first master the basics before tackling production hardening.</p>\n<p><strong>Why Exclude Advanced Interfaces?</strong><br>Sysfs, debugfs, netlink, and Device Tree each have their own complex APIs and conventions. Including them would fragment the learning focus. After mastering character devices and ProcFS, learners can apply similar patterns to these other interfaces in future projects.</p>\n<p><strong>Educational Boundary Enforcement</strong><br>The non-goals create a &quot;sandbox&quot; where learners can safely experiment with kernel programming without being overwhelmed. For example:</p>\n<ol>\n<li><strong>No hardware dependencies</strong> means the driver works on any Linux system (virtual or physical) without special hardware.</li>\n<li><strong>No production requirements</strong> means we can use simple linear buffers instead of optimized ring buffers, making the code easier to understand.</li>\n<li><strong>No advanced features</strong> means we can use the simpler <code>single_open</code> style for ProcFS instead of the more complex <code>seq_file</code> interface, reducing cognitive load.</li>\n</ol>\n<p>These constraints mirror how kernel programming is often taught: starting with software-only drivers before progressing to hardware control, and focusing on correctness before optimization.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>While this section primarily defines requirements rather than implementation, learners should use these goals and non-goals as a checklist throughout development. The following table provides a quick reference for what to include and what to avoid:</p>\n<table>\n<thead>\n<tr>\n<th>✅ <strong>DO Implement</strong></th>\n<th>❌ <strong>DO NOT Implement</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>copy_to_user</code>/<code>copy_from_user</code> for all boundary crossings</td>\n<td>Direct dereferencing of user-space pointers</td>\n</tr>\n<tr>\n<td>Mutex protection for all buffer operations</td>\n<td>Spinlocks for operations that may sleep</td>\n</tr>\n<tr>\n<td>Wait queues for blocking read when empty</td>\n<td>Busy-wait loops polling buffer state</td>\n</tr>\n<tr>\n<td>Proper error checking and cleanup in <code>module_exit</code></td>\n<td>Ignoring allocation failures or cleanup</td>\n</tr>\n<tr>\n<td>Shared header file for <code>ioctl</code> command definitions</td>\n<td>Hard-coded magic numbers for <code>ioctl</code> commands</td>\n</tr>\n<tr>\n<td><code>/proc</code> entry showing buffer size, usage statistics</td>\n<td>Complex sysfs attributes or debugfs entries</td>\n</tr>\n<tr>\n<td><code>poll</code> support with <code>POLLIN</code>/<code>POLLRDNORM</code> events</td>\n<td>Full <code>mmap</code> implementation or shared memory</td>\n</tr>\n<tr>\n<td>Kernel log messages at appropriate levels (<code>KERN_INFO</code>, <code>KERN_ERR</code>)</td>\n<td>Console output or userspace logging libraries</td>\n</tr>\n</tbody></table>\n<p>For project structure, organize code according to these boundaries:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>simplechardev/\n├── Makefile                    # Kbuild system for module compilation\n├── simplechardev.c             # Main driver implementation\n├── simplechardev.h             # Shared ioctl definitions (user/kernel)\n└── test_simplechardev.c       # Userspace test program (optional)</code></pre></div>\n\n<p>This minimal structure reflects the project&#39;s focused scope—no separate directories for hardware abstraction, no complex build systems, and no extensive test frameworks. The simplicity allows learners to see the complete picture of a character device driver without organizational overhead.</p>\n<hr>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1, Milestone 2, Milestone 3, Milestone 4 (architectural foundation for all components)</p>\n</blockquote>\n<p>This section provides a bird&#39;s-eye view of the driver&#39;s internal architecture and its position within the broader Linux kernel ecosystem. Before diving into implementation details, it&#39;s crucial to understand how the driver&#39;s components fit together and interact with kernel subsystems. Think of the driver as a small business operating within a large industrial park (the kernel). This business has a reception desk (<code>Character Device Core</code>) that handles customer interactions, a storage room (<code>I/O Buffer</code>) for holding data, a manager (<code>Synchronization Manager</code>) who coordinates access to prevent chaos, an administrative office (<code>Module Lifecycle Manager</code>) that handles permits and licenses, and a public dashboard (<code>Proc/Control Interface</code>) displaying operational statistics. Each component has specific responsibilities and communicates through well-defined protocols enforced by the park&#39;s regulations (kernel APIs).</p>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiagram-sys-component.svg\" alt=\"System Component Diagram\"></p>\n<h3 id=\"component-overview-and-responsibilities\">Component Overview and Responsibilities</h3>\n<p>The driver decomposes into five logical components, each addressing a distinct aspect of the device driver problem space. This separation follows the <strong>Single Responsibility Principle</strong> adapted for kernel programming: each component manages one type of resource or handles one category of operations. This modular design makes the code easier to understand, test, and extend while aligning with Linux kernel conventions.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Primary Responsibility</th>\n<th>Key Kernel Subsystems Interacted With</th>\n<th>Key Data Structures Owned</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Module Lifecycle Manager</strong></td>\n<td>Handle driver initialization and cleanup, registering/unregistering with the kernel.</td>\n<td>Kernel module loader, device number registry, sysfs</td>\n<td><code>struct mydevice_data</code> (global instance), <code>dev_t</code> (device number), <code>struct class*</code></td>\n</tr>\n<tr>\n<td><strong>Character Device Core</strong></td>\n<td>Implement file operations (open, read, write, release) that userspace applications invoke via system calls.</td>\n<td>Virtual File System (VFS), device model, memory management</td>\n<td><code>struct file_operations</code>, <code>struct cdev</code>, kernel buffer pointer</td>\n</tr>\n<tr>\n<td><strong>I/O Buffer</strong></td>\n<td>Store data written from userspace and provide it for reads, managing memory allocation and bounds.</td>\n<td>Kernel memory allocator (<code>kmalloc</code>/<code>kfree</code>)</td>\n<td>Linear buffer (void*), buffer size (size_t)</td>\n</tr>\n<tr>\n<td><strong>Synchronization Manager</strong></td>\n<td>Coordinate concurrent access from multiple processes, implement blocking reads, and support poll/select.</td>\n<td>Kernel locking API, wait queue subsystem, poll mechanism</td>\n<td><code>struct mutex</code>, <code>struct wait_queue_head_t</code></td>\n</tr>\n<tr>\n<td><strong>Proc/Control Interface</strong></td>\n<td>Provide monitoring and control via <code>ioctl</code> system calls and <code>/proc</code> filesystem entries.</td>\n<td><code>ioctl</code> dispatch, proc filesystem</td>\n<td><code>struct proc_ops</code>, <code>ioctl</code> command definitions</td>\n</tr>\n</tbody></table>\n<h4 id=\"mental-model-the-driver-as-a-library-with-controlled-access\">Mental Model: The Driver as a Library with Controlled Access</h4>\n<p>Imagine a public library (the driver) where patrons (userspace processes) can store and retrieve messages. The <strong>Module Lifecycle Manager</strong> is the library&#39;s founding charter—it establishes the library&#39;s existence, obtains an official address (major/minor number), and registers with the city (kernel). The <strong>Character Device Core</strong> is the front desk staff—they handle check-ins (open), accept donations of books (write), lend books (read), and process check-outs (release). The <strong>I/O Buffer</strong> is the library&#39;s shelves—a finite space where books (data) are stored linearly. The <strong>Synchronization Manager</strong> is the librarian enforcing rules—only one patron can rearrange shelves at a time (mutex), and patrons waiting for new books must sit in a waiting area (wait queue) until notified. The <strong>Proc/Control Interface</strong> is the library&#39;s administrative office and public bulletin board—authorized staff can issue commands to resize shelves or clear inventory (<code>ioctl</code>), while any visitor can view statistics like total books stored (<code>/proc</code> entry).</p>\n<h4 id=\"component-interactions-and-data-flow\">Component Interactions and Data Flow</h4>\n<p>When a userspace program calls <code>write()</code> on <code>/dev/mychardev</code>, the interaction flows through these components sequentially:</p>\n<ol>\n<li><strong>VFS Layer</strong> receives the system call and routes it to our driver&#39;s registered <code>file_operations.write</code> handler (Character Device Core).</li>\n<li><strong>Character Device Core</strong> validates parameters, then requests the <strong>Synchronization Manager</strong> to acquire the mutex protecting the buffer.</li>\n<li>With the lock held, the Core uses <code>copy_from_user</code> to transfer data from userspace into the <strong>I/O Buffer</strong>.</li>\n<li>After transfer, the Core notifies the <strong>Synchronization Manager</strong> to wake up any processes sleeping on the wait queue (blocked readers).</li>\n<li>The <strong>Synchronization Manager</strong> releases the mutex, and control returns up the chain.</li>\n</ol>\n<p>Similarly, when the module is loaded with <code>insmod</code>, the <strong>Module Lifecycle Manager</strong> executes first, allocating resources and registering the character device, which in turn creates the <code>/dev</code> node through kernel&#39;s device model. The <code>/proc</code> entry created by the <strong>Proc/Control Interface</strong> exists independently but reads statistics from the shared <code>struct mydevice_data</code>.</p>\n<blockquote>\n<p><strong>Architectural Insight:</strong> The driver follows a <strong>stateful singleton</strong> pattern. A single instance of <code>struct mydevice_data</code> contains all driver state (buffer, locks, device identifiers). This instance is globally accessible within the module but not exposed to other kernel modules. This design simplifies resource management because all cleanup can be performed by the Module Lifecycle Manager during module exit by freeing this one structure.</p>\n</blockquote>\n<h4 id=\"adr-monolithic-module-vs-multiple-source-files\">ADR: Monolithic Module vs. Multiple Source Files</h4>\n<p><strong>Decision: Single Source File for Core Logic with Separate Header for Shared Definitions</strong></p>\n<ul>\n<li><strong>Context:</strong> We must organize code for a learning-focused kernel module that demonstrates multiple concepts (device registration, file operations, ioctl, synchronization). The module is relatively small (~500 lines), but we need to share <code>ioctl</code> command definitions between kernel and userspace.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Single C file:</strong> Place all code in one <code>.c</code> file for simplicity.</li>\n<li><strong>Multiple C files:</strong> Split components (lifecycle, char device, proc) into separate <code>.c</code> files for modularity.</li>\n<li><strong>Core C file + shared header:</strong> Keep driver logic in one <code>.c</code> file but separate <code>ioctl</code> definitions into a shared header used by both kernel module and userspace test program.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Option 3 (Core C file + shared header).</li>\n<li><strong>Rationale:</strong> <ul>\n<li><strong>Learning Clarity:</strong> Beginners benefit from seeing the complete driver flow in one file without cross-file navigation.</li>\n<li><strong>Kernel Convention:</strong> Many simple drivers in Linux source tree use single-file organization.</li>\n<li><strong>Shared Definitions Necessity:</strong> <code>ioctl</code> command numbers and data structures must be identical in kernel and userspace; a shared header ensures consistency without duplication.</li>\n<li><strong>Build Simplicity:</strong> Single source file requires minimal <code>Makefile</code> complexity.</li>\n</ul>\n</li>\n<li><strong>Consequences:</strong><ul>\n<li><strong>Positive:</strong> Easy to trace code execution; straightforward compilation; clear separation of interface (header) and implementation.</li>\n<li><strong>Negative:</strong> File may become long; components are not physically isolated (though logically separated via functions).</li>\n<li><strong>Mitigation:</strong> Use clear section comments and logical grouping of functions by component.</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single C file</td>\n<td>Simplest build, all code visible in one place</td>\n<td>Can become monolithic, harder to navigate for very large drivers</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Multiple C files</td>\n<td>Better modularity, separation of concerns</td>\n<td>Increased build complexity, more cross-file references for learners</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Core C + shared header</td>\n<td>Balances simplicity with interface separation, mandatory for shared ioctl definitions</td>\n<td>Still single implementation file</td>\n<td><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"recommended-file-and-module-structure\">Recommended File and Module Structure</h3>\n<p>The physical layout of the project mirrors the logical decomposition while keeping the build process straightforward for learners. Following standard Linux kernel driver conventions, we place the module build configuration in a <code>Makefile</code> that invokes the kernel build system, and we separate userspace testing tools into their own directory.</p>\n<h4 id=\"directory-and-file-layout\">Directory and File Layout</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n│\n├── Makefile                    # Kbuild Makefile for kernel module compilation\n├── chardev.c                   # Main driver implementation (all components)\n├── chardev.h                   # Shared header with ioctl definitions, structs\n├── userspace/\n│   ├── Makefile               # Simple Makefile for userspace test programs\n│   ├── test_ioctl.c           # Test program for ioctl commands\n│   └── test_concurrent.c      # Stress test for concurrent access\n└── README.md                  # Project documentation</code></pre></div>\n\n<h4 id=\"file-responsibilities-table\">File Responsibilities Table</h4>\n<table>\n<thead>\n<tr>\n<th>File</th>\n<th>Purpose</th>\n<th>Key Contents</th>\n<th>Used By</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Makefile</code> (root)</td>\n<td>Invoke kernel build system to compile module</td>\n<td><code>obj-m += chardev.o</code>, Kbuild variables</td>\n<td>Developer building module</td>\n</tr>\n<tr>\n<td><code>chardev.c</code></td>\n<td>Implement all driver components</td>\n<td><code>module_init</code>/<code>exit</code>, <code>file_operations</code>, <code>proc_ops</code>, buffer management, mutex/waitqueue</td>\n<td>Kernel module (<code>insmod</code>)</td>\n</tr>\n<tr>\n<td><code>chardev.h</code></td>\n<td>Define shared constants and structures</td>\n<td><code>ioctl</code> command macros (<code>MYDEV_IOCTL_*</code>), <code>struct mydevice_data</code> declaration</td>\n<td><code>chardev.c</code> and userspace test programs</td>\n</tr>\n<tr>\n<td><code>userspace/Makefile</code></td>\n<td>Compile userspace test programs with <code>gcc</code></td>\n<td>Standard compilation rules</td>\n<td>Developer testing driver</td>\n</tr>\n<tr>\n<td><code>userspace/test_ioctl.c</code></td>\n<td>Demonstrate <code>ioctl</code> commands</td>\n<td>Includes <code>chardev.h</code>, calls <code>ioctl()</code> with various commands</td>\n<td>Manual testing of Milestone 3</td>\n</tr>\n<tr>\n<td><code>userspace/test_concurrent.c</code></td>\n<td>Stress test concurrent reads/writes</td>\n<td>Creates multiple processes performing simultaneous operations</td>\n<td>Validation of Milestone 4</td>\n</tr>\n</tbody></table>\n<h4 id=\"adr-in-tree-vs-out-of-tree-module-build\">ADR: In-Tree vs. Out-of-Tree Module Build</h4>\n<p><strong>Decision: Build as Out-of-Tree Module Using Installed Kernel Headers</strong></p>\n<ul>\n<li><strong>Context:</strong> The driver is a learning project not intended for inclusion in the main Linux kernel source tree. We need a build method that works on standard Linux distributions without requiring the full kernel source.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>In-tree build:</strong> Place driver source within the Linux kernel source tree and build using the kernel&#39;s top-level Makefile.</li>\n<li><strong>Out-of-tree with full kernel source:</strong> Require the entire kernel source code, building against a specific source tree.</li>\n<li><strong>Out-of-tree with kernel headers:</strong> Use only the installed kernel headers (typically <code>/lib/modules/$(uname -r)/build</code>) to compile.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Option 3 (Out-of-tree with kernel headers).</li>\n<li><strong>Rationale:</strong><ul>\n<li><strong>Practicality:</strong> Most developers have kernel headers installed via distribution packages (e.g., <code>linux-headers-$(uname -r)</code>), not the full multi-gigabyte kernel source.</li>\n<li><strong>Standard Practice:</strong> This is the recommended approach for third-party kernel modules in Linux distributions.</li>\n<li><strong>Version Matching:</strong> Using headers for the running kernel ensures compatibility with the exact kernel ABI.</li>\n</ul>\n</li>\n<li><strong>Consequences:</strong><ul>\n<li><strong>Positive:</strong> Minimal disk footprint; leverages distribution packaging; matches real-world driver development.</li>\n<li><strong>Negative:</strong> Cannot build for kernels other than the running one without installing additional header packages.</li>\n<li><strong>Mitigation:</strong> The <code>Makefile</code> uses <code>$(uname -r)</code> to detect current kernel version; developers can override <code>KERNELDIR</code> variable for cross-compilation.</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>In-tree build</td>\n<td>Accesses full kernel build infrastructure, easier upstreaming</td>\n<td>Requires entire kernel source, not practical for learning project</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Out-of-tree with full source</td>\n<td>More control over kernel configuration</td>\n<td>Still requires full kernel source, large download</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Out-of-tree with headers</td>\n<td>Lightweight, matches real-world module development</td>\n<td>Limited to installed kernel versions</td>\n<td><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h4 id=\"component-to-file-mapping\">Component-to-File Mapping</h4>\n<p>The logical components described earlier map to sections within <code>chardev.c</code> through function groupings and data structure ownership:</p>\n<ul>\n<li><strong>Module Lifecycle Manager:</strong> <code>init_module()</code> (or <code>mydevice_init()</code>) and <code>cleanup_module()</code> (or <code>mydevice_exit()</code>) functions, plus global <code>struct mydevice_data *dev_data</code>.</li>\n<li><strong>Character Device Core:</strong> <code>struct file_operations mydevice_fops</code> with handlers <code>mydevice_open()</code>, <code>mydevice_read()</code>, <code>mydevice_write()</code>, <code>mydevice_release()</code>.</li>\n<li><strong>I/O Buffer:</strong> Fields within <code>struct mydevice_data</code>: <code>void *buffer</code>, <code>size_t size</code>, managed by helper functions <code>buffer_alloc()</code>, <code>buffer_free()</code>.</li>\n<li><strong>Synchronization Manager:</strong> Mutex and wait queue operations within read/write handlers, plus <code>mydevice_poll()</code> handler.</li>\n<li><strong>Proc/Control Interface:</strong> <code>mydevice_ioctl()</code> handler and <code>/proc</code> file operations via <code>struct proc_ops</code>.</li>\n</ul>\n<blockquote>\n<p><strong>Design Principle:</strong> While components are logically separate, they share the same <code>struct mydevice_data</code> instance. This centralizes state management and ensures all components have consistent view of device state. The mutex within this structure protects access across all components that touch the buffer.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This subsection provides concrete starting points for implementing the architectural structure described above. The guidance assumes the primary language is C and follows Linux kernel programming conventions.</p>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Recommended for Learning)</th>\n<th>Advanced Option (For Further Exploration)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Build System</td>\n<td>Kbuild with external module Makefile</td>\n<td>DKMS (Dynamic Kernel Module Support) for automatic rebuild on kernel updates</td>\n</tr>\n<tr>\n<td>Memory Allocation</td>\n<td><code>kmalloc()</code> + <code>kfree()</code> for simple buffer</td>\n<td><code>vmalloc()</code> for large buffers (&gt;1 page), or slab allocator for many objects</td>\n</tr>\n<tr>\n<td>Synchronization</td>\n<td><code>mutex</code> + <code>wait_queue_head_t</code></td>\n<td><code>rw_semaphore</code> for reader/writer pattern, or RCU for read-mostly data</td>\n</tr>\n<tr>\n<td>Proc Interface</td>\n<td><code>proc_create()</code> with <code>proc_ops</code> using <code>single_open</code></td>\n<td>Full <code>seq_file</code> interface for large outputs, or debugfs for debugging data</td>\n</tr>\n<tr>\n<td>Userspace Testing</td>\n<td>Simple C programs with <code>open()</code>/<code>read()</code>/<code>write()</code>/<code>ioctl()</code></td>\n<td>Python scripts using <code>ctypes</code> or <code>fcntl</code>, or automated test suite with kernel CI</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure-expanded\">B. Recommended File/Module Structure (Expanded)</h4>\n<p>Create the following files with the initial content shown below. This structure implements the architectural decisions and provides a scaffold for each milestone.</p>\n<p><strong>Project Root <code>Makefile</code>:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">makefile</span><pre class=\"arch-pre shiki-highlighted\"><code># Kbuild syntax for out-of-tree kernel module building\nobj-m += chardev.o\n\n# Kernel headers location (adjust if cross-compiling)\nKERNELDIR ?= /lib/modules/$(shell uname -r)/build\nPWD := $(shell pwd)\n\nall:\n\t$(MAKE) -C $(KERNELDIR) M=$(PWD) modules\n\nclean:\n\t$(MAKE) -C $(KERNELDIR) M=$(PWD) clean\n\ninstall: all\n\tsudo insmod chardev.ko\n\nuninstall:\n\tsudo rmmod chardev\n\n# Userspace test programs\nuserspace:\n\t$(MAKE) -C userspace\n\n.PHONY: all clean install uninstall userspace</code></pre></div>\n\n<p><strong>Main Driver Header <code>chardev.h</code>:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> _CHARDEV_H_</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> _CHARDEV_H_</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/ioctl.h></span><span style=\"color:#6A737D\">  // For _IOR, _IOW macros</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Define a magic number for our ioctl commands</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This should be unique to avoid conflicts with other drivers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOC_MAGIC</span><span style=\"color:#9ECBFF\"> 'k'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IOCTL command definitions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RESIZE: takes new buffer size as integer argument</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOCTL_RESIZE</span><span style=\"color:#B392F0\"> _IOW</span><span style=\"color:#E1E4E8\">(MYDEVICE_IOC_MAGIC, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CLEAR: no argument, just clear buffer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOCTL_CLEAR</span><span style=\"color:#B392F0\"> _IO</span><span style=\"color:#E1E4E8\">(MYDEVICE_IOC_MAGIC, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GET_SIZE: returns current buffer size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOCTL_GET_SIZE</span><span style=\"color:#B392F0\"> _IOR</span><span style=\"color:#E1E4E8\">(MYDEVICE_IOC_MAGIC, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GET_MAX_CAPACITY: returns maximum allowed buffer size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOCTL_GET_MAX_CAPACITY</span><span style=\"color:#B392F0\"> _IOR</span><span style=\"color:#E1E4E8\">(MYDEVICE_IOC_MAGIC, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Maximum buffer size limit (safety measure)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_BUFFER_SIZE</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  // 1MB</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Device name for /dev and proc entries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEVICE_NAME</span><span style=\"color:#9ECBFF\"> \"mychardev\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\">  // _CHARDEV_H_</span></span></code></pre></div>\n\n<p><strong>Main Driver Implementation <code>chardev.c</code> Skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// SPDX-License-Identifier: GPL-2.0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Simple character device driver for educational purposes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Implements a kernel buffer accessible via /dev/mychardev</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/module.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/fs.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/cdev.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/device.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/slab.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/uaccess.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/mutex.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/wait.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/poll.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/proc_fs.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/seq_file.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"chardev.h\"</span><span style=\"color:#6A737D\">  // Our shared header</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// --- Module Lifecycle Manager Component ---</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Global device data structure (singleton instance)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydevice_data {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">buffer;</span><span style=\"color:#6A737D\">           // I/O Buffer: kernel memory for stored data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span><span style=\"color:#6A737D\">            // I/O Buffer: current allocated size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> data_len;</span><span style=\"color:#6A737D\">        // I/O Buffer: amount of valid data stored</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> mutex mutex;</span><span style=\"color:#6A737D\">     // Synchronization Manager: mutual exclusion lock</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    wait_queue_head_t</span><span style=\"color:#E1E4E8\"> read_wait;</span><span style=\"color:#6A737D\"> // Synchronization Manager: queue for blocking reads</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> cdev cdev;</span><span style=\"color:#6A737D\">       // Character Device Core: kernel's char device structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    dev_t</span><span style=\"color:#E1E4E8\"> dev_num;</span><span style=\"color:#6A737D\">          // Module Lifecycle: device major/minor number</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> class </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">dev_class;</span><span style=\"color:#6A737D\"> // Module Lifecycle: sysfs class for device creation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> device </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">dev;</span><span style=\"color:#6A737D\">     // Module Lifecycle: actual device instance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">dev_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO 1: Implement module initialization function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Responsibilities:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 1. Allocate dev_data with kmalloc</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 2. Initialize mutex and wait queue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 3. Allocate initial buffer (e.g., 4KB)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 4. Register character device region with alloc_chrdev_region</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 5. Create sysfs class and device node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 6. Set up cdev structure with file_operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> __init </span><span style=\"color:#B392F0\">mydevice_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydevice: Initializing driver</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Fill with implementation from Milestone 1 and 2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO 2: Implement module cleanup function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Responsibilities:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 1. Remove /proc entry if created</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 2. Destroy device node and class</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 3. Unregister character device region</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 4. Free buffer memory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 5. Free dev_data structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#E1E4E8\"> __exit </span><span style=\"color:#B392F0\">mydevice_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydevice: Cleaning up driver</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Fill with implementation from Milestone 1 and 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// --- Character Device Core Component ---</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO 3: Implement file_operations methods</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// open: simple increment of module usage count</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydevice_open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> inode </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Fill with implementation from Milestone 2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// release: decrement module usage count</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydevice_release</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> inode </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Fill with implementation from Milestone 2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// read: copy data from kernel buffer to userspace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Must handle:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Blocking when buffer empty (use wait_event_interruptible)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Partial reads (return less than count)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Proper offset management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydevice_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                            size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">loff_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">f_pos</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Fill with implementation from Milestone 2 and 4</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> retval;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// write: copy data from userspace to kernel buffer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Must handle:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Buffer capacity limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Waking up sleeping readers after write</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydevice_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                             size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">loff_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">f_pos</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Fill with implementation from Milestone 2 and 4</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> retval;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// poll: support for select()/poll() system calls</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> __poll_t</span><span style=\"color:#B392F0\"> mydevice_poll</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, poll_table </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">wait</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    __poll_t</span><span style=\"color:#E1E4E8\"> mask </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Fill with implementation from Milestone 4</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> mask;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Define the file_operations structure linking handlers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> file_operations mydevice_fops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .owner </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> THIS_MODULE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .open </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_open,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .release </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_release,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .read </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_read,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .write </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_write,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .poll </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_poll,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .unlocked_ioctl </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_ioctl,</span><span style=\"color:#6A737D\">  // Defined in Control Interface</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // .llseek = no_llseek,  // Optional: device doesn't support seek</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// --- Control Interface Component ---</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO 4: Implement ioctl handler</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Responsibilities:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 1. Use switch statement on cmd argument</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 2. Handle MYDEVICE_IOCTL_RESIZE: validate size, realloc buffer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 3. Handle MYDEVICE_IOCTL_CLEAR: reset data_len to 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 4. Handle MYDEVICE_IOCTL_GET_SIZE: return current buffer size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 5. Handle MYDEVICE_IOCTL_GET_MAX_CAPACITY: return MAX_BUFFER_SIZE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 6. For invalid commands, return -ENOTTY</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> long</span><span style=\"color:#B392F0\"> mydevice_ioctl</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> int</span><span style=\"color:#FFAB70\"> cmd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> arg</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\"> retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Fill with implementation from Milestone 3</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> retval;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO 5: Implement /proc file operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// proc_show: display device statistics when /proc/mychardev is read</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydevice_proc_show</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> seq_file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">m</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">v</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Fill with implementation from Milestone 3</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Example: seq_printf(m, \"Buffer size: %zu\\n\", dev_data->size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydevice_proc_open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> inode </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">file</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> single_open</span><span style=\"color:#E1E4E8\">(file, mydevice_proc_show, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> proc_ops mydevice_proc_fops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .proc_open </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_proc_open,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .proc_read </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> seq_read,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .proc_lseek </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> seq_lseek,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .proc_release </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> single_release,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Module metadata</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_LICENSE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"GPL\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_AUTHOR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Your Name\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_DESCRIPTION</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Simple character device driver for learning\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_VERSION</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"0.1\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Register init/exit functions</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">module_init</span><span style=\"color:#E1E4E8\">(mydevice_init);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">module_exit</span><span style=\"color:#E1E4E8\">(mydevice_exit);</span></span></code></pre></div>\n\n<p><strong>Userspace Test Program <code>userspace/test_ioctl.c</code> Skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;fcntl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/ioctl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"../chardev.h\"</span><span style=\"color:#6A737D\">  // Shared header with ioctl definitions</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#F97583\">[]</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/dev/\"</span><span style=\"color:#E1E4E8\"> DEVICE_NAME, O_RDWR);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to open device\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test various ioctl commands</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. GET_SIZE to see initial size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. RESIZE to change buffer size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. WRITE some data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. READ back data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. CLEAR buffer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 6. GET_MAX_CAPACITY to see limit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p>For components that are prerequisites but not core learning goals, here is complete helper code that can be added to <code>chardev.c</code>:</p>\n<p><strong>Buffer Management Helpers (I/O Buffer Component):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Allocate or resize the internal buffer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> buffer_resize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">dev</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> new_size</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">new_buf;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (new_size </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> MAX_BUFFER_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydevice: Requested size </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> exceeds maximum </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               new_size, MAX_BUFFER_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_buf </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(new_size, GFP_KERNEL);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">new_buf) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydevice: Failed to allocate buffer of size </span><span style=\"color:#79B8FF\">%zu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               new_size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOMEM;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Copy existing data (up to minimum of old and new size)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (dev->buffer) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> copy_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (dev->data_len </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> new_size) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> dev->data_len </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> new_size;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memcpy</span><span style=\"color:#E1E4E8\">(new_buf, dev->buffer, copy_len);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dev->data_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> copy_len;</span><span style=\"color:#6A737D\">  // Truncate if buffer shrunk</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kfree</span><span style=\"color:#E1E4E8\">(dev->buffer);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dev->data_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dev->buffer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_buf;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dev->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_size;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydevice: Buffer resized to </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, new_size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize buffer with default size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> buffer_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">dev</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> initial_size</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dev->buffer </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dev->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dev->data_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> buffer_resize</span><span style=\"color:#E1E4E8\">(dev, initial_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Free buffer memory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> buffer_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">dev</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (dev->buffer) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kfree</span><span style=\"color:#E1E4E8\">(dev->buffer);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dev->buffer </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dev->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dev->data_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p>For the core components learners should implement themselves, here are detailed TODO skeletons mapping to the architectural responsibilities:</p>\n<p><strong>Module Initialization Detailed TODOs:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> __init </span><span style=\"color:#B392F0\">mydevice_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    dev_t</span><span style=\"color:#E1E4E8\"> dev </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydevice: Initializing driver</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1.1: Allocate dev_data with kzalloc (zero-initialized)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use GFP_KERNEL flag, check for NULL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1.2: Initialize mutex with mutex_init()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1.3: Initialize wait queue with init_waitqueue_head()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1.4: Allocate initial buffer (e.g., 4096 bytes) using buffer_init()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1.5: Allocate device numbers with alloc_chrdev_region()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Use &#x26;dev for first device number</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Base minor = 0, count = 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Device name = DEVICE_NAME</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Check return value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1.6: Initialize cdev structure with cdev_init()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Link to mydevice_fops</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Add to system with cdev_add()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1.7: Create device class with class_create()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - THIS_MODULE as owner</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Name = DEVICE_NAME \"_class\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1.8: Create device node with device_create()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Use created class, parent = NULL, devt = dev</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Device data = dev_data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Name = DEVICE_NAME</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1.9: Create /proc entry with proc_create()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Name = DEVICE_NAME</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Mode = 0444 (read-only)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Link to mydevice_proc_fops</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1.10: On any failure, clean up already-allocated resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // in reverse order (implement goto error handling pattern)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints-kernel-c\">E. Language-Specific Hints (Kernel C)</h4>\n<ol>\n<li><p><strong>Error Codes:</strong> Always return negative <code>errno</code> values (e.g., <code>-ENOMEM</code>, <code>-EINVAL</code>) from kernel functions called by userspace system calls. The VFS will convert these to <code>-1</code> return with appropriate <code>errno</code> in userspace.</p>\n</li>\n<li><p><strong>Memory Allocation:</strong> Use <code>GFP_KERNEL</code> for allocations that can sleep (in process context). Never use <code>GFP_KERNEL</code> in interrupt context or while holding a spinlock.</p>\n</li>\n<li><p><strong>Print Debugging:</strong> Use <code>printk</code> with appropriate log levels: <code>KERN_INFO</code> for normal messages, <code>KERN_ERR</code> for errors. View output with <code>dmesg -w</code> to watch in real-time.</p>\n</li>\n<li><p><strong>User Memory Access:</strong> Always use <code>copy_to_user()</code> and <code>copy_from_user()</code>—never dereference userspace pointers directly. Check return values (0 = success, &gt;0 = number of bytes NOT copied).</p>\n</li>\n<li><p><strong>Module Parameters:</strong> Consider adding <code>module_param()</code> macros later to allow configuration via <code>insmod chardev.ko buffer_size=8192</code>.</p>\n</li>\n</ol>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing the high-level architecture with the skeleton code:</p>\n<ol>\n<li><strong>Build Verification:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   make</span><span style=\"color:#6A737D\">  # Should output: CC [M]  chardev.o; Building modules, [OK]</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Module Info Check:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   modinfo</span><span style=\"color:#9ECBFF\"> chardev.ko</span></span></code></pre></div>\n<p>   Expected output shows correct license, author, description.</p>\n<ol start=\"3\">\n<li><strong>Load Test:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   sudo</span><span style=\"color:#9ECBFF\"> insmod</span><span style=\"color:#9ECBFF\"> chardev.ko</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   dmesg</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tail</span><span style=\"color:#79B8FF\"> -5</span></span></code></pre></div>\n<p>   Should show &quot;mydevice: Initializing driver&quot; and no error messages.</p>\n<ol start=\"4\">\n<li><strong>Device Node Creation:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /dev/mychardev</span></span></code></pre></div>\n<p>   Should show character device with major/minor numbers.</p>\n<ol start=\"5\">\n<li><strong>Proc Entry Verification:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   cat</span><span style=\"color:#9ECBFF\"> /proc/mychardev</span></span></code></pre></div>\n<p>   Should show buffer statistics (once implemented).</p>\n<p>If any step fails, check <code>dmesg</code> for kernel error messages—they often provide specific failure reasons like &quot;Cannot allocate memory&quot; or &quot;Device or resource busy&quot;.</p>\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>insmod</code> fails with &quot;Unknown symbol in module&quot;</td>\n<td>Missing module license or dependency</td>\n<td>`dmesg</td>\n<td>tail` shows which symbol is missing</td>\n</tr>\n<tr>\n<td><code>/dev/mychardev</code> not created</td>\n<td>Device creation failed in init</td>\n<td>Check <code>dmesg</code> for &quot;device_create failed&quot;</td>\n<td>Verify <code>class_create()</code> succeeded before <code>device_create()</code></td>\n</tr>\n<tr>\n<td>Write succeeds but read returns 0</td>\n<td>Buffer not being filled or read offset wrong</td>\n<td>Add <code>printk</code> in read/write to trace data flow</td>\n<td>Ensure <code>data_len</code> is updated on write and read updates offset</td>\n</tr>\n<tr>\n<td>Multiple processes cause system hang</td>\n<td>Deadlock in mutex usage</td>\n<td>Add debug prints before/after mutex_lock/unlock</td>\n<td>Check for double-locking or missing unlock on error paths</td>\n</tr>\n<tr>\n<td><code>ioctl</code> returns <code>-1</code> with <code>errno=22</code> (EINVAL)</td>\n<td>Invalid ioctl command number mismatch</td>\n<td>Compare command numbers in kernel and userspace headers</td>\n<td>Ensure <code>chardev.h</code> is identical in kernel and userspace builds</td>\n</tr>\n</tbody></table>\n<h2 id=\"data-model\">Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2, Milestone 3, Milestone 4 (data structures and ioctl definitions)</p>\n</blockquote>\n<p>This section defines the fundamental building blocks that represent the driver&#39;s internal state and the contract for communication with user-space applications. In kernel programming, data structures must be carefully designed to ensure thread safety, proper memory management, and clear boundaries between kernel and user space. The data model serves as the &quot;source of truth&quot; for what the driver can do and how it maintains its state across multiple concurrent accesses.</p>\n<h3 id=\"kernel-side-data-structures\">Kernel-Side Data Structures</h3>\n<p><strong>Mental Model: The Driver&#39;s Filing Cabinet</strong></p>\n<p>Think of the driver&#39;s internal data as a specialized filing cabinet in a shared office (the kernel). Each drawer (data structure field) holds specific types of information, and there are rules about who can open which drawers and when. The main cabinet, <code>struct mydevice_data</code>, contains everything the driver needs to operate: a drawer for storing data (buffer), a lock to prevent two people from accessing the cabinet simultaneously (mutex), a waiting area for people expecting new documents (wait queue), and identification tags so the office manager (kernel) knows which cabinet is which (device identifiers). This cabinet exists only in the secured office area (kernel space) and cannot be directly accessed from the public area (user space).</p>\n<p>The primary data structure, <code>struct mydevice_data</code>, encapsulates the complete state of a single device instance. Since this driver follows the <strong>singleton pattern</strong> (one device instance), a single global instance of this structure manages all operations. The structure must be allocated and initialized during module loading and cleaned up during module unloading.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>buffer</code></td>\n<td><code>void*</code></td>\n<td>Pointer to dynamically allocated kernel memory that stores data written from user space. Acts as a simple linear buffer where data is appended at the end and read from the beginning.</td>\n</tr>\n<tr>\n<td><code>size</code></td>\n<td><code>size_t</code></td>\n<td>Total capacity of the buffer in bytes. This represents the maximum amount of data the buffer can hold at any time, set during initialization and potentially changed via <code>ioctl</code> resize operations.</td>\n</tr>\n<tr>\n<td><code>data_len</code></td>\n<td><code>size_t</code></td>\n<td>Current number of valid bytes stored in the buffer. This tracks how much of the buffer&#39;s capacity is actually occupied with data available for reading. When <code>data_len</code> is 0, the buffer is empty; when equal to <code>size</code>, the buffer is full.</td>\n</tr>\n<tr>\n<td><code>mutex</code></td>\n<td><code>struct mutex</code></td>\n<td>Mutual exclusion lock that protects all accesses to the buffer and related fields (<code>buffer</code>, <code>size</code>, <code>data_len</code>). Ensures that only one thread (or process) can modify the buffer state at a time, preventing data corruption from concurrent writes or simultaneous read/write operations.</td>\n</tr>\n<tr>\n<td><code>read_wait</code></td>\n<td><code>struct wait_queue_head_t</code></td>\n<td>Wait queue head where reader processes can sleep when the buffer is empty. When a process tries to read but <code>data_len</code> is 0, it adds itself to this queue and sleeps until a writer adds data and wakes it up.</td>\n</tr>\n<tr>\n<td><code>cdev</code></td>\n<td><code>struct cdev</code></td>\n<td>Embedded character device structure that links our driver to the kernel&#39;s character device subsystem. Contains pointers to our <code>file_operations</code> functions and is registered with the kernel via <code>cdev_add</code>.</td>\n</tr>\n<tr>\n<td><code>dev_num</code></td>\n<td><code>dev_t</code></td>\n<td>Combined device number (major and minor) assigned during <code>alloc_chrdev_region</code>. The major number identifies our driver type, while the minor number (always 0 for our singleton) identifies this specific device instance.</td>\n</tr>\n<tr>\n<td><code>dev_class</code></td>\n<td><code>struct class*</code></td>\n<td>Pointer to the device class created via <code>class_create</code>. Used by the kernel&#39;s <code>sysfs</code> to expose device information in <code>/sys/class/</code>.</td>\n</tr>\n<tr>\n<td><code>device</code></td>\n<td><code>struct device*</code></td>\n<td>Pointer to the device instance created via <code>device_create</code>. This triggers the automatic creation of the device node in <code>/dev/</code> (e.g., <code>/dev/mychardev</code>).</td>\n</tr>\n</tbody></table>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiagram-data-model.svg\" alt=\"Data Model and State Relationships\"></p>\n<p><strong>State Transitions and Buffer Management</strong></p>\n<p>The buffer operates as a simple linear storage with three primary states, which can be modeled as a state machine:</p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Event</th>\n<th>Next State</th>\n<th>Actions Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>EMPTY</strong> (<code>data_len == 0</code>)</td>\n<td>Write successful (bytes &gt; 0)</td>\n<td><strong>PARTIALLY_FILLED</strong></td>\n<td>Increment <code>data_len</code> by written bytes, wake up any sleeping readers on <code>read_wait</code></td>\n</tr>\n<tr>\n<td><strong>EMPTY</strong></td>\n<td>Read attempted</td>\n<td><strong>EMPTY</strong> (unchanged)</td>\n<td>Reader process sleeps on <code>read_wait</code> (blocking), returns 0 if non-blocking</td>\n</tr>\n<tr>\n<td><strong>PARTIALLY_FILLED</strong> (<code>0 &lt; data_len &lt; size</code>)</td>\n<td>Write successful</td>\n<td><strong>PARTIALLY_FILLED</strong> or <strong>FULL</strong></td>\n<td>Increment <code>data_len</code>, if <code>data_len</code> reaches <code>size</code>, transition to FULL</td>\n</tr>\n<tr>\n<td><strong>PARTIALLY_FILLED</strong></td>\n<td>Read successful</td>\n<td><strong>PARTIALLY_FILLED</strong> or <strong>EMPTY</strong></td>\n<td>Decrement <code>data_len</code> by read bytes, if <code>data_len</code> becomes 0, transition to EMPTY</td>\n</tr>\n<tr>\n<td><strong>FULL</strong> (<code>data_len == size</code>)</td>\n<td>Write attempted</td>\n<td><strong>FULL</strong> (unchanged)</td>\n<td>Write returns <code>-ENOSPC</code> (no space), writer may block or return immediately</td>\n</tr>\n<tr>\n<td><strong>FULL</strong></td>\n<td>Read successful</td>\n<td><strong>PARTIALLY_FILLED</strong></td>\n<td>Decrement <code>data_len</code> by read bytes, wake up any sleeping writers (if we implement blocking write)</td>\n</tr>\n</tbody></table>\n<p><strong>Relationship Between Structures</strong></p>\n<p>The <code>struct mydevice_data</code> serves as the central hub connecting all driver components. The <code>cdev</code> field links to the VFS layer when file operations occur—when a user-space process opens <code>/dev/mychardev</code>, the kernel finds our <code>cdev</code>, which points to our <code>file_operations</code> functions, and passes the <code>struct mydevice_data</code> as the <code>private_data</code> in the <code>struct file</code>. The <code>mutex</code> protects concurrent access to the buffer, while the <code>read_wait</code> enables synchronization between readers and writers. The <code>dev_class</code> and <code>device</code> fields connect to the device model, creating the user-visible interface in <code>/dev/</code>.</p>\n<p><strong>Memory Lifetime and Ownership</strong></p>\n<p>The <code>buffer</code> pointer owns a dynamically allocated memory region via <code>kmalloc</code>. Its lifetime is tied to the module: allocated in <code>mydevice_init</code> (or on first resize), potentially reallocated during resize operations, and freed in <code>mydevice_exit</code>. The <code>size</code> field tracks the current allocation size, while <code>data_len</code> tracks how much is actually in use. All other fields (mutex, wait queue, cdev) are initialized during module init and cleaned up during exit.</p>\n<blockquote>\n<p><strong>Design Insight:</strong> Using a single structure that contains all driver state (<code>struct mydevice_data</code>) is crucial for kernel programming. It provides a clear ownership model (the module owns this structure), simplifies error cleanup (one structure to free), and enables safe concurrent access (one mutex protecting all related data). This pattern is standard in Linux device drivers.</p>\n</blockquote>\n<h3 id=\"user-space-ioctl-command-format\">User-Space Ioctl Command Format</h3>\n<p><strong>Mental Model: The Driver&#39;s Remote Control</strong></p>\n<p>Imagine the <code>ioctl</code> interface as a specialized remote control for our device. Each button on the remote (ioctl command) performs a specific action: one button resizes the buffer, another clears it, and others query status information. The remote communicates with the device using a predefined protocol (command numbers and data structures) that both sides understand. User-space applications &quot;press buttons&quot; by calling <code>ioctl()</code> with the right command code and optional parameters, and the driver executes the corresponding action and returns results.</p>\n<p>The <code>ioctl</code> interface requires careful definition to ensure compatibility between kernel and user space. We define a shared header file (e.g., <code>mydevice.h</code>) that contains command numbers and any data structures used for parameter passing. This header is included by both the kernel module and user-space test programs.</p>\n<blockquote>\n<p><strong>Decision: Centralized ioctl Command Definitions</strong></p>\n<ul>\n<li><strong>Context</strong>: <code>ioctl</code> commands must be uniquely identified by numbers that both kernel and user space agree upon. We need a consistent way to define these commands that prevents collisions and ensures type safety.</li>\n<li><strong>Options Considered</strong>: <ol>\n<li><strong>Hard-coded numbers in both places</strong>: Define the same numeric constants separately in kernel and user code.</li>\n<li><strong>Shared header file with macros</strong>: Create a single header file that uses Linux&#39;s <code>_IO*</code> macros, included by both kernel and user programs.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use a shared header file with properly constructed <code>ioctl</code> commands using the standard Linux macros (<code>_IOR</code>, <code>_IOW</code>, <code>_IOWR</code>).</li>\n<li><strong>Rationale</strong>: The shared header ensures consistency and prevents subtle bugs where kernel and user space disagree on command numbers. The standard macros incorporate direction (read/write) and data size, providing compile-time checks and documentation. This is the established Linux driver pattern.</li>\n<li><strong>Consequences</strong>: User-space programs must include this header; any changes to command definitions require recompilation of both kernel module and user programs.</li>\n</ul>\n</blockquote>\n<p><strong>Ioctl Command Number Construction</strong></p>\n<p>Linux <code>ioctl</code> commands are 32-bit numbers divided into fields:</p>\n<ul>\n<li><strong>Direction</strong> (bits 30-31): Whether data flows from user to kernel (<code>_IOW</code>), kernel to user (<code>_IOR</code>), both (<code>_IOWR</code>), or none (<code>_IO</code>).</li>\n<li><strong>Size</strong> (bits 16-29): Size of the data argument passed.</li>\n<li><strong>Type</strong> (bits 8-15): &quot;Magic number&quot; unique to our driver, preventing collisions with other drivers.</li>\n<li><strong>Number</strong> (bits 0-7): The specific command within our driver.</li>\n</ul>\n<p>We define our magic number and commands as follows:</p>\n<table>\n<thead>\n<tr>\n<th>Constant</th>\n<th>Value/Definition</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>MYDEVICE_IOC_MAGIC</code></td>\n<td><code>&#39;k&#39;</code> (ASCII character)</td>\n<td>Unique magic number for our driver (chosen from unallocated range).</td>\n</tr>\n<tr>\n<td><code>MYDEVICE_IOCTL_GET_SIZE</code></td>\n<td><code>_IOR(MYDEVICE_IOC_MAGIC, 1, size_t)</code></td>\n<td>Command to get current buffer size (data flows from kernel to user).</td>\n</tr>\n<tr>\n<td><code>MYDEVICE_IOCTL_GET_MAX_CAPACITY</code></td>\n<td><code>_IOR(MYDEVICE_IOC_MAGIC, 2, size_t)</code></td>\n<td>Command to get maximum allowed buffer size (1MB).</td>\n</tr>\n<tr>\n<td><code>MYDEVICE_IOCTL_CLEAR</code></td>\n<td><code>_IO(MYDEVICE_IOC_MAGIC, 3)</code></td>\n<td>Command to clear buffer (no data argument).</td>\n</tr>\n<tr>\n<td><code>MYDEVICE_IOCTL_RESIZE</code></td>\n<td><code>_IOW(MYDEVICE_IOC_MAGIC, 4, size_t)</code></td>\n<td>Command to resize buffer (data flows from user to kernel).</td>\n</tr>\n</tbody></table>\n<p><strong>Data Structures for Parameter Passing</strong></p>\n<p>For commands that transfer data (<code>_IOR</code>, <code>_IOW</code>, <code>_IOWR</code>), we use standard C types. The <code>size_t</code> type is used for size-related operations, but we must be careful about its size differences between kernel and user space (both are typically 64-bit on modern systems, but we should use <code>__kernel_size_t</code> in the shared header for portability). For more complex drivers, custom structures would be defined here.</p>\n<p><strong>Maximum Buffer Size Limitation</strong></p>\n<p>We define <code>MAX_BUFFER_SIZE</code> as <code>(1024 * 1024)</code> (1 MiB) to prevent users from accidentally requesting excessive kernel memory. This protects the system from denial-of-service attacks where a malicious user might try to allocate huge buffers.</p>\n<p><strong>Ioctl Command Semantics</strong></p>\n<p>Each command has specific behavior and error conditions:</p>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>User-Space Argument</th>\n<th>Kernel Action</th>\n<th>Success Return</th>\n<th>Error Conditions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>MYDEVICE_IOCTL_GET_SIZE</code></td>\n<td>Pointer to <code>size_t</code></td>\n<td>Copies <code>dev-&gt;size</code> to user pointer</td>\n<td>0</td>\n<td><code>-EFAULT</code> if <code>copy_to_user</code> fails</td>\n</tr>\n<tr>\n<td><code>MYDEVICE_IOCTL_GET_MAX_CAPACITY</code></td>\n<td>Pointer to <code>size_t</code></td>\n<td>Copies <code>MAX_BUFFER_SIZE</code> to user pointer</td>\n<td>0</td>\n<td><code>-EFAULT</code> if <code>copy_to_user</code> fails</td>\n</tr>\n<tr>\n<td><code>MYDEVICE_IOCTL_CLEAR</code></td>\n<td>None (ignored)</td>\n<td>Sets <code>dev-&gt;data_len = 0</code></td>\n<td>0</td>\n<td>None (always succeeds)</td>\n</tr>\n<tr>\n<td><code>MYDEVICE_IOCTL_RESIZE</code></td>\n<td><code>size_t</code> new_size</td>\n<td>Reallocates buffer to new size (if ≤ <code>MAX_BUFFER_SIZE</code>)</td>\n<td>0</td>\n<td><code>-EINVAL</code> if new_size &gt; <code>MAX_BUFFER_SIZE</code>, <code>-ENOMEM</code> if allocation fails, <code>-EFAULT</code> if <code>copy_from_user</code> fails</td>\n</tr>\n</tbody></table>\n<p><strong>Example User-Space Usage</strong></p>\n<p>A user-space program would use these commands like:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"mydevice.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/dev/mychardev\"</span><span style=\"color:#E1E4E8\">, O_RDWR);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> current_size;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ioctl</span><span style=\"color:#E1E4E8\">(fd, MYDEVICE_IOCTL_GET_SIZE, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">current_size</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<h3 id=\"common-pitfalls-data-model\">Common Pitfalls: Data Model</h3>\n<p>⚠️ <strong>Pitfall: Uninitialized mutex or wait queue</strong></p>\n<ul>\n<li><strong>Description</strong>: Forgetting to initialize the mutex with <code>mutex_init()</code> or the wait queue with <code>init_waitqueue_head()</code> before using them.</li>\n<li><strong>Why it&#39;s wrong</strong>: An uninitialized mutex or wait queue leads to undefined behavior, often causing immediate kernel panics or deadlocks when first accessed.</li>\n<li><strong>Fix</strong>: Always initialize synchronization primitives in the module&#39;s initialization function before any concurrent access is possible.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Incorrect buffer size tracking</strong></p>\n<ul>\n<li><strong>Description</strong>: Mismanaging the relationship between <code>size</code> (capacity) and <code>data_len</code> (used bytes), such as allowing <code>data_len</code> to exceed <code>size</code> or not updating <code>data_len</code> after operations.</li>\n<li><strong>Why it&#39;s wrong</strong>: This can cause buffer overflows (writing past allocated memory) or incorrect behavior where reads return wrong data or hang indefinitely.</li>\n<li><strong>Fix</strong>: Always update <code>data_len</code> atomically with buffer operations, and check boundaries before any read/write.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Wrong ioctl command numbering</strong></p>\n<ul>\n<li><strong>Description</strong>: Using arbitrary numbers for ioctl commands without the proper <code>_IOR</code>/<code>_IOW</code> macros, or using the same command number for different operations.</li>\n<li><strong>Why it&#39;s wrong</strong>: Command number collisions can cause the wrong handler to execute; incorrect direction/size encoding can cause memory corruption or failed copies.</li>\n<li><strong>Fix</strong>: Always use the standard macros with a unique magic number, and document each command clearly in the shared header.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Assuming size_t is same size in kernel and user space</strong></p>\n<ul>\n<li><strong>Description</strong>: Using <code>size_t</code> in shared header without considering that kernel and user space might compile with different definitions (though rare on same architecture).</li>\n<li><strong>Why it&#39;s wrong</strong>: If sizes differ, <code>copy_to_user</code>/<code>copy_from_user</code> may copy wrong amount of data, causing corruption.</li>\n<li><strong>Fix</strong>: Use <code>__kernel_size_t</code> in shared headers or explicitly use fixed-width types like <code>uint64_t</code>.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>A. Technology Recommendations Table</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Buffer Storage</td>\n<td>Linear <code>kmalloc</code> buffer with separate <code>size</code>/<code>data_len</code></td>\n<td>Circular buffer with head/tail pointers for better performance</td>\n</tr>\n<tr>\n<td>Ioctl Interface</td>\n<td>Standard <code>_IOR</code>/<code>_IOW</code> macros with <code>size_t</code> parameters</td>\n<td>Complex structures with versioning and capability flags</td>\n</tr>\n<tr>\n<td>State Tracking</td>\n<td>Simple <code>data_len</code> counter</td>\n<td>Bitmask flags for buffer states (EMPTY, FULL, etc.)</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  Makefile                    # Kbuild makefile\n  mychardev.c                 # Main driver implementation\n  mychardev.h                 # Shared header for ioctl definitions (included by kernel AND user)\n  test_mychardev.c            # Userspace test program</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p><strong>File: <code>mychardev.h</code></strong> (shared header)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> MYCHARDEV_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYCHARDEV_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/ioctl.h></span><span style=\"color:#6A737D\">  // For _IOR, _IOW, etc.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/types.h></span><span style=\"color:#6A737D\">  // For __kernel_size_t</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Magic number for our ioctl commands */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOC_MAGIC</span><span style=\"color:#9ECBFF\"> 'k'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Maximum buffer size (1 MiB) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_BUFFER_SIZE</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Sizes of arguments for ioctl commands.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * We use __kernel_size_t which is the kernel's size_t type,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * ensuring consistency between kernel and user space.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#79B8FF\"> __kernel_size_t</span><span style=\"color:#79B8FF\"> mydevice_size_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * IOCTL command definitions.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Format: _IOR/_IOW/_IO(magic, number, datatype)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOCTL_GET_SIZE</span><span style=\"color:#B392F0\"> _IOR</span><span style=\"color:#E1E4E8\">(MYDEVICE_IOC_MAGIC, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">mydevice_size_t</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOCTL_GET_MAX_CAPACITY</span><span style=\"color:#B392F0\"> _IOR</span><span style=\"color:#E1E4E8\">(MYDEVICE_IOC_MAGIC, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">mydevice_size_t</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOCTL_CLEAR</span><span style=\"color:#B392F0\"> _IO</span><span style=\"color:#E1E4E8\">(MYDEVICE_IOC_MAGIC, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOCTL_RESIZE</span><span style=\"color:#B392F0\"> _IOW</span><span style=\"color:#E1E4E8\">(MYDEVICE_IOC_MAGIC, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">mydevice_size_t</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Ensure unique command numbers - add new ones sequentially */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOCTL_MAXNR</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#6A737D\">  /* Highest command number we use */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> /* MYCHARDEV_H */</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p><strong>In <code>mychardev.c</code>:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Main device state structure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * All device instance data is contained here.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydevice_data {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">buffer;</span><span style=\"color:#6A737D\">                   /* Kernel buffer for stored data */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span><span style=\"color:#6A737D\">                    /* Total capacity of buffer */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> data_len;</span><span style=\"color:#6A737D\">                /* Current data length in buffer */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> mutex mutex;</span><span style=\"color:#6A737D\">             /* Mutex for buffer protection */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    wait_queue_head_t</span><span style=\"color:#E1E4E8\"> read_wait;</span><span style=\"color:#6A737D\">    /* Wait queue for blocking reads */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> cdev cdev;</span><span style=\"color:#6A737D\">               /* Character device structure */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    dev_t</span><span style=\"color:#E1E4E8\"> dev_num;</span><span style=\"color:#6A737D\">                  /* Device number (major+minor) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> class </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">dev_class;</span><span style=\"color:#6A737D\">        /* Device class for sysfs */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> device </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">device;</span><span style=\"color:#6A737D\">          /* Device instance for /dev */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Global device instance (singleton) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> mydevice_data mydevice;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Initialize the device buffer.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Called during module initialization and buffer resize.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns 0 on success, negative error code on failure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> buffer_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">dev</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> initial_size</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 1: Check if initial_size is valid (non-zero, ≤ MAX_BUFFER_SIZE) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 2: Allocate memory with kmalloc using GFP_KERNEL flag */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 3: If allocation succeeds, update dev->buffer and dev->size */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 4: Initialize dev->data_len to 0 (empty buffer) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 5: Return 0 on success, -ENOMEM on allocation failure */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Clean up the device buffer.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Called during module cleanup and buffer resize (before reallocation).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> buffer_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">dev</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 1: Check if dev->buffer is not NULL */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 2: Free the buffer memory with kfree */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 3: Set dev->buffer to NULL and dev->size to 0 */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 4: Reset dev->data_len to 0 */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Resize the device buffer.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Called from ioctl handler with mutex already held.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns 0 on success, negative error code on failure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> buffer_resize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">dev</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> new_size</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 1: Validate new_size (must be ≤ MAX_BUFFER_SIZE, > 0) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 2: If new_size equals current dev->size, return 0 (no-op) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 3: Allocate new buffer with kmalloc */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 4: If allocation fails, return -ENOMEM */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 5: Copy existing data from old buffer to new buffer (up to min(dev->data_len, new_size)) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 6: Update dev->data_len to reflect copied amount (might be truncated if new_size smaller) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 7: Free old buffer with kfree */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 8: Update dev->buffer and dev->size */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 9: Return 0 on success */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints</strong></p>\n<ol>\n<li><strong>Kernel memory allocation</strong>: Always use <code>kmalloc</code> with <code>GFP_KERNEL</code> for buffers that may sleep (our case), or <code>GFP_ATOMIC</code> for interrupt context. Remember to check return value for NULL.</li>\n<li><strong>Size types</strong>: Use <code>size_t</code> for buffer sizes within the kernel module, but convert to/from <code>mydevice_size_t</code> (from shared header) when communicating with user space.</li>\n<li><strong>Structure initialization</strong>: For the global <code>mydevice</code> instance, use <code>= {0}</code> to ensure all pointers are NULL before initialization.</li>\n<li><strong>Error codes</strong>: Return negative <code>errno</code> values (e.g., <code>-ENOMEM</code>, <code>-EINVAL</code>) from functions that may fail.</li>\n</ol>\n<p><strong>F. Milestone Checkpoint</strong></p>\n<p>After implementing the data structures:</p>\n<ol>\n<li><strong>Compilation test</strong>: Run <code>make</code> to ensure the module compiles without errors. The shared header should compile in both kernel context (as part of the module) and user context (when included in test program).</li>\n<li><strong>Structure verification</strong>: Use <code>modinfo</code> to check module information, then load with <code>insmod</code>. Check <code>dmesg</code> for any initialization errors.</li>\n<li><strong>Ioctl header test</strong>: Create a simple user-space program that includes <code>mychardev.h</code> and prints the values of the ioctl constants. Compile with <code>gcc -o test_header test_header.c</code> to verify the header works in user space.</li>\n</ol>\n<p><strong>Expected behavior</strong>: Module loads without errors; header file compiles in both kernel and user space; ioctl command numbers are consistent.</p>\n<p><strong>Signs of trouble</strong>: </p>\n<ul>\n<li>Compilation errors about unknown types in <code>mychardev.h</code>: Likely missing proper kernel headers inclusion guard.</li>\n<li>Module fails to load with &quot;Invalid argument&quot;: Possible uninitialized mutex or wait queue causing panic during initialization.</li>\n</ul>\n<p><strong>G. Debugging Tips</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Kernel panic on first read/write</td>\n<td>Uninitialized mutex or wait queue</td>\n<td>Check <code>dmesg</code> for backtrace showing mutex/wait queue functions</td>\n<td>Call <code>mutex_init()</code> and <code>init_waitqueue_head()</code> in <code>mydevice_init()</code></td>\n</tr>\n<tr>\n<td>Buffer appears corrupted after resize</td>\n<td>Incorrect data copying during resize</td>\n<td>Add <code>printk</code> to show old/new sizes and data_len before/after copy</td>\n<td>Ensure you copy only <code>min(old_data_len, new_size)</code> bytes</td>\n</tr>\n<tr>\n<td>ioctl returns &quot;Invalid argument&quot; (<code>EINVAL</code>)</td>\n<td>Wrong command number or size</td>\n<td>Compare command number in user program with kernel definition using <code>printk</code></td>\n<td>Ensure shared header is identical in kernel and user builds</td>\n</tr>\n<tr>\n<td>Buffer size shows wrong value after resize</td>\n<td>Not updating dev-&gt;size field</td>\n<td>Add debug prints in resize function showing dev-&gt;size changes</td>\n<td>Update dev-&gt;size after successful reallocation</td>\n</tr>\n</tbody></table>\n<h2 id=\"component-module-lifecycle-manager\">Component: Module Lifecycle Manager</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1</p>\n</blockquote>\n<p>This component is the kernel module&#39;s entry and exit point. It manages the driver&#39;s birth and death within the running kernel, securing all necessary resources during initialization and releasing them during cleanup. Its design ensures the driver can be loaded and unloaded dynamically without affecting the stability of the operating system.</p>\n<h3 id=\"mental-model-the-driver39s-birth-and-death-certificate\">Mental Model: The Driver&#39;s Birth and Death Certificate</h3>\n<p>Imagine the Linux kernel as a highly secure, constantly running industrial facility. A <strong>kernel module</strong> is like a specialized piece of equipment (our driver) that you want to install into this facility to add new functionality. The <strong>Module Lifecycle Manager</strong> is the formal process for getting this equipment certified, connected to the facility&#39;s power and control systems, and later, for decommissioning it safely.</p>\n<ul>\n<li><p><strong>Loading (<code>insmod</code>)</strong>: This is the installation and certification process. You submit your equipment&#39;s blueprints (the compiled module) to the facility&#39;s management (the kernel). The <code>module_init</code> function is your equipment&#39;s startup routine, which must:</p>\n<ol>\n<li><strong>Request an official equipment ID</strong>: Ask the facility for a unique device number (<code>alloc_chrdev_region</code>) so your device can be identified in the <code>/dev</code> directory.</li>\n<li><strong>Connect to the control panel</strong>: Register your device&#39;s operational manual (<code>file_operations</code>) with the facility&#39;s Virtual File System (VFS), so user programs know how to interact with it.</li>\n<li><strong>Install the user-facing interface</strong>: Create an accessible control panel (the <code>/dev/mychardev</code> node) using <code>device_create</code>, so users can issue commands.</li>\n<li><strong>Allocate private workspace</strong>: Secure a private memory area (<code>kmalloc</code>) for the driver&#39;s internal data buffer.</li>\n<li><strong>Announce successful installation</strong>: Log a message (<code>printk</code>) to the facility&#39;s central log (<code>dmesg</code>) confirming the driver is operational.</li>\n</ol>\n</li>\n<li><p><strong>Unloading (<code>rmmod</code>)</strong>: This is the decommissioning process. The <code>module_exit</code> function is the meticulous shutdown checklist, which must <strong>reverse every single action</strong> performed during initialization in the exact opposite order:</p>\n<ol>\n<li><strong>Remove the user-facing interface</strong>: Dismantle the control panel (<code>device_destroy</code> and <code>class_destroy</code>).</li>\n<li><strong>Disconnect from the control panel</strong>: Unregister the operational manual (<code>cdev_del</code>).</li>\n<li><strong>Return the equipment ID</strong>: Release the unique device number (<code>unregister_chrdev_region</code>).</li>\n<li><strong>Clean up the private workspace</strong>: Free the allocated memory (<code>kfree</code>).</li>\n<li><strong>Announce decommissioning</strong>: Log a final message confirming the driver has been cleanly removed.</li>\n</ol>\n</li>\n</ul>\n<p>Forgetting any step in the cleanup process is like leaving your equipment plugged in and taking up space after your contract ends—it leads to resource leaks and can destabilize the entire facility (kernel). The golden rule is: <strong>for every <code>alloc</code>, <code>create</code>, or <code>register</code> in <code>init</code>, there must be a corresponding <code>free</code>, <code>destroy</code>, or <code>unregister</code> in <code>exit</code></strong>.</p>\n<h3 id=\"adr-dynamic-vs-static-device-number-allocation\">ADR: Dynamic vs. Static Device Number Allocation</h3>\n<blockquote>\n<p><strong>Decision: Use <code>alloc_chrdev_region</code> for Dynamic Major Number Allocation</strong></p>\n</blockquote>\n<ul>\n<li><strong>Context</strong>: Character devices in Linux are identified by a major number (device type) and minor number (device instance). The driver must obtain a unique major number to create its <code>/dev</code> node. The kernel provides two primary methods: requesting a specific, static number or asking the kernel to assign one dynamically.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Static allocation with <code>register_chrdev</code></strong>: The driver requests a specific, well-known major number (e.g., 240). This is simple but prone to conflicts if another driver or module is already using that number.</li>\n<li><strong>Dynamic allocation with <code>alloc_chrdev_region</code></strong>: The driver asks the kernel to assign an available major number from a pool. The driver then uses this assigned number.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: We will use dynamic allocation via <code>alloc_chrdev_region</code>.</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Conflict Avoidance</strong>: This is the primary reason for an educational, out-of-tree module. Learners may run the module on various systems where static numbers could be occupied. Dynamic allocation guarantees a free number, preventing load failures.</li>\n<li><strong>Modern Practice</strong>: The older <code>register_chrdev</code> function registers a single major number for all 256 minor numbers and uses a global <code>file_operations</code> structure. The newer <code>alloc_chrdev_region</code> and <code>cdev_init</code> API is more flexible and is the recommended approach for new drivers, allowing for better structure encapsulation.</li>\n<li><strong>Scalability</strong>: It naturally supports the potential future extension of creating multiple device instances (multiple minor numbers) under the same dynamically allocated major number.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li>The <code>/dev</code> node&#39;s name will be tied to a major number that changes each time the module is loaded (unless manually specified via module parameters, which is out of scope). This requires using <code>class_create</code> and <code>device_create</code> to automatically create the node with the correct, dynamically assigned number.</li>\n<li>The assigned major number must be communicated to userspace (via <code>printk</code> or <code>/proc/devices</code>) so the user knows which <code>/dev</code> node was created.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Comparison of Allocation Methods</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Option</th>\n<th align=\"left\">Pros</th>\n<th align=\"left\">Cons</th>\n<th align=\"left\">Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Static (<code>register_chrdev</code>)</strong></td>\n<td align=\"left\">Simple API, predictable major number.</td>\n<td align=\"left\">High risk of conflict with other drivers, less flexible, older API.</td>\n<td align=\"left\">❌</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Dynamic (<code>alloc_chrdev_region</code>)</strong></td>\n<td align=\"left\">Guarantees a free major number, avoids conflicts, modern and flexible API.</td>\n<td align=\"left\">Major number changes per load, requires sysfs (<code>class_create</code>) for automatic <code>/dev</code> node creation.</td>\n<td align=\"left\">✅</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-module-lifecycle\">Common Pitfalls: Module Lifecycle</h3>\n<ol>\n<li><p>⚠️ <strong>Pitfall: Forgetting <code>MODULE_LICENSE(&quot;GPL&quot;)</code></strong></p>\n<ul>\n<li><strong>Description</strong>: Omitting or incorrectly specifying the module license macro.</li>\n<li><strong>Why it&#39;s wrong</strong>: The kernel will be marked as &quot;tainted,&quot; which restricts the module&#39;s access to certain kernel symbols and may trigger warnings in the logs. Support from the kernel community may also be withheld for tainted kernels. For our learning module, using <code>&quot;GPL&quot;</code> is standard and expected.</li>\n<li><strong>How to fix</strong>: Always include <code>MODULE_LICENSE(&quot;GPL&quot;);</code> near the top of your <code>.c</code> file, alongside <code>MODULE_AUTHOR</code> and <code>MODULE_DESCRIPTION</code>.</li>\n</ul>\n</li>\n<li><p>⚠️ <strong>Pitfall: Resource Leak on Initialization Failure</strong></p>\n<ul>\n<li><strong>Description</strong>: The <code>mydevice_init</code> function fails partway through (e.g., <code>kmalloc</code> returns <code>NULL</code>) but does not properly roll back resources already allocated (e.g., a successfully allocated device number).</li>\n<li><strong>Why it&#39;s wrong</strong>: This leaves kernel resources permanently allocated until the system reboots. Repeated failed loads will exhaust these resources.</li>\n<li><strong>How to fix</strong>: Implement a <strong>stepwise cleanup</strong> on any error path. Use <code>goto</code> statements to a common error handling label that performs cleanup in reverse order of acquisition. This pattern is standard and idiomatic in kernel code.</li>\n</ul>\n</li>\n<li><p>⚠️ <strong>Pritfall: Kernel Version Mismatch</strong></p>\n<ul>\n<li><strong>Description</strong>: Compiling the module against kernel headers that do not match the version of the currently running kernel.</li>\n<li><strong>Why it&#39;s wrong</strong>: Kernel APIs change between versions. A module compiled for one version may use functions or data structures that don&#39;t exist or behave differently in another, leading to immediate crashes or subtle bugs.</li>\n<li><strong>How to fix</strong>: Always build your module on the same system where it will run. The <code>Makefile</code> should use <code>$(shell uname -r)</code> to automatically target the running kernel&#39;s headers (typically in <code>/lib/modules/$(shell uname -r)/build</code>).</li>\n</ul>\n</li>\n<li><p>⚠️ <strong>Pitfall: Incorrect <code>printk</code> Usage</strong></p>\n<ul>\n<li><strong>Description</strong>: Using <code>printk</code> like <code>printf</code>, forgetting the log level macro (e.g., <code>KERN_INFO</code>), or expecting automatic newlines.</li>\n<li><strong>Why it&#39;s wrong</strong>: Messages without a log level default to <code>KERN_DEFAULT</code>, which might not appear in <code>dmesg</code> depending on the console log level. Also, <code>printk</code> does not automatically append a newline; you must include <code>\\n</code> in the format string.</li>\n<li><strong>How to fix</strong>: Always prefix your format string with a log level macro, and end with <code>\\n</code>. For example: <code>printk(KERN_INFO &quot;mymodule: Initialized successfully.\\n&quot;);</code>.</li>\n</ul>\n</li>\n<li><p>⚠️ <strong>Pitfall: Ignoring Return Values of Initialization Functions</strong></p>\n<ul>\n<li><strong>Description</strong>: Not checking the return value of functions like <code>alloc_chrdev_region</code>, <code>cdev_add</code>, or <code>device_create</code>.</li>\n<li><strong>Why it&#39;s wrong</strong>: These functions can fail (e.g., out of memory, device number exhaustion). Ignoring the error leaves the module in an inconsistent state, often leading to a crash later.</li>\n<li><strong>How to fix</strong>: Check every return value that indicates an error (typically a negative integer or a <code>NULL</code> pointer). Propagate the error back to the caller of <code>module_init</code> (by returning the error code) to cause module loading to fail cleanly.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides the foundational code and structure to achieve Milestone 1: a loadable &quot;Hello World&quot; module that sets up the skeleton for the character device driver.</p>\n<p><strong>A. Technology Recommendations Table</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Simple Option (Recommended for Learning)</th>\n<th align=\"left\">Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Build System</strong></td>\n<td align=\"left\">Standard <code>Kbuild</code> <code>Makefile</code></td>\n<td align=\"left\">Out-of-tree kernel module build system (kbuild) with <code>dkms</code> for distribution</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Kernel APIs</strong></td>\n<td align=\"left\">Classic <code>file_operations</code>, <code>proc_ops</code></td>\n<td align=\"left\">Newer <code>file_operations</code> without <code>.owner</code>, <code>seq_file</code> for <code>/proc</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Memory Allocation</strong></td>\n<td align=\"left\"><code>kmalloc</code>/<code>kfree</code> with <code>GFP_KERNEL</code></td>\n<td align=\"left\"><code>devm_kmalloc</code> for managed resources (more complex setup)</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure</strong></p>\n<p>Create the following directory and file structure. This keeps the project organized from the start.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>mydevice_driver/\n├── Makefile                    # Kbuild Makefile to compile the module\n├── mydevice.c                  # Main driver source file (all components start here)\n└── README.md                   # Project notes (optional)</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p>The following is a complete, compilable kernel module for Milestone 1. It includes the core lifecycle functions, error handling, and logging. Copy this into <code>mydevice.c</code>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// SPDX-License-Identifier: GPL-2.0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * mydevice.c - A simple loadable kernel module (LKM) skeleton for a character device.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This module demonstrates the basic lifecycle: init and exit.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * It will be extended in later milestones to implement a full character device.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/init.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/module.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/kernel.h></span><span style=\"color:#6A737D\">       // For printk, KERN_INFO</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/fs.h></span><span style=\"color:#6A737D\">           // For alloc_chrdev_region, register_chrdev</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/slab.h></span><span style=\"color:#6A737D\">         // For kmalloc, kfree</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/device.h></span><span style=\"color:#6A737D\">       // For class_create, device_create</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/cdev.h></span><span style=\"color:#6A737D\">         // For cdev_init, cdev_add</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Define our internal device data structure (simplified for Milestone 1) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydevice_data {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // These fields will be used in later milestones</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // void *buffer;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // size_t size;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // struct mutex mutex;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // wait_queue_head_t read_wait;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Device identification and kernel structures (introduced now)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    dev_t</span><span style=\"color:#E1E4E8\"> dev_num;</span><span style=\"color:#6A737D\">              // Major and minor device number</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> cdev cdev;</span><span style=\"color:#6A737D\">           // The kernel's character device structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> class </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">dev_class;</span><span style=\"color:#6A737D\">    // Sysfs class for udev/auto device node creation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> device </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">device;</span><span style=\"color:#6A737D\">      // The actual device instance in sysfs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">mydevice_dev;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Module metadata */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_LICENSE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"GPL\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_AUTHOR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Your Name Here\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_DESCRIPTION</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"A simple character device driver for learning\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">MODULE_VERSION</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"0.1\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Forward declarations for file operations (to be implemented in Milestone 2) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">static int mydevice_open(struct inode *inode, struct file *filp);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">static int mydevice_release(struct inode *inode, struct file *filp);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">static ssize_t mydevice_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">static ssize_t mydevice_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">*/</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* The file_operations structure will be populated in Milestone 2 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> file_operations mydevice_fops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .owner </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> THIS_MODULE,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // .open = mydevice_open,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // .release = mydevice_release,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // .read = mydevice_read,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // .write = mydevice_write,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * mydevice_init - Module initialization function.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Called when the module is loaded with 'insmod'.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns 0 on success, a negative error code on failure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> __init </span><span style=\"color:#B392F0\">mydevice_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydevice: Initialization started.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* 1. Allocate memory for our device instance data */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mydevice_dev </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydevice_data), GFP_KERNEL);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">mydevice_dev) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydevice: Failed to allocate device data.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOMEM;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> err_no_mem;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(mydevice_dev, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydevice_data));</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* 2. Dynamically allocate a major device number and a range of minors */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_chrdev_region</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">mydevice_dev->dev_num, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, DEVICE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (retval </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydevice: Failed to allocate device number. Error </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, retval);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> err_alloc_region;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydevice: Allocated device major </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, minor </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">           MAJOR</span><span style=\"color:#E1E4E8\">(mydevice_dev->dev_num), </span><span style=\"color:#B392F0\">MINOR</span><span style=\"color:#E1E4E8\">(mydevice_dev->dev_num));</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* 3. Create a device class in sysfs. This allows udev to create /dev node automatically. */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mydevice_dev->dev_class </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> class_create</span><span style=\"color:#E1E4E8\">(THIS_MODULE, DEVICE_NAME </span><span style=\"color:#9ECBFF\">\"_class\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">IS_ERR</span><span style=\"color:#E1E4E8\">(mydevice_dev->dev_class)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> PTR_ERR</span><span style=\"color:#E1E4E8\">(mydevice_dev->dev_class);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydevice: Failed to create device class. Error </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, retval);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> err_class_create;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* 4. Initialize the cdev structure and link it to our file_operations. */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cdev_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">mydevice_dev->cdev, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">mydevice_fops);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mydevice_dev->cdev.owner </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> THIS_MODULE;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* 5. Add the character device to the kernel, making it live. */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> cdev_add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">mydevice_dev->cdev, mydevice_dev->dev_num, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (retval </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydevice: Failed to add cdev to the system. Error </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, retval);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> err_cdev_add;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* 6. Create the device node in /dev automatically.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *    The node will appear as /dev/mychardev.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mydevice_dev->device </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> device_create</span><span style=\"color:#E1E4E8\">(mydevice_dev->dev_class, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, mydevice_dev->dev_num, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, DEVICE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">IS_ERR</span><span style=\"color:#E1E4E8\">(mydevice_dev->device)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> PTR_ERR</span><span style=\"color:#E1E4E8\">(mydevice_dev->device);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydevice: Failed to create the device node. Error </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, retval);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> err_device_create;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydevice: Module loaded successfully. Device node is /dev/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, DEVICE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Success</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Error handling: Clean up in reverse order of allocation */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">err_device_create:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cdev_del</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">mydevice_dev->cdev);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">err_cdev_add:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    class_destroy</span><span style=\"color:#E1E4E8\">(mydevice_dev->dev_class);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">err_class_create:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    unregister_chrdev_region</span><span style=\"color:#E1E4E8\">(mydevice_dev->dev_num, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">err_alloc_region:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kfree</span><span style=\"color:#E1E4E8\">(mydevice_dev);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mydevice_dev </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">err_no_mem:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"mydevice: Module initialization failed.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> retval;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * mydevice_exit - Module cleanup function.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Called when the module is unloaded with 'rmmod'.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#E1E4E8\"> __exit </span><span style=\"color:#B392F0\">mydevice_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydevice: Starting cleanup.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* 1. Destroy the device node (removes /dev/mychardev) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (mydevice_dev </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> mydevice_dev->device) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        device_destroy</span><span style=\"color:#E1E4E8\">(mydevice_dev->dev_class, mydevice_dev->dev_num);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* 2. Remove the cdev from the system */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (mydevice_dev) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        cdev_del</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">mydevice_dev->cdev);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* 3. Destroy the device class */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (mydevice_dev </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> mydevice_dev->dev_class) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        class_destroy</span><span style=\"color:#E1E4E8\">(mydevice_dev->dev_class);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* 4. Release the device number region */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (mydevice_dev) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        unregister_chrdev_region</span><span style=\"color:#E1E4E8\">(mydevice_dev->dev_num, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* 5. Free the device instance memory */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kfree</span><span style=\"color:#E1E4E8\">(mydevice_dev);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mydevice_dev </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO </span><span style=\"color:#9ECBFF\">\"mydevice: Module unloaded successfully.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Register the init and exit functions with the kernel */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">module_init</span><span style=\"color:#E1E4E8\">(mydevice_init);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">module_exit</span><span style=\"color:#E1E4E8\">(mydevice_exit);</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p>The main logic for Milestone 1 is fully provided above. The following <code>Makefile</code> is required to build the module. Place it in the same directory as <code>mydevice.c</code>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">makefile</span><pre class=\"arch-pre shiki-highlighted\"><code># Kbuild Makefile for the mydevice kernel module\nobj-m += mydevice.o\n\n# Define the device name (used in the C code)\nEXTRA_CFLAGS += -DDEVICE_NAME=\\&quot;mychardev\\&quot;\n\n# Path to the kernel build directory (adjust if needed)\nKDIR ?= /lib/modules/$(shell uname -r)/build\n\n# Default target: build the module\nall:\n\t$(MAKE) -C $(KDIR) M=$(PWD) modules\n\n# Clean target: remove generated files\nclean:\n\t$(MAKE) -C $(KDIR) M=$(PWD) clean\n\n# Installation target (optional, for later use)\ninstall:\n\tsudo insmod mydevice.ko\n\n# Removal target (optional, for later use)\nuninstall:\n\tsudo rmmod mydevice</code></pre></div>\n\n<p><strong>E. Language-Specific Hints (C / Kernel)</strong></p>\n<ul>\n<li><strong>Kernel Logging</strong>: Always use <code>printk</code> for logging inside the kernel. Remember the log level macros (<code>KERN_INFO</code>, <code>KERN_ERR</code>). You can view the output with <code>sudo dmesg</code> or <code>journalctl -k</code>.</li>\n<li><strong>Error Codes</strong>: Kernel functions return negative error codes (e.g., <code>-ENOMEM</code> for out of memory). Your functions should do the same. <code>0</code> typically indicates success.</li>\n<li><strong>Memory Allocation</strong>: Use <code>kmalloc(size, GFP_KERNEL)</code> for normal, sleepable allocations. Always check for <code>NULL</code> return. Use <code>kfree()</code> to free.</li>\n<li><strong>Goto for Error Handling</strong>: The <code>goto</code> statement is standard and preferred for centralized error cleanup in the kernel. It leads to cleaner code than nested <code>if</code> statements.</li>\n</ul>\n<p><strong>F. Milestone Checkpoint: Verification Steps for Milestone 1</strong></p>\n<p>After writing the code above and saving it as <code>mydevice.c</code> with the accompanying <code>Makefile</code>, follow these steps to verify correct implementation:</p>\n<ol>\n<li><strong>Compile the module</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">    make</span></span></code></pre></div>\n<pre><code>Expected: The build should complete without errors, producing a `mydevice.ko` file.\n</code></pre>\n<ol start=\"2\">\n<li><strong>Check module information</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">    modinfo</span><span style=\"color:#9ECBFF\"> mydevice.ko</span></span></code></pre></div>\n<pre><code>Expected: Output should show the license (&quot;GPL&quot;), author, description, and version you set with the `MODULE_*` macros.\n</code></pre>\n<ol start=\"3\">\n<li><strong>Load the module</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">    sudo</span><span style=\"color:#9ECBFF\"> insmod</span><span style=\"color:#9ECBFF\"> mydevice.ko</span></span></code></pre></div>\n<pre><code>Expected: The command should return silently (no error). If there is an error (e.g., &quot;insmod: ERROR: could not insert module&quot;), check the next step.\n</code></pre>\n<ol start=\"4\">\n<li><strong>Verify loading in kernel log</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">    sudo</span><span style=\"color:#9ECBFF\"> dmesg</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tail</span><span style=\"color:#79B8FF\"> -10</span></span></code></pre></div>\n<pre><code>Expected: You should see messages similar to:\n</code></pre>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>    [ 1234.567890] mydevice: Initialization started.\n    [ 1234.567891] mydevice: Allocated device major 246, minor 0.\n    [ 1234.567892] mydevice: Module loaded successfully. Device node is /dev/mychardev.</code></pre></div>\n<pre><code>Note the allocated major number (e.g., 246).\n</code></pre>\n<ol start=\"5\">\n<li><strong>Check if device node was created</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">    ls</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#9ECBFF\"> /dev/mychardev</span></span></code></pre></div>\n<pre><code>Expected: The file `/dev/mychardev` should exist. Its permissions might be `crw-------` and the major number should match the one printed in `dmesg`.\n</code></pre>\n<ol start=\"6\">\n<li><strong>Check kernel modules list</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">    lsmod</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> mydevice</span></span></code></pre></div>\n<pre><code>Expected: The `mydevice` module should be listed.\n</code></pre>\n<ol start=\"7\">\n<li><strong>Unload the module</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">    sudo</span><span style=\"color:#9ECBFF\"> rmmod</span><span style=\"color:#9ECBFF\"> mydevice</span></span></code></pre></div>\n<pre><code>Expected: The command should return silently.\n</code></pre>\n<ol start=\"8\">\n<li><strong>Verify cleanup in kernel log</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">    sudo</span><span style=\"color:#9ECBFF\"> dmesg</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tail</span><span style=\"color:#79B8FF\"> -5</span></span></code></pre></div>\n<pre><code>Expected: You should see:\n</code></pre>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>    [ 1234.678901] mydevice: Starting cleanup.\n    [ 1234.678902] mydevice: Module unloaded successfully.</code></pre></div>\n\n<ol start=\"9\">\n<li><strong>Confirm device node is removed</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">    ls</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#9ECBFF\"> /dev/mychardev</span><span style=\"color:#F97583\"> 2>&#x26;1</span></span></code></pre></div>\n<pre><code>Expected: The command should report &quot;No such file or directory&quot;.\n</code></pre>\n<p>If all steps pass, you have successfully completed Milestone 1. The driver skeleton is ready to have its character device operations implemented in the next milestone.</p>\n<hr>\n<h2 id=\"component-character-device-core\">Component: Character Device Core</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2</p>\n</blockquote>\n<p>This component implements the core functionality that transforms our kernel module into an accessible device. It handles the direct interaction between user-space applications and the kernel module through the <code>/dev</code> interface, enabling programs to read from and write to our device as if it were a file.</p>\n<h3 id=\"mental-model-the-device-as-a-shared-notebook\">Mental Model: The Device as a Shared Notebook</h3>\n<p>Imagine a public library with a single, large notebook at the reference desk. This notebook represents our device&#39;s buffer. Library patrons (user-space processes) can approach the desk to perform two main actions:</p>\n<ol>\n<li><strong>Write a message:</strong> A patron can write text into the notebook. The librarian (the kernel) ensures they write neatly within the notebook&#39;s boundaries and don&#39;t overwrite other messages without permission. They hand their written note to the librarian, who carefully copies it into the next available space in the notebook.</li>\n<li><strong>Read a message:</strong> A patron can ask to read what&#39;s in the notebook. If the notebook is empty, the librarian asks the patron to wait in a designated waiting area (a wait queue) until another patron writes something. Once data is available, the librarian copies text from the notebook and hands the copy to the reading patron.</li>\n</ol>\n<p>The librarian enforces strict rules:</p>\n<ul>\n<li><strong>Only one patron at the desk:</strong> The librarian uses a &quot;Now Serving&quot; ticket (a mutex) to ensure only one patron is interacting with the notebook at any time, preventing jumbled or corrupted messages.</li>\n<li><strong>No original notes leave the library:</strong> Patrons never handle the original notebook. The librarian only works with copies (<code>copy_from_user</code>, <code>copy_to_user</code>). This protects the kernel&#39;s internal data.</li>\n<li><strong>The notebook has finite pages:</strong> The notebook has a maximum capacity. If it&#39;s full, writing patrons must wait until space is freed by reading patrons.</li>\n</ul>\n<p>This mental model captures the essence of a character device: a shared, sequential data store with controlled access, managed by the kernel acting as a gatekeeper between untrusted user-space and protected kernel-space.</p>\n<h3 id=\"adr-simple-linear-buffer-vs-circular-buffer\">ADR: Simple Linear Buffer vs. Circular Buffer</h3>\n<blockquote>\n<p><strong>Decision: Use a Simple Linear Buffer for Initial Implementation</strong></p>\n<ul>\n<li><strong>Context</strong>: We need a storage mechanism within the kernel to hold data written from user-space and serve it back to readers. The buffer must support sequential access, concurrent modification, and have clear full/empty states.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Simple linear buffer</strong>: A contiguous block of kernel memory (<code>kmalloc</code>) with a fixed capacity. Data is written starting at offset 0 and read from offset 0. Once data is read, the buffer is effectively &quot;consumed&quot; and must be cleared or overwritten from the beginning.</li>\n<li><strong>Circular buffer (ring buffer)</strong>: A fixed-size buffer where the read and write pointers wrap around. This allows continuous reading and writing without needing to clear the buffer, providing better throughput for sustained data flow.</li>\n<li><strong>Linked list of pages</strong>: A dynamically sized buffer composed of linked kernel pages, allowing growth without contiguous memory constraints but with increased complexity.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: We will implement a simple linear buffer for Milestone 2.</li>\n<li><strong>Rationale</strong>: The primary goal is educational clarity, not maximum performance. A linear buffer has simpler state management (just <code>data_start</code>, <code>data_end</code> or <code>data_size</code>), making it easier to reason about concurrency, blocking conditions, and buffer state transitions. It directly maps to the &quot;shared notebook&quot; mental model where data is written and then consumed. Implementing a circular buffer adds complexity with wrap-around logic, modulo arithmetic, and handling the case where a read or write operation spans the buffer boundary, which can obscure the core concepts of kernel/user data transfer and synchronization.</li>\n<li><strong>Consequences</strong>: <ul>\n<li><strong>Positive</strong>: Simplified implementation and debugging; clear full/empty states; straightforward <code>read</code>/<code>write</code> semantics.</li>\n<li><strong>Negative</strong>: Lower throughput for continuous data streams; after a read, the buffer becomes empty and cannot hold historical data; requires explicit clearing or management of buffer position.</li>\n<li><strong>Mitigation</strong>: This decision is scoped to Milestone 2. In Milestone 3, we will add an <code>ioctl</code> command to clear the buffer, and in future extensions, the buffer strategy could be upgraded to circular.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Simple Linear Buffer</strong></td>\n<td>Simple state logic, easy to debug, clear full/empty semantics, maps directly to learning objectives</td>\n<td>Inefficient for continuous data, requires manual clearing, data is consumed on read</td>\n<td><strong>Yes</strong> (for Milestone 2)</td>\n</tr>\n<tr>\n<td><strong>Circular Buffer</strong></td>\n<td>Efficient for continuous read/write, no need to clear buffer automatically, common in production drivers</td>\n<td>More complex implementation, wrap-around logic, harder to debug for learners</td>\n<td>No</td>\n</tr>\n<tr>\n<td><strong>Linked List of Pages</strong></td>\n<td>Dynamic size, no contiguous memory requirement, scales well</td>\n<td>High complexity, memory fragmentation, overhead of page management</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-userkernel-boundary\">Common Pitfalls: User/Kernel Boundary</h3>\n<p>Crossing the boundary between user-space and kernel-space is fraught with subtle dangers. The kernel must never blindly trust pointers or data from user-space, as they could be malicious, invalid, or point to unmapped memory. Here are the critical pitfalls to avoid:</p>\n<p>⚠️ <strong>Pitfall: Directly Dereferencing User-Space Pointers</strong></p>\n<ul>\n<li><strong>What happens</strong>: Using <code>*</code> operator or array indexing on a pointer passed from user-space (e.g., the <code>buf</code> argument in <code>mydevice_write</code>).</li>\n<li><strong>Why it&#39;s wrong</strong>: User-space pointers are virtual addresses in the user process&#39;s address space. They are meaningless in the kernel&#39;s address context. Dereferencing them will cause a page fault, crashing the kernel (a &quot;oops&quot; or kernel panic).</li>\n<li><strong>How to fix</strong>: Always use the dedicated kernel functions <code>copy_from_user</code> (to copy data <em>from</em> user-space <em>into</em> kernel memory) and <code>copy_to_user</code> (to copy data <em>from</em> kernel memory <em>to</em> user-space). These functions perform safe translation and handle invalid pointers gracefully by returning a non-zero error code.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Not Checking Return Values of copy_to/from_user</strong></p>\n<ul>\n<li><strong>What happens</strong>: Calling <code>copy_from_user(kernel_buf, user_buf, count)</code> but ignoring its return value.</li>\n<li><strong>Why it&#39;s wrong</strong>: These functions can fail if the user pointer is invalid, points to unmapped memory, or if only part of the requested range is accessible. A failure means the copy was incomplete. Ignoring this leads to using uninitialized kernel buffer data or returning incorrect data to user-space.</li>\n<li><strong>How to fix</strong>: Always check if the return value is 0 (success). If not, return <code>-EFAULT</code> to user-space to indicate a bad address. For example: <code>if (copy_from_user(...)) { return -EFAULT; }</code></li>\n</ul>\n<p>⚠️ <strong>Pitfall: Incorrect Return Values from read/write Handlers</strong></p>\n<ul>\n<li><strong>What happens</strong>: The <code>mydevice_read</code> function returns the number of bytes the user requested (<code>count</code>) regardless of how much data is actually available.</li>\n<li><strong>Why it&#39;s wrong</strong>: The <code>read</code> system call contract expects the return value to be the number of bytes <em>actually transferred</em> to user-space. Returning a larger value tells the user program it received data it didn&#39;t, causing buffer overruns or reading garbage. Conversely, returning 0 indicates EOF (end-of-file), which for a character device typically means no data is available <em>at this moment</em>.</li>\n<li><strong>How to fix</strong>: Return the actual number of bytes copied via <code>copy_to_user</code>. If no data is available and it&#39;s a non-blocking read, return <code>-EAGAIN</code>. If it&#39;s a blocking read, put the process to sleep (see Milestone 4). Return 0 only when at the true end of the data stream (which for our simple device might only happen after a buffer clear).</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Forgetting to Update the File Position</strong></p>\n<ul>\n<li><strong>What happens</strong>: The <code>read</code>/<code>write</code> handlers ignore the <code>loff_t *f_pos</code> parameter.</li>\n<li><strong>Why it&#39;s wrong</strong>: The <code>f_pos</code> tracks the current position in the &quot;file&quot; for sequential access. For our simple sequential device, a <code>read</code> should consume data starting at the current position. If we don&#39;t update <code>*f_pos</code>, subsequent reads will return the same data repeatedly.</li>\n<li><strong>How to fix</strong>: After successfully transferring <code>n</code> bytes, increment <code>*f_pos += n</code>. For our linear buffer model, we typically read from the beginning and reset the buffer (or position) after a complete read. The exact semantics depend on your design; you might choose to treat each <code>read</code> as consuming all available data and resetting the buffer to empty, in which case <code>f_pos</code> might not be used meaningfully.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Not Handling Partial Reads/Writes Due to Buffer Limits</strong></p>\n<ul>\n<li><strong>What happens</strong>: A user requests to write 4096 bytes, but our kernel buffer has only 1024 bytes free.</li>\n<li><strong>Why it&#39;s wrong</strong>: The driver should not silently truncate the data. The <code>write</code> system call expects either to transfer all requested bytes or return an error. If we only copy 1024 bytes and return 1024, the user program might think the entire write succeeded when it didn&#39;t.</li>\n<li><strong>How to fix</strong>: Check if the operation can be completed in full given the buffer&#39;s current state (e.g., free space for write, available data for read). If not, you have two options: 1) Return <code>-ENOSPC</code> (no space) or <code>-EAGAIN</code> for a non-blocking operation, or 2) Transfer as much as possible (partial I/O) and return that count. The Linux convention for character devices often allows partial transfers; document your driver&#39;s behavior clearly. For simplicity in Milestone 2, we can implement partial transfers: write up to the free space, read up to the available data.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Milestone 2)</th>\n<th>Advanced Option (Future)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Buffer Storage</strong></td>\n<td>Linear <code>kmalloc</code> buffer with fixed capacity</td>\n<td>Circular buffer or <code>vmalloc</code> for large sizes</td>\n</tr>\n<tr>\n<td><strong>Device Number</strong></td>\n<td>Dynamic allocation with <code>alloc_chrdev_region</code></td>\n<td>Static major number (requires coordination)</td>\n</tr>\n<tr>\n<td><strong>/dev Node Creation</strong></td>\n<td>Automatic via <code>class_create</code>/<code>device_create</code></td>\n<td>Manual <code>mknod</code> or udev rules</td>\n</tr>\n<tr>\n<td><strong>Concurrency (Milestone 4)</strong></td>\n<td>Single mutex for all operations</td>\n<td>Fine-grained locking (read/write locks)</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<p>After implementing this component, your project directory should look like:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>mydevice-driver/\n├── Makefile                      # Kbuild Makefile\n├── mydevice.c                    # Main driver source (Module Lifecycle + Char Device Core)\n├── mydevice.h                    # Shared header (for ioctl, coming in Milestone 3)\n└── test_user.c                   # Userspace test program (to be written)</code></pre></div>\n<p>For now, <code>mydevice.c</code> will contain both the module lifecycle functions (from previous section) and the character device core implementation.</p>\n<h4 id=\"c-infrastructure-starter-code-the-device-instance-structure\">C. Infrastructure Starter Code: The Device Instance Structure</h4>\n<p>We need a central structure to hold all state for our device. This is a singleton (one instance) for our driver. Add this to <code>mydevice.c</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/fs.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/cdev.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/device.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/slab.h></span><span style=\"color:#6A737D\">           // For kmalloc/kfree</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/uaccess.h></span><span style=\"color:#6A737D\">        // For copy_to/from_user</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEVICE_NAME</span><span style=\"color:#9ECBFF\"> \"mychardev\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BUFFER_SIZE</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#6A737D\">          // Initial buffer size</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Per-device instance data structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydevice_data {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    dev_t</span><span style=\"color:#E1E4E8\"> dev_num;</span><span style=\"color:#6A737D\">                // Major &#x26; minor number</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> cdev cdev;</span><span style=\"color:#6A737D\">             // Character device structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> class </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">dev_class;</span><span style=\"color:#6A737D\">      // Device class for sysfs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> device </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">device;</span><span style=\"color:#6A737D\">        // Device node</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Buffer management (Milestone 2)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">buffer;</span><span style=\"color:#6A737D\">                 // Linear data buffer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> buffer_size;</span><span style=\"color:#6A737D\">           // Total capacity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> data_size;</span><span style=\"color:#6A737D\">             // Current amount of data stored</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Note: We'll add mutex and wait_queue in Milestone 4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">mydevice_dev;</span><span style=\"color:#6A737D\"> // Global device instance</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>1. File Operations Structure</strong>\nDefine the <code>file_operations</code> structure that maps system calls to our handler functions. Place this after the structure definition:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> file_operations mydevice_fops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .owner </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> THIS_MODULE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .open </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_open,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .release </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_release,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .read </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_read,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .write </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_write,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // .unlocked_ioctl will be added in Milestone 3</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // .poll will be added in Milestone 4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>2. Open and Release Handlers</strong>\nImplement the simple open and release methods. The <code>open</code> handler is called when a user-space process opens <code>/dev/mychardev</code>. The <code>release</code> handler is called when the last reference to the file is closed.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydevice_open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> inode </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get pointer to our device data from inode->i_cdev</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use container_of(inode->i_cdev, struct mydevice_data, cdev)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Store the device data pointer in filp->private_data for access in other handlers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Optional: Increment module usage count with try_module_get(THIS_MODULE)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO DEVICE_NAME </span><span style=\"color:#9ECBFF\">\": Device opened</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Success</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydevice_release</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> inode </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Optional: Decrement module usage count with module_put(THIS_MODULE)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO DEVICE_NAME </span><span style=\"color:#9ECBFF\">\": Device closed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>3. Write Handler</strong>\nImplement the write handler to copy data from user-space into our kernel buffer.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydevice_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                              size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">loff_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">f_pos</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">dev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> filp->private_data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> free_space;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Calculate free space in buffer: free_space = dev->buffer_size - dev->data_size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Determine how many bytes we can copy: to_copy = min(count, free_space)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use min_t(size_t, count, free_space) for type-safe min</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If to_copy is 0, return -ENOSPC (No space left) or 0 (partial write convention)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Copy data from user-space to end of our buffer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // copy_from_user(dev->buffer + dev->data_size, buf, to_copy)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check copy_from_user return value. If non-zero, return -EFAULT</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update dev->data_size to reflect new data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Update *f_pos (optional, depending on your semantics)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Return number of bytes actually written (to_copy)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO DEVICE_NAME </span><span style=\"color:#9ECBFF\">\": Wrote </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, to_copy);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>4. Read Handler</strong>\nImplement the read handler to copy data from our kernel buffer to user-space.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydevice_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                             size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">loff_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">f_pos</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">dev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> filp->private_data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> available;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Calculate available data: available = dev->data_size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Determine how many bytes we can copy: to_copy = min(count, available)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If to_copy is 0, return 0 (EOF/no data) - we'll make this blocking in Milestone 4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Copy data from beginning of buffer to user-space</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // copy_to_user(buf, dev->buffer, to_copy)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check copy_to_user return value. If non-zero, return -EFAULT</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Remove copied data from buffer by shifting remaining data forward</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // memmove(dev->buffer, dev->buffer + to_copy, dev->data_size - to_copy)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Update dev->data_size to reflect removed data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Update *f_pos (optional)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Return number of bytes actually read (to_copy)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO DEVICE_NAME </span><span style=\"color:#9ECBFF\">\": Read </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, to_copy);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> to_copy;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>5. Buffer Management Helpers</strong>\nAdd helper functions to initialize and clean up the buffer:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> buffer_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">dev</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> initial_size</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Allocate buffer memory with kmalloc</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // dev->buffer = kmalloc(initial_size, GFP_KERNEL);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if allocation succeeded (NULL means failure)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Initialize buffer_size and data_size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Optional: Zero the buffer with memset</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> buffer_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">dev</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Free buffer memory with kfree</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set buffer pointer to NULL and sizes to 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>6. Enhanced Module Initialization</strong>\nUpdate your <code>mydevice_init</code> function (from the previous section) to set up the character device:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> __init </span><span style=\"color:#B392F0\">mydevice_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Allocate device instance structure with kzalloc</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize buffer with buffer_init(dev, BUFFER_SIZE)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Allocate device numbers with alloc_chrdev_region</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Initialize cdev structure with cdev_init(&#x26;dev->cdev, &#x26;mydevice_fops)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Add cdev to system with cdev_add</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Create device class with class_create</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Create device node with device_create</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Store dev in global pointer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO DEVICE_NAME </span><span style=\"color:#9ECBFF\">\": Module loaded with major number </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">           MAJOR</span><span style=\"color:#E1E4E8\">(dev->dev_num));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">error:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Clean up any resources allocated in reverse order on failure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Update <code>mydevice_exit</code> to clean up the character device:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#E1E4E8\"> __exit </span><span style=\"color:#B392F0\">mydevice_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: If device exists, remove device node with device_destroy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Destroy class with class_destroy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Remove cdev with cdev_del</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Unregister device numbers with unregister_chrdev_region</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Clean up buffer with buffer_cleanup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Free device instance structure with kfree</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO DEVICE_NAME </span><span style=\"color:#9ECBFF\">\": Module unloaded</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ul>\n<li><strong>Error Codes</strong>: In kernel space, errors are returned as negative integers. Common ones: <code>-ENOMEM</code> (out of memory), <code>-EFAULT</code> (bad address), <code>-ENOSPC</code> (no space), <code>-EINVAL</code> (invalid argument). Include <code>&lt;linux/errno.h&gt;</code>.</li>\n<li><strong>Pointer Annotations</strong>: Use <code>__user</code> to annotate user-space pointers in function signatures. This documents the pointer&#39;s origin and triggers sparse (a Linux kernel code checker) warnings if misused.</li>\n<li><strong>Size Types</strong>: Use <code>size_t</code> for buffer sizes and byte counts, <code>ssize_t</code> for signed sizes (return values that can be negative for errors).</li>\n<li><strong>printk Format Specifiers</strong>: For <code>size_t</code>, use <code>%zu</code>; for <code>loff_t</code> (file position), use <code>%lld</code> with explicit casting to <code>long long</code>.</li>\n</ul>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing the character device core:</p>\n<ol>\n<li><strong>Build and Load</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   make</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   sudo</span><span style=\"color:#9ECBFF\"> insmod</span><span style=\"color:#9ECBFF\"> mydevice.ko</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   dmesg</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tail</span></span></code></pre></div>\n<p>   Expected output should show the module loaded with a major number and device created.</p>\n<ol start=\"2\">\n<li><strong>Verify Device Node</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   ls</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#9ECBFF\"> /dev/mychardev</span></span></code></pre></div>\n<p>   Should show a character device file with the dynamically assigned major number.</p>\n<ol start=\"3\">\n<li><strong>Test Basic Write/Read</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#79B8FF\">   echo</span><span style=\"color:#9ECBFF\"> \"Hello, kernel!\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> sudo</span><span style=\"color:#9ECBFF\"> tee</span><span style=\"color:#9ECBFF\"> /dev/mychardev</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   sudo</span><span style=\"color:#9ECBFF\"> cat</span><span style=\"color:#9ECBFF\"> /dev/mychardev</span></span></code></pre></div>\n<p>   Expected: &quot;Hello, kernel!&quot; printed to terminal. Check <code>dmesg</code> for &quot;Wrote X bytes&quot; and &quot;Read X bytes&quot; messages.</p>\n<ol start=\"4\">\n<li><strong>Test Partial Writes</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Write more data than buffer can hold (if buffer is 1024 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   dd</span><span style=\"color:#9ECBFF\"> if=/dev/urandom</span><span style=\"color:#9ECBFF\"> bs=</span><span style=\"color:#79B8FF\">2048</span><span style=\"color:#9ECBFF\"> count=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> sudo</span><span style=\"color:#9ECBFF\"> tee</span><span style=\"color:#9ECBFF\"> /dev/mychardev</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\">/dev/null</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   dmesg</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tail</span></span></code></pre></div>\n<p>   Should show a write of at most 1024 bytes (or your <code>BUFFER_SIZE</code>).</p>\n<p><strong>Signs of Trouble</strong>:</p>\n<ul>\n<li><code>insmod</code> fails: Check <code>dmesg</code> for error messages. Common issues: missing symbols (forgot to implement a required function), permission issues.</li>\n<li><code>/dev/mychardev</code> not created: Verify <code>device_create</code> succeeded. Check if the <code>dev</code> class appears in <code>/sys/class/</code>.</li>\n<li>Write succeeds but read returns nothing: Check your buffer management logic. Ensure <code>data_size</code> is updated correctly and <code>memmove</code> works properly.</li>\n<li>Permission denied when accessing <code>/dev/mychardev</code>: The device node gets default permissions. Use <code>sudo</code> or fix permissions with <code>sudo chmod 666 /dev/mychardev</code>.</li>\n</ul>\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Kernel panic/oops when writing to device</td>\n<td>Direct dereference of user-space pointer</td>\n<td>Look at oops message in <code>dmesg</code> - it will show the faulting instruction</td>\n<td>Use <code>copy_from_user</code> instead of direct access</td>\n</tr>\n<tr>\n<td><code>write()</code> returns success but no data appears in buffer</td>\n<td><code>copy_from_user</code> failure not checked</td>\n<td>Add <code>printk</code> before and after <code>copy_from_user</code>, check return value</td>\n<td>Handle <code>copy_from_user</code> errors, return <code>-EFAULT</code></td>\n</tr>\n<tr>\n<td><code>read()</code> returns 0 immediately even after writing data</td>\n<td><code>data_size</code> not updated or buffer logic error</td>\n<td>Add <code>printk</code> to show <code>data_size</code> in read/write handlers</td>\n<td>Ensure <code>data_size</code> is incremented on write and decremented on read</td>\n</tr>\n<tr>\n<td>Device node not created in <code>/dev</code></td>\n<td><code>device_create</code> failed or class not created</td>\n<td>Check return value of <code>class_create</code> and <code>device_create</code>, check <code>dmesg</code></td>\n<td>Ensure proper error handling in init function</td>\n</tr>\n<tr>\n<td>Multiple opens corrupt data</td>\n<td>No concurrency protection (Milestone 4 issue)</td>\n<td>Not applicable yet, but will be fixed in Milestone 4 with mutex</td>\n<td>Implement mutex locking in all buffer access paths</td>\n</tr>\n</tbody></table>\n<p>Remember: The character device core establishes the fundamental data path. Get this working correctly before adding the more advanced features in subsequent milestones.</p>\n<h2 id=\"component-control-interface-ioctl-and-proc\">Component: Control Interface (ioctl and proc)</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 3</p>\n</blockquote>\n<p>This component extends the character device driver beyond simple read and write operations, providing a dedicated control plane for configuration, monitoring, and management. While the device file <code>/dev/mychardev</code> serves as the <strong>data plane</strong> for byte stream I/O, the <code>ioctl</code> interface and the <code>/proc</code> filesystem entry form the <strong>control plane</strong>, allowing userspace programs to query device state, modify parameters, and perform administrative actions. The core architectural challenge is designing a safe, well-defined protocol that crosses the kernel-user boundary without introducing security vulnerabilities or system instability, while providing intuitive access to internal driver state.</p>\n<h3 id=\"mental-model-the-driver39s-control-panel-and-dashboard\">Mental Model: The Driver&#39;s Control Panel and Dashboard</h3>\n<p>Imagine the device driver as a complex piece of industrial machinery in a factory. The <code>/dev/mychardev</code> file is the <strong>conveyor belt</strong> where raw materials (data bytes) are placed and retrieved. The <code>ioctl</code> interface, then, is the <strong>control panel</strong> attached to this machinery—a series of labeled buttons, dials, and switches that allow an operator to change the machine&#39;s operating mode, adjust its speed, or clear a jam. Each button (<code>ioctl</code> command) performs a specific, privileged action that you wouldn&#39;t (or couldn&#39;t) do by just putting items on the conveyor belt.</p>\n<p>The <code>/proc/mychardev_stats</code> entry, in this analogy, is the <strong>real-time dashboard</strong> mounted on the factory wall. It doesn&#39;t accept commands; instead, it displays continuously updated metrics: how many items have passed through the conveyor belt today, the current capacity of the buffer, whether the safety lock (mutex) is engaged, and how many operators are waiting for items to arrive. Anyone can glance at this dashboard to understand the machinery&#39;s health and performance without interrupting its operation.</p>\n<p>This separation of concerns is critical in kernel design. The <code>ioctl</code> interface uses the <strong>command-argument</strong> paradigm: a numeric command (<code>MYDEVICE_IOCTL_CLEAR</code>) is sent, optionally with a parameter (like a new buffer size), and the kernel executes the associated handler. The <code>/proc</code> interface uses the <strong>file-as-information</strong> paradigm: reading the virtual file triggers a callback that generates a textual report of current state. Both are mediated by the Virtual File System (VFS), but they serve distinct purposes: control versus observation.</p>\n<h3 id=\"adr-raw-procfs-vs-seq_file-interface\">ADR: Raw procfs vs. seq_file Interface</h3>\n<blockquote>\n<p><strong>Decision: Use <code>proc_ops</code> with <code>single_open</code> for the /proc interface</strong></p>\n</blockquote>\n<ul>\n<li><p><strong>Context</strong>: We need to expose device statistics and configuration information via the <code>/proc</code> filesystem. The traditional <code>/proc</code> interface in the Linux kernel has evolved, with the older <code>file_operations</code>-based model being deprecated in favor of the <code>seq_file</code> interface for multi-page output and the newer <code>proc_ops</code> structure. We must choose an implementation that is educationally accessible while being functionally correct and forward-compatible.</p>\n</li>\n<li><p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>Raw <code>proc_create</code> with <code>file_operations</code> (Deprecated)</strong>: The classic method using a custom <code>read</code> function that manages offsets and partial reads manually.</li>\n<li><strong><code>seq_file</code> Interface</strong>: The recommended, more complex interface that handles iteration, page-sized output, and formatting automatically.</li>\n<li><strong><code>proc_ops</code> with <code>single_open</code></strong>: A simplified wrapper around <code>seq_file</code> that uses the <code>single_open</code> helper for cases where the entire output fits in a single kernel buffer (typically one page, 4KB).</li>\n</ol>\n</li>\n<li><p><strong>Decision</strong>: We will implement the <code>/proc</code> entry using the <code>proc_ops</code> structure with the <code>single_open</code> helper function and a custom <code>mydevice_proc_show</code> callback. This method provides a balance between simplicity for learners and adherence to modern kernel APIs.</p>\n</li>\n<li><p><strong>Rationale</strong>:</p>\n<ul>\n<li><strong>Educational Clarity</strong>: The <code>single_open</code> method requires implementing only one show function (<code>mydevice_proc_show</code>) that prints all information at once, avoiding the complexity of the <code>seq_file</code> iterator (<code>start</code>, <code>next</code>, <code>stop</code>, <code>show</code>). This allows learners to focus on the data being presented rather than the mechanics of multi-page output.</li>\n<li><strong>Modern API</strong>: Using <code>proc_ops</code> is the current non-deprecated method (since kernel 5.6+), avoiding warnings and ensuring compatibility. The <code>single_open</code> helper is a standard, well-documented pattern.</li>\n<li><strong>Adequate Capacity</strong>: Our device statistics (buffer size, data size, lock status) will easily fit within a single page (4KB). The <code>seq_file</code> interface&#39;s primary advantage—handling large, multi-page outputs—is not needed for this project&#39;s scope.</li>\n</ul>\n</li>\n<li><p><strong>Consequences</strong>:</p>\n<ul>\n<li><strong>Positive</strong>: Simplified code with fewer callbacks to implement and debug. The <code>single_open</code> method automatically handles <code>lseek</code> correctly and manages the single buffer.</li>\n<li><strong>Negative</strong>: If the output were to grow beyond one page (very unlikely for our use case), the read would be truncated. For future expansion into more detailed statistics, we might need to migrate to the full <code>seq_file</code> interface.</li>\n<li><strong>Maintenance</strong>: The code will be compatible with current and future kernels while avoiding deprecation warnings.</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Raw <code>file_operations</code></td>\n<td>Direct control over read/offset logic, traditional learning example</td>\n<td>Deprecated API, error-prone manual offset management, not forward-compatible</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Full <code>seq_file</code> Interface</td>\n<td>Handles multi-page output elegantly, standard for complex /proc files</td>\n<td>Steeper learning curve, requires four callbacks to implement</td>\n<td>No</td>\n</tr>\n<tr>\n<td><code>proc_ops</code> with <code>single_open</code></td>\n<td>Modern API, simple single-callback implementation, automatic offset handling</td>\n<td>Output limited to single page, less flexible for future expansion</td>\n<td><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-ioctl-and-procfs\">Common Pitfalls: ioctl and procfs</h3>\n<p>Implementing control interfaces is deceptively tricky. The following pitfalls are common for developers new to kernel programming and can lead to subtle bugs, security issues, or system crashes.</p>\n<p>⚠️ <strong>Pitfall 1: Incorrect ioctl Command Numbering</strong></p>\n<ul>\n<li><strong>Description</strong>: Defining <code>ioctl</code> command numbers arbitrarily (e.g., <code>#define MY_CLEAR 1</code>) without using the standard <code>_IO</code>, <code>_IOR</code>, <code>_IOW</code>, <code>_IOWR</code> macros, or choosing a magic number that conflicts with other drivers.</li>\n<li><strong>Why it&#39;s wrong</strong>: The kernel uses the command number to verify the direction (read/write) and size of the data argument. Arbitrary numbers can collide with other drivers&#39; commands, leading to unintended behavior. The macros encode a unique 8-bit &quot;magic number,&quot; a sequential command number, the data size, and the direction bits.</li>\n<li><strong>Fix</strong>: Always use the macros with a unique magic character (e.g., <code>&#39;k&#39;</code>), and define commands in a shared header. Example: <code>#define MYDEVICE_IOCTL_CLEAR _IO(&#39;k&#39;, 3)</code>.</li>\n</ul>\n<p>⚠️ <strong>Pitfall 2: Missing Size Argument in _IOR/_IOW Macros</strong></p>\n<ul>\n<li><strong>Description</strong>: Forgetting to include the size of the data type as the third argument to <code>_IOR(type, nr, size)</code> or <code>_IOW(type, nr, size)</code>.</li>\n<li><strong>Why it&#39;s wrong</strong>: The kernel uses this size to perform automatic validation on 32-bit/64-bit compatibility (using the <code>_IOC_SIZE</code> macro). If omitted, the kernel cannot verify that the userspace argument is the correct size, potentially causing memory corruption or information leaks.</li>\n<li><strong>Fix</strong>: Always pass the <code>sizeof()</code> the data type being transferred. Example: <code>_IOR(MYDEVICE_IOC_MAGIC, 1, size_t)</code> for a command that returns a <code>size_t</code>.</li>\n</ul>\n<p>⚠️ <strong>Pitfall 3: Dereferencing User Pointer Directly in ioctl</strong></p>\n<ul>\n<li><strong>Description</strong>: Treating the <code>arg</code> parameter in <code>mydevice_ioctl</code> as a kernel pointer and directly reading or writing through it (e.g., <code>*(int *)arg = value;</code>).</li>\n<li><strong>Why it&#39;s wrong</strong>: The <code>arg</code> pointer is a <strong>userspace address</strong>. Direct dereferencing will cause a kernel oops (page fault) because kernel code cannot access user memory directly. All data transfer must go through <code>copy_to_user</code> or <code>copy_from_user</code>.</li>\n<li><strong>Fix</strong>: For input arguments, use <code>copy_from_user(&amp;kernel_var, (void __user *)arg, sizeof(kernel_var))</code>. For output, use <code>copy_to_user((void __user *)arg, &amp;kernel_var, sizeof(kernel_var))</code>.</li>\n</ul>\n<p>⚠️ <strong>Pitfall 4: Mishandling Partial Reads in /proc Callbacks (Raw Method)</strong></p>\n<ul>\n<li><strong>Description</strong>: When using the deprecated raw <code>proc_read</code> function, not correctly updating the file position offset (<code>*off</code>) and returning the correct number of bytes copied, leading to infinite loops or truncated output when <code>cat</code>-ing the file.</li>\n<li><strong>Why it&#39;s wrong</strong>: The VFS may call the read callback multiple times for a single <code>read()</code> system call, each time with an increased buffer offset. If the function always returns the full data from the start, the output will be repeated. If it doesn&#39;t update <code>*off</code> correctly, the read may never finish.</li>\n<li><strong>Fix</strong>: This is precisely why we avoid the raw method. With <code>single_open</code>, the <code>seq_file</code> layer handles all offset and partial read logic automatically. Our <code>mydevice_proc_show</code> function simply prints everything once.</li>\n</ul>\n<p>⚠️ <strong>Pitfall 5: Not Checking copy_to/from_user Return Values in ioctl</strong></p>\n<ul>\n<li><strong>Description</strong>: Ignoring the return value of <code>copy_to_user</code> or <code>copy_from_user</code> (which indicates number of bytes NOT copied) and assuming the copy succeeded.</li>\n<li><strong>Why it&#39;s wrong</strong>: These functions can fail if the userspace pointer is invalid (e.g., NULL, points to unmapped memory, or is in a protected region). Failure should be propagated to userspace as an error (<code>-EFAULT</code>).</li>\n<li><strong>Fix</strong>: Always check: <code>if (copy_to_user(...)) { return -EFAULT; }</code>.</li>\n</ul>\n<p>⚠️ <strong>Pitfall 6: Forgetting to Acquire the Mutex in ioctl Handlers</strong></p>\n<ul>\n<li><strong>Description</strong>: Performing operations on the shared device buffer (like resizing or clearing) in the <code>ioctl</code> handler without first acquiring the device&#39;s mutex, while concurrent <code>read</code>/<code>write</code> operations may also be accessing the buffer.</li>\n<li><strong>Why it&#39;s wrong</strong>: This creates a race condition. For example, a <code>buffer_resize</code> could reallocate the buffer while a <code>read</code> is copying data out, leading to use-after-free, corruption, or crashes.</li>\n<li><strong>Fix</strong>: Protect all <code>ioctl</code> commands that touch shared state with <code>mutex_lock(&amp;dev-&gt;lock)</code> and <code>mutex_unlock(&amp;dev-&gt;lock)</code>. Consider the lock ordering if multiple locks are involved (though we only have one).</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This subsection provides concrete code skeletons and organizational advice to implement the control interface. The primary language is C, targeting the Linux kernel API.</p>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Recommended)</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Ioctl Interface</strong></td>\n<td><code>unlocked_ioctl</code> with <code>_IO*</code> macros and a shared header</td>\n<td><code>compat_ioctl</code> for 32-bit userspace on 64-bit kernels</td>\n</tr>\n<tr>\n<td><strong>Proc Filesystem</strong></td>\n<td><code>proc_ops</code> with <code>single_open</code>/<code>single_release</code></td>\n<td>Full <code>seq_file</code> interface with iterator callbacks</td>\n</tr>\n<tr>\n<td><strong>Command Definitions</strong></td>\n<td>Central header file included by both kernel and userspace</td>\n<td>Dynamically assigned ioctl numbers via kernel registration</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<p>Extend the existing project structure to separate interface definitions and add the userspace test program.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n├── mychardev.c              # Main driver source (add ioctl &amp; proc handlers here)\n├── mychardev.h              # Shared header with ioctl command definitions\n├── Makefile                 # Kbuild makefile\n├── test_ioctl.c             # Userspace test program for ioctl commands\n└── README.md</code></pre></div>\n\n<p>The shared header <code>mychardev.h</code> is critical—it must be includable by both kernel code (under <code>#ifdef __KERNEL__</code>) and userspace C programs. This ensures command numbers and data structures are in sync.</p>\n<h4 id=\"c-infrastructure-starter-code-shared-header-file\">C. Infrastructure Starter Code: Shared Header File</h4>\n<p>Create <code>mychardev.h</code> with the following complete code. This file bridges kernel and userspace.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> MYCHARDEV_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYCHARDEV_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/ioctl.h></span><span style=\"color:#6A737D\">  /* For _IO* macros used in kernel */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/types.h></span><span style=\"color:#6A737D\">  /* For size_t in kernel mode */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * The 'magic' number for our ioctl commands.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Choose a unique character (8 bits) not used by other drivers.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * See Documentation/ioctl/ioctl-number.rst in kernel sources.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOC_MAGIC</span><span style=\"color:#9ECBFF\"> 'k'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Define the ioctl commands.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * _IOR(type, nr, size): defines a read command (data from kernel->user)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * _IOW(type, nr, size): defines a write command (data from user->kernel)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * _IO(type, nr):        defines a command with no data transfer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOCTL_GET_SIZE</span><span style=\"color:#B392F0\"> _IOR</span><span style=\"color:#E1E4E8\">(MYDEVICE_IOC_MAGIC, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOCTL_GET_MAX_CAPACITY</span><span style=\"color:#B392F0\"> _IOR</span><span style=\"color:#E1E4E8\">(MYDEVICE_IOC_MAGIC, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOCTL_CLEAR</span><span style=\"color:#B392F0\"> _IO</span><span style=\"color:#E1E4E8\">(MYDEVICE_IOC_MAGIC, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOCTL_RESIZE</span><span style=\"color:#B392F0\"> _IOW</span><span style=\"color:#E1E4E8\">(MYDEVICE_IOC_MAGIC, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * The maximum allowed buffer size to prevent excessive memory allocation.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Define it here so userspace knows the limit.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_BUFFER_SIZE</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\"> /* 1 MiB */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> /* MYCHARDEV_H */</span></span></code></pre></div>\n\n<p><strong>Note for kernel compilation</strong>: When this header is included in the kernel module, <code>size_t</code> will resolve to the kernel&#39;s <code>size_t</code> (typically <code>unsigned long</code>). In userspace, it resolves to the standard C library&#39;s <code>size_t</code>. This is acceptable as long as both are the same width (which they are on most platforms). For maximum portability, we could use <code>__kernel_size_t</code> and provide a userspace typedef, but for simplicity we assume <code>size_t</code> matches.</p>\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>1. Adding ioctl Handler to <code>file_operations</code></strong></p>\n<p>In <code>mychardev.c</code>, update the <code>struct file_operations</code> to include the <code>unlocked_ioctl</code> handler (and compat_ioctl if you want 32-bit support).</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> file_operations mydevice_fops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .owner </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> THIS_MODULE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .open </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_open,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .release </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_release,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .read </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_read,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .write </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_write,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .unlocked_ioctl </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_ioctl,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // .compat_ioctl = mydevice_ioctl, // Optional for 32-bit compatibility</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>2. Implementing <code>mydevice_ioctl</code></strong></p>\n<p>Add the handler function. Note the careful locking and user copy operations.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"mychardev.h\"</span><span style=\"color:#6A737D\">  /* Our shared definitions */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/slab.h></span><span style=\"color:#6A737D\">  /* For krealloc */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> long</span><span style=\"color:#B392F0\"> mydevice_ioctl</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> int</span><span style=\"color:#FFAB70\"> cmd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> arg</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">dev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> filp->private_data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> new_size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">user_arg </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)arg;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 1: Check that the ioctl command's magic number matches ours.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Hint: Use _IOC_TYPE(cmd) to extract the magic number and compare.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * If mismatch, return -ENOTTY (not our command).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 2: Acquire the device mutex to protect shared buffer state.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Hint: mutex_lock(&#x26;dev->lock);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> (cmd) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MYDEVICE_IOCTL_GET_SIZE:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* TODO 3: Copy the current data size (dev->data_size) to userspace.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Use copy_to_user(user_arg, &#x26;dev->data_size, sizeof(size_t)).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * If copy fails, set ret = -EFAULT.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MYDEVICE_IOCTL_GET_MAX_CAPACITY:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* TODO 4: Copy the current buffer capacity (dev->buffer_size) to userspace.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Similar to GET_SIZE.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MYDEVICE_IOCTL_CLEAR:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* TODO 5: Clear the buffer: set dev->data_size = 0.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Also, wake up any readers that might be waiting for data? (No, they wait for data, not emptiness).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Consider if you need to wake up writers waiting for space? (Not implemented in this design).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MYDEVICE_IOCTL_RESIZE:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* TODO 6: Copy the requested new size from userspace.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Use copy_from_user(&#x26;new_size, user_arg, sizeof(size_t)).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * If copy fails, set ret = -EFAULT and break.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* TODO 7: Validate new_size: must be > 0 and &#x3C;= MAX_BUFFER_SIZE.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * If invalid, set ret = -EINVAL and break.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* TODO 8: Call buffer_resize(dev, new_size) (to be implemented).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * If resize fails, set ret = -ENOMEM.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* TODO 9: Command not recognized. Set ret = -ENOTTY.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * This handles commands with our magic number but unknown nr.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 10: Release the device mutex.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Hint: mutex_unlock(&#x26;dev->lock);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>3. Implementing <code>buffer_resize</code> Helper</strong></p>\n<p>This function, called from the ioctl handler, must safely resize the internal buffer while preserving existing data.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> buffer_resize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">dev</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> new_size</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">new_buffer;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 1: Allocate new buffer with kmalloc, using GFP_KERNEL flag.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Hint: new_buffer = kmalloc(new_size, GFP_KERNEL);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * If allocation fails, return -ENOMEM.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 2: Copy existing data from old buffer to new buffer.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Only copy up to min(dev->data_size, new_size) bytes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Use memcpy(new_buffer, dev->buffer, copy_size).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 3: Update dev->data_size to the copied size (cannot exceed new capacity).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Hint: dev->data_size = min(dev->data_size, new_size);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 4: Free the old buffer using kfree(dev->buffer). */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 5: Assign the new buffer and new size to the device structure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * dev->buffer = new_buffer;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * dev->buffer_size = new_size;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 6: Print a debug message via printk(KERN_INFO \"buffer resized to %zu\\n\", new_size). */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> /* Success */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>4. Creating the /proc Entry</strong></p>\n<p>Add to your <code>mydevice_init</code> function to create the proc entry, and clean up in <code>mydevice_exit</code>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/proc_fs.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> proc_dir_entry </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">mydevice_proc_entry;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydevice_proc_show</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> seq_file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">m</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">v</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">dev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> m->private;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 1: Acquire the device mutex to read consistent state.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Hint: mutex_lock(&#x26;dev->lock);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 2: Use seq_printf to output statistics, one line per metric.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Example:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * seq_printf(m, \"Buffer capacity: %zu bytes\\n\", dev->buffer_size);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * seq_printf(m, \"Data stored: %zu bytes\\n\", dev->data_size);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * seq_printf(m, \"Maximum allowed size: %d bytes\\n\", MAX_BUFFER_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * seq_printf(m, \"Device major number: %d\\n\", MAJOR(dev->dev_num));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * seq_printf(m, \"Device minor number: %d\\n\", MINOR(dev->dev_num));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 3: Release the device mutex.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Hint: mutex_unlock(&#x26;dev->lock);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydevice_proc_open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> inode </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">inode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">file</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 1: Use single_open() to associate the show function with the file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * single_open(file, mydevice_proc_show, NULL);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * But we need to pass the device data. How to get it?</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * We can use a global pointer or PDE_DATA(inode). Let's use a global.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Declare: extern struct mydevice_data *mydevice_dev; (defined in main file)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Then: return single_open(file, mydevice_proc_show, mydevice_dev);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> proc_ops mydevice_proc_ops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .proc_open </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_proc_open,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .proc_read </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> seq_read,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .proc_lseek </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> seq_lseek,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .proc_release </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> single_release,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* In mydevice_init, after device creation: */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> __init </span><span style=\"color:#B392F0\">mydevice_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ... existing initialization ... */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Create /proc entry */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mydevice_proc_entry </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> proc_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mychardev_stats\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">444</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">mydevice_proc_ops);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">mydevice_proc_entry) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pr_err</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to create /proc entry</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Handle error: unregister device and class */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOMEM;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* In mydevice_exit: */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#E1E4E8\"> __exit </span><span style=\"color:#B392F0\">mydevice_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    proc_remove</span><span style=\"color:#E1E4E8\">(mydevice_proc_entry);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ... existing cleanup ... */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>5. Userspace Test Program</strong></p>\n<p>Create <code>test_ioctl.c</code> to verify the ioctl interface works correctly from userspace.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;fcntl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/ioctl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"mychardev.h\"</span><span style=\"color:#6A737D\">  /* Shared header */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size, capacity;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/dev/mychardev\"</span><span style=\"color:#E1E4E8\">, O_RDWR);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to open /dev/mychardev\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exit</span><span style=\"color:#E1E4E8\">(EXIT_FAILURE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Get current data size */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ioctl</span><span style=\"color:#E1E4E8\">(fd, MYDEVICE_IOCTL_GET_SIZE, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">size) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ioctl GET_SIZE failed\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Current data size: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Get buffer capacity */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ioctl</span><span style=\"color:#E1E4E8\">(fd, MYDEVICE_IOCTL_GET_MAX_CAPACITY, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">capacity) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ioctl GET_MAX_CAPACITY failed\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Buffer capacity: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, capacity);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Clear the buffer */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Clearing buffer...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ioctl</span><span style=\"color:#E1E4E8\">(fd, MYDEVICE_IOCTL_CLEAR) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ioctl CLEAR failed\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Resize buffer to 2048 bytes */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> new_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2048</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Resizing buffer to </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, new_size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ioctl</span><span style=\"color:#E1E4E8\">(fd, MYDEVICE_IOCTL_RESIZE, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">new_size) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ioctl RESIZE failed\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Resize successful.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ul>\n<li><strong>Kernel vs. Userspace Headers</strong>: The shared header <code>mychardev.h</code> will be included in both contexts. Use <code>#ifdef __KERNEL__</code> to conditionally include kernel-specific headers (like <code>&lt;linux/ioctl.h&gt;</code>) versus userspace headers (like <code>&lt;sys/ioctl.h&gt;</code>). However, since our commands are defined using kernel macros, we can just always include <code>&lt;linux/ioctl.h&gt;</code> and rely on userspace having a compatible definition (often available via <code>linux/ioctl.h</code> or manually defining the macros). A simpler approach is to copy the macro definitions directly into the header if portability is a concern.</li>\n<li><strong><code>size_t</code> in ioctl</strong>: The <code>size</code> argument in <code>_IOR</code> expects a type name, but <code>size_t</code> is a typedef. The macro works fine because it uses <code>sizeof(type)</code>. However, ensure the kernel and userspace agree on the width of <code>size_t</code> (usually they do).</li>\n<li><strong>Error Codes</strong>: Familiarize yourself with kernel error codes: <code>-EFAULT</code> (bad address), <code>-ENOTTY</code> (invalid ioctl command), <code>-EINVAL</code> (invalid argument), <code>-ENOMEM</code> (out of memory). Return these negative numbers from your ioctl handler; the VFS will convert them to positive <code>errno</code> values for userspace.</li>\n<li><strong>Procfs Permissions</strong>: The mode <code>0444</code> in <code>proc_create</code> means read-only for all users. Use <code>0644</code> if you later add a write callback. Always restrict permissions to the minimum necessary.</li>\n</ul>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing the ioctl handler and /proc entry:</p>\n<ol>\n<li><strong>Compile and load the module</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   make\n   sudo insmod mychardev.ko</code></pre></div>\n<p>   Check <code>dmesg</code> for success messages and note the assigned major number.</p>\n<ol start=\"2\">\n<li><strong>Verify <code>/proc</code> entry exists</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   cat /proc/mychardev_stats</code></pre></div>\n<p>   Expected output: lines showing buffer capacity (initially 1024), data size (0), max size (1048576), and major/minor numbers.</p>\n<ol start=\"3\">\n<li><strong>Run the userspace test program</strong> (compile with <code>gcc -o test_ioctl test_ioctl.c</code>):</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   sudo ./test_ioctl</code></pre></div>\n<p>   Expected output:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   Current data size: 0 bytes\n   Buffer capacity: 1024 bytes\n   Clearing buffer...\n   Resizing buffer to 2048 bytes...\n   Resize successful.</code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Verify resize via <code>/proc</code></strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   cat /proc/mychardev_stats</code></pre></div>\n<p>   Should now show &quot;Buffer capacity: 2048 bytes&quot;.</p>\n<ol start=\"5\">\n<li><strong>Test error conditions</strong>:<ul>\n<li>Run <code>ioctl</code> with an invalid command (should return <code>-1</code> with <code>errno=ENOTTY</code>).</li>\n<li>Attempt to resize to a size &gt; <code>MAX_BUFFER_SIZE</code> (should return <code>-1</code> with <code>errno=EINVAL</code>).</li>\n</ul>\n</li>\n</ol>\n<p>If any step fails, check <code>dmesg</code> for kernel error messages. Common issues: forgetting to implement the <code>buffer_resize</code> function, incorrect mutex locking, or misdefined ioctl commands.</p>\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ioctl</code> returns <code>-1</code> with <code>errno=25</code> (<code>ENOTTY</code>)</td>\n<td>Command number not recognized by driver (magic number mismatch or command not in switch)</td>\n<td>Check <code>dmesg</code> for messages. Use <code>strace ./test_ioctl</code> to see the exact <code>ioctl</code> call and command number. Verify the command definitions in the header match those in the driver&#39;s switch statement.</td>\n<td>Ensure <code>MYDEVICE_IOC_MAGIC</code> is the same in header and driver. Check that the command number (e.g., <code>1</code> for <code>GET_SIZE</code>) matches the <code>_IOR</code> macro&#39;s second argument.</td>\n</tr>\n<tr>\n<td><code>ioctl</code> returns <code>-1</code> with <code>errno=14</code> (<code>EFAULT</code>)</td>\n<td><code>copy_to_user</code> or <code>copy_from_user</code> failed due to invalid userspace pointer</td>\n<td>The test program likely passes a bad address. Ensure the userspace program passes a valid pointer (e.g., address of a stack variable). In the driver, verify you are using <code>copy_*_user</code> correctly and checking return values.</td>\n<td>In userspace, check that <code>&amp;size</code> is a valid address. In kernel, ensure you cast <code>arg</code> to <code>(void __user *)</code>.</td>\n</tr>\n<tr>\n<td><code>/proc/mychardev_stats</code> shows garbled numbers or kernel oops</td>\n<td>Race condition: reading <code>/proc</code> while buffer is being resized, or missing mutex protection</td>\n<td>Add <code>printk</code> in <code>mydevice_proc_show</code> before and after lock acquisition. Check <code>dmesg</code> for &quot;BUG: sleeping function called from invalid context&quot; if you use a sleeping lock in atomic context (not applicable here).</td>\n<td>Ensure <code>mydevice_proc_show</code> acquires <code>dev-&gt;lock</code> before accessing any device fields.</td>\n</tr>\n<tr>\n<td>Buffer resize fails silently (no error but capacity unchanged)</td>\n<td><code>buffer_resize</code> not implemented or not called, or <code>new_size</code> validation fails</td>\n<td>Add debug <code>printk</code> in each branch of the ioctl switch and in <code>buffer_resize</code>. Check <code>dmesg</code> for these messages.</td>\n<td>Implement <code>buffer_resize</code> function and ensure it&#39;s called from the <code>MYDEVICE_IOCTL_RESIZE</code> case. Verify <code>new_size</code> is within <code>[1, MAX_BUFFER_SIZE]</code>.</td>\n</tr>\n<tr>\n<td><code>cat /proc/mychardev_stats</code> hangs indefinitely</td>\n<td>Deadlock in <code>/proc</code> show function (e.g., double lock acquisition)</td>\n<td>Check if <code>mydevice_proc_show</code> calls a function that also tries to acquire the same mutex. Look for <code>mutex_lock</code> without matching <code>mutex_unlock</code>.</td>\n<td>Ensure lock acquisition is paired with release on all code paths, including error returns. Avoid calling functions that lock the same mutex.</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"component-concurrency-and-synchronization-manager\">Component: Concurrency and Synchronization Manager</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 4</p>\n</blockquote>\n<p>This component transforms the driver from a simple, single-user device into a robust system that can safely handle concurrent access from multiple processes. It manages the kernel&#39;s most powerful concurrency primitives—mutexes, wait queues, and poll/select notification—to prevent data corruption and provide predictable behavior when multiple userspace programs read and write simultaneously. Think of this as the driver&#39;s &quot;traffic control center,&quot; coordinating access to shared resources without deadlocks or race conditions.</p>\n<h3 id=\"mental-model-the-queue-at-the-library-desk\">Mental Model: The Queue at the Library Desk</h3>\n<p>Imagine a public library with a single reference desk where patrons can write messages into a communal notebook and read messages left by others. This notebook represents the driver&#39;s internal buffer. Without rules, chaos ensues: two people writing simultaneously might overwrite each other, someone reading while another writes might see garbled text, and someone trying to read from an empty notebook just wastes time.</p>\n<p>Now introduce a librarian (the kernel driver) who implements three key systems:</p>\n<ol>\n<li><p><strong>The &quot;One-at-a-Time&quot; Ticket (Mutex)</strong>: The librarian issues a single ticket that grants exclusive access to the notebook. Any patron wanting to read or write must first obtain this ticket. If someone else has it, they wait patiently in their seat (the process sleeps). This prevents simultaneous modifications and ensures each operation sees a consistent state. The ticket is returned immediately after the operation so others can use it.</p>\n</li>\n<li><p><strong>The Waiting Line for Readers (Wait Queue)</strong>: When the notebook is empty, readers have nothing to do. Instead of constantly asking &quot;Is there data yet?&quot; (busy-waiting), they take a numbered ticket and sit in a designated waiting area (the wait queue). When a writer adds new data to the notebook, the librarian announces &quot;Data available!&quot; and calls the next number in line, waking up exactly one waiting reader. This is efficient and polite.</p>\n</li>\n<li><p><strong>The &quot;Ready-to-Serve&quot; Light (Poll/Select)</strong>: Some patrons prefer not to wait idly. They want to know in advance if the notebook has data or has space for writing. The librarian installs a status light with two bulbs: &quot;Data Available to Read&quot; and &quot;Space Available to Write.&quot; Patrons can glance at this light (via <code>poll()</code> or <code>select()</code>) and only approach the desk when it shows what they need. This enables efficient I/O multiplexing where a single program can monitor multiple notebooks (file descriptors) simultaneously.</p>\n</li>\n</ol>\n<p>This mental model clarifies why we need synchronization: kernel data structures exist in a shared, preemptible environment where multiple execution contexts (processes, interrupts) can access them concurrently. The mutex provides mutual exclusion, the wait queue enables efficient blocking, and poll support enables non-blocking readiness checking.</p>\n<h3 id=\"adr-mutex-vs-spinlock-for-buffer-protection\">ADR: Mutex vs. Spinlock for Buffer Protection</h3>\n<blockquote>\n<p><strong>Decision: Use a Mutex (<code>struct mutex</code>) for Buffer Protection Instead of a Spinlock</strong></p>\n<ul>\n<li><strong>Context</strong>: Our driver&#39;s <code>read</code> and <code>write</code> handlers perform operations that may sleep—specifically, <code>copy_to_user</code>, <code>copy_from_user</code>, and <code>wait_event_interruptible</code>. These functions can block the current process if the required user memory is paged out or if we voluntarily sleep on a wait queue. The locking primitive must accommodate this sleeping behavior.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Mutex (<code>struct mutex</code>, <code>mutex_lock()</code>)</strong>: A sleeping lock that yields the CPU when contested.</li>\n<li><strong>Spinlock (<code>spinlock_t</code>, <code>spin_lock()</code>)</strong>: A busy-wait lock that loops continuously until acquired.</li>\n<li><strong>Reader-Writer Semaphore (<code>struct rw_semaphore</code>)</strong>: Allows multiple concurrent readers or a single writer.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: We will use a standard mutex (<code>struct mutex</code>) initialized with <code>mutex_init()</code> and protected with <code>mutex_lock()</code>/<code>mutex_unlock()</code>.</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Sleep Safety</strong>: Mutexes are explicitly designed for contexts where the holder may sleep. Spinlocks cannot be held across operations that might sleep (doing so can deadlock the entire system if the scheduler preempts the lock holder).</li>\n<li><strong>Simplicity</strong>: For our single-buffer model with relatively short critical sections, the overhead of a reader-writer lock is unnecessary. A mutex provides straightforward exclusive access.</li>\n<li><strong>Performance Characteristics</strong>: Critical sections in our driver (copying data, updating buffer metadata) are sufficiently short that spinlock overhead might be acceptable, but the risk of accidentally sleeping while holding the lock (e.g., in future code changes) outweighs any micro-optimization benefit.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li><strong>Positive</strong>: Code remains simple and safe against common sleeping-in-atomic-context errors. The mutex automatically handles process scheduling when blocked.</li>\n<li><strong>Negative</strong>: Slightly higher overhead than a spinlock due to scheduling costs, but this is negligible for a character device. Only one reader or writer can access the buffer at a time, even if multiple concurrent reads would be safe (a trade-off we accept for simplicity).</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Mutex</strong></td>\n<td>Safe for sleeping contexts; simple API; automatic scheduling of waiters</td>\n<td>Higher overhead than spinlock for very short critical sections; exclusive access only (no reader concurrency)</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td><strong>Spinlock</strong></td>\n<td>Very low overhead for nano-second critical sections; can be used in interrupt context</td>\n<td><strong>Cannot sleep while held</strong> – deadly if used with <code>copy_to_user</code> or wait queues; wastes CPU while spinning</td>\n<td>No</td>\n</tr>\n<tr>\n<td><strong>Reader-Writer Semaphore</strong></td>\n<td>Allows multiple concurrent readers; still sleeping-safe</td>\n<td>More complex API; potential writer starvation if readers are continuous; overkill for our simple buffer</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<p>This decision directly influences the fields in our <code>struct mydevice_data</code>: we include a <code>lock</code> field of type <code>struct mutex</code>, not <code>spinlock_t</code>.</p>\n<h3 id=\"common-pitfalls-kernel-synchronization\">Common Pitfalls: Kernel Synchronization</h3>\n<p>Kernel concurrency is notoriously subtle. Here are the most common mistakes when implementing this component, why they&#39;re dangerous, and how to avoid them.</p>\n<h4 id=\"-pitfall-sleeping-while-holding-a-spinlock\">⚠️ <strong>Pitfall: Sleeping While Holding a Spinlock</strong></h4>\n<ul>\n<li><strong>Description</strong>: Calling a function that may sleep (like <code>copy_to_user</code>, <code>kmalloc</code> with <code>GFP_KERNEL</code>, or <code>wait_event_interruptible</code>) while holding a spinlock.</li>\n<li><strong>Why It&#39;s Wrong</strong>: Spinlocks are used in atomic contexts (like interrupt handlers) where sleeping is illegal. If you sleep while holding a spinlock, the scheduler might never run the process that will release it, causing a system deadlock. The kernel will emit a &quot;scheduling while atomic&quot; oops.</li>\n<li><strong>Fix</strong>: Use a mutex for locks that protect operations that may sleep. If you must use a spinlock (e.g., in an interrupt handler), ensure all functions called within the critical section are non-sleeping (use <code>GFP_ATOMIC</code> for allocations).</li>\n</ul>\n<h4 id=\"-pitfall-forgetting-to-unlock-on-error-paths\">⚠️ <strong>Pitfall: Forgetting to Unlock on Error Paths</strong></h4>\n<ul>\n<li><strong>Description</strong>: Acquiring a mutex at the start of a function but returning early on an error condition (e.g., <code>copy_to_user</code> fails) without releasing the mutex.</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">lock</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">copy_to_user</span><span style=\"color:#E1E4E8\">(...)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span><span style=\"color:#6A737D\"> // BUG: mutex still held!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">lock</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<ul>\n<li><strong>Why It&#39;s Wrong</strong>: The mutex remains locked forever, causing all subsequent calls to hang indefinitely on <code>mutex_lock</code>. This deadlock is often subtle because it only triggers when a specific error occurs.</li>\n<li><strong>Fix</strong>: Use <code>goto</code> labels for centralized cleanup or ensure every return path has a corresponding unlock. The pattern is:</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">lock</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (error) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev->lock);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> err;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">lock</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<h4 id=\"-pitfall-incorrect-wait-queue-usage-without-condition-re-check\">⚠️ <strong>Pitfall: Incorrect Wait Queue Usage Without Condition Re-check</strong></h4>\n<ul>\n<li><strong>Description</strong>: Using <code>wait_event_interruptible(wq, condition)</code> but not re-checking the condition after being woken up before proceeding.</li>\n<li><strong>Why It&#39;s Wrong</strong>: The Linux kernel has <strong>spurious wakeups</strong>—processes can be awakened from wait queues even when the condition isn&#39;t true (e.g., due to signals). If you assume the condition holds and proceed to read from an empty buffer, you&#39;ll get invalid data.</li>\n<li><strong>Fix</strong>: Always use <code>wait_event_interruptible</code> in a loop that re-tests the condition. The macro itself implements this loop, but if you manually manipulate wait queues with <code>prepare_to_wait</code>/<code>finish_wait</code>, you must loop.</li>\n</ul>\n<h4 id=\"-pitfall-missing-memory-barriers-in-lock-free-code\">⚠️ <strong>Pitfall: Missing Memory Barriers in Lock-Free Code</strong></h4>\n<ul>\n<li><strong>Description</strong>: Assuming that writes to shared variables are immediately visible to other CPUs without explicit memory ordering directives.</li>\n<li><strong>Why It&#39;s Wrong</strong>: Modern CPUs reorder memory operations for performance. Without proper barriers, one CPU might see stale data even after a lock is released, leading to race conditions.</li>\n<li><strong>Fix</strong>: When using locks (mutex/spinlock), the lock/unlock operations include implicit memory barriers. <strong>Do not attempt lock-free programming</strong> in this learning driver; always use the provided synchronization primitives.</li>\n</ul>\n<h4 id=\"-pitfall-incorrect-poll-mask-return\">⚠️ <strong>Pitfall: Incorrect Poll Mask Return</strong></h4>\n<ul>\n<li><strong>Description</strong>: The <code>poll</code> file operation returns the wrong event mask bits (e.g., returning <code>POLLIN</code> when the buffer is empty) or forgetting to call <code>poll_wait</code>.</li>\n<li><strong>Why It&#39;s Wrong</strong>: Userspace <code>select()</code>/<code>poll()</code> calls will report incorrect readiness, causing busy-waiting or missing available data. Forgetting <code>poll_wait</code> means the driver won&#39;t wake up the waiting process when conditions change.</li>\n<li><strong>Fix</strong>: Return <code>POLLIN | POLLRDNORM</code> only when <code>data_size &gt; 0</code>. Return <code>POLLOUT | POLLWRNORM</code> only when there&#39;s free space (<code>buffer_size - data_size &gt; 0</code>). Always call <code>poll_wait(file, &amp;dev-&gt;waitq, wait)</code> to register the wait queue.</li>\n</ul>\n<h4 id=\"-pitfall-priority-inversion-in-lock-usage\">⚠️ <strong>Pitfall: Priority Inversion in Lock Usage</strong></h4>\n<ul>\n<li><strong>Description</strong>: A high-priority process waiting for a mutex held by a low-priority process that itself isn&#39;t scheduled due to CPU contention.</li>\n<li><strong>Why It&#39;s Wrong</strong>: In real-time systems, this can cause deadlines to be missed. While less critical for our simple driver, it&#39;s a fundamental concurrency design flaw.</li>\n<li><strong>Fix</strong>: The Linux mutex implementation uses priority inheritance (<code>CONFIG_RT_MUTEXES</code>) to mitigate this automatically. For our purposes, just keep critical sections short to minimize hold time.</li>\n</ul>\n<p>The diagram <img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiagram-sys-component.svg\" alt=\"System Component Diagram\"> shows the Synchronization Manager&#39;s position between the Character Device Core and the I/O Buffer, intercepting all access attempts to enforce safe concurrency.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Exclusive Lock</strong></td>\n<td><code>struct mutex</code> with <code>mutex_lock()</code>/<code>mutex_unlock()</code></td>\n<td><code>struct rw_semaphore</code> for reader/writer differentiation</td>\n</tr>\n<tr>\n<td><strong>Blocking I/O</strong></td>\n<td><code>wait_event_interruptible()</code> with a single wait queue</td>\n<td>Multiple wait queues for readers and writers separately</td>\n</tr>\n<tr>\n<td><strong>Poll/Select</strong></td>\n<td>Implement <code>.poll</code> in <code>file_operations</code> returning simple masks</td>\n<td>Full <code>epoll</code> support with <code>struct file_operations</code> <code>.poll</code> and <code>.release</code> that manages epoll contexts</td>\n</tr>\n<tr>\n<td><strong>Concurrency Testing</strong></td>\n<td>Shell script with background <code>dd</code> processes</td>\n<td>Custom userspace stress test with <code>pthreads</code> and fault injection</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<p>The concurrency components are integrated into the existing driver files:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project/\n├── mychardev.c          # Main driver (add mutex, waitq, poll here)\n├── mychardev.h          # Shared header (ioctl commands, struct definitions)\n├── Makefile             # Kbuild Makefile\n└── test_concurrent.c    # Userspace test program for Milestone 4</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p>First, update the <code>struct mydevice_data</code> in <code>mychardev.h</code> to include synchronization fields:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In mychardev.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> MYCHARDEV_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYCHARDEV_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/ioctl.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOC_MAGIC</span><span style=\"color:#9ECBFF\"> 'k'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOCTL_GET_SIZE</span><span style=\"color:#B392F0\"> _IOR</span><span style=\"color:#E1E4E8\">(MYDEVICE_IOC_MAGIC, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOCTL_GET_MAX_CAPACITY</span><span style=\"color:#B392F0\"> _IOR</span><span style=\"color:#E1E4E8\">(MYDEVICE_IOC_MAGIC, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOCTL_CLEAR</span><span style=\"color:#B392F0\"> _IO</span><span style=\"color:#E1E4E8\">(MYDEVICE_IOC_MAGIC, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MYDEVICE_IOCTL_RESIZE</span><span style=\"color:#B392F0\"> _IOW</span><span style=\"color:#E1E4E8\">(MYDEVICE_IOC_MAGIC, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEVICE_NAME</span><span style=\"color:#9ECBFF\"> \"mychardev\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BUFFER_SIZE</span><span style=\"color:#79B8FF\"> 1024</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_BUFFER_SIZE</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\"> // 1 MiB</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#FDAEB7;font-style:italic\">#endif</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In mychardev.c - updated struct definition</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydevice_data {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    dev_t</span><span style=\"color:#E1E4E8\"> dev_num;</span><span style=\"color:#6A737D\">                 // Device number (major+minor)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> cdev cdev;</span><span style=\"color:#6A737D\">              // Character device structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> class </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">dev_class;</span><span style=\"color:#6A737D\">       // Device class for /dev/node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> device </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">device;</span><span style=\"color:#6A737D\">         // Device instance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Buffer and data management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">buffer;</span><span style=\"color:#6A737D\">                  // Linear buffer for data storage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> buffer_size;</span><span style=\"color:#6A737D\">            // Total capacity of buffer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> data_size;</span><span style=\"color:#6A737D\">              // Current amount of data in buffer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // CONCURRENCY FIELDS (Milestone 4)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> mutex lock;</span><span style=\"color:#6A737D\">             // Mutex for buffer protection</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    wait_queue_head_t</span><span style=\"color:#E1E4E8\"> waitq;</span><span style=\"color:#6A737D\">       // Wait queue for blocking read</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>1. Initializing Synchronization Primitives in <code>mydevice_init()</code>:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> __init </span><span style=\"color:#B392F0\">mydevice_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">dev;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> err;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... existing allocation and device registration code ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize buffer (existing)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> buffer_init</span><span style=\"color:#E1E4E8\">(dev, BUFFER_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (err) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // cleanup...</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // MILESTONE 4: Initialize synchronization primitives</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev->lock);</span><span style=\"color:#6A737D\">                    // Initialize mutex</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    init_waitqueue_head</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev->waitq);</span><span style=\"color:#6A737D\">          // Initialize wait queue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO DEVICE_NAME </span><span style=\"color:#9ECBFF\">\": module loaded with mutex and waitq</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>2. Updated <code>mydevice_write()</code> with Mutex Protection:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydevice_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                              size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">loff_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">f_pos</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">dev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> filp->private_data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // MILESTONE 4: Protect buffer access with mutex</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev->lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if buffer has enough space</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (dev->data_size </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> dev->buffer_size) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // No space - truncate write to available space</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        count </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> dev->buffer_size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> dev->data_size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (count </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOSPC;</span><span style=\"color:#6A737D\">  // Buffer full</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            goto</span><span style=\"color:#E1E4E8\"> out_unlock;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Copy data from userspace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">copy_from_user</span><span style=\"color:#E1E4E8\">(dev->buffer </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> dev->data_size, buf, count)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> out_unlock;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update buffer state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dev->data_size </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> count;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> count;</span><span style=\"color:#6A737D\">  // Return number of bytes written</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // MILESTONE 4: Wake up any readers waiting for data</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    wake_up_interruptible</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev->waitq);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">out_unlock:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev->lock);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> retval;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>3. Blocking <code>mydevice_read()</code> with Wait Queue:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydevice_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                             size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">loff_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">f_pos</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">dev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> filp->private_data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // MILESTONE 4: Wait for data to become available (interruptible sleep)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This loop handles spurious wakeups by re-checking condition</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">wait_event_interruptible</span><span style=\"color:#E1E4E8\">(dev->waitq, dev->data_size </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Interrupted by signal before data arrived</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ERESTARTSYS;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev->lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read at most the available data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (count </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> dev->data_size) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        count </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> dev->data_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Copy data to userspace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">copy_to_user</span><span style=\"color:#E1E4E8\">(buf, dev->buffer, count)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> out_unlock;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remove read data from buffer (simple linear buffer - shift remaining data)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Move remaining data to the front of the buffer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // memmove(dev->buffer, dev->buffer + count, dev->data_size - count);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Update data_size after the read</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // dev->data_size -= count;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> count;</span><span style=\"color:#6A737D\">  // Return number of bytes read</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">out_unlock:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev->lock);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> retval;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>4. Implementing the <code>poll</code> File Operation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> __poll_t</span><span style=\"color:#B392F0\"> mydevice_poll</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, poll_table </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">wait</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">dev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> filp->private_data;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    __poll_t</span><span style=\"color:#E1E4E8\"> mask </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // MILESTONE 4: Register wait queue for poll notifications</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    poll_wait</span><span style=\"color:#E1E4E8\">(filp, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev->waitq, wait);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev->lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if data is available for reading</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // if (dev->data_size > 0) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     mask |= POLLIN | POLLRDNORM;  // Readable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if space is available for writing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // if (dev->data_size &#x3C; dev->buffer_size) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     mask |= POLLOUT | POLLWRNORM; // Writable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev->lock);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> mask;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>5. Updated <code>file_operations</code> Structure:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> file_operations fops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .owner </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> THIS_MODULE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .open </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_open,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .release </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_release,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .read </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_read,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .write </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_write,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .unlocked_ioctl </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_ioctl,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // MILESTONE 4: Add poll support</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .poll </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_poll,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>6. Concurrency-Aware <code>ioctl</code> Handler Updates:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> long</span><span style=\"color:#B392F0\"> mydevice_ioctl</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> int</span><span style=\"color:#FFAB70\"> cmd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> arg</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">dev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> filp->private_data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // MILESTONE 4: Protect ioctl operations with mutex</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev->lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> (cmd) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> MYDEVICE_IOCTL_GET_SIZE:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Copy dev->data_size to userspace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> MYDEVICE_IOCTL_CLEAR:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Clear buffer and wake up waiters if needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // dev->data_size = 0;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // wake_up_interruptible(&#x26;dev->waitq);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> MYDEVICE_IOCTL_RESIZE:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Call buffer_resize with mutex held</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // err = buffer_resize(dev, (size_t)arg);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            err </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOTTY;</span><span style=\"color:#6A737D\">  // Unknown ioctl command</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev->lock);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> err;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>7. Userspace Test Program for Concurrency (<code>test_concurrent.c</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;fcntl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/select.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;pthread.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEVICE_PATH</span><span style=\"color:#9ECBFF\"> \"/dev/mychardev\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">writer_thread</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(DEVICE_PATH, O_WRONLY);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"writer open\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#E1E4E8\"> msg</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"Hello from thread!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        write</span><span style=\"color:#E1E4E8\">(fd, msg, </span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(msg));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        usleep</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100000</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\"> // 100ms between writes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">reader_thread</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(DEVICE_PATH, O_RDONLY);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"reader open\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> read</span><span style=\"color:#E1E4E8\">(fd, buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(buf)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            buf</span><span style=\"color:#E1E4E8\">[n] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Reader got: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, buf);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        usleep</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">150000</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\"> // 150ms between reads</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_t</span><span style=\"color:#FFAB70\"> writers</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#FFAB70\">readers</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create multiple writer and reader threads</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">writers</span><span style=\"color:#E1E4E8\">[i], </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, writer_thread, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">readers</span><span style=\"color:#E1E4E8\">[i], </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, reader_thread, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Wait for all threads</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_join</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">writers</span><span style=\"color:#E1E4E8\">[i], </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_join</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">readers</span><span style=\"color:#E1E4E8\">[i], </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Concurrency test completed.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ul>\n<li><strong>Mutex Initialization</strong>: Always initialize mutexes with <code>mutex_init()</code> before use. Static initialization is also possible with <code>DEFINE_MUTEX(mutexname)</code>.</li>\n<li><strong>Wait Queue Usage</strong>: Use <code>wait_event_interruptible()</code> for sleep that can be interrupted by signals (recommended). Use <code>wait_event()</code> for uninterruptible sleep (dangerous, can cause hung processes).</li>\n<li><strong>Poll Implementation</strong>: The <code>poll_table</code> pointer <code>wait</code> must be passed to <code>poll_wait()</code> even if you don&#39;t store it. This registers the wait queue with the poll mechanism.</li>\n<li><strong>Error Codes</strong>: Return <code>-ERESTARTSYS</code> when a wait is interrupted by a signal; the VFS will automatically restart the system call if appropriate.</li>\n<li><strong>Memory Ordering</strong>: When accessing shared variables outside locks (e.g., in <code>poll</code> before taking the lock), consider using <code>READ_ONCE()</code>/<code>WRITE_ONCE()</code> macros to prevent compiler optimizations from causing issues.</li>\n</ul>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing Milestone 4:</p>\n<ol>\n<li><strong>Compile and Load</strong>: <code>sudo insmod mychardev.ko</code></li>\n<li><strong>Check dmesg for initialization</strong>: <code>dmesg | tail</code> should show &quot;module loaded with mutex and waitq&quot;</li>\n<li><strong>Test blocking read</strong>: In one terminal: <code>sudo cat /dev/mychardev</code> (will block)</li>\n<li><strong>Test wakeup</strong>: In another terminal: <code>echo &quot;test&quot; | sudo tee /dev/mychardev</code><ul>\n<li>The <code>cat</code> should immediately output &quot;test&quot; and exit</li>\n</ul>\n</li>\n<li><strong>Test concurrent access</strong>: Compile and run the test program: <code>gcc -pthread test_concurrent.c -o test_concurrent &amp;&amp; sudo ./test_concurrent</code><ul>\n<li>Expected: No crashes, all threads complete, output shows interleaved reads and writes</li>\n</ul>\n</li>\n<li><strong>Test poll/select</strong>: Write a small program that uses <code>select()</code> on the device file descriptor<ul>\n<li>Should show readable when data is present, writable when space available</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>System hangs on <code>read()</code></strong></td>\n<td>Deadlock: mutex held but not released on error path</td>\n<td>Add <code>printk</code> before/after each <code>mutex_lock</code>/<code>mutex_unlock</code>; check for early returns without unlock</td>\n<td>Ensure all error paths release the mutex; use <code>goto</code> cleanup pattern</td>\n</tr>\n<tr>\n<td><strong><code>read()</code> returns 0 immediately even though no data</strong></td>\n<td>Wait queue not being used or condition not rechecked</td>\n<td>Check if <code>wait_event_interruptible</code> is called; add <code>printk</code> to see if read proceeds without waiting</td>\n<td>Ensure <code>wait_event_interruptible</code> surrounds the buffer-empty check</td>\n</tr>\n<tr>\n<td><strong>Multiple readers get same data repeatedly</strong></td>\n<td>Buffer not being cleared/advanced after read</td>\n<td>Check the buffer management in <code>mydevice_read</code>; data should be removed after copying to user</td>\n<td>Implement proper buffer shifting with <code>memmove</code></td>\n</tr>\n<tr>\n<td><strong><code>select()</code> always shows ready even when empty</strong></td>\n<td><code>poll</code> returning wrong mask bits</td>\n<td>Add <code>printk</code> in <code>mydevice_poll</code> showing mask calculation; check condition logic</td>\n<td>Ensure mask only includes <code>POLLIN</code> when <code>data_size &gt; 0</code></td>\n</tr>\n<tr>\n<td><strong>Writer threads starve</strong></td>\n<td>Readers hold mutex too long or buffer never fills</td>\n<td>Check critical section duration; add timing <code>printk</code> statements</td>\n<td>Shorten lock hold time; consider fairness or reader/writer locks</td>\n</tr>\n<tr>\n<td><strong>Module can&#39;t be unloaded (<code>rmmod</code> hangs)</strong></td>\n<td>Processes sleeping in wait queue holding reference</td>\n<td>Check <code>lsmod</code> for usage count; <code>sudo lsof /dev/mychardev</code> shows open handles</td>\n<td>Ensure all processes close device file; wait queue should be interruptible</td>\n</tr>\n</tbody></table>\n<p>The diagram <img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiagram-data-model.svg\" alt=\"Data Model and State Relationships\"> illustrates how the <code>lock</code> and <code>waitq</code> fields integrate into the <code>struct mydevice_data</code>, protecting access to the <code>buffer</code> and its metadata. The sequence diagram <img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiagram-seq-write-read.svg\" alt=\"Sequence Diagram: Write then Read\"> shows the precise flow of lock acquisition, buffer modification, wait queue wakeup, and lock release during concurrent operations.</p>\n<h2 id=\"interactions-and-data-flow\">Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2, Milestone 3, Milestone 4 (integration of all components into cohesive workflows)</p>\n</blockquote>\n<p>This section traces the concrete pathways through which userspace actions translate into kernel operations and how multiple processes interact safely with the device driver. Understanding these flows is critical for debugging and reasoning about the system&#39;s behavior under both normal and concurrent usage.</p>\n<h3 id=\"sequence-of-operations-from-user-command-to-kernel-action\">Sequence of Operations: From User Command to Kernel Action</h3>\n<p>Think of the driver as a <strong>well-trained receptionist in a government office</strong>. Userspace applications are citizens submitting forms (data) or requesting information. The receptionist follows a strict, documented procedure for each type of request: they validate the request, check internal records (the buffer), update logs (statistics), and provide a receipt (return value). Every citizen interaction follows a predictable sequence through different department desks (kernel subsystems).</p>\n<p>The following tables detail the step-by-step journeys for key operations, showing exactly which kernel functions are called in response to specific userspace commands.</p>\n<h4 id=\"module-loading-and-device-node-creation\">Module Loading and Device Node Creation</h4>\n<p>When an administrator runs <code>sudo insmod mychardev.ko</code>, the following sequence unfolds:</p>\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>Actor</th>\n<th>Action</th>\n<th>Kernel Function Called</th>\n<th>Key Data Structure Modified</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Userspace</td>\n<td>Execute <code>insmod</code> system call</td>\n<td><code>init_module()</code> (syscall)</td>\n<td>N/A</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Kernel</td>\n<td>Locate module file, validate headers</td>\n<td><code>load_module()</code></td>\n<td><code>struct module</code></td>\n</tr>\n<tr>\n<td>3</td>\n<td>Kernel</td>\n<td>Call module&#39;s initialization function</td>\n<td><code>mydevice_init()</code></td>\n<td>Global <code>struct mydevice_data dev_data</code></td>\n</tr>\n<tr>\n<td>4</td>\n<td>Driver</td>\n<td>Allocate device number range</td>\n<td><code>alloc_chrdev_region(&amp;dev_data.dev_num, ...)</code></td>\n<td><code>dev_data.dev_num</code></td>\n</tr>\n<tr>\n<td>5</td>\n<td>Driver</td>\n<td>Initialize character device</td>\n<td><code>cdev_init(&amp;dev_data.cdev, &amp;mydevice_fops)</code></td>\n<td><code>dev_data.cdev</code></td>\n</tr>\n<tr>\n<td>6</td>\n<td>Driver</td>\n<td>Add device to system</td>\n<td><code>cdev_add(&amp;dev_data.cdev, ...)</code></td>\n<td>VFS device table</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Driver</td>\n<td>Create device class</td>\n<td><code>class_create(THIS_MODULE, DEVICE_NAME)</code></td>\n<td><code>dev_data.dev_class</code></td>\n</tr>\n<tr>\n<td>8</td>\n<td>Driver</td>\n<td>Create <code>/dev</code> node</td>\n<td><code>device_create(dev_data.dev_class, ...)</code></td>\n<td><code>/dev/mychardev</code> inode</td>\n</tr>\n<tr>\n<td>9</td>\n<td>Driver</td>\n<td>Initialize synchronization</td>\n<td><code>mutex_init(&amp;dev_data.lock)</code>, <code>init_waitqueue_head(&amp;dev_data.waitq)</code></td>\n<td><code>dev_data.lock</code>, <code>dev_data.waitq</code></td>\n</tr>\n<tr>\n<td>10</td>\n<td>Driver</td>\n<td>Allocate buffer</td>\n<td><code>buffer_init(&amp;dev_data, BUFFER_SIZE)</code></td>\n<td><code>dev_data.buffer</code>, <code>dev_data.buffer_size</code></td>\n</tr>\n<tr>\n<td>11</td>\n<td>Kernel</td>\n<td>Return success to userspace</td>\n<td><code>printk(KERN_INFO &quot;mydevice: loaded&quot;)</code></td>\n<td>Kernel log</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight:</strong> Module loading is a <strong>one-time setup</strong> that establishes the infrastructure (device numbers, VFS registration, <code>/dev</code> node) that enables all future file operations. Failure at any step must trigger complete rollback of previous steps.</p>\n</blockquote>\n<h4 id=\"writing-data-to-the-device\">Writing Data to the Device</h4>\n<p>When a userspace program executes <code>echo &quot;Hello&quot; &gt; /dev/mychardev</code>, the following flow occurs:</p>\n<ol>\n<li><strong>System Call Entry</strong>: The <code>write()</code> system call is invoked with file descriptor pointing to <code>/dev/mychardev</code>, buffer containing &quot;Hello&quot;, and count of 5 bytes.</li>\n<li><strong>VFS Routing</strong>: The Virtual File System examines the inode&#39;s <code>file_operations</code> pointer and dispatches to <code>mydevice_write()</code>.</li>\n<li><strong>Parameter Validation</strong>: The driver checks that <code>count</code> doesn&#39;t exceed available buffer space (<code>dev_data.buffer_size - dev_data.data_size</code>).</li>\n<li><strong>Lock Acquisition</strong>: <code>mutex_lock(&amp;dev_data.lock)</code> is called to ensure exclusive access to the buffer.</li>\n<li><strong>Boundary Check</strong>: If buffer would overflow, returns <code>-ENOSPC</code> after releasing mutex.</li>\n<li><strong>Data Transfer</strong>: <code>copy_from_user(dev_data.buffer + dev_data.data_size, user_buf, count)</code> copies 5 bytes from userspace.</li>\n<li><strong>State Update</strong>: <code>dev_data.data_size</code> is incremented by 5.</li>\n<li><strong>Wake Sleepers</strong>: <code>wake_up_interruptible(&amp;dev_data.waitq)</code> alerts any processes blocked in <code>mydevice_read()</code>.</li>\n<li><strong>Lock Release</strong>: <code>mutex_unlock(&amp;dev_data.lock)</code> allows other operations to proceed.</li>\n<li><strong>Return to Userspace</strong>: Returns 5 (bytes written) to the <code>write()</code> system call.</li>\n</ol>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiagram-seq-write-read.svg\" alt=\"Sequence Diagram: Write then Read\"></p>\n<h4 id=\"reading-data-from-the-device-blocking\">Reading Data from the Device (Blocking)</h4>\n<p>When <code>cat /dev/mychardev</code> is executed and the buffer contains data:</p>\n<ol>\n<li><strong>System Call Entry</strong>: The <code>read()</code> system call is invoked with file descriptor, userspace buffer, and maximum count.</li>\n<li><strong>VFS Routing</strong>: Dispatched to <code>mydevice_read()</code> via <code>file_operations</code>.</li>\n<li><strong>Lock Acquisition</strong>: <code>mutex_lock(&amp;dev_data.lock)</code> for exclusive buffer access.</li>\n<li><strong>Data Availability Check</strong>: Since <code>dev_data.data_size &gt; 0</code>, proceed immediately.</li>\n<li><strong>Transfer Calculation</strong>: Determine transfer size as <code>min(count, dev_data.data_size)</code>.</li>\n<li><strong>Data Copy</strong>: <code>copy_to_user(user_buf, dev_data.buffer, transfer_size)</code> copies data to userspace.</li>\n<li><strong>Buffer Update</strong>: If partial read, remaining data is shifted with <code>memmove()</code> and <code>dev_data.data_size</code> is decremented.</li>\n<li><strong>Lock Release</strong>: <code>mutex_unlock(&amp;dev_data.lock)</code>.</li>\n<li><strong>Return</strong>: Returns number of bytes copied (e.g., 5).</li>\n</ol>\n<p>When the buffer is <strong>empty</strong> and a blocking read occurs:</p>\n<ol>\n<li>Steps 1-3 proceed identically.</li>\n<li><strong>Empty Buffer Detection</strong>: <code>dev_data.data_size == 0</code> triggers wait queue logic.</li>\n<li><strong>Sleep Preparation</strong>: <code>mutex_unlock(&amp;dev_data.lock)</code> is called (must release before sleeping).</li>\n<li><strong>Condition Wait</strong>: <code>wait_event_interruptible(dev_data.waitq, dev_data.data_size &gt; 0)</code> puts process to sleep.</li>\n<li><strong>Signal or Data Arrival</strong>: Process wakes either from signal (returns <code>-ERESTARTSYS</code>) or when writer calls <code>wake_up_interruptible()</code>.</li>\n<li><strong>Re-acquire Lock</strong>: Upon waking, <code>mutex_lock(&amp;dev_data.lock)</code> is called again.</li>\n<li><strong>Re-check Condition</strong>: Buffer is verified non-empty (protects against spurious wakeups).</li>\n<li><strong>Proceed with Transfer</strong>: Normal read operations continue from step 5 above.</li>\n</ol>\n<h4 id=\"ioctl-command-execution\">Ioctl Command Execution</h4>\n<p>When a userspace program calls <code>ioctl(fd, MYDEVICE_IOCTL_RESIZE, &amp;new_size)</code>:</p>\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>Action</th>\n<th>Key Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>System call entry with command number and argument</td>\n<td>VFS validates file descriptor</td>\n</tr>\n<tr>\n<td>2</td>\n<td>VFS routes to <code>mydevice_ioctl()</code></td>\n<td>Command number checked against supported set</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Driver validates <code>cmd</code> using <code>_IOC_TYPE()</code> macros</td>\n<td>Ensures magic number matches</td>\n</tr>\n<tr>\n<td>4</td>\n<td>For <code>MYDEVICE_IOCTL_RESIZE</code>: copy argument from userspace</td>\n<td><code>copy_from_user(&amp;size, arg, sizeof(size_t))</code></td>\n</tr>\n<tr>\n<td>5</td>\n<td>Acquire mutex: <code>mutex_lock(&amp;dev_data.lock)</code></td>\n<td>Prevent concurrent buffer modification</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Validate new size (1 ≤ size ≤ MAX_BUFFER_SIZE)</td>\n<td>Return <code>-EINVAL</code> if invalid</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Call <code>buffer_resize(&amp;dev_data, size)</code></td>\n<td>Allocates new buffer, copies old data, frees old</td>\n</tr>\n<tr>\n<td>8</td>\n<td>Release mutex: <code>mutex_unlock(&amp;dev_data.lock)</code></td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>Return 0 (success) or negative error code</td>\n<td>Error codes propagate to userspace <code>errno</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"concurrent-access-flow\">Concurrent Access Flow</h3>\n<p>Imagine the device as a <strong>single photocopier in a busy office</strong> with a formal queue system. The mutex is the &quot;in use&quot; sign on the copier door—only one person can use it at a time. The wait queue is the line of people waiting for documents to copy. When someone finishes (writer), they notify the next person in line (wake reader). When the paper tray is refilled (buffer resized via ioctl), the maintenance person must wait for the current user to finish.</p>\n<h4 id=\"concurrent-read-and-write-scenario\">Concurrent Read and Write Scenario</h4>\n<p>Consider two processes: Process A writing &quot;DataA&quot; and Process B reading simultaneously.</p>\n<p><strong>Initial State</strong>: Buffer empty, mutex unlocked.</p>\n<table>\n<thead>\n<tr>\n<th>Time</th>\n<th>Process A (Writer)</th>\n<th>Process B (Reader)</th>\n<th>Buffer State</th>\n<th>Mutex State</th>\n<th>Wait Queue</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>T1</td>\n<td>Calls <code>write()</code></td>\n<td>Calls <code>read()</code></td>\n<td>Empty</td>\n<td>Unlocked</td>\n<td>Empty</td>\n</tr>\n<tr>\n<td>T2</td>\n<td><code>mutex_lock()</code> succeeds</td>\n<td><code>mutex_lock()</code> blocks</td>\n<td>Empty</td>\n<td>Locked (A)</td>\n<td>Empty</td>\n</tr>\n<tr>\n<td>T3</td>\n<td><code>copy_from_user()</code> copies &quot;DataA&quot;</td>\n<td>Sleeps waiting for lock</td>\n<td>&quot;DataA&quot; (5B)</td>\n<td>Locked (A)</td>\n<td>Empty</td>\n</tr>\n<tr>\n<td>T4</td>\n<td>Updates <code>data_size=5</code></td>\n<td>Still sleeping</td>\n<td>&quot;DataA&quot; (5B)</td>\n<td>Locked (A)</td>\n<td>Empty</td>\n</tr>\n<tr>\n<td>T5</td>\n<td><code>wake_up_interruptible()</code></td>\n<td>Woken by wake-up</td>\n<td>&quot;DataA&quot; (5B)</td>\n<td>Locked (A)</td>\n<td>Wakes B</td>\n</tr>\n<tr>\n<td>T6</td>\n<td><code>mutex_unlock()</code></td>\n<td>Attempts <code>mutex_lock()</code></td>\n<td>&quot;DataA&quot; (5B)</td>\n<td>Unlocked</td>\n<td>Empty</td>\n</tr>\n<tr>\n<td>T7</td>\n<td>Returns success (5)</td>\n<td><code>mutex_lock()</code> succeeds</td>\n<td>&quot;DataA&quot; (5B)</td>\n<td>Locked (B)</td>\n<td>Empty</td>\n</tr>\n<tr>\n<td>T8</td>\n<td></td>\n<td><code>copy_to_user()</code> copies &quot;DataA&quot;</td>\n<td>&quot;DataA&quot; (5B)</td>\n<td>Locked (B)</td>\n<td>Empty</td>\n</tr>\n<tr>\n<td>T9</td>\n<td></td>\n<td>Updates <code>data_size=0</code></td>\n<td>Empty</td>\n<td>Locked (B)</td>\n<td>Empty</td>\n</tr>\n<tr>\n<td>T10</td>\n<td></td>\n<td><code>mutex_unlock()</code></td>\n<td>Empty</td>\n<td>Unlocked</td>\n<td>Empty</td>\n</tr>\n<tr>\n<td>T11</td>\n<td></td>\n<td>Returns 5 bytes</td>\n<td>Empty</td>\n<td>Unlocked</td>\n<td>Empty</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Synchronization Pattern:</strong> The writer releases the mutex <strong>before</strong> calling <code>wake_up_interruptible()</code>. This ensures the woken reader can immediately acquire the mutex without contention, reducing &quot;thundering herd&quot; effects.</p>\n</blockquote>\n<h4 id=\"multiple-readers-and-writers\">Multiple Readers and Writers</h4>\n<p>With three processes (Writer1, Writer2, Reader1) operating concurrently:</p>\n<p><strong>State Transition Table</strong>:</p>\n<table>\n<thead>\n<tr>\n<th>Event</th>\n<th>Triggering Process</th>\n<th>Buffer Before</th>\n<th>Mutex Holder</th>\n<th>Wait Queue</th>\n<th>Buffer After</th>\n<th>Action Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Writer1 <code>write(&quot;W1&quot;)</code></td>\n<td>Empty</td>\n<td>None</td>\n<td>Empty</td>\n<td>&quot;W1&quot;</td>\n<td>Locks mutex, writes, wakes queue (empty), unlocks</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Writer2 <code>write(&quot;W2&quot;)</code></td>\n<td>&quot;W1&quot;</td>\n<td>Writer2</td>\n<td>Empty</td>\n<td>&quot;W1W2&quot;</td>\n<td>Locks, writes, wakes, unlocks</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Reader1 <code>read()</code> (blocking)</td>\n<td>&quot;W1W2&quot;</td>\n<td>Reader1</td>\n<td>Empty</td>\n<td>&quot;&quot;</td>\n<td>Locks, reads both strings, wakes (none), unlocks</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Reader1 <code>read()</code> again</td>\n<td>Empty</td>\n<td>None</td>\n<td>Empty</td>\n<td>Empty</td>\n<td>Locks, sees empty, unlocks, sleeps on waitq</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Writer1 <code>write(&quot;New&quot;)</code></td>\n<td>Empty</td>\n<td>Writer1</td>\n<td>[Reader1]</td>\n<td>&quot;New&quot;</td>\n<td>Locks, writes, wakes Reader1, unlocks</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Reader1 (woken)</td>\n<td>&quot;New&quot;</td>\n<td>Reader1</td>\n<td>Empty</td>\n<td>Empty</td>\n<td>Re-acquires lock, reads, unlocks</td>\n</tr>\n</tbody></table>\n<p><strong>Priority Inversion Avoidance</strong>: Since <code>mutex_lock()</code> doesn&#39;t implement priority inheritance in all kernel configurations, a high-priority reader could be blocked by a low-priority writer holding the mutex. Our simple driver accepts this limitation, but production drivers might use <code>mutex_lock_interruptible()</code> with careful signal handling.</p>\n<h4 id=\"pollselect-operation-flow\">Poll/Select Operation Flow</h4>\n<p>When a userspace program calls <code>poll()</code> or <code>select()</code> on the device file descriptor:</p>\n<ol>\n<li><strong>System Call Entry</strong>: <code>poll()</code> system call invoked with file descriptor and events mask.</li>\n<li><strong>VFS Routing</strong>: Dispatched to <code>mydevice_poll()</code> via <code>file_operations</code>.</li>\n<li><strong>Wait Registration</strong>: <code>poll_wait(file, &amp;dev_data.waitq, wait)</code> adds the process to the device&#39;s wait queue for future notifications.</li>\n<li><strong>Event Mask Calculation</strong>:<ul>\n<li>If <code>dev_data.data_size &gt; 0</code>: set <code>mask |= POLLIN | POLLRDNORM</code> (readable)</li>\n<li>If <code>dev_data.data_size &lt; dev_data.buffer_size</code>: set <code>mask |= POLLOUT | POLLWRNORM</code> (writable)</li>\n</ul>\n</li>\n<li><strong>Return Mask</strong>: Immediate return of event mask—<strong>does not sleep</strong>.</li>\n<li><strong>Later Wake-up</strong>: When a writer adds data, <code>wake_up_interruptible(&amp;dev_data.waitq)</code> wakes all processes registered via <code>poll_wait()</code>.</li>\n<li><strong>Re-evaluation</strong>: The <code>poll()</code> system call re-invokes <code>mydevice_poll()</code> for woken processes, which now returns updated mask.</li>\n</ol>\n<p><strong>Key Difference from Blocking Read</strong>: <code>poll()</code> never sleeps in the driver; it only registers interest. The actual sleeping happens in the <code>poll()</code> system call implementation, which waits for <strong>any</strong> of the monitored file descriptors to become ready.</p>\n<h4 id=\"proc-filesystem-read-operation\">Proc Filesystem Read Operation</h4>\n<p>When a user reads <code>/proc/mychardev_stats</code>:</p>\n<ol>\n<li><strong>File Open</strong>: VFS calls <code>mydevice_proc_open()</code>, which calls <code>single_open()</code> with <code>mydevice_proc_show</code> as callback.</li>\n<li><strong>Read Request</strong>: For each read chunk, VFS calls <code>seq_read()</code> (via <code>proc_ops</code>).</li>\n<li><strong>Callback Invocation</strong>: <code>mydevice_proc_show()</code> is called with seq_file context.</li>\n<li><strong>Data Collection</strong> (under mutex protection):<ul>\n<li><code>mutex_lock(&amp;dev_data.lock)</code></li>\n<li>Capture: <code>data_size</code>, <code>buffer_size</code>, read/write statistics</li>\n<li><code>mutex_unlock(&amp;dev_data.lock)</code></li>\n</ul>\n</li>\n<li><strong>Formatting</strong>: <code>seq_printf(m, &quot;Buffer: %zu/%zu bytes\\n&quot;, data_size, buffer_size)</code></li>\n<li><strong>Iteration</strong>: <code>single_open()</code> automatically handles partial reads and file offsets.</li>\n<li><strong>Completion</strong>: Returns 0 when all data is output.</li>\n</ol>\n<blockquote>\n<p><strong>Design Insight:</strong> The <code>/proc</code> interface uses a <strong>read-once snapshot</strong> model. Concurrent modifications during read may show slightly inconsistent statistics, but each individual read returns a self-consistent snapshot taken under mutex protection.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Sequence Tracing</td>\n<td><code>printk()</code> at function entry/exit</td>\n<td>Dynamic debug (<code>dynamic_debug.ko</code>) with conditional compilation</td>\n</tr>\n<tr>\n<td>Concurrency Testing</td>\n<td>Manual shell scripts with <code>dd</code> and <code>&amp;</code></td>\n<td>Kernel thread stress test using <code>kthread_create()</code></td>\n</tr>\n<tr>\n<td>Flow Visualization</td>\n<td>Manual diagramming</td>\n<td>SystemTap or BPF tracing for actual flow observation</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  Makefile                    # Kbuild makefile\n  mychardev.c                 # Main driver implementation (all components)\n  mychardev.h                 # Shared ioctl definitions (userspace + kernel)\n  test_mychardev.c            # Userspace test program\n  scripts/\n    stress_test.sh            # Concurrent access stress test</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>Complete Userspace Test Program Skeleton</strong> (to be placed in <code>test_mychardev.c</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;fcntl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/ioctl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"mychardev.h\"</span><span style=\"color:#6A737D\">  // Shared header with ioctl definitions</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> **</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/dev/mychardev\"</span><span style=\"color:#E1E4E8\">, O_RDWR);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"open\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test write</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">msg </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"Test message\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> written </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> write</span><span style=\"color:#E1E4E8\">(fd, msg, </span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(msg));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Write returned: </span><span style=\"color:#79B8FF\">%zd\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, written);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test read</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> read_bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> read</span><span style=\"color:#E1E4E8\">(fd, buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(buf));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Read returned: </span><span style=\"color:#79B8FF\">%zd\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, read_bytes);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (read_bytes </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        buf</span><span style=\"color:#E1E4E8\">[read_bytes] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Data: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, buf);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test ioctl</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> current_size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ioctl</span><span style=\"color:#E1E4E8\">(fd, MYDEVICE_IOCTL_GET_SIZE, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">current_size) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Current buffer size: </span><span style=\"color:#79B8FF\">%zu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, current_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>Flow Tracing Helper Function</strong> (to add to driver for debugging):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Add to mychardev.c for debugging data flows</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifdef</span><span style=\"color:#B392F0\"> DEBUG_FLOWS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FLOW_TRACE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...) </span><span style=\"color:#B392F0\">printk</span><span style=\"color:#E1E4E8\">(KERN_DEBUG </span><span style=\"color:#9ECBFF\">\"FLOW </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: \"</span><span style=\"color:#E1E4E8\"> fmt, __func__, ##</span><span style=\"color:#B392F0\">__VA_ARGS__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#else</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FLOW_TRACE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...) </span><span style=\"color:#F97583\">do</span><span style=\"color:#E1E4E8\"> {} </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Example usage in mydevice_write:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydevice_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                              size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">loff_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">f_pos</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    FLOW_TRACE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ENTER: count=</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\">, pos=</span><span style=\"color:#79B8FF\">%lld\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, count, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">f_pos);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate parameters (count > 0, buf not NULL)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Acquire mutex with mutex_lock(&#x26;dev_data.lock)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Calculate available space: avail = buffer_size - data_size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If count > avail, release mutex and return -ENOSPC</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Copy data with copy_from_user(dev_data.buffer + data_size, buf, count)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Check copy_from_user return value; if error, release mutex and return -EFAULT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Update data_size += actual_copied</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Release mutex with mutex_unlock(&#x26;dev_data.lock)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Wake any waiting readers: wake_up_interruptible(&#x26;dev_data.waitq)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Return number of bytes actually written</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    FLOW_TRACE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"EXIT: returning </span><span style=\"color:#79B8FF\">%zd\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, retval);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> retval;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ol>\n<li><strong>Flow Control</strong>: Use <code>switch</code> statements in <code>mydevice_ioctl()</code> for command dispatch, not <code>if-else</code> chains.</li>\n<li><strong>Error Propagation</strong>: Always return negative error codes (e.g., <code>-EINVAL</code>) from kernel functions; VFS converts these to <code>-1</code> with appropriate <code>errno</code> in userspace.</li>\n<li><strong>Concurrency Primitives</strong>: Remember <code>mutex_lock()</code> can sleep; never call it in interrupt context or with spinlocks held.</li>\n<li><strong>Wait Queue Pattern</strong>: The standard pattern is:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">lock</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   wait_event_interruptible</span><span style=\"color:#E1E4E8\">(waitq, condition);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">lock</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing all flows, test with:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Load module</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> insmod</span><span style=\"color:#9ECBFF\"> mychardev.ko</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dmesg</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tail</span><span style=\"color:#6A737D\">  # Should show initialization messages</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test write-read flow</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Test123\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/mychardev</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /dev/mychardev</span><span style=\"color:#6A737D\">  # Should output \"Test123\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test concurrent access</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">bash</span><span style=\"color:#9ECBFF\"> scripts/stress_test.sh</span><span style=\"color:#6A737D\">  # Should run without hangs or corruption</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check /proc interface</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/mychardev_stats</span><span style=\"color:#6A737D\">  # Should show buffer statistics</span></span></code></pre></div>\n\n<p><strong>Expected Output in dmesg</strong> (with <code>DEBUG_FLOWS</code> enabled):</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[ 1234.567890] FLOW mydevice_write: ENTER: count=7, pos=0\n[ 1234.567891] FLOW mydevice_write: EXIT: returning 7\n[ 1234.567892] FLOW mydevice_read: ENTER: count=4096, pos=0\n[ 1234.567893] FLOW mydevice_read: EXIT: returning 7</code></pre></div>\n\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Write hangs forever</td>\n<td>Mutex deadlock (forgot unlock in error path)</td>\n<td>Add <code>printk()</code> before/after each lock operation</td>\n<td>Ensure every error path has <code>mutex_unlock()</code></td>\n</tr>\n<tr>\n<td>Read returns 0 immediately when data exists</td>\n<td><code>copy_to_user()</code> failing</td>\n<td>Check return value of <code>copy_to_user()</code></td>\n<td>Validate userspace buffer is writable</td>\n</tr>\n<tr>\n<td>Multiple readers get same data</td>\n<td>Not advancing buffer pointer after read</td>\n<td>Check buffer management after successful read</td>\n<td>Update buffer state (shift data or update pointer)</td>\n</tr>\n<tr>\n<td><code>poll()</code> returns immediately even when no data</td>\n<td>Not calling <code>poll_wait()</code></td>\n<td>Verify <code>mydevice_poll()</code> calls <code>poll_wait(file, &amp;dev_data.waitq, wait)</code></td>\n<td>Add missing <code>poll_wait()</code> call</td>\n</tr>\n<tr>\n<td>Concurrent write/read causes corruption</td>\n<td>Missing mutex in resize operation</td>\n<td>Check <code>buffer_resize()</code> is called under mutex</td>\n<td>Acquire mutex before <code>buffer_resize()</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2, Milestone 3, Milestone 4 (error handling spans all user-facing operations and concurrency scenarios)</p>\n</blockquote>\n<p>This section defines how the driver detects, reports, and recovers from failures and unusual conditions. In kernel programming, robust error handling is critical—a single unchecked error can crash the entire system, corrupt data, or create security vulnerabilities. Unlike user-space applications where crashes are contained, kernel failures have system-wide consequences.</p>\n<h3 id=\"error-detection-and-recovery-strategy\">Error Detection and Recovery Strategy</h3>\n<blockquote>\n<p><strong>Mental Model: The Defensive Guard at the Bridge</strong><br>Think of the kernel as a secure fortress with bridges (system calls) connecting it to userland. Our driver is a guard stationed at one bridge. A good guard must: (1) <strong>inspect every traveler</strong> (validate all inputs), (2) <strong>have clear protocols</strong> (consistent error codes) for turning away problematic travelers, and (3) <strong>clean up after disturbances</strong> (release resources) without abandoning their post or damaging the bridge. The guard never assumes travelers are well-behaved—they actively verify credentials and intentions before allowing passage.</p>\n</blockquote>\n<p>Our error handling philosophy follows three core principles:</p>\n<ol>\n<li><p><strong>Fail Fast During Initialization</strong>: If the driver cannot acquire essential resources (memory, device numbers) during module loading, it must clean up any partially acquired resources and refuse to load, returning an appropriate error code to <code>insmod</code>. A partially initialized driver in the kernel is dangerous.</p>\n</li>\n<li><p><strong>Propagate Meaningful Errors to User-Space</strong>: When a system call (read, write, ioctl) fails, the driver must return a negative error code that the Virtual File System (VFS) translates into a standard <code>errno</code> value (like <code>-ENOMEM</code> for out-of-memory). User-space applications see these as <code>errno</code> values (positive after <code>-</code> sign inversion) and can respond appropriately.</p>\n</li>\n<li><p><strong>Maintain Internal Consistency</strong>: Even when operations fail, the driver must leave its internal data structures in a consistent state. This typically involves careful ordering of operations and proper cleanup in error paths using <code>goto</code> labels—a common kernel pattern for rolling back multi-step initialization.</p>\n</li>\n</ol>\n<p>The table below maps common failure scenarios to their detection methods and recovery actions:</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Method</th>\n<th>Recovery Action</th>\n<th>Error Propagation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory allocation failure (kmalloc)</td>\n<td><code>kmalloc</code> returns <code>NULL</code></td>\n<td>Return <code>-ENOMEM</code>; release any locks held before returning</td>\n<td>To caller (user-space gets <code>errno=12</code>)</td>\n</tr>\n<tr>\n<td>Invalid user-space pointer</td>\n<td><code>copy_from_user</code>/<code>copy_to_user</code> returns non-zero (bytes not copied)</td>\n<td>Return <code>-EFAULT</code>; no data corruption occurs</td>\n<td>To caller (user-space gets <code>errno=14</code>)</td>\n</tr>\n<tr>\n<td>Buffer full during write</td>\n<td>Check <code>dev-&gt;data_size == dev-&gt;buffer_size</code></td>\n<td>Return <code>-ENOSPC</code> (no space left)</td>\n<td>To caller (user-space gets <code>errno=28</code>)</td>\n</tr>\n<tr>\n<td>Buffer empty during read</td>\n<td>Check <code>dev-&gt;data_size == 0</code></td>\n<td>Block (if O_NONBLOCK not set) or return <code>-EAGAIN</code></td>\n<td>To caller (user-space gets <code>errno=11</code> if non-blocking)</td>\n</tr>\n<tr>\n<td>Invalid ioctl command</td>\n<td>Switch statement default case</td>\n<td>Return <code>-ENOTTY</code> (not a typewriter)</td>\n<td>To caller (user-space gets <code>errno=25</code>)</td>\n</tr>\n<tr>\n<td>Signal interruption while sleeping</td>\n<td><code>wait_event_interruptible</code> returns non-zero</td>\n<td>Return <code>-ERESTARTSYS</code> (system call should be restarted)</td>\n<td>To VFS, which may restart the call</td>\n</tr>\n<tr>\n<td>Concurrent removal during operation</td>\n<td>Check device state flag after acquiring lock</td>\n<td>Return <code>-ENODEV</code> (no such device)</td>\n<td>To caller (user-space gets <code>errno=19</code>)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Defensive Validation Over Optimistic Assumptions</strong></p>\n<ul>\n<li><strong>Context</strong>: Kernel code must assume user-space data and behavior can be malicious or buggy. We need to decide how thoroughly to validate inputs.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Minimal validation</strong>: Trust that userspace follows documented behavior, checking only critical safety issues (pointer validity).</li>\n<li><strong>Comprehensive validation</strong>: Check all parameters for bounds, alignment, and semantic correctness before any side effects.</li>\n<li><strong>Layered validation</strong>: Validate safety-critical issues immediately (pointers), defer semantic checks (buffer sizes) until after acquiring locks.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use layered validation (option 3).</li>\n<li><strong>Rationale</strong>: Safety must come first—invalid pointers can crash the kernel, so they&#39;re checked before any operation. Semantic checks (like buffer bounds) happen after acquiring the mutex to avoid TOCTOU (Time-Of-Check-Time-Of-Use) races. This balances safety with performance.</li>\n<li><strong>Consequences</strong>: Slightly more complex code flow but prevents both security vulnerabilities and race conditions. The mutex acquisition might fail if the device is being removed, which we also handle.</li>\n</ul>\n</blockquote>\n<h3 id=\"specific-edge-cases-and-handling\">Specific Edge Cases and Handling</h3>\n<h4 id=\"1-buffer-full-and-empty-conditions\">1. Buffer Full and Empty Conditions</h4>\n<p>The driver&#39;s linear buffer has three fundamental states, as shown in the state diagram:</p>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiagram-state-buffer.svg\" alt=\"State Machine: Device Buffer\"></p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Event</th>\n<th>Next State</th>\n<th>Actions Taken</th>\n<th>Error Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>EMPTY</td>\n<td>Write request with <code>count &gt; 0</code></td>\n<td>PARTIALLY_FILLED</td>\n<td>Copy data, update <code>data_size</code>, wake waiters</td>\n<td>If <code>count &gt; buffer_size</code>: copy only <code>buffer_size</code> bytes, return <code>-ENOSPC</code></td>\n</tr>\n<tr>\n<td>EMPTY</td>\n<td>Read request</td>\n<td>EMPTY</td>\n<td>Return <code>0</code> (EOF) if non-blocking; block if O_NONBLOCK not set</td>\n<td>If O_NONBLOCK set: return <code>-EAGAIN</code></td>\n</tr>\n<tr>\n<td>PARTIALLY_FILLED</td>\n<td>Write request</td>\n<td>PARTIALLY_FILLED or FULL</td>\n<td>Copy available space, update <code>data_size</code></td>\n<td>If remaining space &lt; <code>count</code>: copy partial, return bytes copied (not error)</td>\n</tr>\n<tr>\n<td>PARTIALLY_FILLED</td>\n<td>Read request</td>\n<td>PARTIALLY_FILLED or EMPTY</td>\n<td>Copy available data, shift remaining data, update <code>data_size</code></td>\n<td>Always succeeds (returns bytes read)</td>\n</tr>\n<tr>\n<td>FULL</td>\n<td>Write request</td>\n<td>FULL</td>\n<td>Return <code>-ENOSPC</code> immediately</td>\n<td>Check O_NONBLOCK: same behavior (error)</td>\n</tr>\n<tr>\n<td>FULL</td>\n<td>Read request</td>\n<td>PARTIALLY_FILLED</td>\n<td>Copy data, shift remaining, update <code>data_size</code>, wake waiters</td>\n<td>Always succeeds</td>\n</tr>\n</tbody></table>\n<p>The key insight: <strong>write operations may perform partial transfers</strong> when the buffer is nearly full. The driver copies as much as fits, returns the number of bytes actually written (not an error), and lets user-space retry with remaining data if needed. This follows Unix convention (like writing to a pipe).</p>\n<h4 id=\"2-invalid-ioctl-commands-and-arguments\">2. Invalid ioctl Commands and Arguments</h4>\n<p>The <code>ioctl</code> interface is particularly vulnerable to invalid inputs because it bypasses standard VFS validation. Our dispatch logic follows this flowchart:</p>\n<p><img src=\"/api/project/build-kernel-module/architecture-doc/asset?path=diagrams%2Fdiagram-flow-ioctl.svg\" alt=\"Flowchart: Ioctl Command Dispatch\"></p>\n<p>Specific edge cases:</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case</th>\n<th>Detection</th>\n<th>Handling</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unknown command number</td>\n<td>Switch default case</td>\n<td>Return <code>-ENOTTY</code></td>\n<td>Standard Linux convention for invalid ioctl</td>\n</tr>\n<tr>\n<td>Invalid buffer size (0 or &gt;MAX_BUFFER_SIZE)</td>\n<td>Check in <code>MYDEVICE_IOCTL_RESIZE</code> handler</td>\n<td>Return <code>-EINVAL</code></td>\n<td>Prevents degenerate allocations</td>\n</tr>\n<tr>\n<td>Misaligned or invalid user pointer for _IOR/_IOWR</td>\n<td><code>copy_to_user</code> fails</td>\n<td>Return <code>-EFAULT</code></td>\n<td>Same protection as read/write</td>\n</tr>\n<tr>\n<td>Size mismatch between command definition and actual argument</td>\n<td>Compile-time checking via <code>_IOR</code> macros</td>\n<td>N/A (compile-time)</td>\n<td>Type safety through kernel macros</td>\n</tr>\n</tbody></table>\n<h4 id=\"3-process-termination-while-sleeping-on-wait-queue\">3. Process Termination While Sleeping on Wait Queue</h4>\n<p>When a process calls <code>read()</code> on an empty buffer with blocking enabled, it sleeps in <code>wait_event_interruptible</code>. If the process receives a fatal signal (SIGKILL) or is terminated:</p>\n<ol>\n<li><strong>Detection</strong>: <code>wait_event_interruptible</code> returns <code>-ERESTARTSYS</code> if interrupted by any signal.</li>\n<li><strong>Handling</strong>: The <code>mydevice_read</code> function checks the return value:<ul>\n<li>If <code>-ERESTARTSYS</code>: Return that value to VFS</li>\n<li>VFS will then check if the signal should restart the system call or return <code>-EINTR</code> to user-space</li>\n</ul>\n</li>\n<li><strong>Cleanup</strong>: The wait queue mechanism automatically removes the process from the queue when it wakes up (by signal or data arrival).</li>\n</ol>\n<blockquote>\n<p><strong>Critical Insight</strong>: The condition in <code>wait_event_interruptible(dev-&gt;waitq, dev-&gt;data_size &gt; 0)</code> MUST be rechecked after waking, because <strong>spurious wakeups</strong> can occur (kernel scheduler may wake processes for other reasons). Our implementation loops: <code>while (dev-&gt;data_size == 0) { wait_event_interruptible(...); }</code>.</p>\n</blockquote>\n<h4 id=\"4-concurrent-module-removal-during-operations\">4. Concurrent Module Removal During Operations</h4>\n<p>A rare but critical scenario: <code>rmmod</code> is called while user-space processes have the device file open and are actively reading/writing.</p>\n<ol>\n<li><strong>Detection</strong>: The module exit function sets a &quot;shutting down&quot; flag and waits for operations to complete.</li>\n<li><strong>Handling in Operations</strong>: Each handler function checks the flag after acquiring the mutex:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">lock</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   if</span><span style=\"color:#E1E4E8\"> (dev</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">is_shutting_down) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">       mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev->lock);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENODEV;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n<ol start=\"3\">\n<li><strong>Cleanup Coordination</strong>: The <code>mydevice_exit</code> function:<ul>\n<li>Sets <code>is_shutting_down = true</code></li>\n<li>Calls <code>synchronize_rcu()</code> to wait for existing readers</li>\n<li>Acquires mutex to ensure no new operations start</li>\n<li>Releases all resources</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"5-pollselect-with-multiple-events\">5. Poll/Select with Multiple Events</h4>\n<p>The <code>poll</code> handler must correctly report which events are possible:</p>\n<table>\n<thead>\n<tr>\n<th>Event Condition</th>\n<th>Reported Mask</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Data available for reading (<code>dev-&gt;data_size &gt; 0</code>)</td>\n<td>`POLLIN</td>\n<td>POLLRDNORM`</td>\n</tr>\n<tr>\n<td>Space available for writing (<code>dev-&gt;data_size &lt; dev-&gt;buffer_size</code>)</td>\n<td>`POLLOUT</td>\n<td>POLLWRNORM`</td>\n</tr>\n<tr>\n<td>Device in error state (should not happen)</td>\n<td><code>POLLERR</code></td>\n<td>Not used in our simple driver</td>\n</tr>\n<tr>\n<td>Device hung up (removed)</td>\n<td><code>POLLHUP</code></td>\n<td>Set if <code>dev-&gt;is_shutting_down</code> is true</td>\n</tr>\n</tbody></table>\n<p><strong>Edge Case</strong>: What if both read and write are possible? The handler must return <code>POLLIN | POLLOUT</code>. The kernel <code>poll</code> implementation combines multiple wait queues correctly.</p>\n<h4 id=\"6-memory-allocation-failure-during-buffer-resize\">6. Memory Allocation Failure During Buffer Resize</h4>\n<p>When handling <code>MYDEVICE_IOCTL_RESIZE</code>:</p>\n<ol>\n<li><strong>Strategy</strong>: Allocate new buffer before freeing old (if allocation fails, original data preserved).</li>\n<li><strong>Steps</strong>:<ol>\n<li>Validate requested size</li>\n<li><code>kmalloc</code> new buffer (with <code>GFP_KERNEL</code>)</li>\n<li>If <code>NULL</code>, return <code>-ENOMEM</code></li>\n<li>Acquire mutex, copy old data (up to min(old_size, new_size))</li>\n<li>Free old buffer, update pointer and size</li>\n<li>Release mutex</li>\n</ol>\n</li>\n<li><strong>Atomicity</strong>: The mutex ensures no read/write sees intermediate state (partially copied data).</li>\n</ol>\n<h4 id=\"7-partial-readwrite-with-signal-interruption\">7. Partial Read/Write with Signal Interruption</h4>\n<p>If <code>copy_to_user</code> or <code>copy_from_user</code> is interrupted by a signal after copying some bytes:</p>\n<ol>\n<li><strong>Kernel Behavior</strong>: The copy functions may return less than requested count if a signal arrives.</li>\n<li><strong>Our Handling</strong>: We treat partial success as success—return the number of bytes actually copied.</li>\n<li><strong>Rationale</strong>: This matches standard Linux filesystem semantics. User-space must check return value and retry if needed.</li>\n</ol>\n<p>⚠️ <strong>Pitfall: Assuming copy_to_user is All-or-Nothing</strong><br>Some developers assume <code>copy_to_user</code> either succeeds completely or fails completely. In reality, it can return a value between 0 and <code>count</code> if interrupted. Always check for <code>&gt; 0</code> as success, not <code>== 0</code>.</p>\n<h4 id=\"8-3264-bit-user-space-compatibility\">8. 32/64-bit User-Space Compatibility</h4>\n<p>When user-space passes pointer arguments to <code>ioctl</code>:</p>\n<ol>\n<li><strong>Issue</strong>: A 32-bit application on 64-bit kernel uses different pointer sizes.</li>\n<li><strong>Solution</strong>: The <code>compat_ioctl</code> handler (not implemented in our learning driver) would be needed for production.</li>\n<li><strong>Our Simplification</strong>: We assume same architecture for learning, but note this limitation.</li>\n</ol>\n<h3 id=\"common-pitfalls-in-error-handling\">Common Pitfalls in Error Handling</h3>\n<p>⚠️ <strong>Pitfall: Forgetting to Unlock Mutex on Error Paths</strong><br><strong>Description</strong>: Acquiring a mutex then returning an error without unlocking.\n<strong>Why Wrong</strong>: Creates permanent deadlock—no subsequent operations can acquire the mutex.\n<strong>Fix</strong>: Use <code>goto</code> labels for cleanup:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">lock</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (error) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev->lock);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> error;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Better pattern:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">lock</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> operation</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (result </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    goto</span><span style=\"color:#E1E4E8\"> out_unlock;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// success path</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">out_unlock:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">lock</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> result;</span></span></code></pre></div>\n\n<p>⚠️ <strong>Pitfall: Not Checking copy_to_user Return Value</strong><br><strong>Description</strong>: Assuming <code>copy_to_user</code> always succeeds.\n<strong>Why Wrong</strong>: User-space pointer may be invalid, causing kernel oops if dereferenced.\n<strong>Fix</strong>: Always check and return <code>-EFAULT</code> on failure:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">copy_to_user</span><span style=\"color:#E1E4E8\">(buf, dev</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">buffer</span><span style=\"color:#E1E4E8\">, count) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>⚠️ <strong>Pitfall: Returning 0 from Read at EOF Without Blocking</strong><br><strong>Description</strong>: When buffer is empty, <code>read</code> returns 0 immediately even without O_NONBLOCK.\n<strong>Why Wrong</strong>: User-space expects blocking read to wait for data (standard file behavior).\n<strong>Fix</strong>: Implement proper blocking with wait queue:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (dev</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">data_size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (filp->f_flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> O_NONBLOCK) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EAGAIN;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    wait_event_interruptible</span><span style=\"color:#E1E4E8\">(dev->waitq, dev->data_size </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Re-check condition after wakeup (spurious wakeups)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>⚠️ <strong>Pitfall: Ignoring wait_event_interruptible Return Value</strong><br><strong>Description</strong>: Not checking why the wait returned.\n<strong>Why Wrong</strong>: Signal interruption looks like data arrival, may cause incorrect behavior.\n<strong>Fix</strong>: Check return value and propagate <code>-ERESTARTSYS</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> wait_event_interruptible</span><span style=\"color:#E1E4E8\">(dev</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">waitq</span><span style=\"color:#E1E4E8\">, dev</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">data_size </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> err;</span><span style=\"color:#6A737D\"> // -ERESTARTSYS</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Learning)</th>\n<th>Advanced Option (Production)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Propagation</td>\n<td>Return negative errno values</td>\n<td>Add detailed <code>printk</code> with <code>KERN_ERR</code> for debugging</td>\n</tr>\n<tr>\n<td>Resource Cleanup</td>\n<td><code>goto</code> labels with rollback</td>\n<td>Reference counting with <code>kref</code></td>\n</tr>\n<tr>\n<td>Signal Handling</td>\n<td>Basic <code>-ERESTARTSYS</code> return</td>\n<td>Full signal masking and restart logic</td>\n</tr>\n<tr>\n<td>Concurrency Safety</td>\n<td>Single mutex for all operations</td>\n<td>Fine-grained locking (read/write locks)</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended Error Handling Infrastructure:</strong></p>\n<p>While the core driver implements error handling directly, these helper patterns ensure consistency:</p>\n<ol>\n<li><strong>Standardized Cleanup Pattern</strong> for initialization:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> __init </span><span style=\"color:#B392F0\">mydevice_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 1: Allocate device numbers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_chrdev_region</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">mydevice.devt, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, DEVICE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"Failed to allocate device number</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> fail_region;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 2: Create device class  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mydevice.class </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> class_create</span><span style=\"color:#E1E4E8\">(THIS_MODULE, DEVICE_NAME </span><span style=\"color:#9ECBFF\">\"_class\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">IS_ERR</span><span style=\"color:#E1E4E8\">(mydevice.class)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> PTR_ERR</span><span style=\"color:#E1E4E8\">(mydevice.class);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printk</span><span style=\"color:#E1E4E8\">(KERN_ERR </span><span style=\"color:#9ECBFF\">\"Failed to create device class</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> fail_class;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... more initialization</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Success</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">fail_class:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    unregister_chrdev_region</span><span style=\"color:#E1E4E8\">(mydevice.devt, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">fail_region:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ret;</span><span style=\"color:#6A737D\">  // Propagate error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Error Code Translation Table</strong> for user-space understanding:</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Kernel Return Value</th>\n<th>User-Space errno</th>\n<th>Meaning</th>\n<th>Typical Cause</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>-ENOMEM</code> (-12)</td>\n<td><code>ENOMEM</code> (12)</td>\n<td>Out of memory</td>\n<td><code>kmalloc</code> failed</td>\n</tr>\n<tr>\n<td><code>-EFAULT</code> (-14)</td>\n<td><code>EFAULT</code> (14)</td>\n<td>Bad address</td>\n<td>Invalid user pointer</td>\n</tr>\n<tr>\n<td><code>-EINVAL</code> (-22)</td>\n<td><code>EINVAL</code> (22)</td>\n<td>Invalid argument</td>\n<td>Bad ioctl parameter</td>\n</tr>\n<tr>\n<td><code>-ENOSPC</code> (-28)</td>\n<td><code>ENOSPC</code> (28)</td>\n<td>No space left</td>\n<td>Buffer full</td>\n</tr>\n<tr>\n<td><code>-EAGAIN</code> (-11)</td>\n<td><code>EAGAIN</code> (11)</td>\n<td>Try again</td>\n<td>Non-blocking I/O would block</td>\n</tr>\n<tr>\n<td><code>-ENOTTY</code> (-25)</td>\n<td><code>ENOTTY</code> (25)</td>\n<td>Not a typewriter</td>\n<td>Unknown ioctl command</td>\n</tr>\n</tbody></table>\n<p><strong>Core Logic Skeleton with Error Handling TODOs:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydevice_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                             size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">loff_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">f_pos</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">dev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> filp->private_data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> available;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate input parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Check if buf is NULL (shouldn't happen but be safe)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Check if count is 0 (legal, return 0)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Acquire mutex for buffer access</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Use mutex_lock(&#x26;dev->lock)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Consider checking dev->is_shutting_down after acquiring lock</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Handle empty buffer condition</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If dev->data_size == 0:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //        a) If O_NONBLOCK set in filp->f_flags, set retval = -EAGAIN, goto out_unlock</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //        b) Otherwise, wait for data with wait_event_interruptible</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //        c) Check wait return: if non-zero, set retval = that value, goto out_unlock</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //        d) Loop back to check data_size again (spurious wakeup protection)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Calculate how much data we can actually read</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - available = min(count, dev->data_size)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If available == 0, set retval = 0, goto out_unlock (shouldn't happen with wait)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Copy data to user-space with proper error handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - retval = copy_to_user(buf, dev->buffer, available)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If retval > 0, then (retval) bytes failed to copy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - actually_copied = available - retval</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If actually_copied == 0 and retval != 0, set retval = -EFAULT, goto out_unlock</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If actually_copied > 0, proceed with partial success</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update buffer state on successful copy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - memmove remaining data to front of buffer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Update dev->data_size -= actually_copied</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Wake up writers (wake_up_interruptible(&#x26;dev->waitq))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Set retval = actually_copied (positive value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">out_unlock:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Release mutex</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - mutex_unlock(&#x26;dev->lock)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Return retval (may be positive count, 0, or negative error)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> retval;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> long</span><span style=\"color:#B392F0\"> mydevice_ioctl</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> int</span><span style=\"color:#FFAB70\"> cmd</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                           unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> arg</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">dev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> filp->private_data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\"> retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Handle each command in switch statement</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> (cmd) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MYDEVICE_IOCTL_GET_SIZE:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Copy simple value to user-space</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - Check copy_to_user for -EFAULT</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MYDEVICE_IOCTL_RESIZE:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Validate new_size from user-space</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - Copy from user-space first (copy_from_user)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - Check if 0 &#x3C; new_size &#x3C;= MAX_BUFFER_SIZE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - If invalid, set retval = -EINVAL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - Allocate new buffer before acquiring lock</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - If allocation fails, set retval = -ENOMEM</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - Acquire mutex, copy data, swap buffers, free old</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - Handle partial copy (data may shrink)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MYDEVICE_IOCTL_CLEAR:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Simple clear operation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - Acquire mutex</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - Set dev->data_size = 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - Wake up writers (buffer now empty)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - Release mutex</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Unknown command</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   - Set retval = -ENOTTY</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> retval;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints for Kernel C:</strong></p>\n<ol>\n<li><p><strong>Error Code Constants</strong>: Use standard kernel error codes from <code>&lt;linux/errno.h&gt;</code> (negative values). Never return positive error values.</p>\n</li>\n<li><p><strong>Pointer Validation</strong>: For user-space pointers, only use <code>copy_to_user</code>/<code>copy_from_user</code>. Never dereference directly.</p>\n</li>\n<li><p><strong>Memory Allocation Errors</strong>: <code>kmalloc</code> returns <code>NULL</code> on failure, not an error code. Convert to <code>-ENOMEM</code>.</p>\n</li>\n<li><p><strong>Class/Device Creation Errors</strong>: <code>IS_ERR()</code> and <code>PTR_ERR()</code> macros handle pointer errors from functions like <code>class_create</code>.</p>\n</li>\n<li><p><strong>Wait Queue Returns</strong>: <code>wait_event_interruptible</code> returns negative if interrupted, 0 if condition met. Check both cases.</p>\n</li>\n</ol>\n<p><strong>Milestone Checkpoint for Error Handling:</strong></p>\n<p>After implementing error handling, test with these scenarios:</p>\n<ol>\n<li><strong>Buffer Full Error</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   $ dd if=/dev/zero of=/dev/mychardev bs=2048 count=1000\n   dd: writing to '/dev/mychardev': No space left on device</code></pre></div>\n<p>   Check <code>dmesg</code> for <code>printk</code> message about buffer full.</p>\n<ol start=\"2\">\n<li><strong>Invalid Pointer Test</strong> (requires test program):</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   // In userspace test program</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">bad_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">12345</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Invalid address</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   write</span><span style=\"color:#E1E4E8\">(fd, bad_ptr, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">           // Should return -1, errno = EFAULT</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Signal Interruption</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> cat</span><span style=\"color:#9ECBFF\"> /dev/mychardev</span><span style=\"color:#E1E4E8\"> &#x26;  </span><span style=\"color:#6A737D\"># Starts blocking read</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   $</span><span style=\"color:#9ECBFF\"> kill</span><span style=\"color:#79B8FF\"> -INT</span><span style=\"color:#9ECBFF\"> %1</span><span style=\"color:#6A737D\">          # Send interrupt signal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Should see cat terminated with no data</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Concurrent Access Stress Test</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Multiple writers trying to fill buffer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..10}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       (</span><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Writer </span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/mychardev</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Writer </span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\"> succeeded\"</span><span style=\"color:#E1E4E8\">) &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   done</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Some should get ENOSPC, others succeed</span></span></code></pre></div>\n\n<p><strong>Debugging Tips for Error Conditions:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Module loads but <code>/dev/mychardev</code> not created</td>\n<td>Class or device creation failed</td>\n<td>Check <code>dmesg</code> for error messages after <code>class_create</code> or <code>device_create</code></td>\n<td>Verify permissions, check <code>IS_ERR()</code> return values</td>\n</tr>\n<tr>\n<td>Write returns <code>-1</code> with <code>errno=14</code> (EFAULT)</td>\n<td>Invalid user-space pointer</td>\n<td>Add <code>printk</code> before <code>copy_from_user</code> to log pointer value</td>\n<td>User-space test program bug</td>\n</tr>\n<tr>\n<td>Read blocks forever even when data is written</td>\n<td>Wait queue not woken up</td>\n<td>Add <code>printk</code> in write after <code>wake_up_interruptible</code></td>\n<td>Ensure wakeup is called after updating <code>data_size</code></td>\n</tr>\n<tr>\n<td><code>ioctl</code> returns <code>-1</code> with <code>errno=25</code> (ENOTTY)</td>\n<td>Command number mismatch</td>\n<td>Compare command definitions in kernel and user-space header</td>\n<td>Ensure same <code>_IOR</code>/<code>_IOW</code> macros with same parameters</td>\n</tr>\n<tr>\n<td>System becomes unresponsive during <code>rmmod</code></td>\n<td>Module exit waiting for operations</td>\n<td>Add <code>printk</code> in each handler to see if called during shutdown</td>\n<td>Implement <code>is_shutting_down</code> flag check in handlers</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"testing-strategy\">Testing Strategy</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1, Milestone 2, Milestone 3, Milestone 4 (verification and validation of all functionality)</p>\n</blockquote>\n<p>This section provides a comprehensive plan for verifying the correctness of the character device driver throughout its development lifecycle. Testing kernel modules presents unique challenges: you cannot simply run them in a debugger like userspace programs, crashes can affect the entire system, and many issues manifest as subtle data corruption or deadlocks under concurrent access. Our strategy employs a <strong>progressive verification approach</strong>—each milestone builds upon the verified functionality of the previous one—using a combination of simple command-line tools, custom test programs, and systematic stress testing. Think of testing a kernel module like <strong>testing the structural integrity of a building</strong>: you start with the foundation (module loading), then test each floor (device operations), then stress-test with simulated occupancy (concurrent access), and finally inspect safety systems (error handling).</p>\n<h3 id=\"milestone-verification-checkpoints\">Milestone Verification Checkpoints</h3>\n<p>This table provides specific, actionable verification steps for each milestone. Each checkpoint assumes you have successfully completed the implementation steps from the corresponding milestone and have the module compiled. The &quot;Expected Output&quot; column shows what you should see when running the commands; deviations indicate implementation issues that need debugging.</p>\n<table>\n<thead>\n<tr>\n<th>Milestone</th>\n<th>Verification Step</th>\n<th>Command to Run</th>\n<th>Expected Output / Behavior</th>\n<th>What This Verifies</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>1: Hello World Module</strong></td>\n<td>1.1 Compile module</td>\n<td><code>make</code></td>\n<td>Successful compilation with no errors, generating <code>mychardev.ko</code></td>\n<td>Kbuild system is correctly configured and kernel headers are available</td>\n</tr>\n<tr>\n<td></td>\n<td>1.2 Check module info</td>\n<td><code>modinfo mychardev.ko</code></td>\n<td>Shows <code>license: GPL</code>, <code>author: [Your Name]</code>, <code>description: Simple character device driver</code></td>\n<td>Module metadata is properly declared with <code>MODULE_LICENSE</code>, <code>MODULE_AUTHOR</code>, <code>MODULE_DESCRIPTION</code></td>\n</tr>\n<tr>\n<td></td>\n<td>1.3 Load module</td>\n<td><code>sudo insmod mychardev.ko</code></td>\n<td>No output on success (errors print to terminal)</td>\n<td>Module initialization (<code>mydevice_init</code>) executes without errors</td>\n</tr>\n<tr>\n<td></td>\n<td>1.4 Verify loading in kernel log</td>\n<td><code>dmesg | tail -5</code></td>\n<td>Contains lines: <code>[timestamp] mychardev: module loaded successfully, major=xxx</code></td>\n<td><code>printk</code> with <code>KERN_INFO</code> works; module registers itself with kernel</td>\n</tr>\n<tr>\n<td></td>\n<td>1.5 Check kernel module list</td>\n<td><code>lsmod | grep mychardev</code></td>\n<td>Shows <code>mychardev</code> with a reference count (probably 0)</td>\n<td>Module is present in the running kernel&#39;s module list</td>\n</tr>\n<tr>\n<td></td>\n<td>1.6 Unload module</td>\n<td><code>sudo rmmod mychardev</code></td>\n<td>No output on success</td>\n<td>Module cleanup (<code>mydevice_exit</code>) executes without errors</td>\n</tr>\n<tr>\n<td></td>\n<td>1.7 Verify unloading in kernel log</td>\n<td><code>dmesg | tail -5</code></td>\n<td>Contains line: <code>[timestamp] mychardev: module unloaded</code></td>\n<td>Module cleans up resources properly and leaves no trace</td>\n</tr>\n<tr>\n<td><strong>2: Character Device Driver</strong></td>\n<td>2.1 Load module (fresh)</td>\n<td><code>sudo insmod mychardev.ko</code></td>\n<td>No errors; check <code>dmesg</code> for major number allocation</td>\n<td>Dynamic device number allocation via <code>alloc_chrdev_region</code> succeeds</td>\n</tr>\n<tr>\n<td></td>\n<td>2.2 Verify device node creation</td>\n<td><code>ls -l /dev/mychardev</code></td>\n<td>Shows <code>crw------- 1 root root major,minor date /dev/mychardev</code></td>\n<td><code>class_create</code> and <code>device_create</code> automatically created <code>/dev</code> node</td>\n</tr>\n<tr>\n<td></td>\n<td>2.3 Write data to device</td>\n<td><code>echo -n &quot;test data&quot; | sudo tee /dev/mychardev</code></td>\n<td>Prints &quot;test data&quot; to terminal (from <code>tee</code>)</td>\n<td><code>mydevice_write</code> handler successfully copies data from userspace to kernel buffer</td>\n</tr>\n<tr>\n<td></td>\n<td>2.4 Read data back</td>\n<td><code>sudo cat /dev/mychardev</code></td>\n<td>Outputs &quot;test data&quot; exactly as written</td>\n<td><code>mydevice_read</code> handler successfully copies data from kernel buffer to userspace</td>\n</tr>\n<tr>\n<td></td>\n<td>2.5 Verify partial read</td>\n<td><code>echo -n &quot;1234567890&quot; | sudo tee /dev/mychardev &amp;&amp; sudo head -c 5 /dev/mychardev</code></td>\n<td>Outputs first 5 bytes: &quot;12345&quot;</td>\n<td><code>read</code> correctly handles partial transfers and updates file position</td>\n</tr>\n<tr>\n<td></td>\n<td>2.6 Verify EOF behavior</td>\n<td>Run <code>sudo cat /dev/mychardev</code> twice</td>\n<td>First: outputs remaining data (&quot;67890&quot;); Second: outputs nothing (returns 0)</td>\n<td><code>read</code> returns 0 at end-of-file, preventing infinite loops</td>\n</tr>\n<tr>\n<td></td>\n<td>2.7 Check buffer persistence</td>\n<td>Write, then read, then write again, then read all</td>\n<td>Second read returns only the second write&#39;s data</td>\n<td>Buffer is cleared after complete read (simple linear buffer behavior)</td>\n</tr>\n<tr>\n<td><strong>3: ioctl and proc Interface</strong></td>\n<td>3.1 Load module</td>\n<td><code>sudo insmod mychardev.ko</code></td>\n<td>As before</td>\n<td>All previous functionality remains intact</td>\n</tr>\n<tr>\n<td></td>\n<td>3.2 Compile test program</td>\n<td><code>gcc -o test_ioctl test_ioctl.c</code></td>\n<td>No errors</td>\n<td>Shared header file (<code>mydevice.h</code>) is correct and accessible</td>\n</tr>\n<tr>\n<td></td>\n<td>3.3 Test <code>MYDEVICE_IOCTL_GET_SIZE</code></td>\n<td><code>sudo ./test_ioctl get_size</code></td>\n<td>Prints: <code>Buffer size: 1024 bytes</code></td>\n<td><code>ioctl</code> handler correctly returns current buffer size</td>\n</tr>\n<tr>\n<td></td>\n<td>3.4 Test <code>MYDEVICE_IOCTL_GET_MAX_CAPACITY</code></td>\n<td><code>sudo ./test_ioctl get_max</code></td>\n<td>Prints: <code>Max capacity: 1048576 bytes</code></td>\n<td><code>ioctl</code> returns the <code>MAX_BUFFER_SIZE</code> constant</td>\n</tr>\n<tr>\n<td></td>\n<td>3.5 Test <code>MYDEVICE_IOCTL_CLEAR</code></td>\n<td>Write data, run <code>sudo ./test_ioctl clear</code>, then read</td>\n<td>Read returns nothing (buffer empty)</td>\n<td><code>ioctl</code> clear command resets buffer and <code>data_size</code> to 0</td>\n</tr>\n<tr>\n<td></td>\n<td>3.6 Test <code>MYDEVICE_IOCTL_RESIZE</code></td>\n<td><code>sudo ./test_ioctl resize 2048</code> then <code>get_size</code></td>\n<td>New size: <code>2048 bytes</code></td>\n<td>Buffer resizes successfully, preserving existing data up to new size</td>\n</tr>\n<tr>\n<td></td>\n<td>3.7 Verify <code>/proc</code> entry</td>\n<td><code>cat /proc/mychardev_stats</code></td>\n<td>Shows multi-line stats: <code>Device: mychardev</code>, <code>Buffer size: 2048</code>, <code>Data stored: 0</code>, etc.</td>\n<td><code>proc_create</code> and <code>mydevice_proc_show</code> correctly display device state</td>\n</tr>\n<tr>\n<td></td>\n<td>3.8 Test invalid ioctl</td>\n<td><code>sudo ./test_ioctl invalid</code></td>\n<td>Program prints error: <code>ioctl: Invalid argument</code> (errno 22)</td>\n<td>Driver returns <code>-EINVAL</code> for unknown commands</td>\n</tr>\n<tr>\n<td><strong>4: Concurrent Access and Locking</strong></td>\n<td>4.1 Load module</td>\n<td><code>sudo insmod mychardev.ko</code></td>\n<td>As before</td>\n<td>All previous functionality remains intact</td>\n</tr>\n<tr>\n<td></td>\n<td>4.2 Test blocking read (empty buffer)</td>\n<td>In terminal A: <code>sudo cat /dev/mychardev</code> (hangs)</td>\n<td>Process blocks (does not return)</td>\n<td><code>wait_event_interruptible</code> puts process to sleep when buffer empty</td>\n</tr>\n<tr>\n<td></td>\n<td>4.3 Wake blocked reader</td>\n<td>In terminal B: <code>echo -n &quot;wake up&quot; | sudo tee /dev/mychardev</code></td>\n<td>Terminal A immediately outputs &quot;wake up&quot; and exits</td>\n<td><code>wake_up_interruptible</code> correctly wakes sleeping reader</td>\n</tr>\n<tr>\n<td></td>\n<td>4.4 Test non-blocking read</td>\n<td><code>sudo cat /dev/mychardev &amp; sleep 1; echo -n &quot;data&quot; | sudo tee /dev/mychardev; wait</code></td>\n<td>Output: &quot;data&quot; (background cat completes)</td>\n<td>Blocking behavior works as expected with process management</td>\n</tr>\n<tr>\n<td></td>\n<td>4.5 Test <code>poll</code>/<code>select</code> readiness</td>\n<td>Write a small test program that uses <code>select()</code> on device</td>\n<td>Program reports device as writable immediately, readable only after write</td>\n<td><code>mydevice_poll</code> returns correct mask bits (<code>POLLOUT</code> always, <code>POLLIN</code> when data available)</td>\n</tr>\n<tr>\n<td></td>\n<td>4.6 Simple concurrency test</td>\n<td>Two parallel writes: <code>(echo -n &quot;AAA&quot; | sudo tee /dev/mychardev &amp; echo -n &quot;BBB&quot; | sudo tee /dev/mychardev &amp; wait)</code> then read</td>\n<td>Read output is either &quot;AAA&quot; or &quot;BBB&quot; (not mixed)</td>\n<td>Mutex protects buffer from concurrent writes corrupting data</td>\n</tr>\n<tr>\n<td></td>\n<td>4.7 Verify mutex prevents race</td>\n<td>Use the concurrency stress test script (below)</td>\n<td>No kernel panics, no corrupted output (all reads get consistent data)</td>\n<td>Locking correctly serializes access to shared buffer</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight:</strong> Kernel testing is iterative and observational. You&#39;re not writing unit tests that run in isolation but rather <strong>observing the system&#39;s behavior</strong> through its external interfaces (<code>/dev</code>, <code>/proc</code>, kernel log). Success is defined by the driver behaving predictably according to Unix file semantics and Linux driver conventions.</p>\n</blockquote>\n<h3 id=\"concurrency-stress-test\">Concurrency Stress Test</h3>\n<p>Concurrency bugs are among the most insidious in kernel programming because they may only surface under specific timing conditions that are difficult to reproduce. Our stress test simulates <strong>multiple readers and writers accessing the device simultaneously</strong> to expose race conditions, deadlocks, and data corruption. Think of this as <strong>stress-testing a bridge with synchronized heavy traffic</strong>: we want to ensure the structure (mutexes) holds, traffic flows (no deadlocks), and no vehicles collide (data remains consistent).</p>\n<p><strong>Test Design Principles:</strong></p>\n<ol>\n<li><strong>Reproducibility:</strong> Use fixed data patterns to easily detect corruption.</li>\n<li><strong>Duration:</strong> Run for sufficient time (10-30 seconds) to increase probability of race conditions.</li>\n<li><strong>Monitoring:</strong> Watch kernel log for error messages and system for lockups.</li>\n<li><strong>Cleanup:</strong> Ensure all background processes are terminated after test.</li>\n</ol>\n<p><strong>Stress Test Script (<code>stress_test.sh</code>):</strong>\nThis shell script launches multiple writer and reader processes that operate on the device concurrently. Writers write distinct patterns, readers verify they receive uncorrupted data.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">#!/bin/bash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># stress_test.sh - Concurrent access stress test for mychardev driver</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">set</span><span style=\"color:#79B8FF\"> -e</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">DEVICE</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"/dev/mychardev\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">TEST_DURATION</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">10</span><span style=\"color:#6A737D\">  # seconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">NUM_WRITERS</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">NUM_READERS</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">3</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"=== Starting concurrency stress test for </span><span style=\"color:#E1E4E8\">$DEVICE</span><span style=\"color:#9ECBFF\"> ===\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Test duration: </span><span style=\"color:#E1E4E8\">$TEST_DURATION</span><span style=\"color:#9ECBFF\"> seconds\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Writers: </span><span style=\"color:#E1E4E8\">$NUM_WRITERS</span><span style=\"color:#9ECBFF\">, Readers: </span><span style=\"color:#E1E4E8\">$NUM_READERS</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Clear buffer initially</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./test_ioctl</span><span style=\"color:#9ECBFF\"> clear</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span><span style=\"color:#F97583\"> 2>&#x26;1</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Start writer processes</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Starting writer processes...\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">seq</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> $NUM_WRITERS); </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        writer_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$i</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        end_time</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(( </span><span style=\"color:#B392F0\">$(date</span><span style=\"color:#9ECBFF\"> +%s</span><span style=\"color:#E1E4E8\">) + $TEST_DURATION ))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> [ $(</span><span style=\"color:#B392F0\">date</span><span style=\"color:#9ECBFF\"> +%s</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">-lt</span><span style=\"color:#E1E4E8\"> $end_time ]; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Each writer writes its unique pattern repeatedly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pattern</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"Writer${</span><span style=\"color:#E1E4E8\">writer_id</span><span style=\"color:#9ECBFF\">}_$(</span><span style=\"color:#B392F0\">date</span><span style=\"color:#9ECBFF\"> +%s%N)\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            echo</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$pattern</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> sudo</span><span style=\"color:#9ECBFF\"> tee</span><span style=\"color:#E1E4E8\"> $DEVICE </span><span style=\"color:#F97583\">></span><span style=\"color:#9ECBFF\"> /dev/null</span><span style=\"color:#F97583\"> 2>&#x26;1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Small random delay to desynchronize</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            sleep</span><span style=\"color:#9ECBFF\"> 0.</span><span style=\"color:#E1E4E8\">$(( </span><span style=\"color:#B392F0\">RANDOM</span><span style=\"color:#9ECBFF\"> %</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\"> ))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        done</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WRITER_PIDS</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$WRITER_PIDS</span><span style=\"color:#79B8FF\"> $!</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Start reader processes  </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Starting reader processes...\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">seq</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> $NUM_READERS); </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        reader_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$i</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        end_time</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(( </span><span style=\"color:#B392F0\">$(date</span><span style=\"color:#9ECBFF\"> +%s</span><span style=\"color:#E1E4E8\">) + $TEST_DURATION ))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> [ $(</span><span style=\"color:#B392F0\">date</span><span style=\"color:#9ECBFF\"> +%s</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">-lt</span><span style=\"color:#E1E4E8\"> $end_time ]; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Read whatever is available (may block)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            data</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> cat</span><span style=\"color:#E1E4E8\"> $DEVICE </span><span style=\"color:#F97583\">2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> [ </span><span style=\"color:#F97583\">-n</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$data</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Basic validation: data should not be empty and should contain writer pattern</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # In a full test, you would verify structure, but we just check non-empty</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                echo</span><span style=\"color:#9ECBFF\"> \"Reader</span><span style=\"color:#E1E4E8\">$reader_id</span><span style=\"color:#9ECBFF\"> read ${</span><span style=\"color:#F97583\">#</span><span style=\"color:#E1E4E8\">data</span><span style=\"color:#9ECBFF\">} bytes\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Optional: check pattern matches expected format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # if [[ ! \"$data\" =~ ^Writer[0-9]+_[0-9]+$ ]]; then</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                #     echo \"ERROR: Corrupted data: $data\" >&#x26;2</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # fi</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            fi</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        done</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    READER_PIDS</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$READER_PIDS</span><span style=\"color:#79B8FF\"> $!</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Let test run for duration</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Test running for </span><span style=\"color:#E1E4E8\">$TEST_DURATION</span><span style=\"color:#9ECBFF\"> seconds...\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sleep</span><span style=\"color:#E1E4E8\"> $TEST_DURATION</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Cleanup: kill all background processes</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Cleaning up background processes...\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">kill</span><span style=\"color:#E1E4E8\"> $WRITER_PIDS $READER_PIDS </span><span style=\"color:#F97583\">2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Final buffer state</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"=== Test complete ===\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Final buffer contents:\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> cat</span><span style=\"color:#E1E4E8\"> $DEVICE </span><span style=\"color:#F97583\">2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> od</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> head</span><span style=\"color:#79B8FF\"> -20</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Check dmesg for errors (should be none):\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dmesg</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tail</span><span style=\"color:#79B8FF\"> -10</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -E</span><span style=\"color:#9ECBFF\"> \"mychardev|BUG|WARNING|Oops\"</span></span></code></pre></div>\n\n<p><strong>Expected Outcome of Stress Test:</strong></p>\n<ol>\n<li><strong>No kernel crashes or panics</strong> - The system remains stable throughout.</li>\n<li><strong>No error messages in <code>dmesg</code></strong> related to our driver (except normal loading/unloading).</li>\n<li><strong>All processes complete</strong> or are cleanly terminated after test duration.</li>\n<li><strong>Readers report consistent data</strong> - No &quot;corrupted data&quot; messages if validation is enabled.</li>\n<li><strong>Final buffer contains valid data</strong> - The <code>od</code> output shows ASCII characters from writer patterns, not garbage.</li>\n</ol>\n<p><strong>Interpreting Test Results:</strong></p>\n<ul>\n<li><strong>System hangs completely:</strong> Likely a deadlock in mutex or wait queue usage (e.g., locking mutex twice in same process).</li>\n<li><strong><code>dmesg</code> shows &quot;BUG: scheduling while atomic&quot;:</strong> Sleeping (like <code>mutex_lock</code>) in atomic context incorrectly.</li>\n<li><strong>Data corruption (mixed patterns):</strong> Insufficient protection of buffer during concurrent writes/reads.</li>\n<li><strong>Readers starve (never read):</strong> <code>wake_up_interruptible</code> not called after writes, or condition checking incorrect.</li>\n<li><strong>&quot;Invalid opcode&quot; or kernel oops:</strong> Memory corruption, likely from buffer overflows or use-after-free.</li>\n</ul>\n<p><strong>Enhanced Test with Ioctl Operations:</strong>\nFor more comprehensive testing, extend the script to include concurrent <code>ioctl</code> operations (resize, clear) mixed with reads and writes. This tests the interaction between control operations and data operations. Add a fourth set of processes that randomly issue <code>ioctl</code> commands while reads and writes are happening.</p>\n<blockquote>\n<p><strong>Design Insight:</strong> Concurrency testing is probabilistic—passing the stress test once doesn&#39;t guarantee absence of bugs, but <strong>repeated failures indicate definite problems</strong>. Run the test multiple times, especially on SMP (multi-core) systems where race conditions are more likely to surface.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>While the main testing strategy uses external observation, you may want to create structured test programs for more systematic verification. This guidance provides a <strong>test program template</strong> for Milestone 3&#39;s <code>ioctl</code> interface and tips for implementing the stress test.</p>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Userspace Testing</td>\n<td>Custom C programs using standard file I/O and <code>ioctl</code></td>\n<td>Python test scripts using <code>ctypes</code> or <code>pyioctl</code> for rapid prototyping</td>\n</tr>\n<tr>\n<td>Concurrency Testing</td>\n<td>Bash script with background processes (<code>&amp;</code>, <code>wait</code>)</td>\n<td>Dedicated multithreaded C program with precise timing control</td>\n</tr>\n<tr>\n<td>Result Validation</td>\n<td>Manual inspection of output and <code>dmesg</code></td>\n<td>Automated parsing of kernel log with expected pattern matching</td>\n</tr>\n<tr>\n<td>Long-running Tests</td>\n<td>Loop shell commands with <code>sleep</code></td>\n<td>Systemtap or BPF tracing to monitor internal driver state</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure-for-testing\">B. Recommended File/Module Structure for Testing</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  Makefile                    # Builds kernel module and test programs\n  mychardev.c                 # Main driver implementation\n  mychardev.h                 # Shared header with ioctl definitions\n  test_ioctl.c                # Userspace test program for milestone 3\n  stress_test.sh              # Concurrency stress test script (bash)\n  test_poll.c                 # Test program for poll/select functionality\n  README.md                   # Includes testing instructions</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code-test-ioctl-program\">C. Infrastructure Starter Code: Test Ioctl Program</h4>\n<p>Here is a <strong>complete, ready-to-use</strong> test program for verifying the <code>ioctl</code> interface (Milestone 3). This program exercises all defined <code>ioctl</code> commands with proper error handling.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test_ioctl.c - Userspace test program for mychardev ioctl interface</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;fcntl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/ioctl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"mychardev.h\"</span><span style=\"color:#6A737D\">  // Shared header with ioctl definitions</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#F97583\">[]</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (argc </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Usage: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> &#x3C;command> [args]</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Commands:</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"  get_size           - get current buffer size</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"  get_max            - get maximum buffer capacity</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"  clear              - clear buffer contents</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"  resize &#x3C;new_size>  - resize buffer (bytes)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Open the device</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/dev/mychardev\"</span><span style=\"color:#E1E4E8\">, O_RDWR);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to open /dev/mychardev\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Dispatch command</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strcmp</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">\"get_size\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ioctl</span><span style=\"color:#E1E4E8\">(fd, MYDEVICE_IOCTL_GET_SIZE, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ioctl GET_SIZE failed\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Buffer size: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strcmp</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">\"get_max\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ioctl</span><span style=\"color:#E1E4E8\">(fd, MYDEVICE_IOCTL_GET_MAX_CAPACITY, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ioctl GET_MAX_CAPACITY failed\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Max capacity: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strcmp</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">\"clear\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ioctl</span><span style=\"color:#E1E4E8\">(fd, MYDEVICE_IOCTL_CLEAR);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ioctl CLEAR failed\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Buffer cleared</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strcmp</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">\"resize\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (argc </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Usage: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> resize &#x3C;new_size_in_bytes></span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        size </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> atoi</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ioctl</span><span style=\"color:#E1E4E8\">(fd, MYDEVICE_IOCTL_RESIZE, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ioctl RESIZE failed\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Error code: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, errno);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Buffer resized to </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Unknown command: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-poll-test-program\">D. Core Logic Skeleton: Poll Test Program</h4>\n<p>For testing the <code>poll</code>/<code>select</code> functionality (Milestone 4), here&#39;s a skeleton test program you can complete:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test_poll.c - Test poll/select on the character device</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;fcntl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;poll.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> pollfd pfd;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Open device /dev/mychardev with O_RDWR | O_NONBLOCK</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // (non-blocking mode allows poll to return immediately)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize pollfd structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Set fd to the device file descriptor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Set events to POLLIN | POLLOUT (interested in both read and write readiness)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Polling device for events...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Call poll() with timeout of 3000 milliseconds (3 seconds)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Handle errors (return -1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Handle timeout (return 0)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check revents field after poll returns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - If POLLIN is set: print \"Device is readable\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - If POLLOUT is set: print \"Device is writable\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - If POLLERR is set: print \"Error condition on device\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - If POLLHUP is set: print \"Hang up occurred\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Demonstrate blocking behavior</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - First poll on empty buffer (should NOT have POLLIN)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Write some data to device</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Poll again (should NOW have POLLIN)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Close device and exit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-c-specific-testing-hints\">E. C-Specific Testing Hints</h4>\n<ol>\n<li><strong>Compile test programs:</strong> Use <code>gcc -o test_ioctl test_ioctl.c</code> with the kernel header in include path.</li>\n<li><strong>Run as root:</strong> All device access requires superuser privileges; use <code>sudo</code> or run test as root.</li>\n<li><strong>Check error codes:</strong> Kernel functions return negative error numbers; in userspace, <code>errno</code> is set.</li>\n<li><strong>Clean up between tests:</strong> Unload and reload module (<code>rmmod; insmod</code>) to get fresh state.</li>\n<li><strong>Use <code>strace</code> for debugging:</strong> <code>strace -e trace=ioctl,read,write ./test_ioctl get_size</code> shows system calls.</li>\n</ol>\n<h4 id=\"f-milestone-checkpoint-verification\">F. Milestone Checkpoint Verification</h4>\n<p>After implementing each milestone, run the corresponding verification steps from the table above. For quick validation, use this <strong>summary checklist</strong>:</p>\n<ul>\n<li><strong>Milestone 1:</strong> Module loads/unloads cleanly, appears in <code>lsmod</code>, shows info with <code>modinfo</code>.</li>\n<li><strong>Milestone 2:</strong> Can write to <code>/dev/mychardev</code> and read back same data; device node has correct permissions.</li>\n<li><strong>Milestone 3:</strong> <code>test_ioctl</code> program works for all commands; <code>/proc/mychardev_stats</code> shows current state.</li>\n<li><strong>Milestone 4:</strong> Blocking read works (hangs until data written); stress test runs without crashes.</li>\n</ul>\n<h4 id=\"g-debugging-tips-for-testing\">G. Debugging Tips for Testing</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Module fails to load with &quot;Invalid module format&quot;</td>\n<td>Kernel version mismatch between headers and running kernel</td>\n<td>Run <code>uname -r</code> and compare with <code>Makefile</code> <code>KERNELDIR</code></td>\n<td>Install correct kernel headers or adjust <code>Makefile</code></td>\n</tr>\n<tr>\n<td>Write succeeds but read returns nothing</td>\n<td>Buffer not preserved between operations or <code>data_size</code> not updated</td>\n<td>Add <code>printk</code> in write handler to show buffer contents and size</td>\n<td>Ensure <code>data_size</code> is incremented on write and not reset prematurely</td>\n</tr>\n<tr>\n<td>System hangs on <code>cat /dev/mychardev</code> (empty buffer)</td>\n<td><code>wait_event_interruptible</code> condition never becomes true or wakeup not called</td>\n<td>Check <code>printk</code> in write to confirm <code>wake_up_interruptible</code> is called</td>\n<td>Verify condition uses correct variables; call wakeup after changing condition</td>\n</tr>\n<tr>\n<td><code>ioctl</code> returns <code>-1</code> with <code>errno=22</code> (EINVAL)</td>\n<td>Incorrect command number or size mismatch in <code>_IOR</code>/<code>_IOW</code> macros</td>\n<td>Compare command numbers in kernel and userspace headers</td>\n<td>Ensure identical macro definitions; check third argument (size) matches data type</td>\n</tr>\n<tr>\n<td>Concurrent test shows mixed data from different writers</td>\n<td>Missing or incorrect mutex protection around buffer operations</td>\n<td>Add <code>printk</code> showing thread/process ID during buffer access</td>\n<td>Protect ALL buffer accesses (read/write/resize) with same mutex</td>\n</tr>\n<tr>\n<td><code>poll</code> always returns <code>POLLOUT</code> but never <code>POLLIN</code></td>\n<td><code>poll</code> handler not calling <code>poll_wait</code> on read wait queue or incorrect condition</td>\n<td>Check <code>mydevice_poll</code> calls <code>poll_wait(&amp;dev-&gt;waitq, ...)</code></td>\n<td>Add wait queue for read readiness; return <code>POLLIN</code> when <code>data_size &gt; 0</code></td>\n</tr>\n<tr>\n<td>Memory leak shown in <code>dmesg</code> on unload</td>\n<td>Resources not freed in <code>mydevice_exit</code> (class, device, buffer, cdev)</td>\n<td>Review cleanup function against initialization in reverse order</td>\n<td>Implement complete cleanup: <code>device_destroy</code>, <code>class_destroy</code>, <code>cdev_del</code>, <code>unregister_chrdev_region</code>, <code>buffer_cleanup</code></td>\n</tr>\n<tr>\n<td>&quot;Kernel tainted&quot; warning in <code>dmesg</code></td>\n<td>Missing or non-GPL module license</td>\n<td>Check <code>MODULE_LICENSE(&quot;GPL&quot;)</code> is present</td>\n<td>Add proper license declaration at end of module</td>\n</tr>\n</tbody></table>\n<p>Remember: <strong>Testing kernel code requires patience and careful observation.</strong> Always check <code>dmesg</code> after each test, reload the module frequently to get a clean state, and consider using a virtual machine for development to avoid crashing your main system.</p>\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1, Milestone 2, Milestone 3, Milestone 4 (debugging is essential throughout development)</p>\n</blockquote>\n<p>Developing kernel modules presents unique debugging challenges compared to userspace programming. You cannot use a standard debugger like GDB on the running kernel without specialized setups, and mistakes can crash the entire system. This guide provides a practical, symptom-based approach to diagnosing common problems in your character device driver using the tools available to kernel developers: <strong>kernel logging (<code>printk</code> and <code>dmesg</code>)</strong>, inspection of kernel interfaces (<code>/proc</code>, <code>/sys</code>), and userspace tracing (<code>strace</code>). The goal is to build a systematic methodology for isolating bugs at the kernel-user boundary and within concurrent kernel code.</p>\n<h3 id=\"symptom-cause-diagnosis-fix-table\">Symptom → Cause → Diagnosis → Fix Table</h3>\n<p>The following table catalogs frequent issues encountered during the development of each milestone. Use it as a first response when your driver behaves unexpectedly.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Symptom</th>\n<th align=\"left\">Likely Cause</th>\n<th align=\"left\">Diagnosis Steps</th>\n<th align=\"left\">Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Module fails to load</strong> with <code>insmod: ERROR: could not insert module: Invalid parameters</code> or a kernel <code>Oops</code>/panic immediately on load.</td>\n<td align=\"left\">1. Missing or incorrect <code>MODULE_LICENSE</code>. <br> 2. Kernel symbol version mismatch (building against wrong headers). <br> 3. Bug in <code>mydevice_init()</code> causing a NULL dereference or resource allocation failure.</td>\n<td align=\"left\">1. Check <code>dmesg</code> for <code>module license &#39;unspecified&#39; taints kernel</code>. <br> 2. Run <code>modinfo mymodule.ko</code> to verify license and dependencies. <br> 3. Look for specific error messages from <code>printk</code> in your init function. <br> 4. Verify kernel version with <code>uname -r</code> matches the headers used for building (<code>/lib/modules/$(uname -r)/build</code>).</td>\n<td align=\"left\">1. Add <code>MODULE_LICENSE(&quot;GPL&quot;)</code> (or a compatible license). <br> 2. Ensure your Makefile uses <code>$(shell uname -r)</code> for the kernel build path. <br> 3. Add defensive <code>printk(KERN_ERR ...)</code> statements at each stage of <code>mydevice_init()</code> and implement proper rollback on error (undoing allocations in reverse order).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Write succeeds (returns byte count) but a subsequent read returns 0 (EOF) or empty data.</strong></td>\n<td align=\"left\">1. <code>mydevice_write</code> does not correctly update the buffer&#39;s <code>data_size</code> or write position. <br> 2. The <code>read</code> handler&#39;s logic for <code>copy_to_user</code> fails silently (e.g., invalid userspace pointer). <br> 3. Concurrent access corrupting buffer metadata (Milestone 4).</td>\n<td align=\"left\">1. Add <code>printk</code> in <code>mydevice_write</code> to log the received <code>count</code> and the new <code>data_size</code>. <br> 2. Check the return value of <code>copy_to_user</code> in <code>mydevice_read</code>; if non-zero, it indicates bytes NOT copied. <br> 3. Inspect <code>/proc/mychardev</code> stats (if implemented) to see the reported <code>data_size</code>. <br> 4. Test with a single process, eliminating concurrency.</td>\n<td align=\"left\">1. Ensure <code>mydevice_write</code> correctly adds to <code>data_size</code> (up to <code>buffer_size</code>) and that <code>mydevice_read</code> uses a separate <code>read_position</code> or correctly reduces <code>data_size</code> after reading. <br> 2. Always check and propagate the error return from <code>copy_to_user</code> (return <code>-EFAULT</code>). <br> 3. Verify mutex locks in <code>read</code>/<code>write</code> cover all metadata updates.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>System hangs indefinitely when a process calls <code>read()</code> on the empty device.</strong></td>\n<td align=\"left\">1. Blocking <code>read</code> implemented with <code>wait_event_interruptible</code> but the wakeup condition (<code>data_size &gt; 0</code>) is never satisfied, or the wakeup call (<code>wake_up_interruptible</code>) is missing. <br> 2. Deadlock: the mutex is held when calling <code>wait_event_interruptible</code>.</td>\n<td align=\"left\">1. Check <code>dmesg</code> for any related messages. Send a SIGINT (Ctrl+C) to the reading process; if it exits, the wait was interruptible. <br> 2. Add <code>printk</code> in the write handler to confirm <code>wake_up_interruptible</code> is called. <br> 3. Review lock ordering: <code>wait_event_interruptible</code> must be called <em>after</em> releasing the mutex (the macro handles this internally).</td>\n<td align=\"left\">1. Ensure <code>wake_up_interruptible(&amp;dev-&gt;waitq)</code> is called in <code>mydevice_write</code> after new data is placed in the buffer. <br> 2. Use <code>wait_event_interruptible(dev-&gt;waitq, (dev-&gt;data_size &gt; 0) );</code> correctly. The condition is re-evaluated after wakeup; ensure no other path can leave <code>data_size</code> at 0 incorrectly. <br> 3. Do not call <code>mutex_lock</code> before <code>wait_event_interruptible</code>; the macro releases the lock while sleeping and re-acquires it upon waking.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>ioctl</code> returns <code>-1</code> with userspace <code>errno=22</code> (<code>EINVAL</code>).</strong></td>\n<td align=\"left\">1. Incorrect <code>ioctl</code> command number definition mismatch between kernel and userspace header. <br> 2. Wrong size specified in the <code>_IOR</code>/<code>_IOW</code> macro versus the actual data type passed. <br> 3. The <code>ioctl</code> handler returns <code>-EINVAL</code> for an unrecognized command or invalid argument.</td>\n<td align=\"left\">1. Compare the command numbers in the shared header file used by both kernel module and userspace test program. Use <code>printf(&quot;%x\\n&quot;, cmd)</code> in userspace and <code>printk</code> in the kernel to see the actual value. <br> 2. Verify the <code>size</code> argument in the macro matches the size of the data type (e.g., <code>sizeof(size_t)</code>). <br> 3. Check the <code>switch(cmd)</code> in <code>mydevice_ioctl</code> for a default case that returns <code>-EINVAL</code>.</td>\n<td align=\"left\">1. Ensure the <code>MYDEVICE_IOC_MAGIC</code> character and numeric command values are identical in both header files. <br> 2. Use <code>_IOW(MYDEVICE_IOC_MAGIC, 4, size_t)</code> for a command that writes a <code>size_t</code> from userspace. <br> 3. In the kernel handler, validate <code>arg</code> (e.g., ensure a requested buffer size is within <code>MAX_BUFFER_SIZE</code>) before using it.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>cat /proc/mychardev</code> shows corrupted data, partial output, or causes a kernel warning.</strong></td>\n<td align=\"left\">1. The <code>/proc</code> read callback (<code>mydevice_proc_show</code>) does not handle the offset mechanism correctly for multiple <code>read</code> system calls. <br> 2. Using a simple <code>proc_ops</code> with <code>proc_read</code> but not managing the single-buffer approach properly. <br> 3. Accessing device data without proper locking (concurrent modification while generating proc output).</td>\n<td align=\"left\">1. Observe if multiple <code>cat</code> commands produce different outputs. <br> 2. Check <code>dmesg</code> for <code>WARNING: at fs/proc/generic.c:...</code> related to procfs. <br> 3. Test with concurrent <code>write</code> operations while reading <code>/proc</code>.</td>\n<td align=\"left\">1. For simplicity, use <code>single_open</code> and <code>single_release</code> with a <code>show</code> function that generates the entire output at once. This avoids offset management. <br> 2. In the <code>show</code> function, acquire the device mutex (<code>mutex_lock(&amp;dev-&gt;lock)</code>) before reading <code>buffer_size</code>, <code>data_size</code>, etc., and release it before returning. <br> 3. Ensure <code>mydevice_proc_show</code> returns 0 on success (not the number of bytes printed).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Concurrent reads and writers cause data corruption (repeated/missing bytes) or a kernel crash.</strong></td>\n<td align=\"left\">1. Missing or incomplete mutual exclusion around the shared buffer and its metadata (<code>data_size</code>). <br> 2. Race condition between checking a condition (e.g., <code>buffer full</code>) and acting on it. <br> 3. Incorrect use of a spinlock where a mutex is required (or vice versa).</td>\n<td align=\"left\">1. Reproduce with a stress test script (multiple <code>dd</code> commands). <br> 2. Add extensive <code>printk</code> logging within critical sections (be aware this changes timing). <br> 3. Look for <code>&quot;BUG: scheduling while atomic&quot;</code> or lockdep warnings in <code>dmesg</code>.</td>\n<td align=\"left\">1. Ensure every access to <code>dev-&gt;buffer</code>, <code>dev-&gt;data_size</code>, and <code>dev-&gt;read_position</code> (if used) is protected by <code>mutex_lock(&amp;dev-&gt;lock)</code>. <br> 2. Re-check conditions after acquiring the lock. For example, after acquiring the lock in <code>write</code>, verify <code>(dev-&gt;buffer_size - dev-&gt;data_size) &gt;= count</code> before proceeding. <br> 3. Use <code>mutex</code> (not spinlock) for all operations as <code>copy_to/from_user</code> and <code>wait_event</code> can sleep.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>poll</code> or <code>select</code> on the device file descriptor always returns &quot;readable&quot; even when the buffer is empty.</strong></td>\n<td align=\"left\">1. The <code>poll</code> handler (<code>mydevice_poll</code>) returns a mask with <code>POLLIN</code> unconditionally, without checking the actual device state. <br> 2. Forgetting to call <code>poll_wait</code> to register the wait queue with the poll table.</td>\n<td align=\"left\">1. Write a small userspace test program that uses <code>poll</code> and prints the returned <code>revents</code>. <br> 2. Check the <code>mydevice_poll</code> implementation: it should check <code>if (dev-&gt;data_size &gt; 0)</code> before setting <code>POLLIN</code>.</td>\n<td align=\"left\">1. Implement <code>mydevice_poll</code> as: call <code>poll_wait(file, &amp;dev-&gt;waitq, wait);</code>, then set `mask = 0; if (dev-&gt;data_size &gt; 0) mask</td>\n</tr>\n</tbody></table>\n<h3 id=\"kernel-specific-debugging-techniques\">Kernel-Specific Debugging Techniques</h3>\n<p>Debugging in kernel space requires a different toolbox. You cannot casually attach a debugger or rely on userspace core dumps. Instead, you become a detective interpreting the kernel&#39;s own logging and introspection interfaces.</p>\n<h4 id=\"mental-model-the-kernel39s-black-box-flight-recorder\">Mental Model: The Kernel&#39;s Black Box Flight Recorder</h4>\n<p>Imagine the running kernel as an airplane in flight. You, the developer on the ground, cannot step inside while it&#39;s flying. Instead, you rely on its <strong>flight data recorder</strong> (<code>printk</code> messages streamed to <code>dmesg</code>) and periodic <strong>maintenance telemetry</strong> (the <code>/proc</code> and <code>/sys</code> filesystems). When a problem occurs, you &quot;recover the black box&quot; (<code>dmesg</code>) and analyze the recorded events leading up to the failure. This passive observation, combined with targeted &quot;probe&quot; messages you insert (<code>printk</code>), forms the primary debugging methodology.</p>\n<h4 id=\"1-mastery-of-printk-and-dmesg\">1. Mastery of <code>printk</code> and <code>dmesg</code></h4>\n<p>The <code>printk</code> function is your most vital tool. It writes messages to a circular kernel log buffer, which you can read using the <code>dmesg</code> command.</p>\n<blockquote>\n<p><strong>Key Insight:</strong> <code>printk</code> messages have <strong>log levels</strong> (<code>KERN_EMERG</code>, <code>KERN_ALERT</code>, <code>KERN_CRIT</code>, <code>KERN_ERR</code>, <code>KERN_WARNING</code>, <code>KERN_NOTICE</code>, <code>KERN_INFO</code>, <code>KERN_DEBUG</code>). The console&#39;s current log level determines which messages appear on the console immediately (e.g., during a panic). Always specify a level: <code>printk(KERN_INFO &quot;Device opened\\n&quot;);</code>. The special <code>pr_info</code>, <code>pr_err</code>, etc., macros can be used as shorthand.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Technique</th>\n<th align=\"left\">Command/Action</th>\n<th align=\"left\">Purpose &amp; Interpretation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>View the entire kernel log</strong></td>\n<td align=\"left\"><code>sudo dmesg</code> or `sudo dmesg</td>\n<td align=\"left\">tail -50`</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Follow logs in real-time</strong></td>\n<td align=\"left\"><code>sudo dmesg -w</code> or <code>sudo tail -f /var/log/kern.log</code> (on some distros)</td>\n<td align=\"left\">Watch messages appear as they are generated, excellent for observing the sequence of operations.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Clear the log buffer</strong></td>\n<td align=\"left\"><code>sudo dmesg -C</code></td>\n<td align=\"left\">Start with a clean slate before reproducing an issue. Caution: this discards all previous messages.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Add strategic debug prints</strong></td>\n<td align=\"left\">In code: <code>printk(KERN_DEBUG &quot;%s: count=%zu, data_size=%zu\\n&quot;, __func__, count, dev-&gt;data_size);</code></td>\n<td align=\"left\">Trace the flow and values inside your functions. Use <code>__func__</code> to automatically include the function name.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Control console log level</strong></td>\n<td align=\"left\"><code>echo 8 &gt; /proc/sys/kernel/printk</code> (sets console log level to <code>KERN_DEBUG</code>, showing all messages)</td>\n<td align=\"left\">Force important debug messages to appear on the console immediately, not just in the buffer.</td>\n</tr>\n</tbody></table>\n<p><strong>Common <code>printk</code> Pitfalls:</strong></p>\n<ul>\n<li><strong>Forgetting the log level:</strong> <code>printk(&quot;hello&quot;)</code> defaults to <code>KERN_DEFAULT</code>, which may not appear in <code>dmesg</code> depending on configuration. Always use an explicit level.</li>\n<li><strong>Excessive logging:</strong> Flooding the log buffer can overwrite critical messages and slow down the system. Use <code>KERN_DEBUG</code> for high-volume traces and conditionally compile them out later.</li>\n<li><strong>Format specifier mismatches:</strong> Using <code>%d</code> for a <code>size_t</code> (which is <code>%zu</code>) or <code>%p</code> for a structure can cause garbled output or crashes. For kernel pointers, use <code>%pK</code> for security or <code>%p</code> for raw addresses.</li>\n</ul>\n<h4 id=\"2-inspecting-kernel-subsystems-via-proc-and-sys\">2. Inspecting Kernel Subsystems via <code>/proc</code> and <code>/sys</code></h4>\n<p>The kernel exposes a wealth of information through virtual filesystems. These provide a live view of the system&#39;s state without needing custom debug code.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Interface</th>\n<th align=\"left\">Path</th>\n<th align=\"left\">Information Relevant to Our Driver</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Loaded Modules</strong></td>\n<td align=\"left\"><code>/proc/modules</code></td>\n<td align=\"left\">Lists all loaded kernel modules, their memory usage, and reference counts. Verify your module is present and not accumulating references (which would prevent <code>rmmod</code>).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Registered Character Devices</strong></td>\n<td align=\"left\"><code>/proc/devices</code></td>\n<td align=\"left\">Shows the major numbers and names of registered character (and block) devices. Look for your device name (<code>mychardev</code>) and its dynamically assigned major number.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Device Nodes</strong></td>\n<td align=\"left\"><code>ls -l /dev/</code></td>\n<td align=\"left\">Check if your device node (e.g., <code>/dev/mychardev</code>) exists and has the correct major/minor number (matching <code>/proc/devices</code>). Verify permissions.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Kernel Taint Status</strong></td>\n<td align=\"left\"><code>/proc/sys/kernel/tainted</code></td>\n<td align=\"left\">A non-zero value indicates the kernel is &quot;tainted&quot; (e.g., by a non-GPL module, an out-of-tree module, or a hardware error). This affects the supportability of kernel bug reports.</td>\n</tr>\n</tbody></table>\n<p><strong>Understanding Kernel Taint:</strong></p>\n<blockquote>\n<p>A tainted kernel is one that has encountered a condition that could make it difficult to support (e.g., loading a proprietary module). The taint value is a bitmask. You can decode it using <code>scripts/decodecode</code> in the kernel source or by looking at the second field in <code>/proc/modules</code> (marked <code>P</code> for proprietary, <code>O</code> for out-of-tree, etc.). If your module lacks <code>MODULE_LICENSE(&quot;GPL&quot;)</code>, it will taint the kernel, which might restrict access to certain GPL-only symbols and cause your module to fail to load if it depends on them.</p>\n</blockquote>\n<h4 id=\"3-using-strace-to-trace-userspace-interactions\">3. Using <code>strace</code> to Trace Userspace Interactions</h4>\n<p>While <code>strace</code> is a userspace tool, it&#39;s invaluable for understanding how your userspace test program interacts with your driver through system calls. It shows you the exact <code>open</code>, <code>read</code>, <code>write</code>, <code>ioctl</code>, and <code>close</code> calls made, along with their arguments and return values.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Command</th>\n<th align=\"left\">Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">`strace ./userspace_test 2&gt;&amp;1</td>\n<td align=\"left\">less`</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strace -e trace=ioctl ./userspace_test</code></td>\n<td align=\"left\">Filter to show only <code>ioctl</code> calls. You can see the <code>cmd</code> and <code>arg</code> values passed, helping verify they match kernel expectations.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>strace -o trace.log ./userspace_test</code></td>\n<td align=\"left\">Save the full trace to a file for detailed analysis.</td>\n</tr>\n</tbody></table>\n<p><strong>Interpreting <code>strace</code> output for driver bugs:</strong></p>\n<ul>\n<li>If a system call returns <code>-1</code>, <code>strace</code> shows the <code>errno</code> (e.g., <code>EINVAL (22)</code>). This directly tells you the error code returned by your driver&#39;s handler.</li>\n<li>You can verify that the arguments (like buffer addresses and counts) match what your driver expects.</li>\n<li>If a <code>read</code> or <code>write</code> call blocks indefinitely, <code>strace</code> will hang, confirming the issue is in the kernel&#39;s blocking logic.</li>\n</ul>\n<h4 id=\"4-handling-kernel-oops-and-panics\">4. Handling Kernel Oops and Panics</h4>\n<p>An &quot;Oops&quot; is a kernel error that allows the system to continue running, often with a corrupted state. A &quot;panic&quot; is a fatal error that halts the system. Both produce a detailed message in <code>dmesg</code>.</p>\n<p><strong>When you encounter an Oops:</strong></p>\n<ol>\n<li><strong>Capture the entire output</strong> from <code>dmesg</code>. The most important part is the <strong>call trace</strong> (stack trace) and the <strong>instruction pointer</strong> (<code>RIP</code> or <code>EIP</code>).</li>\n<li><strong>Look for the offending module.</strong> The trace will show function names. If your module functions are listed (e.g., <code>mydevice_write+0x50/0x120</code>), the bug is in your code.</li>\n<li><strong>Decode the addresses.</strong> You can use the <code>addr2line</code> tool from your kernel build to map the offset (<code>0x50</code>) within the function to a source line: <code>addr2line -e mymodule.ko 0x50</code>. This requires the module to be built with debug symbols (<code>CONFIG_DEBUG_INFO</code> in the kernel config and <code>-g</code> in your Makefile&#39;s <code>CFLAGS</code>).</li>\n</ol>\n<blockquote>\n<p><strong>Design Insight:</strong> Always build your module with debug symbols (<code>EXTRA_CFLAGS += -g</code>) during development. This doesn&#39;t affect performance in the loadable module but dramatically improves the usefulness of Oops messages and allows use of tools like <code>kgdb</code> if you set up kernel debugging.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete code and commands to implement an effective debugging strategy for your driver.</p>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Simple Option</th>\n<th align=\"left\">Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Kernel Logging</strong></td>\n<td align=\"left\"><code>printk</code> with <code>KERN_DEBUG</code> level and <code>dmesg</code> viewing.</td>\n<td align=\"left\">Dynamic debug (<code>dynamic_debug.ko</code>) to enable/verbose debug prints at runtime via <code>/sys/kernel/debug/dynamic_debug/control</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Tracing System Calls</strong></td>\n<td align=\"left\"><code>strace</code> for userspace program tracing.</td>\n<td align=\"left\"><code>perf trace</code> for lower-overhead system-wide tracing, or kernel <code>ftrace</code> for tracing within the kernel.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Memory Error Detection</strong></td>\n<td align=\"left\">Careful code review and <code>printk</code>.</td>\n<td align=\"left\">Use <code>CONFIG_DEBUG_KMEMLEAK</code> in the kernel to detect memory leaks, or <code>CONFIG_KASAN</code> (KernelAddressSANitizer) for out-of-bounds and use-after-free detection (requires a custom kernel build).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Locking Validation</strong></td>\n<td align=\"left\">Manual review of mutex coverage.</td>\n<td align=\"left\">Enable <code>CONFIG_DEBUG_MUTEXES</code> and <code>CONFIG_PROVE_LOCKING</code> in the kernel to get runtime warnings for lock misuse and potential deadlocks.</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure-for-debugging\">B. Recommended File/Module Structure for Debugging</h4>\n<p>Place debug utilities and shared definitions in appropriate files to keep your main driver code clean.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project/\n  mychardev.c          # Main driver source\n  mychardev.h          # Shared ioctl definitions (used by kernel and userspace)\n  Makefile             # Kbuild Makefile\n  test/                # Userspace test programs\n    test_basic.c       # Simple read/write test\n    test_ioctl.c       # ioctl command test\n    test_concurrent.c  # Concurrency stress test</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code-a-simple-debug-macro\">C. Infrastructure Starter Code: A Simple Debug Macro</h4>\n<p>Add this to the top of your <code>mychardev.c</code> (after includes) to easily toggle debug prints. This is more flexible than commenting out <code>printk</code> statements.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// mychardev.c - Add near the top after includes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifdef</span><span style=\"color:#B392F0\"> DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> mydev_dbg</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_DEBUG DEVICE_NAME </span><span style=\"color:#9ECBFF\">\": </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: \"</span><span style=\"color:#E1E4E8\"> fmt, __func__, ##</span><span style=\"color:#B392F0\">__VA_ARGS__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#else</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> mydev_dbg</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...) </span><span style=\"color:#F97583\">do</span><span style=\"color:#E1E4E8\"> {} </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> mydev_info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_INFO DEVICE_NAME </span><span style=\"color:#9ECBFF\">\": \"</span><span style=\"color:#E1E4E8\"> fmt, ##</span><span style=\"color:#B392F0\">__VA_ARGS__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> mydev_err</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printk</span><span style=\"color:#E1E4E8\">(KERN_ERR DEVICE_NAME </span><span style=\"color:#9ECBFF\">\": ERROR: \"</span><span style=\"color:#E1E4E8\"> fmt, ##</span><span style=\"color:#B392F0\">__VA_ARGS__</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n<p>In your Makefile, you can add <code>-DDEBUG</code> to <code>EXTRA_CFLAGS</code> to enable the debug prints:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">makefile</span><pre class=\"arch-pre shiki-highlighted\"><code># To enable debug, add -DDEBUG\nEXTRA_CFLAGS += -DDEBUG</code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code-adding-debug-to-critical-functions\">D. Core Logic Skeleton Code: Adding Debug to Critical Functions</h4>\n<p>Here’s how to instrument the <code>mydevice_write</code> function with the debug macro. Apply similar patterns to other handlers.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydevice_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\"> __user </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                              size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">loff_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">f_pos</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">dev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> filp->private_data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> space_available;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mydev_dbg</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"entry: count=</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\">, data_size=</span><span style=\"color:#79B8FF\">%zu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, count, dev->data_size);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mutex_lock_interruptible</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev->lock))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ERESTARTSYS;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    space_available </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> dev->buffer_size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> dev->data_size;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mydev_dbg</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"space_available=</span><span style=\"color:#79B8FF\">%zu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, space_available);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (space_available </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mydev_dbg</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"buffer full, returning -ENOSPC</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">ENOSPC;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> out_unlock;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (count </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> space_available)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        count </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> space_available;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">copy_from_user</span><span style=\"color:#E1E4E8\">(dev->buffer </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> dev->data_size, buf, count)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mydev_err</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"copy_from_user failed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EFAULT;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#E1E4E8\"> out_unlock;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dev->data_size </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> count;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mydev_dbg</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"new data_size=</span><span style=\"color:#79B8FF\">%zu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, dev->data_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    retval </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> count;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Wake up any waiting readers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    wake_up_interruptible</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev->waitq);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mydev_dbg</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"woke up waitq</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">out_unlock:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dev->lock);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mydev_dbg</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"exit: returning </span><span style=\"color:#79B8FF\">%zd\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, retval);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> retval;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints-c-and-kernel\">E. Language-Specific Hints: C and Kernel</h4>\n<ul>\n<li><strong>Kernel <code>printk</code> Format Specifiers:</strong> Use <code>%zu</code> for <code>size_t</code>, <code>%zd</code> for <code>ssize_t</code>, <code>%p</code> for pointers, <code>%llu</code> for <code>unsigned long long</code>. For <code>dev_t</code> (major/minor), use <code>MAJOR(dev_num)</code> and <code>MINOR(dev_num)</code>.</li>\n<li><strong>Compiler Attributes:</strong> Use <code>__attribute__((unused))</code> on function parameters that you don&#39;t use (e.g., in <code>open</code> or <code>release</code>) to silence compiler warnings.</li>\n<li><strong>Include Debug Symbols:</strong> In your Makefile, add <code>-g</code> to <code>CFLAGS</code> to embed debug information. This allows <code>addr2line</code> to work after an Oops.</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">makefile</span><pre class=\"arch-pre shiki-highlighted\"><code>    ccflags-y += -g</code></pre></div>\n\n<h4 id=\"f-milestone-debugging-checkpoint\">F. Milestone Debugging Checkpoint</h4>\n<p>After each milestone, run these diagnostic commands to verify fundamental health before proceeding.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Milestone</th>\n<th align=\"left\">Command to Run</th>\n<th align=\"left\">Expected Output / Healthy Sign</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>1 (Load/Unload)</strong></td>\n<td align=\"left\">`sudo insmod mychardev.ko; sudo rmmod mychardev; dmesg</td>\n<td align=\"left\">tail -5`</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>2 (Char Device)</strong></td>\n<td align=\"left\"><code>ls -l /dev/mychardev</code></td>\n<td align=\"left\">The device file exists with major/minor numbers matching an entry in <code>/proc/devices</code>. <code>cat /proc/devices | grep mychardev</code> shows the major number.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>3 (ioctl/proc)</strong></td>\n<td align=\"left\"><code>sudo ./test/test_ioctl; cat /proc/mychardev</code></td>\n<td align=\"left\">The test program runs without <code>ioctl</code> errors (<code>errno</code>). The <code>/proc</code> entry displays current buffer size and data size.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>4 (Concurrency)</strong></td>\n<td align=\"left\">`sudo ./test/test_concurrent 2&gt;&amp;1</td>\n<td align=\"left\">grep -i error`</td>\n</tr>\n</tbody></table>\n<h4 id=\"g-debugging-tips-beyond-the-basics\">G. Debugging Tips: Beyond the Basics</h4>\n<p>If you encounter a particularly stubborn issue:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Symptom</th>\n<th align=\"left\">Likely Cause</th>\n<th align=\"left\">How to Diagnose</th>\n<th align=\"left\">Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Module cannot be removed with <code>rmmod</code></strong> (<code>rmmod: ERROR: Module mychardev is in use</code>)</td>\n<td align=\"left\">The device file is still open by a userspace process, or the module&#39;s reference count hasn&#39;t dropped to zero.</td>\n<td align=\"left\">Run <code>sudo lsof /dev/mychardev</code> to see which processes have it open. Check <code>/proc/modules</code> for the module&#39;s reference count.</td>\n<td align=\"left\">Ensure all test programs close the file descriptor. In <code>mydevice_release</code>, ensure you&#39;re not leaking a reference (e.g., improper <code>filp-&gt;private_data</code> management).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Kernel panic with NULL pointer dereference in your driver</strong></td>\n<td align=\"left\">Accessing a member of a <code>struct mydevice_data</code> pointer that is <code>NULL</code>.</td>\n<td align=\"left\">The Oops message will show the exact instruction. Look for lines in your code where you dereference <code>dev</code> without checking.</td>\n<td align=\"left\">In <code>mydevice_open</code>, ensure <code>filp-&gt;private_data</code> is set correctly. In all handlers, verify <code>private_data</code> is not <code>NULL</code> (though VFS should ensure this).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Data corruption only under heavy load</strong></td>\n<td align=\"left\">Race condition due to incomplete critical section or incorrect wait/wake logic.</td>\n<td align=\"left\">Add fine-grained <code>printk</code> inside and outside the mutex lock. Use a script to run many concurrent operations and capture the <code>dmesg</code> log, then look for impossible sequences.</td>\n<td align=\"left\">Extend the scope of the mutex lock to cover the entire sequence of checking condition and modifying data (the &quot;check-then-act&quot; pattern must be atomic).</td>\n</tr>\n</tbody></table>\n<p>By methodically applying these techniques, you can systematically isolate and resolve the unique challenges of kernel driver development, transforming inscrutable system hangs and crashes into understandable, fixable software bugs.</p>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1, Milestone 2, Milestone 3, Milestone 4 (building upon completed foundations for advanced learning)</p>\n</blockquote>\n<p>This section explores potential enhancements to the character device driver project that go beyond the core requirements. These extensions represent natural progression paths for deepening your understanding of Linux kernel programming, exploring alternative design patterns, and tackling more complex problems that real-world drivers face. Each suggestion includes a mental model to build intuition, an architecture decision framework for considering trade-offs, and implementation considerations to guide your exploration.</p>\n<h3 id=\"potential-enhancements\">Potential Enhancements</h3>\n<p>The completed driver implements a functional character device with proper concurrency handling, but real-world drivers often require more sophisticated features. These extensions allow you to explore specific kernel subsystems and design patterns in greater depth while building upon the existing codebase.</p>\n<h4 id=\"enhancement-1-circular-buffer-implementation\">Enhancement 1: Circular Buffer Implementation</h4>\n<p><strong>Mental Model: The Endless Scroll</strong>\nThink of the current linear buffer as a fixed-length whiteboard where writing starts at the beginning and erasing happens from the beginning. When the board fills, you must either erase everything (clear operation) or get a bigger board (resize operation). A circular buffer transforms this into a continuous scroll—like an endless tape loop where new data overwrites old data automatically when the loop completes, creating a rolling window of the most recent data without requiring manual clearing or resizing.</p>\n<p><strong>Implementation Considerations:</strong>\nReplacing the simple linear buffer with a circular buffer fundamentally changes how data is stored and accessed. Instead of tracking just <code>data_size</code>, you&#39;ll need read and write position indices that wrap around the buffer boundaries. This requires modifications to the <code>mydevice_read</code> and <code>mydevice_write</code> functions to handle wrap-around scenarios and properly calculate available space and data.</p>\n<blockquote>\n<p><strong>Decision: Fixed-Size Circular Buffer vs. Dynamic Circular Buffer</strong></p>\n<ul>\n<li><strong>Context</strong>: The driver currently uses a resizable linear buffer, but many real-world devices (like audio interfaces or network packet capture) benefit from fixed-size circular buffers that provide consistent performance and memory usage.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Fixed-size circular buffer</strong>: Pre-allocated buffer with constant size, overwriting oldest data when full</li>\n<li><strong>Dynamic circular buffer</strong>: Buffer that can resize while preserving the circular nature and data</li>\n<li><strong>Hybrid approach</strong>: Fixed-size buffer with configurable size at module load time via module parameters</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Start with a fixed-size circular buffer for simplicity and predictable behavior</li>\n<li><strong>Rationale</strong>: Fixed-size buffers eliminate allocation overhead during operation, prevent fragmentation, and simplify concurrency control. They also model many hardware devices that have fixed memory regions.</li>\n<li><strong>Consequences</strong>: Userspace must handle the case where writes may overwrite unread data; the driver will need to track overwrite counts or provide notification mechanisms.</li>\n</ul>\n</blockquote>\n<p><strong>Required Modifications to Data Structures:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>read_pos</code></td>\n<td><code>size_t</code></td>\n<td>Current read position index within the circular buffer</td>\n</tr>\n<tr>\n<td><code>write_pos</code></td>\n<td><code>size_t</code></td>\n<td>Current write position index within the circular buffer</td>\n</tr>\n<tr>\n<td><code>overwrite_count</code></td>\n<td><code>unsigned long</code></td>\n<td>Number of times data has been overwritten due to buffer wrap</td>\n</tr>\n<tr>\n<td><code>is_circular</code></td>\n<td><code>bool</code></td>\n<td>Flag indicating circular buffer mode is active</td>\n</tr>\n</tbody></table>\n<p><strong>Circular Buffer State Transitions:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Event</th>\n<th>Next State</th>\n<th>Action Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>EMPTY</td>\n<td>Write N bytes</td>\n<td>PARTIAL</td>\n<td><code>write_pos += N</code>, notify wait queue</td>\n</tr>\n<tr>\n<td>PARTIAL</td>\n<td>Write M bytes where <code>(write_pos + M) % buffer_size &gt; write_pos</code></td>\n<td>PARTIAL</td>\n<td><code>write_pos = (write_pos + M) % buffer_size</code></td>\n</tr>\n<tr>\n<td>PARTIAL</td>\n<td>Write M bytes causing wrap-around</td>\n<td>PARTIAL</td>\n<td><code>write_pos = (write_pos + M) % buffer_size</code>, increment <code>overwrite_count</code></td>\n</tr>\n<tr>\n<td>PARTIAL</td>\n<td>Read K bytes where <code>(read_pos + K) % buffer_size &gt; read_pos</code></td>\n<td>PARTIAL/EMPTY</td>\n<td><code>read_pos = (read_pos + K) % buffer_size</code>, if <code>read_pos == write_pos</code> transition to EMPTY</td>\n</tr>\n<tr>\n<td>PARTIAL</td>\n<td>Read causing wrap-around</td>\n<td>PARTIAL</td>\n<td><code>read_pos = (read_pos + K) % buffer_size</code></td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Steps:</strong></p>\n<ol>\n<li>Modify <code>buffer_init</code> to initialize <code>read_pos</code> and <code>write_pos</code> to 0</li>\n<li>Update <code>mydevice_write</code> to:<ul>\n<li>Calculate available space considering the circular nature</li>\n<li>Handle the case where a write needs to be split across the buffer end</li>\n<li>Update <code>write_pos</code> with wrap-around using modulo arithmetic</li>\n<li>Increment <code>overwrite_count</code> when <code>write_pos</code> passes <code>read_pos</code></li>\n</ul>\n</li>\n<li>Update <code>mydevice_read</code> to:<ul>\n<li>Calculate available data considering <code>read_pos</code> and <code>write_pos</code> positions</li>\n<li>Handle reads that cross the buffer boundary</li>\n<li>Update <code>read_pos</code> with proper wrap-around</li>\n</ul>\n</li>\n<li>Adjust <code>mydevice_ioctl</code> to support new commands for circular buffer statistics</li>\n<li>Update <code>/proc</code> interface to show circular buffer-specific metrics</li>\n</ol>\n<p><strong>New Ioctl Commands for Circular Buffer:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Command Name</th>\n<th>Macro</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>MYDEVICE_IOCTL_GET_OVERWRITES</code></td>\n<td><code>_IOR(MYDEVICE_IOC_MAGIC, 5, unsigned long)</code></td>\n<td>Retrieve count of data overwrites</td>\n</tr>\n<tr>\n<td><code>MYDEVICE_IOCTL_SET_CIRCULAR_MODE</code></td>\n<td><code>_IOW(MYDEVICE_IOC_MAGIC, 6, int)</code></td>\n<td>Enable/disable circular buffer mode (1=enabled, 0=linear)</td>\n</tr>\n<tr>\n<td><code>MYDEVICE_IOCTL_GET_AVAILABLE_SPACE</code></td>\n<td><code>_IOR(MYDEVICE_IOC_MAGIC, 7, size_t)</code></td>\n<td>Get free space in circular buffer</td>\n</tr>\n</tbody></table>\n<h4 id=\"enhancement-2-mmap-support-for-zero-copy-data-access\">Enhancement 2: mmap Support for Zero-Copy Data Access</h4>\n<p><strong>Mental Model: The Shared Memory Window</strong>\nCurrently, data transfer between userspace and kernelspace requires explicit copying through <code>copy_to_user</code> and <code>copy_from_user</code>. Imagine this as passing physical documents through a security checkpoint where each page must be inspected and copied. Adding <code>mmap</code> support creates a transparent window—like a two-way mirror—where userspace can directly read and write kernel memory without copying, dramatically improving performance for large data transfers.</p>\n<p><strong>Architecture Decision: Whole Buffer Mapping vs. Partial Mapping</strong></p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Recommended Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Map entire buffer</strong></td>\n<td>Simple implementation, consistent memory region</td>\n<td>Wastes virtual address space, exposes unused buffer areas</td>\n<td>Good starting point for learning</td>\n</tr>\n<tr>\n<td><strong>Map only used portion</strong></td>\n<td>Efficient virtual memory usage</td>\n<td>Requires remapping as buffer grows, complex boundary handling</td>\n<td>Advanced implementation</td>\n</tr>\n<tr>\n<td><strong>Multiple mapping regions</strong></td>\n<td>Allows different processes to map different sections</td>\n<td>Significantly more complex synchronization</td>\n<td>For specialized use cases</td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Requirements:</strong>\nThe <code>mmap</code> operation requires adding a <code>mmap</code> handler to the <code>struct file_operations</code>. The handler will use <code>remap_pfn_range</code> or <code>vm_insert_page</code> to map the kernel buffer pages into the calling process&#39;s address space. Special considerations include:</p>\n<ul>\n<li>Ensuring proper synchronization when userspace directly accesses kernel memory</li>\n<li>Handling page alignment requirements</li>\n<li>Managing reference counting to prevent use-after-free during module unload</li>\n</ul>\n<p><strong>Memory Protection Considerations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Protection Flag</th>\n<th>Kernel Action</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>PROT_READ</code></td>\n<td>Map pages as read-only</td>\n<td>Userspace only needs to read device data</td>\n</tr>\n<tr>\n<td><code>PROT_WRITE</code></td>\n<td>Map pages as writable</td>\n<td>Userspace needs to write to device buffer</td>\n</tr>\n<tr>\n<td><code>PROT_EXEC</code></td>\n<td>Should be denied (return <code>-EINVAL</code>)</td>\n<td>Execution from device buffer is unsafe</td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Steps:</strong></p>\n<ol>\n<li>Add <code>mydevice_mmap</code> function to <code>struct file_operations</code></li>\n<li>Implement <code>mydevice_mmap</code> to:<ul>\n<li>Validate requested protection flags and mapping size</li>\n<li>Calculate the starting page frame for the buffer</li>\n<li>Call <code>remap_pfn_range</code> to create the mapping</li>\n</ul>\n</li>\n<li>Add reference counting to <code>struct mydevice_data</code> to track active mappings</li>\n<li>Modify <code>mydevice_exit</code> to wait for all mappings to be released before freeing the buffer</li>\n<li>Consider adding <code>MYDEVICE_IOCTL_GET_PHYS_ADDR</code> command for advanced users who want to manage their own mappings</li>\n</ol>\n<p><strong>Potential Issues and Solutions:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Issue</th>\n<th>Cause</th>\n<th>Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Page alignment errors</td>\n<td>Buffer not page-aligned</td>\n<td>Use <code>kmalloc</code> with `GFP_KERNEL</td>\n</tr>\n<tr>\n<td>Concurrent modification</td>\n<td>Userspace writes via mmap while kernel writes via <code>mydevice_write</code></td>\n<td>Use <code>atomic_t</code> counters or finer-grained locking</td>\n</tr>\n<tr>\n<td>Module unload race</td>\n<td>Process accessing mapped memory after module unloaded</td>\n<td>Implement <code>is_shutting_down</code> flag and reference counting</td>\n</tr>\n</tbody></table>\n<h4 id=\"enhancement-3-multiple-device-instances-and-dynamic-minor-numbers\">Enhancement 3: Multiple Device Instances and Dynamic Minor Numbers</h4>\n<p><strong>Mental Model: The Device Factory</strong>\nCurrently, the driver creates a single device instance—like a factory that produces exactly one type of widget. Enhancing it to support multiple instances transforms it into a factory that can produce many independent widgets, each with its own buffer and state. This allows multiple applications to use their own private device instances without interfering with each other.</p>\n<p><strong>Design Approaches Comparison:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Implementation Complexity</th>\n<th>Resource Usage</th>\n<th>Flexibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Static array of devices</strong></td>\n<td>Simple, fixed maximum instances</td>\n<td>Wastes memory for unused instances</td>\n<td>Limited by compile-time constant</td>\n</tr>\n<tr>\n<td><strong>Linked list of devices</strong></td>\n<td>Moderate, dynamic creation/destruction</td>\n<td>Efficient memory usage</td>\n<td>Unlimited instances (subject to memory)</td>\n</tr>\n<tr>\n<td><strong>IDR (ID Radix Tree)</strong></td>\n<td>Complex, kernel-provided ID management</td>\n<td>Efficient for sparse instance numbers</td>\n<td>Best for large, sparse instance spaces</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Linked List for Dynamic Instance Management</strong></p>\n<ul>\n<li><strong>Context</strong>: The driver needs to support creation of multiple independent device instances, potentially at runtime via ioctl or module parameters.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Static array</strong>: Simple but wastes resources and has fixed limits</li>\n<li><strong>Linked list</strong>: Dynamic, memory-efficient, but requires manual management</li>\n<li><strong>IDR with hash table</strong>: Most scalable but highest complexity</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement linked list for manageable complexity with good dynamic behavior</li>\n<li><strong>Rationale</strong>: Linked lists are a fundamental kernel data structure with predictable behavior. They allow dynamic growth without predefined limits while being understandable for educational purposes.</li>\n<li><strong>Consequences</strong>: Requires careful locking for list operations, must handle cleanup of all instances during module exit.</li>\n</ul>\n</blockquote>\n<p><strong>Enhanced Data Model for Multiple Instances:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Structure Name</th>\n<th>Fields</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>struct mydevice_instance</code></td>\n<td><code>struct list_head list</code>, <code>struct mydevice_data data</code>, <code>int instance_id</code></td>\n<td>Represents one device instance</td>\n</tr>\n<tr>\n<td><code>struct mydevice_global</code></td>\n<td><code>struct list_head instances</code>, <code>struct mutex instances_lock</code>, <code>int next_instance_id</code></td>\n<td>Global state for managing all instances</td>\n</tr>\n</tbody></table>\n<p><strong>Instance Management Operations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Function</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Create instance</td>\n<td><code>mydevice_create_instance(minor_num)</code></td>\n<td>Allocates and initializes new instance, adds to global list</td>\n</tr>\n<tr>\n<td>Destroy instance</td>\n<td><code>mydevice_destroy_instance(instance_id)</code></td>\n<td>Removes instance from list, frees resources</td>\n</tr>\n<tr>\n<td>Find instance</td>\n<td><code>mydevice_find_instance(minor_num)</code></td>\n<td>Searches list for instance matching minor number</td>\n</tr>\n<tr>\n<td>List all instances</td>\n<td><code>mydevice_list_instances()</code></td>\n<td>Iterates through list (for <code>/proc</code> interface)</td>\n</tr>\n</tbody></table>\n<p><strong>Device Node Naming Scheme:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Minor Number</th>\n<th>Device Node</th>\n<th>Instance ID</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td><code>/dev/mychardev0</code></td>\n<td>Primary instance (backward compatible)</td>\n</tr>\n<tr>\n<td>1</td>\n<td><code>/dev/mychardev1</code></td>\n<td>Secondary instance</td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>/dev/mychardev2</code></td>\n<td>Tertiary instance</td>\n</tr>\n<tr>\n<td>...</td>\n<td>...</td>\n<td>...</td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Steps:</strong></p>\n<ol>\n<li>Refactor <code>struct mydevice_data</code> to remove singleton assumptions</li>\n<li>Create <code>struct mydevice_instance</code> wrapper with list head and instance ID</li>\n<li>Implement global instance list with protection mutex</li>\n<li>Modify <code>mydevice_open</code> to identify which instance based on minor number</li>\n<li>Add <code>MYDEVICE_IOCTL_CREATE_INSTANCE</code> and <code>MYDEVICE_IOCTL_DESTROY_INSTANCE</code> commands</li>\n<li>Update <code>/proc</code> interface to show all instances and their statistics</li>\n<li>Ensure <code>mydevice_exit</code> cleans up all instances</li>\n</ol>\n<p><strong>Concurrency Considerations:</strong></p>\n<ul>\n<li>Use a global mutex (<code>instances_lock</code>) to protect the instance list</li>\n<li>Each instance has its own buffer mutex for local operations</li>\n<li><code>mydevice_open</code> must find the instance before incrementing its reference count</li>\n</ul>\n<h4 id=\"enhancement-4-device-tree-integration-for-hardware-configuration\">Enhancement 4: Device Tree Integration for Hardware Configuration</h4>\n<p><strong>Mental Model: The Architectural Blueprint</strong>\nCurrently, the driver configuration (buffer size, device name) is hardcoded or set via ioctl at runtime. Device Tree integration provides an architectural blueprint that the kernel reads at boot time—like a building plan that specifies where electrical outlets go, what materials to use, and how rooms connect. This allows the same driver binary to work with different hardware configurations without code changes.</p>\n<p><strong>Device Tree vs. Traditional Configuration Methods:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>When Used</th>\n<th>Advantages</th>\n<th>Disadvantages</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Compile-time constants</strong></td>\n<td>Simple software-only drivers</td>\n<td>Simple, no runtime overhead</td>\n<td>Requires recompilation for changes</td>\n</tr>\n<tr>\n<td><strong>Module parameters</strong></td>\n<td>Loadable modules with user-configurable options</td>\n<td>Flexible at module load time</td>\n<td>Not discoverable, manual configuration</td>\n</tr>\n<tr>\n<td><strong>Platform data</strong></td>\n<td>Embedded systems with board files</td>\n<td>Board-specific configuration</td>\n<td>Not portable across architectures</td>\n</tr>\n<tr>\n<td><strong>Device Tree</strong></td>\n<td>Modern ARM, PowerPC, RISC-V systems</td>\n<td>Hardware description separate from driver, portable</td>\n<td>Complex syntax, parser overhead</td>\n</tr>\n</tbody></table>\n<p><strong>Example Device Tree Node:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">dts</span><pre class=\"arch-pre shiki-highlighted\"><code>mychardev: mychardev@1000 {\n    compatible = &quot;custom,mychardev-1.0&quot;;\n    reg = &lt;0x1000 0x1000&gt;;          // MMIO region\n    buffer-size = &lt;0x4000&gt;;         // 16KB buffer\n    circular-mode;                  // Enable circular buffer\n    instance-count = &lt;2&gt;;           // Create 2 instances\n    status = &quot;okay&quot;;\n};</code></pre></div>\n\n<p><strong>Driver Modifications for Device Tree Support:</strong></p>\n<ol>\n<li>Add <code>of_match_table</code> to declare compatible strings</li>\n<li>Implement probe function to parse Device Tree properties</li>\n<li>Map <code>reg</code> regions for memory-mapped I/O (if simulating hardware)</li>\n<li>Use parsed properties to configure buffer size and operation mode</li>\n</ol>\n<p><strong>Device Tree Property Mapping:</strong></p>\n<table>\n<thead>\n<tr>\n<th>DT Property</th>\n<th>Kernel Data Type</th>\n<th>Driver Field</th>\n<th>Default Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>buffer-size</code></td>\n<td><code>u32</code></td>\n<td><code>buffer_size</code></td>\n<td><code>BUFFER_SIZE</code> (1024)</td>\n</tr>\n<tr>\n<td><code>circular-mode</code></td>\n<td>Boolean flag</td>\n<td><code>is_circular</code></td>\n<td><code>false</code></td>\n</tr>\n<tr>\n<td><code>instance-count</code></td>\n<td><code>u32</code></td>\n<td>Number of instances to create</td>\n<td>1</td>\n</tr>\n<tr>\n<td><code>reg</code></td>\n<td><code>struct resource</code></td>\n<td>For MMIO simulation (optional)</td>\n<td>N/A</td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Steps:</strong></p>\n<ol>\n<li>Add <code>#include &lt;linux/of.h&gt;</code> and <code>#include &lt;linux/of_device.h&gt;</code></li>\n<li>Define <code>of_device_id</code> table with compatible strings:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> of_device_id mychardev_of_match</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       { .compatible </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"custom,mychardev-1.0\"</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       { },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   };</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   MODULE_DEVICE_TABLE</span><span style=\"color:#E1E4E8\">(of, mychardev_of_match);</span></span></code></pre></div>\n<ol start=\"3\">\n<li>Implement <code>mydevice_probe</code> function to:<ul>\n<li>Parse Device Tree properties using <code>of_property_read_u32</code></li>\n<li>Allocate and initialize device instances based on configuration</li>\n<li>Map MMIO regions if <code>reg</code> property exists</li>\n</ul>\n</li>\n<li>Register platform driver structure</li>\n<li>Update Kbuild to compile conditionally based on <code>CONFIG_OF</code></li>\n</ol>\n<p><strong>Simulating Hardware for Learning:</strong>\nSince this is an educational project without real hardware, you can simulate memory-mapped I/O by:</p>\n<ol>\n<li>Using <code>ioremap</code> on a dummy physical address (ensure it&#39;s not in use)</li>\n<li>Implementing simple register read/write operations that manipulate the software buffer</li>\n<li>Adding interrupt simulation using a kernel timer to trigger simulated data arrival</li>\n</ol>\n<p><strong>Advanced Extension: Platform Driver Integration</strong>\nTransform the driver into a full platform driver that can be bound to Device Tree nodes:</p>\n<ol>\n<li>Create <code>struct platform_driver</code> with probe, remove, and driver fields</li>\n<li>Use <code>platform_get_resource</code> to get memory regions</li>\n<li>Handle power management callbacks (<code>suspend</code>, <code>resume</code>)</li>\n<li>Support multiple platform devices through Device Tree</li>\n</ol>\n<h4 id=\"enhancement-5-sysfs-interface-for-runtime-configuration\">Enhancement 5: SysFS Interface for Runtime Configuration</h4>\n<p><strong>Mental Model: The Control Knobs and Dials</strong>\nWhile <code>/proc</code> provides a read-oriented dashboard for monitoring, SysFS offers writable control knobs and dials—like the control panel of a machine where operators can adjust settings while it&#39;s running. Each SysFS attribute represents a single controllable parameter with defined access permissions.</p>\n<p><strong>SysFS vs. ProcFS vs. Ioctl Comparison:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Interface</th>\n<th>Best For</th>\n<th>Access Pattern</th>\n<th>Example Use</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Ioctl</strong></td>\n<td>Complex operations with structured data</td>\n<td>Programmatic, binary data</td>\n<td><code>ioctl(fd, RESIZE_BUFFER, &amp;new_size)</code></td>\n</tr>\n<tr>\n<td><strong>ProcFS</strong></td>\n<td>Human-readable status information</td>\n<td>Read-mostly, text format</td>\n<td><code>cat /proc/mychardev/stats</code></td>\n</tr>\n<tr>\n<td><strong>SysFS</strong></td>\n<td>Simple parameter access (one value per file)</td>\n<td>Read/write, text format</td>\n<td><code>echo 8192 &gt; /sys/class/mychardev/mychardev0/buffer_size</code></td>\n</tr>\n</tbody></table>\n<p><strong>SysFS Attribute Design:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Attribute Name</th>\n<th>Permission</th>\n<th>Data Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>buffer_size</code></td>\n<td><code>0644</code> (root can write)</td>\n<td>Decimal integer</td>\n<td>Current buffer size in bytes</td>\n</tr>\n<tr>\n<td><code>data_size</code></td>\n<td><code>0444</code> (read-only)</td>\n<td>Decimal integer</td>\n<td>Amount of data currently stored</td>\n</tr>\n<tr>\n<td><code>mode</code></td>\n<td><code>0644</code></td>\n<td>String (&quot;linear&quot; or &quot;circular&quot;)</td>\n<td>Buffer operating mode</td>\n</tr>\n<tr>\n<td><code>overwrites</code></td>\n<td><code>0444</code></td>\n<td>Decimal integer</td>\n<td>Count of data overwrites (circular mode)</td>\n</tr>\n<tr>\n<td><code>reset</code></td>\n<td><code>0200</code> (write-only)</td>\n<td>Write &quot;1&quot; to clear buffer</td>\n<td>Clear all data in buffer</td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Steps:</strong></p>\n<ol>\n<li>Add SysFS attribute declarations using <code>DEVICE_ATTR_RW</code>, <code>DEVICE_ATTR_RO</code>, <code>DEVICE_ATTR_WO</code> macros</li>\n<li>Implement show/store functions for each attribute</li>\n<li>Create attribute group and register with device class</li>\n<li>Ensure proper locking in store functions (use existing mutex)</li>\n<li>Add error handling for invalid input values</li>\n</ol>\n<p><strong>Example SysFS Store Function:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> buffer_size_store</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> device </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">dev</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                 struct</span><span style=\"color:#E1E4E8\"> device_attribute </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">attr</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                 const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">mydata </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dev_get_drvdata</span><span style=\"color:#E1E4E8\">(dev);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> new_size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> err;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kstrtoul</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">new_size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (err)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (new_size </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> MAX_BUFFER_SIZE </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> new_size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">mydata->lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> buffer_resize</span><span style=\"color:#E1E4E8\">(mydata, new_size);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">mydata->lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> count;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"enhancement-6-advanced-synchronization-with-read-write-locks\">Enhancement 6: Advanced Synchronization with Read-Write Locks</h4>\n<p><strong>Mental Model: The Library with Multiple Reading Rooms</strong>\nThe current mutex implementation is like a library with a single room that only one person can enter at a time. Read-write locks transform this into a library with a reading room that allows multiple readers simultaneously but only one writer at a time—like allowing many people to read books concurrently but only one person to reorganize the shelves.</p>\n<p><strong>When to Use Read-Write Locks:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Current Mutex</th>\n<th>Read-Write Lock</th>\n<th>Benefit</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Many concurrent readers</td>\n<td>Readers serialize</td>\n<td>All readers proceed concurrently</td>\n<td>Higher throughput for read-heavy workloads</td>\n</tr>\n<tr>\n<td>Frequent writes</td>\n<td>Appropriate</td>\n<td>Writers still serialize</td>\n<td>No benefit, adds overhead</td>\n</tr>\n<tr>\n<td>Mixed workload</td>\n<td>Simple, predictable</td>\n<td>Allows reads during writes</td>\n<td>Moderate improvement</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Selective Read-Write Lock Implementation</strong></p>\n<ul>\n<li><strong>Context</strong>: The driver currently uses a single mutex for all buffer operations, which may limit performance in read-heavy scenarios.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Replace mutex with read-write lock</strong>: Simple substitution but may not benefit write-heavy workloads</li>\n<li><strong>Fine-grained locking with multiple mutexes</strong>: Complex but allows more parallelism</li>\n<li><strong>Read-copy-update (RCU)</strong>: Advanced technique for extremely read-heavy cases</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement optional read-write lock mode selectable via ioctl</li>\n<li><strong>Rationale</strong>: This allows comparison between mutex and read-write lock performance while maintaining backward compatibility. The educational value of implementing both is high.</li>\n<li><strong>Consequences</strong>: More complex code, need to handle mode switching safely, potential for writer starvation if not configured properly.</li>\n</ul>\n</blockquote>\n<p><strong>Implementation Strategy:</strong></p>\n<ol>\n<li>Add <code>rwlock_t</code> or <code>struct rw_semaphore</code> to <code>struct mydevice_data</code></li>\n<li>Create <code>use_rwlock</code> flag to select locking mode</li>\n<li>Implement helper functions that use appropriate locking based on mode:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   void</span><span style=\"color:#B392F0\"> mydevice_lock_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">mydata</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       if</span><span style=\"color:#E1E4E8\"> (mydata->use_rwlock)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">           down_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">mydata->rw_sem);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       else</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">           mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">mydata->lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n<ol start=\"4\">\n<li>Add <code>MYDEVICE_IOCTL_SET_LOCKING_MODE</code> command</li>\n<li>Update all code paths to use the appropriate lock/unlock helpers</li>\n</ol>\n<p><strong>Performance Measurement:</strong>\nAdd statistics to track lock contention:</p>\n<table>\n<thead>\n<tr>\n<th>Metric</th>\n<th>Measurement Method</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Read lock acquisitions</td>\n<td>Atomic counter incremented in <code>mydevice_lock_read</code></td>\n<td>Compare mutex vs. rwlock throughput</td>\n</tr>\n<tr>\n<td>Write lock acquisitions</td>\n<td>Atomic counter in <code>mydevice_lock_write</code></td>\n<td>Measure write frequency</td>\n</tr>\n<tr>\n<td>Contention count</td>\n<td><code>lockstat</code> kernel infrastructure or custom timing</td>\n<td>Identify bottlenecks</td>\n</tr>\n</tbody></table>\n<h4 id=\"enhancement-7-asynchronous-io-aio-support\">Enhancement 7: Asynchronous I/O (AIO) Support</h4>\n<p><strong>Mental Model: The Restaurant with Order Tickets</strong>\nCurrent blocking I/O is like a restaurant where each customer must wait at the counter until their order is ready. Asynchronous I/O transforms this into a system where customers submit order tickets and can do other things while waiting—they&#39;re notified when their order is complete. This allows a single application to manage multiple concurrent I/O operations without threads.</p>\n<p><strong>Linux AIO Mechanisms Comparison:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Mechanism</th>\n<th>Interface</th>\n<th>Complexity</th>\n<th>Best For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Kernel AIO</strong></td>\n<td><code>io_submit</code>, <code>io_getevents</code></td>\n<td>High</td>\n<td>High-performance servers, database systems</td>\n</tr>\n<tr>\n<td><strong>POSIX AIO</strong></td>\n<td><code>aio_read</code>, <code>aio_write</code></td>\n<td>Moderate</td>\n<td>Portable asynchronous I/O</td>\n</tr>\n<tr>\n<td><strong>epoll with O_NONBLOCK</strong></td>\n<td><code>epoll_ctl</code>, non-blocking file descriptors</td>\n<td>Low to moderate</td>\n<td>Mixed synchronous/asynchronous patterns</td>\n</tr>\n</tbody></table>\n<p><strong>Implementing <code>aio_read</code> and <code>aio_write</code>:</strong></p>\n<ol>\n<li>Add <code>aio_read</code> and <code>aio_write</code> handlers to <code>struct file_operations</code></li>\n<li>Implement completion callback mechanism using <code>kiocb</code> structure</li>\n<li>Use work queues or kernel threads to process requests asynchronously</li>\n<li>Ensure proper synchronization with existing buffer operations</li>\n</ol>\n<p><strong>Example AIO Read Implementation Outline:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> ssize_t</span><span style=\"color:#B392F0\"> mydevice_aio_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> kiocb </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">iocb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> iov_iter </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">iter</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">mydata </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> iocb->ki_filp->private_data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">mydata->lock);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (mydata->data_size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Queue for asynchronous completion</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        INIT_WORK</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">iocb->ki_wait.work, mydevice_aio_complete_read);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        queue_work</span><span style=\"color:#E1E4E8\">(mydata->aio_wq, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">iocb->ki_wait.work);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">mydata->lock);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\">EIOCBQUEUED;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Synchronous completion if data available</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> mydevice_read_copy</span><span style=\"color:#E1E4E8\">(mydata, iter);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">mydata->lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        iocb-></span><span style=\"color:#B392F0\">ki_complete</span><span style=\"color:#E1E4E8\">(iocb, ret, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Integration with Existing Infrastructure:</strong></p>\n<ul>\n<li>Modify wait queue to notify both blocking readers and AIO completions</li>\n<li>Create dedicated work queue for AIO operations</li>\n<li>Add reference counting to ensure AIO operations complete before module unload</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<blockquote>\n<p><strong>Note</strong>: These extensions are presented as independent learning paths. Choose one based on your interests and implement it incrementally, testing each change thoroughly before proceeding to the next.</p>\n</blockquote>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Circular Buffer</strong></td>\n<td>Fixed-size circular buffer with simple wrap-around</td>\n<td>Dynamic circular buffer with configurable watermark levels</td>\n</tr>\n<tr>\n<td><strong>mmap Support</strong></td>\n<td>Whole-buffer mapping with read-only access</td>\n<td>Partial mapping with configurable protection flags</td>\n</tr>\n<tr>\n<td><strong>Multiple Instances</strong></td>\n<td>Static array of instances (compile-time limit)</td>\n<td>Linked list with dynamic creation/destruction via ioctl</td>\n</tr>\n<tr>\n<td><strong>Device Tree</strong></td>\n<td>Basic property parsing for configuration</td>\n<td>Full platform driver with power management and interrupt simulation</td>\n</tr>\n<tr>\n<td><strong>SysFS Interface</strong></td>\n<td>Read-only attributes for statistics</td>\n<td>Read-write attributes with validation and change notification</td>\n</tr>\n<tr>\n<td><strong>Synchronization</strong></td>\n<td>Mutex for all operations</td>\n<td>Read-write locks with performance counters</td>\n</tr>\n<tr>\n<td><strong>Asynchronous I/O</strong></td>\n<td>epoll with non-blocking mode</td>\n<td>Full kernel AIO support with completion queues</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-file-structure-for-extensions\">B. Recommended File Structure for Extensions</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  ├── mychardev.c              # Main driver (existing)\n  ├── mychardev.h              # Shared header (existing)\n  ├── test_userspace.c         # Test program (existing)\n  ├── Makefile                 # Build file (existing)\n  ├── circular-buffer-example/ # Optional: Circular buffer extension\n  │   ├── circular.c           # Circular buffer implementation\n  │   └── circular.h           # Circular buffer interface\n  ├── mmap-example/            # Optional: mmap extension\n  │   └── mmap-impl.c          # mmap handler implementation\n  ├── multi-instance-example/  # Optional: Multiple instances\n  │   └── instance-mgr.c       # Instance management code\n  └── device-tree-example/     # Optional: Device Tree support\n      ├── mychardev.dts        # Example Device Tree source\n      └── dt-probe.c           # Device Tree probe function</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code-circular-buffer-helper\">C. Infrastructure Starter Code: Circular Buffer Helper</h4>\n<p>For the circular buffer extension, here&#39;s a complete helper module you can integrate:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* circular-buffer.h - Circular buffer helper interface */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> CIRCULAR_BUFFER_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CIRCULAR_BUFFER_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/types.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/mutex.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> circular_buffer {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> read_pos;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> write_pos;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> overwrite_count;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> mutex lock;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Initialize a circular buffer */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> circular_buffer_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> circular_buffer </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">cb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Clean up a circular buffer */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> circular_buffer_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> circular_buffer </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">cb</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Get amount of data available to read */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#B392F0\"> circular_buffer_data_available</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> circular_buffer </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">cb</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Get free space available for writing */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#B392F0\"> circular_buffer_free_space</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> circular_buffer </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">cb</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Write data to circular buffer, returns bytes written */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#B392F0\"> circular_buffer_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> circular_buffer </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">cb</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                             const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">user_buf</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                             size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Read data from circular buffer, returns bytes read */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#B392F0\"> circular_buffer_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> circular_buffer </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">cb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                            char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">user_buf</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                            size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Clear the circular buffer */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> circular_buffer_clear</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> circular_buffer </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">cb</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Resize circular buffer, preserving data if possible */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> circular_buffer_resize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> circular_buffer </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">cb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> new_size</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> /* CIRCULAR_BUFFER_H */</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-mmap-handler-implementation\">D. Core Logic Skeleton: mmap Handler Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* In mychardev.c, add to file_operations */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> file_operations mychardev_fops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .owner </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> THIS_MODULE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .open </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_open,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .release </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_release,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .read </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_read,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .write </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_write,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .unlocked_ioctl </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_ioctl,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .poll </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_poll,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .mmap </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mydevice_mmap,</span><span style=\"color:#6A737D\">  /* NEW: Add mmap handler */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Skeleton for mmap implementation */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mydevice_mmap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">filp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> vm_area_struct </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">vma</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> mydevice_data </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">mydata </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> filp->private_data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> vma->vm_pgoff </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> PAGE_SHIFT;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> vma->vm_end </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> vma->vm_start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> pfn;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 1: Check if mapping request is valid */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* - Ensure offset is 0 (we only map from buffer start) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* - Ensure size doesn't exceed buffer size */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* - Check protection flags (deny PROT_EXEC) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 2: Calculate physical page frame number for buffer */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* - Use virt_to_phys on buffer address */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* - Convert to page frame number (pfn = phys >> PAGE_SHIFT) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 3: Map pages into userspace */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* - Call remap_pfn_range with vma, vma->vm_start, pfn, size, vma->vm_page_prot */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* - Handle return value (0 on success, negative error on failure) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* TODO 4: Update reference counting */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* - Increment mapping count to prevent premature buffer free */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* - Consider using vma->vm_ops for open/close notifications */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints-for-kernel-c\">E. Language-Specific Hints for Kernel C</h4>\n<ol>\n<li><p><strong>Memory Barriers</strong>: When implementing circular buffers, use appropriate memory barriers (<code>smp_rmb()</code>, <code>smp_wmb()</code>) to ensure read/write positions are visible in the correct order on SMP systems.</p>\n</li>\n<li><p><strong>Page Alignment</strong>: For mmap, ensure your buffer is page-aligned by using <code>__get_free_pages</code> or <code>kmalloc</code> with alignment constraints rather than simple <code>kmalloc</code>.</p>\n</li>\n<li><p><strong>Reference Counting</strong>: Use <code>kref</code> or <code>refcount_t</code> for managing object lifetimes with multiple references (mmap mappings, AIO operations).</p>\n</li>\n<li><p><strong>Work Queues</strong>: For AIO implementations, create a dedicated workqueue with <code>alloc_workqueue</code> rather than using the shared system workqueue to avoid priority inversion.</p>\n</li>\n<li><p><strong>Device Tree Parsing</strong>: Use <code>of_property_read_*</code> functions which return error codes rather than <code>of_get_property</code> followed by manual parsing.</p>\n</li>\n</ol>\n<h4 id=\"f-milestone-checkpoint-for-extensions\">F. Milestone Checkpoint for Extensions</h4>\n<p>After implementing any extension, verify with these tests:</p>\n<table>\n<thead>\n<tr>\n<th>Extension</th>\n<th>Test Command</th>\n<th>Expected Result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Circular Buffer</strong></td>\n<td><code>echo &quot;test&quot; &gt; /dev/mychardev0; cat /dev/mychardev0</code></td>\n<td>Should return &quot;test&quot; immediately</td>\n</tr>\n<tr>\n<td><strong>Circular Buffer</strong></td>\n<td>Write more data than buffer size, then read</td>\n<td>Should get most recent data (oldest overwritten)</td>\n</tr>\n<tr>\n<td><strong>mmap Support</strong></td>\n<td><code>sudo dd if=/dev/mychardev0 of=/dev/null bs=4096 count=1</code></td>\n<td>Should succeed without copy_to_user overhead</td>\n</tr>\n<tr>\n<td><strong>Multiple Instances</strong></td>\n<td><code>echo &quot;instance1&quot; &gt; /dev/mychardev0; echo &quot;instance2&quot; &gt; /dev/mychardev1</code></td>\n<td>Each instance maintains separate data</td>\n</tr>\n<tr>\n<td><strong>Device Tree</strong></td>\n<td>Boot with Device Tree containing mychardev node</td>\n<td>Driver should auto-configure based on DT properties</td>\n</tr>\n<tr>\n<td><strong>SysFS</strong></td>\n<td><code>cat /sys/class/mychardev/mychardev0/buffer_size</code></td>\n<td>Should show current buffer size in decimal</td>\n</tr>\n</tbody></table>\n<h4 id=\"g-debugging-tips-for-extensions\">G. Debugging Tips for Extensions</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>mmap segfault</strong></td>\n<td>Buffer not page-aligned</td>\n<td>Check <code>virt_to_phys</code> return value</td>\n<td>Use <code>get_zeroed_page</code> or aligned allocation</td>\n</tr>\n<tr>\n<td><strong>Circular buffer data corruption</strong></td>\n<td>Race condition between read_pos/write_pos updates</td>\n<td>Add memory barriers between position updates</td>\n<td>Use <code>smp_store_release</code> and <code>smp_load_acquire</code></td>\n</tr>\n<tr>\n<td><strong>Multiple instances interfere</strong></td>\n<td>Global variables still used</td>\n<td>Search for non-instance-specific variables</td>\n<td>Move all state to <code>struct mydevice_instance</code></td>\n</tr>\n<tr>\n<td><strong>Device Tree properties ignored</strong></td>\n<td>Wrong compatible string</td>\n<td>Check kernel log for probe failures</td>\n<td>Ensure <code>compatible</code> string matches driver table</td>\n</tr>\n<tr>\n<td><strong>SysFS permission denied</strong></td>\n<td>Wrong attribute permissions</td>\n<td>Check <code>mode</code> parameter in <code>DEVICE_ATTR_*</code></td>\n<td>Use appropriate permission macros</td>\n</tr>\n<tr>\n<td><strong>AIO operation hangs</strong></td>\n<td>Completion not called</td>\n<td>Add <code>printk</code> to completion callback</td>\n<td>Ensure <code>ki_complete</code> is called on all code paths</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1, Milestone 2, Milestone 3, Milestone 4 (foundational vocabulary for all concepts)</p>\n</blockquote>\n<p>This section defines key technical terms, acronyms, and Linux kernel-specific vocabulary used throughout this design document. Understanding these terms is essential for navigating the Linux kernel programming ecosystem and implementing the character device driver.</p>\n<h3 id=\"terms-and-definitions\">Terms and Definitions</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>alloc_chrdev_region</strong></td>\n<td>A kernel function that dynamically allocates a range of character device numbers (major/minor pairs) from the kernel&#39;s available pool, avoiding conflicts with statically assigned numbers. Returns the starting device number in a <code>dev_t</code>.</td>\n</tr>\n<tr>\n<td><strong>Blocking I/O</strong></td>\n<td>Input/output operations that cause the calling process to sleep (wait) until data becomes available for reading or space becomes available for writing. Contrasts with non-blocking I/O, which returns immediately with whatever data is available or an error.</td>\n</tr>\n<tr>\n<td><strong>Character Device</strong></td>\n<td>A type of Linux device that handles data as a stream of bytes (like a serial port or terminal), as opposed to block devices that handle data in fixed-size blocks. Accessed through file operations like <code>read()</code>, <code>write()</code>, and <code>ioctl()</code> via a file in <code>/dev</code>.</td>\n</tr>\n<tr>\n<td><strong>class</strong></td>\n<td>In the Linux device model, a grouping of devices with similar characteristics or functions. Created with <code>class_create()</code>, it appears in sysfs (<code>/sys/class/</code>) and enables automatic device node creation in <code>/dev</code> via <code>udev</code> or <code>mdev</code>.</td>\n</tr>\n<tr>\n<td><strong>class_create</strong></td>\n<td>Kernel function that creates a device class object in sysfs. This class is used by <code>device_create()</code> to automatically create device nodes when the driver registers a device.</td>\n</tr>\n<tr>\n<td><strong>copy_from_user</strong></td>\n<td>Kernel function that safely copies data from user-space memory to kernel-space memory. It validates the user-space pointer, handles page faults, and returns the number of bytes that could not be copied (0 on success). Critical for security—never dereference user pointers directly.</td>\n</tr>\n<tr>\n<td><strong>copy_to_user</strong></td>\n<td>Kernel function that safely copies data from kernel-space memory to user-space memory. Like <code>copy_from_user</code>, it validates the destination pointer and handles faults, returning the number of bytes not copied.</td>\n</tr>\n<tr>\n<td><strong>Critical Section</strong></td>\n<td>A segment of code that accesses shared resources (data structures, hardware registers) and must be executed by only one thread or process at a time to prevent race conditions. Protected by synchronization primitives like mutexes or spinlocks.</td>\n</tr>\n<tr>\n<td><strong>cdev</strong></td>\n<td>Kernel structure (<code>struct cdev</code>) representing a character device internally. Initialized with <code>cdev_init()</code> and added to the system with <code>cdev_add()</code>, it links a device number with its <code>file_operations</code> handlers.</td>\n</tr>\n<tr>\n<td><strong>cdev_add</strong></td>\n<td>Function that registers a <code>cdev</code> structure with the kernel, making the character device operational and reachable through its device number.</td>\n</tr>\n<tr>\n<td><strong>cdev_init</strong></td>\n<td>Function that initializes a <code>cdev</code> structure, associating it with a <code>file_operations</code> structure that defines the driver&#39;s handlers for system calls.</td>\n</tr>\n<tr>\n<td><strong>dev_t</strong></td>\n<td>Kernel data type that holds a device number, combining major and minor numbers into a single 32-bit value (12 bits for major, 20 bits for minor in modern kernels). Functions like <code>MAJOR()</code> and <code>MINOR()</code> extract components.</td>\n</tr>\n<tr>\n<td><strong>device_create</strong></td>\n<td>Kernel function that creates a device node in <code>/dev</code> and corresponding entries in sysfs. It associates a device number (<code>dev_t</code>) with a class, creating the interface userspace applications use to access the device.</td>\n</tr>\n<tr>\n<td><strong>Device Node</strong></td>\n<td>A special file in the <code>/dev</code> directory that provides an interface to a device driver. Applications perform file operations (<code>open</code>, <code>read</code>, <code>write</code>, <code>ioctl</code>, <code>close</code>) on this node, which the kernel routes to the appropriate driver.</td>\n</tr>\n<tr>\n<td><strong>Device Tree</strong></td>\n<td>A data structure and language for describing hardware, used primarily on embedded systems (ARM, PowerPC, RISC-V). The kernel reads the Device Tree at boot to discover hardware configuration without hardcoded platform data.</td>\n</tr>\n<tr>\n<td><strong>dmesg</strong></td>\n<td>Command-line utility that displays the kernel&#39;s ring buffer of log messages (including those from <code>printk</code>). Essential for debugging kernel modules, as it shows initialization messages, errors, and debug output.</td>\n</tr>\n<tr>\n<td><strong>Error Propagation</strong></td>\n<td>The practice of returning appropriate error codes (negative errno values) from kernel functions to user-space system calls. The kernel&#39;s VFS translates these negative values to positive <code>errno</code> values for the C library.</td>\n</tr>\n<tr>\n<td><strong>errno</strong></td>\n<td>In userspace, a global variable that holds the error number from the last failed system call. In kernel space, error codes are negative integers (e.g., <code>-EINVAL</code> for invalid argument) that the VFS converts to positive <code>errno</code> values.</td>\n</tr>\n<tr>\n<td><strong>file_operations</strong></td>\n<td>A kernel structure (<code>struct file_operations</code>) containing function pointers that implement the driver&#39;s handling of system calls like <code>open</code>, <code>read</code>, <code>write</code>, <code>release</code>, <code>ioctl</code>, and <code>poll</code>. The driver initializes this structure with its handler functions.</td>\n</tr>\n<tr>\n<td><strong>Flight Data Recorder</strong></td>\n<td>Analogy for the kernel&#39;s logging system (<code>printk</code> and <code>dmesg</code>). Like an airplane&#39;s black box, it continuously records kernel events and messages, which can be reviewed after crashes or unexpected behavior to diagnose what happened.</td>\n</tr>\n<tr>\n<td><strong>GFP_KERNEL</strong></td>\n<td>Flag passed to memory allocation functions like <code>kmalloc()</code> indicating normal kernel memory allocation that may sleep (schedule other processes) while waiting for memory. Used in process context, not interrupt context.</td>\n</tr>\n<tr>\n<td><strong>insmod</strong></td>\n<td>Command to insert (load) a kernel module into the running kernel. Triggers the module&#39;s initialization function (declared with <code>module_init</code>). Requires root privileges.</td>\n</tr>\n<tr>\n<td><strong>ioctl</strong> (I/O Control)</td>\n<td>A system call and device operation that provides a device-specific command interface for configuration, control, and status queries beyond standard read/write. Commands are defined using <code>_IOR</code>, <code>_IOW</code>, <code>_IOWR</code> macros.</td>\n</tr>\n<tr>\n<td><strong>Kbuild</strong></td>\n<td>The Linux kernel build system. It uses <code>Makefile</code>s with special syntax to build kernel modules against the currently running kernel&#39;s headers, handling dependencies and architecture specifics.</td>\n</tr>\n<tr>\n<td><strong>Kernel Module</strong></td>\n<td>A loadable piece of object code that extends the Linux kernel&#39;s functionality at runtime. Modules can be loaded with <code>insmod</code> and unloaded with <code>rmmod</code>, allowing dynamic addition of drivers, filesystems, or other features without rebooting.</td>\n</tr>\n<tr>\n<td><strong>Kernel Taint</strong></td>\n<td>A state where the kernel marks itself as &quot;tainted&quot; because a non-GPL or problematic module has been loaded, hardware reported a machine check error, or other issues occurred. A tainted kernel may restrict use of debugging symbols and is often unsupported for bug reports.</td>\n</tr>\n<tr>\n<td><strong>Linear Buffer</strong></td>\n<td>A contiguous memory block where data is stored sequentially from the start. When full, no more data can be written until space is freed by reading. Simple to implement but less flexible than a circular buffer for streaming data.</td>\n</tr>\n<tr>\n<td><strong>Magic Number</strong></td>\n<td>In the context of <code>ioctl</code>, a unique byte value used to identify a family of commands and prevent collisions between unrelated drivers. Defined as the first argument to <code>_IOR</code>, <code>_IOW</code>, <code>_IOWR</code> macros (e.g., <code>&#39;k&#39;</code> for our driver).</td>\n</tr>\n<tr>\n<td><strong>Major Number</strong></td>\n<td>The first component of a device number, identifying the device driver type. Historically assigned statically (e.g., 3 for IDE disks), but modern drivers often use <code>alloc_chrdev_region</code> for dynamic allocation to avoid conflicts.</td>\n</tr>\n<tr>\n<td><strong>Memory Barrier</strong></td>\n<td>A CPU instruction that enforces ordering constraints on memory operations, ensuring that reads and writes before the barrier complete before those after the barrier. Critical for correct synchronization on multi-processor systems.</td>\n</tr>\n<tr>\n<td><strong>Minor Number</strong></td>\n<td>The second component of a device number, identifying a specific instance of a device managed by a driver with a given major number. A single driver can manage multiple devices with the same major number but different minor numbers.</td>\n</tr>\n<tr>\n<td><strong>modinfo</strong></td>\n<td>Command that displays information embedded in a kernel module file (<code>.ko</code>), such as author, description, license, parameters, and dependencies. Reads metadata declared with <code>MODULE_AUTHOR</code>, <code>MODULE_DESCRIPTION</code>, etc.</td>\n</tr>\n<tr>\n<td><strong>Module Lifecycle</strong></td>\n<td>The sequence of states a kernel module undergoes: built, loaded (initialization), active (handling operations), and unloaded (cleanup). Managed by <code>module_init</code> and <code>module_exit</code> functions.</td>\n</tr>\n<tr>\n<td><strong>mutex</strong> (Mutual Exclusion Lock)</td>\n<td>A kernel synchronization primitive that allows only one thread of execution to hold it at a time. Threads attempting to acquire a held mutex sleep until it&#39;s released. Used for protecting critical sections in process context where sleeping is allowed.</td>\n</tr>\n<tr>\n<td><strong>O_NONBLOCK</strong></td>\n<td>A file status flag set with <code>open()</code> or <code>fcntl()</code> that causes subsequent I/O operations on the file descriptor to be non-blocking. If data isn&#39;t available for read or space for write, the call returns immediately with <code>EAGAIN</code> instead of sleeping.</td>\n</tr>\n<tr>\n<td><strong>Oops</strong></td>\n<td>A kernel error condition where the kernel detects an internal inconsistency (like dereferencing a NULL pointer) but attempts to continue running. An Oops generates a diagnostic message with a stack trace in the kernel log but may leave the system in an unstable state.</td>\n</tr>\n<tr>\n<td><strong>Out-of-Tree Module</strong></td>\n<td>A kernel module built outside the official kernel source tree, typically using the running kernel&#39;s headers. This project builds an out-of-tree module, as opposed to drivers integrated into the main kernel source.</td>\n</tr>\n<tr>\n<td><strong>Page Frame Number (PFN)</strong></td>\n<td>The index of a physical page in system memory. Used in memory mapping operations to specify which physical pages should be mapped into a process&#39;s virtual address space.</td>\n</tr>\n<tr>\n<td><strong>Panic</strong></td>\n<td>A fatal kernel error that halts the system entirely, often with a diagnostic message. Unlike an Oops, a panic stops execution to prevent further corruption, usually requiring a reboot.</td>\n</tr>\n<tr>\n<td><strong>Partial Transfer</strong></td>\n<td>When a <code>read()</code> or <code>write()</code> system call completes successfully but transfers fewer bytes than requested. For example, a read might return only 100 bytes when 1024 were requested because only 100 were available in the device buffer. Drivers must handle this correctly.</td>\n</tr>\n<tr>\n<td><strong>Platform Driver</strong></td>\n<td>A kernel driver model for devices that are discovered via a platform bus (often representing embedded SOC-integrated peripherals). Uses <code>of_match_table</code> for Device Tree matching and a <code>probe</code> function for initialization.</td>\n</tr>\n<tr>\n<td><strong>POLLIN / POLLOUT</strong></td>\n<td>Bitmask values returned by a driver&#39;s <code>poll</code> handler indicating that the device is readable (<code>POLLIN</code>) or writable (<code>POLLOUT</code>). Used by the <code>select()</code> and <code>poll()</code> system calls to monitor multiple file descriptors for I/O readiness.</td>\n</tr>\n<tr>\n<td><strong>Priority Inversion</strong></td>\n<td>A scheduling problem where a high-priority task is blocked waiting for a resource held by a low-priority task, which in turn is preempted by medium-priority tasks, causing indefinite blocking of the high-priority task. Solved in the kernel with priority inheritance for mutexes.</td>\n</tr>\n<tr>\n<td><strong>printk</strong></td>\n<td>The kernel&#39;s equivalent of <code>printf()</code>, used for logging messages at various severity levels (e.g., <code>KERN_INFO</code>, <code>KERN_ERR</code>). Messages go to the kernel log buffer and can be viewed with <code>dmesg</code>. Does not automatically append newlines.</td>\n</tr>\n<tr>\n<td><strong>proc_create</strong></td>\n<td>Kernel function that creates a file in the <code>/proc</code> filesystem, associating it with a <code>proc_ops</code> structure of handler functions. Provides a simple interface for exporting driver statistics and configuration to userspace.</td>\n</tr>\n<tr>\n<td><strong>ProcFS</strong> (Proc Filesystem)</td>\n<td>A virtual filesystem mounted at <code>/proc</code> that provides a window into kernel internals, exposing process information, system configuration, and driver statistics through files and directories. Our driver creates an entry here for status monitoring.</td>\n</tr>\n<tr>\n<td><strong>proc_ops</strong></td>\n<td>Structure (<code>struct proc_ops</code>) defining the operations for a <code>/proc</code> file, similar to <code>file_operations</code> but optimized for procfs. Includes handlers for <code>proc_open</code>, <code>proc_read</code>, <code>proc_write</code>, <code>proc_lseek</code>, and <code>proc_release</code>.</td>\n</tr>\n<tr>\n<td><strong>probe function</strong></td>\n<td>In device driver models (like platform or PCI), the function called by the kernel when a device is discovered and matched to a driver. Responsible for initializing the device, allocating resources, and registering it with appropriate subsystems.</td>\n</tr>\n<tr>\n<td><strong>Race Condition</strong></td>\n<td>A bug where the correctness of a program depends on the relative timing of uncontrollable events (like thread scheduling or hardware interrupts). Multiple threads accessing shared data without proper synchronization can cause data corruption or crashes.</td>\n</tr>\n<tr>\n<td><strong>Reference Count</strong></td>\n<td>A counter associated with a kernel object (like a <code>struct file</code> or <code>struct inode</code>) that tracks how many entities are currently using it. When the count drops to zero, the object can be safely freed. Prevents use-after-free errors.</td>\n</tr>\n<tr>\n<td><strong>remap_pfn_range</strong></td>\n<td>Kernel function that maps physical memory (identified by page frame numbers) into a process&#39;s virtual address space, typically used to implement the <code>mmap</code> operation for device drivers that support direct memory access.</td>\n</tr>\n<tr>\n<td><strong>Resource Leak</strong></td>\n<td>A bug where a kernel module fails to release allocated resources (memory, device numbers, sysfs entries) during cleanup or error paths, causing gradual exhaustion of system resources across multiple load/unload cycles.</td>\n</tr>\n<tr>\n<td><strong>rmmod</strong></td>\n<td>Command to remove (unload) a kernel module from the running kernel. Triggers the module&#39;s cleanup function (declared with <code>module_exit</code>). Fails if the module is in use (reference count &gt; 0).</td>\n</tr>\n<tr>\n<td><strong>Rollback</strong></td>\n<td>The practice of undoing partial initialization steps when an error occurs during module loading. For example, if <code>device_create</code> fails after <code>alloc_chrdev_region</code> succeeded, the driver must release the device number before returning the error.</td>\n</tr>\n<tr>\n<td><strong>seq_file</strong></td>\n<td>A kernel interface that simplifies the implementation of <code>/proc</code> files that produce more than one page of output. Handles iterative reading, page boundaries, and offset management automatically, preferred over raw <code>proc_read</code> for complex outputs.</td>\n</tr>\n<tr>\n<td><strong>Shutdown Coordination</strong></td>\n<td>Ensuring that all ongoing operations (like sleeping reads) complete or are gracefully terminated before the module unloads. May involve setting a <code>is_shutting_down</code> flag and waking wait queues to abort sleeping processes.</td>\n</tr>\n<tr>\n<td><strong>Signal Interruption</strong></td>\n<td>When a system call is interrupted by the delivery of a signal to the process. The system call returns <code>-ERESTARTSYS</code> internally, which the VFS translates to restarting the call or returning <code>-EINTR</code> to userspace depending on signal handling settings.</td>\n</tr>\n<tr>\n<td><strong>Singleton Pattern</strong></td>\n<td>A design pattern where only one instance of a particular structure or module exists in the system. Our driver uses this pattern for the main device instance, though the design could be extended to support multiple instances.</td>\n</tr>\n<tr>\n<td><strong>single_open</strong></td>\n<td>A helper function for creating simple <code>/proc</code> files that produce a single page of static content. Takes a <code>show</code> function that prints the entire output at once, simplifying the <code>proc_ops</code> implementation compared to <code>seq_file</code>.</td>\n</tr>\n<tr>\n<td><strong>SMP</strong> (Symmetric Multi-Processing)</td>\n<td>A system architecture where two or more identical processors (cores) share the same memory and are controlled by a single operating system. Requires careful synchronization to avoid race conditions on shared data structures.</td>\n</tr>\n<tr>\n<td><strong>Spinlock</strong></td>\n<td>A busy-wait synchronization primitive used in kernel contexts where sleeping is not allowed (like interrupt handlers). The thread repeatedly checks the lock in a loop until it becomes available, consuming CPU but guaranteeing low latency.</td>\n</tr>\n<tr>\n<td><strong>Spurious Wakeup</strong></td>\n<td>When a process sleeping on a wait queue is awakened even though the condition it was waiting for isn&#39;t true. Can happen due to signals or broad wake-up calls. Correct code must re-check the condition after waking, typically in a loop.</td>\n</tr>\n<tr>\n<td><strong>State Machine</strong></td>\n<td>A computational model where the system can be in one of a finite number of states, and transitions between states occur in response to events. Our device buffer can be modeled as a state machine with EMPTY, PARTIALLY_FILLED, and FULL states.</td>\n</tr>\n<tr>\n<td><strong>strace</strong></td>\n<td>A userspace diagnostic tool that traces system calls and signals made by a process. Useful for debugging driver interactions by showing the sequence of <code>open</code>, <code>read</code>, <code>write</code>, <code>ioctl</code>, and <code>close</code> calls and their return values/errors.</td>\n</tr>\n<tr>\n<td><strong>SysFS</strong> (Sys Filesystem)</td>\n<td>A virtual filesystem mounted at <code>/sys</code> that exports kernel object hierarchies (devices, drivers, classes) as directories and files. Used by udev for device node management and by tools like <code>lsmod</code> and <code>lspci</code>.</td>\n</tr>\n<tr>\n<td><strong>TOCTOU</strong> (Time-Of-Check-Time-Of-Use)</td>\n<td>A race condition where the state of a resource (like buffer size) is checked at one time but used at a later time after it may have changed. For example, checking <code>data_size &gt; 0</code> then copying data without holding a lock could lead to reading stale data if another thread clears the buffer in between.</td>\n</tr>\n<tr>\n<td><strong>VFS</strong> (Virtual File System)</td>\n<td>A kernel abstraction layer that provides a uniform interface for filesystem operations, regardless of the underlying filesystem or device type. Our driver&#39;s <code>file_operations</code> are called by the VFS in response to system calls on our device node.</td>\n</tr>\n<tr>\n<td><strong>virt_to_phys</strong></td>\n<td>Kernel function that converts a kernel virtual address to its corresponding physical address. Used in low-level memory mapping operations, but note that for DMA or user mapping, more complex methods are often required due to memory fragmentation.</td>\n</tr>\n<tr>\n<td><strong>Wait Queue</strong></td>\n<td>A kernel data structure (<code>wait_queue_head_t</code>) that allows processes to sleep until a condition becomes true. Processes call <code>wait_event_interruptible()</code> to sleep, and the driver calls <code>wake_up_interruptible()</code> to awaken them when data arrives or space becomes available.</td>\n</tr>\n<tr>\n<td><strong>Work Queue</strong></td>\n<td>A kernel mechanism for deferring work to be processed later by kernel threads. Useful for splitting lengthy operations from interrupt handlers or for executing tasks in process context where sleeping is allowed.</td>\n</tr>\n</tbody></table>\n","toc":[{"level":1,"text":"Linux Character Device Driver: Design Document","id":"linux-character-device-driver-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"The Kernel as a Secure Building","id":"the-kernel-as-a-secure-building"},{"level":3,"text":"The Core Challenge: Safe and Concurrent Access","id":"the-core-challenge-safe-and-concurrent-access"},{"level":3,"text":"Existing Approaches and Learning Path","id":"existing-approaches-and-learning-path"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Functional Goals (What it must do)","id":"functional-goals-what-it-must-do"},{"level":3,"text":"Non-Goals (What it explicitly does NOT do)","id":"non-goals-what-it-explicitly-does-not-do"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Component Overview and Responsibilities","id":"component-overview-and-responsibilities"},{"level":4,"text":"Mental Model: The Driver as a Library with Controlled Access","id":"mental-model-the-driver-as-a-library-with-controlled-access"},{"level":4,"text":"Component Interactions and Data Flow","id":"component-interactions-and-data-flow"},{"level":4,"text":"ADR: Monolithic Module vs. Multiple Source Files","id":"adr-monolithic-module-vs-multiple-source-files"},{"level":3,"text":"Recommended File and Module Structure","id":"recommended-file-and-module-structure"},{"level":4,"text":"Directory and File Layout","id":"directory-and-file-layout"},{"level":4,"text":"File Responsibilities Table","id":"file-responsibilities-table"},{"level":4,"text":"ADR: In-Tree vs. Out-of-Tree Module Build","id":"adr-in-tree-vs-out-of-tree-module-build"},{"level":4,"text":"Component-to-File Mapping","id":"component-to-file-mapping"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure (Expanded)","id":"b-recommended-filemodule-structure-expanded"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints (Kernel C)","id":"e-language-specific-hints-kernel-c"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Data Model","id":"data-model"},{"level":3,"text":"Kernel-Side Data Structures","id":"kernel-side-data-structures"},{"level":3,"text":"User-Space Ioctl Command Format","id":"user-space-ioctl-command-format"},{"level":3,"text":"Common Pitfalls: Data Model","id":"common-pitfalls-data-model"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Component: Module Lifecycle Manager","id":"component-module-lifecycle-manager"},{"level":3,"text":"Mental Model: The Driver&#39;s Birth and Death Certificate","id":"mental-model-the-driver39s-birth-and-death-certificate"},{"level":3,"text":"ADR: Dynamic vs. Static Device Number Allocation","id":"adr-dynamic-vs-static-device-number-allocation"},{"level":3,"text":"Common Pitfalls: Module Lifecycle","id":"common-pitfalls-module-lifecycle"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Component: Character Device Core","id":"component-character-device-core"},{"level":3,"text":"Mental Model: The Device as a Shared Notebook","id":"mental-model-the-device-as-a-shared-notebook"},{"level":3,"text":"ADR: Simple Linear Buffer vs. Circular Buffer","id":"adr-simple-linear-buffer-vs-circular-buffer"},{"level":3,"text":"Common Pitfalls: User/Kernel Boundary","id":"common-pitfalls-userkernel-boundary"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code: The Device Instance Structure","id":"c-infrastructure-starter-code-the-device-instance-structure"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Component: Control Interface (ioctl and proc)","id":"component-control-interface-ioctl-and-proc"},{"level":3,"text":"Mental Model: The Driver&#39;s Control Panel and Dashboard","id":"mental-model-the-driver39s-control-panel-and-dashboard"},{"level":3,"text":"ADR: Raw procfs vs. seq_file Interface","id":"adr-raw-procfs-vs-seq_file-interface"},{"level":3,"text":"Common Pitfalls: ioctl and procfs","id":"common-pitfalls-ioctl-and-procfs"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code: Shared Header File","id":"c-infrastructure-starter-code-shared-header-file"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Component: Concurrency and Synchronization Manager","id":"component-concurrency-and-synchronization-manager"},{"level":3,"text":"Mental Model: The Queue at the Library Desk","id":"mental-model-the-queue-at-the-library-desk"},{"level":3,"text":"ADR: Mutex vs. Spinlock for Buffer Protection","id":"adr-mutex-vs-spinlock-for-buffer-protection"},{"level":3,"text":"Common Pitfalls: Kernel Synchronization","id":"common-pitfalls-kernel-synchronization"},{"level":4,"text":"⚠️ Pitfall: Sleeping While Holding a Spinlock","id":"-pitfall-sleeping-while-holding-a-spinlock"},{"level":4,"text":"⚠️ Pitfall: Forgetting to Unlock on Error Paths","id":"-pitfall-forgetting-to-unlock-on-error-paths"},{"level":4,"text":"⚠️ Pitfall: Incorrect Wait Queue Usage Without Condition Re-check","id":"-pitfall-incorrect-wait-queue-usage-without-condition-re-check"},{"level":4,"text":"⚠️ Pitfall: Missing Memory Barriers in Lock-Free Code","id":"-pitfall-missing-memory-barriers-in-lock-free-code"},{"level":4,"text":"⚠️ Pitfall: Incorrect Poll Mask Return","id":"-pitfall-incorrect-poll-mask-return"},{"level":4,"text":"⚠️ Pitfall: Priority Inversion in Lock Usage","id":"-pitfall-priority-inversion-in-lock-usage"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Interactions and Data Flow","id":"interactions-and-data-flow"},{"level":3,"text":"Sequence of Operations: From User Command to Kernel Action","id":"sequence-of-operations-from-user-command-to-kernel-action"},{"level":4,"text":"Module Loading and Device Node Creation","id":"module-loading-and-device-node-creation"},{"level":4,"text":"Writing Data to the Device","id":"writing-data-to-the-device"},{"level":4,"text":"Reading Data from the Device (Blocking)","id":"reading-data-from-the-device-blocking"},{"level":4,"text":"Ioctl Command Execution","id":"ioctl-command-execution"},{"level":3,"text":"Concurrent Access Flow","id":"concurrent-access-flow"},{"level":4,"text":"Concurrent Read and Write Scenario","id":"concurrent-read-and-write-scenario"},{"level":4,"text":"Multiple Readers and Writers","id":"multiple-readers-and-writers"},{"level":4,"text":"Poll/Select Operation Flow","id":"pollselect-operation-flow"},{"level":4,"text":"Proc Filesystem Read Operation","id":"proc-filesystem-read-operation"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Error Detection and Recovery Strategy","id":"error-detection-and-recovery-strategy"},{"level":3,"text":"Specific Edge Cases and Handling","id":"specific-edge-cases-and-handling"},{"level":4,"text":"1. Buffer Full and Empty Conditions","id":"1-buffer-full-and-empty-conditions"},{"level":4,"text":"2. Invalid ioctl Commands and Arguments","id":"2-invalid-ioctl-commands-and-arguments"},{"level":4,"text":"3. Process Termination While Sleeping on Wait Queue","id":"3-process-termination-while-sleeping-on-wait-queue"},{"level":4,"text":"4. Concurrent Module Removal During Operations","id":"4-concurrent-module-removal-during-operations"},{"level":4,"text":"5. Poll/Select with Multiple Events","id":"5-pollselect-with-multiple-events"},{"level":4,"text":"6. Memory Allocation Failure During Buffer Resize","id":"6-memory-allocation-failure-during-buffer-resize"},{"level":4,"text":"7. Partial Read/Write with Signal Interruption","id":"7-partial-readwrite-with-signal-interruption"},{"level":4,"text":"8. 32/64-bit User-Space Compatibility","id":"8-3264-bit-user-space-compatibility"},{"level":3,"text":"Common Pitfalls in Error Handling","id":"common-pitfalls-in-error-handling"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Testing Strategy","id":"testing-strategy"},{"level":3,"text":"Milestone Verification Checkpoints","id":"milestone-verification-checkpoints"},{"level":3,"text":"Concurrency Stress Test","id":"concurrency-stress-test"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure for Testing","id":"b-recommended-filemodule-structure-for-testing"},{"level":4,"text":"C. Infrastructure Starter Code: Test Ioctl Program","id":"c-infrastructure-starter-code-test-ioctl-program"},{"level":4,"text":"D. Core Logic Skeleton: Poll Test Program","id":"d-core-logic-skeleton-poll-test-program"},{"level":4,"text":"E. C-Specific Testing Hints","id":"e-c-specific-testing-hints"},{"level":4,"text":"F. Milestone Checkpoint Verification","id":"f-milestone-checkpoint-verification"},{"level":4,"text":"G. Debugging Tips for Testing","id":"g-debugging-tips-for-testing"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Symptom → Cause → Diagnosis → Fix Table","id":"symptom-cause-diagnosis-fix-table"},{"level":3,"text":"Kernel-Specific Debugging Techniques","id":"kernel-specific-debugging-techniques"},{"level":4,"text":"Mental Model: The Kernel&#39;s Black Box Flight Recorder","id":"mental-model-the-kernel39s-black-box-flight-recorder"},{"level":4,"text":"1. Mastery of printk and dmesg","id":"1-mastery-of-printk-and-dmesg"},{"level":4,"text":"2. Inspecting Kernel Subsystems via /proc and /sys","id":"2-inspecting-kernel-subsystems-via-proc-and-sys"},{"level":4,"text":"3. Using strace to Trace Userspace Interactions","id":"3-using-strace-to-trace-userspace-interactions"},{"level":4,"text":"4. Handling Kernel Oops and Panics","id":"4-handling-kernel-oops-and-panics"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure for Debugging","id":"b-recommended-filemodule-structure-for-debugging"},{"level":4,"text":"C. Infrastructure Starter Code: A Simple Debug Macro","id":"c-infrastructure-starter-code-a-simple-debug-macro"},{"level":4,"text":"D. Core Logic Skeleton Code: Adding Debug to Critical Functions","id":"d-core-logic-skeleton-code-adding-debug-to-critical-functions"},{"level":4,"text":"E. Language-Specific Hints: C and Kernel","id":"e-language-specific-hints-c-and-kernel"},{"level":4,"text":"F. Milestone Debugging Checkpoint","id":"f-milestone-debugging-checkpoint"},{"level":4,"text":"G. Debugging Tips: Beyond the Basics","id":"g-debugging-tips-beyond-the-basics"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"Potential Enhancements","id":"potential-enhancements"},{"level":4,"text":"Enhancement 1: Circular Buffer Implementation","id":"enhancement-1-circular-buffer-implementation"},{"level":4,"text":"Enhancement 2: mmap Support for Zero-Copy Data Access","id":"enhancement-2-mmap-support-for-zero-copy-data-access"},{"level":4,"text":"Enhancement 3: Multiple Device Instances and Dynamic Minor Numbers","id":"enhancement-3-multiple-device-instances-and-dynamic-minor-numbers"},{"level":4,"text":"Enhancement 4: Device Tree Integration for Hardware Configuration","id":"enhancement-4-device-tree-integration-for-hardware-configuration"},{"level":4,"text":"Enhancement 5: SysFS Interface for Runtime Configuration","id":"enhancement-5-sysfs-interface-for-runtime-configuration"},{"level":4,"text":"Enhancement 6: Advanced Synchronization with Read-Write Locks","id":"enhancement-6-advanced-synchronization-with-read-write-locks"},{"level":4,"text":"Enhancement 7: Asynchronous I/O (AIO) Support","id":"enhancement-7-asynchronous-io-aio-support"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File Structure for Extensions","id":"b-recommended-file-structure-for-extensions"},{"level":4,"text":"C. Infrastructure Starter Code: Circular Buffer Helper","id":"c-infrastructure-starter-code-circular-buffer-helper"},{"level":4,"text":"D. Core Logic Skeleton: mmap Handler Implementation","id":"d-core-logic-skeleton-mmap-handler-implementation"},{"level":4,"text":"E. Language-Specific Hints for Kernel C","id":"e-language-specific-hints-for-kernel-c"},{"level":4,"text":"F. Milestone Checkpoint for Extensions","id":"f-milestone-checkpoint-for-extensions"},{"level":4,"text":"G. Debugging Tips for Extensions","id":"g-debugging-tips-for-extensions"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Terms and Definitions","id":"terms-and-definitions"}],"title":"Linux Character Device Driver: Design Document","markdown":"# Linux Character Device Driver: Design Document\n\n\n## Overview\n\nThis document describes the design of a loadable Linux kernel module that implements a simple character device driver with a `/dev` interface. The key architectural challenge is safely managing data and concurrency across the kernel/user-space boundary, which requires careful handling of memory, synchronization primitives, and driver lifecycle.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n> **Milestone(s):** Milestone 1, Milestone 2, Milestone 3, Milestone 4 (foundational concepts)\n\n## Context and Problem Statement\n\n### The Kernel as a Secure Building\n\nThink of the Linux operating system as a highly secure government building. This building has two distinct zones with strict access controls between them.\n\nThe **userspace zone** (outside the building) is where all regular applications run. This zone is chaotic and unpredictable - thousands of programs with varying levels of trust compete for resources. Any application can crash without bringing down the entire system, much like a protest outside the building doesn't shut down government operations. Applications communicate with each other through well-defined channels, but they have limited direct access to critical resources.\n\nThe **kernel-space zone** (inside the building) is the secure core where privileged operations happen. This is where the operating system's core services run: managing memory, scheduling processes, controlling hardware, and enforcing security policies. The kernel has complete access to all system resources, including physical memory, CPU registers, and hardware devices. A single mistake here can crash the entire system, much like a fire in the building's control room would halt all government functions.\n\nBetween these two zones stands a **security checkpoint** with specific, controlled entrances: the **system call interface**. Each system call (`read`, `write`, `open`, `ioctl`, etc.) is like a designated checkpoint where userspace applications can request kernel services. When an application calls `write()` on a file, it's like submitting a form at the checkpoint - the application waits while security (the kernel) verifies the request, processes it according to strict rules, and returns a result.\n\nThe security guards at these checkpoints are various kernel subsystems. The **Virtual File System (VFS)** guards file operations, ensuring every `read()` or `write()` follows the proper protocol. The **process scheduler** determines which application gets CPU time. The **memory manager** controls what memory each application can access. These subsystems work together to maintain system stability and security.\n\n> **Design Insight:** The fundamental rule of kernel programming is **\"Thou shalt not trust userspace.\"** Any pointer, buffer, or value coming from userspace must be treated as potentially malicious or erroneous. The kernel must validate everything before using it, and must never crash or leak information regardless of what userspace sends.\n\nWithin this secure building, **device drivers** serve as specialized interpreters for hardware components. They translate generic system calls into specific hardware commands. When you type on a keyboard, the keyboard driver receives electrical signals and translates them into character data that applications can read. When you save a file, the storage driver translates file system requests into specific commands for your SSD or hard drive.\n\nOur project focuses on building a particular type of driver: a **character device driver**. This driver doesn't control physical hardware but creates a virtual conduit for data between userspace and kernel-space. It's like installing a secure message passing system within the building - applications can deposit messages (write) and retrieve messages (read) through controlled interfaces, with the kernel managing the storage and access rules.\n\n### The Core Challenge: Safe and Concurrent Access\n\nThe specific problem we're solving has two interconnected dimensions that make kernel programming fundamentally different from userspace programming:\n\n**Dimension 1: The Kernel/User Boundary Problem**\nWhen data moves between userspace and kernel-space, it crosses a fundamental architectural boundary with different memory spaces, privilege levels, and validation requirements. The kernel cannot directly access userspace memory pointers because:\n- Userspace pointers are virtual addresses in the application's address space, not the kernel's\n- Userspace memory might be swapped out, invalid, or deliberately malicious\n- Direct access would bypass security checks and could crash the system\n\nSimilarly, the kernel cannot directly expose its internal memory to userspace because:\n- Kernel memory contains sensitive system data and other processes' information\n- Applications might accidentally or maliciously corrupt kernel data structures\n- Different memory protection mechanisms apply (kernel memory is not swappable)\n\nThe solution requires careful **copying and validation** at the boundary. Every byte transferred must be explicitly copied between address spaces using special kernel functions that handle the translation and validation automatically.\n\n**Dimension 2: The Concurrency Problem**\nUnlike most userspace programs that handle one request at a time, the kernel is inherently **concurrent**. Multiple processes can simultaneously:\n- Open the same device file\n- Read from the device while another process is writing to it\n- Issue control commands (`ioctl`) while data transfers are happening\n- Be interrupted by hardware interrupts that might need to access the same data structures\n\nThis creates classic synchronization problems:\n- **Data races**: Two processes writing to the same buffer location without coordination\n- **Starvation**: One process monopolizing access while others wait indefinitely\n- **Deadlock**: Multiple processes waiting for each other in a circular dependency\n- **Priority inversion**: A high-priority process waiting for a low-priority process\n\nThe kernel solves these problems with **synchronization primitives** (mutexes, spinlocks, semaphores) and **wait queues** (for blocking operations). However, these must be used correctly:\n- Some locks can sleep (mutexes), while others cannot (spinlocks)\n- The wrong lock type in the wrong context can deadlock the entire system\n- Locking too much reduces performance; locking too little causes data corruption\n\n> **Design Insight:** Kernel code must be **reentrant** and **thread-safe** by design. Every function must assume it can be interrupted at any point and resumed later, possibly with other threads executing the same code on different data.\n\nThe table below summarizes the key differences between kernel-space and userspace programming that our driver must handle:\n\n| Aspect | Userspace Programming | Kernel-space Programming | Implications for Our Driver |\n|--------|----------------------|--------------------------|----------------------------|\n| **Memory Access** | Direct access to process memory, can allocate/free at will | Cannot directly access userspace memory; kernel memory is non-swappable | Must use `copy_to_user()`/`copy_from_user()` for all data transfers |\n| **Error Handling** | Process crashes on severe errors; can be restarted | Kernel panic on severe errors; crashes entire system | Must validate all inputs, never dereference invalid pointers, handle all error paths |\n| **Concurrency Model** | Typically single-threaded or explicit threading | Always concurrent - interrupts, multiple processes, SMP | Every data structure must be protected with appropriate locks |\n| **Debugging** | Can use debuggers, printf, core dumps | Limited to `printk()`, system logs, special debugging tools | Must include extensive logging with appropriate log levels |\n| **Libraries** | Full standard C library available | Limited to kernel API; no floating point, limited memory allocation | Must use kernel functions (`kmalloc()`, `kfree()`) instead of `malloc()`/`free()` |\n| **Execution Context** | Always in process context | Can be in process context or interrupt context | Must know context to choose correct synchronization primitives |\n| **Module Lifecycle** | Program starts, runs, exits | Module loads, devices can be opened/closed many times, module unloads | Must clean up all resources on module exit, handle reference counting |\n\n**Our Specific Implementation Challenge:**\nWe're building a character device driver that provides:\n1. A `/dev/` interface that userspace programs can open, read, write, and close\n2. An internal buffer that stores data written from userspace\n3. Control interfaces (`ioctl` and `/proc`) for configuration and monitoring\n4. Safe concurrent access for multiple readers and writers\n\nThe core data flow problem is illustrated in the following sequence:\n\n1. **Userspace Process A** calls `write(fd, \"hello\", 5)` on our device\n2. The system call enters the kernel through the VFS layer\n3. VFS routes the call to our driver's `write` handler\n4. Our handler must:\n   - Validate the userspace pointer and length\n   - Copy \"hello\" from userspace to kernel-space using `copy_from_user()`\n   - Acquire a lock to protect the buffer from concurrent access\n   - Store the data in our internal buffer\n   - Release the lock\n   - Wake up any processes waiting to read from an empty buffer\n   - Return success/failure to userspace\n5. Meanwhile, **Userspace Process B** might be calling `read()` on the same device\n6. Our `read` handler must:\n   - Check if data is available in the buffer\n   - If empty, put the process to sleep on a wait queue (blocking read)\n   - When woken (by the write above), acquire the lock\n   - Copy data from kernel buffer to userspace using `copy_to_user()`\n   - Release the lock\n   - Return the number of bytes read\n\nThis seemingly simple flow involves nearly every challenging aspect of kernel programming: crossing the kernel/user boundary, synchronization, sleeping/waking processes, and proper error handling.\n\n### Existing Approaches and Learning Path\n\nLinux provides several mechanisms for kernel/userspace communication, each suited to different use cases. Understanding why we chose a character device driver requires comparing the alternatives:\n\n| Interface | Primary Use Case | Data Model | Complexity | Why Not for Our Project |\n|-----------|------------------|------------|------------|--------------------------|\n| **Character Device (`/dev/`)** | Stream-oriented I/O, hardware abstraction | Byte stream, sequential access | Medium | **Chosen** - Perfect for learning fundamental driver concepts |\n| **Block Device** | Disk storage, filesystems | Block-oriented, random access | High | Too complex, requires request queue handling |\n| **Network Device** | Network interfaces | Packet-oriented, protocol stacks | High | Different API, requires networking stack integration |\n| **SysFS (`/sys/`)** | Device configuration, attributes | Key-value pairs, hierarchical | Low-Medium | Not for bulk data transfer, read/write semantics different |\n| **DebugFS (`/debug/`)** | Debugging information | Arbitrary files, often human-readable | Low | Not for production interfaces, may not be available |\n| **ProcFS (`/proc/`)** | Process information, system statistics | Mixed (text, binary) | Medium | We'll use it for statistics, but not as primary interface |\n| **Netlink Sockets** | Kernel ↔ userspace messaging | Message-based, bidirectional | Medium-High | Socket programming required, different paradigm |\n| **Memory-mapped I/O (`mmap`)** | High-performance data sharing | Direct memory access | High | Advanced topic, bypasses copy overhead but more complex |\n\n**Why a Character Device Driver is the Ideal Learning Vehicle:**\n\n1. **Historical Significance**: Character devices represent the original Unix device model. Understanding them provides insight into decades of Unix/Linux design philosophy.\n\n2. **Comprehensive Coverage**: Implementing a character device driver requires learning:\n   - Module initialization and cleanup (Milestone 1)\n   - File operations and the VFS layer (Milestone 2)\n   - Kernel/userspace data transfer\n   - Device node creation and management\n   - Control interfaces (`ioctl`) (Milestone 3)\n   - Synchronization and concurrency (Milestone 4)\n   - Process sleeping/waking (wait queues)\n   - Multiple interfaces (`/proc`, `ioctl`, file ops)\n\n3. **Practical Foundation**: The skills transfer directly to:\n   - Real hardware drivers (USB, serial, input devices)\n   - Virtual devices (VPN interfaces, encryption devices)\n   - Kernel services that expose device-like interfaces\n\n4. **Progressive Complexity**: The character device API allows starting simple (basic read/write) and gradually adding complexity (ioctl, proc interface, concurrency) in clearly separated milestones.\n\n**The Learning Progression Through Milestones:**\n\nOur project follows a carefully sequenced learning path:\n\n```mermaid\ngraph TD\n    A[Milestone 1:<br>Module Lifecycle] --> B[Milestone 2:<br>Character Device Core]\n    B --> C[Milestone 3:<br>Control Interfaces]\n    C --> D[Milestone 4:<br>Concurrency & Synchronization]\n    \n    A --> A1[Kbuild System]\n    A --> A2[printk Debugging]\n    A --> A3[Resource Management]\n    \n    B --> B1[File Operations]\n    B --> B2[copy_to/from_user]\n    B --> B3[Device Node Creation]\n    \n    C --> C1[ioctl Command Design]\n    C --> C2[ProcFS Interface]\n    C --> C3[Shared Headers]\n    \n    D --> D1[Mutex Protection]\n    D --> D2[Wait Queues]\n    D --> D3[Poll/Select Support]\n```\n\n**Alternative Approaches We Considered and Rejected:**\n\n> **Decision: Character Device vs. SysFS for Configuration**\n> - **Context**: We need both data transfer (read/write) and configuration (buffer size, statistics). SysFS is commonly used for device attributes.\n> - **Options Considered**:\n>   1. Pure character device with `ioctl` for all control\n>   2. Hybrid approach: character device for data, SysFS for attributes\n>   3. Pure SysFS with binary file operations\n> - **Decision**: Pure character device with `ioctl` and `/proc` interface\n> - **Rationale**: \n>   - `ioctl` provides structured, type-safe command interface\n>   - `/proc` interface is simpler to implement than SysFS for read-only statistics\n>   - Keeping all interfaces in one driver file simplifies learning\n>   - Real-world drivers often use multiple interfaces (char device + SysFS + debugfs)\n> - **Consequences**: \n>   - Learners must understand multiple interface paradigms\n>   - More code to write and test\n>   - Better preparation for real driver development\n\n| Option | Pros | Cons | Why Rejected |\n|--------|------|------|--------------|\n| **Pure Character Device** | Single interface to learn, consistent model | All control through `ioctl` can become complex | **Chosen** - Best for learning fundamentals |\n| **Character + SysFS** | Proper separation of data vs. control, modern Linux practice | Two different APIs to learn, more complex initialization | Too advanced for initial learning |\n| **Pure ProcFS** | Simple file operations, good for read-mostly data | Poor for binary data transfer, not standard for devices | Doesn't teach standard device driver patterns |\n| **Netlink Sockets** | Bidirectional, flexible messaging | Completely different paradigm from device drivers | Wouldn't teach device driver concepts |\n\n**The Evolution of Linux Driver Models:**\n\nIt's important to understand that our simple character device represents the foundation upon which more advanced driver models are built:\n\n1. **Legacy Model (What we're implementing)**: Direct registration with `register_chrdev()`, manual device node creation\n2. **Device Model (Modern approach)**: Integration with the kernel's device model, automatic discovery, power management\n3. **Platform Devices**: For embedded systems with device tree description\n4. **USB/PCI Drivers**: Bus-specific driver frameworks with hotplug support\n\nOur project intentionally starts with the legacy model because:\n- It exposes the fundamental operations without framework abstractions\n- The concepts map directly to the `file_operations` structure\n- Learners understand what frameworks later automate\n- Most educational resources use this model\n\n> **Design Principle**: Learn the fundamentals before the abstractions. Understanding how `copy_to_user()` works at a basic level makes you appreciate why driver frameworks exist and what problems they solve.\n\n**Common Misconceptions About Kernel Programming:**\n\n1. **\"Kernel programming is just C programming\"** - While the language is C, the environment, constraints, and APIs are completely different. There's no standard library, memory management is manual and constrained, and concurrency is ever-present.\n\n2. **\"If it compiles, it works\"** - Kernel modules can compile cleanly but crash the system when loaded. Testing requires careful staging and recovery plans.\n\n3. **\"Userspace debugging techniques work in kernel\"** - No interactive debuggers (usually), no `printf()` (use `printk()` with levels), core dumps are system crashes.\n\n4. **\"Concurrency is an advanced topic\"** - In the kernel, concurrency is fundamental. Even a simple driver with no explicit threading must handle multiple processes accessing it simultaneously.\n\nOur project structure directly addresses these misconceptions by:\n- Starting with module lifecycle (Milestone 1) to learn the kernel build and loading process\n- Progressing to data transfer (Milestone 2) with proper boundary crossing\n- Adding control interfaces (Milestone 3) to learn kernel/userspace API design\n- Finally addressing concurrency (Milestone 4) as a fundamental requirement\n\nThe following diagram shows where our driver fits in the overall Linux architecture:\n\n![System Component Diagram](./diagrams/diagram-sys-component.svg)\n\nAs shown, our character device driver sits between userspace applications and kernel subsystems. It interacts with:\n- **VFS (Virtual File System)**: For file operations (`open`, `read`, `write`, `ioctl`)\n- **ProcFS**: For our statistics interface\n- **Kernel Memory Management**: For buffer allocation\n- **Process Scheduler**: For wait queue management\n\nThis positioning makes it an ideal vehicle for understanding the complete kernel ecosystem while focusing on manageable, incremental milestones.\n\n\n## Goals and Non-Goals\n> **Milestone(s):** Milestone 1, Milestone 2, Milestone 3, Milestone 4 (overarching objectives)\n\nThis section establishes clear boundaries for the driver project by explicitly defining what we aim to build (Goals) and what we deliberately exclude (Non-Goals). These boundaries ensure the project remains focused on its educational purpose while managing complexity for intermediate learners. Understanding these constraints prevents scope creep and helps learners focus on core kernel programming concepts without being overwhelmed by peripheral concerns.\n\n### Functional Goals (What it must do)\n\nThe driver must implement a complete character device driver that serves as a pedagogical tool for understanding kernel/user-space interaction, device driver architecture, and concurrency management in the Linux kernel. These goals are organized into four progressive milestones, each building upon the previous to create a fully functional driver.\n\n| Goal Category | Specific Requirements | Corresponding Milestone | Educational Purpose |\n|---------------|----------------------|-------------------------|---------------------|\n| **Module Lifecycle Management** | 1. Compile as loadable kernel module using Kbuild system<br>2. Clean initialization and cleanup with `module_init`/`module_exit`<br>3. Register proper metadata: `MODULE_LICENSE(\"GPL\")`, `MODULE_AUTHOR`, `MODULE_DESCRIPTION`<br>4. Visible via `modinfo` command<br>5. Clean unloading without resource leaks | Milestone 1 | Teaches kernel module architecture, build system, and resource management lifecycle |\n| **Character Device Interface** | 1. Dynamic device number allocation via `alloc_chrdev_region`<br>2. Automatic `/dev` node creation using `class_create` and `device_create`<br>3. Complete `struct file_operations` with `open`, `release`, `read`, `write` handlers<br>4. Safe user/kernel data transfer via `copy_to_user`/`copy_from_user`<br>5. Persistent kernel buffer for data storage between operations | Milestone 2 | Demonstrates character device registration, VFS integration, and boundary-crossing data transfer |\n| **Control and Monitoring Interfaces** | 1. Custom `ioctl` commands defined with `_IOR`/`_IOW` macros in shared header<br>2. `unlocked_ioctl` handler implementing buffer resize, clear, and status queries<br>3. `/proc` filesystem entry displaying device statistics and configuration<br>4. Userspace test program exercising all control interfaces | Milestone 3 | Teaches kernel-user communication beyond basic read/write and ProcFS integration |\n| **Concurrent Access Safety** | 1. Mutex-protected buffer access for thread-safe read/write operations<br>2. Blocking read via wait queue (`wait_event_interruptible`/`wake_up_interruptible`)<br>3. `poll`/`select` support implementing `poll` file operation<br>4. Stress testing with multiple concurrent readers/writers without data corruption | Milestone 4 | Introduces kernel synchronization primitives and asynchronous I/O patterns |\n\nBeyond these technical requirements, the driver must fulfill specific educational objectives that transform it from a mere code exercise into a learning tool:\n\n1. **Demonstrate Safe Boundary Crossing**: Every interaction between user-space and kernel-space must model proper safety practices—never dereferencing user pointers directly, always checking `copy_to/from_user` return values, and validating all inputs from untrusted user-space.\n\n2. **Illustrate Kernel Concurrency Patterns**: The driver must showcase realistic synchronization scenarios that kernel developers encounter: sleeping locks for operations that may block, proper wait queue usage for event-driven I/O, and correct `poll` implementation for multiplexed I/O.\n\n3. **Model Clean Resource Management**: From module loading to unloading, the driver must demonstrate the \"reverse order\" cleanup principle—freeing resources in the exact opposite order of allocation—to prevent resource leaks that could taint the kernel or require a reboot.\n\n4. **Provide Debuggable Failure Modes**: The implementation should include clear error paths with descriptive `printk` messages (using appropriate log levels like `KERN_INFO` and `KERN_ERR`) that help learners diagnose issues through `dmesg` output.\n\n5. **Serve as Reference Architecture**: The code structure should be modular enough that learners can extract patterns for their own future driver projects, with clear separation between device registration, I/O operations, control interfaces, and synchronization.\n\nThe following table maps each functional goal to specific kernel APIs and concepts that learners will master:\n\n| Kernel Concept | APIs Used | Learning Outcome |\n|----------------|-----------|------------------|\n| **Module Lifecycle** | `module_init`, `module_exit`, `printk`, `MODULE_*` macros | Understanding how kernel modules integrate with the running kernel |\n| **Device Registration** | `alloc_chrdev_region`, `cdev_init`, `cdev_add`, `class_create`, `device_create` | Dynamic device number assignment and automatic device node creation |\n| **File Operations** | `struct file_operations`, `open`, `release`, `read`, `write` handlers | VFS integration and file operation dispatch |\n| **User/Kernel Transfer** | `copy_to_user`, `copy_from_user`, `access_ok` | Safe memory access across privilege boundaries |\n| **Ioctl Interface** | `unlocked_ioctl`, `_IOR`/`_IOW`/`_IOWR` macros | Device-specific control command implementation |\n| **ProcFS Integration** | `proc_create`, `struct proc_ops`, `single_open` | Exporting driver information via virtual filesystem |\n| **Synchronization** | `mutex_lock`/`mutex_unlock`, `DEFINE_MUTEX` | Protecting shared data from concurrent access |\n| **Wait Queues** | `wait_event_interruptible`, `wake_up_interruptible`, `DECLARE_WAIT_QUEUE_HEAD` | Implementing blocking I/O with sleep/wake mechanisms |\n| **Poll/Select** | `poll` file operation, `poll_wait`, mask bits (`POLLIN`, `POLLRDNORM`) | Supporting asynchronous event notification |\n\n### Non-Goals (What it explicitly does NOT do)\n\nDeliberate exclusion of certain features is as important as inclusion for a focused learning project. These non-goals prevent scope creep and ensure learners concentrate on core kernel programming concepts without being sidetracked by advanced or peripheral topics.\n\n| Non-Goal Category | Specific Exclusions | Rationale for Exclusion |\n|-------------------|---------------------|-------------------------|\n| **Hardware Interaction** | 1. No physical hardware device control<br>2. No interrupt handling (IRQs)<br>3. No DMA operations<br>4. No memory-mapped I/O (MMIO)<br>5. No power management (suspend/resume) | Hardware drivers introduce platform-specific complexities, interrupt context constraints, and device-specific knowledge requirements that would distract from core kernel programming concepts. This driver is purely software-based. |\n| **Production-Grade Robustness** | 1. No support for hotplugging (device insertion/removal at runtime)<br>2. No fine-grained error recovery beyond basic cleanup<br>3. No performance optimization (zero-copy, ring buffers)<br>4. No comprehensive security auditing or exploit mitigation<br>5. No support for `mmap` or advanced memory management | Production drivers require extensive error handling, security hardening, and performance optimizations that would obscure the educational focus on fundamental patterns. |\n| **Advanced Kernel Features** | 1. No integration with Device Tree or ACPI<br>2. No sysfs (`/sys`) interface for device attributes<br>3. No debugfs interface for debugging<br>4. No netlink socket communication<br>5. No kernel thread creation or workqueues | These advanced interfaces would introduce additional complexity without contributing to the core learning objectives of character device drivers and basic synchronization. |\n| **System-Wide Integration** | 1. No udev rule creation for automatic node permissions<br>2. No integration with systemd or init systems<br>3. No support for multiple device instances (minor numbers)<br>4. No namespace or container awareness<br>5. No integration with kernel events or notifications | System integration aspects are important for production drivers but represent a different layer of complexity than core kernel programming. |\n| **User-Space Libraries** | 1. No companion userspace library (lib) for simplified access<br>2. No automatic test suite or continuous integration setup<br>3. No graphical monitoring tools or dashboards<br>4. No shell completion or CLI helper utilities | While useful in production, these would shift focus from kernel programming to userspace application development. |\n\nThe driver also explicitly avoids certain implementation patterns that, while common in production, would complicate the learning experience:\n\n> **Design Principle: Simplicity Over Completeness**  \n> This driver prioritizes clear, pedagogical code over feature completeness. Every line of code should serve an educational purpose, demonstrating a specific kernel concept without unnecessary abstraction or optimization that would obscure the core learning.\n\n**Why No Hardware Interaction?**  \nReal hardware drivers require understanding device datasheets, interrupt controllers, DMA controllers, and platform-specific constraints. These topics deserve their own dedicated learning path. Our pure-software driver eliminates these variables, allowing learners to focus on kernel APIs and patterns without hardware debugging complications.\n\n**Why Not Production-Grade?**  \nProduction drivers require handling dozens of edge cases: power management events, surprise device removal, malicious user input, resource exhaustion, and performance under heavy load. While important, these concerns would triple the code size and obscure the fundamental patterns. Learners should first master the basics before tackling production hardening.\n\n**Why Exclude Advanced Interfaces?**  \nSysfs, debugfs, netlink, and Device Tree each have their own complex APIs and conventions. Including them would fragment the learning focus. After mastering character devices and ProcFS, learners can apply similar patterns to these other interfaces in future projects.\n\n**Educational Boundary Enforcement**  \nThe non-goals create a \"sandbox\" where learners can safely experiment with kernel programming without being overwhelmed. For example:\n\n1. **No hardware dependencies** means the driver works on any Linux system (virtual or physical) without special hardware.\n2. **No production requirements** means we can use simple linear buffers instead of optimized ring buffers, making the code easier to understand.\n3. **No advanced features** means we can use the simpler `single_open` style for ProcFS instead of the more complex `seq_file` interface, reducing cognitive load.\n\nThese constraints mirror how kernel programming is often taught: starting with software-only drivers before progressing to hardware control, and focusing on correctness before optimization.\n\n### Implementation Guidance\n\nWhile this section primarily defines requirements rather than implementation, learners should use these goals and non-goals as a checklist throughout development. The following table provides a quick reference for what to include and what to avoid:\n\n| ✅ **DO Implement** | ❌ **DO NOT Implement** |\n|-------------------|-------------------------|\n| `copy_to_user`/`copy_from_user` for all boundary crossings | Direct dereferencing of user-space pointers |\n| Mutex protection for all buffer operations | Spinlocks for operations that may sleep |\n| Wait queues for blocking read when empty | Busy-wait loops polling buffer state |\n| Proper error checking and cleanup in `module_exit` | Ignoring allocation failures or cleanup |\n| Shared header file for `ioctl` command definitions | Hard-coded magic numbers for `ioctl` commands |\n| `/proc` entry showing buffer size, usage statistics | Complex sysfs attributes or debugfs entries |\n| `poll` support with `POLLIN`/`POLLRDNORM` events | Full `mmap` implementation or shared memory |\n| Kernel log messages at appropriate levels (`KERN_INFO`, `KERN_ERR`) | Console output or userspace logging libraries |\n\nFor project structure, organize code according to these boundaries:\n\n```\nsimplechardev/\n├── Makefile                    # Kbuild system for module compilation\n├── simplechardev.c             # Main driver implementation\n├── simplechardev.h             # Shared ioctl definitions (user/kernel)\n└── test_simplechardev.c       # Userspace test program (optional)\n```\n\nThis minimal structure reflects the project's focused scope—no separate directories for hardware abstraction, no complex build systems, and no extensive test frameworks. The simplicity allows learners to see the complete picture of a character device driver without organizational overhead.\n\n---\n\n\n## High-Level Architecture\n\n> **Milestone(s):** Milestone 1, Milestone 2, Milestone 3, Milestone 4 (architectural foundation for all components)\n\nThis section provides a bird's-eye view of the driver's internal architecture and its position within the broader Linux kernel ecosystem. Before diving into implementation details, it's crucial to understand how the driver's components fit together and interact with kernel subsystems. Think of the driver as a small business operating within a large industrial park (the kernel). This business has a reception desk (`Character Device Core`) that handles customer interactions, a storage room (`I/O Buffer`) for holding data, a manager (`Synchronization Manager`) who coordinates access to prevent chaos, an administrative office (`Module Lifecycle Manager`) that handles permits and licenses, and a public dashboard (`Proc/Control Interface`) displaying operational statistics. Each component has specific responsibilities and communicates through well-defined protocols enforced by the park's regulations (kernel APIs).\n\n![System Component Diagram](./diagrams/diagram-sys-component.svg)\n\n### Component Overview and Responsibilities\n\nThe driver decomposes into five logical components, each addressing a distinct aspect of the device driver problem space. This separation follows the **Single Responsibility Principle** adapted for kernel programming: each component manages one type of resource or handles one category of operations. This modular design makes the code easier to understand, test, and extend while aligning with Linux kernel conventions.\n\n| Component | Primary Responsibility | Key Kernel Subsystems Interacted With | Key Data Structures Owned |\n|-----------|------------------------|---------------------------------------|----------------------------|\n| **Module Lifecycle Manager** | Handle driver initialization and cleanup, registering/unregistering with the kernel. | Kernel module loader, device number registry, sysfs | `struct mydevice_data` (global instance), `dev_t` (device number), `struct class*` |\n| **Character Device Core** | Implement file operations (open, read, write, release) that userspace applications invoke via system calls. | Virtual File System (VFS), device model, memory management | `struct file_operations`, `struct cdev`, kernel buffer pointer |\n| **I/O Buffer** | Store data written from userspace and provide it for reads, managing memory allocation and bounds. | Kernel memory allocator (`kmalloc`/`kfree`) | Linear buffer (void*), buffer size (size_t) |\n| **Synchronization Manager** | Coordinate concurrent access from multiple processes, implement blocking reads, and support poll/select. | Kernel locking API, wait queue subsystem, poll mechanism | `struct mutex`, `struct wait_queue_head_t` |\n| **Proc/Control Interface** | Provide monitoring and control via `ioctl` system calls and `/proc` filesystem entries. | `ioctl` dispatch, proc filesystem | `struct proc_ops`, `ioctl` command definitions |\n\n#### Mental Model: The Driver as a Library with Controlled Access\nImagine a public library (the driver) where patrons (userspace processes) can store and retrieve messages. The **Module Lifecycle Manager** is the library's founding charter—it establishes the library's existence, obtains an official address (major/minor number), and registers with the city (kernel). The **Character Device Core** is the front desk staff—they handle check-ins (open), accept donations of books (write), lend books (read), and process check-outs (release). The **I/O Buffer** is the library's shelves—a finite space where books (data) are stored linearly. The **Synchronization Manager** is the librarian enforcing rules—only one patron can rearrange shelves at a time (mutex), and patrons waiting for new books must sit in a waiting area (wait queue) until notified. The **Proc/Control Interface** is the library's administrative office and public bulletin board—authorized staff can issue commands to resize shelves or clear inventory (`ioctl`), while any visitor can view statistics like total books stored (`/proc` entry).\n\n#### Component Interactions and Data Flow\nWhen a userspace program calls `write()` on `/dev/mychardev`, the interaction flows through these components sequentially:\n1. **VFS Layer** receives the system call and routes it to our driver's registered `file_operations.write` handler (Character Device Core).\n2. **Character Device Core** validates parameters, then requests the **Synchronization Manager** to acquire the mutex protecting the buffer.\n3. With the lock held, the Core uses `copy_from_user` to transfer data from userspace into the **I/O Buffer**.\n4. After transfer, the Core notifies the **Synchronization Manager** to wake up any processes sleeping on the wait queue (blocked readers).\n5. The **Synchronization Manager** releases the mutex, and control returns up the chain.\n\nSimilarly, when the module is loaded with `insmod`, the **Module Lifecycle Manager** executes first, allocating resources and registering the character device, which in turn creates the `/dev` node through kernel's device model. The `/proc` entry created by the **Proc/Control Interface** exists independently but reads statistics from the shared `struct mydevice_data`.\n\n> **Architectural Insight:** The driver follows a **stateful singleton** pattern. A single instance of `struct mydevice_data` contains all driver state (buffer, locks, device identifiers). This instance is globally accessible within the module but not exposed to other kernel modules. This design simplifies resource management because all cleanup can be performed by the Module Lifecycle Manager during module exit by freeing this one structure.\n\n#### ADR: Monolithic Module vs. Multiple Source Files\n\n**Decision: Single Source File for Core Logic with Separate Header for Shared Definitions**\n\n- **Context:** We must organize code for a learning-focused kernel module that demonstrates multiple concepts (device registration, file operations, ioctl, synchronization). The module is relatively small (~500 lines), but we need to share `ioctl` command definitions between kernel and userspace.\n- **Options Considered:**\n  1. **Single C file:** Place all code in one `.c` file for simplicity.\n  2. **Multiple C files:** Split components (lifecycle, char device, proc) into separate `.c` files for modularity.\n  3. **Core C file + shared header:** Keep driver logic in one `.c` file but separate `ioctl` definitions into a shared header used by both kernel module and userspace test program.\n- **Decision:** Option 3 (Core C file + shared header).\n- **Rationale:** \n  - **Learning Clarity:** Beginners benefit from seeing the complete driver flow in one file without cross-file navigation.\n  - **Kernel Convention:** Many simple drivers in Linux source tree use single-file organization.\n  - **Shared Definitions Necessity:** `ioctl` command numbers and data structures must be identical in kernel and userspace; a shared header ensures consistency without duplication.\n  - **Build Simplicity:** Single source file requires minimal `Makefile` complexity.\n- **Consequences:**\n  - **Positive:** Easy to trace code execution; straightforward compilation; clear separation of interface (header) and implementation.\n  - **Negative:** File may become long; components are not physically isolated (though logically separated via functions).\n  - **Mitigation:** Use clear section comments and logical grouping of functions by component.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Single C file | Simplest build, all code visible in one place | Can become monolithic, harder to navigate for very large drivers | No |\n| Multiple C files | Better modularity, separation of concerns | Increased build complexity, more cross-file references for learners | No |\n| Core C + shared header | Balances simplicity with interface separation, mandatory for shared ioctl definitions | Still single implementation file | **Yes** |\n\n### Recommended File and Module Structure\n\nThe physical layout of the project mirrors the logical decomposition while keeping the build process straightforward for learners. Following standard Linux kernel driver conventions, we place the module build configuration in a `Makefile` that invokes the kernel build system, and we separate userspace testing tools into their own directory.\n\n#### Directory and File Layout\n```\nproject-root/\n│\n├── Makefile                    # Kbuild Makefile for kernel module compilation\n├── chardev.c                   # Main driver implementation (all components)\n├── chardev.h                   # Shared header with ioctl definitions, structs\n├── userspace/\n│   ├── Makefile               # Simple Makefile for userspace test programs\n│   ├── test_ioctl.c           # Test program for ioctl commands\n│   └── test_concurrent.c      # Stress test for concurrent access\n└── README.md                  # Project documentation\n```\n\n#### File Responsibilities Table\n| File | Purpose | Key Contents | Used By |\n|------|---------|--------------|---------|\n| `Makefile` (root) | Invoke kernel build system to compile module | `obj-m += chardev.o`, Kbuild variables | Developer building module |\n| `chardev.c` | Implement all driver components | `module_init`/`exit`, `file_operations`, `proc_ops`, buffer management, mutex/waitqueue | Kernel module (`insmod`) |\n| `chardev.h` | Define shared constants and structures | `ioctl` command macros (`MYDEV_IOCTL_*`), `struct mydevice_data` declaration | `chardev.c` and userspace test programs |\n| `userspace/Makefile` | Compile userspace test programs with `gcc` | Standard compilation rules | Developer testing driver |\n| `userspace/test_ioctl.c` | Demonstrate `ioctl` commands | Includes `chardev.h`, calls `ioctl()` with various commands | Manual testing of Milestone 3 |\n| `userspace/test_concurrent.c` | Stress test concurrent reads/writes | Creates multiple processes performing simultaneous operations | Validation of Milestone 4 |\n\n#### ADR: In-Tree vs. Out-of-Tree Module Build\n\n**Decision: Build as Out-of-Tree Module Using Installed Kernel Headers**\n\n- **Context:** The driver is a learning project not intended for inclusion in the main Linux kernel source tree. We need a build method that works on standard Linux distributions without requiring the full kernel source.\n- **Options Considered:**\n  1. **In-tree build:** Place driver source within the Linux kernel source tree and build using the kernel's top-level Makefile.\n  2. **Out-of-tree with full kernel source:** Require the entire kernel source code, building against a specific source tree.\n  3. **Out-of-tree with kernel headers:** Use only the installed kernel headers (typically `/lib/modules/$(uname -r)/build`) to compile.\n- **Decision:** Option 3 (Out-of-tree with kernel headers).\n- **Rationale:**\n  - **Practicality:** Most developers have kernel headers installed via distribution packages (e.g., `linux-headers-$(uname -r)`), not the full multi-gigabyte kernel source.\n  - **Standard Practice:** This is the recommended approach for third-party kernel modules in Linux distributions.\n  - **Version Matching:** Using headers for the running kernel ensures compatibility with the exact kernel ABI.\n- **Consequences:**\n  - **Positive:** Minimal disk footprint; leverages distribution packaging; matches real-world driver development.\n  - **Negative:** Cannot build for kernels other than the running one without installing additional header packages.\n  - **Mitigation:** The `Makefile` uses `$(uname -r)` to detect current kernel version; developers can override `KERNELDIR` variable for cross-compilation.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| In-tree build | Accesses full kernel build infrastructure, easier upstreaming | Requires entire kernel source, not practical for learning project | No |\n| Out-of-tree with full source | More control over kernel configuration | Still requires full kernel source, large download | No |\n| Out-of-tree with headers | Lightweight, matches real-world module development | Limited to installed kernel versions | **Yes** |\n\n#### Component-to-File Mapping\nThe logical components described earlier map to sections within `chardev.c` through function groupings and data structure ownership:\n\n- **Module Lifecycle Manager:** `init_module()` (or `mydevice_init()`) and `cleanup_module()` (or `mydevice_exit()`) functions, plus global `struct mydevice_data *dev_data`.\n- **Character Device Core:** `struct file_operations mydevice_fops` with handlers `mydevice_open()`, `mydevice_read()`, `mydevice_write()`, `mydevice_release()`.\n- **I/O Buffer:** Fields within `struct mydevice_data`: `void *buffer`, `size_t size`, managed by helper functions `buffer_alloc()`, `buffer_free()`.\n- **Synchronization Manager:** Mutex and wait queue operations within read/write handlers, plus `mydevice_poll()` handler.\n- **Proc/Control Interface:** `mydevice_ioctl()` handler and `/proc` file operations via `struct proc_ops`.\n\n> **Design Principle:** While components are logically separate, they share the same `struct mydevice_data` instance. This centralizes state management and ensures all components have consistent view of device state. The mutex within this structure protects access across all components that touch the buffer.\n\n### Implementation Guidance\n\nThis subsection provides concrete starting points for implementing the architectural structure described above. The guidance assumes the primary language is C and follows Linux kernel programming conventions.\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option (Recommended for Learning) | Advanced Option (For Further Exploration) |\n|-----------|------------------------------------------|------------------------------------------|\n| Build System | Kbuild with external module Makefile | DKMS (Dynamic Kernel Module Support) for automatic rebuild on kernel updates |\n| Memory Allocation | `kmalloc()` + `kfree()` for simple buffer | `vmalloc()` for large buffers (>1 page), or slab allocator for many objects |\n| Synchronization | `mutex` + `wait_queue_head_t` | `rw_semaphore` for reader/writer pattern, or RCU for read-mostly data |\n| Proc Interface | `proc_create()` with `proc_ops` using `single_open` | Full `seq_file` interface for large outputs, or debugfs for debugging data |\n| Userspace Testing | Simple C programs with `open()`/`read()`/`write()`/`ioctl()` | Python scripts using `ctypes` or `fcntl`, or automated test suite with kernel CI |\n\n#### B. Recommended File/Module Structure (Expanded)\n\nCreate the following files with the initial content shown below. This structure implements the architectural decisions and provides a scaffold for each milestone.\n\n**Project Root `Makefile`:**\n```makefile\n# Kbuild syntax for out-of-tree kernel module building\nobj-m += chardev.o\n\n# Kernel headers location (adjust if cross-compiling)\nKERNELDIR ?= /lib/modules/$(shell uname -r)/build\nPWD := $(shell pwd)\n\nall:\n\t$(MAKE) -C $(KERNELDIR) M=$(PWD) modules\n\nclean:\n\t$(MAKE) -C $(KERNELDIR) M=$(PWD) clean\n\ninstall: all\n\tsudo insmod chardev.ko\n\nuninstall:\n\tsudo rmmod chardev\n\n# Userspace test programs\nuserspace:\n\t$(MAKE) -C userspace\n\n.PHONY: all clean install uninstall userspace\n```\n\n**Main Driver Header `chardev.h`:**\n```c\n#ifndef _CHARDEV_H_\n#define _CHARDEV_H_\n\n#include <linux/ioctl.h>  // For _IOR, _IOW macros\n\n// Define a magic number for our ioctl commands\n// This should be unique to avoid conflicts with other drivers\n#define MYDEVICE_IOC_MAGIC 'k'\n\n// IOCTL command definitions\n// RESIZE: takes new buffer size as integer argument\n#define MYDEVICE_IOCTL_RESIZE _IOW(MYDEVICE_IOC_MAGIC, 0, int)\n// CLEAR: no argument, just clear buffer\n#define MYDEVICE_IOCTL_CLEAR _IO(MYDEVICE_IOC_MAGIC, 1)\n// GET_SIZE: returns current buffer size\n#define MYDEVICE_IOCTL_GET_SIZE _IOR(MYDEVICE_IOC_MAGIC, 2, int)\n// GET_MAX_CAPACITY: returns maximum allowed buffer size\n#define MYDEVICE_IOCTL_GET_MAX_CAPACITY _IOR(MYDEVICE_IOC_MAGIC, 3, int)\n\n// Maximum buffer size limit (safety measure)\n#define MAX_BUFFER_SIZE (1024 * 1024)  // 1MB\n\n// Device name for /dev and proc entries\n#define DEVICE_NAME \"mychardev\"\n\n#endif  // _CHARDEV_H_\n```\n\n**Main Driver Implementation `chardev.c` Skeleton:**\n```c\n// SPDX-License-Identifier: GPL-2.0\n/*\n * Simple character device driver for educational purposes\n * Implements a kernel buffer accessible via /dev/mychardev\n */\n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n\n#include \"chardev.h\"  // Our shared header\n\n// --- Module Lifecycle Manager Component ---\n\n// Global device data structure (singleton instance)\nstruct mydevice_data {\n    void *buffer;           // I/O Buffer: kernel memory for stored data\n    size_t size;            // I/O Buffer: current allocated size\n    size_t data_len;        // I/O Buffer: amount of valid data stored\n    struct mutex mutex;     // Synchronization Manager: mutual exclusion lock\n    wait_queue_head_t read_wait; // Synchronization Manager: queue for blocking reads\n    struct cdev cdev;       // Character Device Core: kernel's char device structure\n    dev_t dev_num;          // Module Lifecycle: device major/minor number\n    struct class *dev_class; // Module Lifecycle: sysfs class for device creation\n    struct device *dev;     // Module Lifecycle: actual device instance\n};\n\nstatic struct mydevice_data *dev_data = NULL;\n\n// TODO 1: Implement module initialization function\n// Responsibilities:\n// 1. Allocate dev_data with kmalloc\n// 2. Initialize mutex and wait queue\n// 3. Allocate initial buffer (e.g., 4KB)\n// 4. Register character device region with alloc_chrdev_region\n// 5. Create sysfs class and device node\n// 6. Set up cdev structure with file_operations\nstatic int __init mydevice_init(void)\n{\n    int result = 0;\n    printk(KERN_INFO \"mydevice: Initializing driver\\n\");\n    // TODO: Fill with implementation from Milestone 1 and 2\n    return result;\n}\n\n// TODO 2: Implement module cleanup function\n// Responsibilities:\n// 1. Remove /proc entry if created\n// 2. Destroy device node and class\n// 3. Unregister character device region\n// 4. Free buffer memory\n// 5. Free dev_data structure\nstatic void __exit mydevice_exit(void)\n{\n    printk(KERN_INFO \"mydevice: Cleaning up driver\\n\");\n    // TODO: Fill with implementation from Milestone 1 and 2\n}\n\n// --- Character Device Core Component ---\n\n// TODO 3: Implement file_operations methods\n// open: simple increment of module usage count\nstatic int mydevice_open(struct inode *inode, struct file *filp)\n{\n    // TODO: Fill with implementation from Milestone 2\n    return 0;\n}\n\n// release: decrement module usage count\nstatic int mydevice_release(struct inode *inode, struct file *filp)\n{\n    // TODO: Fill with implementation from Milestone 2\n    return 0;\n}\n\n// read: copy data from kernel buffer to userspace\n// Must handle:\n// - Blocking when buffer empty (use wait_event_interruptible)\n// - Partial reads (return less than count)\n// - Proper offset management\nstatic ssize_t mydevice_read(struct file *filp, char __user *buf, \n                            size_t count, loff_t *f_pos)\n{\n    ssize_t retval = 0;\n    // TODO: Fill with implementation from Milestone 2 and 4\n    return retval;\n}\n\n// write: copy data from userspace to kernel buffer\n// Must handle:\n// - Buffer capacity limits\n// - Waking up sleeping readers after write\nstatic ssize_t mydevice_write(struct file *filp, const char __user *buf,\n                             size_t count, loff_t *f_pos)\n{\n    ssize_t retval = 0;\n    // TODO: Fill with implementation from Milestone 2 and 4\n    return retval;\n}\n\n// poll: support for select()/poll() system calls\nstatic __poll_t mydevice_poll(struct file *filp, poll_table *wait)\n{\n    __poll_t mask = 0;\n    // TODO: Fill with implementation from Milestone 4\n    return mask;\n}\n\n// Define the file_operations structure linking handlers\nstatic const struct file_operations mydevice_fops = {\n    .owner = THIS_MODULE,\n    .open = mydevice_open,\n    .release = mydevice_release,\n    .read = mydevice_read,\n    .write = mydevice_write,\n    .poll = mydevice_poll,\n    .unlocked_ioctl = mydevice_ioctl,  // Defined in Control Interface\n    // .llseek = no_llseek,  // Optional: device doesn't support seek\n};\n\n// --- Control Interface Component ---\n\n// TODO 4: Implement ioctl handler\n// Responsibilities:\n// 1. Use switch statement on cmd argument\n// 2. Handle MYDEVICE_IOCTL_RESIZE: validate size, realloc buffer\n// 3. Handle MYDEVICE_IOCTL_CLEAR: reset data_len to 0\n// 4. Handle MYDEVICE_IOCTL_GET_SIZE: return current buffer size\n// 5. Handle MYDEVICE_IOCTL_GET_MAX_CAPACITY: return MAX_BUFFER_SIZE\n// 6. For invalid commands, return -ENOTTY\nstatic long mydevice_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n    long retval = 0;\n    // TODO: Fill with implementation from Milestone 3\n    return retval;\n}\n\n// TODO 5: Implement /proc file operations\n// proc_show: display device statistics when /proc/mychardev is read\nstatic int mydevice_proc_show(struct seq_file *m, void *v)\n{\n    // TODO: Fill with implementation from Milestone 3\n    // Example: seq_printf(m, \"Buffer size: %zu\\n\", dev_data->size);\n    return 0;\n}\n\nstatic int mydevice_proc_open(struct inode *inode, struct file *file)\n{\n    return single_open(file, mydevice_proc_show, NULL);\n}\n\nstatic const struct proc_ops mydevice_proc_fops = {\n    .proc_open = mydevice_proc_open,\n    .proc_read = seq_read,\n    .proc_lseek = seq_lseek,\n    .proc_release = single_release,\n};\n\n// Module metadata\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Simple character device driver for learning\");\nMODULE_VERSION(\"0.1\");\n\n// Register init/exit functions\nmodule_init(mydevice_init);\nmodule_exit(mydevice_exit);\n```\n\n**Userspace Test Program `userspace/test_ioctl.c` Skeleton:**\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include \"../chardev.h\"  // Shared header with ioctl definitions\n\nint main(int argc, char *argv[])\n{\n    int fd = open(\"/dev/\" DEVICE_NAME, O_RDWR);\n    if (fd < 0) {\n        perror(\"Failed to open device\");\n        return 1;\n    }\n    \n    // TODO: Test various ioctl commands\n    // 1. GET_SIZE to see initial size\n    // 2. RESIZE to change buffer size\n    // 3. WRITE some data\n    // 4. READ back data\n    // 5. CLEAR buffer\n    // 6. GET_MAX_CAPACITY to see limit\n    \n    close(fd);\n    return 0;\n}\n```\n\n#### C. Infrastructure Starter Code\n\nFor components that are prerequisites but not core learning goals, here is complete helper code that can be added to `chardev.c`:\n\n**Buffer Management Helpers (I/O Buffer Component):**\n```c\n// Allocate or resize the internal buffer\nstatic int buffer_resize(struct mydevice_data *dev, size_t new_size)\n{\n    void *new_buf;\n    \n    if (new_size > MAX_BUFFER_SIZE) {\n        printk(KERN_ERR \"mydevice: Requested size %zu exceeds maximum %d\\n\",\n               new_size, MAX_BUFFER_SIZE);\n        return -EINVAL;\n    }\n    \n    new_buf = kmalloc(new_size, GFP_KERNEL);\n    if (!new_buf) {\n        printk(KERN_ERR \"mydevice: Failed to allocate buffer of size %zu\\n\",\n               new_size);\n        return -ENOMEM;\n    }\n    \n    // Copy existing data (up to minimum of old and new size)\n    if (dev->buffer) {\n        size_t copy_len = (dev->data_len < new_size) ? dev->data_len : new_size;\n        memcpy(new_buf, dev->buffer, copy_len);\n        dev->data_len = copy_len;  // Truncate if buffer shrunk\n        kfree(dev->buffer);\n    } else {\n        dev->data_len = 0;\n    }\n    \n    dev->buffer = new_buf;\n    dev->size = new_size;\n    printk(KERN_INFO \"mydevice: Buffer resized to %zu bytes\\n\", new_size);\n    return 0;\n}\n\n// Initialize buffer with default size\nstatic int buffer_init(struct mydevice_data *dev, size_t initial_size)\n{\n    dev->buffer = NULL;\n    dev->size = 0;\n    dev->data_len = 0;\n    return buffer_resize(dev, initial_size);\n}\n\n// Free buffer memory\nstatic void buffer_cleanup(struct mydevice_data *dev)\n{\n    if (dev->buffer) {\n        kfree(dev->buffer);\n        dev->buffer = NULL;\n        dev->size = 0;\n        dev->data_len = 0;\n    }\n}\n```\n\n#### D. Core Logic Skeleton Code\n\nFor the core components learners should implement themselves, here are detailed TODO skeletons mapping to the architectural responsibilities:\n\n**Module Initialization Detailed TODOs:**\n```c\nstatic int __init mydevice_init(void)\n{\n    int result = 0;\n    dev_t dev = 0;\n    \n    printk(KERN_INFO \"mydevice: Initializing driver\\n\");\n    \n    // TODO 1.1: Allocate dev_data with kzalloc (zero-initialized)\n    // Hint: Use GFP_KERNEL flag, check for NULL\n    \n    // TODO 1.2: Initialize mutex with mutex_init()\n    \n    // TODO 1.3: Initialize wait queue with init_waitqueue_head()\n    \n    // TODO 1.4: Allocate initial buffer (e.g., 4096 bytes) using buffer_init()\n    \n    // TODO 1.5: Allocate device numbers with alloc_chrdev_region()\n    // - Use &dev for first device number\n    // - Base minor = 0, count = 1\n    // - Device name = DEVICE_NAME\n    // - Check return value\n    \n    // TODO 1.6: Initialize cdev structure with cdev_init()\n    // - Link to mydevice_fops\n    // - Add to system with cdev_add()\n    \n    // TODO 1.7: Create device class with class_create()\n    // - THIS_MODULE as owner\n    // - Name = DEVICE_NAME \"_class\"\n    \n    // TODO 1.8: Create device node with device_create()\n    // - Use created class, parent = NULL, devt = dev\n    // - Device data = dev_data\n    // - Name = DEVICE_NAME\n    \n    // TODO 1.9: Create /proc entry with proc_create()\n    // - Name = DEVICE_NAME\n    // - Mode = 0444 (read-only)\n    // - Link to mydevice_proc_fops\n    \n    // TODO 1.10: On any failure, clean up already-allocated resources\n    // in reverse order (implement goto error handling pattern)\n    \n    return result;\n}\n```\n\n#### E. Language-Specific Hints (Kernel C)\n\n1. **Error Codes:** Always return negative `errno` values (e.g., `-ENOMEM`, `-EINVAL`) from kernel functions called by userspace system calls. The VFS will convert these to `-1` return with appropriate `errno` in userspace.\n\n2. **Memory Allocation:** Use `GFP_KERNEL` for allocations that can sleep (in process context). Never use `GFP_KERNEL` in interrupt context or while holding a spinlock.\n\n3. **Print Debugging:** Use `printk` with appropriate log levels: `KERN_INFO` for normal messages, `KERN_ERR` for errors. View output with `dmesg -w` to watch in real-time.\n\n4. **User Memory Access:** Always use `copy_to_user()` and `copy_from_user()`—never dereference userspace pointers directly. Check return values (0 = success, >0 = number of bytes NOT copied).\n\n5. **Module Parameters:** Consider adding `module_param()` macros later to allow configuration via `insmod chardev.ko buffer_size=8192`.\n\n#### F. Milestone Checkpoint\n\nAfter implementing the high-level architecture with the skeleton code:\n\n1. **Build Verification:**\n   ```bash\n   make  # Should output: CC [M]  chardev.o; Building modules, [OK]\n   ```\n\n2. **Module Info Check:**\n   ```bash\n   modinfo chardev.ko\n   ```\n   Expected output shows correct license, author, description.\n\n3. **Load Test:**\n   ```bash\n   sudo insmod chardev.ko\n   dmesg | tail -5\n   ```\n   Should show \"mydevice: Initializing driver\" and no error messages.\n\n4. **Device Node Creation:**\n   ```bash\n   ls -la /dev/mychardev\n   ```\n   Should show character device with major/minor numbers.\n\n5. **Proc Entry Verification:**\n   ```bash\n   cat /proc/mychardev\n   ```\n   Should show buffer statistics (once implemented).\n\nIf any step fails, check `dmesg` for kernel error messages—they often provide specific failure reasons like \"Cannot allocate memory\" or \"Device or resource busy\".\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| `insmod` fails with \"Unknown symbol in module\" | Missing module license or dependency | `dmesg | tail` shows which symbol is missing | Ensure `MODULE_LICENSE(\"GPL\")` is declared |\n| `/dev/mychardev` not created | Device creation failed in init | Check `dmesg` for \"device_create failed\" | Verify `class_create()` succeeded before `device_create()` |\n| Write succeeds but read returns 0 | Buffer not being filled or read offset wrong | Add `printk` in read/write to trace data flow | Ensure `data_len` is updated on write and read updates offset |\n| Multiple processes cause system hang | Deadlock in mutex usage | Add debug prints before/after mutex_lock/unlock | Check for double-locking or missing unlock on error paths |\n| `ioctl` returns `-1` with `errno=22` (EINVAL) | Invalid ioctl command number mismatch | Compare command numbers in kernel and userspace headers | Ensure `chardev.h` is identical in kernel and userspace builds |\n\n\n## Data Model\n> **Milestone(s):** Milestone 2, Milestone 3, Milestone 4 (data structures and ioctl definitions)\n\nThis section defines the fundamental building blocks that represent the driver's internal state and the contract for communication with user-space applications. In kernel programming, data structures must be carefully designed to ensure thread safety, proper memory management, and clear boundaries between kernel and user space. The data model serves as the \"source of truth\" for what the driver can do and how it maintains its state across multiple concurrent accesses.\n\n### Kernel-Side Data Structures\n\n**Mental Model: The Driver's Filing Cabinet**\n\nThink of the driver's internal data as a specialized filing cabinet in a shared office (the kernel). Each drawer (data structure field) holds specific types of information, and there are rules about who can open which drawers and when. The main cabinet, `struct mydevice_data`, contains everything the driver needs to operate: a drawer for storing data (buffer), a lock to prevent two people from accessing the cabinet simultaneously (mutex), a waiting area for people expecting new documents (wait queue), and identification tags so the office manager (kernel) knows which cabinet is which (device identifiers). This cabinet exists only in the secured office area (kernel space) and cannot be directly accessed from the public area (user space).\n\nThe primary data structure, `struct mydevice_data`, encapsulates the complete state of a single device instance. Since this driver follows the **singleton pattern** (one device instance), a single global instance of this structure manages all operations. The structure must be allocated and initialized during module loading and cleaned up during module unloading.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `buffer` | `void*` | Pointer to dynamically allocated kernel memory that stores data written from user space. Acts as a simple linear buffer where data is appended at the end and read from the beginning. |\n| `size` | `size_t` | Total capacity of the buffer in bytes. This represents the maximum amount of data the buffer can hold at any time, set during initialization and potentially changed via `ioctl` resize operations. |\n| `data_len` | `size_t` | Current number of valid bytes stored in the buffer. This tracks how much of the buffer's capacity is actually occupied with data available for reading. When `data_len` is 0, the buffer is empty; when equal to `size`, the buffer is full. |\n| `mutex` | `struct mutex` | Mutual exclusion lock that protects all accesses to the buffer and related fields (`buffer`, `size`, `data_len`). Ensures that only one thread (or process) can modify the buffer state at a time, preventing data corruption from concurrent writes or simultaneous read/write operations. |\n| `read_wait` | `struct wait_queue_head_t` | Wait queue head where reader processes can sleep when the buffer is empty. When a process tries to read but `data_len` is 0, it adds itself to this queue and sleeps until a writer adds data and wakes it up. |\n| `cdev` | `struct cdev` | Embedded character device structure that links our driver to the kernel's character device subsystem. Contains pointers to our `file_operations` functions and is registered with the kernel via `cdev_add`. |\n| `dev_num` | `dev_t` | Combined device number (major and minor) assigned during `alloc_chrdev_region`. The major number identifies our driver type, while the minor number (always 0 for our singleton) identifies this specific device instance. |\n| `dev_class` | `struct class*` | Pointer to the device class created via `class_create`. Used by the kernel's `sysfs` to expose device information in `/sys/class/`. |\n| `device` | `struct device*` | Pointer to the device instance created via `device_create`. This triggers the automatic creation of the device node in `/dev/` (e.g., `/dev/mychardev`). |\n\n![Data Model and State Relationships](./diagrams/diagram-data-model.svg)\n\n**State Transitions and Buffer Management**\n\nThe buffer operates as a simple linear storage with three primary states, which can be modeled as a state machine:\n\n| Current State | Event | Next State | Actions Taken |\n|---------------|-------|------------|---------------|\n| **EMPTY** (`data_len == 0`) | Write successful (bytes > 0) | **PARTIALLY_FILLED** | Increment `data_len` by written bytes, wake up any sleeping readers on `read_wait` |\n| **EMPTY** | Read attempted | **EMPTY** (unchanged) | Reader process sleeps on `read_wait` (blocking), returns 0 if non-blocking |\n| **PARTIALLY_FILLED** (`0 < data_len < size`) | Write successful | **PARTIALLY_FILLED** or **FULL** | Increment `data_len`, if `data_len` reaches `size`, transition to FULL |\n| **PARTIALLY_FILLED** | Read successful | **PARTIALLY_FILLED** or **EMPTY** | Decrement `data_len` by read bytes, if `data_len` becomes 0, transition to EMPTY |\n| **FULL** (`data_len == size`) | Write attempted | **FULL** (unchanged) | Write returns `-ENOSPC` (no space), writer may block or return immediately |\n| **FULL** | Read successful | **PARTIALLY_FILLED** | Decrement `data_len` by read bytes, wake up any sleeping writers (if we implement blocking write) |\n\n**Relationship Between Structures**\n\nThe `struct mydevice_data` serves as the central hub connecting all driver components. The `cdev` field links to the VFS layer when file operations occur—when a user-space process opens `/dev/mychardev`, the kernel finds our `cdev`, which points to our `file_operations` functions, and passes the `struct mydevice_data` as the `private_data` in the `struct file`. The `mutex` protects concurrent access to the buffer, while the `read_wait` enables synchronization between readers and writers. The `dev_class` and `device` fields connect to the device model, creating the user-visible interface in `/dev/`.\n\n**Memory Lifetime and Ownership**\n\nThe `buffer` pointer owns a dynamically allocated memory region via `kmalloc`. Its lifetime is tied to the module: allocated in `mydevice_init` (or on first resize), potentially reallocated during resize operations, and freed in `mydevice_exit`. The `size` field tracks the current allocation size, while `data_len` tracks how much is actually in use. All other fields (mutex, wait queue, cdev) are initialized during module init and cleaned up during exit.\n\n> **Design Insight:** Using a single structure that contains all driver state (`struct mydevice_data`) is crucial for kernel programming. It provides a clear ownership model (the module owns this structure), simplifies error cleanup (one structure to free), and enables safe concurrent access (one mutex protecting all related data). This pattern is standard in Linux device drivers.\n\n### User-Space Ioctl Command Format\n\n**Mental Model: The Driver's Remote Control**\n\nImagine the `ioctl` interface as a specialized remote control for our device. Each button on the remote (ioctl command) performs a specific action: one button resizes the buffer, another clears it, and others query status information. The remote communicates with the device using a predefined protocol (command numbers and data structures) that both sides understand. User-space applications \"press buttons\" by calling `ioctl()` with the right command code and optional parameters, and the driver executes the corresponding action and returns results.\n\nThe `ioctl` interface requires careful definition to ensure compatibility between kernel and user space. We define a shared header file (e.g., `mydevice.h`) that contains command numbers and any data structures used for parameter passing. This header is included by both the kernel module and user-space test programs.\n\n> **Decision: Centralized ioctl Command Definitions**\n> - **Context**: `ioctl` commands must be uniquely identified by numbers that both kernel and user space agree upon. We need a consistent way to define these commands that prevents collisions and ensures type safety.\n> - **Options Considered**: \n>   1. **Hard-coded numbers in both places**: Define the same numeric constants separately in kernel and user code.\n>   2. **Shared header file with macros**: Create a single header file that uses Linux's `_IO*` macros, included by both kernel and user programs.\n> - **Decision**: Use a shared header file with properly constructed `ioctl` commands using the standard Linux macros (`_IOR`, `_IOW`, `_IOWR`).\n> - **Rationale**: The shared header ensures consistency and prevents subtle bugs where kernel and user space disagree on command numbers. The standard macros incorporate direction (read/write) and data size, providing compile-time checks and documentation. This is the established Linux driver pattern.\n> - **Consequences**: User-space programs must include this header; any changes to command definitions require recompilation of both kernel module and user programs.\n\n**Ioctl Command Number Construction**\n\nLinux `ioctl` commands are 32-bit numbers divided into fields:\n- **Direction** (bits 30-31): Whether data flows from user to kernel (`_IOW`), kernel to user (`_IOR`), both (`_IOWR`), or none (`_IO`).\n- **Size** (bits 16-29): Size of the data argument passed.\n- **Type** (bits 8-15): \"Magic number\" unique to our driver, preventing collisions with other drivers.\n- **Number** (bits 0-7): The specific command within our driver.\n\nWe define our magic number and commands as follows:\n\n| Constant | Value/Definition | Purpose |\n|----------|------------------|---------|\n| `MYDEVICE_IOC_MAGIC` | `'k'` (ASCII character) | Unique magic number for our driver (chosen from unallocated range). |\n| `MYDEVICE_IOCTL_GET_SIZE` | `_IOR(MYDEVICE_IOC_MAGIC, 1, size_t)` | Command to get current buffer size (data flows from kernel to user). |\n| `MYDEVICE_IOCTL_GET_MAX_CAPACITY` | `_IOR(MYDEVICE_IOC_MAGIC, 2, size_t)` | Command to get maximum allowed buffer size (1MB). |\n| `MYDEVICE_IOCTL_CLEAR` | `_IO(MYDEVICE_IOC_MAGIC, 3)` | Command to clear buffer (no data argument). |\n| `MYDEVICE_IOCTL_RESIZE` | `_IOW(MYDEVICE_IOC_MAGIC, 4, size_t)` | Command to resize buffer (data flows from user to kernel). |\n\n**Data Structures for Parameter Passing**\n\nFor commands that transfer data (`_IOR`, `_IOW`, `_IOWR`), we use standard C types. The `size_t` type is used for size-related operations, but we must be careful about its size differences between kernel and user space (both are typically 64-bit on modern systems, but we should use `__kernel_size_t` in the shared header for portability). For more complex drivers, custom structures would be defined here.\n\n**Maximum Buffer Size Limitation**\n\nWe define `MAX_BUFFER_SIZE` as `(1024 * 1024)` (1 MiB) to prevent users from accidentally requesting excessive kernel memory. This protects the system from denial-of-service attacks where a malicious user might try to allocate huge buffers.\n\n**Ioctl Command Semantics**\n\nEach command has specific behavior and error conditions:\n\n| Command | User-Space Argument | Kernel Action | Success Return | Error Conditions |\n|---------|---------------------|---------------|----------------|------------------|\n| `MYDEVICE_IOCTL_GET_SIZE` | Pointer to `size_t` | Copies `dev->size` to user pointer | 0 | `-EFAULT` if `copy_to_user` fails |\n| `MYDEVICE_IOCTL_GET_MAX_CAPACITY` | Pointer to `size_t` | Copies `MAX_BUFFER_SIZE` to user pointer | 0 | `-EFAULT` if `copy_to_user` fails |\n| `MYDEVICE_IOCTL_CLEAR` | None (ignored) | Sets `dev->data_len = 0` | 0 | None (always succeeds) |\n| `MYDEVICE_IOCTL_RESIZE` | `size_t` new_size | Reallocates buffer to new size (if ≤ `MAX_BUFFER_SIZE`) | 0 | `-EINVAL` if new_size > `MAX_BUFFER_SIZE`, `-ENOMEM` if allocation fails, `-EFAULT` if `copy_from_user` fails |\n\n**Example User-Space Usage**\n\nA user-space program would use these commands like:\n```c\n#include \"mydevice.h\"\nint fd = open(\"/dev/mychardev\", O_RDWR);\nsize_t current_size;\nioctl(fd, MYDEVICE_IOCTL_GET_SIZE, &current_size);\n```\n\n### Common Pitfalls: Data Model\n\n⚠️ **Pitfall: Uninitialized mutex or wait queue**\n- **Description**: Forgetting to initialize the mutex with `mutex_init()` or the wait queue with `init_waitqueue_head()` before using them.\n- **Why it's wrong**: An uninitialized mutex or wait queue leads to undefined behavior, often causing immediate kernel panics or deadlocks when first accessed.\n- **Fix**: Always initialize synchronization primitives in the module's initialization function before any concurrent access is possible.\n\n⚠️ **Pitfall: Incorrect buffer size tracking**\n- **Description**: Mismanaging the relationship between `size` (capacity) and `data_len` (used bytes), such as allowing `data_len` to exceed `size` or not updating `data_len` after operations.\n- **Why it's wrong**: This can cause buffer overflows (writing past allocated memory) or incorrect behavior where reads return wrong data or hang indefinitely.\n- **Fix**: Always update `data_len` atomically with buffer operations, and check boundaries before any read/write.\n\n⚠️ **Pitfall: Wrong ioctl command numbering**\n- **Description**: Using arbitrary numbers for ioctl commands without the proper `_IOR`/`_IOW` macros, or using the same command number for different operations.\n- **Why it's wrong**: Command number collisions can cause the wrong handler to execute; incorrect direction/size encoding can cause memory corruption or failed copies.\n- **Fix**: Always use the standard macros with a unique magic number, and document each command clearly in the shared header.\n\n⚠️ **Pitfall: Assuming size_t is same size in kernel and user space**\n- **Description**: Using `size_t` in shared header without considering that kernel and user space might compile with different definitions (though rare on same architecture).\n- **Why it's wrong**: If sizes differ, `copy_to_user`/`copy_from_user` may copy wrong amount of data, causing corruption.\n- **Fix**: Use `__kernel_size_t` in shared headers or explicitly use fixed-width types like `uint64_t`.\n\n### Implementation Guidance\n\n**A. Technology Recommendations Table**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Buffer Storage | Linear `kmalloc` buffer with separate `size`/`data_len` | Circular buffer with head/tail pointers for better performance |\n| Ioctl Interface | Standard `_IOR`/`_IOW` macros with `size_t` parameters | Complex structures with versioning and capability flags |\n| State Tracking | Simple `data_len` counter | Bitmask flags for buffer states (EMPTY, FULL, etc.) |\n\n**B. Recommended File/Module Structure**\n\n```\nproject-root/\n  Makefile                    # Kbuild makefile\n  mychardev.c                 # Main driver implementation\n  mychardev.h                 # Shared header for ioctl definitions (included by kernel AND user)\n  test_mychardev.c            # Userspace test program\n```\n\n**C. Infrastructure Starter Code**\n\n**File: `mychardev.h`** (shared header)\n```c\n#ifndef MYCHARDEV_H\n#define MYCHARDEV_H\n\n#include <linux/ioctl.h>  // For _IOR, _IOW, etc.\n#include <linux/types.h>  // For __kernel_size_t\n\n/* Magic number for our ioctl commands */\n#define MYDEVICE_IOC_MAGIC 'k'\n\n/* Maximum buffer size (1 MiB) */\n#define MAX_BUFFER_SIZE (1024 * 1024)\n\n/* \n * Sizes of arguments for ioctl commands.\n * We use __kernel_size_t which is the kernel's size_t type,\n * ensuring consistency between kernel and user space.\n */\ntypedef __kernel_size_t mydevice_size_t;\n\n/* \n * IOCTL command definitions.\n * Format: _IOR/_IOW/_IO(magic, number, datatype)\n */\n#define MYDEVICE_IOCTL_GET_SIZE _IOR(MYDEVICE_IOC_MAGIC, 1, mydevice_size_t)\n#define MYDEVICE_IOCTL_GET_MAX_CAPACITY _IOR(MYDEVICE_IOC_MAGIC, 2, mydevice_size_t)\n#define MYDEVICE_IOCTL_CLEAR _IO(MYDEVICE_IOC_MAGIC, 3)\n#define MYDEVICE_IOCTL_RESIZE _IOW(MYDEVICE_IOC_MAGIC, 4, mydevice_size_t)\n\n/* Ensure unique command numbers - add new ones sequentially */\n#define MYDEVICE_IOCTL_MAXNR 4  /* Highest command number we use */\n\n#endif /* MYCHARDEV_H */\n```\n\n**D. Core Logic Skeleton Code**\n\n**In `mychardev.c`:**\n```c\n/* \n * Main device state structure.\n * All device instance data is contained here.\n */\nstruct mydevice_data {\n    void *buffer;                   /* Kernel buffer for stored data */\n    size_t size;                    /* Total capacity of buffer */\n    size_t data_len;                /* Current data length in buffer */\n    struct mutex mutex;             /* Mutex for buffer protection */\n    wait_queue_head_t read_wait;    /* Wait queue for blocking reads */\n    struct cdev cdev;               /* Character device structure */\n    dev_t dev_num;                  /* Device number (major+minor) */\n    struct class *dev_class;        /* Device class for sysfs */\n    struct device *device;          /* Device instance for /dev */\n};\n\n/* Global device instance (singleton) */\nstatic struct mydevice_data mydevice;\n\n/*\n * Initialize the device buffer.\n * Called during module initialization and buffer resize.\n * Returns 0 on success, negative error code on failure.\n */\nstatic int buffer_init(struct mydevice_data *dev, size_t initial_size)\n{\n    /* TODO 1: Check if initial_size is valid (non-zero, ≤ MAX_BUFFER_SIZE) */\n    /* TODO 2: Allocate memory with kmalloc using GFP_KERNEL flag */\n    /* TODO 3: If allocation succeeds, update dev->buffer and dev->size */\n    /* TODO 4: Initialize dev->data_len to 0 (empty buffer) */\n    /* TODO 5: Return 0 on success, -ENOMEM on allocation failure */\n}\n\n/*\n * Clean up the device buffer.\n * Called during module cleanup and buffer resize (before reallocation).\n */\nstatic void buffer_cleanup(struct mydevice_data *dev)\n{\n    /* TODO 1: Check if dev->buffer is not NULL */\n    /* TODO 2: Free the buffer memory with kfree */\n    /* TODO 3: Set dev->buffer to NULL and dev->size to 0 */\n    /* TODO 4: Reset dev->data_len to 0 */\n}\n\n/*\n * Resize the device buffer.\n * Called from ioctl handler with mutex already held.\n * Returns 0 on success, negative error code on failure.\n */\nstatic int buffer_resize(struct mydevice_data *dev, size_t new_size)\n{\n    /* TODO 1: Validate new_size (must be ≤ MAX_BUFFER_SIZE, > 0) */\n    /* TODO 2: If new_size equals current dev->size, return 0 (no-op) */\n    /* TODO 3: Allocate new buffer with kmalloc */\n    /* TODO 4: If allocation fails, return -ENOMEM */\n    /* TODO 5: Copy existing data from old buffer to new buffer (up to min(dev->data_len, new_size)) */\n    /* TODO 6: Update dev->data_len to reflect copied amount (might be truncated if new_size smaller) */\n    /* TODO 7: Free old buffer with kfree */\n    /* TODO 8: Update dev->buffer and dev->size */\n    /* TODO 9: Return 0 on success */\n}\n```\n\n**E. Language-Specific Hints**\n\n1. **Kernel memory allocation**: Always use `kmalloc` with `GFP_KERNEL` for buffers that may sleep (our case), or `GFP_ATOMIC` for interrupt context. Remember to check return value for NULL.\n2. **Size types**: Use `size_t` for buffer sizes within the kernel module, but convert to/from `mydevice_size_t` (from shared header) when communicating with user space.\n3. **Structure initialization**: For the global `mydevice` instance, use `= {0}` to ensure all pointers are NULL before initialization.\n4. **Error codes**: Return negative `errno` values (e.g., `-ENOMEM`, `-EINVAL`) from functions that may fail.\n\n**F. Milestone Checkpoint**\n\nAfter implementing the data structures:\n1. **Compilation test**: Run `make` to ensure the module compiles without errors. The shared header should compile in both kernel context (as part of the module) and user context (when included in test program).\n2. **Structure verification**: Use `modinfo` to check module information, then load with `insmod`. Check `dmesg` for any initialization errors.\n3. **Ioctl header test**: Create a simple user-space program that includes `mychardev.h` and prints the values of the ioctl constants. Compile with `gcc -o test_header test_header.c` to verify the header works in user space.\n\n**Expected behavior**: Module loads without errors; header file compiles in both kernel and user space; ioctl command numbers are consistent.\n\n**Signs of trouble**: \n- Compilation errors about unknown types in `mychardev.h`: Likely missing proper kernel headers inclusion guard.\n- Module fails to load with \"Invalid argument\": Possible uninitialized mutex or wait queue causing panic during initialization.\n\n**G. Debugging Tips**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Kernel panic on first read/write | Uninitialized mutex or wait queue | Check `dmesg` for backtrace showing mutex/wait queue functions | Call `mutex_init()` and `init_waitqueue_head()` in `mydevice_init()` |\n| Buffer appears corrupted after resize | Incorrect data copying during resize | Add `printk` to show old/new sizes and data_len before/after copy | Ensure you copy only `min(old_data_len, new_size)` bytes |\n| ioctl returns \"Invalid argument\" (`EINVAL`) | Wrong command number or size | Compare command number in user program with kernel definition using `printk` | Ensure shared header is identical in kernel and user builds |\n| Buffer size shows wrong value after resize | Not updating dev->size field | Add debug prints in resize function showing dev->size changes | Update dev->size after successful reallocation |\n\n\n## Component: Module Lifecycle Manager\n\n> **Milestone(s):** Milestone 1\n\nThis component is the kernel module's entry and exit point. It manages the driver's birth and death within the running kernel, securing all necessary resources during initialization and releasing them during cleanup. Its design ensures the driver can be loaded and unloaded dynamically without affecting the stability of the operating system.\n\n### Mental Model: The Driver's Birth and Death Certificate\n\nImagine the Linux kernel as a highly secure, constantly running industrial facility. A **kernel module** is like a specialized piece of equipment (our driver) that you want to install into this facility to add new functionality. The **Module Lifecycle Manager** is the formal process for getting this equipment certified, connected to the facility's power and control systems, and later, for decommissioning it safely.\n\n-   **Loading (`insmod`)**: This is the installation and certification process. You submit your equipment's blueprints (the compiled module) to the facility's management (the kernel). The `module_init` function is your equipment's startup routine, which must:\n    1.  **Request an official equipment ID**: Ask the facility for a unique device number (`alloc_chrdev_region`) so your device can be identified in the `/dev` directory.\n    2.  **Connect to the control panel**: Register your device's operational manual (`file_operations`) with the facility's Virtual File System (VFS), so user programs know how to interact with it.\n    3.  **Install the user-facing interface**: Create an accessible control panel (the `/dev/mychardev` node) using `device_create`, so users can issue commands.\n    4.  **Allocate private workspace**: Secure a private memory area (`kmalloc`) for the driver's internal data buffer.\n    5.  **Announce successful installation**: Log a message (`printk`) to the facility's central log (`dmesg`) confirming the driver is operational.\n\n-   **Unloading (`rmmod`)**: This is the decommissioning process. The `module_exit` function is the meticulous shutdown checklist, which must **reverse every single action** performed during initialization in the exact opposite order:\n    1.  **Remove the user-facing interface**: Dismantle the control panel (`device_destroy` and `class_destroy`).\n    2.  **Disconnect from the control panel**: Unregister the operational manual (`cdev_del`).\n    3.  **Return the equipment ID**: Release the unique device number (`unregister_chrdev_region`).\n    4.  **Clean up the private workspace**: Free the allocated memory (`kfree`).\n    5.  **Announce decommissioning**: Log a final message confirming the driver has been cleanly removed.\n\nForgetting any step in the cleanup process is like leaving your equipment plugged in and taking up space after your contract ends—it leads to resource leaks and can destabilize the entire facility (kernel). The golden rule is: **for every `alloc`, `create`, or `register` in `init`, there must be a corresponding `free`, `destroy`, or `unregister` in `exit`**.\n\n### ADR: Dynamic vs. Static Device Number Allocation\n\n> **Decision: Use `alloc_chrdev_region` for Dynamic Major Number Allocation**\n\n-   **Context**: Character devices in Linux are identified by a major number (device type) and minor number (device instance). The driver must obtain a unique major number to create its `/dev` node. The kernel provides two primary methods: requesting a specific, static number or asking the kernel to assign one dynamically.\n-   **Options Considered**:\n    1.  **Static allocation with `register_chrdev`**: The driver requests a specific, well-known major number (e.g., 240). This is simple but prone to conflicts if another driver or module is already using that number.\n    2.  **Dynamic allocation with `alloc_chrdev_region`**: The driver asks the kernel to assign an available major number from a pool. The driver then uses this assigned number.\n-   **Decision**: We will use dynamic allocation via `alloc_chrdev_region`.\n-   **Rationale**:\n    -   **Conflict Avoidance**: This is the primary reason for an educational, out-of-tree module. Learners may run the module on various systems where static numbers could be occupied. Dynamic allocation guarantees a free number, preventing load failures.\n    -   **Modern Practice**: The older `register_chrdev` function registers a single major number for all 256 minor numbers and uses a global `file_operations` structure. The newer `alloc_chrdev_region` and `cdev_init` API is more flexible and is the recommended approach for new drivers, allowing for better structure encapsulation.\n    -   **Scalability**: It naturally supports the potential future extension of creating multiple device instances (multiple minor numbers) under the same dynamically allocated major number.\n-   **Consequences**:\n    -   The `/dev` node's name will be tied to a major number that changes each time the module is loaded (unless manually specified via module parameters, which is out of scope). This requires using `class_create` and `device_create` to automatically create the node with the correct, dynamically assigned number.\n    -   The assigned major number must be communicated to userspace (via `printk` or `/proc/devices`) so the user knows which `/dev` node was created.\n\n**Comparison of Allocation Methods**\n\n| Option | Pros | Cons | Chosen? |\n| :--- | :--- | :--- | :--- |\n| **Static (`register_chrdev`)** | Simple API, predictable major number. | High risk of conflict with other drivers, less flexible, older API. | ❌ |\n| **Dynamic (`alloc_chrdev_region`)** | Guarantees a free major number, avoids conflicts, modern and flexible API. | Major number changes per load, requires sysfs (`class_create`) for automatic `/dev` node creation. | ✅ |\n\n### Common Pitfalls: Module Lifecycle\n\n1.  ⚠️ **Pitfall: Forgetting `MODULE_LICENSE(\"GPL\")`**\n    -   **Description**: Omitting or incorrectly specifying the module license macro.\n    -   **Why it's wrong**: The kernel will be marked as \"tainted,\" which restricts the module's access to certain kernel symbols and may trigger warnings in the logs. Support from the kernel community may also be withheld for tainted kernels. For our learning module, using `\"GPL\"` is standard and expected.\n    -   **How to fix**: Always include `MODULE_LICENSE(\"GPL\");` near the top of your `.c` file, alongside `MODULE_AUTHOR` and `MODULE_DESCRIPTION`.\n\n2.  ⚠️ **Pitfall: Resource Leak on Initialization Failure**\n    -   **Description**: The `mydevice_init` function fails partway through (e.g., `kmalloc` returns `NULL`) but does not properly roll back resources already allocated (e.g., a successfully allocated device number).\n    -   **Why it's wrong**: This leaves kernel resources permanently allocated until the system reboots. Repeated failed loads will exhaust these resources.\n    -   **How to fix**: Implement a **stepwise cleanup** on any error path. Use `goto` statements to a common error handling label that performs cleanup in reverse order of acquisition. This pattern is standard and idiomatic in kernel code.\n\n3.  ⚠️ **Pritfall: Kernel Version Mismatch**\n    -   **Description**: Compiling the module against kernel headers that do not match the version of the currently running kernel.\n    -   **Why it's wrong**: Kernel APIs change between versions. A module compiled for one version may use functions or data structures that don't exist or behave differently in another, leading to immediate crashes or subtle bugs.\n    -   **How to fix**: Always build your module on the same system where it will run. The `Makefile` should use `$(shell uname -r)` to automatically target the running kernel's headers (typically in `/lib/modules/$(shell uname -r)/build`).\n\n4.  ⚠️ **Pitfall: Incorrect `printk` Usage**\n    -   **Description**: Using `printk` like `printf`, forgetting the log level macro (e.g., `KERN_INFO`), or expecting automatic newlines.\n    -   **Why it's wrong**: Messages without a log level default to `KERN_DEFAULT`, which might not appear in `dmesg` depending on the console log level. Also, `printk` does not automatically append a newline; you must include `\\n` in the format string.\n    -   **How to fix**: Always prefix your format string with a log level macro, and end with `\\n`. For example: `printk(KERN_INFO \"mymodule: Initialized successfully.\\n\");`.\n\n5.  ⚠️ **Pitfall: Ignoring Return Values of Initialization Functions**\n    -   **Description**: Not checking the return value of functions like `alloc_chrdev_region`, `cdev_add`, or `device_create`.\n    -   **Why it's wrong**: These functions can fail (e.g., out of memory, device number exhaustion). Ignoring the error leaves the module in an inconsistent state, often leading to a crash later.\n    -   **How to fix**: Check every return value that indicates an error (typically a negative integer or a `NULL` pointer). Propagate the error back to the caller of `module_init` (by returning the error code) to cause module loading to fail cleanly.\n\n### Implementation Guidance\n\nThis section provides the foundational code and structure to achieve Milestone 1: a loadable \"Hello World\" module that sets up the skeleton for the character device driver.\n\n**A. Technology Recommendations Table**\n\n| Component | Simple Option (Recommended for Learning) | Advanced Option |\n| :--- | :--- | :--- |\n| **Build System** | Standard `Kbuild` `Makefile` | Out-of-tree kernel module build system (kbuild) with `dkms` for distribution |\n| **Kernel APIs** | Classic `file_operations`, `proc_ops` | Newer `file_operations` without `.owner`, `seq_file` for `/proc` |\n| **Memory Allocation** | `kmalloc`/`kfree` with `GFP_KERNEL` | `devm_kmalloc` for managed resources (more complex setup) |\n\n**B. Recommended File/Module Structure**\n\nCreate the following directory and file structure. This keeps the project organized from the start.\n\n```\nmydevice_driver/\n├── Makefile                    # Kbuild Makefile to compile the module\n├── mydevice.c                  # Main driver source file (all components start here)\n└── README.md                   # Project notes (optional)\n```\n\n**C. Infrastructure Starter Code**\n\nThe following is a complete, compilable kernel module for Milestone 1. It includes the core lifecycle functions, error handling, and logging. Copy this into `mydevice.c`.\n\n```c\n// SPDX-License-Identifier: GPL-2.0\n/*\n * mydevice.c - A simple loadable kernel module (LKM) skeleton for a character device.\n *\n * This module demonstrates the basic lifecycle: init and exit.\n * It will be extended in later milestones to implement a full character device.\n */\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>       // For printk, KERN_INFO\n#include <linux/fs.h>           // For alloc_chrdev_region, register_chrdev\n#include <linux/slab.h>         // For kmalloc, kfree\n#include <linux/device.h>       // For class_create, device_create\n#include <linux/cdev.h>         // For cdev_init, cdev_add\n\n/* Define our internal device data structure (simplified for Milestone 1) */\nstruct mydevice_data {\n    // These fields will be used in later milestones\n    // void *buffer;\n    // size_t size;\n    // struct mutex mutex;\n    // wait_queue_head_t read_wait;\n\n    // Device identification and kernel structures (introduced now)\n    dev_t dev_num;              // Major and minor device number\n    struct cdev cdev;           // The kernel's character device structure\n    struct class *dev_class;    // Sysfs class for udev/auto device node creation\n    struct device *device;      // The actual device instance in sysfs\n};\n\nstatic struct mydevice_data *mydevice_dev;\n\n/* Module metadata */\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name Here\");\nMODULE_DESCRIPTION(\"A simple character device driver for learning\");\nMODULE_VERSION(\"0.1\");\n\n/* Forward declarations for file operations (to be implemented in Milestone 2) */\n/*\nstatic int mydevice_open(struct inode *inode, struct file *filp);\nstatic int mydevice_release(struct inode *inode, struct file *filp);\nstatic ssize_t mydevice_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos);\nstatic ssize_t mydevice_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos);\n*/\n\n/* The file_operations structure will be populated in Milestone 2 */\nstatic struct file_operations mydevice_fops = {\n    .owner = THIS_MODULE,\n    // .open = mydevice_open,\n    // .release = mydevice_release,\n    // .read = mydevice_read,\n    // .write = mydevice_write,\n};\n\n/**\n * mydevice_init - Module initialization function.\n * Called when the module is loaded with 'insmod'.\n *\n * Returns 0 on success, a negative error code on failure.\n */\nstatic int __init mydevice_init(void)\n{\n    int retval = 0;\n\n    printk(KERN_INFO \"mydevice: Initialization started.\\n\");\n\n    /* 1. Allocate memory for our device instance data */\n    mydevice_dev = kmalloc(sizeof(struct mydevice_data), GFP_KERNEL);\n    if (!mydevice_dev) {\n        printk(KERN_ERR \"mydevice: Failed to allocate device data.\\n\");\n        retval = -ENOMEM;\n        goto err_no_mem;\n    }\n    memset(mydevice_dev, 0, sizeof(struct mydevice_data));\n\n    /* 2. Dynamically allocate a major device number and a range of minors */\n    retval = alloc_chrdev_region(&mydevice_dev->dev_num, 0, 1, DEVICE_NAME);\n    if (retval < 0) {\n        printk(KERN_ERR \"mydevice: Failed to allocate device number. Error %d\\n\", retval);\n        goto err_alloc_region;\n    }\n    printk(KERN_INFO \"mydevice: Allocated device major %d, minor %d.\\n\",\n           MAJOR(mydevice_dev->dev_num), MINOR(mydevice_dev->dev_num));\n\n    /* 3. Create a device class in sysfs. This allows udev to create /dev node automatically. */\n    mydevice_dev->dev_class = class_create(THIS_MODULE, DEVICE_NAME \"_class\");\n    if (IS_ERR(mydevice_dev->dev_class)) {\n        retval = PTR_ERR(mydevice_dev->dev_class);\n        printk(KERN_ERR \"mydevice: Failed to create device class. Error %d\\n\", retval);\n        goto err_class_create;\n    }\n\n    /* 4. Initialize the cdev structure and link it to our file_operations. */\n    cdev_init(&mydevice_dev->cdev, &mydevice_fops);\n    mydevice_dev->cdev.owner = THIS_MODULE;\n\n    /* 5. Add the character device to the kernel, making it live. */\n    retval = cdev_add(&mydevice_dev->cdev, mydevice_dev->dev_num, 1);\n    if (retval < 0) {\n        printk(KERN_ERR \"mydevice: Failed to add cdev to the system. Error %d\\n\", retval);\n        goto err_cdev_add;\n    }\n\n    /* 6. Create the device node in /dev automatically.\n     *    The node will appear as /dev/mychardev.\n     */\n    mydevice_dev->device = device_create(mydevice_dev->dev_class, NULL, mydevice_dev->dev_num, NULL, DEVICE_NAME);\n    if (IS_ERR(mydevice_dev->device)) {\n        retval = PTR_ERR(mydevice_dev->device);\n        printk(KERN_ERR \"mydevice: Failed to create the device node. Error %d\\n\", retval);\n        goto err_device_create;\n    }\n\n    printk(KERN_INFO \"mydevice: Module loaded successfully. Device node is /dev/%s.\\n\", DEVICE_NAME);\n    return 0; // Success\n\n/* Error handling: Clean up in reverse order of allocation */\nerr_device_create:\n    cdev_del(&mydevice_dev->cdev);\nerr_cdev_add:\n    class_destroy(mydevice_dev->dev_class);\nerr_class_create:\n    unregister_chrdev_region(mydevice_dev->dev_num, 1);\nerr_alloc_region:\n    kfree(mydevice_dev);\n    mydevice_dev = NULL;\nerr_no_mem:\n    printk(KERN_ERR \"mydevice: Module initialization failed.\\n\");\n    return retval;\n}\n\n/**\n * mydevice_exit - Module cleanup function.\n * Called when the module is unloaded with 'rmmod'.\n */\nstatic void __exit mydevice_exit(void)\n{\n    printk(KERN_INFO \"mydevice: Starting cleanup.\\n\");\n\n    /* 1. Destroy the device node (removes /dev/mychardev) */\n    if (mydevice_dev && mydevice_dev->device) {\n        device_destroy(mydevice_dev->dev_class, mydevice_dev->dev_num);\n    }\n\n    /* 2. Remove the cdev from the system */\n    if (mydevice_dev) {\n        cdev_del(&mydevice_dev->cdev);\n    }\n\n    /* 3. Destroy the device class */\n    if (mydevice_dev && mydevice_dev->dev_class) {\n        class_destroy(mydevice_dev->dev_class);\n    }\n\n    /* 4. Release the device number region */\n    if (mydevice_dev) {\n        unregister_chrdev_region(mydevice_dev->dev_num, 1);\n    }\n\n    /* 5. Free the device instance memory */\n    kfree(mydevice_dev);\n    mydevice_dev = NULL;\n\n    printk(KERN_INFO \"mydevice: Module unloaded successfully.\\n\");\n}\n\n/* Register the init and exit functions with the kernel */\nmodule_init(mydevice_init);\nmodule_exit(mydevice_exit);\n```\n\n**D. Core Logic Skeleton Code**\n\nThe main logic for Milestone 1 is fully provided above. The following `Makefile` is required to build the module. Place it in the same directory as `mydevice.c`.\n\n```makefile\n# Kbuild Makefile for the mydevice kernel module\nobj-m += mydevice.o\n\n# Define the device name (used in the C code)\nEXTRA_CFLAGS += -DDEVICE_NAME=\\\"mychardev\\\"\n\n# Path to the kernel build directory (adjust if needed)\nKDIR ?= /lib/modules/$(shell uname -r)/build\n\n# Default target: build the module\nall:\n\t$(MAKE) -C $(KDIR) M=$(PWD) modules\n\n# Clean target: remove generated files\nclean:\n\t$(MAKE) -C $(KDIR) M=$(PWD) clean\n\n# Installation target (optional, for later use)\ninstall:\n\tsudo insmod mydevice.ko\n\n# Removal target (optional, for later use)\nuninstall:\n\tsudo rmmod mydevice\n```\n\n**E. Language-Specific Hints (C / Kernel)**\n\n-   **Kernel Logging**: Always use `printk` for logging inside the kernel. Remember the log level macros (`KERN_INFO`, `KERN_ERR`). You can view the output with `sudo dmesg` or `journalctl -k`.\n-   **Error Codes**: Kernel functions return negative error codes (e.g., `-ENOMEM` for out of memory). Your functions should do the same. `0` typically indicates success.\n-   **Memory Allocation**: Use `kmalloc(size, GFP_KERNEL)` for normal, sleepable allocations. Always check for `NULL` return. Use `kfree()` to free.\n-   **Goto for Error Handling**: The `goto` statement is standard and preferred for centralized error cleanup in the kernel. It leads to cleaner code than nested `if` statements.\n\n**F. Milestone Checkpoint: Verification Steps for Milestone 1**\n\nAfter writing the code above and saving it as `mydevice.c` with the accompanying `Makefile`, follow these steps to verify correct implementation:\n\n1.  **Compile the module**:\n    ```bash\n    make\n    ```\n    Expected: The build should complete without errors, producing a `mydevice.ko` file.\n\n2.  **Check module information**:\n    ```bash\n    modinfo mydevice.ko\n    ```\n    Expected: Output should show the license (\"GPL\"), author, description, and version you set with the `MODULE_*` macros.\n\n3.  **Load the module**:\n    ```bash\n    sudo insmod mydevice.ko\n    ```\n    Expected: The command should return silently (no error). If there is an error (e.g., \"insmod: ERROR: could not insert module\"), check the next step.\n\n4.  **Verify loading in kernel log**:\n    ```bash\n    sudo dmesg | tail -10\n    ```\n    Expected: You should see messages similar to:\n    ```\n    [ 1234.567890] mydevice: Initialization started.\n    [ 1234.567891] mydevice: Allocated device major 246, minor 0.\n    [ 1234.567892] mydevice: Module loaded successfully. Device node is /dev/mychardev.\n    ```\n    Note the allocated major number (e.g., 246).\n\n5.  **Check if device node was created**:\n    ```bash\n    ls -l /dev/mychardev\n    ```\n    Expected: The file `/dev/mychardev` should exist. Its permissions might be `crw-------` and the major number should match the one printed in `dmesg`.\n\n6.  **Check kernel modules list**:\n    ```bash\n    lsmod | grep mydevice\n    ```\n    Expected: The `mydevice` module should be listed.\n\n7.  **Unload the module**:\n    ```bash\n    sudo rmmod mydevice\n    ```\n    Expected: The command should return silently.\n\n8.  **Verify cleanup in kernel log**:\n    ```bash\n    sudo dmesg | tail -5\n    ```\n    Expected: You should see:\n    ```\n    [ 1234.678901] mydevice: Starting cleanup.\n    [ 1234.678902] mydevice: Module unloaded successfully.\n    ```\n\n9.  **Confirm device node is removed**:\n    ```bash\n    ls -l /dev/mychardev 2>&1\n    ```\n    Expected: The command should report \"No such file or directory\".\n\nIf all steps pass, you have successfully completed Milestone 1. The driver skeleton is ready to have its character device operations implemented in the next milestone.\n\n---\n\n\n## Component: Character Device Core\n\n> **Milestone(s):** Milestone 2\n\nThis component implements the core functionality that transforms our kernel module into an accessible device. It handles the direct interaction between user-space applications and the kernel module through the `/dev` interface, enabling programs to read from and write to our device as if it were a file.\n\n### Mental Model: The Device as a Shared Notebook\n\nImagine a public library with a single, large notebook at the reference desk. This notebook represents our device's buffer. Library patrons (user-space processes) can approach the desk to perform two main actions:\n\n1. **Write a message:** A patron can write text into the notebook. The librarian (the kernel) ensures they write neatly within the notebook's boundaries and don't overwrite other messages without permission. They hand their written note to the librarian, who carefully copies it into the next available space in the notebook.\n2. **Read a message:** A patron can ask to read what's in the notebook. If the notebook is empty, the librarian asks the patron to wait in a designated waiting area (a wait queue) until another patron writes something. Once data is available, the librarian copies text from the notebook and hands the copy to the reading patron.\n\nThe librarian enforces strict rules:\n- **Only one patron at the desk:** The librarian uses a \"Now Serving\" ticket (a mutex) to ensure only one patron is interacting with the notebook at any time, preventing jumbled or corrupted messages.\n- **No original notes leave the library:** Patrons never handle the original notebook. The librarian only works with copies (`copy_from_user`, `copy_to_user`). This protects the kernel's internal data.\n- **The notebook has finite pages:** The notebook has a maximum capacity. If it's full, writing patrons must wait until space is freed by reading patrons.\n\nThis mental model captures the essence of a character device: a shared, sequential data store with controlled access, managed by the kernel acting as a gatekeeper between untrusted user-space and protected kernel-space.\n\n### ADR: Simple Linear Buffer vs. Circular Buffer\n\n> **Decision: Use a Simple Linear Buffer for Initial Implementation**\n> - **Context**: We need a storage mechanism within the kernel to hold data written from user-space and serve it back to readers. The buffer must support sequential access, concurrent modification, and have clear full/empty states.\n> - **Options Considered**:\n>   1. **Simple linear buffer**: A contiguous block of kernel memory (`kmalloc`) with a fixed capacity. Data is written starting at offset 0 and read from offset 0. Once data is read, the buffer is effectively \"consumed\" and must be cleared or overwritten from the beginning.\n>   2. **Circular buffer (ring buffer)**: A fixed-size buffer where the read and write pointers wrap around. This allows continuous reading and writing without needing to clear the buffer, providing better throughput for sustained data flow.\n>   3. **Linked list of pages**: A dynamically sized buffer composed of linked kernel pages, allowing growth without contiguous memory constraints but with increased complexity.\n> - **Decision**: We will implement a simple linear buffer for Milestone 2.\n> - **Rationale**: The primary goal is educational clarity, not maximum performance. A linear buffer has simpler state management (just `data_start`, `data_end` or `data_size`), making it easier to reason about concurrency, blocking conditions, and buffer state transitions. It directly maps to the \"shared notebook\" mental model where data is written and then consumed. Implementing a circular buffer adds complexity with wrap-around logic, modulo arithmetic, and handling the case where a read or write operation spans the buffer boundary, which can obscure the core concepts of kernel/user data transfer and synchronization.\n> - **Consequences**: \n>   - **Positive**: Simplified implementation and debugging; clear full/empty states; straightforward `read`/`write` semantics.\n>   - **Negative**: Lower throughput for continuous data streams; after a read, the buffer becomes empty and cannot hold historical data; requires explicit clearing or management of buffer position.\n>   - **Mitigation**: This decision is scoped to Milestone 2. In Milestone 3, we will add an `ioctl` command to clear the buffer, and in future extensions, the buffer strategy could be upgraded to circular.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| **Simple Linear Buffer** | Simple state logic, easy to debug, clear full/empty semantics, maps directly to learning objectives | Inefficient for continuous data, requires manual clearing, data is consumed on read | **Yes** (for Milestone 2) |\n| **Circular Buffer** | Efficient for continuous read/write, no need to clear buffer automatically, common in production drivers | More complex implementation, wrap-around logic, harder to debug for learners | No |\n| **Linked List of Pages** | Dynamic size, no contiguous memory requirement, scales well | High complexity, memory fragmentation, overhead of page management | No |\n\n### Common Pitfalls: User/Kernel Boundary\n\nCrossing the boundary between user-space and kernel-space is fraught with subtle dangers. The kernel must never blindly trust pointers or data from user-space, as they could be malicious, invalid, or point to unmapped memory. Here are the critical pitfalls to avoid:\n\n⚠️ **Pitfall: Directly Dereferencing User-Space Pointers**\n- **What happens**: Using `*` operator or array indexing on a pointer passed from user-space (e.g., the `buf` argument in `mydevice_write`).\n- **Why it's wrong**: User-space pointers are virtual addresses in the user process's address space. They are meaningless in the kernel's address context. Dereferencing them will cause a page fault, crashing the kernel (a \"oops\" or kernel panic).\n- **How to fix**: Always use the dedicated kernel functions `copy_from_user` (to copy data *from* user-space *into* kernel memory) and `copy_to_user` (to copy data *from* kernel memory *to* user-space). These functions perform safe translation and handle invalid pointers gracefully by returning a non-zero error code.\n\n⚠️ **Pitfall: Not Checking Return Values of copy_to/from_user**\n- **What happens**: Calling `copy_from_user(kernel_buf, user_buf, count)` but ignoring its return value.\n- **Why it's wrong**: These functions can fail if the user pointer is invalid, points to unmapped memory, or if only part of the requested range is accessible. A failure means the copy was incomplete. Ignoring this leads to using uninitialized kernel buffer data or returning incorrect data to user-space.\n- **How to fix**: Always check if the return value is 0 (success). If not, return `-EFAULT` to user-space to indicate a bad address. For example: `if (copy_from_user(...)) { return -EFAULT; }`\n\n⚠️ **Pitfall: Incorrect Return Values from read/write Handlers**\n- **What happens**: The `mydevice_read` function returns the number of bytes the user requested (`count`) regardless of how much data is actually available.\n- **Why it's wrong**: The `read` system call contract expects the return value to be the number of bytes *actually transferred* to user-space. Returning a larger value tells the user program it received data it didn't, causing buffer overruns or reading garbage. Conversely, returning 0 indicates EOF (end-of-file), which for a character device typically means no data is available *at this moment*.\n- **How to fix**: Return the actual number of bytes copied via `copy_to_user`. If no data is available and it's a non-blocking read, return `-EAGAIN`. If it's a blocking read, put the process to sleep (see Milestone 4). Return 0 only when at the true end of the data stream (which for our simple device might only happen after a buffer clear).\n\n⚠️ **Pitfall: Forgetting to Update the File Position**\n- **What happens**: The `read`/`write` handlers ignore the `loff_t *f_pos` parameter.\n- **Why it's wrong**: The `f_pos` tracks the current position in the \"file\" for sequential access. For our simple sequential device, a `read` should consume data starting at the current position. If we don't update `*f_pos`, subsequent reads will return the same data repeatedly.\n- **How to fix**: After successfully transferring `n` bytes, increment `*f_pos += n`. For our linear buffer model, we typically read from the beginning and reset the buffer (or position) after a complete read. The exact semantics depend on your design; you might choose to treat each `read` as consuming all available data and resetting the buffer to empty, in which case `f_pos` might not be used meaningfully.\n\n⚠️ **Pitfall: Not Handling Partial Reads/Writes Due to Buffer Limits**\n- **What happens**: A user requests to write 4096 bytes, but our kernel buffer has only 1024 bytes free.\n- **Why it's wrong**: The driver should not silently truncate the data. The `write` system call expects either to transfer all requested bytes or return an error. If we only copy 1024 bytes and return 1024, the user program might think the entire write succeeded when it didn't.\n- **How to fix**: Check if the operation can be completed in full given the buffer's current state (e.g., free space for write, available data for read). If not, you have two options: 1) Return `-ENOSPC` (no space) or `-EAGAIN` for a non-blocking operation, or 2) Transfer as much as possible (partial I/O) and return that count. The Linux convention for character devices often allows partial transfers; document your driver's behavior clearly. For simplicity in Milestone 2, we can implement partial transfers: write up to the free space, read up to the available data.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations Table\n| Component | Simple Option (Milestone 2) | Advanced Option (Future) |\n|-----------|-----------------------------|--------------------------|\n| **Buffer Storage** | Linear `kmalloc` buffer with fixed capacity | Circular buffer or `vmalloc` for large sizes |\n| **Device Number** | Dynamic allocation with `alloc_chrdev_region` | Static major number (requires coordination) |\n| **/dev Node Creation** | Automatic via `class_create`/`device_create` | Manual `mknod` or udev rules |\n| **Concurrency (Milestone 4)** | Single mutex for all operations | Fine-grained locking (read/write locks) |\n\n#### B. Recommended File/Module Structure\nAfter implementing this component, your project directory should look like:\n```\nmydevice-driver/\n├── Makefile                      # Kbuild Makefile\n├── mydevice.c                    # Main driver source (Module Lifecycle + Char Device Core)\n├── mydevice.h                    # Shared header (for ioctl, coming in Milestone 3)\n└── test_user.c                   # Userspace test program (to be written)\n```\nFor now, `mydevice.c` will contain both the module lifecycle functions (from previous section) and the character device core implementation.\n\n#### C. Infrastructure Starter Code: The Device Instance Structure\nWe need a central structure to hold all state for our device. This is a singleton (one instance) for our driver. Add this to `mydevice.c`:\n\n```c\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/slab.h>           // For kmalloc/kfree\n#include <linux/uaccess.h>        // For copy_to/from_user\n\n#define DEVICE_NAME \"mychardev\"\n#define BUFFER_SIZE 1024          // Initial buffer size\n\n// Per-device instance data structure\nstruct mydevice_data {\n    dev_t dev_num;                // Major & minor number\n    struct cdev cdev;             // Character device structure\n    struct class *dev_class;      // Device class for sysfs\n    struct device *device;        // Device node\n    \n    // Buffer management (Milestone 2)\n    char *buffer;                 // Linear data buffer\n    size_t buffer_size;           // Total capacity\n    size_t data_size;             // Current amount of data stored\n    // Note: We'll add mutex and wait_queue in Milestone 4\n};\n\nstatic struct mydevice_data *mydevice_dev; // Global device instance\n```\n\n#### D. Core Logic Skeleton Code\n\n**1. File Operations Structure**\nDefine the `file_operations` structure that maps system calls to our handler functions. Place this after the structure definition:\n\n```c\nstatic const struct file_operations mydevice_fops = {\n    .owner = THIS_MODULE,\n    .open = mydevice_open,\n    .release = mydevice_release,\n    .read = mydevice_read,\n    .write = mydevice_write,\n    // .unlocked_ioctl will be added in Milestone 3\n    // .poll will be added in Milestone 4\n};\n```\n\n**2. Open and Release Handlers**\nImplement the simple open and release methods. The `open` handler is called when a user-space process opens `/dev/mychardev`. The `release` handler is called when the last reference to the file is closed.\n\n```c\nstatic int mydevice_open(struct inode *inode, struct file *filp)\n{\n    // TODO 1: Get pointer to our device data from inode->i_cdev\n    // Hint: Use container_of(inode->i_cdev, struct mydevice_data, cdev)\n    \n    // TODO 2: Store the device data pointer in filp->private_data for access in other handlers\n    \n    // TODO 3: Optional: Increment module usage count with try_module_get(THIS_MODULE)\n    \n    printk(KERN_INFO DEVICE_NAME \": Device opened\\n\");\n    return 0; // Success\n}\n\nstatic int mydevice_release(struct inode *inode, struct file *filp)\n{\n    // TODO 1: Optional: Decrement module usage count with module_put(THIS_MODULE)\n    \n    printk(KERN_INFO DEVICE_NAME \": Device closed\\n\");\n    return 0;\n}\n```\n\n**3. Write Handler**\nImplement the write handler to copy data from user-space into our kernel buffer.\n\n```c\nstatic ssize_t mydevice_write(struct file *filp, const char __user *buf,\n                              size_t count, loff_t *f_pos)\n{\n    struct mydevice_data *dev = filp->private_data;\n    size_t free_space;\n    size_t to_copy;\n    \n    // TODO 1: Calculate free space in buffer: free_space = dev->buffer_size - dev->data_size\n    \n    // TODO 2: Determine how many bytes we can copy: to_copy = min(count, free_space)\n    // Hint: Use min_t(size_t, count, free_space) for type-safe min\n    \n    // TODO 3: If to_copy is 0, return -ENOSPC (No space left) or 0 (partial write convention)\n    \n    // TODO 4: Copy data from user-space to end of our buffer\n    // copy_from_user(dev->buffer + dev->data_size, buf, to_copy)\n    \n    // TODO 5: Check copy_from_user return value. If non-zero, return -EFAULT\n    \n    // TODO 6: Update dev->data_size to reflect new data\n    \n    // TODO 7: Update *f_pos (optional, depending on your semantics)\n    \n    // TODO 8: Return number of bytes actually written (to_copy)\n    \n    printk(KERN_INFO DEVICE_NAME \": Wrote %zu bytes\\n\", to_copy);\n    return to_copy;\n}\n```\n\n**4. Read Handler**\nImplement the read handler to copy data from our kernel buffer to user-space.\n\n```c\nstatic ssize_t mydevice_read(struct file *filp, char __user *buf,\n                             size_t count, loff_t *f_pos)\n{\n    struct mydevice_data *dev = filp->private_data;\n    size_t available;\n    size_t to_copy;\n    \n    // TODO 1: Calculate available data: available = dev->data_size\n    \n    // TODO 2: Determine how many bytes we can copy: to_copy = min(count, available)\n    \n    // TODO 3: If to_copy is 0, return 0 (EOF/no data) - we'll make this blocking in Milestone 4\n    \n    // TODO 4: Copy data from beginning of buffer to user-space\n    // copy_to_user(buf, dev->buffer, to_copy)\n    \n    // TODO 5: Check copy_to_user return value. If non-zero, return -EFAULT\n    \n    // TODO 6: Remove copied data from buffer by shifting remaining data forward\n    // memmove(dev->buffer, dev->buffer + to_copy, dev->data_size - to_copy)\n    \n    // TODO 7: Update dev->data_size to reflect removed data\n    \n    // TODO 8: Update *f_pos (optional)\n    \n    // TODO 9: Return number of bytes actually read (to_copy)\n    \n    printk(KERN_INFO DEVICE_NAME \": Read %zu bytes\\n\", to_copy);\n    return to_copy;\n}\n```\n\n**5. Buffer Management Helpers**\nAdd helper functions to initialize and clean up the buffer:\n\n```c\nstatic int buffer_init(struct mydevice_data *dev, size_t initial_size)\n{\n    // TODO 1: Allocate buffer memory with kmalloc\n    // dev->buffer = kmalloc(initial_size, GFP_KERNEL);\n    \n    // TODO 2: Check if allocation succeeded (NULL means failure)\n    \n    // TODO 3: Initialize buffer_size and data_size\n    \n    // TODO 4: Optional: Zero the buffer with memset\n    \n    return 0;\n}\n\nstatic void buffer_cleanup(struct mydevice_data *dev)\n{\n    // TODO 1: Free buffer memory with kfree\n    \n    // TODO 2: Set buffer pointer to NULL and sizes to 0\n}\n```\n\n**6. Enhanced Module Initialization**\nUpdate your `mydevice_init` function (from the previous section) to set up the character device:\n\n```c\nstatic int __init mydevice_init(void)\n{\n    int ret;\n    \n    // TODO 1: Allocate device instance structure with kzalloc\n    \n    // TODO 2: Initialize buffer with buffer_init(dev, BUFFER_SIZE)\n    \n    // TODO 3: Allocate device numbers with alloc_chrdev_region\n    \n    // TODO 4: Initialize cdev structure with cdev_init(&dev->cdev, &mydevice_fops)\n    \n    // TODO 5: Add cdev to system with cdev_add\n    \n    // TODO 6: Create device class with class_create\n    \n    // TODO 7: Create device node with device_create\n    \n    // TODO 8: Store dev in global pointer\n    \n    printk(KERN_INFO DEVICE_NAME \": Module loaded with major number %d\\n\",\n           MAJOR(dev->dev_num));\n    return 0;\n    \nerror:\n    // TODO 9: Clean up any resources allocated in reverse order on failure\n    return ret;\n}\n```\n\nUpdate `mydevice_exit` to clean up the character device:\n\n```c\nstatic void __exit mydevice_exit(void)\n{\n    // TODO 1: If device exists, remove device node with device_destroy\n    \n    // TODO 2: Destroy class with class_destroy\n    \n    // TODO 3: Remove cdev with cdev_del\n    \n    // TODO 4: Unregister device numbers with unregister_chrdev_region\n    \n    // TODO 5: Clean up buffer with buffer_cleanup\n    \n    // TODO 6: Free device instance structure with kfree\n    \n    printk(KERN_INFO DEVICE_NAME \": Module unloaded\\n\");\n}\n```\n\n#### E. Language-Specific Hints\n\n- **Error Codes**: In kernel space, errors are returned as negative integers. Common ones: `-ENOMEM` (out of memory), `-EFAULT` (bad address), `-ENOSPC` (no space), `-EINVAL` (invalid argument). Include `<linux/errno.h>`.\n- **Pointer Annotations**: Use `__user` to annotate user-space pointers in function signatures. This documents the pointer's origin and triggers sparse (a Linux kernel code checker) warnings if misused.\n- **Size Types**: Use `size_t` for buffer sizes and byte counts, `ssize_t` for signed sizes (return values that can be negative for errors).\n- **printk Format Specifiers**: For `size_t`, use `%zu`; for `loff_t` (file position), use `%lld` with explicit casting to `long long`.\n\n#### F. Milestone Checkpoint\n\nAfter implementing the character device core:\n\n1. **Build and Load**:\n   ```bash\n   make\n   sudo insmod mydevice.ko\n   dmesg | tail\n   ```\n   Expected output should show the module loaded with a major number and device created.\n\n2. **Verify Device Node**:\n   ```bash\n   ls -l /dev/mychardev\n   ```\n   Should show a character device file with the dynamically assigned major number.\n\n3. **Test Basic Write/Read**:\n   ```bash\n   echo \"Hello, kernel!\" | sudo tee /dev/mychardev\n   sudo cat /dev/mychardev\n   ```\n   Expected: \"Hello, kernel!\" printed to terminal. Check `dmesg` for \"Wrote X bytes\" and \"Read X bytes\" messages.\n\n4. **Test Partial Writes**:\n   ```bash\n   # Write more data than buffer can hold (if buffer is 1024 bytes)\n   dd if=/dev/urandom bs=2048 count=1 | sudo tee /dev/mychardev >/dev/null\n   dmesg | tail\n   ```\n   Should show a write of at most 1024 bytes (or your `BUFFER_SIZE`).\n\n**Signs of Trouble**:\n- `insmod` fails: Check `dmesg` for error messages. Common issues: missing symbols (forgot to implement a required function), permission issues.\n- `/dev/mychardev` not created: Verify `device_create` succeeded. Check if the `dev` class appears in `/sys/class/`.\n- Write succeeds but read returns nothing: Check your buffer management logic. Ensure `data_size` is updated correctly and `memmove` works properly.\n- Permission denied when accessing `/dev/mychardev`: The device node gets default permissions. Use `sudo` or fix permissions with `sudo chmod 666 /dev/mychardev`.\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Kernel panic/oops when writing to device | Direct dereference of user-space pointer | Look at oops message in `dmesg` - it will show the faulting instruction | Use `copy_from_user` instead of direct access |\n| `write()` returns success but no data appears in buffer | `copy_from_user` failure not checked | Add `printk` before and after `copy_from_user`, check return value | Handle `copy_from_user` errors, return `-EFAULT` |\n| `read()` returns 0 immediately even after writing data | `data_size` not updated or buffer logic error | Add `printk` to show `data_size` in read/write handlers | Ensure `data_size` is incremented on write and decremented on read |\n| Device node not created in `/dev` | `device_create` failed or class not created | Check return value of `class_create` and `device_create`, check `dmesg` | Ensure proper error handling in init function |\n| Multiple opens corrupt data | No concurrency protection (Milestone 4 issue) | Not applicable yet, but will be fixed in Milestone 4 with mutex | Implement mutex locking in all buffer access paths |\n\nRemember: The character device core establishes the fundamental data path. Get this working correctly before adding the more advanced features in subsequent milestones.\n\n\n## Component: Control Interface (ioctl and proc)\n\n> **Milestone(s):** Milestone 3\n\nThis component extends the character device driver beyond simple read and write operations, providing a dedicated control plane for configuration, monitoring, and management. While the device file `/dev/mychardev` serves as the **data plane** for byte stream I/O, the `ioctl` interface and the `/proc` filesystem entry form the **control plane**, allowing userspace programs to query device state, modify parameters, and perform administrative actions. The core architectural challenge is designing a safe, well-defined protocol that crosses the kernel-user boundary without introducing security vulnerabilities or system instability, while providing intuitive access to internal driver state.\n\n### Mental Model: The Driver's Control Panel and Dashboard\n\nImagine the device driver as a complex piece of industrial machinery in a factory. The `/dev/mychardev` file is the **conveyor belt** where raw materials (data bytes) are placed and retrieved. The `ioctl` interface, then, is the **control panel** attached to this machinery—a series of labeled buttons, dials, and switches that allow an operator to change the machine's operating mode, adjust its speed, or clear a jam. Each button (`ioctl` command) performs a specific, privileged action that you wouldn't (or couldn't) do by just putting items on the conveyor belt.\n\nThe `/proc/mychardev_stats` entry, in this analogy, is the **real-time dashboard** mounted on the factory wall. It doesn't accept commands; instead, it displays continuously updated metrics: how many items have passed through the conveyor belt today, the current capacity of the buffer, whether the safety lock (mutex) is engaged, and how many operators are waiting for items to arrive. Anyone can glance at this dashboard to understand the machinery's health and performance without interrupting its operation.\n\nThis separation of concerns is critical in kernel design. The `ioctl` interface uses the **command-argument** paradigm: a numeric command (`MYDEVICE_IOCTL_CLEAR`) is sent, optionally with a parameter (like a new buffer size), and the kernel executes the associated handler. The `/proc` interface uses the **file-as-information** paradigm: reading the virtual file triggers a callback that generates a textual report of current state. Both are mediated by the Virtual File System (VFS), but they serve distinct purposes: control versus observation.\n\n### ADR: Raw procfs vs. seq_file Interface\n\n> **Decision: Use `proc_ops` with `single_open` for the /proc interface**\n\n- **Context**: We need to expose device statistics and configuration information via the `/proc` filesystem. The traditional `/proc` interface in the Linux kernel has evolved, with the older `file_operations`-based model being deprecated in favor of the `seq_file` interface for multi-page output and the newer `proc_ops` structure. We must choose an implementation that is educationally accessible while being functionally correct and forward-compatible.\n\n- **Options Considered**:\n  1. **Raw `proc_create` with `file_operations` (Deprecated)**: The classic method using a custom `read` function that manages offsets and partial reads manually.\n  2. **`seq_file` Interface**: The recommended, more complex interface that handles iteration, page-sized output, and formatting automatically.\n  3. **`proc_ops` with `single_open`**: A simplified wrapper around `seq_file` that uses the `single_open` helper for cases where the entire output fits in a single kernel buffer (typically one page, 4KB).\n\n- **Decision**: We will implement the `/proc` entry using the `proc_ops` structure with the `single_open` helper function and a custom `mydevice_proc_show` callback. This method provides a balance between simplicity for learners and adherence to modern kernel APIs.\n\n- **Rationale**:\n  - **Educational Clarity**: The `single_open` method requires implementing only one show function (`mydevice_proc_show`) that prints all information at once, avoiding the complexity of the `seq_file` iterator (`start`, `next`, `stop`, `show`). This allows learners to focus on the data being presented rather than the mechanics of multi-page output.\n  - **Modern API**: Using `proc_ops` is the current non-deprecated method (since kernel 5.6+), avoiding warnings and ensuring compatibility. The `single_open` helper is a standard, well-documented pattern.\n  - **Adequate Capacity**: Our device statistics (buffer size, data size, lock status) will easily fit within a single page (4KB). The `seq_file` interface's primary advantage—handling large, multi-page outputs—is not needed for this project's scope.\n\n- **Consequences**:\n  - **Positive**: Simplified code with fewer callbacks to implement and debug. The `single_open` method automatically handles `lseek` correctly and manages the single buffer.\n  - **Negative**: If the output were to grow beyond one page (very unlikely for our use case), the read would be truncated. For future expansion into more detailed statistics, we might need to migrate to the full `seq_file` interface.\n  - **Maintenance**: The code will be compatible with current and future kernels while avoiding deprecation warnings.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Raw `file_operations` | Direct control over read/offset logic, traditional learning example | Deprecated API, error-prone manual offset management, not forward-compatible | No |\n| Full `seq_file` Interface | Handles multi-page output elegantly, standard for complex /proc files | Steeper learning curve, requires four callbacks to implement | No |\n| `proc_ops` with `single_open` | Modern API, simple single-callback implementation, automatic offset handling | Output limited to single page, less flexible for future expansion | **Yes** |\n\n### Common Pitfalls: ioctl and procfs\n\nImplementing control interfaces is deceptively tricky. The following pitfalls are common for developers new to kernel programming and can lead to subtle bugs, security issues, or system crashes.\n\n⚠️ **Pitfall 1: Incorrect ioctl Command Numbering**\n- **Description**: Defining `ioctl` command numbers arbitrarily (e.g., `#define MY_CLEAR 1`) without using the standard `_IO`, `_IOR`, `_IOW`, `_IOWR` macros, or choosing a magic number that conflicts with other drivers.\n- **Why it's wrong**: The kernel uses the command number to verify the direction (read/write) and size of the data argument. Arbitrary numbers can collide with other drivers' commands, leading to unintended behavior. The macros encode a unique 8-bit \"magic number,\" a sequential command number, the data size, and the direction bits.\n- **Fix**: Always use the macros with a unique magic character (e.g., `'k'`), and define commands in a shared header. Example: `#define MYDEVICE_IOCTL_CLEAR _IO('k', 3)`.\n\n⚠️ **Pitfall 2: Missing Size Argument in _IOR/_IOW Macros**\n- **Description**: Forgetting to include the size of the data type as the third argument to `_IOR(type, nr, size)` or `_IOW(type, nr, size)`.\n- **Why it's wrong**: The kernel uses this size to perform automatic validation on 32-bit/64-bit compatibility (using the `_IOC_SIZE` macro). If omitted, the kernel cannot verify that the userspace argument is the correct size, potentially causing memory corruption or information leaks.\n- **Fix**: Always pass the `sizeof()` the data type being transferred. Example: `_IOR(MYDEVICE_IOC_MAGIC, 1, size_t)` for a command that returns a `size_t`.\n\n⚠️ **Pitfall 3: Dereferencing User Pointer Directly in ioctl**\n- **Description**: Treating the `arg` parameter in `mydevice_ioctl` as a kernel pointer and directly reading or writing through it (e.g., `*(int *)arg = value;`).\n- **Why it's wrong**: The `arg` pointer is a **userspace address**. Direct dereferencing will cause a kernel oops (page fault) because kernel code cannot access user memory directly. All data transfer must go through `copy_to_user` or `copy_from_user`.\n- **Fix**: For input arguments, use `copy_from_user(&kernel_var, (void __user *)arg, sizeof(kernel_var))`. For output, use `copy_to_user((void __user *)arg, &kernel_var, sizeof(kernel_var))`.\n\n⚠️ **Pitfall 4: Mishandling Partial Reads in /proc Callbacks (Raw Method)**\n- **Description**: When using the deprecated raw `proc_read` function, not correctly updating the file position offset (`*off`) and returning the correct number of bytes copied, leading to infinite loops or truncated output when `cat`-ing the file.\n- **Why it's wrong**: The VFS may call the read callback multiple times for a single `read()` system call, each time with an increased buffer offset. If the function always returns the full data from the start, the output will be repeated. If it doesn't update `*off` correctly, the read may never finish.\n- **Fix**: This is precisely why we avoid the raw method. With `single_open`, the `seq_file` layer handles all offset and partial read logic automatically. Our `mydevice_proc_show` function simply prints everything once.\n\n⚠️ **Pitfall 5: Not Checking copy_to/from_user Return Values in ioctl**\n- **Description**: Ignoring the return value of `copy_to_user` or `copy_from_user` (which indicates number of bytes NOT copied) and assuming the copy succeeded.\n- **Why it's wrong**: These functions can fail if the userspace pointer is invalid (e.g., NULL, points to unmapped memory, or is in a protected region). Failure should be propagated to userspace as an error (`-EFAULT`).\n- **Fix**: Always check: `if (copy_to_user(...)) { return -EFAULT; }`.\n\n⚠️ **Pitfall 6: Forgetting to Acquire the Mutex in ioctl Handlers**\n- **Description**: Performing operations on the shared device buffer (like resizing or clearing) in the `ioctl` handler without first acquiring the device's mutex, while concurrent `read`/`write` operations may also be accessing the buffer.\n- **Why it's wrong**: This creates a race condition. For example, a `buffer_resize` could reallocate the buffer while a `read` is copying data out, leading to use-after-free, corruption, or crashes.\n- **Fix**: Protect all `ioctl` commands that touch shared state with `mutex_lock(&dev->lock)` and `mutex_unlock(&dev->lock)`. Consider the lock ordering if multiple locks are involved (though we only have one).\n\n### Implementation Guidance\n\nThis subsection provides concrete code skeletons and organizational advice to implement the control interface. The primary language is C, targeting the Linux kernel API.\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option (Recommended) | Advanced Option |\n|-----------|----------------------------|-----------------|\n| **Ioctl Interface** | `unlocked_ioctl` with `_IO*` macros and a shared header | `compat_ioctl` for 32-bit userspace on 64-bit kernels |\n| **Proc Filesystem** | `proc_ops` with `single_open`/`single_release` | Full `seq_file` interface with iterator callbacks |\n| **Command Definitions** | Central header file included by both kernel and userspace | Dynamically assigned ioctl numbers via kernel registration |\n\n#### B. Recommended File/Module Structure\n\nExtend the existing project structure to separate interface definitions and add the userspace test program.\n\n```\nproject-root/\n├── mychardev.c              # Main driver source (add ioctl & proc handlers here)\n├── mychardev.h              # Shared header with ioctl command definitions\n├── Makefile                 # Kbuild makefile\n├── test_ioctl.c             # Userspace test program for ioctl commands\n└── README.md\n```\n\nThe shared header `mychardev.h` is critical—it must be includable by both kernel code (under `#ifdef __KERNEL__`) and userspace C programs. This ensures command numbers and data structures are in sync.\n\n#### C. Infrastructure Starter Code: Shared Header File\n\nCreate `mychardev.h` with the following complete code. This file bridges kernel and userspace.\n\n```c\n#ifndef MYCHARDEV_H\n#define MYCHARDEV_H\n\n#include <linux/ioctl.h>  /* For _IO* macros used in kernel */\n#include <linux/types.h>  /* For size_t in kernel mode */\n\n/* \n * The 'magic' number for our ioctl commands.\n * Choose a unique character (8 bits) not used by other drivers.\n * See Documentation/ioctl/ioctl-number.rst in kernel sources.\n */\n#define MYDEVICE_IOC_MAGIC 'k'\n\n/* \n * Define the ioctl commands.\n * _IOR(type, nr, size): defines a read command (data from kernel->user)\n * _IOW(type, nr, size): defines a write command (data from user->kernel)\n * _IO(type, nr):        defines a command with no data transfer\n */\n#define MYDEVICE_IOCTL_GET_SIZE _IOR(MYDEVICE_IOC_MAGIC, 1, size_t)\n#define MYDEVICE_IOCTL_GET_MAX_CAPACITY _IOR(MYDEVICE_IOC_MAGIC, 2, size_t)\n#define MYDEVICE_IOCTL_CLEAR _IO(MYDEVICE_IOC_MAGIC, 3)\n#define MYDEVICE_IOCTL_RESIZE _IOW(MYDEVICE_IOC_MAGIC, 4, size_t)\n\n/* \n * The maximum allowed buffer size to prevent excessive memory allocation.\n * Define it here so userspace knows the limit.\n */\n#define MAX_BUFFER_SIZE (1024 * 1024) /* 1 MiB */\n\n#endif /* MYCHARDEV_H */\n```\n\n**Note for kernel compilation**: When this header is included in the kernel module, `size_t` will resolve to the kernel's `size_t` (typically `unsigned long`). In userspace, it resolves to the standard C library's `size_t`. This is acceptable as long as both are the same width (which they are on most platforms). For maximum portability, we could use `__kernel_size_t` and provide a userspace typedef, but for simplicity we assume `size_t` matches.\n\n#### D. Core Logic Skeleton Code\n\n**1. Adding ioctl Handler to `file_operations`**\n\nIn `mychardev.c`, update the `struct file_operations` to include the `unlocked_ioctl` handler (and compat_ioctl if you want 32-bit support).\n\n```c\nstatic const struct file_operations mydevice_fops = {\n    .owner = THIS_MODULE,\n    .open = mydevice_open,\n    .release = mydevice_release,\n    .read = mydevice_read,\n    .write = mydevice_write,\n    .unlocked_ioctl = mydevice_ioctl,\n    // .compat_ioctl = mydevice_ioctl, // Optional for 32-bit compatibility\n};\n```\n\n**2. Implementing `mydevice_ioctl`**\n\nAdd the handler function. Note the careful locking and user copy operations.\n\n```c\n#include \"mychardev.h\"  /* Our shared definitions */\n#include <linux/slab.h>  /* For krealloc */\n\nstatic long mydevice_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n    struct mydevice_data *dev = filp->private_data;\n    int ret = 0;\n    size_t new_size;\n    size_t __user *user_arg = (size_t __user *)arg;\n\n    /* TODO 1: Check that the ioctl command's magic number matches ours.\n     * Hint: Use _IOC_TYPE(cmd) to extract the magic number and compare.\n     * If mismatch, return -ENOTTY (not our command).\n     */\n\n    /* TODO 2: Acquire the device mutex to protect shared buffer state.\n     * Hint: mutex_lock(&dev->lock);\n     */\n\n    switch (cmd) {\n    case MYDEVICE_IOCTL_GET_SIZE:\n        /* TODO 3: Copy the current data size (dev->data_size) to userspace.\n         * Use copy_to_user(user_arg, &dev->data_size, sizeof(size_t)).\n         * If copy fails, set ret = -EFAULT.\n         */\n        break;\n\n    case MYDEVICE_IOCTL_GET_MAX_CAPACITY:\n        /* TODO 4: Copy the current buffer capacity (dev->buffer_size) to userspace.\n         * Similar to GET_SIZE.\n         */\n        break;\n\n    case MYDEVICE_IOCTL_CLEAR:\n        /* TODO 5: Clear the buffer: set dev->data_size = 0.\n         * Also, wake up any readers that might be waiting for data? (No, they wait for data, not emptiness).\n         * Consider if you need to wake up writers waiting for space? (Not implemented in this design).\n         */\n        break;\n\n    case MYDEVICE_IOCTL_RESIZE:\n        /* TODO 6: Copy the requested new size from userspace.\n         * Use copy_from_user(&new_size, user_arg, sizeof(size_t)).\n         * If copy fails, set ret = -EFAULT and break.\n         */\n\n        /* TODO 7: Validate new_size: must be > 0 and <= MAX_BUFFER_SIZE.\n         * If invalid, set ret = -EINVAL and break.\n         */\n\n        /* TODO 8: Call buffer_resize(dev, new_size) (to be implemented).\n         * If resize fails, set ret = -ENOMEM.\n         */\n        break;\n\n    default:\n        /* TODO 9: Command not recognized. Set ret = -ENOTTY.\n         * This handles commands with our magic number but unknown nr.\n         */\n        break;\n    }\n\n    /* TODO 10: Release the device mutex.\n     * Hint: mutex_unlock(&dev->lock);\n     */\n\n    return ret;\n}\n```\n\n**3. Implementing `buffer_resize` Helper**\n\nThis function, called from the ioctl handler, must safely resize the internal buffer while preserving existing data.\n\n```c\nstatic int buffer_resize(struct mydevice_data *dev, size_t new_size)\n{\n    char *new_buffer;\n\n    /* TODO 1: Allocate new buffer with kmalloc, using GFP_KERNEL flag.\n     * Hint: new_buffer = kmalloc(new_size, GFP_KERNEL);\n     * If allocation fails, return -ENOMEM.\n     */\n\n    /* TODO 2: Copy existing data from old buffer to new buffer.\n     * Only copy up to min(dev->data_size, new_size) bytes.\n     * Use memcpy(new_buffer, dev->buffer, copy_size).\n     */\n\n    /* TODO 3: Update dev->data_size to the copied size (cannot exceed new capacity).\n     * Hint: dev->data_size = min(dev->data_size, new_size);\n     */\n\n    /* TODO 4: Free the old buffer using kfree(dev->buffer). */\n\n    /* TODO 5: Assign the new buffer and new size to the device structure.\n     * dev->buffer = new_buffer;\n     * dev->buffer_size = new_size;\n     */\n\n    /* TODO 6: Print a debug message via printk(KERN_INFO \"buffer resized to %zu\\n\", new_size). */\n\n    return 0; /* Success */\n}\n```\n\n**4. Creating the /proc Entry**\n\nAdd to your `mydevice_init` function to create the proc entry, and clean up in `mydevice_exit`.\n\n```c\n#include <linux/proc_fs.h>\n\nstatic struct proc_dir_entry *mydevice_proc_entry;\n\nstatic int mydevice_proc_show(struct seq_file *m, void *v)\n{\n    struct mydevice_data *dev = m->private;\n\n    /* TODO 1: Acquire the device mutex to read consistent state.\n     * Hint: mutex_lock(&dev->lock);\n     */\n\n    /* TODO 2: Use seq_printf to output statistics, one line per metric.\n     * Example:\n     * seq_printf(m, \"Buffer capacity: %zu bytes\\n\", dev->buffer_size);\n     * seq_printf(m, \"Data stored: %zu bytes\\n\", dev->data_size);\n     * seq_printf(m, \"Maximum allowed size: %d bytes\\n\", MAX_BUFFER_SIZE);\n     * seq_printf(m, \"Device major number: %d\\n\", MAJOR(dev->dev_num));\n     * seq_printf(m, \"Device minor number: %d\\n\", MINOR(dev->dev_num));\n     */\n\n    /* TODO 3: Release the device mutex.\n     * Hint: mutex_unlock(&dev->lock);\n     */\n\n    return 0;\n}\n\nstatic int mydevice_proc_open(struct inode *inode, struct file *file)\n{\n    /* TODO 1: Use single_open() to associate the show function with the file.\n     * single_open(file, mydevice_proc_show, NULL);\n     * But we need to pass the device data. How to get it?\n     * We can use a global pointer or PDE_DATA(inode). Let's use a global.\n     * Declare: extern struct mydevice_data *mydevice_dev; (defined in main file)\n     * Then: return single_open(file, mydevice_proc_show, mydevice_dev);\n     */\n}\n\nstatic const struct proc_ops mydevice_proc_ops = {\n    .proc_open = mydevice_proc_open,\n    .proc_read = seq_read,\n    .proc_lseek = seq_lseek,\n    .proc_release = single_release,\n};\n\n/* In mydevice_init, after device creation: */\nstatic int __init mydevice_init(void)\n{\n    /* ... existing initialization ... */\n\n    /* Create /proc entry */\n    mydevice_proc_entry = proc_create(\"mychardev_stats\", 0444, NULL, &mydevice_proc_ops);\n    if (!mydevice_proc_entry) {\n        pr_err(\"Failed to create /proc entry\\n\");\n        /* Handle error: unregister device and class */\n        return -ENOMEM;\n    }\n\n    return 0;\n}\n\n/* In mydevice_exit: */\nstatic void __exit mydevice_exit(void)\n{\n    proc_remove(mydevice_proc_entry);\n    /* ... existing cleanup ... */\n}\n```\n\n**5. Userspace Test Program**\n\nCreate `test_ioctl.c` to verify the ioctl interface works correctly from userspace.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include \"mychardev.h\"  /* Shared header */\n\nint main(void)\n{\n    int fd;\n    size_t size, capacity;\n\n    fd = open(\"/dev/mychardev\", O_RDWR);\n    if (fd < 0) {\n        perror(\"Failed to open /dev/mychardev\");\n        exit(EXIT_FAILURE);\n    }\n\n    /* Get current data size */\n    if (ioctl(fd, MYDEVICE_IOCTL_GET_SIZE, &size) < 0) {\n        perror(\"ioctl GET_SIZE failed\");\n    } else {\n        printf(\"Current data size: %zu bytes\\n\", size);\n    }\n\n    /* Get buffer capacity */\n    if (ioctl(fd, MYDEVICE_IOCTL_GET_MAX_CAPACITY, &capacity) < 0) {\n        perror(\"ioctl GET_MAX_CAPACITY failed\");\n    } else {\n        printf(\"Buffer capacity: %zu bytes\\n\", capacity);\n    }\n\n    /* Clear the buffer */\n    printf(\"Clearing buffer...\\n\");\n    if (ioctl(fd, MYDEVICE_IOCTL_CLEAR) < 0) {\n        perror(\"ioctl CLEAR failed\");\n    }\n\n    /* Resize buffer to 2048 bytes */\n    size_t new_size = 2048;\n    printf(\"Resizing buffer to %zu bytes...\\n\", new_size);\n    if (ioctl(fd, MYDEVICE_IOCTL_RESIZE, &new_size) < 0) {\n        perror(\"ioctl RESIZE failed\");\n    } else {\n        printf(\"Resize successful.\\n\");\n    }\n\n    close(fd);\n    return 0;\n}\n```\n\n#### E. Language-Specific Hints\n\n- **Kernel vs. Userspace Headers**: The shared header `mychardev.h` will be included in both contexts. Use `#ifdef __KERNEL__` to conditionally include kernel-specific headers (like `<linux/ioctl.h>`) versus userspace headers (like `<sys/ioctl.h>`). However, since our commands are defined using kernel macros, we can just always include `<linux/ioctl.h>` and rely on userspace having a compatible definition (often available via `linux/ioctl.h` or manually defining the macros). A simpler approach is to copy the macro definitions directly into the header if portability is a concern.\n- **`size_t` in ioctl**: The `size` argument in `_IOR` expects a type name, but `size_t` is a typedef. The macro works fine because it uses `sizeof(type)`. However, ensure the kernel and userspace agree on the width of `size_t` (usually they do).\n- **Error Codes**: Familiarize yourself with kernel error codes: `-EFAULT` (bad address), `-ENOTTY` (invalid ioctl command), `-EINVAL` (invalid argument), `-ENOMEM` (out of memory). Return these negative numbers from your ioctl handler; the VFS will convert them to positive `errno` values for userspace.\n- **Procfs Permissions**: The mode `0444` in `proc_create` means read-only for all users. Use `0644` if you later add a write callback. Always restrict permissions to the minimum necessary.\n\n#### F. Milestone Checkpoint\n\nAfter implementing the ioctl handler and /proc entry:\n\n1. **Compile and load the module**:\n   ```\n   make\n   sudo insmod mychardev.ko\n   ```\n   Check `dmesg` for success messages and note the assigned major number.\n\n2. **Verify `/proc` entry exists**:\n   ```\n   cat /proc/mychardev_stats\n   ```\n   Expected output: lines showing buffer capacity (initially 1024), data size (0), max size (1048576), and major/minor numbers.\n\n3. **Run the userspace test program** (compile with `gcc -o test_ioctl test_ioctl.c`):\n   ```\n   sudo ./test_ioctl\n   ```\n   Expected output:\n   ```\n   Current data size: 0 bytes\n   Buffer capacity: 1024 bytes\n   Clearing buffer...\n   Resizing buffer to 2048 bytes...\n   Resize successful.\n   ```\n\n4. **Verify resize via `/proc`**:\n   ```\n   cat /proc/mychardev_stats\n   ```\n   Should now show \"Buffer capacity: 2048 bytes\".\n\n5. **Test error conditions**:\n   - Run `ioctl` with an invalid command (should return `-1` with `errno=ENOTTY`).\n   - Attempt to resize to a size > `MAX_BUFFER_SIZE` (should return `-1` with `errno=EINVAL`).\n\nIf any step fails, check `dmesg` for kernel error messages. Common issues: forgetting to implement the `buffer_resize` function, incorrect mutex locking, or misdefined ioctl commands.\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| `ioctl` returns `-1` with `errno=25` (`ENOTTY`) | Command number not recognized by driver (magic number mismatch or command not in switch) | Check `dmesg` for messages. Use `strace ./test_ioctl` to see the exact `ioctl` call and command number. Verify the command definitions in the header match those in the driver's switch statement. | Ensure `MYDEVICE_IOC_MAGIC` is the same in header and driver. Check that the command number (e.g., `1` for `GET_SIZE`) matches the `_IOR` macro's second argument. |\n| `ioctl` returns `-1` with `errno=14` (`EFAULT`) | `copy_to_user` or `copy_from_user` failed due to invalid userspace pointer | The test program likely passes a bad address. Ensure the userspace program passes a valid pointer (e.g., address of a stack variable). In the driver, verify you are using `copy_*_user` correctly and checking return values. | In userspace, check that `&size` is a valid address. In kernel, ensure you cast `arg` to `(void __user *)`. |\n| `/proc/mychardev_stats` shows garbled numbers or kernel oops | Race condition: reading `/proc` while buffer is being resized, or missing mutex protection | Add `printk` in `mydevice_proc_show` before and after lock acquisition. Check `dmesg` for \"BUG: sleeping function called from invalid context\" if you use a sleeping lock in atomic context (not applicable here). | Ensure `mydevice_proc_show` acquires `dev->lock` before accessing any device fields. |\n| Buffer resize fails silently (no error but capacity unchanged) | `buffer_resize` not implemented or not called, or `new_size` validation fails | Add debug `printk` in each branch of the ioctl switch and in `buffer_resize`. Check `dmesg` for these messages. | Implement `buffer_resize` function and ensure it's called from the `MYDEVICE_IOCTL_RESIZE` case. Verify `new_size` is within `[1, MAX_BUFFER_SIZE]`. |\n| `cat /proc/mychardev_stats` hangs indefinitely | Deadlock in `/proc` show function (e.g., double lock acquisition) | Check if `mydevice_proc_show` calls a function that also tries to acquire the same mutex. Look for `mutex_lock` without matching `mutex_unlock`. | Ensure lock acquisition is paired with release on all code paths, including error returns. Avoid calling functions that lock the same mutex. |\n\n---\n\n\n## Component: Concurrency and Synchronization Manager\n\n> **Milestone(s):** Milestone 4\n\nThis component transforms the driver from a simple, single-user device into a robust system that can safely handle concurrent access from multiple processes. It manages the kernel's most powerful concurrency primitives—mutexes, wait queues, and poll/select notification—to prevent data corruption and provide predictable behavior when multiple userspace programs read and write simultaneously. Think of this as the driver's \"traffic control center,\" coordinating access to shared resources without deadlocks or race conditions.\n\n### Mental Model: The Queue at the Library Desk\n\nImagine a public library with a single reference desk where patrons can write messages into a communal notebook and read messages left by others. This notebook represents the driver's internal buffer. Without rules, chaos ensues: two people writing simultaneously might overwrite each other, someone reading while another writes might see garbled text, and someone trying to read from an empty notebook just wastes time.\n\nNow introduce a librarian (the kernel driver) who implements three key systems:\n\n1. **The \"One-at-a-Time\" Ticket (Mutex)**: The librarian issues a single ticket that grants exclusive access to the notebook. Any patron wanting to read or write must first obtain this ticket. If someone else has it, they wait patiently in their seat (the process sleeps). This prevents simultaneous modifications and ensures each operation sees a consistent state. The ticket is returned immediately after the operation so others can use it.\n\n2. **The Waiting Line for Readers (Wait Queue)**: When the notebook is empty, readers have nothing to do. Instead of constantly asking \"Is there data yet?\" (busy-waiting), they take a numbered ticket and sit in a designated waiting area (the wait queue). When a writer adds new data to the notebook, the librarian announces \"Data available!\" and calls the next number in line, waking up exactly one waiting reader. This is efficient and polite.\n\n3. **The \"Ready-to-Serve\" Light (Poll/Select)**: Some patrons prefer not to wait idly. They want to know in advance if the notebook has data or has space for writing. The librarian installs a status light with two bulbs: \"Data Available to Read\" and \"Space Available to Write.\" Patrons can glance at this light (via `poll()` or `select()`) and only approach the desk when it shows what they need. This enables efficient I/O multiplexing where a single program can monitor multiple notebooks (file descriptors) simultaneously.\n\nThis mental model clarifies why we need synchronization: kernel data structures exist in a shared, preemptible environment where multiple execution contexts (processes, interrupts) can access them concurrently. The mutex provides mutual exclusion, the wait queue enables efficient blocking, and poll support enables non-blocking readiness checking.\n\n### ADR: Mutex vs. Spinlock for Buffer Protection\n\n> **Decision: Use a Mutex (`struct mutex`) for Buffer Protection Instead of a Spinlock**\n> - **Context**: Our driver's `read` and `write` handlers perform operations that may sleep—specifically, `copy_to_user`, `copy_from_user`, and `wait_event_interruptible`. These functions can block the current process if the required user memory is paged out or if we voluntarily sleep on a wait queue. The locking primitive must accommodate this sleeping behavior.\n> - **Options Considered**:\n>     1. **Mutex (`struct mutex`, `mutex_lock()`)**: A sleeping lock that yields the CPU when contested.\n>     2. **Spinlock (`spinlock_t`, `spin_lock()`)**: A busy-wait lock that loops continuously until acquired.\n>     3. **Reader-Writer Semaphore (`struct rw_semaphore`)**: Allows multiple concurrent readers or a single writer.\n> - **Decision**: We will use a standard mutex (`struct mutex`) initialized with `mutex_init()` and protected with `mutex_lock()`/`mutex_unlock()`.\n> - **Rationale**:\n>     - **Sleep Safety**: Mutexes are explicitly designed for contexts where the holder may sleep. Spinlocks cannot be held across operations that might sleep (doing so can deadlock the entire system if the scheduler preempts the lock holder).\n>     - **Simplicity**: For our single-buffer model with relatively short critical sections, the overhead of a reader-writer lock is unnecessary. A mutex provides straightforward exclusive access.\n>     - **Performance Characteristics**: Critical sections in our driver (copying data, updating buffer metadata) are sufficiently short that spinlock overhead might be acceptable, but the risk of accidentally sleeping while holding the lock (e.g., in future code changes) outweighs any micro-optimization benefit.\n> - **Consequences**:\n>     - **Positive**: Code remains simple and safe against common sleeping-in-atomic-context errors. The mutex automatically handles process scheduling when blocked.\n>     - **Negative**: Slightly higher overhead than a spinlock due to scheduling costs, but this is negligible for a character device. Only one reader or writer can access the buffer at a time, even if multiple concurrent reads would be safe (a trade-off we accept for simplicity).\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| **Mutex** | Safe for sleeping contexts; simple API; automatic scheduling of waiters | Higher overhead than spinlock for very short critical sections; exclusive access only (no reader concurrency) | **Yes** |\n| **Spinlock** | Very low overhead for nano-second critical sections; can be used in interrupt context | **Cannot sleep while held** – deadly if used with `copy_to_user` or wait queues; wastes CPU while spinning | No |\n| **Reader-Writer Semaphore** | Allows multiple concurrent readers; still sleeping-safe | More complex API; potential writer starvation if readers are continuous; overkill for our simple buffer | No |\n\nThis decision directly influences the fields in our `struct mydevice_data`: we include a `lock` field of type `struct mutex`, not `spinlock_t`.\n\n### Common Pitfalls: Kernel Synchronization\n\nKernel concurrency is notoriously subtle. Here are the most common mistakes when implementing this component, why they're dangerous, and how to avoid them.\n\n#### ⚠️ **Pitfall: Sleeping While Holding a Spinlock**\n- **Description**: Calling a function that may sleep (like `copy_to_user`, `kmalloc` with `GFP_KERNEL`, or `wait_event_interruptible`) while holding a spinlock.\n- **Why It's Wrong**: Spinlocks are used in atomic contexts (like interrupt handlers) where sleeping is illegal. If you sleep while holding a spinlock, the scheduler might never run the process that will release it, causing a system deadlock. The kernel will emit a \"scheduling while atomic\" oops.\n- **Fix**: Use a mutex for locks that protect operations that may sleep. If you must use a spinlock (e.g., in an interrupt handler), ensure all functions called within the critical section are non-sleeping (use `GFP_ATOMIC` for allocations).\n\n#### ⚠️ **Pitfall: Forgetting to Unlock on Error Paths**\n- **Description**: Acquiring a mutex at the start of a function but returning early on an error condition (e.g., `copy_to_user` fails) without releasing the mutex.\n```c\nmutex_lock(&dev->lock);\nif (copy_to_user(...)) {\n    return -EFAULT; // BUG: mutex still held!\n}\nmutex_unlock(&dev->lock);\n```\n- **Why It's Wrong**: The mutex remains locked forever, causing all subsequent calls to hang indefinitely on `mutex_lock`. This deadlock is often subtle because it only triggers when a specific error occurs.\n- **Fix**: Use `goto` labels for centralized cleanup or ensure every return path has a corresponding unlock. The pattern is:\n```c\nmutex_lock(&dev->lock);\nif (error) {\n    mutex_unlock(&dev->lock);\n    return err;\n}\nmutex_unlock(&dev->lock);\n```\n\n#### ⚠️ **Pitfall: Incorrect Wait Queue Usage Without Condition Re-check**\n- **Description**: Using `wait_event_interruptible(wq, condition)` but not re-checking the condition after being woken up before proceeding.\n- **Why It's Wrong**: The Linux kernel has **spurious wakeups**—processes can be awakened from wait queues even when the condition isn't true (e.g., due to signals). If you assume the condition holds and proceed to read from an empty buffer, you'll get invalid data.\n- **Fix**: Always use `wait_event_interruptible` in a loop that re-tests the condition. The macro itself implements this loop, but if you manually manipulate wait queues with `prepare_to_wait`/`finish_wait`, you must loop.\n\n#### ⚠️ **Pitfall: Missing Memory Barriers in Lock-Free Code**\n- **Description**: Assuming that writes to shared variables are immediately visible to other CPUs without explicit memory ordering directives.\n- **Why It's Wrong**: Modern CPUs reorder memory operations for performance. Without proper barriers, one CPU might see stale data even after a lock is released, leading to race conditions.\n- **Fix**: When using locks (mutex/spinlock), the lock/unlock operations include implicit memory barriers. **Do not attempt lock-free programming** in this learning driver; always use the provided synchronization primitives.\n\n#### ⚠️ **Pitfall: Incorrect Poll Mask Return**\n- **Description**: The `poll` file operation returns the wrong event mask bits (e.g., returning `POLLIN` when the buffer is empty) or forgetting to call `poll_wait`.\n- **Why It's Wrong**: Userspace `select()`/`poll()` calls will report incorrect readiness, causing busy-waiting or missing available data. Forgetting `poll_wait` means the driver won't wake up the waiting process when conditions change.\n- **Fix**: Return `POLLIN | POLLRDNORM` only when `data_size > 0`. Return `POLLOUT | POLLWRNORM` only when there's free space (`buffer_size - data_size > 0`). Always call `poll_wait(file, &dev->waitq, wait)` to register the wait queue.\n\n#### ⚠️ **Pitfall: Priority Inversion in Lock Usage**\n- **Description**: A high-priority process waiting for a mutex held by a low-priority process that itself isn't scheduled due to CPU contention.\n- **Why It's Wrong**: In real-time systems, this can cause deadlines to be missed. While less critical for our simple driver, it's a fundamental concurrency design flaw.\n- **Fix**: The Linux mutex implementation uses priority inheritance (`CONFIG_RT_MUTEXES`) to mitigate this automatically. For our purposes, just keep critical sections short to minimize hold time.\n\nThe diagram ![System Component Diagram](./diagrams/diagram-sys-component.svg) shows the Synchronization Manager's position between the Character Device Core and the I/O Buffer, intercepting all access attempts to enforce safe concurrency.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **Exclusive Lock** | `struct mutex` with `mutex_lock()`/`mutex_unlock()` | `struct rw_semaphore` for reader/writer differentiation |\n| **Blocking I/O** | `wait_event_interruptible()` with a single wait queue | Multiple wait queues for readers and writers separately |\n| **Poll/Select** | Implement `.poll` in `file_operations` returning simple masks | Full `epoll` support with `struct file_operations` `.poll` and `.release` that manages epoll contexts |\n| **Concurrency Testing** | Shell script with background `dd` processes | Custom userspace stress test with `pthreads` and fault injection |\n\n#### B. Recommended File/Module Structure\n\nThe concurrency components are integrated into the existing driver files:\n```\nproject/\n├── mychardev.c          # Main driver (add mutex, waitq, poll here)\n├── mychardev.h          # Shared header (ioctl commands, struct definitions)\n├── Makefile             # Kbuild Makefile\n└── test_concurrent.c    # Userspace test program for Milestone 4\n```\n\n#### C. Infrastructure Starter Code\n\nFirst, update the `struct mydevice_data` in `mychardev.h` to include synchronization fields:\n\n```c\n// In mychardev.h\n#ifndef MYCHARDEV_H\n#define MYCHARDEV_H\n\n#include <linux/ioctl.h>\n\n#define MYDEVICE_IOC_MAGIC 'k'\n#define MYDEVICE_IOCTL_GET_SIZE _IOR(MYDEVICE_IOC_MAGIC, 1, size_t)\n#define MYDEVICE_IOCTL_GET_MAX_CAPACITY _IOR(MYDEVICE_IOC_MAGIC, 2, size_t)\n#define MYDEVICE_IOCTL_CLEAR _IO(MYDEVICE_IOC_MAGIC, 3)\n#define MYDEVICE_IOCTL_RESIZE _IOW(MYDEVICE_IOC_MAGIC, 4, size_t)\n\n#define DEVICE_NAME \"mychardev\"\n#define BUFFER_SIZE 1024\n#define MAX_BUFFER_SIZE (1024*1024) // 1 MiB\n\n#endif\n```\n\n```c\n// In mychardev.c - updated struct definition\nstruct mydevice_data {\n    dev_t dev_num;                 // Device number (major+minor)\n    struct cdev cdev;              // Character device structure\n    struct class *dev_class;       // Device class for /dev/node\n    struct device *device;         // Device instance\n    \n    // Buffer and data management\n    char *buffer;                  // Linear buffer for data storage\n    size_t buffer_size;            // Total capacity of buffer\n    size_t data_size;              // Current amount of data in buffer\n    \n    // CONCURRENCY FIELDS (Milestone 4)\n    struct mutex lock;             // Mutex for buffer protection\n    wait_queue_head_t waitq;       // Wait queue for blocking read\n};\n```\n\n#### D. Core Logic Skeleton Code\n\n**1. Initializing Synchronization Primitives in `mydevice_init()`:**\n\n```c\nstatic int __init mydevice_init(void)\n{\n    struct mydevice_data *dev;\n    int err;\n    \n    // ... existing allocation and device registration code ...\n    \n    // Initialize buffer (existing)\n    err = buffer_init(dev, BUFFER_SIZE);\n    if (err) {\n        // cleanup...\n        return err;\n    }\n    \n    // MILESTONE 4: Initialize synchronization primitives\n    mutex_init(&dev->lock);                    // Initialize mutex\n    init_waitqueue_head(&dev->waitq);          // Initialize wait queue\n    \n    printk(KERN_INFO DEVICE_NAME \": module loaded with mutex and waitq\\n\");\n    return 0;\n}\n```\n\n**2. Updated `mydevice_write()` with Mutex Protection:**\n\n```c\nstatic ssize_t mydevice_write(struct file *filp, const char __user *buf,\n                              size_t count, loff_t *f_pos)\n{\n    struct mydevice_data *dev = filp->private_data;\n    ssize_t retval = 0;\n    \n    // MILESTONE 4: Protect buffer access with mutex\n    mutex_lock(&dev->lock);\n    \n    // Check if buffer has enough space\n    if (dev->data_size + count > dev->buffer_size) {\n        // No space - truncate write to available space\n        count = dev->buffer_size - dev->data_size;\n        if (count == 0) {\n            retval = -ENOSPC;  // Buffer full\n            goto out_unlock;\n        }\n    }\n    \n    // Copy data from userspace\n    if (copy_from_user(dev->buffer + dev->data_size, buf, count)) {\n        retval = -EFAULT;\n        goto out_unlock;\n    }\n    \n    // Update buffer state\n    dev->data_size += count;\n    retval = count;  // Return number of bytes written\n    \n    // MILESTONE 4: Wake up any readers waiting for data\n    wake_up_interruptible(&dev->waitq);\n    \nout_unlock:\n    mutex_unlock(&dev->lock);\n    return retval;\n}\n```\n\n**3. Blocking `mydevice_read()` with Wait Queue:**\n\n```c\nstatic ssize_t mydevice_read(struct file *filp, char __user *buf,\n                             size_t count, loff_t *f_pos)\n{\n    struct mydevice_data *dev = filp->private_data;\n    ssize_t retval = 0;\n    \n    // MILESTONE 4: Wait for data to become available (interruptible sleep)\n    // This loop handles spurious wakeups by re-checking condition\n    if (wait_event_interruptible(dev->waitq, dev->data_size > 0)) {\n        // Interrupted by signal before data arrived\n        return -ERESTARTSYS;\n    }\n    \n    mutex_lock(&dev->lock);\n    \n    // Read at most the available data\n    if (count > dev->data_size) {\n        count = dev->data_size;\n    }\n    \n    // Copy data to userspace\n    if (copy_to_user(buf, dev->buffer, count)) {\n        retval = -EFAULT;\n        goto out_unlock;\n    }\n    \n    // Remove read data from buffer (simple linear buffer - shift remaining data)\n    // TODO 1: Move remaining data to the front of the buffer\n    // memmove(dev->buffer, dev->buffer + count, dev->data_size - count);\n    \n    // TODO 2: Update data_size after the read\n    // dev->data_size -= count;\n    \n    retval = count;  // Return number of bytes read\n    \nout_unlock:\n    mutex_unlock(&dev->lock);\n    return retval;\n}\n```\n\n**4. Implementing the `poll` File Operation:**\n\n```c\nstatic __poll_t mydevice_poll(struct file *filp, poll_table *wait)\n{\n    struct mydevice_data *dev = filp->private_data;\n    __poll_t mask = 0;\n    \n    // MILESTONE 4: Register wait queue for poll notifications\n    poll_wait(filp, &dev->waitq, wait);\n    \n    mutex_lock(&dev->lock);\n    \n    // TODO 1: Check if data is available for reading\n    // if (dev->data_size > 0) {\n    //     mask |= POLLIN | POLLRDNORM;  // Readable\n    // }\n    \n    // TODO 2: Check if space is available for writing\n    // if (dev->data_size < dev->buffer_size) {\n    //     mask |= POLLOUT | POLLWRNORM; // Writable\n    // }\n    \n    mutex_unlock(&dev->lock);\n    return mask;\n}\n```\n\n**5. Updated `file_operations` Structure:**\n\n```c\nstatic struct file_operations fops = {\n    .owner = THIS_MODULE,\n    .open = mydevice_open,\n    .release = mydevice_release,\n    .read = mydevice_read,\n    .write = mydevice_write,\n    .unlocked_ioctl = mydevice_ioctl,\n    // MILESTONE 4: Add poll support\n    .poll = mydevice_poll,\n};\n```\n\n**6. Concurrency-Aware `ioctl` Handler Updates:**\n\n```c\nstatic long mydevice_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n    struct mydevice_data *dev = filp->private_data;\n    int err = 0;\n    \n    // MILESTONE 4: Protect ioctl operations with mutex\n    mutex_lock(&dev->lock);\n    \n    switch (cmd) {\n        case MYDEVICE_IOCTL_GET_SIZE:\n            // TODO: Copy dev->data_size to userspace\n            break;\n            \n        case MYDEVICE_IOCTL_CLEAR:\n            // TODO: Clear buffer and wake up waiters if needed\n            // dev->data_size = 0;\n            // wake_up_interruptible(&dev->waitq);\n            break;\n            \n        case MYDEVICE_IOCTL_RESIZE:\n            // TODO: Call buffer_resize with mutex held\n            // err = buffer_resize(dev, (size_t)arg);\n            break;\n            \n        default:\n            err = -ENOTTY;  // Unknown ioctl command\n    }\n    \n    mutex_unlock(&dev->lock);\n    return err;\n}\n```\n\n**7. Userspace Test Program for Concurrency (`test_concurrent.c`):**\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/select.h>\n#include <pthread.h>\n#include <errno.h>\n\n#define DEVICE_PATH \"/dev/mychardev\"\n\nvoid *writer_thread(void *arg) {\n    int fd = open(DEVICE_PATH, O_WRONLY);\n    if (fd < 0) {\n        perror(\"writer open\");\n        return NULL;\n    }\n    \n    char msg[] = \"Hello from thread!\\n\";\n    for (int i = 0; i < 10; i++) {\n        write(fd, msg, strlen(msg));\n        usleep(100000); // 100ms between writes\n    }\n    \n    close(fd);\n    return NULL;\n}\n\nvoid *reader_thread(void *arg) {\n    int fd = open(DEVICE_PATH, O_RDONLY);\n    if (fd < 0) {\n        perror(\"reader open\");\n        return NULL;\n    }\n    \n    char buf[256];\n    for (int i = 0; i < 10; i++) {\n        int n = read(fd, buf, sizeof(buf)-1);\n        if (n > 0) {\n            buf[n] = '\\0';\n            printf(\"Reader got: %s\", buf);\n        }\n        usleep(150000); // 150ms between reads\n    }\n    \n    close(fd);\n    return NULL;\n}\n\nint main() {\n    pthread_t writers[2], readers[2];\n    \n    // Create multiple writer and reader threads\n    for (int i = 0; i < 2; i++) {\n        pthread_create(&writers[i], NULL, writer_thread, NULL);\n        pthread_create(&readers[i], NULL, reader_thread, NULL);\n    }\n    \n    // Wait for all threads\n    for (int i = 0; i < 2; i++) {\n        pthread_join(writers[i], NULL);\n        pthread_join(readers[i], NULL);\n    }\n    \n    printf(\"Concurrency test completed.\\n\");\n    return 0;\n}\n```\n\n#### E. Language-Specific Hints\n\n- **Mutex Initialization**: Always initialize mutexes with `mutex_init()` before use. Static initialization is also possible with `DEFINE_MUTEX(mutexname)`.\n- **Wait Queue Usage**: Use `wait_event_interruptible()` for sleep that can be interrupted by signals (recommended). Use `wait_event()` for uninterruptible sleep (dangerous, can cause hung processes).\n- **Poll Implementation**: The `poll_table` pointer `wait` must be passed to `poll_wait()` even if you don't store it. This registers the wait queue with the poll mechanism.\n- **Error Codes**: Return `-ERESTARTSYS` when a wait is interrupted by a signal; the VFS will automatically restart the system call if appropriate.\n- **Memory Ordering**: When accessing shared variables outside locks (e.g., in `poll` before taking the lock), consider using `READ_ONCE()`/`WRITE_ONCE()` macros to prevent compiler optimizations from causing issues.\n\n#### F. Milestone Checkpoint\n\nAfter implementing Milestone 4:\n\n1. **Compile and Load**: `sudo insmod mychardev.ko`\n2. **Check dmesg for initialization**: `dmesg | tail` should show \"module loaded with mutex and waitq\"\n3. **Test blocking read**: In one terminal: `sudo cat /dev/mychardev` (will block)\n4. **Test wakeup**: In another terminal: `echo \"test\" | sudo tee /dev/mychardev`\n   - The `cat` should immediately output \"test\" and exit\n5. **Test concurrent access**: Compile and run the test program: `gcc -pthread test_concurrent.c -o test_concurrent && sudo ./test_concurrent`\n   - Expected: No crashes, all threads complete, output shows interleaved reads and writes\n6. **Test poll/select**: Write a small program that uses `select()` on the device file descriptor\n   - Should show readable when data is present, writable when space available\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **System hangs on `read()`** | Deadlock: mutex held but not released on error path | Add `printk` before/after each `mutex_lock`/`mutex_unlock`; check for early returns without unlock | Ensure all error paths release the mutex; use `goto` cleanup pattern |\n| **`read()` returns 0 immediately even though no data** | Wait queue not being used or condition not rechecked | Check if `wait_event_interruptible` is called; add `printk` to see if read proceeds without waiting | Ensure `wait_event_interruptible` surrounds the buffer-empty check |\n| **Multiple readers get same data repeatedly** | Buffer not being cleared/advanced after read | Check the buffer management in `mydevice_read`; data should be removed after copying to user | Implement proper buffer shifting with `memmove` |\n| **`select()` always shows ready even when empty** | `poll` returning wrong mask bits | Add `printk` in `mydevice_poll` showing mask calculation; check condition logic | Ensure mask only includes `POLLIN` when `data_size > 0` |\n| **Writer threads starve** | Readers hold mutex too long or buffer never fills | Check critical section duration; add timing `printk` statements | Shorten lock hold time; consider fairness or reader/writer locks |\n| **Module can't be unloaded (`rmmod` hangs)** | Processes sleeping in wait queue holding reference | Check `lsmod` for usage count; `sudo lsof /dev/mychardev` shows open handles | Ensure all processes close device file; wait queue should be interruptible |\n\nThe diagram ![Data Model and State Relationships](./diagrams/diagram-data-model.svg) illustrates how the `lock` and `waitq` fields integrate into the `struct mydevice_data`, protecting access to the `buffer` and its metadata. The sequence diagram ![Sequence Diagram: Write then Read](./diagrams/diagram-seq-write-read.svg) shows the precise flow of lock acquisition, buffer modification, wait queue wakeup, and lock release during concurrent operations.\n\n\n## Interactions and Data Flow\n\n> **Milestone(s):** Milestone 2, Milestone 3, Milestone 4 (integration of all components into cohesive workflows)\n\nThis section traces the concrete pathways through which userspace actions translate into kernel operations and how multiple processes interact safely with the device driver. Understanding these flows is critical for debugging and reasoning about the system's behavior under both normal and concurrent usage.\n\n### Sequence of Operations: From User Command to Kernel Action\n\nThink of the driver as a **well-trained receptionist in a government office**. Userspace applications are citizens submitting forms (data) or requesting information. The receptionist follows a strict, documented procedure for each type of request: they validate the request, check internal records (the buffer), update logs (statistics), and provide a receipt (return value). Every citizen interaction follows a predictable sequence through different department desks (kernel subsystems).\n\nThe following tables detail the step-by-step journeys for key operations, showing exactly which kernel functions are called in response to specific userspace commands.\n\n#### Module Loading and Device Node Creation\n\nWhen an administrator runs `sudo insmod mychardev.ko`, the following sequence unfolds:\n\n| Step | Actor | Action | Kernel Function Called | Key Data Structure Modified |\n|------|-------|--------|------------------------|-----------------------------|\n| 1 | Userspace | Execute `insmod` system call | `init_module()` (syscall) | N/A |\n| 2 | Kernel | Locate module file, validate headers | `load_module()` | `struct module` |\n| 3 | Kernel | Call module's initialization function | `mydevice_init()` | Global `struct mydevice_data dev_data` |\n| 4 | Driver | Allocate device number range | `alloc_chrdev_region(&dev_data.dev_num, ...)` | `dev_data.dev_num` |\n| 5 | Driver | Initialize character device | `cdev_init(&dev_data.cdev, &mydevice_fops)` | `dev_data.cdev` |\n| 6 | Driver | Add device to system | `cdev_add(&dev_data.cdev, ...)` | VFS device table |\n| 7 | Driver | Create device class | `class_create(THIS_MODULE, DEVICE_NAME)` | `dev_data.dev_class` |\n| 8 | Driver | Create `/dev` node | `device_create(dev_data.dev_class, ...)` | `/dev/mychardev` inode |\n| 9 | Driver | Initialize synchronization | `mutex_init(&dev_data.lock)`, `init_waitqueue_head(&dev_data.waitq)` | `dev_data.lock`, `dev_data.waitq` |\n| 10 | Driver | Allocate buffer | `buffer_init(&dev_data, BUFFER_SIZE)` | `dev_data.buffer`, `dev_data.buffer_size` |\n| 11 | Kernel | Return success to userspace | `printk(KERN_INFO \"mydevice: loaded\")` | Kernel log |\n\n> **Key Insight:** Module loading is a **one-time setup** that establishes the infrastructure (device numbers, VFS registration, `/dev` node) that enables all future file operations. Failure at any step must trigger complete rollback of previous steps.\n\n#### Writing Data to the Device\n\nWhen a userspace program executes `echo \"Hello\" > /dev/mychardev`, the following flow occurs:\n\n1. **System Call Entry**: The `write()` system call is invoked with file descriptor pointing to `/dev/mychardev`, buffer containing \"Hello\", and count of 5 bytes.\n2. **VFS Routing**: The Virtual File System examines the inode's `file_operations` pointer and dispatches to `mydevice_write()`.\n3. **Parameter Validation**: The driver checks that `count` doesn't exceed available buffer space (`dev_data.buffer_size - dev_data.data_size`).\n4. **Lock Acquisition**: `mutex_lock(&dev_data.lock)` is called to ensure exclusive access to the buffer.\n5. **Boundary Check**: If buffer would overflow, returns `-ENOSPC` after releasing mutex.\n6. **Data Transfer**: `copy_from_user(dev_data.buffer + dev_data.data_size, user_buf, count)` copies 5 bytes from userspace.\n7. **State Update**: `dev_data.data_size` is incremented by 5.\n8. **Wake Sleepers**: `wake_up_interruptible(&dev_data.waitq)` alerts any processes blocked in `mydevice_read()`.\n9. **Lock Release**: `mutex_unlock(&dev_data.lock)` allows other operations to proceed.\n10. **Return to Userspace**: Returns 5 (bytes written) to the `write()` system call.\n\n![Sequence Diagram: Write then Read](./diagrams/diagram-seq-write-read.svg)\n\n#### Reading Data from the Device (Blocking)\n\nWhen `cat /dev/mychardev` is executed and the buffer contains data:\n\n1. **System Call Entry**: The `read()` system call is invoked with file descriptor, userspace buffer, and maximum count.\n2. **VFS Routing**: Dispatched to `mydevice_read()` via `file_operations`.\n3. **Lock Acquisition**: `mutex_lock(&dev_data.lock)` for exclusive buffer access.\n4. **Data Availability Check**: Since `dev_data.data_size > 0`, proceed immediately.\n5. **Transfer Calculation**: Determine transfer size as `min(count, dev_data.data_size)`.\n6. **Data Copy**: `copy_to_user(user_buf, dev_data.buffer, transfer_size)` copies data to userspace.\n7. **Buffer Update**: If partial read, remaining data is shifted with `memmove()` and `dev_data.data_size` is decremented.\n8. **Lock Release**: `mutex_unlock(&dev_data.lock)`.\n9. **Return**: Returns number of bytes copied (e.g., 5).\n\nWhen the buffer is **empty** and a blocking read occurs:\n\n1. Steps 1-3 proceed identically.\n2. **Empty Buffer Detection**: `dev_data.data_size == 0` triggers wait queue logic.\n3. **Sleep Preparation**: `mutex_unlock(&dev_data.lock)` is called (must release before sleeping).\n4. **Condition Wait**: `wait_event_interruptible(dev_data.waitq, dev_data.data_size > 0)` puts process to sleep.\n5. **Signal or Data Arrival**: Process wakes either from signal (returns `-ERESTARTSYS`) or when writer calls `wake_up_interruptible()`.\n6. **Re-acquire Lock**: Upon waking, `mutex_lock(&dev_data.lock)` is called again.\n7. **Re-check Condition**: Buffer is verified non-empty (protects against spurious wakeups).\n8. **Proceed with Transfer**: Normal read operations continue from step 5 above.\n\n#### Ioctl Command Execution\n\nWhen a userspace program calls `ioctl(fd, MYDEVICE_IOCTL_RESIZE, &new_size)`:\n\n| Step | Action | Key Considerations |\n|------|--------|-------------------|\n| 1 | System call entry with command number and argument | VFS validates file descriptor |\n| 2 | VFS routes to `mydevice_ioctl()` | Command number checked against supported set |\n| 3 | Driver validates `cmd` using `_IOC_TYPE()` macros | Ensures magic number matches |\n| 4 | For `MYDEVICE_IOCTL_RESIZE`: copy argument from userspace | `copy_from_user(&size, arg, sizeof(size_t))` |\n| 5 | Acquire mutex: `mutex_lock(&dev_data.lock)` | Prevent concurrent buffer modification |\n| 6 | Validate new size (1 ≤ size ≤ MAX_BUFFER_SIZE) | Return `-EINVAL` if invalid |\n| 7 | Call `buffer_resize(&dev_data, size)` | Allocates new buffer, copies old data, frees old |\n| 8 | Release mutex: `mutex_unlock(&dev_data.lock)` | |\n| 9 | Return 0 (success) or negative error code | Error codes propagate to userspace `errno` |\n\n### Concurrent Access Flow\n\nImagine the device as a **single photocopier in a busy office** with a formal queue system. The mutex is the \"in use\" sign on the copier door—only one person can use it at a time. The wait queue is the line of people waiting for documents to copy. When someone finishes (writer), they notify the next person in line (wake reader). When the paper tray is refilled (buffer resized via ioctl), the maintenance person must wait for the current user to finish.\n\n#### Concurrent Read and Write Scenario\n\nConsider two processes: Process A writing \"DataA\" and Process B reading simultaneously.\n\n**Initial State**: Buffer empty, mutex unlocked.\n\n| Time | Process A (Writer) | Process B (Reader) | Buffer State | Mutex State | Wait Queue |\n|------|-------------------|-------------------|--------------|-------------|------------|\n| T1 | Calls `write()` | Calls `read()` | Empty | Unlocked | Empty |\n| T2 | `mutex_lock()` succeeds | `mutex_lock()` blocks | Empty | Locked (A) | Empty |\n| T3 | `copy_from_user()` copies \"DataA\" | Sleeps waiting for lock | \"DataA\" (5B) | Locked (A) | Empty |\n| T4 | Updates `data_size=5` | Still sleeping | \"DataA\" (5B) | Locked (A) | Empty |\n| T5 | `wake_up_interruptible()` | Woken by wake-up | \"DataA\" (5B) | Locked (A) | Wakes B |\n| T6 | `mutex_unlock()` | Attempts `mutex_lock()` | \"DataA\" (5B) | Unlocked | Empty |\n| T7 | Returns success (5) | `mutex_lock()` succeeds | \"DataA\" (5B) | Locked (B) | Empty |\n| T8 | | `copy_to_user()` copies \"DataA\" | \"DataA\" (5B) | Locked (B) | Empty |\n| T9 | | Updates `data_size=0` | Empty | Locked (B) | Empty |\n| T10 | | `mutex_unlock()` | Empty | Unlocked | Empty |\n| T11 | | Returns 5 bytes | Empty | Unlocked | Empty |\n\n> **Critical Synchronization Pattern:** The writer releases the mutex **before** calling `wake_up_interruptible()`. This ensures the woken reader can immediately acquire the mutex without contention, reducing \"thundering herd\" effects.\n\n#### Multiple Readers and Writers\n\nWith three processes (Writer1, Writer2, Reader1) operating concurrently:\n\n**State Transition Table**:\n\n| Event | Triggering Process | Buffer Before | Mutex Holder | Wait Queue | Buffer After | Action Taken |\n|-------|-------------------|---------------|--------------|------------|--------------|--------------|\n| 1 | Writer1 `write(\"W1\")` | Empty | None | Empty | \"W1\" | Locks mutex, writes, wakes queue (empty), unlocks |\n| 2 | Writer2 `write(\"W2\")` | \"W1\" | Writer2 | Empty | \"W1W2\" | Locks, writes, wakes, unlocks |\n| 3 | Reader1 `read()` (blocking) | \"W1W2\" | Reader1 | Empty | \"\" | Locks, reads both strings, wakes (none), unlocks |\n| 4 | Reader1 `read()` again | Empty | None | Empty | Empty | Locks, sees empty, unlocks, sleeps on waitq |\n| 5 | Writer1 `write(\"New\")` | Empty | Writer1 | [Reader1] | \"New\" | Locks, writes, wakes Reader1, unlocks |\n| 6 | Reader1 (woken) | \"New\" | Reader1 | Empty | Empty | Re-acquires lock, reads, unlocks |\n\n**Priority Inversion Avoidance**: Since `mutex_lock()` doesn't implement priority inheritance in all kernel configurations, a high-priority reader could be blocked by a low-priority writer holding the mutex. Our simple driver accepts this limitation, but production drivers might use `mutex_lock_interruptible()` with careful signal handling.\n\n#### Poll/Select Operation Flow\n\nWhen a userspace program calls `poll()` or `select()` on the device file descriptor:\n\n1. **System Call Entry**: `poll()` system call invoked with file descriptor and events mask.\n2. **VFS Routing**: Dispatched to `mydevice_poll()` via `file_operations`.\n3. **Wait Registration**: `poll_wait(file, &dev_data.waitq, wait)` adds the process to the device's wait queue for future notifications.\n4. **Event Mask Calculation**:\n   - If `dev_data.data_size > 0`: set `mask |= POLLIN | POLLRDNORM` (readable)\n   - If `dev_data.data_size < dev_data.buffer_size`: set `mask |= POLLOUT | POLLWRNORM` (writable)\n5. **Return Mask**: Immediate return of event mask—**does not sleep**.\n6. **Later Wake-up**: When a writer adds data, `wake_up_interruptible(&dev_data.waitq)` wakes all processes registered via `poll_wait()`.\n7. **Re-evaluation**: The `poll()` system call re-invokes `mydevice_poll()` for woken processes, which now returns updated mask.\n\n**Key Difference from Blocking Read**: `poll()` never sleeps in the driver; it only registers interest. The actual sleeping happens in the `poll()` system call implementation, which waits for **any** of the monitored file descriptors to become ready.\n\n#### Proc Filesystem Read Operation\n\nWhen a user reads `/proc/mychardev_stats`:\n\n1. **File Open**: VFS calls `mydevice_proc_open()`, which calls `single_open()` with `mydevice_proc_show` as callback.\n2. **Read Request**: For each read chunk, VFS calls `seq_read()` (via `proc_ops`).\n3. **Callback Invocation**: `mydevice_proc_show()` is called with seq_file context.\n4. **Data Collection** (under mutex protection):\n   - `mutex_lock(&dev_data.lock)`\n   - Capture: `data_size`, `buffer_size`, read/write statistics\n   - `mutex_unlock(&dev_data.lock)`\n5. **Formatting**: `seq_printf(m, \"Buffer: %zu/%zu bytes\\n\", data_size, buffer_size)`\n6. **Iteration**: `single_open()` automatically handles partial reads and file offsets.\n7. **Completion**: Returns 0 when all data is output.\n\n> **Design Insight:** The `/proc` interface uses a **read-once snapshot** model. Concurrent modifications during read may show slightly inconsistent statistics, but each individual read returns a self-consistent snapshot taken under mutex protection.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Sequence Tracing | `printk()` at function entry/exit | Dynamic debug (`dynamic_debug.ko`) with conditional compilation |\n| Concurrency Testing | Manual shell scripts with `dd` and `&` | Kernel thread stress test using `kthread_create()` |\n| Flow Visualization | Manual diagramming | SystemTap or BPF tracing for actual flow observation |\n\n#### B. Recommended File/Module Structure\n\n```\nproject-root/\n  Makefile                    # Kbuild makefile\n  mychardev.c                 # Main driver implementation (all components)\n  mychardev.h                 # Shared ioctl definitions (userspace + kernel)\n  test_mychardev.c            # Userspace test program\n  scripts/\n    stress_test.sh            # Concurrent access stress test\n```\n\n#### C. Infrastructure Starter Code\n\n**Complete Userspace Test Program Skeleton** (to be placed in `test_mychardev.c`):\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include \"mychardev.h\"  // Shared header with ioctl definitions\n\nint main(int argc, char **argv) {\n    int fd = open(\"/dev/mychardev\", O_RDWR);\n    if (fd < 0) {\n        perror(\"open\");\n        return 1;\n    }\n    \n    // Test write\n    char *msg = \"Test message\";\n    ssize_t written = write(fd, msg, strlen(msg));\n    printf(\"Write returned: %zd\\n\", written);\n    \n    // Test read\n    char buf[256];\n    ssize_t read_bytes = read(fd, buf, sizeof(buf));\n    printf(\"Read returned: %zd\\n\", read_bytes);\n    if (read_bytes > 0) {\n        buf[read_bytes] = '\\0';\n        printf(\"Data: %s\\n\", buf);\n    }\n    \n    // Test ioctl\n    size_t current_size;\n    if (ioctl(fd, MYDEVICE_IOCTL_GET_SIZE, &current_size) == 0) {\n        printf(\"Current buffer size: %zu\\n\", current_size);\n    }\n    \n    close(fd);\n    return 0;\n}\n```\n\n#### D. Core Logic Skeleton Code\n\n**Flow Tracing Helper Function** (to add to driver for debugging):\n\n```c\n// Add to mychardev.c for debugging data flows\n#ifdef DEBUG_FLOWS\n#define FLOW_TRACE(fmt, ...) printk(KERN_DEBUG \"FLOW %s: \" fmt, __func__, ##__VA_ARGS__)\n#else\n#define FLOW_TRACE(fmt, ...) do {} while (0)\n#endif\n\n// Example usage in mydevice_write:\nstatic ssize_t mydevice_write(struct file *filp, const char __user *buf,\n                              size_t count, loff_t *f_pos) {\n    FLOW_TRACE(\"ENTER: count=%zu, pos=%lld\\n\", count, *f_pos);\n    \n    // TODO 1: Validate parameters (count > 0, buf not NULL)\n    // TODO 2: Acquire mutex with mutex_lock(&dev_data.lock)\n    // TODO 3: Calculate available space: avail = buffer_size - data_size\n    // TODO 4: If count > avail, release mutex and return -ENOSPC\n    // TODO 5: Copy data with copy_from_user(dev_data.buffer + data_size, buf, count)\n    // TODO 6: Check copy_from_user return value; if error, release mutex and return -EFAULT\n    // TODO 7: Update data_size += actual_copied\n    // TODO 8: Release mutex with mutex_unlock(&dev_data.lock)\n    // TODO 9: Wake any waiting readers: wake_up_interruptible(&dev_data.waitq)\n    // TODO 10: Return number of bytes actually written\n    \n    FLOW_TRACE(\"EXIT: returning %zd\\n\", retval);\n    return retval;\n}\n```\n\n#### E. Language-Specific Hints\n\n1. **Flow Control**: Use `switch` statements in `mydevice_ioctl()` for command dispatch, not `if-else` chains.\n2. **Error Propagation**: Always return negative error codes (e.g., `-EINVAL`) from kernel functions; VFS converts these to `-1` with appropriate `errno` in userspace.\n3. **Concurrency Primitives**: Remember `mutex_lock()` can sleep; never call it in interrupt context or with spinlocks held.\n4. **Wait Queue Pattern**: The standard pattern is:\n   ```c\n   mutex_unlock(&lock);\n   wait_event_interruptible(waitq, condition);\n   mutex_lock(&lock);\n   ```\n\n#### F. Milestone Checkpoint\n\nAfter implementing all flows, test with:\n\n```bash\n# Load module\nsudo insmod mychardev.ko\ndmesg | tail  # Should show initialization messages\n\n# Test write-read flow\necho \"Test123\" > /dev/mychardev\ncat /dev/mychardev  # Should output \"Test123\"\n\n# Test concurrent access\nbash scripts/stress_test.sh  # Should run without hangs or corruption\n\n# Check /proc interface\ncat /proc/mychardev_stats  # Should show buffer statistics\n```\n\n**Expected Output in dmesg** (with `DEBUG_FLOWS` enabled):\n```\n[ 1234.567890] FLOW mydevice_write: ENTER: count=7, pos=0\n[ 1234.567891] FLOW mydevice_write: EXIT: returning 7\n[ 1234.567892] FLOW mydevice_read: ENTER: count=4096, pos=0\n[ 1234.567893] FLOW mydevice_read: EXIT: returning 7\n```\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Write hangs forever | Mutex deadlock (forgot unlock in error path) | Add `printk()` before/after each lock operation | Ensure every error path has `mutex_unlock()` |\n| Read returns 0 immediately when data exists | `copy_to_user()` failing | Check return value of `copy_to_user()` | Validate userspace buffer is writable |\n| Multiple readers get same data | Not advancing buffer pointer after read | Check buffer management after successful read | Update buffer state (shift data or update pointer) |\n| `poll()` returns immediately even when no data | Not calling `poll_wait()` | Verify `mydevice_poll()` calls `poll_wait(file, &dev_data.waitq, wait)` | Add missing `poll_wait()` call |\n| Concurrent write/read causes corruption | Missing mutex in resize operation | Check `buffer_resize()` is called under mutex | Acquire mutex before `buffer_resize()` |\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** Milestone 2, Milestone 3, Milestone 4 (error handling spans all user-facing operations and concurrency scenarios)\n\nThis section defines how the driver detects, reports, and recovers from failures and unusual conditions. In kernel programming, robust error handling is critical—a single unchecked error can crash the entire system, corrupt data, or create security vulnerabilities. Unlike user-space applications where crashes are contained, kernel failures have system-wide consequences.\n\n### Error Detection and Recovery Strategy\n\n> **Mental Model: The Defensive Guard at the Bridge**  \n> Think of the kernel as a secure fortress with bridges (system calls) connecting it to userland. Our driver is a guard stationed at one bridge. A good guard must: (1) **inspect every traveler** (validate all inputs), (2) **have clear protocols** (consistent error codes) for turning away problematic travelers, and (3) **clean up after disturbances** (release resources) without abandoning their post or damaging the bridge. The guard never assumes travelers are well-behaved—they actively verify credentials and intentions before allowing passage.\n\nOur error handling philosophy follows three core principles:\n\n1. **Fail Fast During Initialization**: If the driver cannot acquire essential resources (memory, device numbers) during module loading, it must clean up any partially acquired resources and refuse to load, returning an appropriate error code to `insmod`. A partially initialized driver in the kernel is dangerous.\n\n2. **Propagate Meaningful Errors to User-Space**: When a system call (read, write, ioctl) fails, the driver must return a negative error code that the Virtual File System (VFS) translates into a standard `errno` value (like `-ENOMEM` for out-of-memory). User-space applications see these as `errno` values (positive after `-` sign inversion) and can respond appropriately.\n\n3. **Maintain Internal Consistency**: Even when operations fail, the driver must leave its internal data structures in a consistent state. This typically involves careful ordering of operations and proper cleanup in error paths using `goto` labels—a common kernel pattern for rolling back multi-step initialization.\n\nThe table below maps common failure scenarios to their detection methods and recovery actions:\n\n| Failure Mode | Detection Method | Recovery Action | Error Propagation |\n|--------------|------------------|-----------------|-------------------|\n| Memory allocation failure (kmalloc) | `kmalloc` returns `NULL` | Return `-ENOMEM`; release any locks held before returning | To caller (user-space gets `errno=12`) |\n| Invalid user-space pointer | `copy_from_user`/`copy_to_user` returns non-zero (bytes not copied) | Return `-EFAULT`; no data corruption occurs | To caller (user-space gets `errno=14`) |\n| Buffer full during write | Check `dev->data_size == dev->buffer_size` | Return `-ENOSPC` (no space left) | To caller (user-space gets `errno=28`) |\n| Buffer empty during read | Check `dev->data_size == 0` | Block (if O_NONBLOCK not set) or return `-EAGAIN` | To caller (user-space gets `errno=11` if non-blocking) |\n| Invalid ioctl command | Switch statement default case | Return `-ENOTTY` (not a typewriter) | To caller (user-space gets `errno=25`) |\n| Signal interruption while sleeping | `wait_event_interruptible` returns non-zero | Return `-ERESTARTSYS` (system call should be restarted) | To VFS, which may restart the call |\n| Concurrent removal during operation | Check device state flag after acquiring lock | Return `-ENODEV` (no such device) | To caller (user-space gets `errno=19`) |\n\n> **Decision: Defensive Validation Over Optimistic Assumptions**\n> - **Context**: Kernel code must assume user-space data and behavior can be malicious or buggy. We need to decide how thoroughly to validate inputs.\n> - **Options Considered**:\n>   1. **Minimal validation**: Trust that userspace follows documented behavior, checking only critical safety issues (pointer validity).\n>   2. **Comprehensive validation**: Check all parameters for bounds, alignment, and semantic correctness before any side effects.\n>   3. **Layered validation**: Validate safety-critical issues immediately (pointers), defer semantic checks (buffer sizes) until after acquiring locks.\n> - **Decision**: Use layered validation (option 3).\n> - **Rationale**: Safety must come first—invalid pointers can crash the kernel, so they're checked before any operation. Semantic checks (like buffer bounds) happen after acquiring the mutex to avoid TOCTOU (Time-Of-Check-Time-Of-Use) races. This balances safety with performance.\n> - **Consequences**: Slightly more complex code flow but prevents both security vulnerabilities and race conditions. The mutex acquisition might fail if the device is being removed, which we also handle.\n\n### Specific Edge Cases and Handling\n\n#### 1. Buffer Full and Empty Conditions\nThe driver's linear buffer has three fundamental states, as shown in the state diagram:\n\n![State Machine: Device Buffer](./diagrams/diagram-state-buffer.svg)\n\n| Current State | Event | Next State | Actions Taken | Error Handling |\n|---------------|-------|------------|---------------|----------------|\n| EMPTY | Write request with `count > 0` | PARTIALLY_FILLED | Copy data, update `data_size`, wake waiters | If `count > buffer_size`: copy only `buffer_size` bytes, return `-ENOSPC` |\n| EMPTY | Read request | EMPTY | Return `0` (EOF) if non-blocking; block if O_NONBLOCK not set | If O_NONBLOCK set: return `-EAGAIN` |\n| PARTIALLY_FILLED | Write request | PARTIALLY_FILLED or FULL | Copy available space, update `data_size` | If remaining space < `count`: copy partial, return bytes copied (not error) |\n| PARTIALLY_FILLED | Read request | PARTIALLY_FILLED or EMPTY | Copy available data, shift remaining data, update `data_size` | Always succeeds (returns bytes read) |\n| FULL | Write request | FULL | Return `-ENOSPC` immediately | Check O_NONBLOCK: same behavior (error) |\n| FULL | Read request | PARTIALLY_FILLED | Copy data, shift remaining, update `data_size`, wake waiters | Always succeeds |\n\nThe key insight: **write operations may perform partial transfers** when the buffer is nearly full. The driver copies as much as fits, returns the number of bytes actually written (not an error), and lets user-space retry with remaining data if needed. This follows Unix convention (like writing to a pipe).\n\n#### 2. Invalid ioctl Commands and Arguments\nThe `ioctl` interface is particularly vulnerable to invalid inputs because it bypasses standard VFS validation. Our dispatch logic follows this flowchart:\n\n![Flowchart: Ioctl Command Dispatch](./diagrams/diagram-flow-ioctl.svg)\n\nSpecific edge cases:\n\n| Edge Case | Detection | Handling | Rationale |\n|-----------|-----------|----------|-----------|\n| Unknown command number | Switch default case | Return `-ENOTTY` | Standard Linux convention for invalid ioctl |\n| Invalid buffer size (0 or >MAX_BUFFER_SIZE) | Check in `MYDEVICE_IOCTL_RESIZE` handler | Return `-EINVAL` | Prevents degenerate allocations |\n| Misaligned or invalid user pointer for _IOR/_IOWR | `copy_to_user` fails | Return `-EFAULT` | Same protection as read/write |\n| Size mismatch between command definition and actual argument | Compile-time checking via `_IOR` macros | N/A (compile-time) | Type safety through kernel macros |\n\n#### 3. Process Termination While Sleeping on Wait Queue\nWhen a process calls `read()` on an empty buffer with blocking enabled, it sleeps in `wait_event_interruptible`. If the process receives a fatal signal (SIGKILL) or is terminated:\n\n1. **Detection**: `wait_event_interruptible` returns `-ERESTARTSYS` if interrupted by any signal.\n2. **Handling**: The `mydevice_read` function checks the return value:\n   - If `-ERESTARTSYS`: Return that value to VFS\n   - VFS will then check if the signal should restart the system call or return `-EINTR` to user-space\n3. **Cleanup**: The wait queue mechanism automatically removes the process from the queue when it wakes up (by signal or data arrival).\n\n> **Critical Insight**: The condition in `wait_event_interruptible(dev->waitq, dev->data_size > 0)` MUST be rechecked after waking, because **spurious wakeups** can occur (kernel scheduler may wake processes for other reasons). Our implementation loops: `while (dev->data_size == 0) { wait_event_interruptible(...); }`.\n\n#### 4. Concurrent Module Removal During Operations\nA rare but critical scenario: `rmmod` is called while user-space processes have the device file open and are actively reading/writing.\n\n1. **Detection**: The module exit function sets a \"shutting down\" flag and waits for operations to complete.\n2. **Handling in Operations**: Each handler function checks the flag after acquiring the mutex:\n   ```c\n   mutex_lock(&dev->lock);\n   if (dev->is_shutting_down) {\n       mutex_unlock(&dev->lock);\n       return -ENODEV;\n   }\n   ```\n3. **Cleanup Coordination**: The `mydevice_exit` function:\n   - Sets `is_shutting_down = true`\n   - Calls `synchronize_rcu()` to wait for existing readers\n   - Acquires mutex to ensure no new operations start\n   - Releases all resources\n\n#### 5. Poll/Select with Multiple Events\nThe `poll` handler must correctly report which events are possible:\n\n| Event Condition | Reported Mask | Notes |\n|-----------------|---------------|-------|\n| Data available for reading (`dev->data_size > 0`) | `POLLIN | POLLRDNORM` | Standard readable events |\n| Space available for writing (`dev->data_size < dev->buffer_size`) | `POLLOUT | POLLWRNORM` | Standard writable events |\n| Device in error state (should not happen) | `POLLERR` | Not used in our simple driver |\n| Device hung up (removed) | `POLLHUP` | Set if `dev->is_shutting_down` is true |\n\n**Edge Case**: What if both read and write are possible? The handler must return `POLLIN | POLLOUT`. The kernel `poll` implementation combines multiple wait queues correctly.\n\n#### 6. Memory Allocation Failure During Buffer Resize\nWhen handling `MYDEVICE_IOCTL_RESIZE`:\n\n1. **Strategy**: Allocate new buffer before freeing old (if allocation fails, original data preserved).\n2. **Steps**:\n   1. Validate requested size\n   2. `kmalloc` new buffer (with `GFP_KERNEL`)\n   3. If `NULL`, return `-ENOMEM`\n   4. Acquire mutex, copy old data (up to min(old_size, new_size))\n   5. Free old buffer, update pointer and size\n   6. Release mutex\n3. **Atomicity**: The mutex ensures no read/write sees intermediate state (partially copied data).\n\n#### 7. Partial Read/Write with Signal Interruption\nIf `copy_to_user` or `copy_from_user` is interrupted by a signal after copying some bytes:\n\n1. **Kernel Behavior**: The copy functions may return less than requested count if a signal arrives.\n2. **Our Handling**: We treat partial success as success—return the number of bytes actually copied.\n3. **Rationale**: This matches standard Linux filesystem semantics. User-space must check return value and retry if needed.\n\n⚠️ **Pitfall: Assuming copy_to_user is All-or-Nothing**  \nSome developers assume `copy_to_user` either succeeds completely or fails completely. In reality, it can return a value between 0 and `count` if interrupted. Always check for `> 0` as success, not `== 0`.\n\n#### 8. 32/64-bit User-Space Compatibility\nWhen user-space passes pointer arguments to `ioctl`:\n\n1. **Issue**: A 32-bit application on 64-bit kernel uses different pointer sizes.\n2. **Solution**: The `compat_ioctl` handler (not implemented in our learning driver) would be needed for production.\n3. **Our Simplification**: We assume same architecture for learning, but note this limitation.\n\n### Common Pitfalls in Error Handling\n\n⚠️ **Pitfall: Forgetting to Unlock Mutex on Error Paths**  \n**Description**: Acquiring a mutex then returning an error without unlocking.\n**Why Wrong**: Creates permanent deadlock—no subsequent operations can acquire the mutex.\n**Fix**: Use `goto` labels for cleanup:\n```c\nmutex_lock(&dev->lock);\nif (error) {\n    mutex_unlock(&dev->lock);\n    return error;\n}\n```\nBetter pattern:\n```c\nmutex_lock(&dev->lock);\nresult = operation();\nif (result < 0) {\n    goto out_unlock;\n}\n// success path\nout_unlock:\nmutex_unlock(&dev->lock);\nreturn result;\n```\n\n⚠️ **Pitfall: Not Checking copy_to_user Return Value**  \n**Description**: Assuming `copy_to_user` always succeeds.\n**Why Wrong**: User-space pointer may be invalid, causing kernel oops if dereferenced.\n**Fix**: Always check and return `-EFAULT` on failure:\n```c\nif (copy_to_user(buf, dev->buffer, count) != 0) {\n    return -EFAULT;\n}\n```\n\n⚠️ **Pitfall: Returning 0 from Read at EOF Without Blocking**  \n**Description**: When buffer is empty, `read` returns 0 immediately even without O_NONBLOCK.\n**Why Wrong**: User-space expects blocking read to wait for data (standard file behavior).\n**Fix**: Implement proper blocking with wait queue:\n```c\nif (dev->data_size == 0) {\n    if (filp->f_flags & O_NONBLOCK) {\n        return -EAGAIN;\n    }\n    wait_event_interruptible(dev->waitq, dev->data_size > 0);\n    // Re-check condition after wakeup (spurious wakeups)\n}\n```\n\n⚠️ **Pitfall: Ignoring wait_event_interruptible Return Value**  \n**Description**: Not checking why the wait returned.\n**Why Wrong**: Signal interruption looks like data arrival, may cause incorrect behavior.\n**Fix**: Check return value and propagate `-ERESTARTSYS`:\n```c\nint err = wait_event_interruptible(dev->waitq, dev->data_size > 0);\nif (err) {\n    return err; // -ERESTARTSYS\n}\n```\n\n### Implementation Guidance\n\n**Technology Recommendations Table:**\n\n| Component | Simple Option (Learning) | Advanced Option (Production) |\n|-----------|--------------------------|------------------------------|\n| Error Propagation | Return negative errno values | Add detailed `printk` with `KERN_ERR` for debugging |\n| Resource Cleanup | `goto` labels with rollback | Reference counting with `kref` |\n| Signal Handling | Basic `-ERESTARTSYS` return | Full signal masking and restart logic |\n| Concurrency Safety | Single mutex for all operations | Fine-grained locking (read/write locks) |\n\n**Recommended Error Handling Infrastructure:**\n\nWhile the core driver implements error handling directly, these helper patterns ensure consistency:\n\n1. **Standardized Cleanup Pattern** for initialization:\n```c\nstatic int __init mydevice_init(void)\n{\n    int ret = 0;\n    \n    // Step 1: Allocate device numbers\n    ret = alloc_chrdev_region(&mydevice.devt, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        printk(KERN_ERR \"Failed to allocate device number\\n\");\n        goto fail_region;\n    }\n    \n    // Step 2: Create device class  \n    mydevice.class = class_create(THIS_MODULE, DEVICE_NAME \"_class\");\n    if (IS_ERR(mydevice.class)) {\n        ret = PTR_ERR(mydevice.class);\n        printk(KERN_ERR \"Failed to create device class\\n\");\n        goto fail_class;\n    }\n    \n    // ... more initialization\n    \n    return 0;  // Success\n    \nfail_class:\n    unregister_chrdev_region(mydevice.devt, 1);\nfail_region:\n    return ret;  // Propagate error\n}\n```\n\n2. **Error Code Translation Table** for user-space understanding:\n\n| Kernel Return Value | User-Space errno | Meaning | Typical Cause |\n|--------------------|------------------|---------|---------------|\n| `-ENOMEM` (-12) | `ENOMEM` (12) | Out of memory | `kmalloc` failed |\n| `-EFAULT` (-14) | `EFAULT` (14) | Bad address | Invalid user pointer |\n| `-EINVAL` (-22) | `EINVAL` (22) | Invalid argument | Bad ioctl parameter |\n| `-ENOSPC` (-28) | `ENOSPC` (28) | No space left | Buffer full |\n| `-EAGAIN` (-11) | `EAGAIN` (11) | Try again | Non-blocking I/O would block |\n| `-ENOTTY` (-25) | `ENOTTY` (25) | Not a typewriter | Unknown ioctl command |\n\n**Core Logic Skeleton with Error Handling TODOs:**\n\n```c\nstatic ssize_t mydevice_read(struct file *filp, char __user *buf,\n                             size_t count, loff_t *f_pos)\n{\n    struct mydevice_data *dev = filp->private_data;\n    ssize_t retval = 0;\n    size_t available;\n    \n    // TODO 1: Validate input parameters\n    //   - Check if buf is NULL (shouldn't happen but be safe)\n    //   - Check if count is 0 (legal, return 0)\n    \n    // TODO 2: Acquire mutex for buffer access\n    //   - Use mutex_lock(&dev->lock)\n    //   - Consider checking dev->is_shutting_down after acquiring lock\n    \n    // TODO 3: Handle empty buffer condition\n    //   - If dev->data_size == 0:\n    //        a) If O_NONBLOCK set in filp->f_flags, set retval = -EAGAIN, goto out_unlock\n    //        b) Otherwise, wait for data with wait_event_interruptible\n    //        c) Check wait return: if non-zero, set retval = that value, goto out_unlock\n    //        d) Loop back to check data_size again (spurious wakeup protection)\n    \n    // TODO 4: Calculate how much data we can actually read\n    //   - available = min(count, dev->data_size)\n    //   - If available == 0, set retval = 0, goto out_unlock (shouldn't happen with wait)\n    \n    // TODO 5: Copy data to user-space with proper error handling\n    //   - retval = copy_to_user(buf, dev->buffer, available)\n    //   - If retval > 0, then (retval) bytes failed to copy\n    //   - actually_copied = available - retval\n    //   - If actually_copied == 0 and retval != 0, set retval = -EFAULT, goto out_unlock\n    //   - If actually_copied > 0, proceed with partial success\n    \n    // TODO 6: Update buffer state on successful copy\n    //   - memmove remaining data to front of buffer\n    //   - Update dev->data_size -= actually_copied\n    //   - Wake up writers (wake_up_interruptible(&dev->waitq))\n    //   - Set retval = actually_copied (positive value)\n    \nout_unlock:\n    // TODO 7: Release mutex\n    //   - mutex_unlock(&dev->lock)\n    //   - Return retval (may be positive count, 0, or negative error)\n    \n    return retval;\n}\n\nstatic long mydevice_ioctl(struct file *filp, unsigned int cmd,\n                           unsigned long arg)\n{\n    struct mydevice_data *dev = filp->private_data;\n    long retval = 0;\n    \n    // TODO 1: Handle each command in switch statement\n    switch (cmd) {\n    case MYDEVICE_IOCTL_GET_SIZE:\n        // TODO 2: Copy simple value to user-space\n        //   - Check copy_to_user for -EFAULT\n        break;\n        \n    case MYDEVICE_IOCTL_RESIZE:\n        // TODO 3: Validate new_size from user-space\n        //   - Copy from user-space first (copy_from_user)\n        //   - Check if 0 < new_size <= MAX_BUFFER_SIZE\n        //   - If invalid, set retval = -EINVAL\n        //   - Allocate new buffer before acquiring lock\n        //   - If allocation fails, set retval = -ENOMEM\n        //   - Acquire mutex, copy data, swap buffers, free old\n        //   - Handle partial copy (data may shrink)\n        break;\n        \n    case MYDEVICE_IOCTL_CLEAR:\n        // TODO 4: Simple clear operation\n        //   - Acquire mutex\n        //   - Set dev->data_size = 0\n        //   - Wake up writers (buffer now empty)\n        //   - Release mutex\n        break;\n        \n    default:\n        // TODO 5: Unknown command\n        //   - Set retval = -ENOTTY\n        break;\n    }\n    \n    return retval;\n}\n```\n\n**Language-Specific Hints for Kernel C:**\n\n1. **Error Code Constants**: Use standard kernel error codes from `<linux/errno.h>` (negative values). Never return positive error values.\n\n2. **Pointer Validation**: For user-space pointers, only use `copy_to_user`/`copy_from_user`. Never dereference directly.\n\n3. **Memory Allocation Errors**: `kmalloc` returns `NULL` on failure, not an error code. Convert to `-ENOMEM`.\n\n4. **Class/Device Creation Errors**: `IS_ERR()` and `PTR_ERR()` macros handle pointer errors from functions like `class_create`.\n\n5. **Wait Queue Returns**: `wait_event_interruptible` returns negative if interrupted, 0 if condition met. Check both cases.\n\n**Milestone Checkpoint for Error Handling:**\n\nAfter implementing error handling, test with these scenarios:\n\n1. **Buffer Full Error**: \n   ```\n   $ dd if=/dev/zero of=/dev/mychardev bs=2048 count=1000\n   dd: writing to '/dev/mychardev': No space left on device\n   ```\n   Check `dmesg` for `printk` message about buffer full.\n\n2. **Invalid Pointer Test** (requires test program):\n   ```c\n   // In userspace test program\n   char *bad_ptr = (char *)0x12345;  // Invalid address\n   write(fd, bad_ptr, 10);           // Should return -1, errno = EFAULT\n   ```\n\n3. **Signal Interruption**:\n   ```bash\n   $ cat /dev/mychardev &  # Starts blocking read\n   $ kill -INT %1          # Send interrupt signal\n   # Should see cat terminated with no data\n   ```\n\n4. **Concurrent Access Stress Test**:\n   ```bash\n   # Multiple writers trying to fill buffer\n   for i in {1..10}; do\n       (echo \"Writer $i\" > /dev/mychardev && echo \"Writer $i succeeded\") &\n   done\n   # Some should get ENOSPC, others succeed\n   ```\n\n**Debugging Tips for Error Conditions:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Module loads but `/dev/mychardev` not created | Class or device creation failed | Check `dmesg` for error messages after `class_create` or `device_create` | Verify permissions, check `IS_ERR()` return values |\n| Write returns `-1` with `errno=14` (EFAULT) | Invalid user-space pointer | Add `printk` before `copy_from_user` to log pointer value | User-space test program bug |\n| Read blocks forever even when data is written | Wait queue not woken up | Add `printk` in write after `wake_up_interruptible` | Ensure wakeup is called after updating `data_size` |\n| `ioctl` returns `-1` with `errno=25` (ENOTTY) | Command number mismatch | Compare command definitions in kernel and user-space header | Ensure same `_IOR`/`_IOW` macros with same parameters |\n| System becomes unresponsive during `rmmod` | Module exit waiting for operations | Add `printk` in each handler to see if called during shutdown | Implement `is_shutting_down` flag check in handlers |\n\n---\n\n\n## Testing Strategy\n\n> **Milestone(s):** Milestone 1, Milestone 2, Milestone 3, Milestone 4 (verification and validation of all functionality)\n\nThis section provides a comprehensive plan for verifying the correctness of the character device driver throughout its development lifecycle. Testing kernel modules presents unique challenges: you cannot simply run them in a debugger like userspace programs, crashes can affect the entire system, and many issues manifest as subtle data corruption or deadlocks under concurrent access. Our strategy employs a **progressive verification approach**—each milestone builds upon the verified functionality of the previous one—using a combination of simple command-line tools, custom test programs, and systematic stress testing. Think of testing a kernel module like **testing the structural integrity of a building**: you start with the foundation (module loading), then test each floor (device operations), then stress-test with simulated occupancy (concurrent access), and finally inspect safety systems (error handling).\n\n### Milestone Verification Checkpoints\n\nThis table provides specific, actionable verification steps for each milestone. Each checkpoint assumes you have successfully completed the implementation steps from the corresponding milestone and have the module compiled. The \"Expected Output\" column shows what you should see when running the commands; deviations indicate implementation issues that need debugging.\n\n| Milestone | Verification Step | Command to Run | Expected Output / Behavior | What This Verifies |\n|-----------|-------------------|----------------|----------------------------|---------------------|\n| **1: Hello World Module** | 1.1 Compile module | `make` | Successful compilation with no errors, generating `mychardev.ko` | Kbuild system is correctly configured and kernel headers are available |\n| | 1.2 Check module info | `modinfo mychardev.ko` | Shows `license: GPL`, `author: [Your Name]`, `description: Simple character device driver` | Module metadata is properly declared with `MODULE_LICENSE`, `MODULE_AUTHOR`, `MODULE_DESCRIPTION` |\n| | 1.3 Load module | `sudo insmod mychardev.ko` | No output on success (errors print to terminal) | Module initialization (`mydevice_init`) executes without errors |\n| | 1.4 Verify loading in kernel log | `dmesg \\| tail -5` | Contains lines: `[timestamp] mychardev: module loaded successfully, major=xxx` | `printk` with `KERN_INFO` works; module registers itself with kernel |\n| | 1.5 Check kernel module list | `lsmod \\| grep mychardev` | Shows `mychardev` with a reference count (probably 0) | Module is present in the running kernel's module list |\n| | 1.6 Unload module | `sudo rmmod mychardev` | No output on success | Module cleanup (`mydevice_exit`) executes without errors |\n| | 1.7 Verify unloading in kernel log | `dmesg \\| tail -5` | Contains line: `[timestamp] mychardev: module unloaded` | Module cleans up resources properly and leaves no trace |\n| **2: Character Device Driver** | 2.1 Load module (fresh) | `sudo insmod mychardev.ko` | No errors; check `dmesg` for major number allocation | Dynamic device number allocation via `alloc_chrdev_region` succeeds |\n| | 2.2 Verify device node creation | `ls -l /dev/mychardev` | Shows `crw------- 1 root root major,minor date /dev/mychardev` | `class_create` and `device_create` automatically created `/dev` node |\n| | 2.3 Write data to device | `echo -n \"test data\" \\| sudo tee /dev/mychardev` | Prints \"test data\" to terminal (from `tee`) | `mydevice_write` handler successfully copies data from userspace to kernel buffer |\n| | 2.4 Read data back | `sudo cat /dev/mychardev` | Outputs \"test data\" exactly as written | `mydevice_read` handler successfully copies data from kernel buffer to userspace |\n| | 2.5 Verify partial read | `echo -n \"1234567890\" \\| sudo tee /dev/mychardev && sudo head -c 5 /dev/mychardev` | Outputs first 5 bytes: \"12345\" | `read` correctly handles partial transfers and updates file position |\n| | 2.6 Verify EOF behavior | Run `sudo cat /dev/mychardev` twice | First: outputs remaining data (\"67890\"); Second: outputs nothing (returns 0) | `read` returns 0 at end-of-file, preventing infinite loops |\n| | 2.7 Check buffer persistence | Write, then read, then write again, then read all | Second read returns only the second write's data | Buffer is cleared after complete read (simple linear buffer behavior) |\n| **3: ioctl and proc Interface** | 3.1 Load module | `sudo insmod mychardev.ko` | As before | All previous functionality remains intact |\n| | 3.2 Compile test program | `gcc -o test_ioctl test_ioctl.c` | No errors | Shared header file (`mydevice.h`) is correct and accessible |\n| | 3.3 Test `MYDEVICE_IOCTL_GET_SIZE` | `sudo ./test_ioctl get_size` | Prints: `Buffer size: 1024 bytes` | `ioctl` handler correctly returns current buffer size |\n| | 3.4 Test `MYDEVICE_IOCTL_GET_MAX_CAPACITY` | `sudo ./test_ioctl get_max` | Prints: `Max capacity: 1048576 bytes` | `ioctl` returns the `MAX_BUFFER_SIZE` constant |\n| | 3.5 Test `MYDEVICE_IOCTL_CLEAR` | Write data, run `sudo ./test_ioctl clear`, then read | Read returns nothing (buffer empty) | `ioctl` clear command resets buffer and `data_size` to 0 |\n| | 3.6 Test `MYDEVICE_IOCTL_RESIZE` | `sudo ./test_ioctl resize 2048` then `get_size` | New size: `2048 bytes` | Buffer resizes successfully, preserving existing data up to new size |\n| | 3.7 Verify `/proc` entry | `cat /proc/mychardev_stats` | Shows multi-line stats: `Device: mychardev`, `Buffer size: 2048`, `Data stored: 0`, etc. | `proc_create` and `mydevice_proc_show` correctly display device state |\n| | 3.8 Test invalid ioctl | `sudo ./test_ioctl invalid` | Program prints error: `ioctl: Invalid argument` (errno 22) | Driver returns `-EINVAL` for unknown commands |\n| **4: Concurrent Access and Locking** | 4.1 Load module | `sudo insmod mychardev.ko` | As before | All previous functionality remains intact |\n| | 4.2 Test blocking read (empty buffer) | In terminal A: `sudo cat /dev/mychardev` (hangs) | Process blocks (does not return) | `wait_event_interruptible` puts process to sleep when buffer empty |\n| | 4.3 Wake blocked reader | In terminal B: `echo -n \"wake up\" \\| sudo tee /dev/mychardev` | Terminal A immediately outputs \"wake up\" and exits | `wake_up_interruptible` correctly wakes sleeping reader |\n| | 4.4 Test non-blocking read | `sudo cat /dev/mychardev & sleep 1; echo -n \"data\" \\| sudo tee /dev/mychardev; wait` | Output: \"data\" (background cat completes) | Blocking behavior works as expected with process management |\n| | 4.5 Test `poll`/`select` readiness | Write a small test program that uses `select()` on device | Program reports device as writable immediately, readable only after write | `mydevice_poll` returns correct mask bits (`POLLOUT` always, `POLLIN` when data available) |\n| | 4.6 Simple concurrency test | Two parallel writes: `(echo -n \"AAA\" \\| sudo tee /dev/mychardev & echo -n \"BBB\" \\| sudo tee /dev/mychardev & wait)` then read | Read output is either \"AAA\" or \"BBB\" (not mixed) | Mutex protects buffer from concurrent writes corrupting data |\n| | 4.7 Verify mutex prevents race | Use the concurrency stress test script (below) | No kernel panics, no corrupted output (all reads get consistent data) | Locking correctly serializes access to shared buffer |\n\n> **Key Insight:** Kernel testing is iterative and observational. You're not writing unit tests that run in isolation but rather **observing the system's behavior** through its external interfaces (`/dev`, `/proc`, kernel log). Success is defined by the driver behaving predictably according to Unix file semantics and Linux driver conventions.\n\n### Concurrency Stress Test\n\nConcurrency bugs are among the most insidious in kernel programming because they may only surface under specific timing conditions that are difficult to reproduce. Our stress test simulates **multiple readers and writers accessing the device simultaneously** to expose race conditions, deadlocks, and data corruption. Think of this as **stress-testing a bridge with synchronized heavy traffic**: we want to ensure the structure (mutexes) holds, traffic flows (no deadlocks), and no vehicles collide (data remains consistent).\n\n**Test Design Principles:**\n1. **Reproducibility:** Use fixed data patterns to easily detect corruption.\n2. **Duration:** Run for sufficient time (10-30 seconds) to increase probability of race conditions.\n3. **Monitoring:** Watch kernel log for error messages and system for lockups.\n4. **Cleanup:** Ensure all background processes are terminated after test.\n\n**Stress Test Script (`stress_test.sh`):**\nThis shell script launches multiple writer and reader processes that operate on the device concurrently. Writers write distinct patterns, readers verify they receive uncorrupted data.\n\n```bash\n#!/bin/bash\n# stress_test.sh - Concurrent access stress test for mychardev driver\nset -e\n\nDEVICE=\"/dev/mychardev\"\nTEST_DURATION=10  # seconds\nNUM_WRITERS=3\nNUM_READERS=3\n\necho \"=== Starting concurrency stress test for $DEVICE ===\"\necho \"Test duration: $TEST_DURATION seconds\"\necho \"Writers: $NUM_WRITERS, Readers: $NUM_READERS\"\n\n# Clear buffer initially\nsudo ./test_ioctl clear > /dev/null 2>&1 || true\n\n# Start writer processes\necho \"Starting writer processes...\"\nfor i in $(seq 1 $NUM_WRITERS); do\n    (\n        writer_id=$i\n        end_time=$(( $(date +%s) + $TEST_DURATION ))\n        while [ $(date +%s) -lt $end_time ]; do\n            # Each writer writes its unique pattern repeatedly\n            pattern=\"Writer${writer_id}_$(date +%s%N)\"\n            echo -n \"$pattern\" | sudo tee $DEVICE > /dev/null 2>&1\n            # Small random delay to desynchronize\n            sleep 0.$(( RANDOM % 3 ))\n        done\n    ) &\n    WRITER_PIDS=\"$WRITER_PIDS $!\"\ndone\n\n# Start reader processes  \necho \"Starting reader processes...\"\nfor i in $(seq 1 $NUM_READERS); do\n    (\n        reader_id=$i\n        end_time=$(( $(date +%s) + $TEST_DURATION ))\n        while [ $(date +%s) -lt $end_time ]; do\n            # Read whatever is available (may block)\n            data=$(sudo cat $DEVICE 2>/dev/null || true)\n            if [ -n \"$data\" ]; then\n                # Basic validation: data should not be empty and should contain writer pattern\n                # In a full test, you would verify structure, but we just check non-empty\n                echo \"Reader$reader_id read ${#data} bytes\"\n                # Optional: check pattern matches expected format\n                # if [[ ! \"$data\" =~ ^Writer[0-9]+_[0-9]+$ ]]; then\n                #     echo \"ERROR: Corrupted data: $data\" >&2\n                # fi\n            fi\n        done\n    ) &\n    READER_PIDS=\"$READER_PIDS $!\"\ndone\n\n# Let test run for duration\necho \"Test running for $TEST_DURATION seconds...\"\nsleep $TEST_DURATION\n\n# Cleanup: kill all background processes\necho \"Cleaning up background processes...\"\nkill $WRITER_PIDS $READER_PIDS 2>/dev/null || true\nwait 2>/dev/null\n\n# Final buffer state\necho \"=== Test complete ===\"\necho \"Final buffer contents:\"\nsudo cat $DEVICE 2>/dev/null | od -c | head -20\necho \"Check dmesg for errors (should be none):\"\ndmesg | tail -10 | grep -E \"mychardev|BUG|WARNING|Oops\"\n```\n\n**Expected Outcome of Stress Test:**\n1. **No kernel crashes or panics** - The system remains stable throughout.\n2. **No error messages in `dmesg`** related to our driver (except normal loading/unloading).\n3. **All processes complete** or are cleanly terminated after test duration.\n4. **Readers report consistent data** - No \"corrupted data\" messages if validation is enabled.\n5. **Final buffer contains valid data** - The `od` output shows ASCII characters from writer patterns, not garbage.\n\n**Interpreting Test Results:**\n- **System hangs completely:** Likely a deadlock in mutex or wait queue usage (e.g., locking mutex twice in same process).\n- **`dmesg` shows \"BUG: scheduling while atomic\":** Sleeping (like `mutex_lock`) in atomic context incorrectly.\n- **Data corruption (mixed patterns):** Insufficient protection of buffer during concurrent writes/reads.\n- **Readers starve (never read):** `wake_up_interruptible` not called after writes, or condition checking incorrect.\n- **\"Invalid opcode\" or kernel oops:** Memory corruption, likely from buffer overflows or use-after-free.\n\n**Enhanced Test with Ioctl Operations:**\nFor more comprehensive testing, extend the script to include concurrent `ioctl` operations (resize, clear) mixed with reads and writes. This tests the interaction between control operations and data operations. Add a fourth set of processes that randomly issue `ioctl` commands while reads and writes are happening.\n\n> **Design Insight:** Concurrency testing is probabilistic—passing the stress test once doesn't guarantee absence of bugs, but **repeated failures indicate definite problems**. Run the test multiple times, especially on SMP (multi-core) systems where race conditions are more likely to surface.\n\n### Implementation Guidance\n\nWhile the main testing strategy uses external observation, you may want to create structured test programs for more systematic verification. This guidance provides a **test program template** for Milestone 3's `ioctl` interface and tips for implementing the stress test.\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Userspace Testing | Custom C programs using standard file I/O and `ioctl` | Python test scripts using `ctypes` or `pyioctl` for rapid prototyping |\n| Concurrency Testing | Bash script with background processes (`&`, `wait`) | Dedicated multithreaded C program with precise timing control |\n| Result Validation | Manual inspection of output and `dmesg` | Automated parsing of kernel log with expected pattern matching |\n| Long-running Tests | Loop shell commands with `sleep` | Systemtap or BPF tracing to monitor internal driver state |\n\n#### B. Recommended File/Module Structure for Testing\n\n```\nproject-root/\n  Makefile                    # Builds kernel module and test programs\n  mychardev.c                 # Main driver implementation\n  mychardev.h                 # Shared header with ioctl definitions\n  test_ioctl.c                # Userspace test program for milestone 3\n  stress_test.sh              # Concurrency stress test script (bash)\n  test_poll.c                 # Test program for poll/select functionality\n  README.md                   # Includes testing instructions\n```\n\n#### C. Infrastructure Starter Code: Test Ioctl Program\n\nHere is a **complete, ready-to-use** test program for verifying the `ioctl` interface (Milestone 3). This program exercises all defined `ioctl` commands with proper error handling.\n\n```c\n// test_ioctl.c - Userspace test program for mychardev ioctl interface\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <errno.h>\n#include \"mychardev.h\"  // Shared header with ioctl definitions\n\nint main(int argc, char *argv[]) {\n    int fd;\n    size_t size;\n    int ret;\n    \n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <command> [args]\\n\", argv[0]);\n        fprintf(stderr, \"Commands:\\n\");\n        fprintf(stderr, \"  get_size           - get current buffer size\\n\");\n        fprintf(stderr, \"  get_max            - get maximum buffer capacity\\n\");\n        fprintf(stderr, \"  clear              - clear buffer contents\\n\");\n        fprintf(stderr, \"  resize <new_size>  - resize buffer (bytes)\\n\");\n        return 1;\n    }\n    \n    // Open the device\n    fd = open(\"/dev/mychardev\", O_RDWR);\n    if (fd < 0) {\n        perror(\"Failed to open /dev/mychardev\");\n        return 1;\n    }\n    \n    // Dispatch command\n    if (strcmp(argv[1], \"get_size\") == 0) {\n        ret = ioctl(fd, MYDEVICE_IOCTL_GET_SIZE, &size);\n        if (ret < 0) {\n            perror(\"ioctl GET_SIZE failed\");\n            close(fd);\n            return 1;\n        }\n        printf(\"Buffer size: %zu bytes\\n\", size);\n    }\n    else if (strcmp(argv[1], \"get_max\") == 0) {\n        ret = ioctl(fd, MYDEVICE_IOCTL_GET_MAX_CAPACITY, &size);\n        if (ret < 0) {\n            perror(\"ioctl GET_MAX_CAPACITY failed\");\n            close(fd);\n            return 1;\n        }\n        printf(\"Max capacity: %zu bytes\\n\", size);\n    }\n    else if (strcmp(argv[1], \"clear\") == 0) {\n        ret = ioctl(fd, MYDEVICE_IOCTL_CLEAR);\n        if (ret < 0) {\n            perror(\"ioctl CLEAR failed\");\n            close(fd);\n            return 1;\n        }\n        printf(\"Buffer cleared\\n\");\n    }\n    else if (strcmp(argv[1], \"resize\") == 0) {\n        if (argc < 3) {\n            fprintf(stderr, \"Usage: %s resize <new_size_in_bytes>\\n\", argv[0]);\n            close(fd);\n            return 1;\n        }\n        size = atoi(argv[2]);\n        ret = ioctl(fd, MYDEVICE_IOCTL_RESIZE, &size);\n        if (ret < 0) {\n            perror(\"ioctl RESIZE failed\");\n            fprintf(stderr, \"Error code: %d\\n\", errno);\n            close(fd);\n            return 1;\n        }\n        printf(\"Buffer resized to %zu bytes\\n\", size);\n    }\n    else {\n        fprintf(stderr, \"Unknown command: %s\\n\", argv[1]);\n        close(fd);\n        return 1;\n    }\n    \n    close(fd);\n    return 0;\n}\n```\n\n#### D. Core Logic Skeleton: Poll Test Program\n\nFor testing the `poll`/`select` functionality (Milestone 4), here's a skeleton test program you can complete:\n\n```c\n// test_poll.c - Test poll/select on the character device\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <poll.h>\n\nint main() {\n    int fd;\n    struct pollfd pfd;\n    int ret;\n    \n    // TODO 1: Open device /dev/mychardev with O_RDWR | O_NONBLOCK\n    // (non-blocking mode allows poll to return immediately)\n    \n    // TODO 2: Initialize pollfd structure\n    // - Set fd to the device file descriptor\n    // - Set events to POLLIN | POLLOUT (interested in both read and write readiness)\n    \n    printf(\"Polling device for events...\\n\");\n    \n    // TODO 3: Call poll() with timeout of 3000 milliseconds (3 seconds)\n    // - Handle errors (return -1)\n    // - Handle timeout (return 0)\n    \n    // TODO 4: Check revents field after poll returns\n    // - If POLLIN is set: print \"Device is readable\"\n    // - If POLLOUT is set: print \"Device is writable\"\n    // - If POLLERR is set: print \"Error condition on device\"\n    // - If POLLHUP is set: print \"Hang up occurred\"\n    \n    // TODO 5: Demonstrate blocking behavior\n    // - First poll on empty buffer (should NOT have POLLIN)\n    // - Write some data to device\n    // - Poll again (should NOW have POLLIN)\n    \n    // TODO 6: Close device and exit\n    \n    return 0;\n}\n```\n\n#### E. C-Specific Testing Hints\n\n1. **Compile test programs:** Use `gcc -o test_ioctl test_ioctl.c` with the kernel header in include path.\n2. **Run as root:** All device access requires superuser privileges; use `sudo` or run test as root.\n3. **Check error codes:** Kernel functions return negative error numbers; in userspace, `errno` is set.\n4. **Clean up between tests:** Unload and reload module (`rmmod; insmod`) to get fresh state.\n5. **Use `strace` for debugging:** `strace -e trace=ioctl,read,write ./test_ioctl get_size` shows system calls.\n\n#### F. Milestone Checkpoint Verification\n\nAfter implementing each milestone, run the corresponding verification steps from the table above. For quick validation, use this **summary checklist**:\n\n- **Milestone 1:** Module loads/unloads cleanly, appears in `lsmod`, shows info with `modinfo`.\n- **Milestone 2:** Can write to `/dev/mychardev` and read back same data; device node has correct permissions.\n- **Milestone 3:** `test_ioctl` program works for all commands; `/proc/mychardev_stats` shows current state.\n- **Milestone 4:** Blocking read works (hangs until data written); stress test runs without crashes.\n\n#### G. Debugging Tips for Testing\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Module fails to load with \"Invalid module format\" | Kernel version mismatch between headers and running kernel | Run `uname -r` and compare with `Makefile` `KERNELDIR` | Install correct kernel headers or adjust `Makefile` |\n| Write succeeds but read returns nothing | Buffer not preserved between operations or `data_size` not updated | Add `printk` in write handler to show buffer contents and size | Ensure `data_size` is incremented on write and not reset prematurely |\n| System hangs on `cat /dev/mychardev` (empty buffer) | `wait_event_interruptible` condition never becomes true or wakeup not called | Check `printk` in write to confirm `wake_up_interruptible` is called | Verify condition uses correct variables; call wakeup after changing condition |\n| `ioctl` returns `-1` with `errno=22` (EINVAL) | Incorrect command number or size mismatch in `_IOR`/`_IOW` macros | Compare command numbers in kernel and userspace headers | Ensure identical macro definitions; check third argument (size) matches data type |\n| Concurrent test shows mixed data from different writers | Missing or incorrect mutex protection around buffer operations | Add `printk` showing thread/process ID during buffer access | Protect ALL buffer accesses (read/write/resize) with same mutex |\n| `poll` always returns `POLLOUT` but never `POLLIN` | `poll` handler not calling `poll_wait` on read wait queue or incorrect condition | Check `mydevice_poll` calls `poll_wait(&dev->waitq, ...)` | Add wait queue for read readiness; return `POLLIN` when `data_size > 0` |\n| Memory leak shown in `dmesg` on unload | Resources not freed in `mydevice_exit` (class, device, buffer, cdev) | Review cleanup function against initialization in reverse order | Implement complete cleanup: `device_destroy`, `class_destroy`, `cdev_del`, `unregister_chrdev_region`, `buffer_cleanup` |\n| \"Kernel tainted\" warning in `dmesg` | Missing or non-GPL module license | Check `MODULE_LICENSE(\"GPL\")` is present | Add proper license declaration at end of module |\n\nRemember: **Testing kernel code requires patience and careful observation.** Always check `dmesg` after each test, reload the module frequently to get a clean state, and consider using a virtual machine for development to avoid crashing your main system.\n\n\n## Debugging Guide\n\n> **Milestone(s):** Milestone 1, Milestone 2, Milestone 3, Milestone 4 (debugging is essential throughout development)\n\nDeveloping kernel modules presents unique debugging challenges compared to userspace programming. You cannot use a standard debugger like GDB on the running kernel without specialized setups, and mistakes can crash the entire system. This guide provides a practical, symptom-based approach to diagnosing common problems in your character device driver using the tools available to kernel developers: **kernel logging (`printk` and `dmesg`)**, inspection of kernel interfaces (`/proc`, `/sys`), and userspace tracing (`strace`). The goal is to build a systematic methodology for isolating bugs at the kernel-user boundary and within concurrent kernel code.\n\n### Symptom → Cause → Diagnosis → Fix Table\n\nThe following table catalogs frequent issues encountered during the development of each milestone. Use it as a first response when your driver behaves unexpectedly.\n\n| Symptom | Likely Cause | Diagnosis Steps | Fix |\n| :--- | :--- | :--- | :--- |\n| **Module fails to load** with `insmod: ERROR: could not insert module: Invalid parameters` or a kernel `Oops`/panic immediately on load. | 1. Missing or incorrect `MODULE_LICENSE`. <br> 2. Kernel symbol version mismatch (building against wrong headers). <br> 3. Bug in `mydevice_init()` causing a NULL dereference or resource allocation failure. | 1. Check `dmesg` for `module license 'unspecified' taints kernel`. <br> 2. Run `modinfo mymodule.ko` to verify license and dependencies. <br> 3. Look for specific error messages from `printk` in your init function. <br> 4. Verify kernel version with `uname -r` matches the headers used for building (`/lib/modules/$(uname -r)/build`). | 1. Add `MODULE_LICENSE(\"GPL\")` (or a compatible license). <br> 2. Ensure your Makefile uses `$(shell uname -r)` for the kernel build path. <br> 3. Add defensive `printk(KERN_ERR ...)` statements at each stage of `mydevice_init()` and implement proper rollback on error (undoing allocations in reverse order). |\n| **Write succeeds (returns byte count) but a subsequent read returns 0 (EOF) or empty data.** | 1. `mydevice_write` does not correctly update the buffer's `data_size` or write position. <br> 2. The `read` handler's logic for `copy_to_user` fails silently (e.g., invalid userspace pointer). <br> 3. Concurrent access corrupting buffer metadata (Milestone 4). | 1. Add `printk` in `mydevice_write` to log the received `count` and the new `data_size`. <br> 2. Check the return value of `copy_to_user` in `mydevice_read`; if non-zero, it indicates bytes NOT copied. <br> 3. Inspect `/proc/mychardev` stats (if implemented) to see the reported `data_size`. <br> 4. Test with a single process, eliminating concurrency. | 1. Ensure `mydevice_write` correctly adds to `data_size` (up to `buffer_size`) and that `mydevice_read` uses a separate `read_position` or correctly reduces `data_size` after reading. <br> 2. Always check and propagate the error return from `copy_to_user` (return `-EFAULT`). <br> 3. Verify mutex locks in `read`/`write` cover all metadata updates. |\n| **System hangs indefinitely when a process calls `read()` on the empty device.** | 1. Blocking `read` implemented with `wait_event_interruptible` but the wakeup condition (`data_size > 0`) is never satisfied, or the wakeup call (`wake_up_interruptible`) is missing. <br> 2. Deadlock: the mutex is held when calling `wait_event_interruptible`. | 1. Check `dmesg` for any related messages. Send a SIGINT (Ctrl+C) to the reading process; if it exits, the wait was interruptible. <br> 2. Add `printk` in the write handler to confirm `wake_up_interruptible` is called. <br> 3. Review lock ordering: `wait_event_interruptible` must be called *after* releasing the mutex (the macro handles this internally). | 1. Ensure `wake_up_interruptible(&dev->waitq)` is called in `mydevice_write` after new data is placed in the buffer. <br> 2. Use `wait_event_interruptible(dev->waitq, (dev->data_size > 0) );` correctly. The condition is re-evaluated after wakeup; ensure no other path can leave `data_size` at 0 incorrectly. <br> 3. Do not call `mutex_lock` before `wait_event_interruptible`; the macro releases the lock while sleeping and re-acquires it upon waking. |\n| **`ioctl` returns `-1` with userspace `errno=22` (`EINVAL`).** | 1. Incorrect `ioctl` command number definition mismatch between kernel and userspace header. <br> 2. Wrong size specified in the `_IOR`/`_IOW` macro versus the actual data type passed. <br> 3. The `ioctl` handler returns `-EINVAL` for an unrecognized command or invalid argument. | 1. Compare the command numbers in the shared header file used by both kernel module and userspace test program. Use `printf(\"%x\\n\", cmd)` in userspace and `printk` in the kernel to see the actual value. <br> 2. Verify the `size` argument in the macro matches the size of the data type (e.g., `sizeof(size_t)`). <br> 3. Check the `switch(cmd)` in `mydevice_ioctl` for a default case that returns `-EINVAL`. | 1. Ensure the `MYDEVICE_IOC_MAGIC` character and numeric command values are identical in both header files. <br> 2. Use `_IOW(MYDEVICE_IOC_MAGIC, 4, size_t)` for a command that writes a `size_t` from userspace. <br> 3. In the kernel handler, validate `arg` (e.g., ensure a requested buffer size is within `MAX_BUFFER_SIZE`) before using it. |\n| **`cat /proc/mychardev` shows corrupted data, partial output, or causes a kernel warning.** | 1. The `/proc` read callback (`mydevice_proc_show`) does not handle the offset mechanism correctly for multiple `read` system calls. <br> 2. Using a simple `proc_ops` with `proc_read` but not managing the single-buffer approach properly. <br> 3. Accessing device data without proper locking (concurrent modification while generating proc output). | 1. Observe if multiple `cat` commands produce different outputs. <br> 2. Check `dmesg` for `WARNING: at fs/proc/generic.c:...` related to procfs. <br> 3. Test with concurrent `write` operations while reading `/proc`. | 1. For simplicity, use `single_open` and `single_release` with a `show` function that generates the entire output at once. This avoids offset management. <br> 2. In the `show` function, acquire the device mutex (`mutex_lock(&dev->lock)`) before reading `buffer_size`, `data_size`, etc., and release it before returning. <br> 3. Ensure `mydevice_proc_show` returns 0 on success (not the number of bytes printed). |\n| **Concurrent reads and writers cause data corruption (repeated/missing bytes) or a kernel crash.** | 1. Missing or incomplete mutual exclusion around the shared buffer and its metadata (`data_size`). <br> 2. Race condition between checking a condition (e.g., `buffer full`) and acting on it. <br> 3. Incorrect use of a spinlock where a mutex is required (or vice versa). | 1. Reproduce with a stress test script (multiple `dd` commands). <br> 2. Add extensive `printk` logging within critical sections (be aware this changes timing). <br> 3. Look for `\"BUG: scheduling while atomic\"` or lockdep warnings in `dmesg`. | 1. Ensure every access to `dev->buffer`, `dev->data_size`, and `dev->read_position` (if used) is protected by `mutex_lock(&dev->lock)`. <br> 2. Re-check conditions after acquiring the lock. For example, after acquiring the lock in `write`, verify `(dev->buffer_size - dev->data_size) >= count` before proceeding. <br> 3. Use `mutex` (not spinlock) for all operations as `copy_to/from_user` and `wait_event` can sleep. |\n| **`poll` or `select` on the device file descriptor always returns \"readable\" even when the buffer is empty.** | 1. The `poll` handler (`mydevice_poll`) returns a mask with `POLLIN` unconditionally, without checking the actual device state. <br> 2. Forgetting to call `poll_wait` to register the wait queue with the poll table. | 1. Write a small userspace test program that uses `poll` and prints the returned `revents`. <br> 2. Check the `mydevice_poll` implementation: it should check `if (dev->data_size > 0)` before setting `POLLIN`. | 1. Implement `mydevice_poll` as: call `poll_wait(file, &dev->waitq, wait);`, then set `mask = 0; if (dev->data_size > 0) mask |= POLLIN; if (dev->data_size < dev->buffer_size) mask |= POLLOUT; return mask;`. <br> 2. Ensure `poll_wait` is called for the same wait queue (`dev->waitq`) that `write` uses to wake up readers. |\n\n### Kernel-Specific Debugging Techniques\n\nDebugging in kernel space requires a different toolbox. You cannot casually attach a debugger or rely on userspace core dumps. Instead, you become a detective interpreting the kernel's own logging and introspection interfaces.\n\n#### Mental Model: The Kernel's Black Box Flight Recorder\nImagine the running kernel as an airplane in flight. You, the developer on the ground, cannot step inside while it's flying. Instead, you rely on its **flight data recorder** (`printk` messages streamed to `dmesg`) and periodic **maintenance telemetry** (the `/proc` and `/sys` filesystems). When a problem occurs, you \"recover the black box\" (`dmesg`) and analyze the recorded events leading up to the failure. This passive observation, combined with targeted \"probe\" messages you insert (`printk`), forms the primary debugging methodology.\n\n#### 1. Mastery of `printk` and `dmesg`\nThe `printk` function is your most vital tool. It writes messages to a circular kernel log buffer, which you can read using the `dmesg` command.\n\n> **Key Insight:** `printk` messages have **log levels** (`KERN_EMERG`, `KERN_ALERT`, `KERN_CRIT`, `KERN_ERR`, `KERN_WARNING`, `KERN_NOTICE`, `KERN_INFO`, `KERN_DEBUG`). The console's current log level determines which messages appear on the console immediately (e.g., during a panic). Always specify a level: `printk(KERN_INFO \"Device opened\\n\");`. The special `pr_info`, `pr_err`, etc., macros can be used as shorthand.\n\n| Technique | Command/Action | Purpose & Interpretation |\n| :--- | :--- | :--- |\n| **View the entire kernel log** | `sudo dmesg` or `sudo dmesg | tail -50` | See all recorded kernel messages since boot. Useful for finding crash reports and your debug output. |\n| **Follow logs in real-time** | `sudo dmesg -w` or `sudo tail -f /var/log/kern.log` (on some distros) | Watch messages appear as they are generated, excellent for observing the sequence of operations. |\n| **Clear the log buffer** | `sudo dmesg -C` | Start with a clean slate before reproducing an issue. Caution: this discards all previous messages. |\n| **Add strategic debug prints** | In code: `printk(KERN_DEBUG \"%s: count=%zu, data_size=%zu\\n\", __func__, count, dev->data_size);` | Trace the flow and values inside your functions. Use `__func__` to automatically include the function name. |\n| **Control console log level** | `echo 8 > /proc/sys/kernel/printk` (sets console log level to `KERN_DEBUG`, showing all messages) | Force important debug messages to appear on the console immediately, not just in the buffer. |\n\n**Common `printk` Pitfalls:**\n- **Forgetting the log level:** `printk(\"hello\")` defaults to `KERN_DEFAULT`, which may not appear in `dmesg` depending on configuration. Always use an explicit level.\n- **Excessive logging:** Flooding the log buffer can overwrite critical messages and slow down the system. Use `KERN_DEBUG` for high-volume traces and conditionally compile them out later.\n- **Format specifier mismatches:** Using `%d` for a `size_t` (which is `%zu`) or `%p` for a structure can cause garbled output or crashes. For kernel pointers, use `%pK` for security or `%p` for raw addresses.\n\n#### 2. Inspecting Kernel Subsystems via `/proc` and `/sys`\nThe kernel exposes a wealth of information through virtual filesystems. These provide a live view of the system's state without needing custom debug code.\n\n| Interface | Path | Information Relevant to Our Driver |\n| :--- | :--- | :--- |\n| **Loaded Modules** | `/proc/modules` | Lists all loaded kernel modules, their memory usage, and reference counts. Verify your module is present and not accumulating references (which would prevent `rmmod`). |\n| **Registered Character Devices** | `/proc/devices` | Shows the major numbers and names of registered character (and block) devices. Look for your device name (`mychardev`) and its dynamically assigned major number. |\n| **Device Nodes** | `ls -l /dev/` | Check if your device node (e.g., `/dev/mychardev`) exists and has the correct major/minor number (matching `/proc/devices`). Verify permissions. |\n| **Kernel Taint Status** | `/proc/sys/kernel/tainted` | A non-zero value indicates the kernel is \"tainted\" (e.g., by a non-GPL module, an out-of-tree module, or a hardware error). This affects the supportability of kernel bug reports. |\n\n**Understanding Kernel Taint:**\n> A tainted kernel is one that has encountered a condition that could make it difficult to support (e.g., loading a proprietary module). The taint value is a bitmask. You can decode it using `scripts/decodecode` in the kernel source or by looking at the second field in `/proc/modules` (marked `P` for proprietary, `O` for out-of-tree, etc.). If your module lacks `MODULE_LICENSE(\"GPL\")`, it will taint the kernel, which might restrict access to certain GPL-only symbols and cause your module to fail to load if it depends on them.\n\n#### 3. Using `strace` to Trace Userspace Interactions\nWhile `strace` is a userspace tool, it's invaluable for understanding how your userspace test program interacts with your driver through system calls. It shows you the exact `open`, `read`, `write`, `ioctl`, and `close` calls made, along with their arguments and return values.\n\n| Command | Purpose |\n| :--- | :--- |\n| `strace ./userspace_test 2>&1 | less` | Trace all system calls made by the test program. Look for the sequence of operations on your device file descriptor. |\n| `strace -e trace=ioctl ./userspace_test` | Filter to show only `ioctl` calls. You can see the `cmd` and `arg` values passed, helping verify they match kernel expectations. |\n| `strace -o trace.log ./userspace_test` | Save the full trace to a file for detailed analysis. |\n\n**Interpreting `strace` output for driver bugs:**\n- If a system call returns `-1`, `strace` shows the `errno` (e.g., `EINVAL (22)`). This directly tells you the error code returned by your driver's handler.\n- You can verify that the arguments (like buffer addresses and counts) match what your driver expects.\n- If a `read` or `write` call blocks indefinitely, `strace` will hang, confirming the issue is in the kernel's blocking logic.\n\n#### 4. Handling Kernel Oops and Panics\nAn \"Oops\" is a kernel error that allows the system to continue running, often with a corrupted state. A \"panic\" is a fatal error that halts the system. Both produce a detailed message in `dmesg`.\n\n**When you encounter an Oops:**\n1. **Capture the entire output** from `dmesg`. The most important part is the **call trace** (stack trace) and the **instruction pointer** (`RIP` or `EIP`).\n2. **Look for the offending module.** The trace will show function names. If your module functions are listed (e.g., `mydevice_write+0x50/0x120`), the bug is in your code.\n3. **Decode the addresses.** You can use the `addr2line` tool from your kernel build to map the offset (`0x50`) within the function to a source line: `addr2line -e mymodule.ko 0x50`. This requires the module to be built with debug symbols (`CONFIG_DEBUG_INFO` in the kernel config and `-g` in your Makefile's `CFLAGS`).\n\n> **Design Insight:** Always build your module with debug symbols (`EXTRA_CFLAGS += -g`) during development. This doesn't affect performance in the loadable module but dramatically improves the usefulness of Oops messages and allows use of tools like `kgdb` if you set up kernel debugging.\n\n### Implementation Guidance\n\nThis section provides concrete code and commands to implement an effective debugging strategy for your driver.\n\n#### A. Technology Recommendations Table\n| Component | Simple Option | Advanced Option |\n| :--- | :--- | :--- |\n| **Kernel Logging** | `printk` with `KERN_DEBUG` level and `dmesg` viewing. | Dynamic debug (`dynamic_debug.ko`) to enable/verbose debug prints at runtime via `/sys/kernel/debug/dynamic_debug/control`. |\n| **Tracing System Calls** | `strace` for userspace program tracing. | `perf trace` for lower-overhead system-wide tracing, or kernel `ftrace` for tracing within the kernel. |\n| **Memory Error Detection** | Careful code review and `printk`. | Use `CONFIG_DEBUG_KMEMLEAK` in the kernel to detect memory leaks, or `CONFIG_KASAN` (KernelAddressSANitizer) for out-of-bounds and use-after-free detection (requires a custom kernel build). |\n| **Locking Validation** | Manual review of mutex coverage. | Enable `CONFIG_DEBUG_MUTEXES` and `CONFIG_PROVE_LOCKING` in the kernel to get runtime warnings for lock misuse and potential deadlocks. |\n\n#### B. Recommended File/Module Structure for Debugging\nPlace debug utilities and shared definitions in appropriate files to keep your main driver code clean.\n```\nproject/\n  mychardev.c          # Main driver source\n  mychardev.h          # Shared ioctl definitions (used by kernel and userspace)\n  Makefile             # Kbuild Makefile\n  test/                # Userspace test programs\n    test_basic.c       # Simple read/write test\n    test_ioctl.c       # ioctl command test\n    test_concurrent.c  # Concurrency stress test\n```\n\n#### C. Infrastructure Starter Code: A Simple Debug Macro\nAdd this to the top of your `mychardev.c` (after includes) to easily toggle debug prints. This is more flexible than commenting out `printk` statements.\n```c\n// mychardev.c - Add near the top after includes\n#ifdef DEBUG\n#define mydev_dbg(fmt, ...) \\\n    printk(KERN_DEBUG DEVICE_NAME \": %s: \" fmt, __func__, ##__VA_ARGS__)\n#else\n#define mydev_dbg(fmt, ...) do {} while (0)\n#endif\n\n#define mydev_info(fmt, ...) \\\n    printk(KERN_INFO DEVICE_NAME \": \" fmt, ##__VA_ARGS__)\n#define mydev_err(fmt, ...) \\\n    printk(KERN_ERR DEVICE_NAME \": ERROR: \" fmt, ##__VA_ARGS__)\n```\nIn your Makefile, you can add `-DDEBUG` to `EXTRA_CFLAGS` to enable the debug prints:\n```makefile\n# To enable debug, add -DDEBUG\nEXTRA_CFLAGS += -DDEBUG\n```\n\n#### D. Core Logic Skeleton Code: Adding Debug to Critical Functions\nHere’s how to instrument the `mydevice_write` function with the debug macro. Apply similar patterns to other handlers.\n```c\nstatic ssize_t mydevice_write(struct file *filp, const char __user *buf,\n                              size_t count, loff_t *f_pos)\n{\n    struct mydevice_data *dev = filp->private_data;\n    ssize_t retval = 0;\n    size_t space_available;\n\n    mydev_dbg(\"entry: count=%zu, data_size=%zu\\n\", count, dev->data_size);\n\n    if (mutex_lock_interruptible(&dev->lock))\n        return -ERESTARTSYS;\n\n    space_available = dev->buffer_size - dev->data_size;\n    mydev_dbg(\"space_available=%zu\\n\", space_available);\n\n    if (space_available == 0) {\n        mydev_dbg(\"buffer full, returning -ENOSPC\\n\");\n        retval = -ENOSPC;\n        goto out_unlock;\n    }\n\n    if (count > space_available)\n        count = space_available;\n\n    if (copy_from_user(dev->buffer + dev->data_size, buf, count)) {\n        mydev_err(\"copy_from_user failed\\n\");\n        retval = -EFAULT;\n        goto out_unlock;\n    }\n\n    dev->data_size += count;\n    mydev_dbg(\"new data_size=%zu\\n\", dev->data_size);\n    retval = count;\n\n    // Wake up any waiting readers\n    wake_up_interruptible(&dev->waitq);\n    mydev_dbg(\"woke up waitq\\n\");\n\nout_unlock:\n    mutex_unlock(&dev->lock);\n    mydev_dbg(\"exit: returning %zd\\n\", retval);\n    return retval;\n}\n```\n\n#### E. Language-Specific Hints: C and Kernel\n- **Kernel `printk` Format Specifiers:** Use `%zu` for `size_t`, `%zd` for `ssize_t`, `%p` for pointers, `%llu` for `unsigned long long`. For `dev_t` (major/minor), use `MAJOR(dev_num)` and `MINOR(dev_num)`.\n- **Compiler Attributes:** Use `__attribute__((unused))` on function parameters that you don't use (e.g., in `open` or `release`) to silence compiler warnings.\n- **Include Debug Symbols:** In your Makefile, add `-g` to `CFLAGS` to embed debug information. This allows `addr2line` to work after an Oops.\n    ```makefile\n    ccflags-y += -g\n    ```\n\n#### F. Milestone Debugging Checkpoint\nAfter each milestone, run these diagnostic commands to verify fundamental health before proceeding.\n\n| Milestone | Command to Run | Expected Output / Healthy Sign |\n| :--- | :--- | :--- |\n| **1 (Load/Unload)** | `sudo insmod mychardev.ko; sudo rmmod mychardev; dmesg | tail -5` | Shows your `mydevice_init` and `mydevice_exit` `printk` messages without errors or warnings. |\n| **2 (Char Device)** | `ls -l /dev/mychardev` | The device file exists with major/minor numbers matching an entry in `/proc/devices`. `cat /proc/devices \\| grep mychardev` shows the major number. |\n| **3 (ioctl/proc)** | `sudo ./test/test_ioctl; cat /proc/mychardev` | The test program runs without `ioctl` errors (`errno`). The `/proc` entry displays current buffer size and data size. |\n| **4 (Concurrency)** | `sudo ./test/test_concurrent 2>&1 | grep -i error` | No output (no errors). The system does not hang or crash. Multiple `dmesg` entries show interleaved reads and writes from different processes. |\n\n#### G. Debugging Tips: Beyond the Basics\nIf you encounter a particularly stubborn issue:\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n| :--- | :--- | :--- | :--- |\n| **Module cannot be removed with `rmmod`** (`rmmod: ERROR: Module mychardev is in use`) | The device file is still open by a userspace process, or the module's reference count hasn't dropped to zero. | Run `sudo lsof /dev/mychardev` to see which processes have it open. Check `/proc/modules` for the module's reference count. | Ensure all test programs close the file descriptor. In `mydevice_release`, ensure you're not leaking a reference (e.g., improper `filp->private_data` management). |\n| **Kernel panic with NULL pointer dereference in your driver** | Accessing a member of a `struct mydevice_data` pointer that is `NULL`. | The Oops message will show the exact instruction. Look for lines in your code where you dereference `dev` without checking. | In `mydevice_open`, ensure `filp->private_data` is set correctly. In all handlers, verify `private_data` is not `NULL` (though VFS should ensure this). |\n| **Data corruption only under heavy load** | Race condition due to incomplete critical section or incorrect wait/wake logic. | Add fine-grained `printk` inside and outside the mutex lock. Use a script to run many concurrent operations and capture the `dmesg` log, then look for impossible sequences. | Extend the scope of the mutex lock to cover the entire sequence of checking condition and modifying data (the \"check-then-act\" pattern must be atomic). |\n\nBy methodically applying these techniques, you can systematically isolate and resolve the unique challenges of kernel driver development, transforming inscrutable system hangs and crashes into understandable, fixable software bugs.\n\n\n## Future Extensions\n\n> **Milestone(s):** Milestone 1, Milestone 2, Milestone 3, Milestone 4 (building upon completed foundations for advanced learning)\n\nThis section explores potential enhancements to the character device driver project that go beyond the core requirements. These extensions represent natural progression paths for deepening your understanding of Linux kernel programming, exploring alternative design patterns, and tackling more complex problems that real-world drivers face. Each suggestion includes a mental model to build intuition, an architecture decision framework for considering trade-offs, and implementation considerations to guide your exploration.\n\n### Potential Enhancements\n\nThe completed driver implements a functional character device with proper concurrency handling, but real-world drivers often require more sophisticated features. These extensions allow you to explore specific kernel subsystems and design patterns in greater depth while building upon the existing codebase.\n\n#### Enhancement 1: Circular Buffer Implementation\n\n**Mental Model: The Endless Scroll**\nThink of the current linear buffer as a fixed-length whiteboard where writing starts at the beginning and erasing happens from the beginning. When the board fills, you must either erase everything (clear operation) or get a bigger board (resize operation). A circular buffer transforms this into a continuous scroll—like an endless tape loop where new data overwrites old data automatically when the loop completes, creating a rolling window of the most recent data without requiring manual clearing or resizing.\n\n**Implementation Considerations:**\nReplacing the simple linear buffer with a circular buffer fundamentally changes how data is stored and accessed. Instead of tracking just `data_size`, you'll need read and write position indices that wrap around the buffer boundaries. This requires modifications to the `mydevice_read` and `mydevice_write` functions to handle wrap-around scenarios and properly calculate available space and data.\n\n> **Decision: Fixed-Size Circular Buffer vs. Dynamic Circular Buffer**\n> - **Context**: The driver currently uses a resizable linear buffer, but many real-world devices (like audio interfaces or network packet capture) benefit from fixed-size circular buffers that provide consistent performance and memory usage.\n> - **Options Considered**:\n>   1. **Fixed-size circular buffer**: Pre-allocated buffer with constant size, overwriting oldest data when full\n>   2. **Dynamic circular buffer**: Buffer that can resize while preserving the circular nature and data\n>   3. **Hybrid approach**: Fixed-size buffer with configurable size at module load time via module parameters\n> - **Decision**: Start with a fixed-size circular buffer for simplicity and predictable behavior\n> - **Rationale**: Fixed-size buffers eliminate allocation overhead during operation, prevent fragmentation, and simplify concurrency control. They also model many hardware devices that have fixed memory regions.\n> - **Consequences**: Userspace must handle the case where writes may overwrite unread data; the driver will need to track overwrite counts or provide notification mechanisms.\n\n**Required Modifications to Data Structures:**\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `read_pos` | `size_t` | Current read position index within the circular buffer |\n| `write_pos` | `size_t` | Current write position index within the circular buffer |\n| `overwrite_count` | `unsigned long` | Number of times data has been overwritten due to buffer wrap |\n| `is_circular` | `bool` | Flag indicating circular buffer mode is active |\n\n**Circular Buffer State Transitions:**\n| Current State | Event | Next State | Action Taken |\n|---------------|-------|------------|--------------|\n| EMPTY | Write N bytes | PARTIAL | `write_pos += N`, notify wait queue |\n| PARTIAL | Write M bytes where `(write_pos + M) % buffer_size > write_pos` | PARTIAL | `write_pos = (write_pos + M) % buffer_size` |\n| PARTIAL | Write M bytes causing wrap-around | PARTIAL | `write_pos = (write_pos + M) % buffer_size`, increment `overwrite_count` |\n| PARTIAL | Read K bytes where `(read_pos + K) % buffer_size > read_pos` | PARTIAL/EMPTY | `read_pos = (read_pos + K) % buffer_size`, if `read_pos == write_pos` transition to EMPTY |\n| PARTIAL | Read causing wrap-around | PARTIAL | `read_pos = (read_pos + K) % buffer_size` |\n\n**Implementation Steps:**\n1. Modify `buffer_init` to initialize `read_pos` and `write_pos` to 0\n2. Update `mydevice_write` to:\n   - Calculate available space considering the circular nature\n   - Handle the case where a write needs to be split across the buffer end\n   - Update `write_pos` with wrap-around using modulo arithmetic\n   - Increment `overwrite_count` when `write_pos` passes `read_pos`\n3. Update `mydevice_read` to:\n   - Calculate available data considering `read_pos` and `write_pos` positions\n   - Handle reads that cross the buffer boundary\n   - Update `read_pos` with proper wrap-around\n4. Adjust `mydevice_ioctl` to support new commands for circular buffer statistics\n5. Update `/proc` interface to show circular buffer-specific metrics\n\n**New Ioctl Commands for Circular Buffer:**\n| Command Name | Macro | Description |\n|--------------|-------|-------------|\n| `MYDEVICE_IOCTL_GET_OVERWRITES` | `_IOR(MYDEVICE_IOC_MAGIC, 5, unsigned long)` | Retrieve count of data overwrites |\n| `MYDEVICE_IOCTL_SET_CIRCULAR_MODE` | `_IOW(MYDEVICE_IOC_MAGIC, 6, int)` | Enable/disable circular buffer mode (1=enabled, 0=linear) |\n| `MYDEVICE_IOCTL_GET_AVAILABLE_SPACE` | `_IOR(MYDEVICE_IOC_MAGIC, 7, size_t)` | Get free space in circular buffer |\n\n#### Enhancement 2: mmap Support for Zero-Copy Data Access\n\n**Mental Model: The Shared Memory Window**\nCurrently, data transfer between userspace and kernelspace requires explicit copying through `copy_to_user` and `copy_from_user`. Imagine this as passing physical documents through a security checkpoint where each page must be inspected and copied. Adding `mmap` support creates a transparent window—like a two-way mirror—where userspace can directly read and write kernel memory without copying, dramatically improving performance for large data transfers.\n\n**Architecture Decision: Whole Buffer Mapping vs. Partial Mapping**\n| Option | Pros | Cons | Recommended Approach |\n|--------|------|------|---------------------|\n| **Map entire buffer** | Simple implementation, consistent memory region | Wastes virtual address space, exposes unused buffer areas | Good starting point for learning |\n| **Map only used portion** | Efficient virtual memory usage | Requires remapping as buffer grows, complex boundary handling | Advanced implementation |\n| **Multiple mapping regions** | Allows different processes to map different sections | Significantly more complex synchronization | For specialized use cases |\n\n**Implementation Requirements:**\nThe `mmap` operation requires adding a `mmap` handler to the `struct file_operations`. The handler will use `remap_pfn_range` or `vm_insert_page` to map the kernel buffer pages into the calling process's address space. Special considerations include:\n- Ensuring proper synchronization when userspace directly accesses kernel memory\n- Handling page alignment requirements\n- Managing reference counting to prevent use-after-free during module unload\n\n**Memory Protection Considerations:**\n| Protection Flag | Kernel Action | Use Case |\n|-----------------|---------------|----------|\n| `PROT_READ` | Map pages as read-only | Userspace only needs to read device data |\n| `PROT_WRITE` | Map pages as writable | Userspace needs to write to device buffer |\n| `PROT_EXEC` | Should be denied (return `-EINVAL`) | Execution from device buffer is unsafe |\n\n**Implementation Steps:**\n1. Add `mydevice_mmap` function to `struct file_operations`\n2. Implement `mydevice_mmap` to:\n   - Validate requested protection flags and mapping size\n   - Calculate the starting page frame for the buffer\n   - Call `remap_pfn_range` to create the mapping\n3. Add reference counting to `struct mydevice_data` to track active mappings\n4. Modify `mydevice_exit` to wait for all mappings to be released before freeing the buffer\n5. Consider adding `MYDEVICE_IOCTL_GET_PHYS_ADDR` command for advanced users who want to manage their own mappings\n\n**Potential Issues and Solutions:**\n| Issue | Cause | Solution |\n|-------|-------|----------|\n| Page alignment errors | Buffer not page-aligned | Use `kmalloc` with `GFP_KERNEL | __GFP_ZERO` and `get_order` for proper alignment |\n| Concurrent modification | Userspace writes via mmap while kernel writes via `mydevice_write` | Use `atomic_t` counters or finer-grained locking |\n| Module unload race | Process accessing mapped memory after module unloaded | Implement `is_shutting_down` flag and reference counting |\n\n#### Enhancement 3: Multiple Device Instances and Dynamic Minor Numbers\n\n**Mental Model: The Device Factory**\nCurrently, the driver creates a single device instance—like a factory that produces exactly one type of widget. Enhancing it to support multiple instances transforms it into a factory that can produce many independent widgets, each with its own buffer and state. This allows multiple applications to use their own private device instances without interfering with each other.\n\n**Design Approaches Comparison:**\n| Approach | Implementation Complexity | Resource Usage | Flexibility |\n|----------|---------------------------|----------------|-------------|\n| **Static array of devices** | Simple, fixed maximum instances | Wastes memory for unused instances | Limited by compile-time constant |\n| **Linked list of devices** | Moderate, dynamic creation/destruction | Efficient memory usage | Unlimited instances (subject to memory) |\n| **IDR (ID Radix Tree)** | Complex, kernel-provided ID management | Efficient for sparse instance numbers | Best for large, sparse instance spaces |\n\n> **Decision: Linked List for Dynamic Instance Management**\n> - **Context**: The driver needs to support creation of multiple independent device instances, potentially at runtime via ioctl or module parameters.\n> - **Options Considered**:\n>   1. **Static array**: Simple but wastes resources and has fixed limits\n>   2. **Linked list**: Dynamic, memory-efficient, but requires manual management\n>   3. **IDR with hash table**: Most scalable but highest complexity\n> - **Decision**: Implement linked list for manageable complexity with good dynamic behavior\n> - **Rationale**: Linked lists are a fundamental kernel data structure with predictable behavior. They allow dynamic growth without predefined limits while being understandable for educational purposes.\n> - **Consequences**: Requires careful locking for list operations, must handle cleanup of all instances during module exit.\n\n**Enhanced Data Model for Multiple Instances:**\n| Structure Name | Fields | Purpose |\n|----------------|--------|---------|\n| `struct mydevice_instance` | `struct list_head list`, `struct mydevice_data data`, `int instance_id` | Represents one device instance |\n| `struct mydevice_global` | `struct list_head instances`, `struct mutex instances_lock`, `int next_instance_id` | Global state for managing all instances |\n\n**Instance Management Operations:**\n| Operation | Function | Description |\n|-----------|----------|-------------|\n| Create instance | `mydevice_create_instance(minor_num)` | Allocates and initializes new instance, adds to global list |\n| Destroy instance | `mydevice_destroy_instance(instance_id)` | Removes instance from list, frees resources |\n| Find instance | `mydevice_find_instance(minor_num)` | Searches list for instance matching minor number |\n| List all instances | `mydevice_list_instances()` | Iterates through list (for `/proc` interface) |\n\n**Device Node Naming Scheme:**\n| Minor Number | Device Node | Instance ID |\n|--------------|-------------|-------------|\n| 0 | `/dev/mychardev0` | Primary instance (backward compatible) |\n| 1 | `/dev/mychardev1` | Secondary instance |\n| 2 | `/dev/mychardev2` | Tertiary instance |\n| ... | ... | ... |\n\n**Implementation Steps:**\n1. Refactor `struct mydevice_data` to remove singleton assumptions\n2. Create `struct mydevice_instance` wrapper with list head and instance ID\n3. Implement global instance list with protection mutex\n4. Modify `mydevice_open` to identify which instance based on minor number\n5. Add `MYDEVICE_IOCTL_CREATE_INSTANCE` and `MYDEVICE_IOCTL_DESTROY_INSTANCE` commands\n6. Update `/proc` interface to show all instances and their statistics\n7. Ensure `mydevice_exit` cleans up all instances\n\n**Concurrency Considerations:**\n- Use a global mutex (`instances_lock`) to protect the instance list\n- Each instance has its own buffer mutex for local operations\n- `mydevice_open` must find the instance before incrementing its reference count\n\n#### Enhancement 4: Device Tree Integration for Hardware Configuration\n\n**Mental Model: The Architectural Blueprint**\nCurrently, the driver configuration (buffer size, device name) is hardcoded or set via ioctl at runtime. Device Tree integration provides an architectural blueprint that the kernel reads at boot time—like a building plan that specifies where electrical outlets go, what materials to use, and how rooms connect. This allows the same driver binary to work with different hardware configurations without code changes.\n\n**Device Tree vs. Traditional Configuration Methods:**\n| Method | When Used | Advantages | Disadvantages |\n|--------|-----------|------------|---------------|\n| **Compile-time constants** | Simple software-only drivers | Simple, no runtime overhead | Requires recompilation for changes |\n| **Module parameters** | Loadable modules with user-configurable options | Flexible at module load time | Not discoverable, manual configuration |\n| **Platform data** | Embedded systems with board files | Board-specific configuration | Not portable across architectures |\n| **Device Tree** | Modern ARM, PowerPC, RISC-V systems | Hardware description separate from driver, portable | Complex syntax, parser overhead |\n\n**Example Device Tree Node:**\n```dts\nmychardev: mychardev@1000 {\n    compatible = \"custom,mychardev-1.0\";\n    reg = <0x1000 0x1000>;          // MMIO region\n    buffer-size = <0x4000>;         // 16KB buffer\n    circular-mode;                  // Enable circular buffer\n    instance-count = <2>;           // Create 2 instances\n    status = \"okay\";\n};\n```\n\n**Driver Modifications for Device Tree Support:**\n1. Add `of_match_table` to declare compatible strings\n2. Implement probe function to parse Device Tree properties\n3. Map `reg` regions for memory-mapped I/O (if simulating hardware)\n4. Use parsed properties to configure buffer size and operation mode\n\n**Device Tree Property Mapping:**\n| DT Property | Kernel Data Type | Driver Field | Default Value |\n|-------------|------------------|--------------|---------------|\n| `buffer-size` | `u32` | `buffer_size` | `BUFFER_SIZE` (1024) |\n| `circular-mode` | Boolean flag | `is_circular` | `false` |\n| `instance-count` | `u32` | Number of instances to create | 1 |\n| `reg` | `struct resource` | For MMIO simulation (optional) | N/A |\n\n**Implementation Steps:**\n1. Add `#include <linux/of.h>` and `#include <linux/of_device.h>`\n2. Define `of_device_id` table with compatible strings:\n   ```c\n   static const struct of_device_id mychardev_of_match[] = {\n       { .compatible = \"custom,mychardev-1.0\" },\n       { },\n   };\n   MODULE_DEVICE_TABLE(of, mychardev_of_match);\n   ```\n3. Implement `mydevice_probe` function to:\n   - Parse Device Tree properties using `of_property_read_u32`\n   - Allocate and initialize device instances based on configuration\n   - Map MMIO regions if `reg` property exists\n4. Register platform driver structure\n5. Update Kbuild to compile conditionally based on `CONFIG_OF`\n\n**Simulating Hardware for Learning:**\nSince this is an educational project without real hardware, you can simulate memory-mapped I/O by:\n1. Using `ioremap` on a dummy physical address (ensure it's not in use)\n2. Implementing simple register read/write operations that manipulate the software buffer\n3. Adding interrupt simulation using a kernel timer to trigger simulated data arrival\n\n**Advanced Extension: Platform Driver Integration**\nTransform the driver into a full platform driver that can be bound to Device Tree nodes:\n1. Create `struct platform_driver` with probe, remove, and driver fields\n2. Use `platform_get_resource` to get memory regions\n3. Handle power management callbacks (`suspend`, `resume`)\n4. Support multiple platform devices through Device Tree\n\n#### Enhancement 5: SysFS Interface for Runtime Configuration\n\n**Mental Model: The Control Knobs and Dials**\nWhile `/proc` provides a read-oriented dashboard for monitoring, SysFS offers writable control knobs and dials—like the control panel of a machine where operators can adjust settings while it's running. Each SysFS attribute represents a single controllable parameter with defined access permissions.\n\n**SysFS vs. ProcFS vs. Ioctl Comparison:**\n| Interface | Best For | Access Pattern | Example Use |\n|-----------|----------|----------------|-------------|\n| **Ioctl** | Complex operations with structured data | Programmatic, binary data | `ioctl(fd, RESIZE_BUFFER, &new_size)` |\n| **ProcFS** | Human-readable status information | Read-mostly, text format | `cat /proc/mychardev/stats` |\n| **SysFS** | Simple parameter access (one value per file) | Read/write, text format | `echo 8192 > /sys/class/mychardev/mychardev0/buffer_size` |\n\n**SysFS Attribute Design:**\n| Attribute Name | Permission | Data Type | Description |\n|----------------|------------|-----------|-------------|\n| `buffer_size` | `0644` (root can write) | Decimal integer | Current buffer size in bytes |\n| `data_size` | `0444` (read-only) | Decimal integer | Amount of data currently stored |\n| `mode` | `0644` | String (\"linear\" or \"circular\") | Buffer operating mode |\n| `overwrites` | `0444` | Decimal integer | Count of data overwrites (circular mode) |\n| `reset` | `0200` (write-only) | Write \"1\" to clear buffer | Clear all data in buffer |\n\n**Implementation Steps:**\n1. Add SysFS attribute declarations using `DEVICE_ATTR_RW`, `DEVICE_ATTR_RO`, `DEVICE_ATTR_WO` macros\n2. Implement show/store functions for each attribute\n3. Create attribute group and register with device class\n4. Ensure proper locking in store functions (use existing mutex)\n5. Add error handling for invalid input values\n\n**Example SysFS Store Function:**\n```c\nstatic ssize_t buffer_size_store(struct device *dev,\n                                 struct device_attribute *attr,\n                                 const char *buf, size_t count)\n{\n    struct mydevice_data *mydata = dev_get_drvdata(dev);\n    unsigned long new_size;\n    int err;\n    \n    err = kstrtoul(buf, 10, &new_size);\n    if (err)\n        return err;\n    \n    if (new_size > MAX_BUFFER_SIZE || new_size == 0)\n        return -EINVAL;\n    \n    mutex_lock(&mydata->lock);\n    err = buffer_resize(mydata, new_size);\n    mutex_unlock(&mydata->lock);\n    \n    return err ? err : count;\n}\n```\n\n#### Enhancement 6: Advanced Synchronization with Read-Write Locks\n\n**Mental Model: The Library with Multiple Reading Rooms**\nThe current mutex implementation is like a library with a single room that only one person can enter at a time. Read-write locks transform this into a library with a reading room that allows multiple readers simultaneously but only one writer at a time—like allowing many people to read books concurrently but only one person to reorganize the shelves.\n\n**When to Use Read-Write Locks:**\n| Scenario | Current Mutex | Read-Write Lock | Benefit |\n|----------|---------------|-----------------|---------|\n| Many concurrent readers | Readers serialize | All readers proceed concurrently | Higher throughput for read-heavy workloads |\n| Frequent writes | Appropriate | Writers still serialize | No benefit, adds overhead |\n| Mixed workload | Simple, predictable | Allows reads during writes | Moderate improvement |\n\n> **Decision: Selective Read-Write Lock Implementation**\n> - **Context**: The driver currently uses a single mutex for all buffer operations, which may limit performance in read-heavy scenarios.\n> - **Options Considered**:\n>   1. **Replace mutex with read-write lock**: Simple substitution but may not benefit write-heavy workloads\n>   2. **Fine-grained locking with multiple mutexes**: Complex but allows more parallelism\n>   3. **Read-copy-update (RCU)**: Advanced technique for extremely read-heavy cases\n> - **Decision**: Implement optional read-write lock mode selectable via ioctl\n> - **Rationale**: This allows comparison between mutex and read-write lock performance while maintaining backward compatibility. The educational value of implementing both is high.\n> - **Consequences**: More complex code, need to handle mode switching safely, potential for writer starvation if not configured properly.\n\n**Implementation Strategy:**\n1. Add `rwlock_t` or `struct rw_semaphore` to `struct mydevice_data`\n2. Create `use_rwlock` flag to select locking mode\n3. Implement helper functions that use appropriate locking based on mode:\n   ```c\n   void mydevice_lock_read(struct mydevice_data *mydata) {\n       if (mydata->use_rwlock)\n           down_read(&mydata->rw_sem);\n       else\n           mutex_lock(&mydata->lock);\n   }\n   ```\n4. Add `MYDEVICE_IOCTL_SET_LOCKING_MODE` command\n5. Update all code paths to use the appropriate lock/unlock helpers\n\n**Performance Measurement:**\nAdd statistics to track lock contention:\n| Metric | Measurement Method | Use Case |\n|--------|-------------------|----------|\n| Read lock acquisitions | Atomic counter incremented in `mydevice_lock_read` | Compare mutex vs. rwlock throughput |\n| Write lock acquisitions | Atomic counter in `mydevice_lock_write` | Measure write frequency |\n| Contention count | `lockstat` kernel infrastructure or custom timing | Identify bottlenecks |\n\n#### Enhancement 7: Asynchronous I/O (AIO) Support\n\n**Mental Model: The Restaurant with Order Tickets**\nCurrent blocking I/O is like a restaurant where each customer must wait at the counter until their order is ready. Asynchronous I/O transforms this into a system where customers submit order tickets and can do other things while waiting—they're notified when their order is complete. This allows a single application to manage multiple concurrent I/O operations without threads.\n\n**Linux AIO Mechanisms Comparison:**\n| Mechanism | Interface | Complexity | Best For |\n|-----------|-----------|------------|----------|\n| **Kernel AIO** | `io_submit`, `io_getevents` | High | High-performance servers, database systems |\n| **POSIX AIO** | `aio_read`, `aio_write` | Moderate | Portable asynchronous I/O |\n| **epoll with O_NONBLOCK** | `epoll_ctl`, non-blocking file descriptors | Low to moderate | Mixed synchronous/asynchronous patterns |\n\n**Implementing `aio_read` and `aio_write`:**\n1. Add `aio_read` and `aio_write` handlers to `struct file_operations`\n2. Implement completion callback mechanism using `kiocb` structure\n3. Use work queues or kernel threads to process requests asynchronously\n4. Ensure proper synchronization with existing buffer operations\n\n**Example AIO Read Implementation Outline:**\n```c\nstatic ssize_t mydevice_aio_read(struct kiocb *iocb, struct iov_iter *iter)\n{\n    struct mydevice_data *mydata = iocb->ki_filp->private_data;\n    ssize_t ret;\n    \n    mutex_lock(&mydata->lock);\n    if (mydata->data_size == 0) {\n        // Queue for asynchronous completion\n        INIT_WORK(&iocb->ki_wait.work, mydevice_aio_complete_read);\n        queue_work(mydata->aio_wq, &iocb->ki_wait.work);\n        mutex_unlock(&mydata->lock);\n        return -EIOCBQUEUED;\n    }\n    \n    // Synchronous completion if data available\n    ret = mydevice_read_copy(mydata, iter);\n    mutex_unlock(&mydata->lock);\n    \n    if (ret > 0)\n        iocb->ki_complete(iocb, ret, 0);\n    \n    return ret;\n}\n```\n\n**Integration with Existing Infrastructure:**\n- Modify wait queue to notify both blocking readers and AIO completions\n- Create dedicated work queue for AIO operations\n- Add reference counting to ensure AIO operations complete before module unload\n\n### Implementation Guidance\n\n> **Note**: These extensions are presented as independent learning paths. Choose one based on your interests and implement it incrementally, testing each change thoroughly before proceeding to the next.\n\n#### A. Technology Recommendations Table\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **Circular Buffer** | Fixed-size circular buffer with simple wrap-around | Dynamic circular buffer with configurable watermark levels |\n| **mmap Support** | Whole-buffer mapping with read-only access | Partial mapping with configurable protection flags |\n| **Multiple Instances** | Static array of instances (compile-time limit) | Linked list with dynamic creation/destruction via ioctl |\n| **Device Tree** | Basic property parsing for configuration | Full platform driver with power management and interrupt simulation |\n| **SysFS Interface** | Read-only attributes for statistics | Read-write attributes with validation and change notification |\n| **Synchronization** | Mutex for all operations | Read-write locks with performance counters |\n| **Asynchronous I/O** | epoll with non-blocking mode | Full kernel AIO support with completion queues |\n\n#### B. Recommended File Structure for Extensions\n```\nproject-root/\n  ├── mychardev.c              # Main driver (existing)\n  ├── mychardev.h              # Shared header (existing)\n  ├── test_userspace.c         # Test program (existing)\n  ├── Makefile                 # Build file (existing)\n  ├── circular-buffer-example/ # Optional: Circular buffer extension\n  │   ├── circular.c           # Circular buffer implementation\n  │   └── circular.h           # Circular buffer interface\n  ├── mmap-example/            # Optional: mmap extension\n  │   └── mmap-impl.c          # mmap handler implementation\n  ├── multi-instance-example/  # Optional: Multiple instances\n  │   └── instance-mgr.c       # Instance management code\n  └── device-tree-example/     # Optional: Device Tree support\n      ├── mychardev.dts        # Example Device Tree source\n      └── dt-probe.c           # Device Tree probe function\n```\n\n#### C. Infrastructure Starter Code: Circular Buffer Helper\n\nFor the circular buffer extension, here's a complete helper module you can integrate:\n\n```c\n/* circular-buffer.h - Circular buffer helper interface */\n#ifndef CIRCULAR_BUFFER_H\n#define CIRCULAR_BUFFER_H\n\n#include <linux/types.h>\n#include <linux/mutex.h>\n\nstruct circular_buffer {\n    char *data;\n    size_t size;\n    size_t read_pos;\n    size_t write_pos;\n    unsigned long overwrite_count;\n    struct mutex lock;\n};\n\n/* Initialize a circular buffer */\nint circular_buffer_init(struct circular_buffer *cb, size_t size);\n\n/* Clean up a circular buffer */\nvoid circular_buffer_cleanup(struct circular_buffer *cb);\n\n/* Get amount of data available to read */\nsize_t circular_buffer_data_available(const struct circular_buffer *cb);\n\n/* Get free space available for writing */\nsize_t circular_buffer_free_space(const struct circular_buffer *cb);\n\n/* Write data to circular buffer, returns bytes written */\nsize_t circular_buffer_write(struct circular_buffer *cb, \n                             const char *user_buf, \n                             size_t count);\n\n/* Read data from circular buffer, returns bytes read */\nsize_t circular_buffer_read(struct circular_buffer *cb,\n                            char *user_buf,\n                            size_t count);\n\n/* Clear the circular buffer */\nvoid circular_buffer_clear(struct circular_buffer *cb);\n\n/* Resize circular buffer, preserving data if possible */\nint circular_buffer_resize(struct circular_buffer *cb, size_t new_size);\n\n#endif /* CIRCULAR_BUFFER_H */\n```\n\n#### D. Core Logic Skeleton: mmap Handler Implementation\n\n```c\n/* In mychardev.c, add to file_operations */\nstatic const struct file_operations mychardev_fops = {\n    .owner = THIS_MODULE,\n    .open = mydevice_open,\n    .release = mydevice_release,\n    .read = mydevice_read,\n    .write = mydevice_write,\n    .unlocked_ioctl = mydevice_ioctl,\n    .poll = mydevice_poll,\n    .mmap = mydevice_mmap,  /* NEW: Add mmap handler */\n};\n\n/* Skeleton for mmap implementation */\nstatic int mydevice_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n    struct mydevice_data *mydata = filp->private_data;\n    unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n    unsigned long size = vma->vm_end - vma->vm_start;\n    unsigned long pfn;\n    int ret;\n    \n    /* TODO 1: Check if mapping request is valid */\n    /* - Ensure offset is 0 (we only map from buffer start) */\n    /* - Ensure size doesn't exceed buffer size */\n    /* - Check protection flags (deny PROT_EXEC) */\n    \n    /* TODO 2: Calculate physical page frame number for buffer */\n    /* - Use virt_to_phys on buffer address */\n    /* - Convert to page frame number (pfn = phys >> PAGE_SHIFT) */\n    \n    /* TODO 3: Map pages into userspace */\n    /* - Call remap_pfn_range with vma, vma->vm_start, pfn, size, vma->vm_page_prot */\n    /* - Handle return value (0 on success, negative error on failure) */\n    \n    /* TODO 4: Update reference counting */\n    /* - Increment mapping count to prevent premature buffer free */\n    /* - Consider using vma->vm_ops for open/close notifications */\n    \n    return ret;\n}\n```\n\n#### E. Language-Specific Hints for Kernel C\n\n1. **Memory Barriers**: When implementing circular buffers, use appropriate memory barriers (`smp_rmb()`, `smp_wmb()`) to ensure read/write positions are visible in the correct order on SMP systems.\n\n2. **Page Alignment**: For mmap, ensure your buffer is page-aligned by using `__get_free_pages` or `kmalloc` with alignment constraints rather than simple `kmalloc`.\n\n3. **Reference Counting**: Use `kref` or `refcount_t` for managing object lifetimes with multiple references (mmap mappings, AIO operations).\n\n4. **Work Queues**: For AIO implementations, create a dedicated workqueue with `alloc_workqueue` rather than using the shared system workqueue to avoid priority inversion.\n\n5. **Device Tree Parsing**: Use `of_property_read_*` functions which return error codes rather than `of_get_property` followed by manual parsing.\n\n#### F. Milestone Checkpoint for Extensions\n\nAfter implementing any extension, verify with these tests:\n\n| Extension | Test Command | Expected Result |\n|-----------|--------------|-----------------|\n| **Circular Buffer** | `echo \"test\" > /dev/mychardev0; cat /dev/mychardev0` | Should return \"test\" immediately |\n| **Circular Buffer** | Write more data than buffer size, then read | Should get most recent data (oldest overwritten) |\n| **mmap Support** | `sudo dd if=/dev/mychardev0 of=/dev/null bs=4096 count=1` | Should succeed without copy_to_user overhead |\n| **Multiple Instances** | `echo \"instance1\" > /dev/mychardev0; echo \"instance2\" > /dev/mychardev1` | Each instance maintains separate data |\n| **Device Tree** | Boot with Device Tree containing mychardev node | Driver should auto-configure based on DT properties |\n| **SysFS** | `cat /sys/class/mychardev/mychardev0/buffer_size` | Should show current buffer size in decimal |\n\n#### G. Debugging Tips for Extensions\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **mmap segfault** | Buffer not page-aligned | Check `virt_to_phys` return value | Use `get_zeroed_page` or aligned allocation |\n| **Circular buffer data corruption** | Race condition between read_pos/write_pos updates | Add memory barriers between position updates | Use `smp_store_release` and `smp_load_acquire` |\n| **Multiple instances interfere** | Global variables still used | Search for non-instance-specific variables | Move all state to `struct mydevice_instance` |\n| **Device Tree properties ignored** | Wrong compatible string | Check kernel log for probe failures | Ensure `compatible` string matches driver table |\n| **SysFS permission denied** | Wrong attribute permissions | Check `mode` parameter in `DEVICE_ATTR_*` | Use appropriate permission macros |\n| **AIO operation hangs** | Completion not called | Add `printk` to completion callback | Ensure `ki_complete` is called on all code paths |\n\n---\n\n\n## Glossary\n\n> **Milestone(s):** Milestone 1, Milestone 2, Milestone 3, Milestone 4 (foundational vocabulary for all concepts)\n\nThis section defines key technical terms, acronyms, and Linux kernel-specific vocabulary used throughout this design document. Understanding these terms is essential for navigating the Linux kernel programming ecosystem and implementing the character device driver.\n\n### Terms and Definitions\n\n| Term | Definition |\n|------|------------|\n| **alloc_chrdev_region** | A kernel function that dynamically allocates a range of character device numbers (major/minor pairs) from the kernel's available pool, avoiding conflicts with statically assigned numbers. Returns the starting device number in a `dev_t`. |\n| **Blocking I/O** | Input/output operations that cause the calling process to sleep (wait) until data becomes available for reading or space becomes available for writing. Contrasts with non-blocking I/O, which returns immediately with whatever data is available or an error. |\n| **Character Device** | A type of Linux device that handles data as a stream of bytes (like a serial port or terminal), as opposed to block devices that handle data in fixed-size blocks. Accessed through file operations like `read()`, `write()`, and `ioctl()` via a file in `/dev`. |\n| **class** | In the Linux device model, a grouping of devices with similar characteristics or functions. Created with `class_create()`, it appears in sysfs (`/sys/class/`) and enables automatic device node creation in `/dev` via `udev` or `mdev`. |\n| **class_create** | Kernel function that creates a device class object in sysfs. This class is used by `device_create()` to automatically create device nodes when the driver registers a device. |\n| **copy_from_user** | Kernel function that safely copies data from user-space memory to kernel-space memory. It validates the user-space pointer, handles page faults, and returns the number of bytes that could not be copied (0 on success). Critical for security—never dereference user pointers directly. |\n| **copy_to_user** | Kernel function that safely copies data from kernel-space memory to user-space memory. Like `copy_from_user`, it validates the destination pointer and handles faults, returning the number of bytes not copied. |\n| **Critical Section** | A segment of code that accesses shared resources (data structures, hardware registers) and must be executed by only one thread or process at a time to prevent race conditions. Protected by synchronization primitives like mutexes or spinlocks. |\n| **cdev** | Kernel structure (`struct cdev`) representing a character device internally. Initialized with `cdev_init()` and added to the system with `cdev_add()`, it links a device number with its `file_operations` handlers. |\n| **cdev_add** | Function that registers a `cdev` structure with the kernel, making the character device operational and reachable through its device number. |\n| **cdev_init** | Function that initializes a `cdev` structure, associating it with a `file_operations` structure that defines the driver's handlers for system calls. |\n| **dev_t** | Kernel data type that holds a device number, combining major and minor numbers into a single 32-bit value (12 bits for major, 20 bits for minor in modern kernels). Functions like `MAJOR()` and `MINOR()` extract components. |\n| **device_create** | Kernel function that creates a device node in `/dev` and corresponding entries in sysfs. It associates a device number (`dev_t`) with a class, creating the interface userspace applications use to access the device. |\n| **Device Node** | A special file in the `/dev` directory that provides an interface to a device driver. Applications perform file operations (`open`, `read`, `write`, `ioctl`, `close`) on this node, which the kernel routes to the appropriate driver. |\n| **Device Tree** | A data structure and language for describing hardware, used primarily on embedded systems (ARM, PowerPC, RISC-V). The kernel reads the Device Tree at boot to discover hardware configuration without hardcoded platform data. |\n| **dmesg** | Command-line utility that displays the kernel's ring buffer of log messages (including those from `printk`). Essential for debugging kernel modules, as it shows initialization messages, errors, and debug output. |\n| **Error Propagation** | The practice of returning appropriate error codes (negative errno values) from kernel functions to user-space system calls. The kernel's VFS translates these negative values to positive `errno` values for the C library. |\n| **errno** | In userspace, a global variable that holds the error number from the last failed system call. In kernel space, error codes are negative integers (e.g., `-EINVAL` for invalid argument) that the VFS converts to positive `errno` values. |\n| **file_operations** | A kernel structure (`struct file_operations`) containing function pointers that implement the driver's handling of system calls like `open`, `read`, `write`, `release`, `ioctl`, and `poll`. The driver initializes this structure with its handler functions. |\n| **Flight Data Recorder** | Analogy for the kernel's logging system (`printk` and `dmesg`). Like an airplane's black box, it continuously records kernel events and messages, which can be reviewed after crashes or unexpected behavior to diagnose what happened. |\n| **GFP_KERNEL** | Flag passed to memory allocation functions like `kmalloc()` indicating normal kernel memory allocation that may sleep (schedule other processes) while waiting for memory. Used in process context, not interrupt context. |\n| **insmod** | Command to insert (load) a kernel module into the running kernel. Triggers the module's initialization function (declared with `module_init`). Requires root privileges. |\n| **ioctl** (I/O Control) | A system call and device operation that provides a device-specific command interface for configuration, control, and status queries beyond standard read/write. Commands are defined using `_IOR`, `_IOW`, `_IOWR` macros. |\n| **Kbuild** | The Linux kernel build system. It uses `Makefile`s with special syntax to build kernel modules against the currently running kernel's headers, handling dependencies and architecture specifics. |\n| **Kernel Module** | A loadable piece of object code that extends the Linux kernel's functionality at runtime. Modules can be loaded with `insmod` and unloaded with `rmmod`, allowing dynamic addition of drivers, filesystems, or other features without rebooting. |\n| **Kernel Taint** | A state where the kernel marks itself as \"tainted\" because a non-GPL or problematic module has been loaded, hardware reported a machine check error, or other issues occurred. A tainted kernel may restrict use of debugging symbols and is often unsupported for bug reports. |\n| **Linear Buffer** | A contiguous memory block where data is stored sequentially from the start. When full, no more data can be written until space is freed by reading. Simple to implement but less flexible than a circular buffer for streaming data. |\n| **Magic Number** | In the context of `ioctl`, a unique byte value used to identify a family of commands and prevent collisions between unrelated drivers. Defined as the first argument to `_IOR`, `_IOW`, `_IOWR` macros (e.g., `'k'` for our driver). |\n| **Major Number** | The first component of a device number, identifying the device driver type. Historically assigned statically (e.g., 3 for IDE disks), but modern drivers often use `alloc_chrdev_region` for dynamic allocation to avoid conflicts. |\n| **Memory Barrier** | A CPU instruction that enforces ordering constraints on memory operations, ensuring that reads and writes before the barrier complete before those after the barrier. Critical for correct synchronization on multi-processor systems. |\n| **Minor Number** | The second component of a device number, identifying a specific instance of a device managed by a driver with a given major number. A single driver can manage multiple devices with the same major number but different minor numbers. |\n| **modinfo** | Command that displays information embedded in a kernel module file (`.ko`), such as author, description, license, parameters, and dependencies. Reads metadata declared with `MODULE_AUTHOR`, `MODULE_DESCRIPTION`, etc. |\n| **Module Lifecycle** | The sequence of states a kernel module undergoes: built, loaded (initialization), active (handling operations), and unloaded (cleanup). Managed by `module_init` and `module_exit` functions. |\n| **mutex** (Mutual Exclusion Lock) | A kernel synchronization primitive that allows only one thread of execution to hold it at a time. Threads attempting to acquire a held mutex sleep until it's released. Used for protecting critical sections in process context where sleeping is allowed. |\n| **O_NONBLOCK** | A file status flag set with `open()` or `fcntl()` that causes subsequent I/O operations on the file descriptor to be non-blocking. If data isn't available for read or space for write, the call returns immediately with `EAGAIN` instead of sleeping. |\n| **Oops** | A kernel error condition where the kernel detects an internal inconsistency (like dereferencing a NULL pointer) but attempts to continue running. An Oops generates a diagnostic message with a stack trace in the kernel log but may leave the system in an unstable state. |\n| **Out-of-Tree Module** | A kernel module built outside the official kernel source tree, typically using the running kernel's headers. This project builds an out-of-tree module, as opposed to drivers integrated into the main kernel source. |\n| **Page Frame Number (PFN)** | The index of a physical page in system memory. Used in memory mapping operations to specify which physical pages should be mapped into a process's virtual address space. |\n| **Panic** | A fatal kernel error that halts the system entirely, often with a diagnostic message. Unlike an Oops, a panic stops execution to prevent further corruption, usually requiring a reboot. |\n| **Partial Transfer** | When a `read()` or `write()` system call completes successfully but transfers fewer bytes than requested. For example, a read might return only 100 bytes when 1024 were requested because only 100 were available in the device buffer. Drivers must handle this correctly. |\n| **Platform Driver** | A kernel driver model for devices that are discovered via a platform bus (often representing embedded SOC-integrated peripherals). Uses `of_match_table` for Device Tree matching and a `probe` function for initialization. |\n| **POLLIN / POLLOUT** | Bitmask values returned by a driver's `poll` handler indicating that the device is readable (`POLLIN`) or writable (`POLLOUT`). Used by the `select()` and `poll()` system calls to monitor multiple file descriptors for I/O readiness. |\n| **Priority Inversion** | A scheduling problem where a high-priority task is blocked waiting for a resource held by a low-priority task, which in turn is preempted by medium-priority tasks, causing indefinite blocking of the high-priority task. Solved in the kernel with priority inheritance for mutexes. |\n| **printk** | The kernel's equivalent of `printf()`, used for logging messages at various severity levels (e.g., `KERN_INFO`, `KERN_ERR`). Messages go to the kernel log buffer and can be viewed with `dmesg`. Does not automatically append newlines. |\n| **proc_create** | Kernel function that creates a file in the `/proc` filesystem, associating it with a `proc_ops` structure of handler functions. Provides a simple interface for exporting driver statistics and configuration to userspace. |\n| **ProcFS** (Proc Filesystem) | A virtual filesystem mounted at `/proc` that provides a window into kernel internals, exposing process information, system configuration, and driver statistics through files and directories. Our driver creates an entry here for status monitoring. |\n| **proc_ops** | Structure (`struct proc_ops`) defining the operations for a `/proc` file, similar to `file_operations` but optimized for procfs. Includes handlers for `proc_open`, `proc_read`, `proc_write`, `proc_lseek`, and `proc_release`. |\n| **probe function** | In device driver models (like platform or PCI), the function called by the kernel when a device is discovered and matched to a driver. Responsible for initializing the device, allocating resources, and registering it with appropriate subsystems. |\n| **Race Condition** | A bug where the correctness of a program depends on the relative timing of uncontrollable events (like thread scheduling or hardware interrupts). Multiple threads accessing shared data without proper synchronization can cause data corruption or crashes. |\n| **Reference Count** | A counter associated with a kernel object (like a `struct file` or `struct inode`) that tracks how many entities are currently using it. When the count drops to zero, the object can be safely freed. Prevents use-after-free errors. |\n| **remap_pfn_range** | Kernel function that maps physical memory (identified by page frame numbers) into a process's virtual address space, typically used to implement the `mmap` operation for device drivers that support direct memory access. |\n| **Resource Leak** | A bug where a kernel module fails to release allocated resources (memory, device numbers, sysfs entries) during cleanup or error paths, causing gradual exhaustion of system resources across multiple load/unload cycles. |\n| **rmmod** | Command to remove (unload) a kernel module from the running kernel. Triggers the module's cleanup function (declared with `module_exit`). Fails if the module is in use (reference count > 0). |\n| **Rollback** | The practice of undoing partial initialization steps when an error occurs during module loading. For example, if `device_create` fails after `alloc_chrdev_region` succeeded, the driver must release the device number before returning the error. |\n| **seq_file** | A kernel interface that simplifies the implementation of `/proc` files that produce more than one page of output. Handles iterative reading, page boundaries, and offset management automatically, preferred over raw `proc_read` for complex outputs. |\n| **Shutdown Coordination** | Ensuring that all ongoing operations (like sleeping reads) complete or are gracefully terminated before the module unloads. May involve setting a `is_shutting_down` flag and waking wait queues to abort sleeping processes. |\n| **Signal Interruption** | When a system call is interrupted by the delivery of a signal to the process. The system call returns `-ERESTARTSYS` internally, which the VFS translates to restarting the call or returning `-EINTR` to userspace depending on signal handling settings. |\n| **Singleton Pattern** | A design pattern where only one instance of a particular structure or module exists in the system. Our driver uses this pattern for the main device instance, though the design could be extended to support multiple instances. |\n| **single_open** | A helper function for creating simple `/proc` files that produce a single page of static content. Takes a `show` function that prints the entire output at once, simplifying the `proc_ops` implementation compared to `seq_file`. |\n| **SMP** (Symmetric Multi-Processing) | A system architecture where two or more identical processors (cores) share the same memory and are controlled by a single operating system. Requires careful synchronization to avoid race conditions on shared data structures. |\n| **Spinlock** | A busy-wait synchronization primitive used in kernel contexts where sleeping is not allowed (like interrupt handlers). The thread repeatedly checks the lock in a loop until it becomes available, consuming CPU but guaranteeing low latency. |\n| **Spurious Wakeup** | When a process sleeping on a wait queue is awakened even though the condition it was waiting for isn't true. Can happen due to signals or broad wake-up calls. Correct code must re-check the condition after waking, typically in a loop. |\n| **State Machine** | A computational model where the system can be in one of a finite number of states, and transitions between states occur in response to events. Our device buffer can be modeled as a state machine with EMPTY, PARTIALLY_FILLED, and FULL states. |\n| **strace** | A userspace diagnostic tool that traces system calls and signals made by a process. Useful for debugging driver interactions by showing the sequence of `open`, `read`, `write`, `ioctl`, and `close` calls and their return values/errors. |\n| **SysFS** (Sys Filesystem) | A virtual filesystem mounted at `/sys` that exports kernel object hierarchies (devices, drivers, classes) as directories and files. Used by udev for device node management and by tools like `lsmod` and `lspci`. |\n| **TOCTOU** (Time-Of-Check-Time-Of-Use) | A race condition where the state of a resource (like buffer size) is checked at one time but used at a later time after it may have changed. For example, checking `data_size > 0` then copying data without holding a lock could lead to reading stale data if another thread clears the buffer in between. |\n| **VFS** (Virtual File System) | A kernel abstraction layer that provides a uniform interface for filesystem operations, regardless of the underlying filesystem or device type. Our driver's `file_operations` are called by the VFS in response to system calls on our device node. |\n| **virt_to_phys** | Kernel function that converts a kernel virtual address to its corresponding physical address. Used in low-level memory mapping operations, but note that for DMA or user mapping, more complex methods are often required due to memory fragmentation. |\n| **Wait Queue** | A kernel data structure (`wait_queue_head_t`) that allows processes to sleep until a condition becomes true. Processes call `wait_event_interruptible()` to sleep, and the driver calls `wake_up_interruptible()` to awaken them when data arrives or space becomes available. |\n| **Work Queue** | A kernel mechanism for deferring work to be processed later by kernel threads. Useful for splitting lengthy operations from interrupt handlers or for executing tasks in process context where sleeping is allowed. |\n"}