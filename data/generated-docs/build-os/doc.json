{"html":"<h1 id=\"build-your-own-os\">Build Your Own OS</h1>\n<p>This project guides you through building a complete x86 operating system kernel from scratch, starting with the boot process and culminating in preemptive multitasking with user-mode processes. You will implement the fundamental abstractions that every modern OS provides: bootstrapping from firmware, hardware interrupt handling, virtual memory isolation, and fair process scheduling. Each layer reveals how software negotiates with hardware physics—CPU pipelines, cache hierarchies, TLBs, and the memory bus.</p>\n<p>The journey begins with a 512-byte bootloader that wrests control from BIOS, configures the Global Descriptor Table (GDT), and transitions the CPU from 16-bit real mode to 32-bit protected mode. From there, you&#39;ll build an interrupt subsystem that handles CPU exceptions and hardware IRQs, implement physical and virtual memory management with page tables, and finally create a preemptive scheduler that safely transitions between ring 0 (kernel) and ring 3 (user) privilege levels.</p>\n<p>By the end, you will have demystified the abstraction layer that underlies every computing platform—from interrupt latency to memory isolation to context switch overhead. You will understand not just what an OS does, but why it must do it, and how hardware constraints shape every design decision.</p>\n<!-- MS_ID: build-os-m1 -->\n<h1 id=\"milestone-1-bootloader-gdt-and-kernel-entry\">Milestone 1: Bootloader, GDT, and Kernel Entry</h1>\n<h2 id=\"the-first-breath-of-your-operating-system\">The First Breath of Your Operating System</h2>\n<p>{{DIAGRAM:diag-boot-sequence}}</p>\n<p>When you press the power button, nothing about your computer knows what an &quot;operating system&quot; is. The CPU wakes up in a primitive state—16-bit real mode—and begins executing firmware code at a fixed address. Your kernel, your C code, your beautiful abstractions? They don&#39;t exist yet. They&#39;re just bits on a disk, waiting to be loaded.</p>\n<p>This milestone is about the <strong>bootstrap problem</strong>: how do you go from a 512-byte constraint (the Master Boot Record) to a fully running C kernel with memory protection? Every step is your responsibility. The hardware provides mechanisms; you must orchestrate them.</p>\n<h3 id=\"the-fundamental-tension\">The Fundamental Tension</h3>\n<p><strong>Constraint 1: The 512-Byte Prison</strong></p>\n<p>BIOS loads exactly one sector—512 bytes—from the boot disk into memory at address <code>0x7C00</code>. That&#39;s it. Your entire bootloader must fit in 512 bytes, or you must be clever enough to load more code from disk.</p>\n<p><strong>Constraint 2: The A20 Gate</strong></p>\n<p>For historical compatibility with the original IBM PC, the 21st address line (A20) is often disabled at boot. Without it, addresses wrap around at 1MB—the CPU cannot access memory above this boundary. Your kernel needs to live above 1MB (at <code>0x100000</code>), so you must enable A20.</p>\n<p><strong>Constraint 3: Real Mode Addressing</strong></p>\n<p>The CPU starts in <strong>real mode</strong> (16-bit), where addresses are calculated as <code>segment * 16 + offset</code>. This gives you access to only the first 1MB of memory. To access 4GB of memory and enable protection features, you must transition to <strong>protected mode</strong> (32-bit).</p>\n<blockquote>\n<p><strong>Real Mode vs. Protected Mode (Memory Models)</strong></p>\n<p>In <strong>real mode</strong>, memory addressing uses <code>segment:offset</code> pairs. The segment value is multiplied by 16 and added to the offset: <code>segment * 16 + offset = physical_address</code>. With 16-bit segments and offsets, you can only address up to <code>0xFFFF0 + 0xFFFF = 0x10FFEF</code> (about 1MB + 64KB). There&#39;s no memory protection—any code can access any memory.</p>\n<p>In <strong>protected mode</strong>, segmentation works differently. Instead of multiplying by 16, the segment register is a <strong>selector</strong>—an index into the Global Descriptor Table (GDT). Each GDT entry (segment descriptor) contains a 32-bit base address and a 20-bit limit. The CPU translates every memory access through this table. Protected mode also enables paging (Milestone 3) and privilege rings (Ring 0-3).</p>\n</blockquote>\n<p><strong>Constraint 4: The Pipeline Inconsistency</strong></p>\n<p>Setting the CR0.PE bit (Protection Enable) switches the CPU to protected mode, but the instruction prefetch queue still contains real-mode instructions. A far jump flushes this queue and loads the correct protected-mode code segment.</p>\n<hr>\n<h2 id=\"stage-1-the-bootloader\">Stage 1: The Bootloader</h2>\n<p>The bootloader has one job: load the kernel from disk and transfer control to it. Let&#39;s trace through the sequence.</p>\n<h3 id=\"the-bios-handoff\">The BIOS Handoff</h3>\n<p>BIOS performs POST (Power-On Self-Test), initializes hardware, then searches for a bootable disk. A disk is bootable if byte 511-512 contain the signature <code>0x55 0xAA</code>. BIOS loads the first 512 bytes to <code>0x7C00</code> and jumps there.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; boot.asm - Stage 1 Bootloader\n[BITS 16]\n[ORG 0x7C00]\n\nstart:\n    ; Disable interrupts during setup\n    cli\n    \n    ; Set up segment registers for real mode\n    xor ax, ax\n    mov ds, ax\n    mov es, ax\n    mov ss, ax\n    mov sp, 0x7C00      ; Stack grows down from bootloader</code></pre></div>\n\n<p>The stack pointer starts at <code>0x7C00</code> and grows downward. We disable interrupts (<code>cli</code>) because we don&#39;t have an interrupt table set up yet—any interrupt would crash the system.</p>\n<h3 id=\"enabling-the-a20-line\">Enabling the A20 Line</h3>\n<p>The A20 line is a historical artifact from the 8086/8088 era. The 8086 could only address 1MB, but address calculation could wrap around. Some software relied on this behavior, so when the 286 introduced 24-bit addressing, the A20 line was gated.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>enable_a20:\n    ; Method 1: Fast A20 (port 0x92)\n    in al, 0x92\n    or al, 2            ; Set A20 bit\n    out 0x92, al\n    \n    ; Alternative: Keyboard controller method (slower but more compatible)\n    ; call kbc_enable_a20</code></pre></div>\n\n<p>The fast A20 method uses I/O port <code>0x92</code>. Setting bit 1 enables the A20 line. This works on most modern hardware and emulators like QEMU.</p>\n<h3 id=\"loading-the-kernel-from-disk\">Loading the Kernel from Disk</h3>\n<p>The kernel binary lives on disk, starting at some known sector. We use BIOS INT 13h to read sectors into memory.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>load_kernel:\n    ; Load kernel at 0x100000 (1MB mark)\n    ; We need to use extended BIOS reads for addresses above 1MB\n    \n    mov si, dap          ; Disk Address Packet\n    mov ah, 0x42         ; Extended read function\n    mov dl, 0x80         ; First hard drive\n    int 0x13\n    jc disk_error\n\n; Disk Address Packet (DAP)\ndap:\n    db 0x10              ; Size of packet (16 bytes)\n    db 0x00              ; Reserved\n    dw 50                ; Number of sectors to read (adjust for kernel size)\n    dw 0x0000, 0x1000    ; Buffer address: 0x10000 (segment:offset for real mode)\n                          ; We'll copy to 0x100000 after enabling protected mode\n    dq 1                 ; Starting LBA (sector 1, after MBR)</code></pre></div>\n\n<p>Wait—there&#39;s a problem. In real mode, we can only address up to 1MB directly. The kernel needs to be at <code>0x100000</code> (1MB). How do we load it there?</p>\n<p><strong>Solution</strong>: We load the kernel to a temporary buffer below 1MB, enable protected mode, then copy it to its final destination.</p>\n<h3 id=\"the-gdt-your-translation-table\">The GDT: Your Translation Table</h3>\n<p>Before entering protected mode, we must configure the Global Descriptor Table. The GDT defines memory segments—their base addresses, limits, and access permissions.</p>\n<p>{{DIAGRAM:diag-gdt-layout}}</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; GDT Layout\ngdt_start:\n    ; Null descriptor (required)\n    dq 0x0000000000000000\n\ngdt_kernel_code:\n    ; Kernel code segment: base=0, limit=0xFFFFF, 4KB granularity\n    ; Access: present, ring 0, executable, readable\n    dq 0x00CF9A000000FFFF\n\ngdt_kernel_data:\n    ; Kernel data segment: base=0, limit=0xFFFFF, 4KB granularity\n    ; Access: present, ring 0, writable\n    dq 0x00CF92000000FFFF\n\ngdt_user_code:\n    ; User code segment: ring 3, executable, readable\n    dq 0x00CFFA000000FFFF\n\ngdt_user_data:\n    ; User data segment: ring 3, writable\n    dq 0x00CFF2000000FFFF\n\ngdt_end:\n\ngdt_descriptor:\n    dw gdt_end - gdt_start - 1   ; GDT size (limit)\n    dd gdt_start                  ; GDT linear address</code></pre></div>\n\n<p>Let&#39;s decode the kernel code descriptor byte-by-byte:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>0x00CF9A000000FFFF\n\nLow 16 bits of limit:     0xFFFF  (65535)\nBase address (bits 16-31): 0x0000\nBase address (bits 32-39): 0x00\nAccess byte:              0x9A    = 10011010\n  - Present (P):          1       (segment is valid)\n  - DPL (privilege):      00      (ring 0)\n  - System (S):           1       (code/data segment, not system)\n  - Executable (E):       1       (code segment)\n  - Direction (DC):       0       (grows up)\n  - Readable (R):         1       (can read)\n  - Accessed (A):         0       (CPU sets this)\nFlags + limit (bits 48-51): 0xC   = 1100\n  - Granularity (G):      1       (4KB blocks, limit * 4096)\n  - Size (D/B):           1       (32-bit)\n  - Long (L):             0       (not 64-bit)\nHigh 4 bits of limit:     0xF\nBase address (bits 56-63): 0x00</code></pre></div>\n\n<p>With granularity=4KB and limit=0xFFFFF, the segment spans <code>0xFFFFF * 4096 = 4GB</code>. Base=0 means linear addresses equal virtual addresses—<strong>flat addressing</strong>. This makes segmentation a no-op and lets paging (Milestone 3) handle all address translation.</p>\n<blockquote>\n<p><strong>Segmentation vs. Paging</strong></p>\n<p>Both are address translation mechanisms, but they serve different purposes:</p>\n<p><strong>Segmentation</strong> divides memory into variable-sized logical units (code, data, stack). Each segment has a base address and limit. The CPU checks every access against segment bounds. Segmentation is mandatory in x86—you can&#39;t disable it.</p>\n<p><strong>Paging</strong> divides memory into fixed-size 4KB pages. It provides finer-grained protection (per-page) and enables virtual memory (swapping to disk). Paging is optional in 32-bit mode.</p>\n<p>The trick: by setting all segment bases to 0 and limits to 4GB, segmentation becomes a no-op. Every linear address passes through unchanged. This is called <strong>flat addressing</strong>, and it lets paging be the sole translation mechanism. Modern OSes use this approach.</p>\n</blockquote>\n<h3 id=\"entering-protected-mode\">Entering Protected Mode</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>enter_protected_mode:\n    ; Load the GDT\n    lgdt [gdt_descriptor]\n    \n    ; Set CR0.PE bit (Protection Enable)\n    mov eax, cr0\n    or eax, 1\n    mov cr0, eax\n    \n    ; FAR JUMP - This is NOT optional!\n    ; Flushes the prefetch queue and loads CS with kernel code selector\n    jmp 0x08:protected_mode_entry\n\n[BITS 32]\nprotected_mode_entry:\n    ; Now in 32-bit protected mode!\n    ; Load all data segment registers with kernel data selector (0x10)\n    mov ax, 0x10         ; Kernel data selector (index 2 * 8 = 0x10)\n    mov ds, ax\n    mov es, ax\n    mov fs, ax\n    mov gs, ax\n    mov ss, ax\n    mov esp, 0x90000     ; Set up kernel stack\n    \n    ; Copy kernel from temporary buffer to 0x100000\n    ; (implementation depends on where you loaded it)\n    \n    ; Jump to kernel entry point\n    jmp 0x08:0x100000</code></pre></div>\n\n<p>The far jump <code>jmp 0x08:protected_mode_entry</code> is critical:</p>\n<ul>\n<li><code>0x08</code> is the segment selector for the kernel code segment (GDT index 1, RPL=0, TI=0)</li>\n<li>This loads CS with the protected-mode selector and flushes the pipeline</li>\n<li>Without it, the CPU continues executing real-mode code with a corrupted state</li>\n</ul>\n<hr>\n<h2 id=\"stage-2-the-kernel-entry-point\">Stage 2: The Kernel Entry Point</h2>\n<p>The kernel is now loaded at <code>0x100000</code> and the CPU is in protected mode. Time to enter C.</p>\n<h3 id=\"the-linker-script-section-placement\">The Linker Script: Section Placement</h3>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-linker-script.svg\" alt=\"Linker Script: Section Placement and Addresses\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">ld</span><pre class=\"arch-pre shiki-highlighted\"><code>/* linker.ld */\nENTRY(kernel_entry)\n\nSECTIONS\n{\n    . = 0x100000;        /* Kernel starts at 1MB */\n    \n    .text : {\n        *(.multiboot)    /* Multiboot header if using GRUB */\n        *(.text)\n    }\n    \n    .rodata : {\n        *(.rodata)\n    }\n    \n    .data : {\n        *(.data)\n    }\n    \n    .bss : {\n        __bss_start = .;\n        *(.COMMON)\n        *(.bss)\n        __bss_end = .;\n    }\n    \n    /DISCARD/ : {\n        *(.comment)\n        *(.eh_frame)\n    }\n}</code></pre></div>\n\n<p>The linker script defines where each section goes in memory. <code>.text</code> contains code, <code>.rodata</code> contains read-only data, <code>.data</code> contains initialized global variables, and <code>.bss</code> contains uninitialized globals.</p>\n<h3 id=\"zeroing-bss-your-responsibility\">Zeroing BSS: Your Responsibility</h3>\n<p>In a hosted C environment (userspace), the C runtime (CRT0) zeros the BSS section before calling <code>main()</code>. In freestanding mode (kernel), there&#39;s no CRT0—BSS contains garbage until you zero it.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* kernel_entry.asm */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">[BITS </span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">[GLOBAL kernel_entry]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">[EXTERN kernel_main]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">[EXTERN __bss_start]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">[EXTERN __bss_end]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">kernel_entry:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ; Zero the BSS section</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mov edi, __bss_start</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mov ecx, __bss_end</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sub ecx, edi</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    xor eax, eax</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rep stosb</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ; Call kernel main</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    call kernel_main</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ; Halt </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> kernel_main </span><span style=\"color:#B392F0\">returns</span><span style=\"color:#E1E4E8\"> (it shouldn</span><span style=\"color:#9ECBFF\">'t)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    cli</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">.halt:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    hlt</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    jmp .halt</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* main.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"vga.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"serial.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> kernel_main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    serial_init</span><span style=\"color:#E1E4E8\">(COM1_PORT);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Welcome to MyOS!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Kernel loaded at 0x100000</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Kernel continues...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"stage-3-output-drivers\">Stage 3: Output Drivers</h2>\n<p>You need to see what&#39;s happening. Two output mechanisms: VGA text mode (screen) and serial port (debugging).</p>\n<h3 id=\"vga-text-mode\">VGA Text Mode</h3>\n<p>VGA text mode is memory-mapped at <code>0xB8000</code>. Each character cell is 2 bytes: character + attribute (color).</p>\n<p>{{DIAGRAM:diag-vga-serial-dual}}</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* vga.h */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> VGA_BUFFER</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> uint16_t*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">B8000</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> VGA_WIDTH</span><span style=\"color:#79B8FF\"> 80</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> VGA_HEIGHT</span><span style=\"color:#79B8FF\"> 25</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VGA_COLOR_BLACK </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VGA_COLOR_BLUE </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VGA_COLOR_GREEN </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VGA_COLOR_CYAN </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VGA_COLOR_RED </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VGA_COLOR_MAGENTA </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VGA_COLOR_BROWN </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VGA_COLOR_LIGHT_GREY </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 7</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VGA_COLOR_WHITE </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 15</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">vga_color_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint16_t</span><span style=\"color:#B392F0\"> vga_entry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> c</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">vga_color_t</span><span style=\"color:#FFAB70\"> fg</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">vga_color_t</span><span style=\"color:#FFAB70\"> bg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\">)c </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\">)(fg </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> (bg </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vga_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vga_putchar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> c</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> str</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* vga.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"vga.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#E1E4E8\"> vga_row </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#E1E4E8\"> vga_col </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> vga_color_t</span><span style=\"color:#E1E4E8\"> current_fg </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> VGA_COLOR_WHITE;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> vga_color_t</span><span style=\"color:#E1E4E8\"> current_bg </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> VGA_COLOR_BLACK;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vga_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Clear screen</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> VGA_WIDTH </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> VGA_HEIGHT; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        VGA_BUFFER</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> vga_entry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">' '</span><span style=\"color:#E1E4E8\">, current_fg, current_bg);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vga_row </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vga_col </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vga_putchar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> c</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (c </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vga_col </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vga_row</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (vga_row </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> VGA_HEIGHT) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Scroll up (implement if needed)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            vga_row </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> VGA_HEIGHT </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> index </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> vga_row </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> VGA_WIDTH </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> vga_col;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    VGA_BUFFER</span><span style=\"color:#E1E4E8\">[index] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> vga_entry</span><span style=\"color:#E1E4E8\">(c, current_fg, current_bg);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vga_col</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (vga_col </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> VGA_WIDTH) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vga_col </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vga_row</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"serial-port-com1\">Serial Port (COM1)</h3>\n<p>Serial output goes to <code>0x3F8</code>. In QEMU, this appears in the console with <code>-serial stdio</code>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* serial.h */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> COM1_PORT</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">3F8</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> serial_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> serial_putchar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> c</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> serial_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> str</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* serial.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"serial.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"port_io.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> serial_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(port </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">    // Disable interrupts</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(port </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">    // Enable DLAB</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(port </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">03</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">    // Divisor low byte (38400 baud)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(port </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">    // Divisor high byte</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(port </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">03</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">    // 8 bits, no parity, one stop bit</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(port </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">C7</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">    // Enable FIFO</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(port </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">0B</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">    // IRQs enabled, RTS/DSR set</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> serial_is_transmit_empty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> inb</span><span style=\"color:#E1E4E8\">(port </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> serial_putchar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> c</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">serial_is_transmit_empty</span><span style=\"color:#E1E4E8\">(port) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(port, c);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* port_io.h */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> outb</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> val</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">outb %0, %1</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">a</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(val), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">Nd</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(port));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint8_t</span><span style=\"color:#B392F0\"> inb</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">inb %1, %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=a</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(ret) : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">Nd</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(port));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"combined-output-kprintf\">Combined Output: kprintf</h3>\n<p>A minimal printf that outputs to both VGA and serial:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* kprintf.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdarg.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"vga.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"serial.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> print_string</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> str</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">str) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_putchar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">str);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        serial_putchar</span><span style=\"color:#E1E4E8\">(COM1_PORT, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">str);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        str</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> fmt</span><span style=\"color:#E1E4E8\">, ...) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    va_list args;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    va_start</span><span style=\"color:#E1E4E8\">(args, fmt);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Minimal implementation - handle %s, %d, %x, %c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">fmt) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">fmt </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '%'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            fmt</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            switch</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">fmt) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                case</span><span style=\"color:#9ECBFF\"> 's'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    print_string</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">va_arg</span><span style=\"color:#E1E4E8\">(args, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                case</span><span style=\"color:#9ECBFF\"> 'd'</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    int</span><span style=\"color:#E1E4E8\"> val </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> va_arg</span><span style=\"color:#E1E4E8\">(args, </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // Convert to string (implement itoa)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                case</span><span style=\"color:#9ECBFF\"> 'x'</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    unsigned</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> val </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> va_arg</span><span style=\"color:#E1E4E8\">(args, </span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // Convert to hex string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                case</span><span style=\"color:#9ECBFF\"> 'c'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    vga_putchar</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">va_arg</span><span style=\"color:#E1E4E8\">(args, </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    serial_putchar</span><span style=\"color:#E1E4E8\">(COM1_PORT, (</span><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">va_arg</span><span style=\"color:#E1E4E8\">(args, </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            vga_putchar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">fmt);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            serial_putchar</span><span style=\"color:#E1E4E8\">(COM1_PORT, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">fmt);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        fmt</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    va_end</span><span style=\"color:#E1E4E8\">(args);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"testing-in-qemu\">Testing in QEMU</h2>\n<p>Build and run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Assemble bootloader</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">nasm</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> bin</span><span style=\"color:#9ECBFF\"> boot.asm</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> boot.bin</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Compile kernel</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -m32</span><span style=\"color:#79B8FF\"> -ffreestanding</span><span style=\"color:#79B8FF\"> -nostdlib</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> main.c</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> main.o</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -m32</span><span style=\"color:#79B8FF\"> -ffreestanding</span><span style=\"color:#79B8FF\"> -nostdlib</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> vga.c</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> vga.o</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -m32</span><span style=\"color:#79B8FF\"> -ffreestanding</span><span style=\"color:#79B8FF\"> -nostdlib</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> serial.c</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> serial.o</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Link kernel</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ld</span><span style=\"color:#79B8FF\"> -T</span><span style=\"color:#9ECBFF\"> linker.ld</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> kernel.elf</span><span style=\"color:#9ECBFF\"> main.o</span><span style=\"color:#9ECBFF\"> vga.o</span><span style=\"color:#9ECBFF\"> serial.o</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Extract raw binary</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">objcopy</span><span style=\"color:#79B8FF\"> -O</span><span style=\"color:#9ECBFF\"> binary</span><span style=\"color:#9ECBFF\"> kernel.elf</span><span style=\"color:#9ECBFF\"> kernel.bin</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create disk image (bootloader + kernel)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> boot.bin</span><span style=\"color:#9ECBFF\"> kernel.bin</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> os.img</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run in QEMU</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> -serial</span><span style=\"color:#9ECBFF\"> stdio</span></span></code></pre></div>\n\n<p>You should see &quot;Welcome to MyOS!&quot; on both the VGA display and the serial console.</p>\n<hr>\n<h2 id=\"the-three-level-view-what-happens-when-you-call-vga_putchar\">The Three-Level View: What Happens When You Call vga_putchar</h2>\n<p><strong>Level 1 — Application (Your Code)</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">vga_putchar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'A'</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<p>A simple function call. You&#39;re writing a character to the screen.</p>\n<p><strong>Level 2 — Memory Bus (Hardware Interface)</strong>:\nThe CPU writes a 16-bit value to physical address <code>0xB8000 + offset</code>. This address is in the VGA controller&#39;s memory-mapped I/O region. The write travels over the memory bus to the VGA hardware, not to RAM.</p>\n<p><strong>Level 3 — Hardware (VGA Controller)</strong>:\nThe VGA controller continuously scans its text buffer, converting character/attribute pairs to analog RGB signals. Each scan (60+ times per second) reads the buffer and generates the video signal. Your write is visible on the next scan.</p>\n<hr>\n<h2 id=\"common-pitfalls-and-debugging\">Common Pitfalls and Debugging</h2>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Triple fault immediately after <code>mov cr0, eax</code></td>\n<td>No far jump to flush pipeline</td>\n<td>Add <code>jmp 0x08:protected_mode_entry</code></td>\n</tr>\n<tr>\n<td>Triple fault when accessing memory above 1MB</td>\n<td>A20 not enabled</td>\n<td>Enable A20 via port 0x92 or keyboard controller</td>\n</tr>\n<tr>\n<td>Garbage on screen</td>\n<td>Wrong VGA address or attribute bytes</td>\n<td>Verify <code>0xB8000</code> and check color encoding</td>\n</tr>\n<tr>\n<td>Kernel hangs, no output</td>\n<td>Serial not initialized or BSS not zeroed</td>\n<td>Check serial_init() call order</td>\n</tr>\n<tr>\n<td>Linker error: undefined references</td>\n<td>Missing freestanding flags</td>\n<td>Use <code>-ffreestanding -nostdlib</code></td>\n</tr>\n</tbody></table>\n<p><strong>Debugging with GDB</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> -serial</span><span style=\"color:#9ECBFF\"> stdio</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#79B8FF\"> -S</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># In another terminal:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gdb</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">gdb</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">target</span><span style=\"color:#9ECBFF\"> remote</span><span style=\"color:#9ECBFF\"> localhost:1234</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">gdb</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">break</span><span style=\"color:#79B8FF\"> *</span><span style=\"color:#9ECBFF\">0x7C00</span><span style=\"color:#6A737D\">      # Break at bootloader entry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">gdb</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">break</span><span style=\"color:#79B8FF\"> *</span><span style=\"color:#9ECBFF\">0x100000</span><span style=\"color:#6A737D\">    # Break at kernel entry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">gdb</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">continue</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"knowledge-cascade\">Knowledge Cascade</h2>\n<p>You&#39;ve built the bootstrap layer of an operating system. Here&#39;s where this knowledge connects:</p>\n<p><strong>→ Page Tables (Milestone 3)</strong>: The GDT you configured uses flat addressing (base=0, limit=4GB). This means segmentation does nothing—every linear address passes through unchanged. When you enable paging, page tables become the sole translation mechanism. The GDT stays the same; CR3 points to a page directory instead.</p>\n<p><strong>→ ELF Loaders (Cross-Domain: Compilers and Linkers)</strong>: Your linker script places <code>.text</code>, <code>.data</code>, and <code>.bss</code> at specific addresses. This is exactly what an ELF loader does when loading a userspace program—it reads section headers and maps them to virtual addresses. You&#39;re implementing the same logic that <code>/lib/ld-linux.so</code> performs for every executable.</p>\n<p><strong>→ UEFI vs. BIOS (Cross-Domain: Firmware Security)</strong>: Modern systems use UEFI instead of BIOS. UEFI starts the CPU in protected mode (or long mode) with paging enabled—no real mode transition needed. But UEFI still requires GDT and page table configuration. Secure Boot adds cryptographic verification: the firmware checks signatures on the bootloader before executing it. The same boot chain you built, but with cryptographic attestation.</p>\n<p><strong>→ Virtualization (Cross-Domain: Cloud Infrastructure)</strong>: Hypervisors like KVM and Xen virtualize the same hardware you&#39;re programming. When a VM writes to its GDT, the hypervisor intercepts the <code>lgdt</code> instruction and maintains a &quot;shadow GDT&quot; or uses hardware-assisted virtualization (VMX/SVM). The VM&#39;s CR3 points to guest-physical pages; the hypervisor maintains nested page tables (EPT/NPT) that translate guest-physical to host-physical addresses. You&#39;re building the same translation layers that hypervisors virtualize.</p>\n<p><strong>→ JIT Compilation (Cross-Domain: Language Runtimes)</strong>: When a JIT compiler generates machine code at runtime, it must write code bytes to memory and then execute them. This requires understanding memory protection: the page must be writable to store the code, then executable to run it. The same segment descriptor flags (readable, writable, executable) you configured in the GDT apply to page table entries. Modern systems use W^X (write XOR execute) protection, requiring mprotect() calls to change page permissions—directly manipulating the same hardware flags you&#39;re setting up.</p>\n<hr>\n<p>[[CRITERIA_JSON: {&quot;milestone_id&quot;: &quot;build-os-m1&quot;, &quot;criteria&quot;: [&quot;Bootloader fits in 512 bytes (MBR) or uses a two-stage approach with stage1 in MBR loading stage2 from disk&quot;, &quot;Bootloader reads kernel binary from disk using BIOS INT 13h and loads it to physical address 0x100000 (1MB mark)&quot;, &quot;GDT configured with 5 entries: null descriptor, kernel code (ring 0, base=0, limit=4GB, executable+readable), kernel data (ring 0, base=0, limit=4GB, writable), user code (ring 3), user data (ring 3)&quot;, &quot;Protected mode entered by setting CR0.PE bit after loading GDTR, followed by a far jump to kernel code segment to flush the pipeline&quot;, &quot;Segment registers DS, ES, FS, GS, SS loaded with kernel data segment selector (0x10) after the far jump to protected mode&quot;, &quot;Kernel entry point (assembly) zeroes BSS section from __bss_start to __bss_end and calls kernel_main()&quot;, &quot;VGA text mode driver writes characters with foreground/background color attributes to memory-mapped buffer at 0xB8000&quot;, &quot;Serial port COM1 (0x3F8) initialized for debug output with kprintf-like function outputting to both VGA and serial&quot;, &quot;Kernel boots successfully in QEMU displaying welcome message on screen and serial console&quot;]}]</p>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-os-m2 -->\n<h1 id=\"milestone-2-interrupts-exceptions-and-keyboard\">Milestone 2: Interrupts, Exceptions, and Keyboard</h1>\n<h2 id=\"the-heartbeat-of-a-reactive-system\">The Heartbeat of a Reactive System</h2>\n<p>Your kernel boots. It displays a welcome message. And then... it sits there. Frozen. Not because it crashed—it&#39;s just waiting. Waiting for you to type something. Waiting for time to pass. Waiting for the hardware to signal that something happened.</p>\n<p>This milestone transforms your kernel from a passive program into a reactive system. The mechanism is <strong>interrupts</strong>: hardware signals that pause whatever code is running, jump to a handler you define, and then resume. The CPU does this automatically—you just need to tell it <em>where</em> to jump.</p>\n<h3 id=\"the-fundamental-tension\">The Fundamental Tension</h3>\n<p><strong>Constraint 1: Asynchronous Events Demand Immediate Response</strong></p>\n<p>The keyboard doesn&#39;t wait for your code to poll it. When you press a key, the keyboard controller generates an electrical signal that must be handled <em>now</em>—the scancode buffer is tiny, and missed keystrokes are lost forever. The timer doesn&#39;t ask permission before ticking. Hardware is asynchronous, and your code must be ready.</p>\n<p><strong>Constraint 2: The CPU Pushes Minimal State</strong></p>\n<p>When an interrupt fires, the CPU pushes exactly three things: <code>EIP</code> (instruction pointer), <code>CS</code> (code segment), and <code>EFLAGS</code> (processor flags). That&#39;s it. Your handler receives control with <em>all general-purpose registers containing garbage from the interrupted code</em>. If you modify <code>EAX</code> without saving it first, you&#39;ve corrupted whatever the interrupted code was doing.</p>\n<p><strong>Constraint 3: The PIC&#39;s Default Mapping Is Broken</strong></p>\n<p>The 8259 Programmable Interrupt Controller maps IRQ0-7 to CPU vectors 8-15 by default. But vectors 8-15 are reserved for CPU exceptions—vector 8 is the Double Fault! Without remapping, a timer tick looks exactly like a catastrophic system failure.</p>\n<p><strong>Constraint 4: EOI Is Not Optional</strong></p>\n<p>The PIC tracks which interrupts are &quot;in service.&quot; After your handler finishes, you <em>must</em> send End of Interrupt (EOI). Without it, the PIC blocks all lower-priority interrupts forever. The system doesn&#39;t crash—it just stops responding to input.</p>\n<hr>\n<h2 id=\"the-revelation-interrupts-are-not-function-pointers\">The Revelation: Interrupts Are Not Function Pointers</h2>\n<p>{{DIAGRAM:diag-idt-entry-layout}}</p>\n<p>If you&#39;ve written event-driven code in userspace, you might think interrupts work like this:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG MENTAL MODEL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> on_timer</span><span style=\"color:#E1E4E8\">() { tick_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> on_keyboard</span><span style=\"color:#E1E4E8\">() { </span><span style=\"color:#B392F0\">read_key</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">register_callback</span><span style=\"color:#E1E4E8\">(TIMER_IRQ, on_timer);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">register_callback</span><span style=\"color:#E1E4E8\">(KEYBOARD_IRQ, on_keyboard);</span></span></code></pre></div>\n\n<p>This is a comforting abstraction, but it hides critical details that will crash your kernel:</p>\n<ol>\n<li><p><strong>The IDT contains gate descriptors, not function pointers.</strong> Each 8-byte entry specifies a handler address, a code segment selector, privilege level, and gate type (interrupt vs. trap). The CPU validates all of this before jumping.</p>\n</li>\n<li><p><strong>The CPU pushes an error code for some exceptions.</strong> Exceptions 8, 10, 11, 12, 13, 14, 17, 21, 29, and 30 push an additional error code onto the stack. Your handler must account for this, or <code>iret</code> will return to garbage.</p>\n</li>\n<li><p><strong>Interrupts run on the current stack.</strong> If a userspace process has a 4KB stack and your handler uses 5KB of local variables, you&#39;ve corrupted adjacent memory. This is why kernel code must be stack-disciplined.</p>\n</li>\n<li><p><strong>Interrupt gates disable interrupts automatically; trap gates don&#39;t.</strong> This affects whether your handler can be interrupted by a higher-priority IRQ.</p>\n</li>\n</ol>\n<p>Let&#39;s build the real thing.</p>\n<hr>\n<h2 id=\"stage-1-the-interrupt-descriptor-table\">Stage 1: The Interrupt Descriptor Table</h2>\n<p>The IDT is an array of 256 gate descriptors. Each descriptor tells the CPU: &quot;when interrupt N happens, jump to this address in this code segment.&quot;</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* idt.h */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> IDT_ENTRIES</span><span style=\"color:#79B8FF\"> 256</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> offset_low;</span><span style=\"color:#6A737D\">    // Lower 16 bits of handler address</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> selector;</span><span style=\"color:#6A737D\">      // Kernel code segment selector</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\">  zero;</span><span style=\"color:#6A737D\">          // Reserved, must be 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\">  type_attr;</span><span style=\"color:#6A737D\">     // Gate type, DPL, present bit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> offset_high;</span><span style=\"color:#6A737D\">   // Upper 16 bits of handler address</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed)) </span><span style=\"color:#79B8FF\">idt_entry_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> limit;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> base;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed)) </span><span style=\"color:#79B8FF\">idt_ptr_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> idt_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> handler</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> selector</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> flags</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p>The <code>type_attr</code> byte encodes the gate type and privilege level:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Bit 7:    Present (1 = valid gate)\nBits 5-6: DPL (Descriptor Privilege Level) - 00 for kernel\nBit 4:    Storage segment (0 for interrupt/trap gates)\nBits 0-3: Gate type:\n          0xE = 32-bit interrupt gate (disables interrupts on entry)\n          0xF = 32-bit trap gate (keeps interrupts enabled)</code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* idt.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"idt.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> idt_entry_t</span><span style=\"color:#FFAB70\"> idt</span><span style=\"color:#E1E4E8\">[IDT_ENTRIES];</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">idt_ptr_t</span><span style=\"color:#E1E4E8\"> idt_ptr;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> handler</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> selector</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> flags</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    idt</span><span style=\"color:#E1E4E8\">[num].offset_low  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> handler </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    idt</span><span style=\"color:#E1E4E8\">[num].offset_high </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (handler </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    idt</span><span style=\"color:#E1E4E8\">[num].selector    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> selector;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    idt</span><span style=\"color:#E1E4E8\">[num].zero        </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    idt</span><span style=\"color:#E1E4E8\">[num].type_attr   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> flags;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> idt_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    idt_ptr.limit </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(idt) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    idt_ptr.base  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">idt;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Load IDT</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">lidt %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">m</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(idt_ptr));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"stage-2-interrupt-handlers-and-the-stack-frame\">Stage 2: Interrupt Handlers and the Stack Frame</h2>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-interrupt-stack-frame.svg\" alt=\"Interrupt Stack Frame: CPU-Pushed vs. Handler-Pushed\"></p>\n<p>When an interrupt fires, the CPU performs this sequence:</p>\n<ol>\n<li><strong>Pushes EFLAGS, CS, EIP</strong> (and error code for some exceptions)</li>\n<li><strong>Loads CS:EIP from the IDT entry</strong></li>\n<li><strong>For interrupt gates: clears the IF flag</strong> (disables interrupts)</li>\n</ol>\n<p>Your handler must save <em>all</em> registers it will modify, do its work, restore registers, then execute <code>iret</code> (not <code>ret</code>!).</p>\n<h3 id=\"the-assembly-wrapper\">The Assembly Wrapper</h3>\n<p>The cleanest pattern is an assembly wrapper that saves/restores registers and calls a C function:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; interrupt.asm\n[BITS 32]\n\n; Common interrupt stub - saves context, calls C handler, restores context\nextern c_interrupt_handler\n\nglobal isr_common_stub\nisr_common_stub:\n    pusha                    ; Pushes EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI\n    push ds\n    push es\n    push fs\n    push gs\n    \n    mov ax, 0x10             ; Load kernel data segment\n    mov ds, ax\n    mov es, ax\n    mov fs, ax\n    mov gs, ax\n    \n    push esp                 ; Pass stack pointer to C handler\n    call c_interrupt_handler\n    add esp, 4               ; Clean up argument\n    \n    pop gs\n    pop fs\n    pop es\n    pop ds\n    popa\n    add esp, 8               ; Clean up error code and interrupt number\n    iret                     ; Restores EIP, CS, EFLAGS</code></pre></div>\n\n<h3 id=\"cpu-exception-handlers-vectors-0-31\">CPU Exception Handlers (Vectors 0-31)</h3>\n<p>CPU exceptions are synchronous—they occur in response to instruction execution. Some push an error code; some don&#39;t.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; Exception handlers - no error code pushed by CPU\nglobal isr0   ; Divide by zero\nglobal isr1   ; Debug\nglobal isr2   ; NMI\nglobal isr3   ; Breakpoint\n; ... (handlers 0-31)\n\n; Macros for cleaner definition\n%macro ISR_NO_ERROR 1\nglobal isr%1\nisr%1:\n    cli\n    push byte 0            ; Dummy error code to unify stack frame\n    push byte %1           ; Interrupt number\n    jmp isr_common_stub\n%endmacro\n\n%macro ISR_ERROR 1\nglobal isr%1\nisr%1:\n    cli\n    push byte %1           ; Interrupt number (error code already pushed by CPU)\n    jmp isr_common_stub\n%endmacro\n\n; CPU exceptions without error codes\nISR_NO_ERROR 0    ; Divide by zero\nISR_NO_ERROR 1    ; Debug\nISR_NO_ERROR 2    ; Non-maskable interrupt\nISR_NO_ERROR 3    ; Breakpoint\nISR_NO_ERROR 4    ; Overflow\nISR_NO_ERROR 5    ; Bound range exceeded\nISR_NO_ERROR 6    ; Invalid opcode\nISR_NO_ERROR 7    ; Device not available\nISR_NO_ERROR 9    ; Coprocessor segment overrun\n\n; CPU exceptions with error codes (CPU pushes the error code)\nISR_ERROR 8       ; Double fault\nISR_ERROR 10      ; Invalid TSS\nISR_ERROR 11      ; Segment not present\nISR_ERROR 12      ; Stack-segment fault\nISR_ERROR 13      ; General protection fault\nISR_ERROR 14      ; Page fault</code></pre></div>\n\n\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-exception-handling.svg\" alt=\"CPU Exception Flow: Divide Error to Handler\"></p>\n<p>The dummy error code for exceptions 0-7, 9, etc. ensures a uniform stack frame. Every handler can use the same restoration code.</p>\n<h3 id=\"the-c-handler\">The C Handler</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* interrupt.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"interrupt.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"vga.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> gs, fs, es, ds;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> edi, esi, ebp, esp, ebx, edx, ecx, eax;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> int_no, err_code;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eip, cs, eflags;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> useresp, ss;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed)) </span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> c_interrupt_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (regs->int_no </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // CPU exception</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exception_handler</span><span style=\"color:#E1E4E8\">(regs);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (regs->int_no </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> regs->int_no </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 48</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hardware IRQ (IRQ0-15 mapped to vectors 32-47)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        irq_handler</span><span style=\"color:#E1E4E8\">(regs);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Ignore spurious interrupts (int_no >= 48)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">exception_messages</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"Division by zero\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"Debug\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"Non-maskable interrupt\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"Breakpoint\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"Overflow\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"Bound range exceeded\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"Invalid opcode\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"Device not available\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"Double fault\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"Coprocessor segment overrun\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"Invalid TSS\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"Segment not present\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"Stack-segment fault\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"General protection fault\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"Page fault\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"Reserved\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... 16-31 are reserved</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> exception_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">EXCEPTION: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> (vector </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            exception_messages</span><span style=\"color:#E1E4E8\">[regs->int_no], regs->int_no);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Error code: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, regs->err_code);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"EIP: 0x</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\">, CS: 0x</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\">, EFLAGS: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            regs->eip, regs->cs, regs->eflags);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (regs->int_no </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 14</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Page fault - read CR2 for faulting address</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> fault_addr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %%cr2, %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(fault_addr));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Faulting address: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, fault_addr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Decode error code bits</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Present: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, Write: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, User: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                regs->err_code </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                (regs->err_code </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                (regs->err_code </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Halt on exception (for now)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"System halted.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">cli; hlt</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"double-fault-the-last-line-of-defense\">Double Fault: The Last Line of Defense</h3>\n<p>A double fault occurs when an exception happens while the CPU is trying to invoke another exception handler. The most common causes:</p>\n<ul>\n<li>Stack corruption (handler can&#39;t push to stack)</li>\n<li>Page fault while reading the IDT</li>\n<li>Invalid gate descriptor</li>\n</ul>\n<p>Without a double fault handler, the CPU triple-faults and resets.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> double_fault_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">!!! DOUBLE FAULT !!!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"This indicates a cascading failure.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Error code: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, regs->err_code);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Kernel stack may be corrupted.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"System halted.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Don't try to recover - state is undefined</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">cli; hlt</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"stage-3-remapping-the-pic\">Stage 3: Remapping the PIC</h2>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-pic-remapping.svg\" alt=\"PIC Remapping: IRQ to Vector Translation\"></p>\n<p>The 8259 PIC has two chips: master (IRQ0-7) and slave (IRQ8-15). By default:</p>\n<ul>\n<li>Master maps IRQ0-7 → vectors 0x08-0x0F</li>\n<li>Slave maps IRQ8-15 → vectors 0x70-0x77</li>\n</ul>\n<p>This is catastrophic. Vector 8 is the Double Fault exception! A timer tick (IRQ0) would trigger the double fault handler.</p>\n<p><strong>Remap to vectors 32-47</strong> (above the 32 CPU exceptions):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* pic.h */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIC1_COMMAND</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#6A737D\">    // Master PIC command port</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIC1_DATA</span><span style=\"color:#F97583\">    0x</span><span style=\"color:#79B8FF\">21</span><span style=\"color:#6A737D\">    // Master PIC data port</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIC2_COMMAND</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">A0</span><span style=\"color:#6A737D\">    // Slave PIC command port</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIC2_DATA</span><span style=\"color:#F97583\">    0x</span><span style=\"color:#79B8FF\">A1</span><span style=\"color:#6A737D\">    // Slave PIC data port</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIC_EOI</span><span style=\"color:#F97583\">      0x</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#6A737D\">    // End of Interrupt command</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pic_remap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> offset1, </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> offset2);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pic_send_eoi</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> irq</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p>The PIC is programmed via Initialization Command Words (ICW1-ICW4):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* pic.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"pic.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"port_io.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pic_remap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> offset1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> offset2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ICW1: Start initialization, cascade mode, need ICW4</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC1_COMMAND, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">11</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC2_COMMAND, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">11</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ICW2: Vector offset (where IRQs map to)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC1_DATA, offset1);</span><span style=\"color:#6A737D\">    // Master: IRQ0-7 → vectors 32-39</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC2_DATA, offset2);</span><span style=\"color:#6A737D\">    // Slave: IRQ8-15 → vectors 40-47</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ICW3: Tell master there's a slave at IRQ2 (bitmask 0x04)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //       Tell slave its cascade identity is 2</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC1_DATA, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">04</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC2_DATA, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">02</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ICW4: 8086 mode, normal EOI</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC1_DATA, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">01</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC2_DATA, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">01</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Clear data registers (no IRQs masked)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC1_DATA, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC2_DATA, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pic_send_eoi</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> irq</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (irq </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // IRQ came from slave - send EOI to both</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        outb</span><span style=\"color:#E1E4E8\">(PIC2_COMMAND, PIC_EOI);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Always send EOI to master</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC1_COMMAND, PIC_EOI);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"eoi-timing-why-forgetting-it-freezes-the-system\">EOI Timing: Why Forgetting It Freezes the System</h3>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-eoi-timing.svg\" alt=\"EOI Timing: Why Forgetting EOI Freezes the System\"></p>\n<p>The PIC maintains an In-Service Register (ISR) that tracks which IRQs are being handled. When an IRQ fires:</p>\n<ol>\n<li>PIC sets the corresponding bit in ISR</li>\n<li>PIC raises INTR to CPU</li>\n<li>CPU acknowledges, PIC sends vector number</li>\n<li><strong>PIC now blocks all lower-priority IRQs</strong> until EOI is received</li>\n</ol>\n<p>If your timer handler forgets EOI:</p>\n<ul>\n<li>IRQ0 is still marked &quot;in service&quot;</li>\n<li>Keyboard (IRQ1, lower priority) is blocked</li>\n<li>System appears frozen—it&#39;s not crashed, just deaf</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> irq_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> irq </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> regs->int_no </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Convert vector to IRQ number</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> (irq) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            timer_handler</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            keyboard_handler</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // ... other IRQs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pic_send_eoi</span><span style=\"color:#E1E4E8\">(irq);</span><span style=\"color:#6A737D\">  // CRITICAL: Never forget this!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"stage-4-timer-interrupt-irq0\">Stage 4: Timer Interrupt (IRQ0)</h2>\n<p>The Programmable Interval Timer (PIT) channel 0 is connected to IRQ0. It can fire at frequencies from ~18 Hz to several MHz.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* timer.h */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIT_CHANNEL0</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">40</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIT_COMMAND</span><span style=\"color:#F97583\">  0x</span><span style=\"color:#79B8FF\">43</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIT_FREQUENCY</span><span style=\"color:#79B8FF\"> 1193182</span><span style=\"color:#6A737D\">  // Base frequency in Hz</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#E1E4E8\"> timer_ticks;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> timer_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> frequency</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> timer_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* timer.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"timer.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"port_io.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#E1E4E8\"> timer_ticks </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> timer_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> frequency</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate divisor</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> divisor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PIT_FREQUENCY </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> frequency;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Command byte: channel 0, lobyte/hibyte, square wave mode</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIT_COMMAND, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">36</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Send divisor</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIT_CHANNEL0, divisor </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FF</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">        // Low byte</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIT_CHANNEL0, (divisor </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FF</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\"> // High byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> timer_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timer_ticks</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Every 100 ticks (1 second at 100Hz), print something</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (timer_ticks </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Timer: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> seconds</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, timer_ticks </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>At 100 Hz, the timer fires every 10 milliseconds. This will become the heartbeat of your preemptive scheduler in Milestone 4.</p>\n<hr>\n<h2 id=\"stage-5-ps2-keyboard-driver-irq1\">Stage 5: PS/2 Keyboard Driver (IRQ1)</h2>\n<p>{{DIAGRAM:diag-keyboard-scancode}}</p>\n<p>The keyboard controller sends <strong>scancodes</strong>, not ASCII. When you press &#39;A&#39;, you receive scancode 0x1E. When you release &#39;A&#39;, you receive 0x9E (0x1E | 0x80). The relationship between scancodes and ASCII is arbitrary and layout-dependent.</p>\n<h3 id=\"scancode-to-ascii-translation\">Scancode to ASCII Translation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* keyboard.h */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KEYBOARD_PORT</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">60</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KBUFFER_SIZE</span><span style=\"color:#79B8FF\"> 256</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> keyboard_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> keyboard_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#B392F0\"> keyboard_getchar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\"> keyboard_buffer</span><span style=\"color:#F97583\">[]</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> kb_read_pos;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> kb_write_pos;</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* keyboard.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"keyboard.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"port_io.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// US QWERTY scancode table (scancode set 1)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\"> scancode_to_ascii</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    0</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'1'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'2'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'3'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'4'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'5'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'6'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'7'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'8'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'9'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'0'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'-'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'='</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'q'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'w'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'e'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'r'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'t'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'y'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'u'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'i'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'o'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'p'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'['</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">']'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'a'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'s'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'d'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'f'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'g'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'h'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'j'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'k'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'l'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">';'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\'</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'`'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\\\</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'z'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'x'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'c'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'v'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'b'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'n'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'m'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">','</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'.'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'/'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#9ECBFF\">'*'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">' '</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Shifted versions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\"> scancode_to_ascii_shift</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    0</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'!'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'@'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'#'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'$'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'%'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'^'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'&#x26;'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'*'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'('</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">')'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'_'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'+'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'Q'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'W'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'E'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'R'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'T'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Y'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'U'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'I'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'O'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'P'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'{'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'}'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'A'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'S'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'D'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'F'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'G'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'H'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'J'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'K'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'L'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">':'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'\"'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'~'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'|'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'Z'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'X'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'C'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'V'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'B'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'N'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'M'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'&#x3C;'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'>'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'?'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#9ECBFF\">'*'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">' '</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> char</span><span style=\"color:#FFAB70\"> keyboard_buffer</span><span style=\"color:#E1E4E8\">[KBUFFER_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> kb_read_pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> kb_write_pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> shift_pressed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> keyboard_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> scancode </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> inb</span><span style=\"color:#E1E4E8\">(KEYBOARD_PORT);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check for key release (bit 7 set)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (scancode </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Key released</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        scancode </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">7F</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (scancode </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">2A</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> scancode </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">36</span><span style=\"color:#E1E4E8\">) {</span><span style=\"color:#6A737D\">  // Left or right shift</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            shift_pressed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Key pressed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (scancode </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">2A</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> scancode </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">36</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        shift_pressed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Translate to ASCII</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#E1E4E8\"> ascii </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> shift_pressed </span><span style=\"color:#F97583\">?</span><span style=\"color:#FFAB70\"> scancode_to_ascii_shift</span><span style=\"color:#E1E4E8\">[scancode] </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                               :</span><span style=\"color:#FFAB70\"> scancode_to_ascii</span><span style=\"color:#E1E4E8\">[scancode];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ascii </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Add to circular buffer</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        keyboard_buffer</span><span style=\"color:#E1E4E8\">[kb_write_pos] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ascii;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        kb_write_pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (kb_write_pos </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> KBUFFER_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#B392F0\"> keyboard_getchar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Block until a character is available</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (kb_read_pos </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> kb_write_pos) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">hlt</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Wait for interrupt</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> keyboard_buffer</span><span style=\"color:#E1E4E8\">[kb_read_pos];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    kb_read_pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (kb_read_pos </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> KBUFFER_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> c;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The circular buffer handles the asynchronous nature of keyboard input. The interrupt handler produces characters; <code>keyboard_getchar()</code> consumes them.</p>\n<hr>\n<h2 id=\"stage-6-putting-it-all-together\">Stage 6: Putting It All Together</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* main.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"idt.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"pic.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"timer.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"keyboard.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"vga.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> kernel_main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Initializing IDT...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set up exception handlers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,  (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)isr0,  </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">8E</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,  (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)isr1,  </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">8E</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... (set all 32 exception handlers)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">14</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)isr14, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">8E</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Page fault</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">,  (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)isr8,  </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">8E</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Double fault</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set up IRQ handlers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)irq0, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">8E</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Timer</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">33</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)irq1, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">8E</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Keyboard</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... (set remaining IRQ handlers)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Remapping PIC...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pic_remap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">40</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Initializing timer at 100Hz...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    timer_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Initializing keyboard...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    keyboard_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Enabling interrupts...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">sti</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"System ready. Type something!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Echo keyboard input</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> keyboard_getchar</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (c </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (c </span><span style=\"color:#F97583\">>=</span><span style=\"color:#9ECBFF\"> ' '</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%c</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, c);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"the-three-level-view-what-happens-when-you-press-a-key\">The Three-Level View: What Happens When You Press a Key</h2>\n<p><strong>Level 1 — Application (Your Handler)</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> keyboard_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> scancode </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> inb</span><span style=\"color:#E1E4E8\">(KEYBOARD_PORT);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Translate, buffer, process...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>A simple function that reads a byte and processes it.</p>\n<p><strong>Level 2 — Interrupt Controller (PIC)</strong>:\nThe keyboard controller asserts IRQ1. The master PIC:</p>\n<ol>\n<li>Checks if IRQ1 is masked (it&#39;s not)</li>\n<li>Checks if any higher-priority IRQ is in service (none)</li>\n<li>Sets bit 1 in the In-Service Register</li>\n<li>Raises INTR to the CPU</li>\n<li>Waits for CPU acknowledgment</li>\n<li>Sends vector 33 to the CPU</li>\n</ol>\n<p><strong>Level 3 — Hardware (CPU and Keyboard Controller)</strong>:\nThe keyboard controller has been buffering your keystroke in a small internal buffer. When you press &#39;A&#39;, it generates scancode 0x1E and stores it in an output buffer at I/O port 0x60. The <code>inb</code> instruction reads this port through the I/O bus. The keyboard controller then clears its buffer—if you don&#39;t read fast enough, the next keystroke overwrites it.</p>\n<hr>\n<h2 id=\"hardware-soul-interrupt-latency\">Hardware Soul: Interrupt Latency</h2>\n<p>When the keyboard generates an interrupt, a chain of events must occur before your handler runs:</p>\n<table>\n<thead>\n<tr>\n<th>Stage</th>\n<th>Latency</th>\n<th>Why It Matters</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Keyboard controller → PIC</td>\n<td>~1 µs</td>\n<td>Electrical signal propagation</td>\n</tr>\n<tr>\n<td>PIC priority arbitration</td>\n<td>~100 ns</td>\n<td>PIC checks higher-priority IRQs</td>\n</tr>\n<tr>\n<td>CPU interrupt acknowledge</td>\n<td>~50 ns</td>\n<td>CPU finishes current instruction</td>\n</tr>\n<tr>\n<td>CPU pushes EFLAGS, CS, EIP</td>\n<td>~10 ns</td>\n<td>Memory writes</td>\n</tr>\n<tr>\n<td>CPU loads IDT entry</td>\n<td>~20 ns</td>\n<td>Memory read (may cache miss)</td>\n</tr>\n<tr>\n<td>Your handler prologue (pusha)</td>\n<td>~20 ns</td>\n<td>Register saves</td>\n</tr>\n</tbody></table>\n<p><strong>Total latency</strong>: roughly 1-2 microseconds. But if interrupts are disabled (<code>cli</code>), the keyboard event sits waiting. If you hold interrupts disabled for 10 ms, you might miss keystrokes—the keyboard buffer is only a few bytes.</p>\n<p>This is why kernel code must minimize time with interrupts disabled. Critical sections should be short, measured in microseconds, not milliseconds.</p>\n<hr>\n<h2 id=\"common-pitfalls\">Common Pitfalls</h2>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>System hangs after first interrupt</td>\n<td>Forgot EOI</td>\n<td>Add <code>pic_send_eoi(irq)</code> to end of handler</td>\n</tr>\n<tr>\n<td>Keyboard doesn&#39;t work</td>\n<td>PIC not remapped (IRQ1 → vector 9 = Coprocessor error)</td>\n<td>Call <code>pic_remap(32, 40)</code> before <code>sti</code></td>\n</tr>\n<tr>\n<td>Random crashes after interrupts</td>\n<td>Not saving/restoring all registers</td>\n<td>Use <code>pusha</code>/<code>popa</code> in assembly stub</td>\n</tr>\n<tr>\n<td>Triple fault on exception</td>\n<td>Stack frame mismatch (error code handling)</td>\n<td>Check ISR_ERROR vs ISR_NO_ERROR macros</td>\n</tr>\n<tr>\n<td>Characters repeat infinitely</td>\n<td>Not handling break codes (scancode &amp; 0x80)</td>\n<td>Check bit 7 to distinguish press/release</td>\n</tr>\n<tr>\n<td>Timer fires once, then stops</td>\n<td>IRQ0 handler doesn&#39;t send EOI</td>\n<td>Every IRQ handler must call <code>pic_send_eoi</code></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"knowledge-cascade\">Knowledge Cascade</h2>\n<p>You&#39;ve made your kernel reactive to hardware. Here&#39;s where this connects:</p>\n<p><strong>→ Preemptive Scheduling (Milestone 4)</strong>: The timer interrupt you just built becomes the heartbeat of multitasking. Every timer tick, the scheduler checks if the current process has run long enough, then performs a context switch. The same interrupt mechanism that increments <code>timer_ticks</code> will soon save and restore complete process state.</p>\n<p><strong>→ Signal Handling (Cross-Domain: Unix APIs)</strong>: POSIX signals are userspace&#39;s interrupt mechanism. When a process receives <code>SIGINT</code> (Ctrl+C), the kernel interrupts whatever code is running and jumps to a signal handler the process registered via <code>sigaction()</code>. The same &quot;save state, jump to handler, restore state&quot; pattern you implemented in <code>isr_common_stub</code> is what the kernel does for signal delivery. The <code>siginfo_t</code> structure is analogous to your <code>registers_t</code>—it captures the interrupted context.</p>\n<p><strong>→ Exception Handling (Cross-Domain: Language Runtimes)</strong>: When C++ throws an exception, the runtime searches for a matching <code>catch</code> block by unwinding the stack. This uses CPU exception mechanisms under the hood—specifically, the unwind tables stored in the <code>.eh_frame</code> section. A null pointer dereference triggers a page fault; the runtime&#39;s page fault handler catches it, throws <code>std::bad_null_access</code>, and unwinds. Java&#39;s <code>NullPointerException</code> works similarly. Your exception handler is the kernel&#39;s equivalent of these runtime mechanisms.</p>\n<p><strong>→ Real-Time Systems (Cross-Domain: Embedded)</strong>: In an RTOS, interrupt latency must be bounded and predictable. A hard real-time system might guarantee &quot;interrupt handler starts within 10 µs.&quot; This requires careful PIC priority configuration—high-priority interrupts (motor control, sensors) must preempt lower-priority ones (logging, UI). The same PIC priority hierarchy you&#39;re using (IRQ0 highest, IRQ7 lowest) is what RTOS engineers tune for their specific hardware.</p>\n<p><strong>→ Game Development (Cross-Domain: Input Latency)</strong>: Frame-perfect input in competitive games requires understanding interrupt latency. When you press a button, the scancode travels through the keyboard controller, USB bus (for modern keyboards), OS input stack, and finally the game&#39;s input polling. The game reads input at a specific point in its frame loop—if the interrupt arrives just after polling, the input is delayed by a full frame (16.67 ms at 60 fps). Fighting game developers measure and minimize this latency; some read input in a high-priority thread that wakes on interrupt.</p>\n<hr>\n<p>[[CRITERIA_JSON: {&quot;milestone_id&quot;: &quot;build-os-m2&quot;, &quot;criteria&quot;: [&quot;IDT contains 256 entries with entries 0-31 configured for CPU exceptions including divide error, page fault, and general protection fault with descriptive error messages&quot;, &quot;All interrupt handlers save general-purpose registers (pusha) and segment registers on entry and restore them before iret; handlers for exceptions 8, 10-14 account for the error code pushed by the CPU&quot;, &quot;PIC 8259 is remapped so IRQ0-7 map to vectors 32-39 and IRQ8-15 map to vectors 40-47, avoiding conflicts with CPU exception vectors 0-31&quot;, &quot;EOI is sent to the correct PIC (master for IRQ0-7, both master and slave for IRQ8-15) at the end of each IRQ handler before iret&quot;, &quot;Timer interrupt (IRQ0 via PIT channel 0) fires at a configurable frequency (e.g., 100Hz) and increments a global tick counter on each interrupt&quot;, &quot;Keyboard interrupt (IRQ1) reads PS/2 scancode from port 0x60, converts to ASCII using a scancode-to-ASCII table, and places characters in a circular keyboard buffer&quot;, &quot;Double fault handler (exception 8) catches cascading faults, prints diagnostic information including error code, and halts the system instead of allowing a triple fault&quot;, &quot;Interrupts are enabled (sti) only after IDT is loaded and PIC is remapped and configured&quot;]}]</p>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-os-m3 -->\n<h1 id=\"milestone-3-physical-and-virtual-memory-management\">Milestone 3: Physical and Virtual Memory Management</h1>\n<h2 id=\"the-memory-illusion\">The Memory Illusion</h2>\n<p>Your kernel boots. It runs code, handles interrupts, responds to keyboard input. But it has a secret vulnerability: everything runs in the same memory space. One wild pointer write could corrupt the kernel&#39;s own data structures. There&#39;s no isolation, no protection, no virtual memory.</p>\n<p>More fundamentally, you have no dynamic memory allocation. Every buffer, every structure, every piece of data must be statically allocated at compile time. Want to load a file? You need to know its maximum size beforehand. Want to support multiple processes? You need to pre-allocate space for all of them.</p>\n<p>This milestone solves both problems. You&#39;ll build a <strong>physical frame allocator</strong> that tracks which 4KB blocks of RAM are available, implement <strong>two-level page tables</strong> that translate virtual addresses to physical frames, and create a <strong>kernel heap allocator</strong> that provides <code>kmalloc()</code> and <code>kfree()</code>. By the end, your kernel will have virtual memory—the foundation for process isolation, demand paging, and every advanced memory feature.</p>\n<h3 id=\"the-fundamental-tension\">The Fundamental Tension</h3>\n<p><strong>Constraint 1: The 4KB Page Boundary</strong></p>\n<p>The hardware page table enforces 4KB granularity. You cannot allocate 100 bytes of physical memory directly—you allocate a 4096-byte frame and manage the waste. Small allocations fragment memory; large allocations waste it. Your allocator must balance both.</p>\n<p><strong>Constraint 2: The Bootstrap Problem</strong></p>\n<p>Enabling paging is not a simple flag flip. When you set CR0.PG, the CPU immediately starts translating <em>every</em> memory access through page tables—including the very next instruction. If that instruction&#39;s address isn&#39;t properly mapped, you page fault immediately. The CPU doesn&#39;t pause, doesn&#39;t transition gracefully. You must identity-map the code you&#39;re currently executing <em>before</em> enabling paging.</p>\n<p><strong>Constraint 3: The TLB Cache</strong></p>\n<p>The Translation Lookaside Buffer (TLB) caches page table entries. It&#39;s essential for performance—without it, every memory access would require two additional memory reads (page directory + page table). But the TLB doesn&#39;t automatically invalidate when you modify page tables. Change a mapping without flushing, and the CPU serves stale translations. Debugging this is painful: the code looks correct, the page tables are correct, but the CPU sees the old mapping.</p>\n<p><strong>Constraint 4: Physical Memory Is a Finite Resource</strong></p>\n<p>Your physical frame allocator must track every 4KB block: which are used by the kernel binary, which hold page tables, which contain multiboot data, and which are truly available. Allocating a frame that&#39;s already in use corrupts whatever was there. Double-freeing a frame causes subtle corruption later. The allocator must be bulletproof.</p>\n<hr>\n<h2 id=\"the-revelation-paging-is-not-just-a-lookup-table\">The Revelation: Paging Is Not Just a Lookup Table</h2>\n<p>{{DIAGRAM:diag-page-table-hierarchy}}</p>\n<p>If you&#39;ve used <code>malloc()</code> in userspace, you might think memory allocation is simple: ask for bytes, get a pointer, free it when done. The kernel&#39;s memory subsystem is far more complex:</p>\n<ol>\n<li><p><strong>Virtual addresses are not physical addresses.</strong> After paging is enabled, address <code>0xC0100000</code> might map to physical frame <code>0x100000</code>, or it might not be mapped at all. The page tables define this translation, and they can change at runtime.</p>\n</li>\n<li><p><strong>The TLB caches translations, not permissions.</strong> When you modify a page table entry—even just to change the writable bit—the TLB still contains the old entry. The CPU will allow writes to a now-read-only page until you flush that TLB entry.</p>\n</li>\n<li><p><strong>Higher-half mapping requires linker script cooperation.</strong> Your kernel code must be compiled to run at virtual address <code>0xC0000000+</code>, but it&#39;s loaded at physical address <code>0x100000</code>. The linker script uses virtual addresses; the bootloader loads to physical addresses. Until paging is enabled, you&#39;re executing code at addresses that don&#39;t match what the compiler expected.</p>\n</li>\n<li><p><strong>Page faults are features, not just errors.</strong> A page fault tells you <em>which</em> address failed and <em>why</em> (not present, write violation, user access). This is the mechanism behind demand paging (load from disk on fault), copy-on-write (fault on write, then copy), and memory-mapped files.</p>\n</li>\n</ol>\n<p>Let&#39;s build this layer by layer.</p>\n<hr>\n<h2 id=\"stage-1-physical-memory-map\">Stage 1: Physical Memory Map</h2>\n<p>Before you can allocate memory, you must know what exists. The BIOS provides a memory map via INT 15h/E820 (real mode) or multiboot info (if using GRUB). This tells you which address ranges are usable RAM, which are reserved (BIOS, ACPI), and which are memory-mapped I/O.</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-physical-memory-map.svg\" alt=\"Physical Memory Map: E820/Multiboot Regions\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* memory_map.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MEMORY_TYPE_USABLE </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MEMORY_TYPE_RESERVED </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MEMORY_TYPE_ACPI_RECLAIMABLE </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MEMORY_TYPE_ACPI_NVS </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MEMORY_TYPE_BAD </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 5</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">memory_type_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> base;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> length;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    memory_type_t</span><span style=\"color:#E1E4E8\"> type;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">memory_region_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_MEMORY_REGIONS</span><span style=\"color:#79B8FF\"> 64</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#79B8FF\"> memory_region_t</span><span style=\"color:#FFAB70\"> memory_map</span><span style=\"color:#E1E4E8\">[MAX_MEMORY_REGIONS];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> memory_map_count;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> memory_map_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">multiboot_info_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">mbi</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> memory_map_print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p>If you&#39;re using multiboot (GRUB loads your kernel), the bootloader passes a pointer to multiboot info in EBX:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* memory_map.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"memory_map.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"multiboot.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"kprintf.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">memory_region_t</span><span style=\"color:#FFAB70\"> memory_map</span><span style=\"color:#E1E4E8\">[MAX_MEMORY_REGIONS];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> memory_map_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> memory_map_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">multiboot_info_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">mbi</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(mbi->flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">))) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ERROR: No memory map from bootloader!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    multiboot_memory_map_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">entry </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">multiboot_memory_map_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)mbi->mmap_addr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mbi->mmap_addr </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> mbi->mmap_length;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)entry </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> memory_map_count </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> MAX_MEMORY_REGIONS) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        memory_map</span><span style=\"color:#E1E4E8\">[memory_map_count].base </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> entry->addr;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        memory_map</span><span style=\"color:#E1E4E8\">[memory_map_count].length </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> entry->len;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        memory_map</span><span style=\"color:#E1E4E8\">[memory_map_count].type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">memory_type_t</span><span style=\"color:#E1E4E8\">)entry->type;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Region </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: 0x</span><span style=\"color:#79B8FF\">%x%08x</span><span style=\"color:#9ECBFF\"> - 0x</span><span style=\"color:#79B8FF\">%x%08x</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                memory_map_count,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)(entry->addr </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">), (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)entry->addr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)((entry->addr </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> entry->len) </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">), </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)(entry->addr </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> entry->len),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                entry->type </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> ?</span><span style=\"color:#9ECBFF\"> \"Usable\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"Reserved\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        memory_map_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entry </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">multiboot_memory_map_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)entry </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> entry->size </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<blockquote>\n<p><strong>The E820 Memory Map</strong></p>\n<p>The BIOS INT 15h/E820 function returns a list of memory regions. Each entry contains:</p>\n<ul>\n<li>Base address (64-bit)</li>\n<li>Length (64-bit)</li>\n<li>Type (usable, reserved, ACPI, etc.)</li>\n</ul>\n<p>The kernel must parse this map to know which physical addresses contain actual RAM. The first megabyte is typically reserved (BIOS data, VGA memory). Usable RAM starts around 1MB but may have holes (ACPI tables, memory-mapped I/O). A typical 1GB system might have 3-5 distinct usable regions.</p>\n</blockquote>\n<p>The memory map tells you <em>what exists</em>. Now you need to track <em>what&#39;s available</em>.</p>\n<hr>\n<h2 id=\"stage-2-physical-frame-allocator\">Stage 2: Physical Frame Allocator</h2>\n<p>The physical frame allocator manages 4KB blocks of physical memory. Two common approaches:</p>\n<p><strong>Bitmap</strong>: One bit per frame. Bit = 0 means free, bit = 1 means allocated. Simple, constant-time allocation, but requires O(memory_size / 32768) bytes of metadata.</p>\n<p><strong>Free list</strong>: Each free frame contains a pointer to the next free frame. Zero overhead for allocated frames, but allocation is O(1) only if you don&#39;t need contiguous blocks.</p>\n<p>We&#39;ll use a bitmap for simplicity and predictable performance.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* pmm.h */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_SIZE</span><span style=\"color:#79B8FF\"> 4096</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FRAME_SIZE</span><span style=\"color:#79B8FF\"> 4096</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bitmap: 1 bit per frame</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// For 4GB of memory: 4GB / 4KB = 1M frames = 128KB bitmap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_FRAMES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  // 1M frames for 4GB</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BITMAP_SIZE</span><span style=\"color:#E1E4E8\"> (MAX_FRAMES </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#FFAB70\"> physical_frame_bitmap</span><span style=\"color:#E1E4E8\">[BITMAP_SIZE </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FRAME_INDEX</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">addr</span><span style=\"color:#E1E4E8\">) ((addr) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> FRAME_SIZE)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BIT_OFFSET</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">index</span><span style=\"color:#E1E4E8\">) ((index) </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> WORD_OFFSET</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">index</span><span style=\"color:#E1E4E8\">) ((index) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pmm_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">memory_region_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regions</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pmm_free_frame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> frame_addr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pmm_mark_used</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> frame_addr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pmm_mark_free</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> frame_addr</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* pmm.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"pmm.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"memory_map.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"kprintf.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> physical_frame_bitmap</span><span style=\"color:#E1E4E8\">[BITMAP_SIZE </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> total_frames </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> used_frames </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> set_bit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> index</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    physical_frame_bitmap</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">WORD_OFFSET</span><span style=\"color:#E1E4E8\">(index)] </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> BIT_OFFSET</span><span style=\"color:#E1E4E8\">(index));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> clear_bit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> index</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    physical_frame_bitmap</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">WORD_OFFSET</span><span style=\"color:#E1E4E8\">(index)] </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> BIT_OFFSET</span><span style=\"color:#E1E4E8\">(index));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> test_bit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> index</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#FFAB70\"> physical_frame_bitmap</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">WORD_OFFSET</span><span style=\"color:#E1E4E8\">(index)] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> BIT_OFFSET</span><span style=\"color:#E1E4E8\">(index));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pmm_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">memory_region_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regions</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize all frames as reserved (1 = used)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> BITMAP_SIZE </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        physical_frame_bitmap</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFFFFFF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find the highest addressable frame</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> max_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> count; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint64_t</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> regions</span><span style=\"color:#E1E4E8\">[i].base </span><span style=\"color:#F97583\">+</span><span style=\"color:#FFAB70\"> regions</span><span style=\"color:#E1E4E8\">[i].length;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (end </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> max_addr) max_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> end;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    total_frames </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)(max_addr </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> FRAME_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (total_frames </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> MAX_FRAMES) total_frames </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> MAX_FRAMES;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mark usable regions as free</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> count; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">regions</span><span style=\"color:#E1E4E8\">[i].type </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> MEMORY_TYPE_USABLE) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint64_t</span><span style=\"color:#E1E4E8\"> addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> regions</span><span style=\"color:#E1E4E8\">[i].base;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint64_t</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> addr </span><span style=\"color:#F97583\">+</span><span style=\"color:#FFAB70\"> regions</span><span style=\"color:#E1E4E8\">[i].length;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Align to frame boundaries</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (addr </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> FRAME_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#E1E4E8\">(FRAME_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#E1E4E8\">(FRAME_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (; addr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> end; addr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> FRAME_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint32_t</span><span style=\"color:#E1E4E8\"> index </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> FRAME_INDEX</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)addr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (index </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> total_frames) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                clear_bit</span><span style=\"color:#E1E4E8\">(index);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mark frames 0-1MB as used (BIOS, VGA, kernel load area)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // The kernel binary and page tables will also be marked used</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; addr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">100000</span><span style=\"color:#E1E4E8\">; addr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> FRAME_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pmm_mark_used</span><span style=\"color:#E1E4E8\">(addr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PMM: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> total frames, </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> available</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            total_frames, total_frames </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> used_frames);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Linear search for first free frame</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> total_frames; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">test_bit</span><span style=\"color:#E1E4E8\">(i)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            set_bit</span><span style=\"color:#E1E4E8\">(i);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            used_frames</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> FRAME_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PMM: Out of memory!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Out of memory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pmm_free_frame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> frame_addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> index </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> FRAME_INDEX</span><span style=\"color:#E1E4E8\">(frame_addr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (index </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> total_frames) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PMM: Invalid frame free: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, frame_addr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">test_bit</span><span style=\"color:#E1E4E8\">(index)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PMM: Double free detected: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, frame_addr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    clear_bit</span><span style=\"color:#E1E4E8\">(index);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    used_frames</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pmm_mark_used</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> frame_addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> index </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> FRAME_INDEX</span><span style=\"color:#E1E4E8\">(frame_addr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (index </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> total_frames </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#B392F0\">test_bit</span><span style=\"color:#E1E4E8\">(index)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        set_bit</span><span style=\"color:#E1E4E8\">(index);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        used_frames</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<blockquote>\n<p><strong>Frame vs. Page: Terminology</strong></p>\n<p>A <strong>frame</strong> is a physical 4KB block of RAM. A <strong>page</strong> is a virtual 4KB block of address space. Page tables map pages to frames. The physical frame allocator gives you frames; the page table maps them to pages; the heap allocator carves pages into smaller blocks.</p>\n</blockquote>\n<hr>\n<h2 id=\"stage-3-two-level-page-tables\">Stage 3: Two-Level Page Tables</h2>\n<p>x86 uses a two-level hierarchical page table structure:</p>\n<ol>\n<li><strong>Page Directory (PD)</strong>: 1024 entries, each pointing to a page table</li>\n<li><strong>Page Table (PT)</strong>: 1024 entries, each pointing to a 4KB frame</li>\n</ol>\n<p>A virtual address is split into three parts:</p>\n<ul>\n<li>Bits 31-22: Page Directory Index (which PD entry)</li>\n<li>Bits 21-12: Page Table Index (which PT entry)</li>\n<li>Bits 11-0: Page Offset (offset within the 4KB frame)</li>\n</ul>\n<p>{{DIAGRAM:diag-pde-pte-layout}}</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* vmm.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Page Directory Entry (PDE) and Page Table Entry (PTE) flags</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_PRESENT</span><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_WRITABLE</span><span style=\"color:#E1E4E8\">   (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_USER</span><span style=\"color:#E1E4E8\">       (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_WRITETHROUGH</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_CACHE_DISABLE</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_ACCESSED</span><span style=\"color:#E1E4E8\">   (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_DIRTY</span><span style=\"color:#E1E4E8\">      (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">   // PTE only</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_SIZE_4MB</span><span style=\"color:#E1E4E8\">   (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 7</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">   // PDE only (for 4MB pages)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_GLOBAL</span><span style=\"color:#E1E4E8\">     (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#79B8FF\"> page_table_entry_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#79B8FF\"> page_directory_entry_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_entry_t</span><span style=\"color:#FFAB70\"> entries</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#B392F0\">aligned</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">))) </span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_directory_entry_t</span><span style=\"color:#FFAB70\"> entries</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#B392F0\">aligned</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">))) </span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#79B8FF\"> page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">kernel_page_directory;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vmm_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vmm_map_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> virtual_addr</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                  uint32_t</span><span style=\"color:#FFAB70\"> physical_addr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> flags</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vmm_unmap_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> virtual_addr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> vmm_get_physical</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> virtual_addr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vmm_enable_paging</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* vmm.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"vmm.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"pmm.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"kprintf.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">kernel_page_directory;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">page_tables</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">  // Track allocated page tables</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> pd_index</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (addr </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 22</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">3FF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> pt_index</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (addr </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">3FF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> page_offset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> addr </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Extract physical address from PDE/PTE (bits 12-31)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> frame_addr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> entry</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> entry </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFFF000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vmm_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate page directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pd_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    kernel_page_directory </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)pd_frame;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Zero the page directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        kernel_page_directory->entries[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize page table tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        page_tables</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"VMM: Page directory at 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)kernel_page_directory);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vmm_map_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> virtual_addr</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                  uint32_t</span><span style=\"color:#FFAB70\"> physical_addr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> flags</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Align addresses to page boundaries</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    virtual_addr </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFFF000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    physical_addr </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFFF000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pd_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pd_index</span><span style=\"color:#E1E4E8\">(virtual_addr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pt_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pt_index</span><span style=\"color:#E1E4E8\">(virtual_addr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if page table exists</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pt;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(pd->entries[pd_idx] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PAGE_PRESENT)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Allocate new page table</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> pt_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)pt_frame;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Zero the page table</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pt->entries[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Link page table in page directory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pd->entries[pd_idx] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pt_frame </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PAGE_PRESENT </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PAGE_WRITABLE </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> (flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PAGE_USER);</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        page_tables</span><span style=\"color:#E1E4E8\">[pd_idx] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pt;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">frame_addr</span><span style=\"color:#E1E4E8\">(pd->entries[pd_idx]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Map the page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pt->entries[pt_idx] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> physical_addr </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> flags </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PAGE_PRESENT;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Invalidate TLB entry for this page</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">invlpg %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">m</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(virtual_addr));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vmm_unmap_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> virtual_addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    virtual_addr </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFFF000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pd_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pd_index</span><span style=\"color:#E1E4E8\">(virtual_addr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pt_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pt_index</span><span style=\"color:#E1E4E8\">(virtual_addr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(pd->entries[pd_idx] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PAGE_PRESENT)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Page table doesn't exist</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">frame_addr</span><span style=\"color:#E1E4E8\">(pd->entries[pd_idx]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pt->entries[pt_idx] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Remove mapping</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Invalidate TLB entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">invlpg %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">m</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(virtual_addr));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<blockquote>\n<p><strong>Why Two Levels?</strong></p>\n<p>A single-level page table for 4GB of address space would require 1M entries (4MB of memory). By splitting into two levels, you only allocate page tables for regions you actually use. A process using 8MB of memory needs only 1 page directory (4KB) + 2 page tables (8KB) = 12KB of page table structures, not 4MB.</p>\n</blockquote>\n<hr>\n<h2 id=\"stage-4-identity-mapping-and-higher-half-kernel\">Stage 4: Identity Mapping and Higher-Half Kernel</h2>\n<p>{{DIAGRAM:diag-identity-higher-half}}</p>\n<p>The critical insight: <strong>before enabling paging, you must identity-map the code that enables paging</strong>. Otherwise, the moment you set CR0.PG, the CPU tries to fetch the next instruction using page tables, fails, and triple-faults.</p>\n<h3 id=\"the-mapping-strategy\">The Mapping Strategy</h3>\n<p>We need two mappings:</p>\n<ol>\n<li><p><strong>Identity map (0x00000000 → 0x00000000)</strong>: Covers the first 4MB (kernel, VGA, boot data). Required during the paging enable transition.</p>\n</li>\n<li><p><strong>Higher-half map (0xC0000000 → 0x00000000)</strong>: The kernel&#39;s permanent home. After setup, we remove the identity map and run purely from higher-half addresses.</p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* higher_half.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"vmm.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"pmm.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"kprintf.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KERNEL_PHYSICAL_START</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">100000</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KERNEL_VIRTUAL_START</span><span style=\"color:#F97583\">  0x</span><span style=\"color:#79B8FF\">C0000000</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> IDENTITY_MAP_END</span><span style=\"color:#F97583\">      0x</span><span style=\"color:#79B8FF\">400000</span><span style=\"color:#6A737D\">   // 4MB</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> setup_page_tables</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vmm_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Identity map first 4MB (kernel + VGA + boot data)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Mapping identity region: 0x0 - 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, IDENTITY_MAP_END);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; addr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> IDENTITY_MAP_END; addr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> PAGE_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // VGA region at 0xB8000 - accessible from kernel</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Kernel at 0x100000 - accessible from kernel</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vmm_map_page</span><span style=\"color:#E1E4E8\">(kernel_page_directory, addr, addr, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                     PAGE_WRITABLE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Higher-half mapping: 0xC0000000+ maps to 0x0+</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Mapping higher-half: 0xC0000000 - 0xC0400000</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; offset </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> IDENTITY_MAP_END; offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> PAGE_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> virtual_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> KERNEL_VIRTUAL_START </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> offset;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> physical_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> offset;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vmm_map_page</span><span style=\"color:#E1E4E8\">(kernel_page_directory, virtual_addr, physical_addr, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                     PAGE_WRITABLE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Page tables configured.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"the-linker-script-dance\">The Linker Script Dance</h3>\n<p>The linker script must place sections at their <em>virtual</em> addresses (0xC0000000+), but the kernel binary is loaded at <em>physical</em> addresses (0x100000). This is controlled via the <code>AT()</code> directive:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">ld</span><pre class=\"arch-pre shiki-highlighted\"><code>/* linker.ld */\nENTRY(kernel_entry)\n\nSECTIONS\n{\n    /* Kernel starts at 0xC0100000 (virtual), loaded at 0x100000 (physical) */\n    . = 0xC0100000;\n    \n    /* Store the physical load address */\n    kernel_physical_start = . - 0xC000000;\n    \n    .text ALIGN(4K) : AT(ADDR(.text) - 0xC000000)\n    {\n        *(.multiboot)\n        *(.text)\n    }\n    \n    .rodata ALIGN(4K) : AT(ADDR(.rodata) - 0xC000000)\n    {\n        *(.rodata)\n    }\n    \n    .data ALIGN(4K) : AT(ADDR(.data) - 0xC000000)\n    {\n        *(.data)\n    }\n    \n    .bss ALIGN(4K) : AT(ADDR(.bss) - 0xC000000)\n    {\n        __bss_start = .;\n        *(.COMMON)\n        *(.bss)\n        __bss_end = .;\n    }\n    \n    kernel_physical_end = . - 0xC000000;\n}</code></pre></div>\n\n<p>The <code>AT()</code> directive tells the linker: &quot;this section runs at the virtual address, but load it at the physical address.&quot; The bootloader loads the binary to physical addresses; after paging is enabled, the CPU accesses it via virtual addresses.</p>\n<hr>\n<h2 id=\"stage-5-enabling-paging\">Stage 5: Enabling Paging</h2>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-tlb-flush.svg\" alt=\"TLB Coherency: invlpg vs. CR3 Reload\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* paging_enable.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"vmm.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"kprintf.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> kernel_physical_start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> kernel_physical_end;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> enable_paging</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pd_physical </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)kernel_page_directory;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Loading CR3 with page directory at 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, pd_physical);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Load page directory base into CR3</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %0, %%cr3</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(pd_physical));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Enable paging by setting CR0.PG (bit 31)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> cr0;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %%cr0, %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(cr0));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cr0 </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 31</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Set PG bit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %0, %%cr0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(cr0));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Paging enabled!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Now running with virtual addresses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Can safely jump to higher-half code</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"the-assembly-transition\">The Assembly Transition</h3>\n<p>The trickiest part: the code that enables paging must handle the address transition. Before paging, you&#39;re at physical address. After paging, you&#39;re at virtual address. A normal function call would use the wrong return address.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; paging_transition.asm\n[BITS 32]\n\nextern enable_paging\nextern kernel_main_higher_half\n\nglobal paging_transition\npaging_transition:\n    ; We're still running at physical addresses (e.g., 0x100000)\n    \n    ; Set up page tables (still using physical addresses)\n    call setup_page_tables\n    \n    ; Enable paging (this function uses physical addresses internally)\n    call enable_paging\n    \n    ; CRITICAL: Now paging is enabled. The return address pushed by\n    ; the 'call enable_paging' is a PHYSICAL address, but we're now\n    ; executing at VIRTUAL addresses. We need to jump to the higher half.\n    \n    ; Jump to higher-half kernel main\n    ; This must be an absolute jump to the virtual address\n    mov eax, kernel_main_higher_half\n    jmp eax\n    \n    ; Should never reach here\n.halt:\n    hlt\n    jmp .halt</code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* main.c - after paging is enabled */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> kernel_main_higher_half</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Now we're running at 0xC0100000+</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // All addresses are virtual</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Kernel running in higher half!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Kernel virtual start: 0xC0100000</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"VGA still accessible at 0xB8000 (identity mapped)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize heap, start scheduler, etc.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kernel_main_continued</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"stage-6-tlb-management\">Stage 6: TLB Management</h2>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-tlb-flush.svg\" alt=\"TLB Coherency: invlpg vs. CR3 Reload\"></p>\n<p>The TLB caches page table translations. It&#39;s a small, fast cache (typically 32-64 entries) that avoids the two-level page table walk on every memory access.</p>\n<p><strong>Problem</strong>: The TLB doesn&#39;t automatically invalidate when you modify page tables.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Modify page table without flushing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">pt</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">entries</span><span style=\"color:#E1E4E8\">[pt_idx] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Unmap the page</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The TLB still contains the old translation!</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Accessing the virtual address will succeed (stale entry)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// until something causes a TLB miss or flush</span></span></code></pre></div>\n\n<p><strong>Solutions</strong>:</p>\n<ol>\n<li><strong><code>invlpg</code></strong>: Invalidate a single TLB entry</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">invlpg %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">m</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(virtual_addr));</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>CR3 reload</strong>: Invalidate all TLB entries (except global pages)</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %0, %%cr3</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(pd_physical));</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong><code>invlpg</code> is preferred</strong> when modifying a single page—it&#39;s faster than a full CR3 reload.</li>\n</ol>\n<blockquote>\n<p><strong>Global Pages</strong></p>\n<p>Pages marked with the <code>PAGE_GLOBAL</code> flag aren&#39;t flushed on CR3 reload. This is useful for kernel code that&#39;s mapped in every process&#39;s address space—the kernel&#39;s TLB entries persist across context switches, improving performance.</p>\n</blockquote>\n<hr>\n<h2 id=\"stage-7-page-fault-handler\">Stage 7: Page Fault Handler</h2>\n<p>{{DIAGRAM:diag-page-fault-handling}}</p>\n<p>Page faults (exception 14) are your window into the memory subsystem. When a page fault occurs:</p>\n<ol>\n<li><strong>CR2</strong> contains the faulting virtual address (not the instruction address!)</li>\n<li><strong>Error code</strong> (pushed by CPU) tells you why:<ul>\n<li>Bit 0 (P): 0 = page not present, 1 = protection violation</li>\n<li>Bit 1 (W): 0 = read access, 1 = write access</li>\n<li>Bit 2 (U): 0 = kernel mode, 1 = user mode</li>\n<li>Bit 3 (R): 1 = reserved bit set in page table</li>\n<li>Bit 4 (I): 1 = instruction fetch (NX bit violation)</li>\n</ul>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* page_fault.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"interrupt.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"kprintf.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> page_fault_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> faulting_addr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %%cr2, %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(faulting_addr));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> regs->err_code;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">===== PAGE FAULT =====</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Faulting address: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, faulting_addr);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Error code: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Reason: \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(err </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Page not present</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (err </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Write to read-only page</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (err </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"User access to kernel page</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (err </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Instruction fetch from NX page</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Unknown</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Access type: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (err </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"Write\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"Read\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Privilege: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (err </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"User\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"Kernel\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"EIP at fault: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, regs->eip);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For now, halt. Later: implement demand paging, COW, etc.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"System halted.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">cli; hlt</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<blockquote>\n<p><strong>CR2 vs. EIP</strong></p>\n<p>CR2 contains the <em>data address</em> that caused the fault—the address you tried to read or write. EIP (in regs-&gt;eip) contains the <em>instruction address</em> that caused the fault. They&#39;re different! A <code>mov [0xDEADBEEF], eax</code> instruction at address 0x1000 would have CR2=0xDEADBEEF and EIP=0x1000.</p>\n</blockquote>\n<hr>\n<h2 id=\"stage-8-kernel-heap-allocator\">Stage 8: Kernel Heap Allocator</h2>\n<p>With paging and a physical frame allocator, you can build <code>kmalloc()</code>. The simplest approach: a linked list of free blocks, each with a header containing size and status.</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-kmalloc-internals.svg\" alt=\"kmalloc Internals: Block Headers and Free Lists\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* kmalloc.h */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KHEAP_START</span><span style=\"color:#F97583\">   0x</span><span style=\"color:#79B8FF\">D0000000</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KHEAP_SIZE</span><span style=\"color:#F97583\">    0x</span><span style=\"color:#79B8FF\">10000000</span><span style=\"color:#6A737D\">   // 256MB virtual space for heap</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> kmalloc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> kfree</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* kmalloc.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"kmalloc.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"vmm.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"pmm.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"kprintf.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> block_header {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> free;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> block_header </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">block_header_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> HEADER_SIZE</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">block_header_t</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ALIGN</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">x</span><span style=\"color:#E1E4E8\">) (((x) </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 15</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#79B8FF\">15</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  // 16-byte alignment</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> block_header_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">heap_head </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> heap_current_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> KHEAP_START;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">heap_grow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate physical frames and map them</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> frames_needed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (size </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> PAGE_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> PAGE_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> start_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> heap_current_end;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> frames_needed; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (frame </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"kmalloc: Out of physical memory!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vmm_map_page</span><span style=\"color:#E1E4E8\">(kernel_page_directory, heap_current_end, frame, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                     PAGE_WRITABLE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        heap_current_end </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> PAGE_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)start_addr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> kmalloc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate initial heap page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    heap_head </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">block_header_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">heap_grow</span><span style=\"color:#E1E4E8\">(PAGE_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">heap_head) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"kmalloc: Failed to initialize heap!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    heap_head->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PAGE_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> HEADER_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    heap_head->free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    heap_head->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"kmalloc: Heap initialized at 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, KHEAP_START);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    size </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ALIGN</span><span style=\"color:#E1E4E8\">(size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find a free block (first-fit)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    block_header_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> heap_head;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    block_header_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (current </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (current->free </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> current->size </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> size) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Found a suitable block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Split if block is much larger</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (current->size </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> size </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> HEADER_SIZE </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                block_header_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">new_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">block_header_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    ((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)current </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> HEADER_SIZE </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                new_block->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current->size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> HEADER_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                new_block->free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                new_block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                current->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                current->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current->free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)current </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> HEADER_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // No suitable block found, grow heap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> alloc_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> size </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> HEADER_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (alloc_size </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> PAGE_SIZE) alloc_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PAGE_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    block_header_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">new_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">block_header_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">heap_grow</span><span style=\"color:#E1E4E8\">(alloc_size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">new_block) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_block->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> alloc_size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> HEADER_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_block->free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (prev) prev->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)new_block </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> HEADER_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> kfree</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    block_header_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">block_header_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)ptr </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> HEADER_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    header->free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Coalesce with next block if free</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (header->next </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> header->next->free) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        header->size </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> header->next->size </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> HEADER_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        header->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> header->next->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Could also coalesce with previous block (requires doubly-linked list)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>This is a simple first-fit allocator. It&#39;s not optimal (fragmentation, no coalescing with previous blocks), but it demonstrates the key concept: <strong>kmalloc requests page frames from the physical allocator, maps them to virtual addresses, and carves them into smaller blocks</strong>.</p>\n<hr>\n<h2 id=\"the-three-level-view-what-happens-when-you-access-memory\">The Three-Level View: What Happens When You Access Memory</h2>\n<p><strong>Level 1 — Application (Your Code)</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">D0001000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 42</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n<p>A simple memory write. You&#39;re storing a value at a virtual address.</p>\n<p><strong>Level 2 — Memory Management Unit (MMU)</strong>:\nThe CPU&#39;s MMU translates the virtual address:</p>\n<ol>\n<li>Extract PD index: <code>(0xD0001000 &gt;&gt; 22) = 832</code></li>\n<li>Read PDE from page directory at index 832</li>\n<li>PDE points to page table at physical address X</li>\n<li>Extract PT index: <code>(0xD0001000 &gt;&gt; 12) &amp; 0x3FF = 1</code></li>\n<li>Read PTE from page table at index 1</li>\n<li>PTE points to frame at physical address Y</li>\n<li>Combine frame address + offset: <code>Y + 0x000 = final physical address</code></li>\n</ol>\n<p>Each step requires a memory access—unless cached in the TLB.</p>\n<p><strong>Level 3 — Hardware (Cache and Memory Bus)</strong>:\nThe page table walk reads from memory (or cache). The final data write goes through the cache hierarchy (L1 → L2 → L3 → RAM). A TLB hit saves two memory accesses; a TLB miss costs two additional memory reads.</p>\n<hr>\n<h2 id=\"hardware-soul-tlb-miss-penalty\">Hardware Soul: TLB Miss Penalty</h2>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Memory Accesses</th>\n<th>Approximate Latency</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TLB hit, cache hit</td>\n<td>1 (data only)</td>\n<td>~4 cycles</td>\n</tr>\n<tr>\n<td>TLB hit, cache miss</td>\n<td>1 + RAM access</td>\n<td>~100 cycles</td>\n</tr>\n<tr>\n<td>TLB miss (page table in cache)</td>\n<td>2 (PD + PT) + 1 (data)</td>\n<td>~12 cycles</td>\n</tr>\n<tr>\n<td>TLB miss (page table in RAM)</td>\n<td>2 × RAM + 1 × RAM</td>\n<td>~300 cycles</td>\n</tr>\n</tbody></table>\n<p>A TLB miss is 75× slower than a TLB hit with cached data. This is why:</p>\n<ul>\n<li>The kernel uses identity-mapped or higher-half addresses (TLB entries stay valid)</li>\n<li>Global pages (kernel code) aren&#39;t flushed on context switch</li>\n<li>Memory-intensive code benefits from huge pages (4MB instead of 4KB = 1/1024th the TLB entries)</li>\n</ul>\n<hr>\n<h2 id=\"common-pitfalls\">Common Pitfalls</h2>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Triple fault immediately after setting CR0.PG</td>\n<td>Code not identity-mapped</td>\n<td>Map pages 0x0-0x400000 before enabling paging</td>\n</tr>\n<tr>\n<td>Page fault on valid address</td>\n<td>TLB contains stale entry</td>\n<td>Call <code>invlpg</code> after modifying page tables</td>\n</tr>\n<tr>\n<td>Random corruption after kmalloc</td>\n<td>Double-free or heap overflow</td>\n<td>Audit all kfree() calls, add heap guards</td>\n</tr>\n<tr>\n<td>VGA output stops working after paging</td>\n<td>VGA not mapped</td>\n<td>Identity-map 0xB8000 or map at fixed virtual address</td>\n</tr>\n<tr>\n<td>Page fault handler crashes</td>\n<td>Handler code not mapped</td>\n<td>Ensure handler is in identity-mapped region</td>\n</tr>\n<tr>\n<td>Cannot access memory above 4MB</td>\n<td>Page table not allocated</td>\n<td>Check PDE present bit before accessing PTE</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"knowledge-cascade\">Knowledge Cascade</h2>\n<p>You&#39;ve built the memory management layer. Here&#39;s where this connects:</p>\n<p><strong>→ Process Isolation (Milestone 4)</strong>: Each process gets its own page directory. Switching CR3 on context switch provides complete memory isolation—process A cannot see process B&#39;s memory, even though they run on the same CPU. The page tables you just built become the foundation of process separation.</p>\n<p><strong>→ Demand Paging (Cross-Domain: Databases)</strong>: A page fault on a not-present page doesn&#39;t have to crash the system. It can trigger a disk read to load the page from swap or a memory-mapped file. Databases use this extensively: <code>mmap()</code> a 100GB file, and the OS loads only the pages you actually access. The page fault handler you wrote is the entry point for this mechanism.</p>\n<p><strong>→ Copy-on-Write (Cross-Domain: Unix fork)</strong>: When a process calls <code>fork()</code>, the kernel creates a copy of the page table (not the actual pages) and marks all pages read-only. When either process writes, a page fault occurs, the kernel copies just that one page, and updates permissions. This is why <code>fork()</code> is fast—it doesn&#39;t copy memory, it copies page tables.</p>\n<p><strong>→ Containerization (Cross-Domain: DevOps)</strong>: Docker containers use cgroups and namespaces, but memory limits are enforced through page frame tracking. When a container exceeds its memory limit, the kernel&#39;s OOM killer selects a process to terminate. The same frame allocator you built tracks which cgroup owns which frames.</p>\n<p><strong>→ Garbage Collection (Cross-Domain: Language Runtimes)</strong>: Generational garbage collectors use page protection bits to implement write barriers. A generational GC marks &quot;old&quot; pages as read-only; any write triggers a page fault, which the runtime intercepts to track references from old to young objects. The same hardware mechanism you&#39;re using for protection becomes a GC synchronization primitive.</p>\n<hr>\n<p>[[CRITERIA_JSON: {&quot;milestone_id&quot;: &quot;build-os-m3&quot;, &quot;criteria&quot;: [&quot;Physical memory map obtained from multiboot info or E820 with regions classified as usable, reserved, or ACPI&quot;, &quot;Physical frame allocator (bitmap or free-list) allocates and frees 4KB frames with double-free prevention&quot;, &quot;Page directory and page tables configured for identity-mapping (kernel + VGA + MMIO) and higher-half kernel mapping (0xC0000000+)&quot;, &quot;Paging enabled by loading CR3 with page directory physical address and setting CR0.PG bit&quot;, &quot;TLB flushed with invlpg or CR3 reload after modifying page table entries&quot;, &quot;Page fault handler reads CR2 for faulting address and prints diagnostic (address, error code bits for present/write/user)&quot;, &quot;Kernel heap allocator (kmalloc/kfree) provides dynamic allocation from dedicated virtual range using page allocator for backing frames&quot;, &quot;Identity map maintained for low memory so VGA (0xB8000) and MMIO regions remain accessible at physical addresses&quot;]}]</p>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-os-m4 -->\n<h1 id=\"milestone-4-processes-and-preemptive-scheduling\">Milestone 4: Processes and Preemptive Scheduling</h1>\n<h2 id=\"the-illusion-of-simultaneity\">The Illusion of Simultaneity</h2>\n<p>Your kernel boots. It handles interrupts, manages memory, responds to keyboard input. But it&#39;s fundamentally single-tasking—one thread of execution, one instruction pointer marching forward. If your keyboard handler enters an infinite loop, the entire system freezes. If one function corrupts memory, everything crashes.</p>\n<p>Real operating systems create an illusion: dozens of processes appear to run simultaneously. You can compile code while listening to music while browsing the web. The CPU executes one instruction at a time, but it switches between processes so fast that each one seems to have the entire machine to itself.</p>\n<p>This milestone builds that illusion. You&#39;ll create <strong>process control blocks</strong> to capture complete execution state, implement <strong>context switching</strong> to atomically save one process and restore another, configure the <strong>Task State Segment</strong> for safe privilege transitions, and build a <strong>round-robin scheduler</strong> triggered by timer interrupts. By the end, three processes will run concurrently, each printing to its own screen region—and you&#39;ll understand exactly how the CPU juggles them.</p>\n<h3 id=\"the-fundamental-tension\">The Fundamental Tension</h3>\n<p><strong>Constraint 1: The CPU Has One Set of Registers</strong></p>\n<p>The CPU has exactly one EAX, one EBX, one EIP, one ESP. When Process A is running, its values occupy these registers. To switch to Process B, you must somehow preserve A&#39;s state, load B&#39;s state, and do it atomically—if an interrupt fires mid-switch, you&#39;ll have corrupted state from both processes.</p>\n<p><strong>Constraint 2: The Stack Is the Execution Record</strong></p>\n<p>The stack contains return addresses, local variables, saved registers. A process&#39;s stack defines where it is in its execution. But the CPU has only one ESP. To have multiple processes, each needs its own stack, and context switching must swap ESP values correctly.</p>\n<p><strong>Constraint 3: User Mode Cannot Access Kernel Memory</strong></p>\n<p>When a userspace process makes a system call, it transitions from ring 3 to ring 0. The CPU must switch to a kernel stack—the userspace stack might be corrupted or malicious. But which stack? The CPU needs to be told, via the TSS, where the kernel stack for this process lives.</p>\n<p><strong>Constraint 4: Preemption Requires Interrupt Safety</strong></p>\n<p>The timer interrupt will trigger context switches. But the context switch code itself must not be interrupted—if an IRQ fires while you&#39;re halfway through saving registers, you&#39;ll save garbage. The switch must be atomic.</p>\n<hr>\n<h2 id=\"the-revelation-context-switching-is-not-just-saving-registers\">The Revelation: Context Switching Is Not Just Saving Registers</h2>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-pcb-structure.svg\" alt=\"Process Control Block: Saved State Layout\"></p>\n<p>If you&#39;ve swapped variables in a program, you might think context switching works like this:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG MENTAL MODEL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> context_switch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">old</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">new</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    old->eax </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> eax;</span><span style=\"color:#6A737D\">  // Save current registers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    old->ebx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ebx;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... save all registers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    eax </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new->eax;</span><span style=\"color:#6A737D\">  // Load new registers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ebx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new->ebx;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... load all registers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Done!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>This mental model misses critical details that will crash your kernel:</p>\n<ol>\n<li><p><strong>EFLAGS contains the interrupt flag.</strong> If you save EFLAGS from a process that had interrupts disabled, then restore it during context switch, you&#39;ve just disabled interrupts in the middle of your scheduler. The system freezes.</p>\n</li>\n<li><p><strong>The stack pointer swap is the actual switch.</strong> When you change ESP, you&#39;re not just saving a value—you&#39;re literally changing which stack the CPU uses. The next <code>push</code> or <code>call</code> will use the new process&#39;s stack.</p>\n</li>\n<li><p><strong>The return address is on the stack.</strong> After saving registers, you need to somehow &quot;return&quot; into the new process. This isn&#39;t a normal function return—you&#39;re resuming execution at whatever EIP the new process was at when it was switched out.</p>\n</li>\n<li><p><strong>EIP is not directly accessible.</strong> You can&#39;t <code>mov eax, eip</code> in x86. The instruction pointer is implicit—you manipulate it through control flow instructions (call, ret, jmp). To save/restore EIP, you must use the stack.</p>\n</li>\n<li><p><strong>The TSS ESP0 field must be updated.</strong> When a userspace process makes a syscall, the CPU loads SS:ESP from the TSS. If ESP0 points to the wrong process&#39;s kernel stack, the syscall will corrupt state.</p>\n</li>\n</ol>\n<p>Let&#39;s build the real thing, step by step.</p>\n<hr>\n<h2 id=\"stage-1-the-process-control-block\">Stage 1: The Process Control Block</h2>\n<p>The PCB captures everything needed to resume a process. If you save all this state, swap to a different PCB, and restore its state, the process will resume exactly where it left off—as if nothing happened.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* process.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_PROCESSES</span><span style=\"color:#79B8FF\"> 16</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KERNEL_STACK_SIZE</span><span style=\"color:#79B8FF\"> 4096</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROCESS_STATE_READY,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROCESS_STATE_RUNNING,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROCESS_STATE_BLOCKED,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROCESS_STATE_ZOMBIE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">process_state_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eax, ebx, ecx, edx;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esi, edi, ebp;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esp, eip;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eflags;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> cs, ds, es, fs, gs, ss;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> cr3;</span><span style=\"color:#6A737D\">           // Page directory physical address</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">cpu_state_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> process {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pid;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_state_t</span><span style=\"color:#E1E4E8\"> state;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    cpu_state_t</span><span style=\"color:#E1E4E8\"> cpu;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Kernel stack for this process (used during syscalls/interrupts)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> kernel_stack;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> kernel_stack_top;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Scheduling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> process </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For user-mode processes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> user_stack;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> is_user;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-pcb-structure.svg\" alt=\"Process Control Block: Saved State Layout\"></p>\n<p>The key insight: <code>cpu_state_t</code> contains <em>exactly</em> what the CPU needs to resume execution. The general-purpose registers (EAX-EDI), the stack pointer (ESP), the instruction pointer (EIP), the flags (EFLAGS), the segment registers (CS-SS), and the page directory (CR3). If you can restore all of these atomically, you&#39;ve switched processes.</p>\n<h3 id=\"process-creation\">Process Creation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* process.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"process.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"pmm.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"vmm.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"kprintf.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> process_t</span><span style=\"color:#FFAB70\"> process_table</span><span style=\"color:#E1E4E8\">[MAX_PROCESSES];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> next_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">current_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">ready_queue </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">entry_point)(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> is_user</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find a free slot</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> MAX_PROCESSES; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">process_table</span><span style=\"color:#E1E4E8\">[i].state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PROCESS_STATE_ZOMBIE </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            process_table</span><span style=\"color:#E1E4E8\">[i].pid </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#FFAB70\">process_table</span><span style=\"color:#E1E4E8\">[i];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">proc) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"process_create: No free process slots!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize PCB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next_pid</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PROCESS_STATE_READY;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->is_user </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> is_user;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate kernel stack</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> kstack_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->kernel_stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> kstack_frame;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->kernel_stack_top </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> kstack_frame </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> KERNEL_STACK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set up initial CPU state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->cpu.eip </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)entry_point;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->cpu.eflags </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">202</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // IF=1 (interrupts enabled), bit 1 always set</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (is_user) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // User-mode process: allocate user stack and set up segments</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> ustack_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->user_stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ustack_frame;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->cpu.esp </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ustack_frame </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> KERNEL_STACK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->cpu.cs </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">1B</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   // User code segment (GDT index 4, RPL=3)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->cpu.ds </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">23</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   // User data segment (GDT index 5, RPL=3)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->cpu.es </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">23</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->cpu.fs </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">23</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->cpu.gs </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">23</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->cpu.ss </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">23</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Create user page directory (copy kernel mappings)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->cpu.cr3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_user_page_directory</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Kernel-mode process: use kernel segments</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->cpu.esp </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc->kernel_stack_top;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->cpu.cs </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   // Kernel code segment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->cpu.ds </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   // Kernel data segment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->cpu.es </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->cpu.fs </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->cpu.gs </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->cpu.ss </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->cpu.cr3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)kernel_page_directory;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add to ready queue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ready_queue;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ready_queue </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Created process PID=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, entry=0x</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> mode</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            proc->pid, entry_point, is_user </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"user\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"kernel\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> proc;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<blockquote>\n<p><strong>The EFLAGS Value 0x202</strong></p>\n<p>EFLAGS bit 1 is always 1 (reserved). Bit 9 (IF, Interrupt Flag) must be set for the process to receive interrupts. 0x202 = binary <code>0010 0000 0010</code> = IF set + reserved bit set. If you forget IF, the process will never respond to timer ticks and will run forever.</p>\n</blockquote>\n<hr>\n<h2 id=\"stage-2-the-context-switch\">Stage 2: The Context Switch</h2>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-context-switch-flow.svg\" alt=\"Context Switch: Save Old → Load New\"></p>\n<p>Context switching is the most critical code in your kernel. It must be written in assembly—C cannot directly control register saving/restoration with the precision needed.</p>\n<h3 id=\"the-assembly-context-switch\">The Assembly Context Switch</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; context_switch.asm\n[BITS 32]\n\nextern current_process\nextern next_process\n\nglobal context_switch\ncontext_switch:\n    ; Save current process state\n    ; We're called from the scheduler, which was called from the timer interrupt\n    ; The timer handler already pushed general registers via pusha\n    \n    ; Get pointer to current_process-&gt;cpu\n    mov eax, [current_process]\n    test eax, eax\n    jz .load_new           ; No current process, just load new\n    \n    ; Save registers into PCB\n    ; The caller (scheduler) passes us a pointer to old CPU state on stack\n    mov ebx, [esp + 4]     ; Pointer to old cpu_state_t\n    \n    ; Save general-purpose registers (already saved by interrupt handler)\n    ; But we need to save the stack pointer as it will be after iret\n    mov [ebx + 28], esp    ; Save ESP offset in cpu_state_t\n    \n    ; Save segment registers\n    mov ax, ds\n    mov [ebx + 44], ax     ; ds\n    mov ax, es\n    mov [ebx + 46], ax     ; es\n    mov ax, fs\n    mov [ebx + 48], ax     ; fs\n    mov ax, gs\n    mov [ebx + 50], ax     ; gs\n    \n    ; Save CR3 (page directory)\n    mov eax, cr3\n    mov [ebx + 56], eax    ; cr3\n    \n    ; Save EIP - this is the return address that will be used after context switch\n    ; We need to set up for &quot;returning&quot; to the new process\n    mov eax, [esp + 0]     ; Return address to scheduler\n    mov [ebx + 24], eax    ; eip - but this needs adjustment\n\n.load_new:\n    ; Load new process state\n    mov eax, [next_process]\n    mov [current_process], eax\n    \n    ; Get pointer to new process's cpu state\n    lea ebx, [eax + 8]     ; Offset of cpu field in process_t\n    \n    ; Load CR3 (page directory)\n    mov eax, [ebx + 56]    ; cr3\n    mov cr3, eax\n    \n    ; Load segment registers\n    mov ax, [ebx + 44]     ; ds\n    mov ds, ax\n    mov ax, [ebx + 46]     ; es\n    mov es, ax\n    mov ax, [ebx + 48]     ; fs\n    mov fs, ax\n    mov ax, [ebx + 50]     ; gs\n    mov gs, ax\n    \n    ; Load stack pointer\n    mov esp, [ebx + 28]    ; esp\n    \n    ; The stack now contains the saved state of the new process\n    ; Return to restore registers and iret\n    ret</code></pre></div>\n\n<p>Actually, let me show you a cleaner approach that integrates with your interrupt handler:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; context_switch.asm - cleaner version\n[BITS 32]\n\nextern current_process\nextern schedule_next\n\nglobal context_switch_entry\ncontext_switch_entry:\n    ; This is called from the timer interrupt handler\n    ; The stack contains: pushed registers, error code, int number, EIP, CS, EFLAGS\n    ; For user mode: also ESP, SS\n    \n    cli                     ; Disable interrupts during context switch!\n    \n    ; Save current process state\n    mov eax, [current_process]\n    test eax, eax\n    jz .no_current\n    \n    ; Get pointer to cpu state (offset in process_t)\n    lea ebx, [eax + 8]      ; process_t.cpu starts at offset 8\n    \n    ; Save general-purpose registers from stack\n    ; The interrupt handler pushed: eax, ecx, edx, ebx, esp, ebp, esi, edi (pusha order)\n    ; But we need to be careful about esp\n    \n    pop dword [ebx + 0]     ; edi\n    pop dword [ebx + 4]     ; esi\n    pop dword [ebx + 8]     ; ebp\n    pop dword [ebx + 12]    ; esp (will be ignored, we save real esp below)\n    pop dword [ebx + 16]    ; ebx\n    pop dword [ebx + 20]    ; edx\n    pop dword [ebx + 24]    ; ecx\n    pop dword [ebx + 28]    ; eax\n    \n    ; Save actual ESP (after all the pops)\n    mov [ebx + 32], esp\n    \n    ; Save EIP, CS, EFLAGS from stack\n    pop dword [ebx + 36]    ; eip\n    pop dword [ebx + 40]    ; cs\n    pop dword [ebx + 44]    ; eflags\n    \n    ; Check if we need to save user ESP/SS\n    test byte [ebx + 40], 3  ; Check CS RPL (bits 0-1)\n    jz .kernel_mode_save\n    pop dword [ebx + 48]    ; useresp\n    pop dword [ebx + 52]    ; ss\n    jmp .save_segments\n\n.kernel_mode_save:\n    ; For kernel mode, ESP/SS are already saved\n    \n.save_segments:\n    ; Save segment registers\n    mov ax, ds\n    mov [ebx + 56], ax\n    mov ax, es\n    mov [ebx + 58], ax\n    \n    ; Save CR3\n    mov eax, cr3\n    mov [ebx + 60], eax\n\n.no_current:\n    ; Call scheduler to pick next process\n    call schedule_next\n    \n    ; Load new process\n    mov eax, [current_process]\n    lea ebx, [eax + 8]      ; cpu state pointer\n    \n    ; Load CR3\n    mov eax, [ebx + 60]\n    mov cr3, eax\n    \n    ; Load segments\n    mov ax, [ebx + 56]\n    mov ds, ax\n    mov ax, [ebx + 58]\n    mov es, ax\n    \n    ; Check if returning to user mode\n    test byte [ebx + 40], 3  ; CS RPL\n    jz .kernel_mode_restore\n    \n    ; User mode: push SS, ESP for iret\n    push dword [ebx + 52]   ; ss\n    push dword [ebx + 48]   ; useresp\n\n.kernel_mode_restore:\n    ; Push EFLAGS, CS, EIP for iret\n    push dword [ebx + 44]   ; eflags\n    push dword [ebx + 40]   ; cs\n    push dword [ebx + 36]   ; eip\n    \n    ; Push general-purpose registers\n    push dword [ebx + 28]   ; eax\n    push dword [ebx + 24]   ; ecx\n    push dword [ebx + 20]   ; edx\n    push dword [ebx + 16]   ; ebx\n    push dword [ebx + 12]   ; esp (placeholder, will be overwritten)\n    push dword [ebx + 8]    ; ebp\n    push dword [ebx + 4]    ; esi\n    push dword [ebx + 0]    ; edi\n    \n    ; Restore registers and iret\n    popa\n    iret</code></pre></div>\n\n<blockquote>\n<p><strong>Why Interrupts Must Be Disabled During Context Switch</strong></p>\n<p>Imagine this scenario:</p>\n<ol>\n<li>Timer fires, you start saving Process A&#39;s registers</li>\n<li>Halfway through, keyboard interrupt fires</li>\n<li>Keyboard handler uses the stack, overwriting data</li>\n<li>You return, load Process B&#39;s state</li>\n<li>Process B&#39;s stack is corrupted → crash</li>\n</ol>\n<p>The <code>cli</code> at the start of context switch prevents this. Interrupts are re-enabled by <code>iret</code> (which restores EFLAGS, including IF).</p>\n</blockquote>\n<hr>\n<h2 id=\"stage-3-the-round-robin-scheduler\">Stage 3: The Round-Robin Scheduler</h2>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-scheduler-round-robin.svg\" alt=\"Round-Robin Scheduler: Ready Queue Rotation\"></p>\n<p>The scheduler is simple: maintain a queue of ready processes, pick the next one on each timer tick.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* scheduler.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"scheduler.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"process.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"kprintf.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> context_switch_entry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> schedule_next</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (current_process </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // First process ever</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (ready_queue </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ready_queue;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current_process->state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PROCESS_STATE_RUNNING;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find next ready process after current</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current_process->next;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (next </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ready_queue;</span><span style=\"color:#6A737D\">  // Wrap around to front</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Search for a ready process</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (next->state </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> PROCESS_STATE_READY) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next->next;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (next </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ready_queue;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (next </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> start) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // No ready processes, keep running current</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mark old process as ready</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_process->state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PROCESS_STATE_READY;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mark new process as running</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_process->state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PROCESS_STATE_RUNNING;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update TSS ESP0 for this process</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    tss_update_esp0</span><span style=\"color:#E1E4E8\">(current_process->kernel_stack_top);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"the-timer-interrupt-hook\">The Timer Interrupt Hook</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* timer.c - updated for scheduling */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"timer.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"scheduler.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> timer_ticks;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> timer_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timer_ticks</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Trigger scheduler every 10 ms (at 100Hz, every tick)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // You could add a counter here for different quantum sizes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    schedule</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> schedule</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Only switch if there are multiple processes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ready_queue </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> ready_queue->next </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        context_switch_entry</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"stage-4-the-task-state-segment\">Stage 4: The Task State Segment</h2>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-tss-esp0.svg\" alt=\"TSS and ESP0: Ring 3 → Ring 0 Stack Switch\"></p>\n<p>The TSS is mandatory for ring 3 → ring 0 transitions. When a userspace process triggers an interrupt or syscall, the CPU:</p>\n<ol>\n<li>Looks up the TSS (via TR register)</li>\n<li>Loads SS0 and ESP0 from the TSS</li>\n<li>Switches to the kernel stack</li>\n<li>Pushes the userspace SS, ESP, EFLAGS, CS, EIP</li>\n<li>Jumps to the interrupt handler</li>\n</ol>\n<p>Without a valid TSS, the CPU has nowhere to push the userspace state—it triple faults.</p>\n<h3 id=\"tss-structure\">TSS Structure</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* tss.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> link, _pad0;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esp0;</span><span style=\"color:#6A737D\">          // Stack pointer for ring 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ss0, _pad1;</span><span style=\"color:#6A737D\">    // Stack segment for ring 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esp1;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ss1, _pad2;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esp2;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ss2, _pad3;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> cr3;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eip;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eflags;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eax, ecx, edx, ebx, esp, ebp, esi, edi;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> es, _pad4;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> cs, _pad5;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ss, _pad6;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ds, _pad7;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> fs, _pad8;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> gs, _pad9;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ldtr, _pad10;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> _pad11;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> iomap_base;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed)) </span><span style=\"color:#79B8FF\">tss_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#79B8FF\"> tss_t</span><span style=\"color:#E1E4E8\"> kernel_tss;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tss_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tss_update_esp0</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> esp0</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* tss.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"tss.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"gdt.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"kprintf.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">tss_t</span><span style=\"color:#E1E4E8\"> kernel_tss;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tss_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Zero the TSS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tss_t</span><span style=\"color:#E1E4E8\">); i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ((</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">kernel_tss)[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set up kernel stack for ring 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    kernel_tss.ss0 </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">      // Kernel data segment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    kernel_tss.esp0 </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">90000</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Initial kernel stack (will be updated)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set IO bitmap offset (beyond TSS = no IO permissions)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    kernel_tss.iomap_base </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tss_t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add TSS to GDT (you need a TSS descriptor in the GDT)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TSS descriptor at index 6 (adjust based on your GDT)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gdt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">kernel_tss, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tss_t</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                 0x</span><span style=\"color:#79B8FF\">89</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">  // Present, ring 0, type=64 (TSS available)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                 0x</span><span style=\"color:#79B8FF\">00</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Load TR (Task Register) with TSS selector</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> tr </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // GDT index 6, RPL=0, TI=0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">ltr %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(tr));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"TSS initialized at 0x</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\">, TR=</span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">kernel_tss, tr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tss_update_esp0</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> esp0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    kernel_tss.esp0 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> esp0;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<blockquote>\n<p><strong>The TSS Is Not Optional for User Mode</strong></p>\n<p>You might wonder: &quot;Can&#39;t I just switch stacks manually in my interrupt handler?&quot; No. The CPU <em>automatically</em> loads SS0:ESP0 from the TSS before pushing anything. If ESP0 is garbage, the push writes to garbage addresses. Triple fault is immediate and unrecoverable.</p>\n</blockquote>\n<hr>\n<h2 id=\"stage-5-user-mode-processes-and-isolation\">Stage 5: User-Mode Processes and Isolation</h2>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-user-kernel-pages.svg\" alt=\"User vs. Kernel Page Directories: Isolation\"></p>\n<p>A user-mode process runs at ring 3 with its own page directory. The kernel pages must be mapped but marked supervisor-only—the user bit (bit 2) must be 0 for kernel pages.</p>\n<h3 id=\"creating-user-page-directories\">Creating User Page Directories</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* user_memory.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"user_memory.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"vmm.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"pmm.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"kprintf.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> create_user_page_directory</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate a page for the new page directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pd_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">user_pd </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)pd_frame;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Zero the page directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        user_pd->entries[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Copy kernel mappings (higher half: entries 768-1023)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // These are supervisor-only (no PAGE_USER flag)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 768</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        user_pd->entries[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> kernel_page_directory->entries[i];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Ensure kernel pages are NOT user-accessible</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        user_pd->entries[i] </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#E1E4E8\">PAGE_USER;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate and map user code/data pages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For simplicity, we'll create a simple user address space:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 0x00000000 - 0x00400000: user code/data (4MB)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 0xBFFFF000 - 0xC0000000: user stack (4KB)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Map user code at 0x00001000</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> user_code_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vmm_map_page_user</span><span style=\"color:#E1E4E8\">(user_pd, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00001000</span><span style=\"color:#E1E4E8\">, user_code_frame, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                      PAGE_PRESENT </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PAGE_WRITABLE </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PAGE_USER);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Map user stack at 0xBFFFF000</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> user_stack_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vmm_map_page_user</span><span style=\"color:#E1E4E8\">(user_pd, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">BFFFF000</span><span style=\"color:#E1E4E8\">, user_stack_frame,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                      PAGE_PRESENT </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PAGE_WRITABLE </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PAGE_USER);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> pd_frame;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper function to map a page in a user page directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vmm_map_page_user</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> virtual_addr</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                       uint32_t</span><span style=\"color:#FFAB70\"> physical_addr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> flags</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Similar to vmm_map_page, but operates on the specified PD</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // and respects the user flags</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    virtual_addr </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFFF000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    physical_addr </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFFF000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pd_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (virtual_addr </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 22</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">3FF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pt_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (virtual_addr </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">3FF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get or create page table</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pt;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(pd->entries[pd_idx] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PAGE_PRESENT)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> pt_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)pt_frame;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pt->entries[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pd->entries[pd_idx] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pt_frame </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PAGE_PRESENT </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PAGE_WRITABLE </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PAGE_USER;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)(pd->entries[pd_idx] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFFF000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Map the page with user-accessible flag</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pt->entries[pt_idx] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> physical_addr </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> flags;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"jumping-to-user-mode\">Jumping to User Mode</h3>\n<p>The first entry into user mode is special—you can&#39;t just call a function. You must use <code>iret</code> with the user CS, SS, ESP, EIP, and EFLAGS properly set up on the stack.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; jump_to_user.asm\n[BITS 32]\n\nglobal jump_to_user_mode\nextern kernel_tss\n\njump_to_user_mode:\n    ; Args: EAX = user EIP, EBX = user ESP, ECX = user stack top (for TSS)\n    \n    ; Update TSS ESP0 before entering user mode\n    mov [kernel_tss + 4], ecx   ; tss_t.esp0 offset is 4\n    \n    ; Set up stack for iret to user mode\n    ; Stack must contain: SS, ESP, EFLAGS, CS, EIP\n    \n    ; Set up data segments\n    mov ax, 0x23        ; User data segment (index 5 * 8 = 0x28, OR 3 = 0x2B... wait, let me recalculate)\n                        ; Actually: index 4 = user code (0x20 | 3 = 0x23 for data? No...)\n                        ; GDT: 0=null, 1=kcode(0x08), 2=kdata(0x10), 3=ucode(0x18|3=0x1B), 4=udata(0x20|3=0x23)\n    mov ds, ax\n    mov es, ax\n    mov fs, ax\n    mov gs, ax\n    \n    ; Push user stack segment and pointer\n    push 0x23           ; User data segment (SS)\n    push ebx            ; User ESP\n    \n    ; Push EFLAGS with IF set\n    pushf\n    or dword [esp], 0x200   ; Set IF\n    popf\n    pushf              ; Push EFLAGS\n    \n    ; Push user code segment and EIP\n    push 0x1B           ; User code segment (CS)\n    push eax            ; User EIP\n    \n    ; iret jumps to user mode!\n    iret</code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* user_mode.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"user_mode.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> jump_to_user_mode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> eip</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> esp</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> kernel_esp</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> enter_user_mode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> entry_point</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> stack_top</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // We need to provide the kernel stack top for TSS ESP0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> kstack </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current_process->kernel_stack_top;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Jump to user mode - never returns</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    jump_to_user_mode</span><span style=\"color:#E1E4E8\">(entry_point, stack_top, kstack);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"stage-6-system-calls-via-int-0x80\">Stage 6: System Calls via INT 0x80</h2>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-syscall-int-0x80.svg\" alt=\"System Call: INT 0x80 Entry and Exit\"></p>\n<p>System calls are the controlled entry point from user mode to kernel mode. The user process triggers INT 0x80, the CPU switches to ring 0 (using TSS ESP0), and the kernel handler executes with full privileges.</p>\n<h3 id=\"system-call-handler\">System Call Handler</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* syscall.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SYS_EXIT</span><span style=\"color:#79B8FF\">  0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SYS_WRITE</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SYS_READ</span><span style=\"color:#79B8FF\">  2</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> syscall_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> syscall_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* syscall.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"syscall.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"process.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"vga.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"kprintf.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> syscall_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Register INT 0x80 handler</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)isr128, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">8E</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // DPL=3 allows user mode to call</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> syscall_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Syscall number in EAX</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Arguments in EBX, ECX, EDX</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> (regs->eax) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> SYS_WRITE: {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // sys_write(int fd, const char *buf, int len)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> regs->ebx;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">buf </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)regs->ecx;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            int</span><span style=\"color:#E1E4E8\"> len </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> regs->edx;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Simple implementation: write to VGA</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> len; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                vga_putchar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            regs->eax </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> len;</span><span style=\"color:#6A737D\">  // Return bytes written</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> SYS_EXIT: {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // sys_exit(int status)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            int</span><span style=\"color:#E1E4E8\"> status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> regs->ebx;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Process </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> exited with status </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    current_process->pid, status);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Mark process as zombie</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current_process->state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PROCESS_STATE_ZOMBIE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Force immediate reschedule</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            schedule</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> SYS_READ: {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // sys_read(int fd, char *buf, int len)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // For now, read from keyboard buffer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> regs->ebx;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">buf </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)regs->ecx;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            int</span><span style=\"color:#E1E4E8\"> len </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> regs->edx;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            int</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            while</span><span style=\"color:#E1E4E8\"> (count </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> len) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                char</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> keyboard_getchar_nonblocking</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (c </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                buf</span><span style=\"color:#E1E4E8\">[count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> c;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            regs->eax </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> count;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Unknown syscall: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, regs</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">eax</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            regs->eax </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Return error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"assembly-wrapper-for-int-0x80\">Assembly Wrapper for INT 0x80</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; syscall.asm\n[BITS 32]\n\nglobal sys_exit\nglobal sys_write\n\nsys_exit:\n    ; void sys_exit(int status)\n    mov eax, 0       ; SYS_EXIT\n    mov ebx, [esp + 4]  ; status\n    int 0x80\n    ret\n\nsys_write:\n    ; int sys_write(int fd, const char *buf, int len)\n    mov eax, 1       ; SYS_WRITE\n    mov ebx, [esp + 4]  ; fd\n    mov ecx, [esp + 8]  ; buf\n    mov edx, [esp + 12] ; len\n    int 0x80\n    ret</code></pre></div>\n\n<h3 id=\"user-mode-system-call-example\">User-Mode System Call Example</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* user_program.c - linked into user process */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// These are declared in the syscall assembly wrapper</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> sys_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> status</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> sys_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> len</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> user_main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">msg </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"Hello from user mode!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sys_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, msg, </span><span style=\"color:#79B8FF\">23</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sys_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"stage-7-multi-process-demo\">Stage 7: Multi-Process Demo</h2>\n<p>{{DIAGRAM:diag-multi-process-demo}}</p>\n<p>Let&#39;s create three kernel-mode processes that print to different screen regions, demonstrating preemptive multitasking.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* process_demo.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"process.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"vga.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Process A: prints 'A' to top-left region</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> process_a</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> col </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_putc_at</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, col, </span><span style=\"color:#9ECBFF\">'A'</span><span style=\"color:#E1E4E8\">, VGA_COLOR_GREEN);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        col </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (col </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 26</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Busy wait</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Process B: prints 'B' to middle region</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> process_b</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> col </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_putc_at</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, col, </span><span style=\"color:#9ECBFF\">'B'</span><span style=\"color:#E1E4E8\">, VGA_COLOR_BLUE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        col </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (col </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 26</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Process C: prints 'C' to bottom region</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> process_c</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> col </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_putc_at</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">, col, </span><span style=\"color:#9ECBFF\">'C'</span><span style=\"color:#E1E4E8\">, VGA_COLOR_RED);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        col </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (col </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 26</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> demo_create_processes</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    process_create</span><span style=\"color:#E1E4E8\">(process_a, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Kernel mode</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    process_create</span><span style=\"color:#E1E4E8\">(process_b, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    process_create</span><span style=\"color:#E1E4E8\">(process_c, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Created 3 demo processes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"updated-kernel-main\">Updated Kernel Main</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* main.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"vga.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"idt.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"pic.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"timer.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"keyboard.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"pmm.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"vmm.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"kmalloc.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"tss.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"process.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"syscall.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"process_demo.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> kernel_main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    serial_init</span><span style=\"color:#E1E4E8\">(COM1_PORT);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"=== MyOS Kernel ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize IDT and interrupts</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pic_remap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">40</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize memory management</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memory_map_init</span><span style=\"color:#E1E4E8\">(multiboot_info);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pmm_init</span><span style=\"color:#E1E4E8\">(memory_map, memory_map_count);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vmm_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    setup_page_tables</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    enable_paging</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kmalloc_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize TSS (required for user mode)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    tss_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize devices</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    timer_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 100 Hz = 10ms quantum</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    keyboard_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set up interrupt handlers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)isr0, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">8E</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... set all exception handlers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">14</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)isr14, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">8E</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Page fault</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)irq0, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">8E</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Timer</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">33</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)irq1, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">8E</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Keyboard</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set up system calls</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    syscall_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)isr128, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">EE</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // DPL=3 for user mode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Enable interrupts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">sti</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Creating demo processes...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    demo_create_processes</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Starting scheduler...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Become the idle process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">hlt</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"the-three-level-view-what-happens-during-a-context-switch\">The Three-Level View: What Happens During a Context Switch</h2>\n<p><strong>Level 1 — Application (Process Code)</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> process_a</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        do_work</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Timer fires here!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Process A is running, blissfully unaware. It calls <code>do_work()</code>, the timer fires mid-function, and... nothing. From A&#39;s perspective, time simply skipped forward.</p>\n<p><strong>Level 2 — Kernel (Scheduler)</strong>:</p>\n<ol>\n<li>Timer interrupt fires (IRQ0)</li>\n<li>CPU pushes EIP, CS, EFLAGS to A&#39;s stack</li>\n<li>CPU jumps to timer handler</li>\n<li>Handler saves A&#39;s general registers</li>\n<li>Handler calls <code>schedule()</code></li>\n<li>Scheduler picks Process B</li>\n<li><code>context_switch()</code> saves A&#39;s complete state to PCB</li>\n<li><code>context_switch()</code> loads B&#39;s state from PCB</li>\n<li><code>context_switch()</code> executes <code>iret</code></li>\n<li>CPU pops B&#39;s EIP, CS, EFLAGS and resumes B</li>\n</ol>\n<p><strong>Level 3 — Hardware (CPU and Memory)</strong>:</p>\n<ul>\n<li>The CR3 register changes from A&#39;s page directory to B&#39;s page directory. The TLB is flushed (unless global pages are used).</li>\n<li>The TSS ESP0 field is updated to point to B&#39;s kernel stack.</li>\n<li>The stack pointer (ESP) now points somewhere completely different in physical memory.</li>\n<li>The CPU&#39;s pipeline is flushed and refilled with instructions from B&#39;s code.</li>\n</ul>\n<p>The entire switch takes ~1-5 microseconds on modern hardware. Process A was interrupted mid-instruction-stream; Process B resumes mid-instruction-stream. Neither knows anything happened.</p>\n<hr>\n<h2 id=\"hardware-soul-context-switch-overhead\">Hardware Soul: Context Switch Overhead</h2>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Cost</th>\n<th>Why</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>General register save/restore</td>\n<td>~20 cycles</td>\n<td>8 registers × 2 (push/pop)</td>\n</tr>\n<tr>\n<td>CR3 reload (TLB flush)</td>\n<td>~100-500 cycles</td>\n<td>All non-global TLB entries invalidated</td>\n</tr>\n<tr>\n<td>Pipeline flush</td>\n<td>~10-20 cycles</td>\n<td>CPU fetches from new EIP</td>\n</tr>\n<tr>\n<td>Cache effects</td>\n<td>Variable</td>\n<td>B&#39;s working set may not be cached</td>\n</tr>\n<tr>\n<td>Total</td>\n<td>~150-1000 cycles</td>\n<td>~0.15-1 microsecond</td>\n</tr>\n</tbody></table>\n<p>The TLB flush is the most expensive part. If both processes are small (working set fits in TLB), the overhead is minimal. If processes are large (TLB misses on every access), the cost skyrockets. This is why:</p>\n<ul>\n<li>Servers use process pools (reuse processes, avoid CR3 reload)</li>\n<li>Games use thread pools (threads share address space, no CR3 reload)</li>\n<li>Kernels map themselves into every process (global pages, avoid TLB flush for kernel entries)</li>\n</ul>\n<hr>\n<h2 id=\"common-pitfalls\">Common Pitfalls</h2>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>System hangs after first context switch</td>\n<td>Forgot to re-enable interrupts</td>\n<td>Ensure EFLAGS has IF=1 (0x202)</td>\n</tr>\n<tr>\n<td>Page fault on user-mode entry</td>\n<td>TSS ESP0 not set or invalid</td>\n<td>Update TSS before <code>iret</code> to user mode</td>\n</tr>\n<tr>\n<td>Kernel memory accessible from user mode</td>\n<td>User bit set on kernel pages</td>\n<td>Clear PAGE_USER for kernel mappings</td>\n</tr>\n<tr>\n<td>Triple fault on syscall</td>\n<td>IDT gate 0x80 not configured or DPL=0</td>\n<td>Set DPL=3 (0xEE) for INT 0x80</td>\n</tr>\n<tr>\n<td>Process state corrupted</td>\n<td>Context switch not atomic</td>\n<td>Disable interrupts during switch</td>\n</tr>\n<tr>\n<td>Wrong process resumes</td>\n<td>Ready queue not circular</td>\n<td>Check queue links and wraparound</td>\n</tr>\n<tr>\n<td>Stack overflow in interrupt</td>\n<td>Nested interrupts without guard</td>\n<td>Use <code>cli</code> during critical sections</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"knowledge-cascade\">Knowledge Cascade</h2>\n<p>You&#39;ve built the foundation of multitasking. Here&#39;s where this connects:</p>\n<p><strong>→ Kernel Preemption (Advanced OS)</strong>: Your scheduler is voluntary—it only runs on timer ticks. A preemptive kernel allows context switches <em>anywhere</em> in kernel code, not just on timer interrupts. Linux tracks <code>preempt_count</code> to know when preemption is safe (not holding locks, not in interrupt context). The same context switch mechanism you built enables this finer-grained concurrency.</p>\n<p><strong>→ Thread Pools (Cross-Domain: Web Servers)</strong>: A web server creates N worker threads at startup. Each thread waits for work, processes a request, then waits again. This is exactly your process model—PCBs waiting on a queue, being scheduled, then returning to the queue. The difference: threads share an address space (same CR3), so switching is faster (no TLB flush).</p>\n<p><strong>→ Coroutine Runtimes (Cross-Domain: Async/Await)</strong>: Go&#39;s goroutines, Rust&#39;s async tasks, and JavaScript&#39;s promises all use the same fundamental technique: save registers to a structure, swap stack pointers, resume. The difference is they do it in userspace, without kernel involvement. A goroutine&#39;s &quot;PCB&quot; is just a Go runtime structure; the &quot;context switch&quot; is just a function call that swaps ESP.</p>\n<p><strong>→ Virtualization (Cross-Domain: Cloud)</strong>: When a VM executes a privileged instruction, the CPU triggers a &quot;VM exit&quot;—the hypervisor takes over. This is exactly a context switch: guest registers are saved to a VMCS (Virtual Machine Control Structure), host registers are restored, the hypervisor runs. The hypervisor&#39;s scheduler then decides which VM to run next. Your PCB is their VMCS; your context switch is their VM entry/exit.</p>\n<p><strong>→ Signal Delivery (Cross-Domain: Unix APIs)</strong>: When a process receives a signal, the kernel injects a &quot;function call&quot; into the process&#39;s execution. It modifies the saved user stack pointer to include the signal handler&#39;s arguments, then sets EIP to the handler&#39;s address. When the process resumes via <code>iret</code>, it &quot;returns&quot; into the signal handler. This is a controlled form of context switching—the same saved register manipulation you do in context_switch, but targeted at signal handling.</p>\n<hr>\n<p>[[CRITERIA_JSON: {&quot;milestone_id&quot;: &quot;build-os-m4&quot;, &quot;criteria&quot;: [&quot;Process control block (PCB) stores PID, register state (EIP, ESP, EBP, general-purpose registers, EFLAGS), page directory pointer (CR3), process state (ready/running/blocked), and kernel stack pointer&quot;, &quot;Context switch saves current process registers to its PCB and loads the next process&#39;s registers using assembly implementation for correctness&quot;, &quot;TSS (Task State Segment) configured with kernel stack pointer (SS0:ESP0) so CPU knows which stack to use for ring 3 to ring 0 transitions&quot;, &quot;Timer interrupt (IRQ0) triggers scheduler which selects next ready process in round-robin order and performs context switch&quot;, &quot;At least 3 kernel-mode processes run concurrently each printing to different screen region demonstrating preemptive multitasking&quot;, &quot;User-mode processes run in ring 3 with own page directory; accessing kernel memory triggers page fault due to supervisor-only bit&quot;, &quot;System call interface via INT 0x80: kernel reads syscall number from EAX and arguments from EBX/ECX/EDX, implementing sys_write and sys_exit at minimum&quot;, &quot;TSS ESP0 updated on every context switch to point to current process kernel stack top&quot;]}]</p>\n<!-- END_MS -->\n\n\n\n\n<h1 id=\"tdd\">TDD</h1>\n<p>A complete x86 operating system kernel built from scratch, demonstrating mastery of the hardware-software boundary. From the 512-byte bootloader constraint to preemptive multitasking with user-mode isolation, this project reveals how every software abstraction—processes, virtual memory, interrupts—negotiates with hardware physics: CPU pipelines, cache hierarchies, TLBs, and the memory bus. Each milestone is a layer in the stack that transforms raw hardware into a usable computing platform.</p>\n<!-- TDD_MOD_ID: build-os-m1 -->\n<h1 id=\"module-bootloader-gdt-and-kernel-entry\">Module: Bootloader, GDT, and Kernel Entry</h1>\n<h2 id=\"module-charter\">Module Charter</h2>\n<p>This module transforms a powered-on x86 CPU from 16-bit real mode into 32-bit protected mode running a C kernel. It handles the bootstrap problem: BIOS loads only 512 bytes, the CPU starts in a primitive state, and your kernel must be loaded from disk and given control. This module configures the GDT for flat addressing (base=0, limit=4GB), enables the A20 line for memory access above 1MB, loads the kernel binary to physical address 0x100000, and establishes VGA and serial output for debugging. It does NOT handle interrupts (Milestone 2), memory management (Milestone 3), or process scheduling (Milestone 4). The invariant is: after this module completes, the CPU is in protected mode with paging disabled, executing C code at a known address, with working output drivers.</p>\n<hr>\n<h2 id=\"file-structure\">File Structure</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>kernel/\n├── boot/\n│   ├── boot.asm              # 1. Stage 1 bootloader (MBR)\n│   ├── gdt.asm               # 3. GDT definitions\n│   └── kernel_entry.asm      # 5. Assembly entry point, BSS zeroing\n├── drivers/\n│   ├── vga.h                 # 6. VGA text mode header\n│   ├── vga.c                 # 6. VGA implementation\n│   ├── serial.h              # 7. Serial port header\n│   ├── serial.c              # 7. Serial implementation\n│   └── port_io.h             # 7. Inline I/O functions\n├── kernel/\n│   ├── main.c                # 5. Kernel C entry point\n│   ├── kprintf.h             # 7. Printf header\n│   └── kprintf.c             # 7. Printf implementation\n├── linker.ld                 # 4. Linker script\n└── Makefile                  # Build system</code></pre></div>\n\n<p>Files are numbered by creation order. Read existing files before editing.</p>\n<hr>\n<h2 id=\"complete-data-model\">Complete Data Model</h2>\n<h3 id=\"gdt-entry-segment-descriptor\">GDT Entry (Segment Descriptor)</h3>\n<p>Every GDT entry is 8 bytes. The layout is legacy x86 with split fields.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Offset  Size  Field\n------  ----  -----\n0       16    Limit bits 0-15\n2       24    Base bits 0-23\n4       1     Byte 6: flags + limit bits 16-19\n5       1     Byte 7: base bits 24-31\n\nByte 4 (Access Byte):\n  Bit 7: Present (P) - 1 for valid segments\n  Bits 5-6: DPL (Descriptor Privilege Level) - 00=ring 0, 11=ring 3\n  Bit 4: System (S) - 1 for code/data, 0 for system (TSS, gates)\n  Bit 3: Executable (E) - 1 for code, 0 for data\n  Bit 2: Direction/Conforming (DC) - for data: 0=grows up, for code: 0=non-conforming\n  Bit 1: Readable/Writable (RW) - for code: readable, for data: writable\n  Bit 0: Accessed (A) - CPU sets this when accessed\n\nByte 5 (Flags + Limit High):\n  Bit 7: Granularity (G) - 1 = 4KB blocks, 0 = 1 byte blocks\n  Bit 6: Size (D/B) - 1 = 32-bit, 0 = 16-bit\n  Bit 5: Long (L) - 1 = 64-bit (for long mode)\n  Bit 4: Available (AVL) - free for OS use\n  Bits 0-3: Limit bits 16-19</code></pre></div>\n\n<p><strong>Memory Layout (8 bytes, little-endian):</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Byte:    [0]   [1]   [2]   [3]   [4]   [5]   [6]   [7]\nField:   |----limit----| |-----base----| |acc| |flg| |base|\n         lo    hi      lo    mid       byte  lim+flg hi\n         0-7   8-15    0-15  16-23           16-19  24-31\n\nKernel Code Descriptor (0x00CF9A000000FFFF):\n  [0-1]: 0xFFFF  - limit low = 0xFFFF\n  [2-3]: 0x0000  - base low = 0\n  [4]:   0x00    - base mid = 0\n  [5]:   0x9A    - access: P=1, DPL=0, S=1, E=1, DC=0, RW=1, A=0\n  [6]:   0xCF    - flags: G=1, D=1, L=0, AVL=0; limit high = 0xF\n  [7]:   0x00    - base high = 0\n\nResult: base=0, limit=0xFFFFF with G=1 (4KB granularity) = 4GB</code></pre></div>\n\n<h3 id=\"gdt-descriptor-gdtr-load-value\">GDT Descriptor (GDTR Load Value)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> limit;</span><span style=\"color:#6A737D\">   // Size of GDT - 1 (in bytes)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> base;</span><span style=\"color:#6A737D\">    // Linear address of GDT</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed));</span></span></code></pre></div>\n\n<p>Size: 6 bytes. Loaded via <code>lgdt</code>.</p>\n<h3 id=\"vga-character-cell\">VGA Character Cell</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#E1E4E8\">     character;</span><span style=\"color:#6A737D\">  // ASCII code (0-255)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\">  attribute;</span><span style=\"color:#6A737D\">  // Color: high nibble = background, low nibble = foreground</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed));</span></span></code></pre></div>\n\n<p>Size: 2 bytes per cell. Buffer starts at 0xB8000. 80×25 = 2000 cells = 4000 bytes total.</p>\n<p><strong>Attribute Byte Encoding:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Bits 7-6-5-4: Background color (0-15, but 8-15 may blink)\nBits 3-2-1-0: Foreground color (0-15)\n\nColors:\n  0=Black, 1=Blue, 2=Green, 3=Cyan, 4=Red, 5=Magenta, 6=Brown, 7=Light Grey\n  8=Dark Grey, 9=Light Blue, 10=Light Green, 11=Light Cyan, 12=Light Red,\n  13=Light Magenta, 14=Yellow, 15=White</code></pre></div>\n\n<h3 id=\"serial-port-registers-com1-at-0x3f8\">Serial Port Registers (COM1 at 0x3F8)</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Offset  Register (DLAB=0)      Register (DLAB=1)\n------  -----------------      -----------------\n+0      Transmit/Receive       Divisor Latch Low\n+1      Interrupt Enable       Divisor Latch High\n+2      FIFO Control           (same)\n+3      Line Control           (same)\n+4      Modem Control          (same)\n+5      Line Status            (read-only)\n+6      Modem Status           (read-only)\n\nDLAB (Divisor Latch Access Bit) is bit 7 of Line Control Register (+3).</code></pre></div>\n\n<p><strong>Line Status Register (offset +5):</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Bit 5: Transmitter Holding Register Empty (THRE)\n       1 = Ready to transmit next byte</code></pre></div>\n\n<hr>\n<h2 id=\"interface-contracts\">Interface Contracts</h2>\n<h3 id=\"bootasm-stage-1-bootloader\">boot.asm: Stage 1 Bootloader</h3>\n<p><strong>Entry:</strong> CPU state after BIOS handoff</p>\n<ul>\n<li>CS:IP = 0x0000:0x7C00</li>\n<li>DL = boot drive number (0x80 for first HDD)</li>\n<li>Interrupts enabled, real mode (16-bit)</li>\n</ul>\n<p><strong>Exit:</strong> Protected mode, kernel loaded</p>\n<ul>\n<li>CPU in 32-bit protected mode</li>\n<li>CS = 0x08 (kernel code selector)</li>\n<li>DS/ES/FS/GS/SS = 0x10 (kernel data selector)</li>\n<li>ESP = 0x90000 (kernel stack)</li>\n<li>Kernel binary at 0x100000</li>\n<li>Control transferred to kernel_entry</li>\n</ul>\n<p><strong>Error Conditions:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Error</th>\n<th>Detection</th>\n<th>Recovery</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Disk read failure</td>\n<td>INT 13h CF set</td>\n<td>Print error, halt</td>\n</tr>\n<tr>\n<td>No boot signature</td>\n<td>BIOS check</td>\n<td>BIOS displays error</td>\n</tr>\n<tr>\n<td>A20 enable failure</td>\n<td>Test memory wrap</td>\n<td>Try alternate method, continue anyway</td>\n</tr>\n</tbody></table>\n<h3 id=\"kernel_entryasm-assembly-entry-point\">kernel_entry.asm: Assembly Entry Point</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Called from bootloader at physical address 0x100000</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// No parameters, no return value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> kernel_entry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Preconditions:</strong></p>\n<ul>\n<li>Protected mode enabled</li>\n<li>GDT loaded with flat selectors</li>\n<li>Stack valid at 0x90000</li>\n</ul>\n<p><strong>Postconditions:</strong></p>\n<ul>\n<li>BSS section zeroed</li>\n<li>kernel_main() called</li>\n<li>System halted if kernel_main returns (shouldn&#39;t happen)</li>\n</ul>\n<p><strong>Memory Layout Assumptions:</strong></p>\n<ul>\n<li><code>__bss_start</code> and <code>__bss_end</code> defined by linker script</li>\n<li>BSS may be 0 bytes (check before zeroing)</li>\n</ul>\n<h3 id=\"vga_init-vga_putchar-vga_puts\">vga_init / vga_putchar / vga_puts</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Initialize VGA to known state (clear screen, cursor at 0,0)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vga_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Output single character with current colors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Handles '\\n' (newline), '\\r' (carriage return), '\\t' (tab to next 8-column boundary)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Scrolls screen when row 24 overflows (move lines 1-24 up, clear line 24)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vga_putchar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> c</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Output null-terminated string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">str</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Set foreground/background colors for subsequent output</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vga_set_color</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">vga_color_t</span><span style=\"color:#FFAB70\"> fg</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">vga_color_t</span><span style=\"color:#FFAB70\"> bg</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Preconditions:</strong> VGA buffer accessible at 0xB8000</p>\n<p><strong>Edge Cases:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Input</th>\n<th>Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&#39;\\n&#39;</td>\n<td>Move to column 0, increment row, scroll if needed</td>\n</tr>\n<tr>\n<td>&#39;\\r&#39;</td>\n<td>Move to column 0 only</td>\n</tr>\n<tr>\n<td>&#39;\\t&#39;</td>\n<td>Move to next column where (col % 8 == 0)</td>\n</tr>\n<tr>\n<td>&#39;\\b&#39;</td>\n<td>Move back one column, clear cell</td>\n</tr>\n<tr>\n<td>Row 25</td>\n<td>Scroll: copy rows 1-24 to 0-23, clear row 24</td>\n</tr>\n</tbody></table>\n<h3 id=\"serial_init-serial_putchar-serial_puts\">serial_init / serial_putchar / serial_puts</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> COM1_PORT</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">3F8</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> COM2_PORT</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">2F8</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize serial port at 38400 baud, 8N1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns 0 on success, -1 if port not present</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> serial_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Output single byte, blocks until transmitter ready</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> serial_putchar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> c</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Output null-terminated string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> serial_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">str</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Preconditions:</strong> Port I/O instructions available (in protected mode)</p>\n<p><strong>Error Handling:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Error</th>\n<th>Detection</th>\n<th>Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Port not present</td>\n<td>No response to initialization</td>\n<td>Return -1 from init</td>\n</tr>\n<tr>\n<td>Transmitter timeout</td>\n<td>Loop without THRE bit</td>\n<td>Infinite loop (hardware failure)</td>\n</tr>\n</tbody></table>\n<h3 id=\"kprintf\">kprintf</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Formatted output to VGA and serial</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Supports: %s (string), %c (char), %d (int), %x (hex), %p (pointer)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns number of characters printed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...);</span></span></code></pre></div>\n\n<p><strong>Format Specifiers:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Specifier</th>\n<th>Type</th>\n<th>Output</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%s</td>\n<td>const char*</td>\n<td>Null-terminated string</td>\n</tr>\n<tr>\n<td>%c</td>\n<td>int</td>\n<td>Single character</td>\n</tr>\n<tr>\n<td>%d</td>\n<td>int</td>\n<td>Signed decimal</td>\n</tr>\n<tr>\n<td>%u</td>\n<td>unsigned int</td>\n<td>Unsigned decimal</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>unsigned int</td>\n<td>Hexadecimal (lowercase)</td>\n</tr>\n<tr>\n<td>%X</td>\n<td>unsigned int</td>\n<td>Hexadecimal (uppercase)</td>\n</tr>\n<tr>\n<td>%p</td>\n<td>void*</td>\n<td>Pointer as hex with 0x prefix</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"algorithm-specification\">Algorithm Specification</h2>\n<h3 id=\"algorithm-a20-line-enablement\">Algorithm: A20 Line Enablement</h3>\n<p><strong>Purpose:</strong> Enable address line 20 to access memory above 1MB.</p>\n<p><strong>Inputs:</strong> None\n<strong>Outputs:</strong> A20 enabled (memory at 0x100000 accessible)</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li><p>Try fast A20 method (port 0x92):</p>\n<ul>\n<li>Read port 0x92</li>\n<li>Set bit 1 (A20), clear bit 0 (reset)</li>\n<li>Write back to port 0x92</li>\n<li>Wait 1µs (I/O delay)</li>\n<li>Test if A20 is enabled</li>\n</ul>\n</li>\n<li><p>If fast A20 failed, try keyboard controller method:</p>\n<ul>\n<li>Disable keyboard (command 0xAD)</li>\n<li>Read controller output port (command 0xD0)</li>\n<li>Write output port with bit 1 set (command 0xD1, data with A20 bit)</li>\n<li>Enable keyboard (command 0xAE)</li>\n<li>Wait for controller ready between each step</li>\n</ul>\n</li>\n<li><p>Test A20:</p>\n<ul>\n<li>Write 0x00 to 0x0000:0x0500</li>\n<li>Write 0xFF to 0xFFFF:0x0510 (wraps to 0x0000:0x0500 if A20 disabled)</li>\n<li>Compare values at 0x0000:0x0500</li>\n<li>If different, A20 is enabled</li>\n</ul>\n</li>\n</ol>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>Memory below 1MB remains accessible throughout</li>\n<li>Keyboard controller not left in undefined state</li>\n</ul>\n<h3 id=\"algorithm-protected-mode-transition\">Algorithm: Protected Mode Transition</h3>\n<p><strong>Purpose:</strong> Switch CPU from 16-bit real mode to 32-bit protected mode.</p>\n<p><strong>Inputs:</strong> GDT at known address\n<strong>Outputs:</strong> CPU in protected mode, CS=0x08, data segments=0x10</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>Disable interrupts (cli)</li>\n<li>Load GDTR with GDT address and limit</li>\n<li>Set CR0.PE bit (bit 0)</li>\n<li>Far jump to flush pipeline: <code>jmp 0x08:protected_mode_entry</code></li>\n<li>In 32-bit code:<ul>\n<li>Load data segment registers with 0x10</li>\n<li>Set up stack pointer</li>\n<li>Continue execution</li>\n</ul>\n</li>\n</ol>\n<p><strong>Critical:</strong> Step 4 must immediately follow step 3. The far jump is not optional—the prefetch queue contains 16-bit instructions.</p>\n<h3 id=\"algorithm-vga-scrolling\">Algorithm: VGA Scrolling</h3>\n<p><strong>Purpose:</strong> Scroll screen up one line when cursor reaches bottom.</p>\n<p><strong>Inputs:</strong> None (operates on VGA buffer)\n<strong>Outputs:</strong> Screen scrolled, cursor at start of last row</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>Copy rows 1-24 to rows 0-23:<ul>\n<li>Source: 0xB8000 + 160 (row 1)</li>\n<li>Dest: 0xB8000 (row 0)</li>\n<li>Count: 160 × 24 = 3840 bytes</li>\n</ul>\n</li>\n<li>Clear row 24:<ul>\n<li>Write space character (0x20) with current attribute</li>\n<li>Count: 80 cells = 160 bytes</li>\n</ul>\n</li>\n<li>Set cursor to row 24, column 0</li>\n</ol>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>VGA buffer memory unchanged outside rows 0-24</li>\n<li>Cursor position valid after scroll</li>\n</ul>\n<hr>\n<h2 id=\"error-handling-matrix\">Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th>Error</th>\n<th>Detected By</th>\n<th>Recovery</th>\n<th>User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Disk read failure (INT 13h error)</td>\n<td>Carry flag set after INT 13h</td>\n<td>Print &quot;Disk error&quot; via BIOS teletype, halt</td>\n<td>Yes, on screen</td>\n</tr>\n<tr>\n<td>No boot signature</td>\n<td>BIOS before loading MBR</td>\n<td>BIOS displays &quot;No bootable device&quot;</td>\n<td>Yes, BIOS message</td>\n</tr>\n<tr>\n<td>A20 line stuck disabled</td>\n<td>Memory wrap test fails</td>\n<td>Print warning, continue (may crash later)</td>\n<td>Yes, serial debug</td>\n</tr>\n<tr>\n<td>GDT too large</td>\n<td>Compile-time (must be &lt; 64KB)</td>\n<td>N/A (compile error)</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Triple fault after CR0.PE</td>\n<td>CPU resets</td>\n<td>System reboots</td>\n<td>Yes, visible reboot</td>\n</tr>\n<tr>\n<td>BSS overlap with code</td>\n<td>Linker script error</td>\n<td>Link fails</td>\n<td>No</td>\n</tr>\n<tr>\n<td>VGA buffer not accessible</td>\n<td>Page fault (if paging enabled)</td>\n<td>Crash</td>\n<td>Yes, blank screen</td>\n</tr>\n<tr>\n<td>Serial port not present</td>\n<td>No THRE bit timeout</td>\n<td>Skip serial output</td>\n<td>No, VGA still works</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"implementation-sequence-with-checkpoints\">Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-stage-1-bootloader-4-6-hours\">Phase 1: Stage 1 Bootloader (4-6 hours)</h3>\n<p><strong>Files:</strong> boot/boot.asm</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Set up real mode segment registers and stack</li>\n<li>Print boot message via BIOS INT 10h</li>\n<li>Enable A20 line</li>\n<li>Load kernel from disk to temporary buffer (below 1MB)</li>\n<li>Configure GDT</li>\n<li>Enter protected mode with far jump</li>\n<li>Copy kernel to 0x100000</li>\n<li>Jump to kernel entry</li>\n</ol>\n<p><strong>Checkpoint:</strong> Bootloader prints &quot;Loading...&quot; and reaches protected mode without triple fault.</p>\n<p><strong>Test:</strong> <code>qemu-system-i386 -drive format=raw,file=boot.bin -d int,cpu_reset 2&gt;&amp;1 | grep &quot;SMM: enter&quot;</code></p>\n<hr>\n<h3 id=\"phase-2-gdt-configuration-2-3-hours\">Phase 2: GDT Configuration (2-3 hours)</h3>\n<p><strong>Files:</strong> boot/gdt.asm (or inline in boot.asm)</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Define GDT with 5 entries: null, kcode, kdata, ucode, udata</li>\n<li>Create GDT descriptor (limit, base)</li>\n<li>Verify GDT entries byte-by-byte</li>\n</ol>\n<p><strong>Checkpoint:</strong> GDT loads without fault. Use <code>info gdt</code> in QEMU monitor.</p>\n<p><strong>Test:</strong> </p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> -monitor</span><span style=\"color:#9ECBFF\"> stdio</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># In monitor: info gdt</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-3-kernel-entry-and-linker-script-2-3-hours\">Phase 3: Kernel Entry and Linker Script (2-3 hours)</h3>\n<p><strong>Files:</strong> boot/kernel_entry.asm, linker.ld, kernel/main.c</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Create linker script placing kernel at 0x100000</li>\n<li>Write assembly entry that zeros BSS and calls main</li>\n<li>Write minimal main() that halts</li>\n</ol>\n<p><strong>Checkpoint:</strong> Kernel entry reached, main() called.</p>\n<p><strong>Test:</strong> Add infinite loop in main(), verify QEMU doesn&#39;t crash.</p>\n<hr>\n<h3 id=\"phase-4-vga-driver-2-3-hours\">Phase 4: VGA Driver (2-3 hours)</h3>\n<p><strong>Files:</strong> drivers/vga.h, drivers/vga.c</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Define VGA buffer pointer at 0xB8000</li>\n<li>Implement vga_init() to clear screen</li>\n<li>Implement vga_putchar() with newline and scrolling</li>\n<li>Implement vga_puts()</li>\n<li>Test from main()</li>\n</ol>\n<p><strong>Checkpoint:</strong> &quot;Hello from kernel!&quot; appears on screen.</p>\n<p><strong>Test:</strong> </p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">vga_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"VGA test passed!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-5-serial-driver-1-2-hours\">Phase 5: Serial Driver (1-2 hours)</h3>\n<p><strong>Files:</strong> drivers/serial.h, drivers/serial.c, drivers/port_io.h</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Implement outb/inb inline functions</li>\n<li>Implement serial_init() with 38400 baud, 8N1</li>\n<li>Implement serial_putchar() with THRE wait</li>\n<li>Test output to serial</li>\n</ol>\n<p><strong>Checkpoint:</strong> Serial output visible in QEMU console with <code>-serial stdio</code>.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> -serial</span><span style=\"color:#9ECBFF\"> stdio</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should see output in terminal</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-6-kprintf-2-3-hours\">Phase 6: kprintf (2-3 hours)</h3>\n<p><strong>Files:</strong> kernel/kprintf.h, kernel/kprintf.c</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Implement string output (call vga_putchar and serial_putchar)</li>\n<li>Implement %s, %c, %d, %x</li>\n<li>Handle width padding (optional)</li>\n<li>Test all format specifiers</li>\n</ol>\n<p><strong>Checkpoint:</strong> kprintf(&quot;Kernel loaded at 0x%x\\n&quot;, 0x100000) outputs correctly.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Testing: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#79B8FF\"> %d</span><span style=\"color:#79B8FF\"> %x</span><span style=\"color:#79B8FF\"> %c\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"string\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">42</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">DEAD</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'X'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Expected: \"Testing: string 42 dead X\"</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-7-integration-and-full-test-2-3-hours\">Phase 7: Integration and Full Test (2-3 hours)</h3>\n<p><strong>Files:</strong> Makefile</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Write Makefile to assemble, compile, link, create disk image</li>\n<li>Build complete disk image</li>\n<li>Test in QEMU with VGA and serial output</li>\n<li>Verify boot sequence with GDB</li>\n</ol>\n<p><strong>Checkpoint:</strong> Kernel boots, displays welcome message on both VGA and serial.</p>\n<p><strong>Test Command:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">make</span><span style=\"color:#9ECBFF\"> run</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should see: \"Welcome to MyOS!\" on screen and serial</span></span></code></pre></div>\n\n<p><strong>GDB Debug:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#79B8FF\"> -S</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gdb</span><span style=\"color:#79B8FF\"> -ex</span><span style=\"color:#9ECBFF\"> \"target remote localhost:1234\"</span><span style=\"color:#79B8FF\"> -ex</span><span style=\"color:#9ECBFF\"> \"break *0x7C00\"</span><span style=\"color:#79B8FF\"> -ex</span><span style=\"color:#9ECBFF\"> \"continue\"</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"test-specification\">Test Specification</h2>\n<h3 id=\"test-bootloader-loads-and-enters-protected-mode\">Test: Bootloader Loads and Enters Protected Mode</h3>\n<p><strong>Setup:</strong> Create boot.bin with boot signature\n<strong>Steps:</strong></p>\n<ol>\n<li>Run QEMU with disk image</li>\n<li>Check QEMU doesn&#39;t reset (triple fault)</li>\n</ol>\n<p><strong>Expected:</strong> QEMU continues running, no reset</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">timeout</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#9ECBFF\"> qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=boot.bin</span><span style=\"color:#79B8FF\"> -d</span><span style=\"color:#9ECBFF\"> cpu_reset</span><span style=\"color:#F97583\"> 2>&#x26;1</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"CPU reset\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: 0</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-gdt-configuration-valid\">Test: GDT Configuration Valid</h3>\n<p><strong>Setup:</strong> Bootloader with GDT, halted in protected mode</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Boot in QEMU with monitor</li>\n<li>Inspect GDT</li>\n</ol>\n<p><strong>Expected:</strong> 5 entries, base=0, limit=0xFFFFF, correct access bytes</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># In QEMU monitor:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">info</span><span style=\"color:#9ECBFF\"> gdt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check: entry 1 = code, entry 2 = data, both ring 0</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-vga-output\">Test: VGA Output</h3>\n<p><strong>Setup:</strong> Kernel with VGA driver</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Call vga_init()</li>\n<li>Call vga_puts(&quot;Test&quot;)</li>\n<li>Read VGA buffer at 0xB8000</li>\n</ol>\n<p><strong>Expected:</strong> &#39;T&#39;, &#39;e&#39;, &#39;s&#39;, &#39;t&#39; at positions 0-3</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In kernel:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">vga_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Test\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Verification (could be separate test):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#F97583\"> uint16_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">VGA_BUFFER;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">VGA_BUFFER</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">'T'</span><span style=\"color:#F97583\"> |</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">0F</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">)));</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-serial-output\">Test: Serial Output</h3>\n<p><strong>Setup:</strong> Kernel with serial driver</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Initialize COM1</li>\n<li>Output test string</li>\n<li>Capture serial output in QEMU</li>\n</ol>\n<p><strong>Expected:</strong> String appears on serial console</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> -serial</span><span style=\"color:#9ECBFF\"> file:serial.out</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># After boot, serial.out contains expected string</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-kprintf-format-specifiers\">Test: kprintf Format Specifiers</h3>\n<p><strong>Setup:</strong> Kernel with kprintf</p>\n<p><strong>Test Cases:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Input</th>\n<th>Expected Output</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>kprintf(&quot;Hello&quot;)</code></td>\n<td>&quot;Hello&quot;</td>\n</tr>\n<tr>\n<td><code>kprintf(&quot;%s&quot;, &quot;world&quot;)</code></td>\n<td>&quot;world&quot;</td>\n</tr>\n<tr>\n<td><code>kprintf(&quot;%d&quot;, 42)</code></td>\n<td>&quot;42&quot;</td>\n</tr>\n<tr>\n<td><code>kprintf(&quot;%d&quot;, -17)</code></td>\n<td>&quot;-17&quot;</td>\n</tr>\n<tr>\n<td><code>kprintf(&quot;%x&quot;, 0xDEAD)</code></td>\n<td>&quot;dead&quot;</td>\n</tr>\n<tr>\n<td><code>kprintf(&quot;%c&quot;, &#39;X&#39;)</code></td>\n<td>&quot;X&quot;</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"performance-targets\">Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Target</th>\n<th>How to Measure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Boot to kernel entry</td>\n<td>&lt; 100ms</td>\n<td>QEMU <code>-d</code> flag with timestamps</td>\n</tr>\n<tr>\n<td>VGA putchar</td>\n<td>&lt; 1µs</td>\n<td>Not critical (human reading speed)</td>\n</tr>\n<tr>\n<td>Serial putchar</td>\n<td>&lt; 10µs</td>\n<td>Baud rate limited (38400 = ~260µs/char)</td>\n</tr>\n<tr>\n<td>BSS zeroing (1KB)</td>\n<td>&lt; 10µs</td>\n<td><code>rep stosb</code> at ~100 MB/s</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"hardware-soul\">Hardware Soul</h2>\n<h3 id=\"cache-behavior\">Cache Behavior</h3>\n<ul>\n<li><strong>GDT (48 bytes):</strong> Fits in single L1 cache line (64 bytes). <code>lgdt</code> loads entire GDT to internal CPU registers; subsequent memory access doesn&#39;t re-read GDT.</li>\n<li><strong>VGA buffer (4KB):</strong> Memory-mapped I/O, marked uncacheable (UC). Writes go directly to bus, not cache. This is why VGA output is slow—every character incurs bus latency (~100ns).</li>\n</ul>\n<h3 id=\"branch-prediction\">Branch Prediction</h3>\n<p>Boot code is linear:</p>\n<ul>\n<li>No loops except A20 test (runs once)</li>\n<li>No function calls except far jump</li>\n<li>Pipeline flush on far jump is intentional (required for mode switch)</li>\n</ul>\n<h3 id=\"tlb-behavior\">TLB Behavior</h3>\n<p>N/A before paging enabled. After paging (Milestone 3), VGA buffer must have a TLB entry.</p>\n<h3 id=\"memory-access-patterns\">Memory Access Patterns</h3>\n<ul>\n<li><strong>Disk read:</strong> Sequential (LBA 0, 1, 2, ...) — prefetch-friendly</li>\n<li><strong>VGA write:</strong> Random access (cursor position varies) — cache-hostile, but doesn&#39;t matter (MMIO)</li>\n<li><strong>BSS zeroing:</strong> Sequential write — maximum bandwidth</li>\n</ul>\n<hr>\n<h2 id=\"visual-diagrams\">Visual Diagrams</h2>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-001.svg\" alt=\"Boot Sequence: BIOS to Kernel Entry\"></p>\n<p>Boot sequence: BIOS → MBR → Protected Mode → Kernel Entry</p>\n<p>{{DIAGRAM:tdd-diag-002}}\nGDT entry layout with byte-by-byte breakdown</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-003.svg\" alt=\"Real Mode to Protected Mode Transition\"></p>\n<p>Memory map: bootloader at 0x7C00, kernel at 0x100000, stack at 0x90000</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-004.svg\" alt=\"Linker Script: Section Placement\"></p>\n<p>VGA buffer layout: 80×25 cells, 2 bytes per cell</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-005.svg\" alt=\"VGA Text Buffer Memory Layout\"></p>\n<p>Serial port register map and initialization sequence</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-006.svg\" alt=\"Serial Port Initialization Sequence\"></p>\n<p>Protected mode transition: CR0.PE → far jump → segment reload</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-007.svg\" alt=\"kprintf Data Flow\"></p>\n<p>Linker script section placement: .text, .rodata, .data, .bss</p>\n<p>{{DIAGRAM:tdd-diag-008}}\nDual output: kprintf → VGA + Serial</p>\n<hr>\n<p>[[CRITERIA_JSON: {&quot;module_id&quot;: &quot;build-os-m1&quot;, &quot;criteria&quot;: [&quot;Bootloader fits in 512 bytes (MBR) or uses a two-stage approach with stage1 in MBR loading stage2 from disk&quot;, &quot;Bootloader reads kernel binary from disk using BIOS INT 13h and loads it to physical address 0x100000 (1MB mark)&quot;, &quot;GDT configured with 5 entries: null descriptor, kernel code (ring 0, base=0, limit=4GB, executable+readable), kernel data (ring 0, base=0, limit=4GB, writable), user code (ring 3), user data (ring 3)&quot;, &quot;Protected mode entered by setting CR0.PE bit after loading GDTR, followed by a far jump to kernel code segment to flush the pipeline&quot;, &quot;Segment registers DS, ES, FS, GS, SS loaded with kernel data segment selector (0x10) after the far jump to protected mode&quot;, &quot;Kernel entry point (assembly) zeroes BSS section from __bss_start to __bss_end and calls kernel_main()&quot;, &quot;VGA text mode driver writes characters with foreground/background color attributes to memory-mapped buffer at 0xB8000&quot;, &quot;Serial port COM1 (0x3F8) initialized for debug output with kprintf-like function outputting to both VGA and serial&quot;, &quot;Kernel boots successfully in QEMU displaying welcome message on screen and serial console&quot;]}]</p>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-os-m2 -->\n<h1 id=\"module-interrupts-exceptions-and-keyboard\">Module: Interrupts, Exceptions, and Keyboard</h1>\n<h2 id=\"module-charter\">Module Charter</h2>\n<p>This module transforms your kernel from a passive program into a reactive system by implementing the interrupt subsystem. It configures the Interrupt Descriptor Table (IDT) with 256 gate descriptors, establishes CPU exception handlers (vectors 0-31) that capture and report processor faults, remaps the 8259 Programmable Interrupt Controller to route hardware IRQs to vectors 32-47, implements a timer interrupt (IRQ0) that provides the scheduling heartbeat, and builds a PS/2 keyboard driver that translates scancodes to ASCII characters. The module does NOT implement preemptive scheduling (Milestone 4), system calls (Milestone 4), or advanced interrupt controllers like APIC. The invariant is: after this module completes, every hardware event (timer tick, keystroke) and CPU exception (page fault, divide error) is captured, processed with full register preservation, and the system remains in a consistent state.</p>\n<hr>\n<h2 id=\"file-structure\">File Structure</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>kernel/\n├── interrupt/\n│   ├── idt.h                 # 1. IDT structures and declarations\n│   ├── idt.c                 # 1. IDT initialization and gate setting\n│   ├── interrupt.h           # 3. Common interrupt handler interface\n│   ├── interrupt.c           # 3. C handler dispatch\n│   ├── isr.asm               # 2. Exception handler assembly stubs\n│   ├── irq.asm               # 5. IRQ handler assembly stubs\n│   ├── exception.h           # 2. Exception handler declarations\n│   └── exception.c           # 2. Exception-specific handling\n├── pic/\n│   ├── pic.h                 # 4. PIC interface\n│   └── pic.c                 # 4. PIC remapping and EOI\n├── timer/\n│   ├── timer.h               # 6. Timer interface\n│   └── timer.c               # 6. PIT channel 0 programming\n├── keyboard/\n│   ├── keyboard.h            # 7. Keyboard interface\n│   ├── keyboard.c            # 7. Scancode translation\n│   └── scancode.h            # 7. Scancode-to-ASCII tables\n└── Makefile                  # Updated build system</code></pre></div>\n\n<hr>\n<h2 id=\"complete-data-model\">Complete Data Model</h2>\n<h3 id=\"idt-entry-gate-descriptor\">IDT Entry (Gate Descriptor)</h3>\n<p>Every IDT entry is 8 bytes, defining where to jump when an interrupt occurs.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Offset  Size  Field\n------  ----  -----\n0       16    Offset bits 0-15 (handler address low)\n2       16    Segment selector (code segment to use)\n4       8     Reserved (must be 0)\n5       8     Type and attributes\n6       16    Offset bits 16-31 (handler address high)\n\nByte 5 (Type/Attributes):\n  Bit 7: Present (P) - 1 = valid gate\n  Bits 5-6: DPL (Descriptor Privilege Level) - 00=ring 0 only, 11=ring 3 can invoke\n  Bit 4: Storage Segment (S) - 0 for interrupt/trap gates\n  Bits 0-3: Gate Type:\n    0x5 = 32-bit task gate (rarely used)\n    0x6 = 16-bit interrupt gate\n    0x7 = 16-bit trap gate\n    0xE = 32-bit interrupt gate (interrupts disabled on entry)\n    0xF = 32-bit trap gate (interrupts stay enabled)</code></pre></div>\n\n<p><strong>Memory Layout (8 bytes, little-endian):</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Byte:    [0]   [1]   [2]   [3]   [4]   [5]   [6]   [7]\nField:   |--offset_low--| |--selector--| |res| |typ| |--offset_high-|\n         handler_addr    code_seg       0    attrs  handler_addr+16\n\nInterrupt Gate Example (handler at 0x00101234, CS=0x08, DPL=0):\n  [0-1]: 0x1234  - offset low\n  [2-3]: 0x0008  - selector (kernel code)\n  [4]:   0x00    - reserved\n  [5]:   0x8E    - P=1, DPL=0, S=0, Type=0xE (32-bit interrupt gate)\n  [6-7]: 0x0010  - offset high</code></pre></div>\n\n<h3 id=\"idt-pointer-idtr-load-value\">IDT Pointer (IDTR Load Value)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> limit;</span><span style=\"color:#6A737D\">    // Size of IDT - 1 (in bytes): 256 * 8 - 1 = 0x7FF</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> base;</span><span style=\"color:#6A737D\">     // Linear address of IDT array</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed)) </span><span style=\"color:#79B8FF\">idt_ptr_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p>Size: 6 bytes. Loaded via <code>lidt</code>.</p>\n<h3 id=\"interrupt-stack-frame\">Interrupt Stack Frame</h3>\n<p>When an interrupt fires, the CPU pushes a specific frame to the stack. The layout depends on privilege level transition.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Kernel-to-Kernel (same privilege):\nOffset  Field\n------  -----\n+0      EFLAGS\n+4      CS\n+8      EIP\n+12     [Error code if exception 8, 10-14, 17, 21, 29, 30]\n\nUser-to-Kernel (privilege transition):\nOffset  Field\n------  -----\n+0      SS (old)\n+4      ESP (old)\n+8      EFLAGS\n+12     CS\n+16     EIP\n+20     [Error code if applicable]</code></pre></div>\n\n<p><strong>Handler-Pushed State (after CPU pushes):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Segment registers (pushed by handler)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> gs, fs, es, ds;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // General-purpose registers (pushed by pusha)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // pusha order: EDI, ESI, EBP, ESP (original), EBX, EDX, ECX, EAX</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> edi, esi, ebp, esp_ignored, ebx, edx, ecx, eax;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handler-pushed interrupt number and error code</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> int_no;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> err_code;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // CPU-pushed state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eip;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> cs;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eflags;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Only present if privilege transition occurred</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> useresp;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ss;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed)) </span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p><strong>Memory Layout (stack grows down):</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>High addresses\n│\n│  [useresp]     &lt;- only if CS.RPL != 0\n│  [ss]          &lt;- only if CS.RPL != 0\n│  eflags\n│  cs\n│  eip\n│  err_code      &lt;- only for exceptions 8,10-14,17,21,29,30\n│  int_no        &lt;- pushed by our stub\n│  eax           &lt;- pusha: last pushed = lowest address\n│  ecx\n│  edx\n│  ebx\n│  esp_ignored   &lt;- value before pusha\n│  ebp\n│  esi\n│  edi           &lt;- pusha: first pushed\n│  ds\n│  es\n│  fs\n│  gs            &lt;- stack pointer points here after all pushes\n│\nLow addresses (ESP points here)</code></pre></div>\n\n<h3 id=\"pic-registers\">PIC Registers</h3>\n<p>The 8259 PIC has two chips, each with command and data ports.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Master PIC (IRQ0-7):\n  0x20 - Command port (ICW1, OCW2, OCW3)\n  0x21 - Data port (ICW2, ICW3, ICW4, OCW1 - mask)\n\nSlave PIC (IRQ8-15):\n  0xA0 - Command port\n  0xA1 - Data port\n\nInitialization Command Words (ICW):\n  ICW1 (command port): \n    Bit 0: IC4 - need ICW4\n    Bit 1: SNGL - single (0) vs cascade (1)\n    Bit 4: Init - must be 1\n    Others: 0\n  \n  ICW2 (data port): Vector offset base (IRQ0 → vector N)\n  \n  ICW3 (data port):\n    Master: bit mask of which IRQ has slave (bit 2 = IRQ2)\n    Slave: slave ID (2)\n  \n  ICW4 (data port):\n    Bit 0: 8086 mode (1)\n    Bit 1: Auto-EOI (0 for manual)\n    Bits 4-5: Buffer mode (0)\n\nOperation Control Words:\n  OCW1 (data port): IRQ mask (1 = masked)\n  OCW2 (command port): EOI and priority\n    0x20 = Non-specific EOI\n    0x60 = Specific EOI for IRQ0 (not used)</code></pre></div>\n\n<h3 id=\"pit-timer-registers\">PIT (Timer) Registers</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>0x40 - Channel 0 data port (IRQ0)\n0x41 - Channel 1 data port (DRAM refresh, unused)\n0x42 - Channel 2 data port (speaker)\n0x43 - Mode/Command register\n\nCommand byte (write to 0x43):\n  Bits 6-7: Channel select (00=0, 01=1, 10=2, 11=read-back)\n  Bits 4-5: Access mode (00=latch, 01=low, 10=high, 11=low then high)\n  Bits 1-3: Operating mode (000=int on TC, 011=square wave, etc.)\n  Bit 0: BCD (0=binary)\n\nSquare wave command: 0x36 = 00 11 011 0 = channel 0, lobyte/hibyte, square wave, binary</code></pre></div>\n\n<h3 id=\"keyboard-buffer\">Keyboard Buffer</h3>\n<p>Circular buffer for decoupling interrupt-driven scancode arrival from synchronous character consumption.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KBUFFER_SIZE</span><span style=\"color:#79B8FF\"> 256</span><span style=\"color:#6A737D\">  // Must be power of 2 for efficient modulo</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> buffer</span><span style=\"color:#E1E4E8\">[KBUFFER_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    volatile</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> read_pos;</span><span style=\"color:#6A737D\">   // Consumer index</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    volatile</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> write_pos;</span><span style=\"color:#6A737D\">  // Producer index (IRQ handler)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">keyboard_buffer_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Buffer full: (write_pos + 1) % KBUFFER_SIZE == read_pos</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Buffer empty: read_pos == write_pos</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Available: (write_pos - read_pos) % KBUFFER_SIZE</span></span></code></pre></div>\n\n<p><strong>Cache Line Analysis:</strong></p>\n<ul>\n<li><code>keyboard_buffer_t</code> is ~260 bytes = 5 cache lines</li>\n<li><code>read_pos</code> and <code>write_pos</code> are on separate cache lines from <code>buffer</code> (good for false sharing)</li>\n<li>Producer (IRQ) and consumer (main) access different cache lines primarily</li>\n</ul>\n<hr>\n<h2 id=\"interface-contracts\">Interface Contracts</h2>\n<h3 id=\"idt_init-idt_set_gate\">idt_init / idt_set_gate</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Initialize IDT with 256 entries, all set to present but pointing to dummy handler</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> idt_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Set a specific IDT gate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// num: vector number (0-255)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// handler: 32-bit address of handler function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// selector: code segment selector (typically 0x08 for kernel)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// flags: type/attributes byte (0x8E for interrupt gate, 0x8F for trap gate)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> handler</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> selector</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> flags</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Load IDT (called internally by idt_init)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> idt_load</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Preconditions:</strong> GDT loaded with valid code segment at selector</p>\n<p><strong>Postconditions:</strong> IDT loaded, CPU will jump to handlers on interrupt</p>\n<h3 id=\"exception-handlers-isr-0-31\">Exception Handlers (ISR 0-31)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Each exception has a dedicated assembly entry point</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// These are declared global in isr.asm, referenced in idt.c</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Assembly stubs (in isr.asm):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> isr0</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Divide by zero</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> isr1</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Debug</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> isr2</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Non-maskable interrupt</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> isr3</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Breakpoint</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> isr4</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Overflow</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> isr5</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Bound range exceeded</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> isr6</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Invalid opcode</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> isr7</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Device not available</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> isr8</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Double fault (has error code)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> isr9</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Coprocessor segment overrun</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> isr10</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Invalid TSS (has error code)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> isr11</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Segment not present (has error code)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> isr12</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Stack-segment fault (has error code)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> isr13</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // General protection fault (has error code)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> isr14</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Page fault (has error code)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ... 15-31 reserved</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// C handler called by assembly stub</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> exception_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Error Code Presence (CPU-pushed):</strong></p>\n<table>\n<thead>\n<tr>\n<th>Vector</th>\n<th>Exception</th>\n<th>Error Code?</th>\n<th>Error Code Meaning</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>Divide error</td>\n<td>No</td>\n<td>N/A</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Debug</td>\n<td>No</td>\n<td>N/A</td>\n</tr>\n<tr>\n<td>2</td>\n<td>NMI</td>\n<td>No</td>\n<td>N/A</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Breakpoint</td>\n<td>No</td>\n<td>N/A</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Invalid opcode</td>\n<td>No</td>\n<td>N/A</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Device not available</td>\n<td>No</td>\n<td>N/A</td>\n</tr>\n<tr>\n<td>8</td>\n<td>Double fault</td>\n<td>Yes</td>\n<td>0 (always)</td>\n</tr>\n<tr>\n<td>10</td>\n<td>Invalid TSS</td>\n<td>Yes</td>\n<td>Selector index</td>\n</tr>\n<tr>\n<td>11</td>\n<td>Segment not present</td>\n<td>Yes</td>\n<td>Selector index</td>\n</tr>\n<tr>\n<td>12</td>\n<td>Stack fault</td>\n<td>Yes</td>\n<td>Selector index</td>\n</tr>\n<tr>\n<td>13</td>\n<td>General protection</td>\n<td>Yes</td>\n<td>Selector index or 0</td>\n</tr>\n<tr>\n<td>14</td>\n<td>Page fault</td>\n<td>Yes</td>\n<td>P, W, U bits (see below)</td>\n</tr>\n</tbody></table>\n<p><strong>Page Fault Error Code (Exception 14):</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Bit 0 (P): 0 = page not present, 1 = protection violation\nBit 1 (W): 0 = read access, 1 = write access\nBit 2 (U): 0 = kernel mode, 1 = user mode\nBit 3 (R): 1 = reserved bit set in page table\nBit 4 (I): 1 = instruction fetch (NX violation)</code></pre></div>\n\n<h3 id=\"irq-handlers-irq-0-15\">IRQ Handlers (IRQ 0-15)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Assembly stubs (in irq.asm):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> irq0</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Timer (PIT channel 0)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> irq1</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Keyboard (PS/2)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> irq2</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Cascade (slave PIC)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> irq3</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // COM2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> irq4</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // COM1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> irq5</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // LPT2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> irq6</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Floppy</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> irq7</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // LPT1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> irq8</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // RTC</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> irq9</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Free</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> irq10</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Free</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> irq11</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Free</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> irq12</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // PS/2 mouse</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> irq13</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // FPU</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> irq14</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Primary ATA</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> irq15</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Secondary ATA</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// C handler called by assembly stub</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> irq_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Vector Mapping (after PIC remap):</strong></p>\n<table>\n<thead>\n<tr>\n<th>IRQ</th>\n<th>Vector</th>\n<th>Source</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>32</td>\n<td>Timer (PIT)</td>\n</tr>\n<tr>\n<td>1</td>\n<td>33</td>\n<td>Keyboard</td>\n</tr>\n<tr>\n<td>2</td>\n<td>34</td>\n<td>Cascade</td>\n</tr>\n<tr>\n<td>3-7</td>\n<td>35-39</td>\n<td>Various</td>\n</tr>\n<tr>\n<td>8</td>\n<td>40</td>\n<td>RTC</td>\n</tr>\n<tr>\n<td>9-15</td>\n<td>41-47</td>\n<td>Various</td>\n</tr>\n</tbody></table>\n<h3 id=\"pic_remap-pic_send_eoi\">pic_remap / pic_send_eoi</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Remap PIC to route IRQs to vectors starting at offset1 (master) and offset2 (slave)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Must be called before enabling interrupts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Standard: offset1=32, offset2=40</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pic_remap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> offset1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> offset2</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Send End of Interrupt to PIC(s)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Must be called at end of every IRQ handler</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// irq: IRQ number (0-15), not vector number</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pic_send_eoi</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> irq</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Mask/unmask specific IRQ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pic_mask_irq</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> irq</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pic_unmask_irq</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> irq</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Preconditions:</strong> PIC exists and is responsive</p>\n<p><strong>Postconditions:</strong> IRQs routed to correct vectors, EOI mechanism working</p>\n<p><strong>CRITICAL:</strong> <code>pic_send_eoi</code> must be called for every IRQ. Forgetting this freezes the system.</p>\n<h3 id=\"timer_init-timer_handler\">timer_init / timer_handler</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIT_BASE_FREQUENCY</span><span style=\"color:#79B8FF\"> 1193182</span><span style=\"color:#6A737D\">  // Hz</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize PIT channel 0 to fire at specified frequency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// frequency: desired interrupt rate in Hz (typically 100-1000)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> timer_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> frequency</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Called by IRQ handler on timer interrupt</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> timer_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Global tick counter (incremented every timer interrupt)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#E1E4E8\"> timer_ticks;</span></span></code></pre></div>\n\n<p><strong>Preconditions:</strong> PIC remapped, IRQ0 unmasked, IDT gate 32 set</p>\n<p><strong>Edge Cases:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Frequency</th>\n<th>Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&lt; 19</td>\n<td>Clamped to 19 (PIT minimum)</td>\n</tr>\n<tr>\n<td>&gt; 1.19 MHz</td>\n<td>Clamped to max (divisor=1)</td>\n</tr>\n<tr>\n<td>0</td>\n<td>Division error, halt</td>\n</tr>\n</tbody></table>\n<h3 id=\"keyboard_init-keyboard_handler-keyboard_getchar\">keyboard_init / keyboard_handler / keyboard_getchar</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KEYBOARD_PORT</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">60</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize keyboard driver (clear buffer, reset state)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> keyboard_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Called by IRQ handler on keyboard interrupt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Reads scancode from port 0x60, translates to ASCII, stores in buffer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> keyboard_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Blocking read: returns next ASCII character from buffer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Waits (via hlt) until character available</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#B392F0\"> keyboard_getchar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Non-blocking read: returns character or 0 if buffer empty</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#B392F0\"> keyboard_getchar_nonblocking</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Check if characters available</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> keyboard_has_char</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Preconditions:</strong> PIC remapped, IRQ1 unmasked, IDT gate 33 set</p>\n<p><strong>Edge Cases:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Scancode</th>\n<th>Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0x2A, 0x36</td>\n<td>Shift pressed, set flag</td>\n</tr>\n<tr>\n<td>0xAA, 0xB6</td>\n<td>Shift released, clear flag</td>\n</tr>\n<tr>\n<td>0x3A</td>\n<td>Caps lock toggle</td>\n</tr>\n<tr>\n<td>0xE0</td>\n<td>Extended scancode prefix (arrow keys, etc.)</td>\n</tr>\n<tr>\n<td>0x80+</td>\n<td>Break code (key released), ignore</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"algorithm-specification\">Algorithm Specification</h2>\n<h3 id=\"algorithm-idt-gate-installation\">Algorithm: IDT Gate Installation</h3>\n<p><strong>Purpose:</strong> Configure a single IDT entry to jump to a handler.</p>\n<p><strong>Inputs:</strong> </p>\n<ul>\n<li>Vector number (0-255)</li>\n<li>Handler address (32-bit)</li>\n<li>Selector (16-bit code segment)</li>\n<li>Flags (8-bit type/attributes)</li>\n</ul>\n<p><strong>Outputs:</strong> IDT entry populated, handler reachable</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>Calculate array index (same as vector number)</li>\n<li>Store offset_low = handler &amp; 0xFFFF</li>\n<li>Store selector as-is</li>\n<li>Store reserved byte = 0</li>\n<li>Store flags byte (type, DPL, present)</li>\n<li>Store offset_high = (handler &gt;&gt; 16) &amp; 0xFFFF</li>\n</ol>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>All 256 entries exist after initialization</li>\n<li>Present bit set only for installed handlers</li>\n<li>Handler address is within code segment</li>\n</ul>\n<h3 id=\"algorithm-interrupt-entry-assembly-stub\">Algorithm: Interrupt Entry (Assembly Stub)</h3>\n<p><strong>Purpose:</strong> Save CPU state, call C handler, restore state, return.</p>\n<p><strong>Inputs:</strong> None (triggered by CPU on interrupt)\n<strong>Outputs:</strong> C handler called, EOI sent (for IRQs), system state preserved</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li><strong>Save segment registers:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   push ds, es, fs, gs</code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Load kernel data segment:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   mov ax, 0x10\n   mov ds, ax\n   mov es, ax\n   mov fs, ax\n   mov gs, ax</code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Save general-purpose registers:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   pusha  ; pushes EDI, ESI, EBP, ESP, EBX, EDX, ECX, EAX</code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Push interrupt number:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   push byte &lt;int_no&gt;</code></pre></div>\n\n<ol start=\"5\">\n<li><strong>Call C handler:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   push esp        ; pass pointer to saved state\n   call c_interrupt_handler\n   add esp, 4      ; clean up argument</code></pre></div>\n\n<ol start=\"6\">\n<li><strong>Restore general-purpose registers:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   popa</code></pre></div>\n\n<ol start=\"7\">\n<li><strong>Restore segment registers:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   pop gs, fs, es, ds</code></pre></div>\n\n<ol start=\"8\">\n<li><strong>Clean up interrupt number and error code:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   add esp, 8      ; int_no + (error_code or dummy)</code></pre></div>\n\n<ol start=\"9\">\n<li><strong>Return from interrupt:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   iret</code></pre></div>\n\n<p><strong>Critical:</strong> For exceptions that don&#39;t push error code, the stub must push a dummy 0 before pushing int_no. This ensures uniform stack frame.</p>\n<h3 id=\"algorithm-exception-with-error-code-handling\">Algorithm: Exception with Error Code Handling</h3>\n<p><strong>Purpose:</strong> Handle the fact that some exceptions push error codes and some don&#39;t.</p>\n<p><strong>Inputs:</strong> Exception vector number\n<strong>Outputs:</strong> Uniform stack frame for C handler</p>\n<p><strong>Procedure:</strong></p>\n<p>For exceptions WITHOUT error code (use macro):</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>isrN:\n    cli\n    push byte 0        ; Dummy error code\n    push byte N        ; Interrupt number\n    jmp isr_common_stub</code></pre></div>\n\n<p>For exceptions WITH error code (use macro):</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>isrM:\n    cli\n    push byte M        ; Interrupt number (error already pushed by CPU)\n    jmp isr_common_stub</code></pre></div>\n\n<p><strong>Vectors requiring error code handling:</strong></p>\n<ul>\n<li>WITH error code: 8, 10, 11, 12, 13, 14, 17, 21, 29, 30</li>\n<li>WITHOUT error code: 0-7, 9, 15, 16, 18-20, 22-28, 31</li>\n</ul>\n<h3 id=\"algorithm-pic-remapping\">Algorithm: PIC Remapping</h3>\n<p><strong>Purpose:</strong> Change IRQ-to-vector mapping from broken defaults to usable range.</p>\n<p><strong>Inputs:</strong> Offset1 (master base vector), offset2 (slave base vector)\n<strong>Outputs:</strong> IRQ0-7 → vectors 32-39, IRQ8-15 → vectors 40-47</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li><strong>Save current masks:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   in al, 0x21   ; Master mask\n   mov [master_mask], al\n   in al, 0xA1   ; Slave mask\n   mov [slave_mask], al</code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Start initialization (ICW1):</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   out 0x20, 0x11   ; Master: init + need ICW4\n   out 0xA0, 0x11   ; Slave: init + need ICW4</code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Set vector offsets (ICW2):</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   out 0x21, offset1   ; Master: IRQ0 → vector 32\n   out 0xA1, offset2   ; Slave: IRQ8 → vector 40</code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Configure cascade (ICW3):</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   out 0x21, 0x04   ; Master: slave at IRQ2 (bit 2 set)\n   out 0xA1, 0x02   ; Slave: I am slave ID 2</code></pre></div>\n\n<ol start=\"5\">\n<li><strong>Set mode (ICW4):</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   out 0x21, 0x01   ; Master: 8086 mode, manual EOI\n   out 0xA1, 0x01   ; Slave: 8086 mode, manual EOI</code></pre></div>\n\n<ol start=\"6\">\n<li><strong>Restore masks:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   mov al, [master_mask]\n   out 0x21, al\n   mov al, [slave_mask]\n   out 0xA1, al</code></pre></div>\n\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>Master and slave both in 8086 mode</li>\n<li>Slave connected to master IRQ2</li>\n<li>No IRQs lost during remap (interrupts disabled)</li>\n</ul>\n<h3 id=\"algorithm-eoi-handling\">Algorithm: EOI Handling</h3>\n<p><strong>Purpose:</strong> Tell PIC that interrupt handling is complete, allow next IRQ.</p>\n<p><strong>Inputs:</strong> IRQ number (0-15)\n<strong>Outputs:</strong> PIC in-service register updated</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>If IRQ &gt;= 8 (from slave):</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   out 0xA0, 0x20   ; EOI to slave</code></pre></div>\n<ol start=\"2\">\n<li>Always send EOI to master:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   out 0x20, 0x20   ; EOI to master</code></pre></div>\n\n<p><strong>CRITICAL:</strong> Order matters. Slave EOI first, then master.</p>\n<p><strong>Why this matters:</strong> Without EOI, the PIC&#39;s In-Service Register keeps the IRQ marked active. The PIC will not deliver any lower-priority IRQs. System appears frozen.</p>\n<h3 id=\"algorithm-timer-frequency-programming\">Algorithm: Timer Frequency Programming</h3>\n<p><strong>Purpose:</strong> Configure PIT channel 0 to fire at desired frequency.</p>\n<p><strong>Inputs:</strong> Desired frequency in Hz\n<strong>Outputs:</strong> IRQ0 firing at specified rate</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>Calculate divisor:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   divisor = PIT_BASE_FREQUENCY / frequency\n   if divisor &lt; 1: divisor = 1\n   if divisor &gt; 65535: divisor = 65535</code></pre></div>\n\n<ol start=\"2\">\n<li>Send command byte:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   out 0x43, 0x36   ; Channel 0, lobyte/hibyte, square wave, binary</code></pre></div>\n\n<ol start=\"3\">\n<li>Send divisor (low byte first):</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   out 0x40, divisor &amp; 0xFF\n   out 0x40, (divisor &gt;&gt; 8) &amp; 0xFF</code></pre></div>\n\n<p><strong>Example:</strong> 100 Hz frequency</p>\n<ul>\n<li>divisor = 1193182 / 100 = 11931</li>\n<li>Low byte: 0x1B</li>\n<li>High byte: 0x2E</li>\n</ul>\n<h3 id=\"algorithm-scancode-translation\">Algorithm: Scancode Translation</h3>\n<p><strong>Purpose:</strong> Convert hardware scancode to ASCII character.</p>\n<p><strong>Inputs:</strong> Scancode byte from port 0x60\n<strong>Outputs:</strong> ASCII character (or 0 for non-printable)</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li><p>Read scancode from port 0x60</p>\n</li>\n<li><p>Check if break code (bit 7 set):</p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   if scancode &amp; 0x80:\n       scancode &amp;= 0x7F\n       if scancode == LEFT_SHIFT or RIGHT_SHIFT:\n           shift_pressed = 0\n       return  ; Ignore other break codes</code></pre></div>\n\n<ol start=\"3\">\n<li>Handle modifier keys:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   if scancode == LEFT_SHIFT or scancode == RIGHT_SHIFT:\n       shift_pressed = 1\n       return\n   if scancode == CAPS_LOCK:\n       caps_lock = !caps_lock\n       return</code></pre></div>\n\n<ol start=\"4\">\n<li>Translate using table:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   if shift_pressed xor caps_lock:\n       ascii = scancode_shift_table[scancode]\n   else:\n       ascii = scancode_table[scancode]</code></pre></div>\n\n<ol start=\"5\">\n<li>Store in buffer if printable:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   if ascii != 0:\n       buffer[write_pos] = ascii\n       write_pos = (write_pos + 1) % KBUFFER_SIZE</code></pre></div>\n\n<p><strong>Scancode Set 1 (US QWERTY) Partial Table:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Scancode  Key      Normal  Shift\n--------  ---      ------  -----\n0x02      1        1       !\n0x03      2        2       @\n0x04      3        3       #\n...\n0x10      Q        q       Q\n0x11      W        w       W\n0x12      E        e       E\n...\n0x1E      A        a       A\n0x1F      S        s       S\n...\n0x39      Space    ' '     ' '</code></pre></div>\n\n<hr>\n<h2 id=\"error-handling-matrix\">Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th>Error</th>\n<th>Detected By</th>\n<th>Recovery</th>\n<th>User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Triple fault</td>\n<td>CPU reset</td>\n<td>System reboots</td>\n<td>Yes, reboot loop</td>\n</tr>\n<tr>\n<td>Missing EOI</td>\n<td>System hangs (no more IRQs)</td>\n<td>N/A (prevent by code review)</td>\n<td>Yes, frozen system</td>\n</tr>\n<tr>\n<td>Stack overflow in handler</td>\n<td>Page fault or random crash</td>\n<td>Increase stack size</td>\n<td>Yes, crash</td>\n</tr>\n<tr>\n<td>Exception during exception</td>\n<td>Double fault (vector 8)</td>\n<td>Print diagnostic, halt</td>\n<td>Yes, error message</td>\n</tr>\n<tr>\n<td>Invalid IDT entry</td>\n<td>General protection fault</td>\n<td>GPF handler prints info</td>\n<td>Yes, error message</td>\n</tr>\n<tr>\n<td>PIC not responding</td>\n<td>Timeout on I/O</td>\n<td>Continue, warn on serial</td>\n<td>Debug only</td>\n</tr>\n<tr>\n<td>Keyboard buffer overflow</td>\n<td>write_pos catches read_pos</td>\n<td>Drop oldest character</td>\n<td>No (or key lost)</td>\n</tr>\n<tr>\n<td>Unknown scancode</td>\n<td>No table entry</td>\n<td>Ignore, no buffer write</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Page fault in handler</td>\n<td>Infinite page fault loop</td>\n<td>Use task gate or reserved stack</td>\n<td>Yes, crash</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"state-machine-keyboard-modifier-state\">State Machine: Keyboard Modifier State</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>           +-----------------+\n           |    NORMAL       |\n           +-------+---------+\n                   |\n        +----------+----------+\n        |                     |\n  Shift press            Caps lock press\n        |                     |\n        v                     v\n+---------------+      +-------------+\n| SHIFT_ACTIVE  |      | CAPS_ACTIVE |\n+-------+-------+      +------+------+\n        |                     |\n  Shift release          Caps lock press\n        |                     |\n        v                     v\n+-------+-------+      +-------------+\n|    NORMAL     |      |   NORMAL    |\n+---------------+      +-------------+\n\nTranslation logic:\n  uppercase = shift_pressed XOR caps_lock</code></pre></div>\n\n<hr>\n<h2 id=\"implementation-sequence-with-checkpoints\">Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-idt-structure-and-loading-2-3-hours\">Phase 1: IDT Structure and Loading (2-3 hours)</h3>\n<p><strong>Files:</strong> interrupt/idt.h, interrupt/idt.c</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Define <code>idt_entry_t</code> and <code>idt_ptr_t</code> structures</li>\n<li>Declare IDT array (256 entries)</li>\n<li>Implement <code>idt_set_gate()</code></li>\n<li>Implement <code>idt_load()</code> with inline assembly</li>\n<li>Implement <code>idt_init()</code> to clear all entries</li>\n</ol>\n<p><strong>Checkpoint:</strong> IDT loads without fault. <code>info idt</code> in QEMU shows 256 entries.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> -monitor</span><span style=\"color:#9ECBFF\"> stdio</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># In monitor: info idt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show IDT at loaded address</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-2-exception-handlers-4-5-hours\">Phase 2: Exception Handlers (4-5 hours)</h3>\n<p><strong>Files:</strong> interrupt/isr.asm, interrupt/exception.h, interrupt/exception.c</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Define macros <code>ISR_NO_ERROR</code> and <code>ISR_ERROR</code></li>\n<li>Implement all 32 exception stubs</li>\n<li>Implement <code>isr_common_stub</code> that saves/restores all registers</li>\n<li>Implement <code>exception_handler()</code> in C with descriptive messages</li>\n<li>Register exception handlers in IDT</li>\n</ol>\n<p><strong>Checkpoint:</strong> Trigger divide by zero, see exception message.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In kernel_main, after IDT init:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> b;</span><span style=\"color:#6A737D\">  // Should trigger exception 0</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-3-interrupt-stack-frame-3-4-hours\">Phase 3: Interrupt Stack Frame (3-4 hours)</h3>\n<p><strong>Files:</strong> interrupt/interrupt.h, interrupt/interrupt.c</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Define <code>registers_t</code> structure matching stack layout</li>\n<li>Implement <code>c_interrupt_handler()</code> that dispatches based on int_no</li>\n<li>Update assembly stub to pass stack pointer to C handler</li>\n<li>Add debug output to dump registers on exception</li>\n</ol>\n<p><strong>Checkpoint:</strong> Exception handler prints all register values correctly.</p>\n<p><strong>Test:</strong> Trigger page fault by accessing invalid address:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">DEADBEEF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 42</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Page fault</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-4-pic-remapping-2-3-hours\">Phase 4: PIC Remapping (2-3 hours)</h3>\n<p><strong>Files:</strong> pic/pic.h, pic/pic.c</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Implement <code>pic_remap()</code> with ICW1-ICW4 sequence</li>\n<li>Implement <code>pic_send_eoi()</code></li>\n<li>Implement <code>pic_mask_irq()</code> and <code>pic_unmask_irq()</code></li>\n<li>Call <code>pic_remap(32, 40)</code> before enabling interrupts</li>\n</ol>\n<p><strong>Checkpoint:</strong> IRQ0 (timer) doesn&#39;t trigger double fault.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">pic_remap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">40</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pic_unmask_irq</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Enable timer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">__asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">sti</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// If no double fault, remap succeeded</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-5-eoi-handling-and-irq-routing-2-3-hours\">Phase 5: EOI Handling and IRQ Routing (2-3 hours)</h3>\n<p><strong>Files:</strong> interrupt/irq.asm, pic/pic.c (update)</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Define IRQ stubs (irq0-irq15) in assembly</li>\n<li>Implement <code>irq_common_stub</code> similar to ISR stub</li>\n<li>Implement <code>irq_handler()</code> in C that calls <code>pic_send_eoi()</code></li>\n<li>Register IRQ handlers in IDT at vectors 32-47</li>\n</ol>\n<p><strong>Checkpoint:</strong> Timer interrupt fires repeatedly without hanging.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">timer_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pic_unmask_irq</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">__asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">sti</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Wait 1 second, check timer_ticks ≈ 100</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-6-timer-interrupt-2-3-hours\">Phase 6: Timer Interrupt (2-3 hours)</h3>\n<p><strong>Files:</strong> timer/timer.h, timer/timer.c</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Implement <code>timer_init()</code> to program PIT channel 0</li>\n<li>Implement <code>timer_handler()</code> to increment tick counter</li>\n<li>Register timer handler in IRQ dispatch</li>\n<li>Add <code>timer_get_seconds()</code> helper</li>\n</ol>\n<p><strong>Checkpoint:</strong> Timer ticks increment at expected rate.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">timer_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 100 Hz</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\"> start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> timer_ticks;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Wait ~1 second (busy loop or hlt loop)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\"> elapsed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> timer_ticks </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Ticks: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (expected ~100)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, elapsed);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-7-ps2-keyboard-driver-3-4-hours\">Phase 7: PS/2 Keyboard Driver (3-4 hours)</h3>\n<p><strong>Files:</strong> keyboard/keyboard.h, keyboard/keyboard.c, keyboard/scancode.h</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Implement <code>keyboard_init()</code> to clear buffer</li>\n<li>Define scancode-to-ASCII tables (normal and shifted)</li>\n<li>Implement <code>keyboard_handler()</code> to read scancode, translate, store</li>\n<li>Handle shift press/release</li>\n<li>Register keyboard handler in IRQ dispatch</li>\n</ol>\n<p><strong>Checkpoint:</strong> Keystrokes appear in buffer.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">keyboard_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pic_unmask_irq</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Enable keyboard IRQ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">__asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">sti</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Press keys, check buffer contents</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-8-circular-keyboard-buffer-1-2-hours\">Phase 8: Circular Keyboard Buffer (1-2 hours)</h3>\n<p><strong>Files:</strong> keyboard/keyboard.c (update)</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Implement circular buffer with read_pos/write_pos</li>\n<li>Implement <code>keyboard_getchar()</code> with blocking (hlt)</li>\n<li>Implement <code>keyboard_getchar_nonblocking()</code></li>\n<li>Handle buffer overflow (drop oldest or ignore new)</li>\n</ol>\n<p><strong>Checkpoint:</strong> <code>keyboard_getchar()</code> returns typed characters.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Type something: \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> keyboard_getchar</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%c</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, c);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (c </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'q'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"test-specification\">Test Specification</h2>\n<h3 id=\"test-idt-loads-without-fault\">Test: IDT Loads Without Fault</h3>\n<p><strong>Setup:</strong> IDT initialized with 256 entries</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Call <code>idt_init()</code></li>\n<li>Verify <code>lidt</code> executed (check with QEMU monitor)</li>\n</ol>\n<p><strong>Expected:</strong> No triple fault, IDT visible in QEMU</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> -monitor</span><span style=\"color:#9ECBFF\"> stdio</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># In monitor:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">info</span><span style=\"color:#9ECBFF\"> idt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show: IDT base=0x... limit=0x7ff</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-exception-handler-catches-divide-error\">Test: Exception Handler Catches Divide Error</h3>\n<p><strong>Setup:</strong> Exception 0 handler registered</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Execute division by zero</li>\n<li>Verify exception handler called</li>\n</ol>\n<p><strong>Expected:</strong> &quot;Division by zero&quot; message printed</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> x </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> y </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> z </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> x </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> y;</span><span style=\"color:#6A737D\">  // Exception 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Should not reach here</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-exception-handler-catches-page-fault\">Test: Exception Handler Catches Page Fault</h3>\n<p><strong>Setup:</strong> Exception 14 handler registered, paging enabled</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Access invalid memory address</li>\n<li>Verify CR2 read and error code decoded</li>\n</ol>\n<p><strong>Expected:</strong> Page fault message with faulting address</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">DEADBEEF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 42</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Page fault</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Should not reach here</span></span></code></pre></div>\n\n<p><strong>Verify CR2:</strong> Handler should print CR2 = 0xDEADBEEF</p>\n<hr>\n<h3 id=\"test-pic-remapped-correctly\">Test: PIC Remapped Correctly</h3>\n<p><strong>Setup:</strong> PIC remapped to vectors 32-47</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Enable timer interrupt</li>\n<li>Verify no double fault</li>\n</ol>\n<p><strong>Expected:</strong> Timer fires without triggering exception 8</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">pic_remap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">40</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">irq0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">8E</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pic_unmask_irq</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">timer_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">__asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">sti</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// If we get here, remap succeeded</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-eoi-sent-on-every-irq\">Test: EOI Sent on Every IRQ</h3>\n<p><strong>Setup:</strong> Timer interrupt enabled</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Let timer fire multiple times</li>\n<li>Verify ticks increment</li>\n</ol>\n<p><strong>Expected:</strong> Multiple timer interrupts without system freeze</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">timer_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">__asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">sti</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Busy wait</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// timer_ticks should be > 0</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(timer_ticks </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-timer-frequency-accuracy\">Test: Timer Frequency Accuracy</h3>\n<p><strong>Setup:</strong> Timer at 100 Hz</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Record start ticks</li>\n<li>Wait approximately 1 second</li>\n<li>Record end ticks</li>\n</ol>\n<p><strong>Expected:</strong> ~100 ticks (±10%)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">timer_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\"> start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> timer_ticks;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Wait ~1 second (could use PIT channel 2 for precise timing)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 50000000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\"> elapsed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> timer_ticks </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Elapsed ticks: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (expected ~100)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">elapsed</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-keyboard-scancode-translation\">Test: Keyboard Scancode Translation</h3>\n<p><strong>Setup:</strong> Keyboard interrupt enabled</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Press &#39;A&#39; key</li>\n<li>Check buffer contains &#39;a&#39;</li>\n</ol>\n<p><strong>Expected:</strong> &#39;a&#39; (lowercase) in buffer</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">keyboard_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">__asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">sti</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// User presses 'A'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> keyboard_getchar</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(c </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'a'</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-shift-key-modifies-output\">Test: Shift Key Modifies Output</h3>\n<p><strong>Setup:</strong> Keyboard interrupt enabled</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Hold shift, press &#39;A&#39;</li>\n<li>Check buffer contains &#39;A&#39;</li>\n</ol>\n<p><strong>Expected:</strong> &#39;A&#39; (uppercase) in buffer</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// User holds shift and presses 'A'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> keyboard_getchar</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(c </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'A'</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-circular-buffer-overflow\">Test: Circular Buffer Overflow</h3>\n<p><strong>Setup:</strong> Keyboard buffer size 16 (for testing)</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Type 20 characters without reading</li>\n<li>Verify oldest characters dropped or newest rejected</li>\n</ol>\n<p><strong>Expected:</strong> Buffer contains last 15 characters (or first 15)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Modify KBUFFER_SIZE to 16 for testing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Type 20 characters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Check that buffer state is consistent</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-targets\">Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Target</th>\n<th>How to Measure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IRQ to handler entry</td>\n<td>&lt; 2 µs</td>\n<td>QEMU <code>-d int</code> with timestamps</td>\n</tr>\n<tr>\n<td>Exception handler complete</td>\n<td>&lt; 10 µs</td>\n<td>Cycle counter before/after</td>\n</tr>\n<tr>\n<td>Timer handler (tick++)</td>\n<td>&lt; 5 µs</td>\n<td>Same as above</td>\n</tr>\n<tr>\n<td>Keyboard scancode to buffer</td>\n<td>&lt; 50 µs</td>\n<td>Port read + table lookup + buffer write</td>\n</tr>\n<tr>\n<td>EOI to next IRQ allowed</td>\n<td>&lt; 1 µs</td>\n<td>I/O port write timing</td>\n</tr>\n<tr>\n<td>Full context save/restore</td>\n<td>&lt; 1 µs</td>\n<td>pusha/popa timing (~20 cycles)</td>\n</tr>\n</tbody></table>\n<p><strong>Measurement Method:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> -d</span><span style=\"color:#9ECBFF\"> int</span><span style=\"color:#F97583\"> 2>&#x26;1</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> head</span><span style=\"color:#79B8FF\"> -100</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Shows interrupt entry/exit with timestamps</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"hardware-soul\">Hardware Soul</h2>\n<h3 id=\"cache-behavior\">Cache Behavior</h3>\n<ul>\n<li><strong>IDT (2KB):</strong> Spans 32 cache lines. Frequently accessed entries (timer, keyboard, page fault) will be cached. First access on each entry causes cache miss (~50 cycles).</li>\n<li><strong>Keyboard buffer (256B):</strong> Fits in 4 cache lines. Producer (IRQ handler) and consumer (main loop) may cause cache coherency traffic if on different cores (not applicable for single-core).</li>\n<li><strong>Interrupt stack:</strong> Assumes 4KB kernel stack. If handler uses &gt;4KB local variables, stack overflow corrupts adjacent memory.</li>\n</ul>\n<h3 id=\"branch-prediction\">Branch Prediction</h3>\n<ul>\n<li><strong>Exception handlers:</strong> Unpredictable (rare events). Branch misprediction on error handling paths is acceptable.</li>\n<li><strong>Timer handler:</strong> Highly predictable (straight-line, increment counter). Good IPC.</li>\n<li><strong>Keyboard handler:</strong> Moderately predictable (check shift state, table lookup). Shift state branch is predictable (usually not pressed).</li>\n</ul>\n<h3 id=\"tlb-behavior\">TLB Behavior</h3>\n<ul>\n<li><strong>Handler code:</strong> Must be in identity-mapped region or always-present pages. Page fault during exception handling = double fault.</li>\n<li><strong>Keyboard buffer:</strong> Should be in kernel memory (always mapped). If in user memory, page fault on IRQ = crash.</li>\n</ul>\n<h3 id=\"memory-access-patterns\">Memory Access Patterns</h3>\n<ul>\n<li><strong>Stack (pusha/popa):</strong> Sequential, cache-line aligned after first push. Maximum bandwidth.</li>\n<li><strong>Keyboard buffer:</strong> Circular with random access pattern from consumer. Producer is append-only (sequential).</li>\n<li><strong>Scancode table:</strong> Random access (scancode as index). 128-entry table fits in single cache line if using uint8_t.</li>\n</ul>\n<h3 id=\"simd-opportunity\">SIMD Opportunity</h3>\n<p>None. Interrupt handlers save/restore all state; SIMD (SSE/AVX) would require saving 512+ bytes of register state. Not worth the overhead for simple handlers.</p>\n<hr>\n<h2 id=\"concurrency-specification\">Concurrency Specification</h2>\n<h3 id=\"interrupt-safety\">Interrupt Safety</h3>\n<table>\n<thead>\n<tr>\n<th>Data Structure</th>\n<th>Access Pattern</th>\n<th>Protection</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IDT entries</td>\n<td>Write once at boot, read by CPU</td>\n<td>No protection needed</td>\n</tr>\n<tr>\n<td>timer_ticks</td>\n<td>Write by IRQ, read by main</td>\n<td><code>volatile</code>, atomic on x86</td>\n</tr>\n<tr>\n<td>keyboard buffer</td>\n<td>Write by IRQ, read by main</td>\n<td>Circular buffer with volatile indices</td>\n</tr>\n<tr>\n<td>shift_pressed</td>\n<td>Write by IRQ, read by IRQ</td>\n<td>Single-threaded (IRQ context)</td>\n</tr>\n<tr>\n<td>VGA buffer</td>\n<td>Write by IRQ or main</td>\n<td>Not protected (race OK for debug output)</td>\n</tr>\n</tbody></table>\n<h3 id=\"reentrancy\">Reentrancy</h3>\n<ul>\n<li><strong>Exception handlers:</strong> NOT reentrant. If exception occurs during exception handling, double fault.</li>\n<li><strong>IRQ handlers:</strong> CAN be interrupted by higher-priority IRQs (if IF=1). Timer and keyboard handlers must be reentrant-safe.</li>\n<li><strong>Solution:</strong> Use per-CPU data (not needed for single-core). Disable interrupts during critical sections.</li>\n</ul>\n<h3 id=\"critical-sections\">Critical Sections</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Example: safely reading timer_ticks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#B392F0\"> get_timer_ticks</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // On 32-bit, reading 64-bit value is not atomic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // But IRQ won't corrupt it—only increment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Safe for single-reader, single-writer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> timer_ticks;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Example: safely reading keyboard buffer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#B392F0\"> keyboard_getchar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (read_pos </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> write_pos) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">hlt</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Wait for IRQ</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // IRQ won't corrupt this read (single consumer)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> buffer</span><span style=\"color:#E1E4E8\">[read_pos];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    read_pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (read_pos </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> KBUFFER_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> c;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"visual-diagrams\">Visual Diagrams</h2>\n<p>{{DIAGRAM:tdd-diag-009}}\nIDT entry layout with byte-by-byte breakdown</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-010.svg\" alt=\"Interrupt Stack Frame: CPU-Pushed vs Handler-Pushed\"></p>\n<p>Interrupt stack frame: CPU-pushed vs handler-pushed</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-011.svg\" alt=\"CPU Exception Flow: Divide Error to Handler\"></p>\n<p>PIC cascade: master (IRQ0-7) and slave (IRQ8-15)</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-012.svg\" alt=\"PIC Remapping: IRQ to Vector Translation\"></p>\n<p>EOI timing: In-Service Register state transitions</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-013.svg\" alt=\"EOI Timing: Why Forgetting EOI Freezes the System\"></p>\n<p>PIT channel 0 programming: divisor calculation</p>\n<p>{{DIAGRAM:tdd-diag-014}}\nKeyboard scancode flow: port 0x60 → translation → buffer</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-015.svg\" alt=\"Circular Keyboard Buffer State Machine\"></p>\n<p>Circular buffer indices: read_pos and write_pos</p>\n<p>{{DIAGRAM:tdd-diag-016}}\nException handling flow: CPU → stub → C handler → EOI (for IRQs) → iret</p>\n<hr>\n<p>[[CRITERIA_JSON: {&quot;module_id&quot;: &quot;build-os-m2&quot;, &quot;criteria&quot;: [&quot;IDT contains 256 entries with entries 0-31 configured for CPU exceptions including divide error, page fault, and general protection fault with descriptive error messages&quot;, &quot;All interrupt handlers save general-purpose registers (pusha) and segment registers on entry and restore them before iret; handlers for exceptions 8, 10-14 account for the error code pushed by the CPU&quot;, &quot;PIC 8259 is remapped so IRQ0-7 map to vectors 32-39 and IRQ8-15 map to vectors 40-47, avoiding conflicts with CPU exception vectors 0-31&quot;, &quot;EOI is sent to the correct PIC (master for IRQ0-7, both master and slave for IRQ8-15) at the end of each IRQ handler before iret&quot;, &quot;Timer interrupt (IRQ0 via PIT channel 0) fires at a configurable frequency (e.g., 100Hz) and increments a global tick counter on each interrupt&quot;, &quot;Keyboard interrupt (IRQ1) reads PS/2 scancode from port 0x60, converts to ASCII using a scancode-to-ASCII table, and places characters in a circular keyboard buffer&quot;, &quot;Double fault handler (exception 8) catches cascading faults, prints diagnostic information including error code, and halts the system instead of allowing a triple fault&quot;, &quot;Interrupts are enabled (sti) only after IDT is loaded and PIC is remapped and configured&quot;]}]</p>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-os-m3 -->\n<h1 id=\"module-physical-and-virtual-memory-management\">Module: Physical and Virtual Memory Management</h1>\n<h2 id=\"module-charter\">Module Charter</h2>\n<p>This module implements the memory management layer that transforms raw physical RAM into a virtualized address space. It parses the BIOS memory map (E820 or multiboot) to identify usable regions, manages physical frames through a bitmap allocator (1 bit per 4KB frame), constructs two-level page tables (page directory + page tables) for virtual-to-physical translation, establishes both identity mapping (for bootstrap) and higher-half kernel mapping (for isolation), provides TLB management through <code>invlpg</code> and CR3 reload, handles page faults by reading CR2 and decoding error codes, and implements a kernel heap allocator (<code>kmalloc</code>/<code>kfree</code>) for dynamic memory. This module does NOT implement demand paging from disk, copy-on-write semantics, swap, or per-process address spaces (Milestone 4). The invariant is: after this module completes, every virtual address translates correctly to a physical frame (or faults with diagnostic information), physical frames are never double-allocated, and dynamic memory is available through the heap.</p>\n<hr>\n<h2 id=\"file-structure\">File Structure</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>kernel/\n├── mm/\n│   ├── memory_map.h          # 1. Memory region structures\n│   ├── memory_map.c          # 1. E820/multiboot parsing\n│   ├── pmm.h                 # 2. Physical frame allocator interface\n│   ├── pmm.c                 # 2. Bitmap implementation\n│   ├── vmm.h                 # 3-4. Virtual memory structures and API\n│   ├── vmm.c                 # 3-4. Page table management\n│   ├── paging.h              # 5-7. Identity/higher-half setup\n│   ├── paging.c              # 5-7. Paging enable and transition\n│   ├── tlb.h                 # 8. TLB management interface\n│   ├── tlb.c                 # 8. invlpg and CR3 helpers\n│   ├── page_fault.h          # 9. Page fault handler interface\n│   ├── page_fault.c          # 9. CR2 reading and diagnostics\n│   ├── kmalloc.h             # 10. Kernel heap interface\n│   └── kmalloc.c             # 10. Linked-list allocator\n├── linker.ld                 # Updated for higher-half addresses\n└── Makefile                  # Updated build system</code></pre></div>\n\n<hr>\n<h2 id=\"complete-data-model\">Complete Data Model</h2>\n<h3 id=\"memory-region-e820multiboot-entry\">Memory Region (E820/Multiboot Entry)</h3>\n<p>Each region describes a contiguous range of physical memory with a type classification.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* memory_map.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MEMORY_TYPE_USABLE </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">           // Available RAM</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MEMORY_TYPE_RESERVED </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">         // Reserved (BIOS, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MEMORY_TYPE_ACPI_RECLAIMABLE </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\"> // ACPI tables (can reclaim after use)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MEMORY_TYPE_NVS </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">              // ACPI Non-Volatile Storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MEMORY_TYPE_BAD </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#6A737D\">               // Bad memory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">memory_type_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> base;</span><span style=\"color:#6A737D\">       // Physical start address</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> length;</span><span style=\"color:#6A737D\">     // Region length in bytes</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    memory_type_t</span><span style=\"color:#E1E4E8\"> type;</span><span style=\"color:#6A737D\">  // Region classification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> acpi_attrs;</span><span style=\"color:#6A737D\"> // ACPI extended attributes (if available)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">memory_region_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_MEMORY_REGIONS</span><span style=\"color:#79B8FF\"> 64</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#79B8FF\"> memory_region_t</span><span style=\"color:#FFAB70\"> memory_regions</span><span style=\"color:#E1E4E8\">[MAX_MEMORY_REGIONS];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> memory_region_count;</span></span></code></pre></div>\n\n<p><strong>Memory Layout:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Offset  Size  Field\n------  ----  -----\n0       8     base (64-bit, little-endian)\n8       8     length (64-bit, little-endian)\n16      4     type (enum as uint32_t)\n20      4     acpi_attrs (optional, may be padding)\nTotal: 24 bytes per entry</code></pre></div>\n\n<p><strong>Multiboot1 mmap Entry (from bootloader):</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Offset  Size  Field\n------  ----  -----\n0       4     entry_size (size of this entry minus this field)\n4       8     base_addr (64-bit)\n12      8     length (64-bit)\n20      4     type (uint32_t)</code></pre></div>\n\n<h3 id=\"physical-frame-bitmap\">Physical Frame Bitmap</h3>\n<p>The frame allocator uses a bitmap where each bit represents one 4KB frame.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* pmm.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FRAME_SIZE</span><span style=\"color:#79B8FF\">       4096</span><span style=\"color:#6A737D\">                // 4KB per frame</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FRAME_SHIFT</span><span style=\"color:#79B8FF\">      12</span><span style=\"color:#6A737D\">                  // log2(4096)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_PHYSICAL_MB</span><span style=\"color:#79B8FF\">  4096</span><span style=\"color:#6A737D\">                // Support up to 4GB</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_FRAMES</span><span style=\"color:#E1E4E8\">       (MAX_PHYSICAL_MB </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> /</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  // 1M frames for 4GB</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BITMAP_SIZE</span><span style=\"color:#E1E4E8\">      (MAX_FRAMES </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">    // 128KB bitmap for 4GB</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BITMAP_WORDS</span><span style=\"color:#E1E4E8\">     (BITMAP_SIZE </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">   // 32768 uint32_t words</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#FFAB70\"> frame_bitmap</span><span style=\"color:#E1E4E8\">[BITMAP_WORDS];</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Frame state encoding:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   bit = 0: frame is FREE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   bit = 1: frame is USED</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bit manipulation helpers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FRAME_INDEX</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">addr</span><span style=\"color:#E1E4E8\">)    ((addr) </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> FRAME_SHIFT)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> WORD_INDEX</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frame</span><span style=\"color:#E1E4E8\">)    ((frame) </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">       // frame / 32</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BIT_INDEX</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frame</span><span style=\"color:#E1E4E8\">)     ((frame) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">1F</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">     // frame % 32</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SET_BIT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frame</span><span style=\"color:#E1E4E8\">)       (</span><span style=\"color:#FFAB70\">frame_bitmap</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">WORD_INDEX</span><span style=\"color:#E1E4E8\">(frame)] </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> BIT_INDEX</span><span style=\"color:#E1E4E8\">(frame)))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CLEAR_BIT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frame</span><span style=\"color:#E1E4E8\">)     (</span><span style=\"color:#FFAB70\">frame_bitmap</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">WORD_INDEX</span><span style=\"color:#E1E4E8\">(frame)] </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> BIT_INDEX</span><span style=\"color:#E1E4E8\">(frame)))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TEST_BIT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frame</span><span style=\"color:#E1E4E8\">)      (</span><span style=\"color:#FFAB70\">frame_bitmap</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">WORD_INDEX</span><span style=\"color:#E1E4E8\">(frame)] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#B392F0\"> BIT_INDEX</span><span style=\"color:#E1E4E8\">(frame)))</span></span></code></pre></div>\n\n<p><strong>Memory Layout (128KB for 4GB):</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Address         Content\n----------      -------\nbitmap[0]       Frames 0-31    (physical 0x00000000 - 0x0001FFFF)\nbitmap[1]       Frames 32-63   (physical 0x00020000 - 0x0003FFFF)\n...\nbitmap[32767]   Frames 1048544-1048575 (physical 0xFFF80000 - 0xFFFFFFFF)\n\nFrame address calculation:\n  frame_index = physical_address / 4096\n  physical_address = frame_index * 4096</code></pre></div>\n\n<h3 id=\"page-directory-entry-pde\">Page Directory Entry (PDE)</h3>\n<p>Each PDE points to a page table or represents a 4MB page. For 4KB pages:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* vmm.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#79B8FF\"> page_directory_entry_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#79B8FF\"> page_table_entry_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PDE/PTE flag bits (same layout for both on x86)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PDE_PRESENT</span><span style=\"color:#E1E4E8\">     (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">   // Page/table is present in memory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PDE_WRITABLE</span><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">   // Read/write (0=read-only, 1=read-write)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PDE_USER</span><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">   // User/supervisor (0=ring0 only, 1=ring3 OK)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PDE_PWT</span><span style=\"color:#E1E4E8\">         (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">   // Page-level write-through</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PDE_PCD</span><span style=\"color:#E1E4E8\">         (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">   // Page-level cache disable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PDE_ACCESSED</span><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">   // Has been read (CPU sets)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PDE_DIRTY</span><span style=\"color:#E1E4E8\">       (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">   // Has been written (CPU sets, PTE only)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PDE_PS</span><span style=\"color:#E1E4E8\">          (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 7</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">   // Page size (0=4KB, 1=4MB for PDE)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PDE_GLOBAL</span><span style=\"color:#E1E4E8\">      (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">   // Global page (not flushed on CR3 load)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PDE_AVAILABLE</span><span style=\"color:#E1E4E8\">   (</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 9</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\"> // Available for OS use (bits 9-11)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PDE_FRAME</span><span style=\"color:#E1E4E8\">       (</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">FFFFF000</span><span style=\"color:#F97583\">U</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\"> // Frame address mask (bits 12-31)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Extract frame address from entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PDE_GET_FRAME</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pde</span><span style=\"color:#E1E4E8\">)  ((pde) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PDE_FRAME)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create PDE from frame address and flags</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PDE_CREATE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frame</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">flags</span><span style=\"color:#E1E4E8\">) (((frame) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PDE_FRAME) </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> ((flags) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFF</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PDE_PRESENT)</span></span></code></pre></div>\n\n<p><strong>PDE Memory Layout (4 bytes):</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Bits    Field           Description\n----    -----           -----------\n0       Present         1 = valid entry\n1       Read/Write      1 = writable\n2       User/Supervisor 1 = user-accessible\n3       PWT             Write-through caching\n4       PCD             Cache disabled\n5       Accessed        CPU sets on read\n6       Reserved        0 for PDE (4KB pages)\n7       PS              0 for 4KB pages\n8       G               Global page\n9-11    Available       OS-defined\n12-31   Frame Address   Physical address of page table (4KB aligned)</code></pre></div>\n\n<h3 id=\"page-table-entry-pte\">Page Table Entry (PTE)</h3>\n<p>Each PTE maps one 4KB virtual page to a 4KB physical frame.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// PTE uses same flag definitions as PDE, plus:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PDE_DIRTY (bit 6) indicates the page has been written</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PTE structure is identical to PDE for 4KB pages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Both are uint32_t with bits 12-31 containing frame address</span></span></code></pre></div>\n\n<p><strong>Virtual Address Decomposition:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>32-bit virtual address:\n┌─────────────┬─────────────┬─────────────┐\n│ PD Index    │ PT Index    │ Page Offset │\n│ (10 bits)   │ (10 bits)   │ (12 bits)   │\n└─────────────┴─────────────┴─────────────┘\n  31        22 21         12 11          0\n\nPD Index:   bits 31-22 (1024 entries)\nPT Index:   bits 21-12 (1024 entries)\nPage Offset: bits 11-0  (4096 bytes per page)\n\nTranslation:\n  PDE = page_directory[pd_index]\n  PT  = (page_table_t*)PDE_GET_FRAME(PDE)\n  PTE = PT-&gt;entries[pt_index]\n  physical_addr = PDE_GET_FRAME(PTE) | page_offset</code></pre></div>\n\n<h3 id=\"page-directory-and-page-table-structures\">Page Directory and Page Table Structures</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* vmm.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_entry_t</span><span style=\"color:#FFAB70\"> entries</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#B392F0\">aligned</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">))) </span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_directory_entry_t</span><span style=\"color:#FFAB70\"> entries</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#B392F0\">aligned</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">))) </span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Each structure is exactly 4096 bytes (1024 × 4 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Alignment ensures they fit in single pages</span></span></code></pre></div>\n\n<p><strong>Memory Layout (both 4KB):</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Offset    Entry Index\n------    -----------\n0x000     entry[0]\n0x004     entry[1]\n0x008     entry[2]\n...\n0xFFC     entry[1023]\n\nTotal: 0x1000 (4096) bytes</code></pre></div>\n\n<h3 id=\"kernel-heap-block-header\">Kernel Heap Block Header</h3>\n<p>The heap allocator maintains free blocks with headers containing metadata.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* kmalloc.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KHEAP_VIRTUAL_START</span><span style=\"color:#F97583\">   0x</span><span style=\"color:#79B8FF\">D0000000</span><span style=\"color:#6A737D\">   // Heap starts at 3.5GB virtual</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KHEAP_VIRTUAL_END</span><span style=\"color:#F97583\">     0x</span><span style=\"color:#79B8FF\">E0000000</span><span style=\"color:#6A737D\">   // Heap ends at 3.5GB + 256MB</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KHEAP_INITIAL_SIZE</span><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  // Start with 64KB</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> block_header {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> magic;</span><span style=\"color:#6A737D\">               // Magic number for corruption detection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> size;</span><span style=\"color:#6A737D\">                // Size of usable space (not including header)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\">  free;</span><span style=\"color:#6A737D\">                // 1 = free, 0 = allocated</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\">  padding</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">          // Align to 4 bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> block_header </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">next;</span><span style=\"color:#6A737D\">    // Next block in list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> block_header </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">prev;</span><span style=\"color:#6A737D\">    // Previous block in list (for coalescing)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed)) </span><span style=\"color:#79B8FF\">block_header_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> HEAP_MAGIC</span><span style=\"color:#F97583\">       0x</span><span style=\"color:#79B8FF\">4B484250</span><span style=\"color:#6A737D\">  // \"KHPB\" - Kernel Heap Block</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> HEADER_SIZE</span><span style=\"color:#F97583\">      sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">block_header_t</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MIN_BLOCK_SIZE</span><span style=\"color:#79B8FF\">   16</span><span style=\"color:#6A737D\">          // Minimum allocation size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ALIGN_SIZE</span><span style=\"color:#79B8FF\">       16</span><span style=\"color:#6A737D\">          // 16-byte alignment for all allocations</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Block layout in memory:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   [header][usable space]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//    ^      ^</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//    |      |</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//    |      +-- Pointer returned to caller</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//    +---------- Start of allocated frame(s)</span></span></code></pre></div>\n\n<p><strong>Memory Layout (24 bytes header):</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Offset  Size  Field\n------  ----  -----\n0       4     magic (0x4B484250)\n4       4     size (usable bytes)\n8       1     free flag\n9       3     padding\n12      4     next pointer\n16      4     prev pointer\n20      4     (padding to 24 bytes for alignment)\nTotal: 24 bytes\n\nAlignment:\n  Block start address % ALIGN_SIZE == 0\n  User pointer = block_start + HEADER_SIZE\n  User pointer % ALIGN_SIZE == 0</code></pre></div>\n\n<hr>\n<h2 id=\"interface-contracts\">Interface Contracts</h2>\n<h3 id=\"memory_map_init\">memory_map_init</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* memory_map.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parse memory map from multiboot info</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Must be called before any memory allocation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// mbi: pointer to multiboot_info_t from bootloader (passed in EBX)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> memory_map_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">mbi</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get total usable memory in bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#B392F0\"> memory_map_get_total_usable</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Print memory map for debugging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> memory_map_print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Preconditions:</strong></p>\n<ul>\n<li>Called before <code>pmm_init()</code></li>\n<li><code>mbi</code> points to valid multiboot info structure</li>\n<li>Interrupts disabled (safety)</li>\n</ul>\n<p><strong>Postconditions:</strong></p>\n<ul>\n<li><code>memory_regions[]</code> populated with all detected regions</li>\n<li><code>memory_region_count</code> set correctly</li>\n<li>First 1MB marked as reserved (BIOS/VGA)</li>\n</ul>\n<p><strong>Error Handling:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Condition</th>\n<th>Detection</th>\n<th>Recovery</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>No mmap in multiboot</td>\n<td>flags bit 6 clear</td>\n<td>Panic with message</td>\n</tr>\n<tr>\n<td>Too many regions</td>\n<td>count &gt;= MAX</td>\n<td>Truncate, log warning</td>\n</tr>\n<tr>\n<td>Invalid region</td>\n<td>length == 0</td>\n<td>Skip entry</td>\n</tr>\n</tbody></table>\n<h3 id=\"pmm_init-pmm_alloc_frame-pmm_free_frame\">pmm_init / pmm_alloc_frame / pmm_free_frame</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* pmm.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize physical frame allocator from memory map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Must be called after memory_map_init()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pmm_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Allocate a single 4KB frame</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns physical address of frame, or 0 if out of memory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Free a previously allocated frame</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// addr: physical address returned by pmm_alloc_frame (must be 4KB aligned)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pmm_free_frame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> addr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Mark a specific frame as used (for kernel, page tables, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// addr: physical address (must be 4KB aligned)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pmm_mark_used</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> addr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> pmm_get_total_frames</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> pmm_get_used_frames</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> pmm_get_free_frames</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Preconditions:</strong></p>\n<ul>\n<li><code>memory_map_init()</code> called successfully</li>\n<li>Bitmap fits in available memory</li>\n</ul>\n<p><strong>Postconditions:</strong></p>\n<ul>\n<li>All usable frames available for allocation</li>\n<li>Kernel binary, page tables, bitmap itself marked used</li>\n</ul>\n<p><strong>Edge Cases:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Input</th>\n<th>Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>pmm_alloc_frame()</code> when full</td>\n<td>Returns 0, logs warning</td>\n</tr>\n<tr>\n<td><code>pmm_free_frame(0)</code></td>\n<td>Logs error, ignored</td>\n</tr>\n<tr>\n<td><code>pmm_free_frame(unaligned)</code></td>\n<td>Logs error, ignored</td>\n</tr>\n<tr>\n<td><code>pmm_free_frame(already free)</code></td>\n<td>Logs double-free warning, ignored</td>\n</tr>\n</tbody></table>\n<h3 id=\"vmm_init-vmm_map_page-vmm_unmap_page\">vmm_init / vmm_map_page / vmm_unmap_page</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* vmm.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Current page directory (set after vmm_init)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#79B8FF\"> page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">current_page_directory;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize virtual memory manager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Allocates and clears initial page directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vmm_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Map a virtual page to a physical frame</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// vaddr: virtual address (will be page-aligned)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// paddr: physical address (will be page-aligned)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// flags: PDE_WRITABLE, PDE_USER, etc.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns 0 on success, -1 on failure (out of memory for page table)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> vmm_map_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> paddr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> flags</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Unmap a virtual page</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// vaddr: virtual address to unmap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vmm_unmap_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get physical address for a virtual address</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns physical address, or 0 if not mapped</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> vmm_get_physical</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Check if virtual address is mapped</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> vmm_is_mapped</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create a new page directory (for user processes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns pointer to new directory, or NULL on failure</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">vmm_create_directory</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Switch to a different page directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vmm_switch_directory</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pd</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Preconditions:</strong></p>\n<ul>\n<li><code>pmm_init()</code> called successfully</li>\n<li>Interrupts disabled during mapping (to prevent race with page faults)</li>\n</ul>\n<p><strong>Postconditions:</strong></p>\n<ul>\n<li>Page tables created/updated as needed</li>\n<li>TLB entry for page invalidated</li>\n</ul>\n<p><strong>Error Handling:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Error</th>\n<th>Detection</th>\n<th>Recovery</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>No frame for page table</td>\n<td><code>pmm_alloc_frame()</code> returns 0</td>\n<td>Return -1</td>\n</tr>\n<tr>\n<td>Invalid flags</td>\n<td>Reserved bits set</td>\n<td>Ignore reserved bits</td>\n</tr>\n<tr>\n<td>Already mapped</td>\n<td>PTE present</td>\n<td>Remap (update PTE)</td>\n</tr>\n</tbody></table>\n<h3 id=\"paging_setup_identity-paging_setup_higher_half-paging_enable\">paging_setup_identity / paging_setup_higher_half / paging_enable</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* paging.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Identity map the first 4MB (kernel + VGA + boot data)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Required for safe paging enable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> paging_setup_identity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Set up higher-half kernel mapping</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Maps 0xC0000000-0xC0400000 to 0x00000000-0x00400000</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> paging_setup_higher_half</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Enable paging (set CR0.PG)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CRITICAL: Must have identity map active when called</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// After this, all addresses are virtual</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> paging_enable</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete paging initialization sequence</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Calls identity, higher-half, then enables paging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> paging_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Preconditions:</strong></p>\n<ul>\n<li><code>vmm_init()</code> called</li>\n<li>GDT configured with flat segments</li>\n</ul>\n<p><strong>Postconditions:</strong></p>\n<ul>\n<li>Paging enabled</li>\n<li>Identity map for first 4MB active</li>\n<li>Higher-half map for kernel active</li>\n<li>Kernel executing at virtual addresses</li>\n</ul>\n<p><strong>CRITICAL:</strong> The transition must be handled carefully. The code that enables paging must be identity-mapped, or the CPU will fault on the next instruction fetch.</p>\n<h3 id=\"tlb_invalidate_page-tlb_flush_all\">tlb_invalidate_page / tlb_flush_all</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* tlb.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Invalidate TLB entry for a single page</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// addr: virtual address of page to invalidate</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> tlb_invalidate_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">invlpg (%0)</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(addr) : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">memory</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Flush entire TLB (except global pages)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Reloads CR3 with current page directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> tlb_flush_all</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> cr3;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %%cr3, %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(cr3));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %0, %%cr3</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(cr3) : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">memory</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Flush entire TLB including global pages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Requires CR4.PGE toggle</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tlb_flush_all_global</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Preconditions:</strong></p>\n<ul>\n<li>Paging enabled</li>\n</ul>\n<p><strong>Postconditions:</strong></p>\n<ul>\n<li>Specified TLB entries invalidated</li>\n<li>Subsequent accesses will re-walk page tables</li>\n</ul>\n<h3 id=\"page_fault_handler\">page_fault_handler</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* page_fault.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Register page fault handler (called from interrupt init)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> page_fault_register_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Page fault handler (called from interrupt.asm)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// regs: saved register state from interrupt</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> page_fault_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Read CR2 (faulting address)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> read_cr2</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> addr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %%cr2, %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(addr));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> addr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Preconditions:</strong></p>\n<ul>\n<li>IDT entry 14 configured</li>\n<li>Handler registered</li>\n</ul>\n<p><strong>Postconditions:</strong></p>\n<ul>\n<li>Diagnostic information printed</li>\n<li>System halted (for now; demand paging in future)</li>\n</ul>\n<p><strong>Page Fault Error Code Decoding:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Error code bits from page fault</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PF_ERROR_PRESENT</span><span style=\"color:#E1E4E8\">  (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  // 0 = not present, 1 = protection violation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PF_ERROR_WRITE</span><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  // 0 = read, 1 = write</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PF_ERROR_USER</span><span style=\"color:#E1E4E8\">     (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  // 0 = kernel, 1 = user</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PF_ERROR_RESERVED</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  // Reserved bit set in page table</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PF_ERROR_FETCH</span><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  // Instruction fetch (NX bit)</span></span></code></pre></div>\n\n<h3 id=\"kmalloc-kfree\">kmalloc / kfree</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* kmalloc.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize kernel heap</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Must be called after paging is enabled</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> kmalloc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Allocate memory from kernel heap</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// size: bytes to allocate (will be aligned to ALIGN_SIZE)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns pointer to allocated memory, or NULL on failure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Free previously allocated memory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ptr: pointer returned by kmalloc (or NULL, which is a no-op)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> kfree</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Allocate and zero-initialize memory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">kcalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Reallocate memory (change size of allocation)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">krealloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get heap statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#B392F0\"> kmalloc_get_total_size</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#B392F0\"> kmalloc_get_used_size</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#B392F0\"> kmalloc_get_free_size</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Preconditions:</strong></p>\n<ul>\n<li>Paging enabled</li>\n<li>Heap virtual range mapped</li>\n</ul>\n<p><strong>Postconditions:</strong></p>\n<ul>\n<li>Memory allocated with 16-byte alignment</li>\n<li>Adjacent free blocks coalesced</li>\n</ul>\n<p><strong>Edge Cases:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Input</th>\n<th>Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>kmalloc(0)</code></td>\n<td>Returns NULL</td>\n</tr>\n<tr>\n<td><code>kmalloc(very_large)</code></td>\n<td>Returns NULL if can&#39;t grow heap</td>\n</tr>\n<tr>\n<td><code>kfree(NULL)</code></td>\n<td>No-op</td>\n</tr>\n<tr>\n<td><code>kfree(bad_pointer)</code></td>\n<td>Magic check fails, log error, ignore</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"algorithm-specification\">Algorithm Specification</h2>\n<h3 id=\"algorithm-memory-map-parsing-multiboot\">Algorithm: Memory Map Parsing (Multiboot)</h3>\n<p><strong>Purpose:</strong> Extract memory regions from multiboot info structure.</p>\n<p><strong>Inputs:</strong> </p>\n<ul>\n<li>Multiboot info pointer (from bootloader)</li>\n<li>Multiboot magic (from bootloader, in EAX)</li>\n</ul>\n<p><strong>Outputs:</strong> </p>\n<ul>\n<li><code>memory_regions[]</code> populated</li>\n<li><code>memory_region_count</code> set</li>\n</ul>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>Verify multiboot magic (0x2BADB002)</li>\n<li>Check if mmap field is valid (flags bit 6)</li>\n<li>Iterate through mmap entries:<ul>\n<li>Read base, length, type from entry</li>\n<li>Store in <code>memory_regions[count]</code></li>\n<li>Advance to next entry (entry_size varies)</li>\n</ul>\n</li>\n<li>Sort regions by base address (optional, for debugging)</li>\n<li>Merge adjacent regions of same type (optional)</li>\n</ol>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>No overlapping regions</li>\n<li>All regions aligned to at least page boundaries (for our use)</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> memory_map_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">mbi_ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    multiboot_info_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">mbi </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">multiboot_info_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)mbi_ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(mbi->flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">))) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"No memory map from bootloader!\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> mmap_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mbi->mmap_addr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> mmap_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mmap_addr </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> mbi->mmap_length;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    memory_region_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (mmap_addr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> mmap_end </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> memory_region_count </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> MAX_MEMORY_REGIONS) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        multiboot_mmap_entry_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">entry </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">multiboot_mmap_entry_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)mmap_addr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        memory_regions</span><span style=\"color:#E1E4E8\">[memory_region_count].base </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> entry->base_addr;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        memory_regions</span><span style=\"color:#E1E4E8\">[memory_region_count].length </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> entry->length;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        memory_regions</span><span style=\"color:#E1E4E8\">[memory_region_count].type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">memory_type_t</span><span style=\"color:#E1E4E8\">)entry->type;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        memory_region_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mmap_addr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> entry->size </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // size field doesn't include itself</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mark first 1MB as reserved (even if reported as usable)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // (BIOS data structures, VGA memory, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"algorithm-physical-frame-allocation-bitmap-scan\">Algorithm: Physical Frame Allocation (Bitmap Scan)</h3>\n<p><strong>Purpose:</strong> Find and allocate a free physical frame.</p>\n<p><strong>Inputs:</strong> None\n<strong>Outputs:</strong> Physical address of allocated frame, or 0 if none available</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>For each word in bitmap:<ul>\n<li>If word != 0xFFFFFFFF (not all used):<ul>\n<li>Find first zero bit using <code>bsf</code> (Bit Scan Forward)</li>\n<li>Set the bit</li>\n<li>Calculate frame address</li>\n<li>Return address</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>If no free bits found, return 0</li>\n</ol>\n<p><strong>Optimization with BSF:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> word_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; word_idx </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> BITMAP_WORDS; word_idx</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">frame_bitmap</span><span style=\"color:#E1E4E8\">[word_idx] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFFFFFF</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Find first zero bit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint32_t</span><span style=\"color:#E1E4E8\"> word </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> frame_bitmap</span><span style=\"color:#E1E4E8\">[word_idx];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint32_t</span><span style=\"color:#E1E4E8\"> bit_idx;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // bsf finds index of least significant 1 bit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // We want first 0 bit, so invert</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">bsf %1, %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(bit_idx) : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">~</span><span style=\"color:#E1E4E8\">word));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint32_t</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (word_idx </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> bit_idx;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Verify frame is within valid range</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (frame </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> total_frames) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            SET_BIT</span><span style=\"color:#E1E4E8\">(frame);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            used_frames</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> FRAME_SHIFT;</span><span style=\"color:#6A737D\">  // Convert to physical address</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PMM: Out of memory!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>Each frame allocated exactly once</li>\n<li>No frame returned twice before being freed</li>\n</ul>\n<h3 id=\"algorithm-physical-frame-free\">Algorithm: Physical Frame Free</h3>\n<p><strong>Purpose:</strong> Mark a frame as available for reuse.</p>\n<p><strong>Inputs:</strong> Physical address of frame to free\n<strong>Outputs:</strong> None (bitmap updated)</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>Check address is 4KB aligned</li>\n<li>Calculate frame index</li>\n<li>Verify frame is currently allocated (TEST_BIT)</li>\n<li>Clear the bit</li>\n<li>Decrement used count</li>\n</ol>\n<p><strong>Error Detection:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pmm_free_frame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (addr </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PMM: Attempt to free NULL frame</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (addr </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFF</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PMM: Unaligned free: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, addr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> FRAME_INDEX</span><span style=\"color:#E1E4E8\">(addr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (frame </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> total_frames) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PMM: Frame out of range: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, addr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">TEST_BIT</span><span style=\"color:#E1E4E8\">(frame)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PMM: Double free detected: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, addr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CLEAR_BIT</span><span style=\"color:#E1E4E8\">(frame);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    used_frames</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"algorithm-virtual-address-translation\">Algorithm: Virtual Address Translation</h3>\n<p><strong>Purpose:</strong> Map a virtual page to a physical frame.</p>\n<p><strong>Inputs:</strong></p>\n<ul>\n<li>Virtual address (will be page-aligned)</li>\n<li>Physical address (will be page-aligned)</li>\n<li>Flags (writable, user, etc.)</li>\n</ul>\n<p><strong>Outputs:</strong> Page table entry created/updated</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>Extract PD index and PT index from virtual address</li>\n<li>Check if page table exists for this PD entry:<ul>\n<li>If not present, allocate frame for new page table</li>\n<li>Clear the page table (all zeros = not present)</li>\n<li>Set PD entry with page table physical address</li>\n</ul>\n</li>\n<li>Set PT entry with frame address and flags</li>\n<li>Invalidate TLB entry for this page</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> vmm_map_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> paddr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> flags</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Align addresses</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vaddr </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> ~0x</span><span style=\"color:#79B8FF\">FFF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    paddr </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> ~0x</span><span style=\"color:#79B8FF\">FFF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pd_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (vaddr </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 22</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">3FF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pt_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (vaddr </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">3FF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_directory_entry_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pde </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">current_page_directory->entries[pd_idx];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if page table exists</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pde </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PDE_PRESENT)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Allocate new page table</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> pt_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (pt_frame </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Out of memory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Clear page table</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)pt_frame;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pt->entries[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Set PDE to point to page table</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">pde </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> PDE_CREATE</span><span style=\"color:#E1E4E8\">(pt_frame, flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> (PDE_WRITABLE </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PDE_USER));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get page table</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">PDE_GET_FRAME</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pde);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set PTE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pt->entries[pt_idx] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> PDE_CREATE</span><span style=\"color:#E1E4E8\">(paddr, flags);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Invalidate TLB</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    tlb_invalidate_page</span><span style=\"color:#E1E4E8\">(vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"algorithm-identity-mapping-setup\">Algorithm: Identity Mapping Setup</h3>\n<p><strong>Purpose:</strong> Map virtual addresses 0x0-0x400000 to physical addresses 0x0-0x400000.</p>\n<p><strong>Inputs:</strong> None\n<strong>Outputs:</strong> First 4MB identity-mapped</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>For each 4KB page from 0 to 4MB:<ul>\n<li>Call <code>vmm_map_page(vaddr, paddr, PDE_WRITABLE)</code></li>\n<li>Where vaddr = paddr = loop variable</li>\n</ul>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> paging_setup_identity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; addr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">400000</span><span style=\"color:#E1E4E8\">; addr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> PAGE_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Map with writable, kernel-only access</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vmm_map_page</span><span style=\"color:#E1E4E8\">(addr, addr, PDE_WRITABLE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Special handling for VGA (0xB8000) - already covered by above</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // But could add different flags if needed:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // vmm_map_page(0xB8000, 0xB8000, PDE_WRITABLE | PDE_PCD);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"algorithm-higher-half-kernel-mapping\">Algorithm: Higher-Half Kernel Mapping</h3>\n<p><strong>Purpose:</strong> Map 0xC0000000+ to physical 0x0+.</p>\n<p><strong>Inputs:</strong> None\n<strong>Outputs:</strong> Kernel accessible at higher-half virtual addresses</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>For each 4KB page from 0 to 4MB:<ul>\n<li>vaddr = 0xC0000000 + addr</li>\n<li>paddr = addr</li>\n<li>Call <code>vmm_map_page(vaddr, paddr, PDE_WRITABLE)</code></li>\n</ul>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> paging_setup_higher_half</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; offset </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">400000</span><span style=\"color:#E1E4E8\">; offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> PAGE_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> vaddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> KERNEL_VIRTUAL_START </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> offset;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> paddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> offset;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vmm_map_page</span><span style=\"color:#E1E4E8\">(vaddr, paddr, PDE_WRITABLE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"algorithm-paging-enable-transition\">Algorithm: Paging Enable Transition</h3>\n<p><strong>Purpose:</strong> Enable paging while maintaining execution continuity.</p>\n<p><strong>Inputs:</strong> None (uses global page directory)\n<strong>Outputs:</strong> Paging enabled, executing at virtual addresses</p>\n<p><strong>CRITICAL:</strong> This is the most delicate operation. The code that sets CR0.PG must be identity-mapped, or the CPU faults immediately.</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>Ensure identity mapping is active</li>\n<li>Load CR3 with page directory physical address</li>\n<li>Set CR0.PG bit</li>\n<li>Far jump to higher-half code (optional, for higher-half kernel)</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> paging_enable</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pd_phys </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)current_page_directory;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // CRITICAL: We must be executing from identity-mapped code here</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Load page directory base</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %0, %%cr3</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(pd_phys));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Enable paging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> cr0;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %%cr0, %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(cr0));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cr0 </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 31</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Set PG bit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %0, %%cr0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(cr0));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Now paging is enabled!</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // All addresses are virtual</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Assembly Transition (for higher-half):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; paging_transition.asm\nglobal paging_enable_and_jump\nextern kernel_main_higher_half\n\npaging_enable_and_jump:\n    ; Load CR3\n    mov eax, [page_directory_phys]\n    mov cr3, eax\n    \n    ; Enable paging\n    mov eax, cr0\n    or eax, (1 &lt;&lt; 31)\n    mov cr0, eax\n    \n    ; Now paging is enabled\n    ; We're still at identity-mapped address\n    ; Jump to higher-half\n    \n    mov eax, kernel_main_higher_half\n    jmp eax\n    \n    ; Never returns</code></pre></div>\n\n<h3 id=\"algorithm-page-fault-handling\">Algorithm: Page Fault Handling</h3>\n<p><strong>Purpose:</strong> Capture and diagnose page faults.</p>\n<p><strong>Inputs:</strong> </p>\n<ul>\n<li>CR2 (faulting address)</li>\n<li>Error code (from stack)</li>\n</ul>\n<p><strong>Outputs:</strong> Diagnostic information printed</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>Read CR2 to get faulting address</li>\n<li>Decode error code bits</li>\n<li>Print diagnostic information</li>\n<li>Halt system (for now)</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> page_fault_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> fault_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> read_cr2</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> regs->err_code;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">========== PAGE FAULT ==========</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Faulting address: 0x</span><span style=\"color:#79B8FF\">%08x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, fault_addr);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Error code: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Cause: \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(err </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PF_ERROR_PRESENT)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Page not present</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (err </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PF_ERROR_WRITE) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Write to read-only page</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (err </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PF_ERROR_USER) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"User access to kernel page</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Unknown</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Access type: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (err </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PF_ERROR_WRITE) </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"Write\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"Read\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Mode: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (err </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PF_ERROR_USER) </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"User\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"Kernel\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"EIP at fault: 0x</span><span style=\"color:#79B8FF\">%08x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, regs->eip);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Dump current page table state for debugging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">vmm_is_mapped</span><span style=\"color:#E1E4E8\">(fault_addr)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Mapped to: 0x</span><span style=\"color:#79B8FF\">%08x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">vmm_get_physical</span><span style=\"color:#E1E4E8\">(fault_addr));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Page fault\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"algorithm-kernel-heap-allocation-first-fit\">Algorithm: Kernel Heap Allocation (First-Fit)</h3>\n<p><strong>Purpose:</strong> Allocate memory from kernel heap.</p>\n<p><strong>Inputs:</strong> Size in bytes\n<strong>Outputs:</strong> Pointer to allocated memory, or NULL</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>Align size to ALIGN_SIZE (16 bytes)</li>\n<li>Calculate total size needed (size + HEADER_SIZE)</li>\n<li>Walk free list looking for first block &gt;= total size</li>\n<li>If found:<ul>\n<li>If block is much larger, split into two blocks</li>\n<li>Mark block as allocated</li>\n<li>Return pointer to usable space</li>\n</ul>\n</li>\n<li>If not found:<ul>\n<li>Grow heap by mapping new pages</li>\n<li>Create new block</li>\n<li>Return pointer</li>\n</ul>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Align size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (size </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> ALIGN_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#E1E4E8\">(ALIGN_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (size </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> MIN_BLOCK_SIZE) size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> MIN_BLOCK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> total_needed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> size </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> HEADER_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Search free list (first-fit)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    block_header_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> heap_head;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (block </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (block->free </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> block->size </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> size) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Found a suitable block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Split if large enough</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (block->size </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> size </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> HEADER_SIZE </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> MIN_BLOCK_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                block_header_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">new_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">block_header_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    ((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)block </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> HEADER_SIZE </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                new_block->magic </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> HEAP_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                new_block->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> HEADER_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                new_block->free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                new_block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                new_block->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (block->next) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    block->next->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                block->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            block->free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)block </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> HEADER_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // No suitable block, grow heap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> heap_grow</span><span style=\"color:#E1E4E8\">(total_needed);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"algorithm-kernel-heap-free-with-coalescing\">Algorithm: Kernel Heap Free with Coalescing</h3>\n<p><strong>Purpose:</strong> Free memory and merge adjacent free blocks.</p>\n<p><strong>Inputs:</strong> Pointer to allocated memory\n<strong>Outputs:</strong> None (block marked free, coalesced)</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>Get header from pointer</li>\n<li>Verify magic number</li>\n<li>Mark block as free</li>\n<li>Coalesce with next block if free</li>\n<li>Coalesce with previous block if free</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> kfree</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    block_header_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">block_header_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)ptr </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> HEADER_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify magic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (block->magic </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> HEAP_MAGIC) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"kmalloc: Bad magic in kfree: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, block->magic);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Already free?</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (block->free) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"kmalloc: Double free detected</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Coalesce with next block</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (block->next </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> block->next->free </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> block->next->magic </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> HEAP_MAGIC) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        block->size </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> block->next->size </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> HEADER_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->next->next;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (block->next) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            block->next->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Coalesce with previous block</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (block->prev </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> block->prev->free </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> block->prev->magic </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> HEAP_MAGIC) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        block->prev->size </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> block->size </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> HEADER_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        block->prev->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->next;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (block->next) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            block->next->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->prev;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"error-handling-matrix\">Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th>Error</th>\n<th>Detected By</th>\n<th>Recovery</th>\n<th>User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>No memory map from bootloader</td>\n<td>Multiboot flags check</td>\n<td>Panic with message</td>\n<td>Yes, halt</td>\n</tr>\n<tr>\n<td>Frame allocation failure</td>\n<td><code>pmm_alloc_frame()</code> returns 0</td>\n<td>Return NULL to caller</td>\n<td>Caller handles</td>\n</tr>\n<tr>\n<td>Double frame free</td>\n<td><code>TEST_BIT()</code> check</td>\n<td>Log warning, ignore</td>\n<td>Debug log</td>\n</tr>\n<tr>\n<td>Unaligned frame free</td>\n<td>Address check</td>\n<td>Log warning, ignore</td>\n<td>Debug log</td>\n</tr>\n<tr>\n<td>Page table allocation failure</td>\n<td><code>pmm_alloc_frame()</code> returns 0</td>\n<td>Return -1 from <code>vmm_map_page()</code></td>\n<td>Caller handles</td>\n</tr>\n<tr>\n<td>Page fault on paging enable</td>\n<td>Immediate triple fault</td>\n<td>None (system resets)</td>\n<td>Yes, reboot</td>\n</tr>\n<tr>\n<td>TLB staleness</td>\n<td>Stale data access</td>\n<td>Fix by <code>invlpg</code> after map</td>\n<td>Debug symptoms</td>\n</tr>\n<tr>\n<td>Heap corruption</td>\n<td>Magic number check</td>\n<td>Log error, ignore free</td>\n<td>Debug log</td>\n</tr>\n<tr>\n<td>Heap exhausted</td>\n<td>No suitable block found</td>\n<td>Return NULL from <code>kmalloc()</code></td>\n<td>Caller handles</td>\n</tr>\n<tr>\n<td>Invalid kfree pointer</td>\n<td>Magic check</td>\n<td>Log error, ignore</td>\n<td>Debug log</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"concurrency-specification\">Concurrency Specification</h2>\n<h3 id=\"interrupt-safety\">Interrupt Safety</h3>\n<table>\n<thead>\n<tr>\n<th>Data Structure</th>\n<th>Access Pattern</th>\n<th>Protection</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Frame bitmap</td>\n<td>Read/write from kernel</td>\n<td>Disable IRQs during alloc/free</td>\n</tr>\n<tr>\n<td>Page tables</td>\n<td>Read/write from kernel</td>\n<td>Disable IRQs during map/unmap</td>\n</tr>\n<tr>\n<td>Heap free list</td>\n<td>Read/write from kernel</td>\n<td>Disable IRQs during malloc/free</td>\n</tr>\n<tr>\n<td>Memory regions</td>\n<td>Read-only after init</td>\n<td>No protection needed</td>\n</tr>\n</tbody></table>\n<p><strong>Critical Sections:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Frame allocation with interrupt safety</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> pmm_alloc_frame_safe</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> flags;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">pushf; pop %0; cli</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(flags));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">sti</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> frame;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"future-preemptive-kernel-considerations\">Future Preemptive Kernel Considerations</h3>\n<p>When the kernel becomes preemptive (Milestone 4), all memory operations must use spinlocks:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Future: spinlock for frame allocator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> spinlock_t</span><span style=\"color:#E1E4E8\"> pmm_lock </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> SPINLOCK_INIT;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    spinlock_acquire</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pmm_lock);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... allocation code ...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    spinlock_release</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pmm_lock);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> frame;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"state-machine-heap-block-lifecycle\">State Machine: Heap Block Lifecycle</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>                 +-----------------+\n                 |    ALLOCATED    |\n                 +--------+--------+\n                          |\n                     kfree(ptr)\n                          |\n                          v\n                 +-----------------+\n                 |      FREE       |\n                 +--------+--------+\n                          |\n         +----------------+----------------+\n         |                                 |\n   Coalesce with next              Coalesce with prev\n         |                                 |\n         v                                 v\n+----------------+                 +----------------+\n| MERGED (larger)|                 | MERGED (larger)|\n|    FREE block  |                 |    FREE block  |\n+--------+-------+                 +--------+-------+\n         |                                  |\n         +------------------+---------------+\n                            |\n                      kmalloc(size)\n                            |\n                            v\n                 +-----------------+\n                 |   ALLOCATED     |\n                 |  (possibly      |\n                 |   split)        |\n                 +-----------------+\n\nBlock states:\n  - ALLOCATED: magic valid, free=0\n  - FREE: magic valid, free=1\n  - CORRUPT: magic invalid (error state)</code></pre></div>\n\n<hr>\n<h2 id=\"implementation-sequence-with-checkpoints\">Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-memory-map-parsing-2-3-hours\">Phase 1: Memory Map Parsing (2-3 hours)</h3>\n<p><strong>Files:</strong> mm/memory_map.h, mm/memory_map.c</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Define <code>memory_region_t</code> structure</li>\n<li>Implement <code>memory_map_init()</code> to parse multiboot mmap</li>\n<li>Implement <code>memory_map_print()</code> for debugging</li>\n<li>Test with QEMU memory configuration</li>\n</ol>\n<p><strong>Checkpoint:</strong> Memory regions printed correctly.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">memory_map_init</span><span style=\"color:#E1E4E8\">(mbi);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">memory_map_print</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Should show usable regions, reserved regions</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-2-physical-frame-allocator-4-5-hours\">Phase 2: Physical Frame Allocator (4-5 hours)</h3>\n<p><strong>Files:</strong> mm/pmm.h, mm/pmm.c</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Define bitmap array and constants</li>\n<li>Implement <code>pmm_init()</code> to mark usable/used frames</li>\n<li>Implement <code>pmm_alloc_frame()</code> with BSF optimization</li>\n<li>Implement <code>pmm_free_frame()</code> with double-free detection</li>\n<li>Implement statistics functions</li>\n</ol>\n<p><strong>Checkpoint:</strong> Allocate and free frames successfully.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">pmm_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> f1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> f2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Allocated frames: 0x</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\">, 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, f1, f2);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pmm_free_frame</span><span style=\"color:#E1E4E8\">(f1);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> f3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"After free, allocated: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, f3);</span><span style=\"color:#6A737D\">  // Should be f1</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-3-page-directory-and-page-table-structures-3-4-hours\">Phase 3: Page Directory and Page Table Structures (3-4 hours)</h3>\n<p><strong>Files:</strong> mm/vmm.h, mm/vmm.c (partial)</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Define PDE/PTE flag constants</li>\n<li>Define <code>page_table_t</code> and <code>page_directory_t</code> structures</li>\n<li>Implement <code>vmm_init()</code> to allocate initial page directory</li>\n<li>Implement helper macros for address extraction</li>\n</ol>\n<p><strong>Checkpoint:</strong> Page directory allocated and cleared.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">vmm_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Page directory at: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, current_page_directory);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Check that all entries are 0</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-4-virtual-memory-mapping-functions-3-4-hours\">Phase 4: Virtual Memory Mapping Functions (3-4 hours)</h3>\n<p><strong>Files:</strong> mm/vmm.c (continued)</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Implement <code>vmm_map_page()</code> with page table allocation</li>\n<li>Implement <code>vmm_unmap_page()</code></li>\n<li>Implement <code>vmm_get_physical()</code></li>\n<li>Implement <code>vmm_is_mapped()</code></li>\n</ol>\n<p><strong>Checkpoint:</strong> Map and unmap pages, verify translation.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">vmm_map_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">C0000000</span><span style=\"color:#E1E4E8\">, frame, PDE_WRITABLE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> phys </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> vmm_get_physical</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">C0000000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Mapped 0xC0000000 -> 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, phys);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(phys </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> frame);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-5-identity-mapping-setup-2-3-hours\">Phase 5: Identity Mapping Setup (2-3 hours)</h3>\n<p><strong>Files:</strong> mm/paging.h, mm/paging.c</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Implement <code>paging_setup_identity()</code></li>\n<li>Mark VGA region appropriately</li>\n<li>Verify all entries present</li>\n</ol>\n<p><strong>Checkpoint:</strong> First 4MB identity-mapped.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">paging_setup_identity</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; addr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">400000</span><span style=\"color:#E1E4E8\">; addr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> PAGE_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">vmm_is_mapped</span><span style=\"color:#E1E4E8\">(addr));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">vmm_get_physical</span><span style=\"color:#E1E4E8\">(addr) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> addr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-6-higher-half-kernel-mapping-3-4-hours\">Phase 6: Higher-Half Kernel Mapping (3-4 hours)</h3>\n<p><strong>Files:</strong> mm/paging.c (continued), linker.ld (update)</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Update linker script for higher-half addresses</li>\n<li>Implement <code>paging_setup_higher_half()</code></li>\n<li>Verify mapping without enabling paging yet</li>\n</ol>\n<p><strong>Checkpoint:</strong> Higher-half entries present in page directory.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">paging_setup_higher_half</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; offset </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">400000</span><span style=\"color:#E1E4E8\">; offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> PAGE_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> vaddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">C0000000</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> offset;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">vmm_is_mapped</span><span style=\"color:#E1E4E8\">(vaddr));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">vmm_get_physical</span><span style=\"color:#E1E4E8\">(vaddr) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> offset);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-7-paging-enable-and-transition-3-4-hours\">Phase 7: Paging Enable and Transition (3-4 hours)</h3>\n<p><strong>Files:</strong> mm/paging.c (continued), boot/paging_transition.asm (new)</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Implement <code>paging_enable()</code> with CR0.PG set</li>\n<li>Write assembly transition code</li>\n<li>Handle the identity-to-higher-half jump</li>\n<li>Test carefully in QEMU with GDB</li>\n</ol>\n<p><strong>Checkpoint:</strong> Paging enabled, kernel runs at higher-half address.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">paging_init</span><span style=\"color:#E1E4E8\">();</span><span style=\"color:#6A737D\">  // identity + higher-half + enable</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Paging enabled! Running at 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#FFAB70\">here</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">here:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// If we get here, paging works</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-8-tlb-management-2-3-hours\">Phase 8: TLB Management (2-3 hours)</h3>\n<p><strong>Files:</strong> mm/tlb.h, mm/tlb.c</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Implement <code>tlb_invalidate_page()</code> with <code>invlpg</code></li>\n<li>Implement <code>tlb_flush_all()</code> with CR3 reload</li>\n<li>Implement <code>tlb_flush_all_global()</code> with CR4.PGE toggle</li>\n<li>Integrate with <code>vmm_map_page()</code></li>\n</ol>\n<p><strong>Checkpoint:</strong> TLB invalidation working.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Map a page</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">vmm_map_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">D0000000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">pmm_alloc_frame</span><span style=\"color:#E1E4E8\">(), PDE_WRITABLE);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Write to it</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">D0000000</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">DEADBEEF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Unmap</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">vmm_unmap_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">D0000000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TLB should be invalidated, access should fault</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// *(volatile uint32_t *)0xD0000000 = 0;  // Should page fault</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-9-page-fault-handler-2-3-hours\">Phase 9: Page Fault Handler (2-3 hours)</h3>\n<p><strong>Files:</strong> mm/page_fault.h, mm/page_fault.c</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Implement <code>read_cr2()</code> helper</li>\n<li>Implement <code>page_fault_handler()</code> with diagnostics</li>\n<li>Register handler in IDT (update interrupt.c)</li>\n<li>Test with intentional faults</li>\n</ol>\n<p><strong>Checkpoint:</strong> Page faults produce diagnostic output.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Trigger page fault</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">DEADBEEF</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 42</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Should see page fault handler output</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-10-kernel-heap-allocator-4-6-hours\">Phase 10: Kernel Heap Allocator (4-6 hours)</h3>\n<p><strong>Files:</strong> mm/kmalloc.h, mm/kmalloc.c</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Define heap constants and block header</li>\n<li>Implement <code>kmalloc_init()</code> with initial heap mapping</li>\n<li>Implement <code>kmalloc()</code> with first-fit and splitting</li>\n<li>Implement <code>kfree()</code> with coalescing</li>\n<li>Implement <code>kcalloc()</code> and <code>krealloc()</code></li>\n<li>Test thoroughly</li>\n</ol>\n<p><strong>Checkpoint:</strong> Dynamic memory allocation working.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">kmalloc_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">50</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Allocated: 0x</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\">, 0x</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\">, 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, p1, p2, p3);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kfree</span><span style=\"color:#E1E4E8\">(p2);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p4 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">150</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Should reuse p2's space</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"After free, allocated: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, p4);</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"test-specification\">Test Specification</h2>\n<h3 id=\"test-memory-map-parsing\">Test: Memory Map Parsing</h3>\n<p><strong>Setup:</strong> Boot with multiboot, pass mbi to kernel</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Call <code>memory_map_init(mbi)</code></li>\n<li>Verify region count &gt; 0</li>\n<li>Verify at least one usable region exists</li>\n</ol>\n<p><strong>Expected:</strong> Regions printed, usable memory detected</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(memory_region_count </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> has_usable </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> memory_region_count; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">memory_regions</span><span style=\"color:#E1E4E8\">[i].type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> MEMORY_TYPE_USABLE) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        has_usable </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(has_usable);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-frame-allocation\">Test: Frame Allocation</h3>\n<p><strong>Setup:</strong> PMM initialized</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Allocate 10 frames</li>\n<li>Verify all addresses are 4KB aligned</li>\n<li>Verify no duplicates</li>\n<li>Free all frames</li>\n<li>Verify frames can be re-allocated</li>\n</ol>\n<p><strong>Expected:</strong> Clean allocation/deallocation</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> frames</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    frames</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frames</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#FFAB70\">frames</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFF</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 4KB aligned</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Check no duplicates</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; j </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">; j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frames</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#FFAB70\"> frames</span><span style=\"color:#E1E4E8\">[j]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-double-free-detection\">Test: Double-Free Detection</h3>\n<p><strong>Setup:</strong> PMM initialized</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Allocate a frame</li>\n<li>Free it</li>\n<li>Try to free it again</li>\n</ol>\n<p><strong>Expected:</strong> Warning logged, no crash</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pmm_free_frame</span><span style=\"color:#E1E4E8\">(frame);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Should log warning but not crash</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pmm_free_frame</span><span style=\"color:#E1E4E8\">(frame);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-page-mapping\">Test: Page Mapping</h3>\n<p><strong>Setup:</strong> VMM initialized</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Allocate a physical frame</li>\n<li>Map it to a virtual address</li>\n<li>Verify translation</li>\n<li>Write to virtual address</li>\n<li>Read back</li>\n</ol>\n<p><strong>Expected:</strong> Correct translation, data written/read</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> vaddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">C0100000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">vmm_map_page</span><span style=\"color:#E1E4E8\">(vaddr, frame, PDE_WRITABLE);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">vmm_is_mapped</span><span style=\"color:#E1E4E8\">(vaddr));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">vmm_get_physical</span><span style=\"color:#E1E4E8\">(vaddr) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> frame);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)vaddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">12345678</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)vaddr </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">12345678</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-paging-enable\">Test: Paging Enable</h3>\n<p><strong>Setup:</strong> Identity and higher-half mapping set up</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Enable paging</li>\n<li>Verify kernel still executing</li>\n<li>Access higher-half address</li>\n</ol>\n<p><strong>Expected:</strong> No triple fault, kernel continues</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">paging_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// If we get here, paging is enabled</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Paging enabled successfully!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-tlb-invalidation\">Test: TLB Invalidation</h3>\n<p><strong>Setup:</strong> Paging enabled</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Map a page</li>\n<li>Write to it</li>\n<li>Unmap it</li>\n<li>Verify TLB invalidated (access should fault)</li>\n</ol>\n<p><strong>Expected:</strong> Page fault on access after unmap</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> vaddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">D0001000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">vmm_map_page</span><span style=\"color:#E1E4E8\">(vaddr, </span><span style=\"color:#B392F0\">pmm_alloc_frame</span><span style=\"color:#E1E4E8\">(), PDE_WRITABLE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)vaddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 42</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">vmm_unmap_page</span><span style=\"color:#E1E4E8\">(vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Should page fault:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// *(volatile uint32_t *)vaddr = 0;</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-page-fault-handler\">Test: Page Fault Handler</h3>\n<p><strong>Setup:</strong> Page fault handler registered</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Access unmapped address</li>\n<li>Verify handler called</li>\n<li>Verify CR2 and error code printed</li>\n</ol>\n<p><strong>Expected:</strong> Diagnostic output with faulting address</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// This should trigger page fault handler</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">DEADBEEF</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 42</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Handler should print:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// \"PAGE FAULT at 0xDEADBEEF, cause: not present\"</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-kmalloc-basic\">Test: kmalloc Basic</h3>\n<p><strong>Setup:</strong> Heap initialized</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Allocate various sizes</li>\n<li>Verify alignment</li>\n<li>Write to allocated memory</li>\n<li>Free and reallocate</li>\n</ol>\n<p><strong>Expected:</strong> All allocations succeed, data intact</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(p1 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(p2 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(p3 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)p1 </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">F</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 16-byte aligned</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">memset</span><span style=\"color:#E1E4E8\">(p1, </span><span style=\"color:#9ECBFF\">'A'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">memset</span><span style=\"color:#E1E4E8\">(p2, </span><span style=\"color:#9ECBFF\">'B'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">memset</span><span style=\"color:#E1E4E8\">(p3, </span><span style=\"color:#9ECBFF\">'C'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kfree</span><span style=\"color:#E1E4E8\">(p2);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p4 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">50</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Should reuse p2's space</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(p4 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-heap-coalescing\">Test: Heap Coalescing</h3>\n<p><strong>Setup:</strong> Heap initialized</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Allocate three blocks</li>\n<li>Free middle block</li>\n<li>Free first block</li>\n<li>Verify coalescing (allocate larger block)</li>\n</ol>\n<p><strong>Expected:</strong> Blocks merged, larger allocation succeeds</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kfree</span><span style=\"color:#E1E4E8\">(p1);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kfree</span><span style=\"color:#E1E4E8\">(p2);</span><span style=\"color:#6A737D\">  // Should coalesce with p1</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p4 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">180</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Should fit in coalesced space</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(p4 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-targets\">Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Target</th>\n<th>How to Measure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Frame allocation</td>\n<td>&lt; 1 µs</td>\n<td>Cycle counter around <code>pmm_alloc_frame()</code></td>\n</tr>\n<tr>\n<td>Frame free</td>\n<td>&lt; 0.5 µs</td>\n<td>Cycle counter around <code>pmm_free_frame()</code></td>\n</tr>\n<tr>\n<td>Page mapping</td>\n<td>&lt; 2 µs</td>\n<td>Cycle counter around <code>vmm_map_page()</code></td>\n</tr>\n<tr>\n<td>Page unmapping</td>\n<td>&lt; 1 µs</td>\n<td>Cycle counter around <code>vmm_unmap_page()</code></td>\n</tr>\n<tr>\n<td>TLB invalidate (single)</td>\n<td>&lt; 50 cycles</td>\n<td><code>invlpg</code> instruction timing</td>\n</tr>\n<tr>\n<td>TLB flush (full)</td>\n<td>&lt; 500 cycles</td>\n<td>CR3 reload timing</td>\n</tr>\n<tr>\n<td>kmalloc (small, &lt; 64B)</td>\n<td>&lt; 5 µs</td>\n<td>Cycle counter around <code>kmalloc()</code></td>\n</tr>\n<tr>\n<td>kmalloc (large, &gt; 1KB)</td>\n<td>&lt; 20 µs</td>\n<td>Cycle counter around <code>kmalloc()</code></td>\n</tr>\n<tr>\n<td>kfree</td>\n<td>&lt; 3 µs</td>\n<td>Cycle counter around <code>kfree()</code></td>\n</tr>\n<tr>\n<td>Page fault handler</td>\n<td>&lt; 50 µs</td>\n<td>Time from fault to diagnostic output</td>\n</tr>\n</tbody></table>\n<p><strong>Measurement Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#B392F0\"> rdtsc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> lo, hi;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">rdtsc</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=a</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(lo), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(hi));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)hi </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> lo;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> benchmark_pmm</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> rdtsc</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> rdtsc</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Frame alloc: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> cycles</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)(end </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"hardware-soul\">Hardware Soul</h2>\n<h3 id=\"cache-behavior\">Cache Behavior</h3>\n<table>\n<thead>\n<tr>\n<th>Structure</th>\n<th>Size</th>\n<th>Cache Lines</th>\n<th>Access Pattern</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Page directory</td>\n<td>4KB</td>\n<td>64</td>\n<td>Sequential on walk, random on lookup</td>\n</tr>\n<tr>\n<td>Page table</td>\n<td>4KB</td>\n<td>64</td>\n<td>Sequential on walk, random on lookup</td>\n</tr>\n<tr>\n<td>Frame bitmap</td>\n<td>128KB</td>\n<td>2048</td>\n<td>Linear scan (predictable)</td>\n</tr>\n<tr>\n<td>Heap headers</td>\n<td>~24B each</td>\n<td>1 per 2 blocks</td>\n<td>Random (allocation dependent)</td>\n</tr>\n</tbody></table>\n<p><strong>Cache Optimization Notes:</strong></p>\n<ul>\n<li>Frame bitmap scan is prefetch-friendly (sequential reads)</li>\n<li>Page table walks benefit from having PD/PT in cache</li>\n<li>Heap fragmentation leads to cache misses on header traversal</li>\n</ul>\n<h3 id=\"branch-prediction\">Branch Prediction</h3>\n<table>\n<thead>\n<tr>\n<th>Code Path</th>\n<th>Predictability</th>\n<th>Why</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Bitmap scan</td>\n<td>High</td>\n<td>Linear scan, bit check usually fails</td>\n</tr>\n<tr>\n<td>Page table lookup</td>\n<td>Medium</td>\n<td>Depends on access pattern</td>\n</tr>\n<tr>\n<td>Heap first-fit</td>\n<td>Low</td>\n<td>Depends on allocation history</td>\n</tr>\n<tr>\n<td>Coalescing</td>\n<td>Low</td>\n<td>Depends on free pattern</td>\n</tr>\n</tbody></table>\n<h3 id=\"tlb-behavior\">TLB Behavior</h3>\n<p><strong>CRITICAL:</strong> Every TLB miss costs 2 memory accesses (PD read + PT read).</p>\n<table>\n<thead>\n<tr>\n<th>Working Set Size</th>\n<th>TLB Entries Needed</th>\n<th>Performance Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&lt; 128 KB</td>\n<td>&lt; 32</td>\n<td>Minimal (fits in L1 TLB)</td>\n</tr>\n<tr>\n<td>128 KB - 4 MB</td>\n<td>32 - 1024</td>\n<td>Moderate (L2 TLB helps)</td>\n</tr>\n<tr>\n<td>&gt; 4 MB</td>\n<td>&gt; 1024</td>\n<td>Significant (frequent TLB misses)</td>\n</tr>\n</tbody></table>\n<p><strong>Optimization Strategies:</strong></p>\n<ul>\n<li>Use 4MB pages for kernel code (single PDE, no PT walk)</li>\n<li>Map frequently accessed structures with global pages</li>\n<li>Keep page tables in physically contiguous memory</li>\n</ul>\n<h3 id=\"simd-opportunity\">SIMD Opportunity</h3>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>SIMD Potential</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Page table zeroing</td>\n<td>High</td>\n<td>Use SSE <code>movdqa</code> or <code>rep stosd</code></td>\n</tr>\n<tr>\n<td>Bitmap operations</td>\n<td>Medium</td>\n<td>Could use SSE for bulk set/clear</td>\n</tr>\n<tr>\n<td>Memory copy</td>\n<td>High</td>\n<td>SSE for <code>memcpy</code> implementation</td>\n</tr>\n<tr>\n<td>Heap operations</td>\n<td>Low</td>\n<td>Pointer manipulation, not data</td>\n</tr>\n</tbody></table>\n<p><strong>Example: SSE Page Zeroing</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> zero_page_sse</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">page</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"</span><span style=\"color:#9ECBFF\">pxor %%xmm0, %%xmm0</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"</span><span style=\"color:#9ECBFF\">movdqa %%xmm0, (%0)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"</span><span style=\"color:#9ECBFF\">movdqa %%xmm0, 16(%0)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"</span><span style=\"color:#9ECBFF\">movdqa %%xmm0, 32(%0)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"</span><span style=\"color:#9ECBFF\">movdqa %%xmm0, 48(%0)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // ... repeat for 4096 bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(page) : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">xmm0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">memory</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    );</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"memory-access-patterns\">Memory Access Patterns</h3>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Pattern</th>\n<th>Cache Friendliness</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Bitmap scan</td>\n<td>Sequential</td>\n<td>Excellent (prefetch)</td>\n</tr>\n<tr>\n<td>Page table walk</td>\n<td>2-level tree</td>\n<td>Moderate (depends on locality)</td>\n</tr>\n<tr>\n<td>Heap allocation</td>\n<td>Linked list</td>\n<td>Poor (pointer chasing)</td>\n</tr>\n<tr>\n<td>Page fault</td>\n<td>Random</td>\n<td>N/A (exception)</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"visual-diagrams\">Visual Diagrams</h2>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-017.svg\" alt=\"Physical Memory Map: E820/Multiboot Regions\"></p>\n<p>Memory map regions: usable vs. reserved address ranges</p>\n<p>{{DIAGRAM:tdd-diag-018}}\nFrame bitmap: address to bit mapping</p>\n<p>{{DIAGRAM:tdd-diag-019}}\nTwo-level page table: virtual address decomposition</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-020.svg\" alt=\"PDE and PTE Entry Layout (4 bytes each)\"></p>\n<p>PDE and PTE structure: flag bits and frame address</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-021.svg\" alt=\"Identity Mapping vs Higher-Half Mapping\"></p>\n<p>Identity mapping vs. higher-half mapping</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-022.svg\" alt=\"Paging Enable Transition Sequence\"></p>\n<p>Paging enable transition: identity to virtual</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-023.svg\" alt=\"TLB Coherency: invlpg vs CR3 Reload\"></p>\n<p>TLB invalidation: invlpg vs. CR3 reload</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-024.svg\" alt=\"Page Fault Handling: CR2 and Error Code\"></p>\n<p>Page fault handling: CR2 and error code</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-025.svg\" alt=\"kmalloc Block Header and Free List\"></p>\n<p>Heap block structure: header and usable space</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-026.svg\" alt=\"Memory Management Module Architecture\"></p>\n<p>Heap coalescing: merging adjacent free blocks</p>\n<hr>\n<p>[[CRITERIA_JSON: {&quot;module_id&quot;: &quot;build-os-m3&quot;, &quot;criteria&quot;: [&quot;Physical memory map obtained from multiboot info or E820 with regions classified as usable, reserved, or ACPI&quot;, &quot;Physical frame allocator (bitmap or free-list) allocates and frees 4KB frames with double-free prevention&quot;, &quot;Page directory and page tables configured for identity-mapping (kernel + VGA + MMIO) and higher-half kernel mapping (0xC0000000+)&quot;, &quot;Paging enabled by loading CR3 with page directory physical address and setting CR0.PG bit&quot;, &quot;TLB flushed with invlpg or CR3 reload after modifying page table entries&quot;, &quot;Page fault handler reads CR2 for faulting address and prints diagnostic (address, error code bits for present/write/user)&quot;, &quot;Kernel heap allocator (kmalloc/kfree) provides dynamic allocation from dedicated virtual range using page allocator for backing frames&quot;, &quot;Identity map maintained for low memory so VGA (0xB8000) and MMIO regions remain accessible at physical addresses&quot;]}]</p>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-os-m4 -->\n<h1 id=\"module-processes-and-preemptive-scheduling\">Module: Processes and Preemptive Scheduling</h1>\n<h2 id=\"module-charter\">Module Charter</h2>\n<p>This module implements preemptive multitasking, transforming the kernel from a single-threaded program into a multi-process system. It defines the Process Control Block (PCB) as the complete capture of CPU state (general registers, segment registers, EIP, ESP, EFLAGS, CR3), implements context switching in assembly to atomically save one process and restore another, configures the Task State Segment (TSS) for safe ring 3 → ring 0 transitions by providing the kernel stack pointer (ESP0), builds a round-robin scheduler triggered by timer interrupts that fairly distributes CPU time, creates isolated user-mode processes with their own page directories where kernel pages are supervisor-only, and establishes a system call interface via INT 0x80 with DPL=3 allowing user mode to request kernel services. This module does NOT implement priority scheduling, blocking I/O, signals, or multi-core support. The invariant is: after this module completes, multiple processes run concurrently with complete isolation, context switches preserve all state atomically, user processes cannot access kernel memory, and syscalls provide controlled kernel entry.</p>\n<hr>\n<h2 id=\"file-structure\">File Structure</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>kernel/\n├── process/\n│   ├── process.h             # 1. PCB structure and process API\n│   ├── process.c             # 1-2. Process creation and management\n│   ├── context_switch.h      # 3. Context switch interface\n│   └── context_switch.asm    # 3. Assembly context switch implementation\n├── tss/\n│   ├── tss.h                 # 4. TSS structure and interface\n│   └── tss.c                 # 4-5. TSS initialization and ESP0 update\n├── scheduler/\n│   ├── scheduler.h           # 6. Scheduler interface\n│   └── scheduler.c           # 6-7. Round-robin implementation\n├── user/\n│   ├── user_memory.h         # 8. User address space management\n│   ├── user_memory.c         # 8. User page directory creation\n│   ├── user_mode.h           # 9. User mode entry interface\n│   └── user_mode.asm         # 9. Assembly iret to user mode\n├── syscall/\n│   ├── syscall.h             # 10. System call interface\n│   ├── syscall.c             # 10-11. Syscall dispatch and implementations\n│   └── syscall.asm           # 10. Syscall assembly entry\n└── Makefile                  # Updated build system</code></pre></div>\n\n<hr>\n<h2 id=\"complete-data-model\">Complete Data Model</h2>\n<h3 id=\"process-control-block-pcb\">Process Control Block (PCB)</h3>\n<p>The PCB captures all state needed to suspend and resume a process. Every field exists because the CPU requires it to resume execution correctly.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* process.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_PROCESSES</span><span style=\"color:#79B8FF\">       16</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KERNEL_STACK_SIZE</span><span style=\"color:#79B8FF\">   4096</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> USER_STACK_SIZE</span><span style=\"color:#79B8FF\">     4096</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_NAME_LEN</span><span style=\"color:#79B8FF\">        16</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROCESS_STATE_UNUSED </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROCESS_STATE_READY,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROCESS_STATE_RUNNING,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROCESS_STATE_BLOCKED,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROCESS_STATE_ZOMBIE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">process_state_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CPU state saved on context switch</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This matches the stack layout created by interrupt entry + our pushes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // General-purpose registers (pushed by pusha in reverse order)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> edi;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esi;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ebp;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esp;</span><span style=\"color:#6A737D\">        // Kernel ESP at time of switch (not user ESP!)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ebx;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> edx;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ecx;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eax;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Segment registers (pushed manually)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ds;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> es;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> fs;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> gs;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ss;</span><span style=\"color:#6A737D\">         // Stack segment at interrupt time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> padding;</span><span style=\"color:#6A737D\">    // Align to 4 bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Control registers and pointers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eip;</span><span style=\"color:#6A737D\">        // Instruction pointer (from stack)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eflags;</span><span style=\"color:#6A737D\">     // CPU flags (from stack)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> cs;</span><span style=\"color:#6A737D\">         // Code segment (from stack)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> cr3;</span><span style=\"color:#6A737D\">        // Page directory physical address</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed)) </span><span style=\"color:#79B8FF\">cpu_state_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete process descriptor</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> process {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Identification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pid;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">[MAX_NAME_LEN];</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_state_t</span><span style=\"color:#E1E4E8\"> state;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // CPU state (must be aligned for efficient save/restore)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    cpu_state_t</span><span style=\"color:#E1E4E8\"> cpu;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Memory management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> kernel_stack;</span><span style=\"color:#6A737D\">      // Physical address of kernel stack</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> kernel_stack_top;</span><span style=\"color:#6A737D\">  // Top of kernel stack (ESP value)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> user_stack;</span><span style=\"color:#6A737D\">        // Physical address of user stack (if user mode)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> user_stack_top;</span><span style=\"color:#6A737D\">    // Top of user stack</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> page_directory;</span><span style=\"color:#6A737D\">    // Physical address of page directory (CR3)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Scheduling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> process </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">next;</span><span style=\"color:#6A737D\">       // Next process in ready queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> process </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">prev;</span><span style=\"color:#6A737D\">       // Previous process (for removal)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> time_slice;</span><span style=\"color:#6A737D\">        // Remaining time slice (for future priority)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> total_ticks;</span><span style=\"color:#6A737D\">       // Total CPU time consumed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Process type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> is_user;</span><span style=\"color:#6A737D\">                // 1 = user mode, 0 = kernel mode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Exit status (for zombie state)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> exit_status;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p><strong>Memory Layout of cpu_state_t:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Offset  Size  Field         Notes\n------  ----  -----         -----\n0       4     edi           pusha pushes this first\n4       4     esi\n8       4     ebp\n12      4     esp           Value before pusha (ignored on restore)\n16      4     ebx\n20      4     edx\n24      4     ecx\n28      4     eax           pusha pushes this last\n30      2     ds\n32      2     es\n34      2     fs\n36      2     gs\n38      2     ss\n40      2     padding\n44      4     eip           From interrupt stack frame\n48      4     eflags        From interrupt stack frame\n52      4     cs            From interrupt stack frame\n56      4     cr3           Page directory\nTotal: 60 bytes</code></pre></div>\n\n<p><strong>Cache Line Analysis:</strong></p>\n<ul>\n<li><code>cpu_state_t</code> is 60 bytes = 1 cache line (64 bytes)</li>\n<li><code>process_t</code> is ~100 bytes = 2 cache lines</li>\n<li>During context switch, we access ~2 cache lines per process</li>\n<li>Critical for performance: keep PCB small, aligned</li>\n</ul>\n<h3 id=\"task-state-segment-tss\">Task State Segment (TSS)</h3>\n<p>The TSS is used solely for ring 3 → ring 0 stack switching. The CPU loads SS0:ESP0 automatically on privilege level transitions.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* tss.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> link;     </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\"> _pad0;</span><span style=\"color:#6A737D\">   // Previous task link (for task switches)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esp0;</span><span style=\"color:#6A737D\">                       // Stack pointer for ring 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ss0;      </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\"> _pad1;</span><span style=\"color:#6A737D\">   // Stack segment for ring 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esp1;</span><span style=\"color:#6A737D\">                       // Stack pointer for ring 1 (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ss1;      </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\"> _pad2;</span><span style=\"color:#6A737D\">   // Stack segment for ring 1 (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esp2;</span><span style=\"color:#6A737D\">                       // Stack pointer for ring 2 (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ss2;      </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\"> _pad3;</span><span style=\"color:#6A737D\">   // Stack segment for ring 2 (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> cr3;</span><span style=\"color:#6A737D\">                        // Page directory (not used by us)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eip;</span><span style=\"color:#6A737D\">                        // Instruction pointer (not used)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eflags;</span><span style=\"color:#6A737D\">                     // CPU flags (not used)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eax, ecx, edx, ebx;</span><span style=\"color:#6A737D\">         // General registers (not used)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esp, ebp, esi, edi;</span><span style=\"color:#6A737D\">         // General registers (not used)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> es;       </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\"> _pad4;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> cs;       </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\"> _pad5;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ss;       </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\"> _pad6;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ds;       </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\"> _pad7;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> fs;       </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\"> _pad8;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> gs;       </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\"> _pad9;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ldtr;     </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\"> _pad10;</span><span style=\"color:#6A737D\">  // LDT selector (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> _pad11;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> iomap_base;</span><span style=\"color:#6A737D\">                 // I/O permission bitmap offset</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed)) </span><span style=\"color:#79B8FF\">tss_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TSS is 104 bytes minimum (without I/O bitmap)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// We place iomap_base = sizeof(tss_t) to indicate no I/O bitmap</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#79B8FF\"> tss_t</span><span style=\"color:#E1E4E8\"> kernel_tss;</span></span></code></pre></div>\n\n<p><strong>Memory Layout (104 bytes):</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Offset  Field\n------  -----\n0x00    link (2) + padding (2)\n0x04    esp0 (4)           &lt;-- CRITICAL: updated on every context switch\n0x08    ss0 (2) + padding (2)\n0x0C    esp1, ss1 (unused)\n0x14    esp2, ss2 (unused)\n0x1C    cr3 (unused)\n0x20    eip, eflags (unused)\n0x28    eax-edi (unused)\n0x48    es, cs, ss, ds, fs, gs (unused)\n0x58    ldtr (unused)\n0x60    iomap_base (2)\n0x64    End (104 bytes total)</code></pre></div>\n\n<p><strong>CRITICAL FIELDS:</strong></p>\n<ul>\n<li><code>esp0</code>: Must point to top of current process&#39;s kernel stack</li>\n<li><code>ss0</code>: Must be kernel data segment selector (0x10)</li>\n<li><code>iomap_base</code>: Set to <code>sizeof(tss_t)</code> = 104 to indicate no I/O bitmap</li>\n</ul>\n<h3 id=\"gdt-tss-descriptor\">GDT TSS Descriptor</h3>\n<p>The TSS must be referenced by a descriptor in the GDT.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// TSS descriptor in GDT (8 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Placed at GDT index 6 (selector 0x30)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Structure of TSS descriptor:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bits 0-15:  Limit low (sizeof(tss_t) - 1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bits 16-39: Base low (address bits 0-23)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bit 40:     Present (1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bits 41-42: DPL (00 for ring 0 only, 11 for ring 3 can use)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bit 43:     S (0 for system segment)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bits 44-47: Type (1001 = 32-bit TSS available)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bits 48-51: Limit high</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bit 52:     AVL (0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bit 53:     L (0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bit 54:     D/B (0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bit 55:     G (0 = byte granularity)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bits 56-63: Base high (address bits 24-31)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TSS_DESCRIPTOR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">base</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">limit</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">dpl</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (((</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)(base) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FF000000</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 56</span><span style=\"color:#F97583\"> |</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     ((</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)(limit) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">000F0000</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#F97583\"> |</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">ULL</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 47</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     ((</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)(dpl) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 45</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     (</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">9</span><span style=\"color:#F97583\">ULL</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 40</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     (((</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)(base) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">00FF0000</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     (((</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)(limit) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">0000FFFF</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     (((</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)(base) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">0000FFFF</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">))</span></span></code></pre></div>\n\n<h3 id=\"system-call-registers-convention\">System Call Registers Convention</h3>\n<p>System calls use registers for arguments, following a simple convention.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* syscall.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// System call numbers (in EAX)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SYS_EXIT</span><span style=\"color:#79B8FF\">    0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SYS_WRITE</span><span style=\"color:#79B8FF\">   1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SYS_READ</span><span style=\"color:#79B8FF\">    2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SYS_GETPID</span><span style=\"color:#79B8FF\">  3</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Register convention for INT 0x80:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EAX = syscall number</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EBX = first argument</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ECX = second argument</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EDX = third argument</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ESI = fourth argument (if needed)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EDI = fifth argument (if needed)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Return value in EAX</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Error: EAX = -errno (negative error code)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> syscall_num;</span><span style=\"color:#6A737D\">  // EAX</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> arg0;</span><span style=\"color:#6A737D\">         // EBX</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> arg1;</span><span style=\"color:#6A737D\">         // ECX</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> arg2;</span><span style=\"color:#6A737D\">         // EDX</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> arg3;</span><span style=\"color:#6A737D\">         // ESI</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> arg4;</span><span style=\"color:#6A737D\">         // EDI</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">syscall_args_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Syscall handler type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> int32_t</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">syscall_handler_t</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> arg0, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> arg1, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                      uint32_t</span><span style=\"color:#E1E4E8\"> arg2, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> arg3, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                      uint32_t</span><span style=\"color:#E1E4E8\"> arg4);</span></span></code></pre></div>\n\n<h3 id=\"ready-queue-structure\">Ready Queue Structure</h3>\n<p>The scheduler maintains a circular doubly-linked list of ready processes.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* scheduler.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Ready queue: circular doubly-linked list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#79B8FF\"> process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">ready_queue_head;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#79B8FF\"> process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">current_process;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Scheduler functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_add_process</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">proc</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_remove_process</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">proc</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">scheduler_pick_next</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_yield</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_unblock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">proc</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Timer hook</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_timer_tick</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Queue State Diagram:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Empty queue:\n    ready_queue_head = NULL\n    current_process = NULL\n\nSingle process:\n    ready_queue_head --&gt; [P1] &lt;--+\n                         ^  |    |\n                         +--+    |\n                         current_process\n\nMultiple processes (circular):\n    ready_queue_head --&gt; [P1] &lt;--&gt; [P2] &lt;--&gt; [P3] &lt;--+\n                         ^                           |\n                         |---------------------------+\n                         current_process</code></pre></div>\n\n<hr>\n<h2 id=\"interface-contracts\">Interface Contracts</h2>\n<h3 id=\"process_create-process_destroy\">process_create / process_destroy</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* process.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create a new kernel-mode process</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// entry_point: function to execute</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// name: process name for debugging</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns pointer to PCB, or NULL on failure</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">entry_point)(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create a new user-mode process</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// entry_point: virtual address of entry function (in user address space)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// name: process name for debugging</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns pointer to PCB, or NULL on failure</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">process_create_user</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">entry_point)(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get current process</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">process_get_current</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Terminate current process</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// status: exit status code</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> process_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> status</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((noreturn));</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Find process by PID</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">process_find_by_pid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> pid</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Preconditions:</strong></p>\n<ul>\n<li>Memory management initialized (kmalloc available)</li>\n<li>GDT configured with kernel and user segments</li>\n</ul>\n<p><strong>Postconditions:</strong></p>\n<ul>\n<li>PCB allocated and initialized</li>\n<li>Kernel stack allocated</li>\n<li>Process added to ready queue</li>\n<li>For user processes: page directory created with isolated address space</li>\n</ul>\n<p><strong>Error Handling:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Error</th>\n<th>Detection</th>\n<th>Recovery</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>No free PCB slots</td>\n<td>Loop finds no unused entry</td>\n<td>Return NULL</td>\n</tr>\n<tr>\n<td>Stack allocation failed</td>\n<td><code>kmalloc</code> returns NULL</td>\n<td>Return NULL</td>\n</tr>\n<tr>\n<td>Page directory failed</td>\n<td><code>pmm_alloc_frame</code> returns 0</td>\n<td>Return NULL</td>\n</tr>\n</tbody></table>\n<h3 id=\"context_switch\">context_switch</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* context_switch.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Switch from current process to next process</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is called from scheduler after picking next process</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Does NOT return normally - it \"returns\" into the new process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> context_switch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">old</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">new</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Assembly entry point for context switch from interrupt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Called with interrupts disabled, after saving interrupt state to stack</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> context_switch_from_interrupt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Preconditions:</strong></p>\n<ul>\n<li>Interrupts disabled</li>\n<li><code>old</code> process state already saved to PCB (by interrupt handler)</li>\n<li><code>new</code> process has valid state in PCB</li>\n</ul>\n<p><strong>Postconditions:</strong></p>\n<ul>\n<li>All registers restored from <code>new-&gt;cpu</code></li>\n<li>CR3 loaded with <code>new-&gt;page_directory</code></li>\n<li>ESP0 in TSS updated to <code>new-&gt;kernel_stack_top</code></li>\n<li>Execution resumes at <code>new-&gt;cpu.eip</code></li>\n</ul>\n<p><strong>CRITICAL:</strong> This function does not return in the normal sense. It &quot;returns&quot; into the new process at whatever EIP the new process was at when switched out.</p>\n<h3 id=\"tss_init-tss_update_esp0\">tss_init / tss_update_esp0</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* tss.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize TSS and load TR</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Must be called after GDT is configured</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tss_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Update ESP0 field for current process</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Must be called after every context switch</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tss_update_esp0</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> esp0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get current ESP0 value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> tss_get_esp0</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Preconditions:</strong></p>\n<ul>\n<li>GDT configured with TSS descriptor at index 6</li>\n</ul>\n<p><strong>Postconditions:</strong></p>\n<ul>\n<li>TSS zeroed and initialized</li>\n<li>SS0 set to kernel data segment (0x10)</li>\n<li>TR loaded with TSS selector (0x30)</li>\n<li>ESP0 valid</li>\n</ul>\n<h3 id=\"scheduler_add-scheduler_remove-scheduler_pick_next\">scheduler_add / scheduler_remove / scheduler_pick_next</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* scheduler.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Add process to end of ready queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_add_process</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">proc</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Remove process from ready queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_remove_process</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">proc</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Pick next process to run (round-robin)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns process to run, or NULL if no processes ready</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">scheduler_pick_next</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Voluntarily yield CPU</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_yield</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Called from timer interrupt</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_timer_tick</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Preconditions:</strong></p>\n<ul>\n<li>Process state is PROCESS_STATE_READY (for add)</li>\n</ul>\n<p><strong>Postconditions:</strong></p>\n<ul>\n<li>Process linked into ready queue</li>\n<li>On pick_next: selected process state = PROCESS_STATE_RUNNING</li>\n</ul>\n<h3 id=\"user_create_page_directory-user_map_code\">user_create_page_directory / user_map_code</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* user_memory.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create a new page directory for user process</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Copies kernel mappings (higher half) but marks them supervisor-only</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns physical address of page directory, or 0 on failure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> user_create_page_directory</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Map user code at virtual address 0x00001000</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// pd_phys: physical address of user page directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// code: pointer to code data (will be copied)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// size: size of code</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns 0 on success, -1 on failure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> user_map_code</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> pd_phys</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">code</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Map user stack at virtual address 0xBFFFF000</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// pd_phys: physical address of user page directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns 0 on success, -1 on failure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> user_map_stack</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> pd_phys</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Preconditions:</strong></p>\n<ul>\n<li>PMM and VMM initialized</li>\n<li>Paging enabled</li>\n</ul>\n<p><strong>Postconditions:</strong></p>\n<ul>\n<li>User page directory created</li>\n<li>Kernel pages mapped but supervisor-only</li>\n<li>User code and stack mapped with user-accessible flag</li>\n</ul>\n<h3 id=\"jump_to_user_mode\">jump_to_user_mode</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* user_mode.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Jump to user mode using iret</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This function never returns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// entry: virtual address of user entry point</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// stack_top: virtual address of user stack top</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> jump_to_user_mode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> entry</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> stack_top</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((noreturn));</span></span></code></pre></div>\n\n<p><strong>Preconditions:</strong></p>\n<ul>\n<li>User page directory loaded (CR3)</li>\n<li>User code and stack mapped</li>\n<li>TSS ESP0 set to valid kernel stack</li>\n</ul>\n<p><strong>Postconditions:</strong></p>\n<ul>\n<li>CPU in ring 3 (CPL = 3)</li>\n<li>CS = user code selector (0x1B)</li>\n<li>SS = user data selector (0x23)</li>\n<li>ESP = stack_top</li>\n<li>EIP = entry</li>\n</ul>\n<h3 id=\"syscall_handler\">syscall_handler</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* syscall.h */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Main syscall dispatcher</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// regs: pointer to saved register state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> syscall_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Register a syscall handler</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> syscall_register</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">syscall_handler_t</span><span style=\"color:#FFAB70\"> handler</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Individual syscall implementations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int32_t</span><span style=\"color:#B392F0\"> sys_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> status</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int32_t</span><span style=\"color:#B392F0\"> sys_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> len</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int32_t</span><span style=\"color:#B392F0\"> sys_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> len</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int32_t</span><span style=\"color:#B392F0\"> sys_getpid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Preconditions:</strong></p>\n<ul>\n<li>IDT gate 0x80 configured with DPL=3 (0xEE)</li>\n<li>Syscall table initialized</li>\n</ul>\n<p><strong>Postconditions:</strong></p>\n<ul>\n<li>Syscall executed</li>\n<li>Return value in EAX</li>\n<li>If error: EAX = negative error code</li>\n</ul>\n<hr>\n<h2 id=\"algorithm-specification\">Algorithm Specification</h2>\n<h3 id=\"algorithm-process-creation-kernel-mode\">Algorithm: Process Creation (Kernel Mode)</h3>\n<p><strong>Purpose:</strong> Create a new kernel-mode process ready to execute.</p>\n<p><strong>Inputs:</strong></p>\n<ul>\n<li>Entry point function pointer</li>\n<li>Process name</li>\n</ul>\n<p><strong>Outputs:</strong> Pointer to initialized PCB</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>Find unused slot in process table</li>\n<li>Allocate PID</li>\n<li>Zero PCB structure</li>\n<li>Set initial CPU state:<ul>\n<li>EIP = entry_point</li>\n<li>CS = kernel code selector (0x08)</li>\n<li>DS/ES/FS/GS/SS = kernel data selector (0x10)</li>\n<li>EFLAGS = 0x202 (IF set, reserved bit set)</li>\n<li>CR3 = kernel page directory</li>\n</ul>\n</li>\n<li>Allocate kernel stack</li>\n<li>Set ESP = kernel_stack_top</li>\n<li>Set state = PROCESS_STATE_READY</li>\n<li>Add to scheduler ready queue</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">entry_point)(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find free slot</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> MAX_PROCESSES; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">process_table</span><span style=\"color:#E1E4E8\">[i].state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PROCESS_STATE_UNUSED) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#FFAB70\">process_table</span><span style=\"color:#E1E4E8\">[i];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">proc) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize PCB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next_pid</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PROCESS_STATE_READY;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->is_user </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strncpy</span><span style=\"color:#E1E4E8\">(proc->name, name, MAX_NAME_LEN </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate kernel stack</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->kernel_stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">kmalloc</span><span style=\"color:#E1E4E8\">(KERNEL_STACK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">proc->kernel_stack) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PROCESS_STATE_UNUSED;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->kernel_stack_top </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc->kernel_stack </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> KERNEL_STACK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set initial CPU state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->cpu.eip </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)entry_point;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->cpu.cs </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->cpu.ds </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->cpu.es </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->cpu.fs </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->cpu.gs </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->cpu.ss </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->cpu.esp </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc->kernel_stack_top;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->cpu.eflags </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">202</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // IF set</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->cpu.cr3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)kernel_page_directory;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add to ready queue</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scheduler_add_process</span><span style=\"color:#E1E4E8\">(proc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> proc;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>Process is in ready queue</li>\n<li>Kernel stack is valid and 4KB aligned</li>\n<li>EFLAGS.IF = 1 (process can receive interrupts)</li>\n</ul>\n<h3 id=\"algorithm-context-switch-assembly\">Algorithm: Context Switch (Assembly)</h3>\n<p><strong>Purpose:</strong> Atomically switch from one process to another.</p>\n<p><strong>Inputs:</strong></p>\n<ul>\n<li><code>old</code>: PCB of current process (to save state)</li>\n<li><code>new</code>: PCB of next process (to restore state)</li>\n</ul>\n<p><strong>Outputs:</strong> None (execution resumes in new process)</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>Disable interrupts (cli)</li>\n<li>Save current segment registers to old PCB</li>\n<li>Save current general registers to old PCB</li>\n<li>Save old ESP to old PCB</li>\n<li>Load new CR3 (page directory)</li>\n<li>Update TSS ESP0 to new kernel stack top</li>\n<li>Load new segment registers from new PCB</li>\n<li>Load new general registers from new PCB</li>\n<li>Load new ESP from new PCB</li>\n<li>Enable interrupts (restore from new EFLAGS)</li>\n<li>Return (actually &quot;returns&quot; to new EIP)</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; context_switch.asm\n[BITS 32]\n\nglobal context_switch\nextern kernel_tss\nextern tss_update_esp0\n\n; void context_switch(process_t *old, process_t *new)\n; Stack: [ret_addr] [old] [new]\ncontext_switch:\n    push ebp\n    mov ebp, esp\n    push ebx\n    push esi\n    push edi\n    \n    mov ebx, [ebp + 8]     ; old process\n    mov ecx, [ebp + 12]    ; new process\n    \n    ; ===== SAVE OLD PROCESS STATE =====\n    test ebx, ebx\n    jz .load_new           ; Skip save if old is NULL\n    \n    ; Save general-purpose registers\n    mov [ebx + process_t.cpu + cpu_state_t.eax], eax\n    mov [ebx + process_t.cpu + cpu_state_t.ebx], ebx\n    mov [ebx + process_t.cpu + cpu_state_t.ecx], ecx\n    mov [ebx + process_t.cpu + cpu_state_t.edx], edx\n    mov [ebx + process_t.cpu + cpu_state_t.esi], esi\n    mov [ebx + process_t.cpu + cpu_state_t.edi], edi\n    mov [ebx + process_t.cpu + cpu_state_t.ebp], ebp\n    \n    ; Save ESP (current stack pointer after our pushes)\n    lea eax, [ebp + 16]    ; ESP before function call\n    mov [ebx + process_t.cpu + cpu_state_t.esp], eax\n    \n    ; Save return address as EIP\n    mov eax, [ebp + 4]     ; Return address\n    mov [ebx + process_t.cpu + cpu_state_t.eip], eax\n    \n    ; Save EFLAGS\n    pushf\n    pop eax\n    mov [ebx + process_t.cpu + cpu_state_t.eflags], eax\n    \n    ; Save segment registers\n    mov ax, ds\n    mov [ebx + process_t.cpu + cpu_state_t.ds], ax\n    mov ax, es\n    mov [ebx + process_t.cpu + cpu_state_t.es], ax\n    mov ax, fs\n    mov [ebx + process_t.cpu + cpu_state_t.fs], ax\n    mov ax, gs\n    mov [ebx + process_t.cpu + cpu_state_t.gs], ax\n    mov ax, ss\n    mov [ebx + process_t.cpu + cpu_state_t.ss], ax\n    \n    ; Save CR3\n    mov eax, cr3\n    mov [ebx + process_t.cpu + cpu_state_t.cr3], eax\n\n.load_new:\n    ; ===== LOAD NEW PROCESS STATE =====\n    mov ecx, [ebp + 12]    ; new process\n    \n    ; Update TSS ESP0\n    mov eax, [ecx + process_t.kernel_stack_top]\n    mov [kernel_tss + tss_t.esp0], eax\n    \n    ; Load CR3 (page directory)\n    mov eax, [ecx + process_t.cpu + cpu_state_t.cr3]\n    mov cr3, eax\n    \n    ; Load segment registers\n    mov ax, [ecx + process_t.cpu + cpu_state_t.ds]\n    mov ds, ax\n    mov ax, [ecx + process_t.cpu + cpu_state_t.es]\n    mov es, ax\n    mov ax, [ecx + process_t.cpu + cpu_state_t.fs]\n    mov fs, ax\n    mov ax, [ecx + process_t.cpu + cpu_state_t.gs]\n    mov gs, ax\n    \n    ; Load EFLAGS\n    push dword [ecx + process_t.cpu + cpu_state_t.eflags]\n    popf\n    \n    ; Load general registers\n    mov eax, [ecx + process_t.cpu + cpu_state_t.eax]\n    mov ebx, [ecx + process_t.cpu + cpu_state_t.ebx]\n    mov ecx, [ecx + process_t.cpu + cpu_state_t.ecx]\n    mov edx, [ecx + process_t.cpu + cpu_state_t.edx]\n    mov esi, [ecx + process_t.cpu + cpu_state_t.esi]\n    mov edi, [ecx + process_t.cpu + cpu_state_t.edi]\n    mov ebp, [ecx + process_t.cpu + cpu_state_t.ebp]\n    \n    ; Load ESP and EIP simultaneously via stack\n    mov esp, [ecx + process_t.cpu + cpu_state_t.esp]\n    \n    ; Return to new EIP (this is the magic!)\n    jmp [ecx + process_t.cpu + cpu_state_t.eip]\n    \n    ; Never reaches here</code></pre></div>\n\n<p><strong>CRITICAL INSIGHTS:</strong></p>\n<ol>\n<li>The return address is saved as EIP - when we later &quot;return&quot; to this address, we resume the old process</li>\n<li>ESP is loaded last, after all other registers - this is the actual switch point</li>\n<li>CR3 reload flushes TLB (unless global pages used) - expensive but necessary</li>\n<li>EFLAGS.IF is restored from new process, re-enabling interrupts</li>\n</ol>\n<h3 id=\"algorithm-round-robin-scheduling\">Algorithm: Round-Robin Scheduling</h3>\n<p><strong>Purpose:</strong> Fairly distribute CPU time among ready processes.</p>\n<p><strong>Inputs:</strong> None (uses ready queue)\n<strong>Outputs:</strong> Next process to run</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>If no current process, return head of ready queue</li>\n<li>Find next process in circular queue after current</li>\n<li>Skip processes that are not READY</li>\n<li>Return found process</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">scheduler_pick_next</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ready_queue_head </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (current_process </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ready_queue_head;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current_process->state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PROCESS_STATE_RUNNING;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> current_process;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start from current, find next ready process</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current_process->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (next </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> current_process) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (next->state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PROCESS_STATE_READY) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current_process->state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PROCESS_STATE_READY;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            next->state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PROCESS_STATE_RUNNING;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Only current process is ready, continue running it</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> current_process;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>Ready queue is circular</li>\n<li>At least one process is RUNNING if any exist</li>\n<li>No process appears twice in queue</li>\n</ul>\n<h3 id=\"algorithm-timer-interrupt-scheduler-hook\">Algorithm: Timer Interrupt Scheduler Hook</h3>\n<p><strong>Purpose:</strong> Trigger context switch on timer tick.</p>\n<p><strong>Inputs:</strong> Timer interrupt\n<strong>Outputs:</strong> Possible context switch</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>Increment tick counter</li>\n<li>Increment current process&#39;s total_ticks</li>\n<li>Decrement time slice</li>\n<li>If time slice expired:<ul>\n<li>Reset time slice</li>\n<li>Pick next process</li>\n<li>If different from current, do context switch</li>\n</ul>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_timer_tick</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (current_process </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_process->total_ticks</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_process->time_slice</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (current_process->time_slice </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Time slice expired, switch process</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current_process->time_slice </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> DEFAULT_TIME_SLICE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">next </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> scheduler_pick_next</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (next </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> next </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> current_process) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">old </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current_process;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            context_switch</span><span style=\"color:#E1E4E8\">(old, next);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"algorithm-user-page-directory-creation\">Algorithm: User Page Directory Creation</h3>\n<p><strong>Purpose:</strong> Create isolated address space for user process.</p>\n<p><strong>Inputs:</strong> None\n<strong>Outputs:</strong> Physical address of new page directory</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>Allocate frame for page directory</li>\n<li>Zero the page directory</li>\n<li>Copy kernel mappings (entries 768-1023 for higher half)</li>\n<li>Clear user-accessible bit on kernel pages</li>\n<li>Allocate and map user code page at 0x00001000</li>\n<li>Allocate and map user stack page at 0xBFFFF000</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> user_create_page_directory</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate page directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pd_phys </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (pd_phys </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pd </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)pd_phys;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Zero page directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pd->entries[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Copy kernel mappings (higher half: 0xC0000000+)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // These are supervisor-only (no PAGE_USER flag)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 768</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pd->entries[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> kernel_page_directory->entries[i];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Ensure kernel pages are NOT user-accessible</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pd->entries[i] </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#E1E4E8\">PAGE_USER;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> pd_phys;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> user_map_code</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> pd_phys</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">code</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pd </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)pd_phys;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate frame for code</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> code_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (code_frame </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Map at 0x00001000 (user virtual address)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> vaddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">00001000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pd_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (vaddr </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 22</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">3FF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pt_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (vaddr </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">3FF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create page table if needed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(pd->entries[pd_idx] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PAGE_PRESENT)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> pt_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pmm_alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (pt_frame </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)pt_frame;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pt->entries[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pd->entries[pd_idx] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pt_frame </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PAGE_PRESENT </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PAGE_WRITABLE </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PAGE_USER;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Map the page</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)(pd->entries[pd_idx] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFFF000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pt->entries[pt_idx] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> code_frame </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PAGE_PRESENT </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PAGE_WRITABLE </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PAGE_USER;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Copy code to frame (need temporary mapping)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... implementation depends on your VMM</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>CRITICAL:</strong> Kernel pages MUST NOT have PAGE_USER flag set, or user processes can read kernel memory.</p>\n<h3 id=\"algorithm-jump-to-user-mode\">Algorithm: Jump to User Mode</h3>\n<p><strong>Purpose:</strong> Transition from kernel mode to user mode.</p>\n<p><strong>Inputs:</strong></p>\n<ul>\n<li>User entry point address</li>\n<li>User stack top address</li>\n</ul>\n<p><strong>Outputs:</strong> Never returns (executes in user mode)</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>Load user data segment selectors</li>\n<li>Push user SS (0x23)</li>\n<li>Push user ESP</li>\n<li>Push user EFLAGS (with IF set)</li>\n<li>Push user CS (0x1B)</li>\n<li>Push user EIP</li>\n<li>Execute <code>iret</code></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; user_mode.asm\n[BITS 32]\n\nglobal jump_to_user_mode\n\n; void jump_to_user_mode(uint32_t entry, uint32_t stack_top)\n; [ret] [entry] [stack_top]\njump_to_user_mode:\n    mov eax, [esp + 4]     ; entry\n    mov ebx, [esp + 8]     ; stack_top\n    \n    ; Load user data segments\n    mov ax, 0x23           ; User data selector (index 4, RPL=3)\n    mov ds, ax\n    mov es, ax\n    mov fs, ax\n    mov gs, ax\n    \n    ; Set up stack for iret\n    ; Stack must contain: SS, ESP, EFLAGS, CS, EIP\n    \n    push 0x23              ; SS = user data segment\n    push ebx               ; ESP = user stack top\n    \n    ; Set up EFLAGS with IF=1\n    pushf\n    or dword [esp], 0x200  ; Set IF\n    and dword [esp], ~0x4000  ; Clear NT (nested task)\n    \n    push 0x1B              ; CS = user code segment (index 3, RPL=3)\n    push eax               ; EIP = entry point\n    \n    ; iret pops: EIP, CS, EFLAGS, [ESP, SS if CPL change]\n    iret\n    \n    ; Never returns</code></pre></div>\n\n<p><strong>CRITICAL:</strong> The selector values must have RPL=3 (bits 0-1 = 11) for the CPU to enter ring 3.</p>\n<h3 id=\"algorithm-system-call-handler\">Algorithm: System Call Handler</h3>\n<p><strong>Purpose:</strong> Dispatch system calls from user mode.</p>\n<p><strong>Inputs:</strong></p>\n<ul>\n<li>EAX = syscall number</li>\n<li>EBX-EDI = arguments</li>\n</ul>\n<p><strong>Outputs:</strong> EAX = return value</p>\n<p><strong>Procedure:</strong></p>\n<ol>\n<li>Save all registers (already done by interrupt entry)</li>\n<li>Validate syscall number</li>\n<li>Look up handler in syscall table</li>\n<li>Call handler with arguments</li>\n<li>Store return value in regs-&gt;eax</li>\n<li>Return (iret restores registers)</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Syscall table</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> syscall_handler_t</span><span style=\"color:#FFAB70\"> syscall_table</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> syscall_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> regs->eax;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (num </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#FFAB70\"> syscall_table</span><span style=\"color:#E1E4E8\">[num] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        regs->eax </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // ENOSYS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Call handler</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int32_t</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> syscall_table</span><span style=\"color:#E1E4E8\">[num](</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        regs->ebx,</span><span style=\"color:#6A737D\">  // arg0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        regs->ecx,</span><span style=\"color:#6A737D\">  // arg1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        regs->edx,</span><span style=\"color:#6A737D\">  // arg2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        regs->esi,</span><span style=\"color:#6A737D\">  // arg3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        regs->edi</span><span style=\"color:#6A737D\">   // arg4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    );</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    regs->eax </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// sys_exit: terminate current process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int32_t</span><span style=\"color:#B392F0\"> sys_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> status</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_process->state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PROCESS_STATE_ZOMBIE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_process->exit_status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Force immediate reschedule</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scheduler_yield</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Never returns</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// sys_write: write to file descriptor</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int32_t</span><span style=\"color:#B392F0\"> sys_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> len</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For now, fd 0 = console output</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">9</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // EBADF</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validate buffer is in user space</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)buf </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">C0000000</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">14</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // EFAULT</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> len; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_putchar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        serial_putchar</span><span style=\"color:#E1E4E8\">(COM1_PORT, </span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> len;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// sys_getpid: get current process ID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int32_t</span><span style=\"color:#B392F0\"> sys_getpid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int32_t</span><span style=\"color:#E1E4E8\">)current_process->pid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>IDT Gate Configuration:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Gate 0x80 must have DPL=3 (bits 5-6 = 11) for user mode to call</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 0xEE = P=1, DPL=3, S=0, Type=0xE (32-bit interrupt gate)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">isr128</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">EE</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"error-handling-matrix\">Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th>Error</th>\n<th>Detected By</th>\n<th>Recovery</th>\n<th>User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Context switch corrupts registers</td>\n<td>Assembly bug, manifests as random crashes</td>\n<td>Debug with register dump</td>\n<td>Yes, crash</td>\n</tr>\n<tr>\n<td>TSS ESP0 invalid</td>\n<td>Triple fault on ring 3→ring0 transition</td>\n<td>Validate before context switch</td>\n<td>Yes, reboot</td>\n</tr>\n<tr>\n<td>User can access kernel memory</td>\n<td>Page fault on kernel access (if PAGE_USER set wrong)</td>\n<td>Audit page table flags</td>\n<td>No (security hole)</td>\n</tr>\n<tr>\n<td>Syscall with wrong DPL</td>\n<td>General protection fault on INT 0x80</td>\n<td>Fix IDT gate flags</td>\n<td>Yes, crash</td>\n</tr>\n<tr>\n<td>Process table full</td>\n<td>Loop finds no unused slot</td>\n<td>Return NULL from create</td>\n<td>Caller handles</td>\n</tr>\n<tr>\n<td>Stack overflow</td>\n<td>Page fault or corruption</td>\n<td>Increase stack size</td>\n<td>Yes, crash</td>\n</tr>\n<tr>\n<td>Circular queue broken</td>\n<td>Infinite loop in scheduler</td>\n<td>Validate queue integrity</td>\n<td>Yes, hang</td>\n</tr>\n<tr>\n<td>Double context switch</td>\n<td>Reentrant interrupt</td>\n<td>Disable IRQs during switch</td>\n<td>Yes, corruption</td>\n</tr>\n<tr>\n<td>Invalid syscall number</td>\n<td>Bounds check</td>\n<td>Return -ENOSYS</td>\n<td>No, returns error</td>\n</tr>\n<tr>\n<td>Bad user pointer</td>\n<td>Page fault in syscall</td>\n<td>Return -EFAULT</td>\n<td>No, returns error</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"concurrency-specification\">Concurrency Specification</h2>\n<h3 id=\"interrupt-safety\">Interrupt Safety</h3>\n<table>\n<thead>\n<tr>\n<th>Data Structure</th>\n<th>Access Pattern</th>\n<th>Protection</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Process table</td>\n<td>Read/write from IRQ context</td>\n<td>Disable IRQs during modification</td>\n</tr>\n<tr>\n<td>Ready queue</td>\n<td>Read/write from IRQ context</td>\n<td>Disable IRQs during modification</td>\n</tr>\n<tr>\n<td>Current process pointer</td>\n<td>Read/write from IRQ context</td>\n<td>Disable IRQs during modification</td>\n</tr>\n<tr>\n<td>TSS ESP0</td>\n<td>Write from context switch</td>\n<td>IRQs already disabled</td>\n</tr>\n</tbody></table>\n<h3 id=\"critical-sections\">Critical Sections</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Context switch MUST be atomic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> do_context_switch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> flags;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">pushf; pop %0; cli</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(flags));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">old </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current_process;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">new </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> scheduler_pick_next</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (new </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> old) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        context_switch</span><span style=\"color:#E1E4E8\">(old, new);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Restore interrupts if they were enabled</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">sti</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"reentrancy-rules\">Reentrancy Rules</h3>\n<ul>\n<li><strong>Timer interrupt:</strong> CAN interrupt kernel code, MUST NOT interrupt context switch</li>\n<li><strong>Context switch:</strong> MUST NOT be interrupted (IRQs disabled)</li>\n<li><strong>Scheduler:</strong> CAN be called from interrupt context only</li>\n<li><strong>Syscall handler:</strong> CAN be interrupted, MUST NOT cause context switch directly</li>\n</ul>\n<hr>\n<h2 id=\"state-machine-process-lifecycle\">State Machine: Process Lifecycle</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>                    +------------------+\n                    |     UNUSED       |\n                    +--------+---------+\n                             |\n                      process_create()\n                             |\n                             v\n                    +------------------+\n            +------&gt;|      READY       |&lt;------+\n            |       +--------+---------+       |\n            |                |                 |\n            |         scheduler_pick()         |\n            |                |                 |\n            |                v                 |\n            |       +------------------+       |\n            |       |     RUNNING      |-------+\n            |       +--------+---------+  time_slice=0\n            |                |\n            |         block() or\n            |         wait for I/O\n            |                |\n            |                v\n            |       +------------------+\n            |       |     BLOCKED      |\n            |       +--------+---------+\n            |                |\n            |         I/O complete\n            |         or event\n            |                |\n            +----------------+\n            \n            sys_exit() or\n            fatal exception\n                    |\n                    v\n           +------------------+\n           |      ZOMBIE      |\n           +--------+---------+\n                    |\n             parent reaps\n                    |\n                    v\n           +------------------+\n           |     UNUSED       |\n           +------------------+\n\nStates:\n  - UNUSED: PCB slot available\n  - READY: Process can run, waiting for CPU\n  - RUNNING: Currently executing\n  - BLOCKED: Waiting for I/O or event (not implemented yet)\n  - ZOMBIE: Terminated, waiting for parent to reap</code></pre></div>\n\n<hr>\n<h2 id=\"implementation-sequence-with-checkpoints\">Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-process-control-block-structure-2-3-hours\">Phase 1: Process Control Block Structure (2-3 hours)</h3>\n<p><strong>Files:</strong> process/process.h</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Define <code>process_state_t</code> enum</li>\n<li>Define <code>cpu_state_t</code> structure with all registers</li>\n<li>Define <code>process_t</code> structure</li>\n<li>Define constants (MAX_PROCESSES, stack sizes)</li>\n<li>Calculate offsets for assembly access</li>\n</ol>\n<p><strong>Checkpoint:</strong> Structures compile, sizes verified.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"process.h\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">cpu_state_t</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 60</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">offsetof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">, cpu) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 20</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // After pid, name, state</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-2-process-creation-kernel-mode-3-4-hours\">Phase 2: Process Creation (Kernel Mode) (3-4 hours)</h3>\n<p><strong>Files:</strong> process/process.c</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Declare process table and current_process</li>\n<li>Implement <code>process_create()</code></li>\n<li>Implement <code>process_get_current()</code></li>\n<li>Test process creation without scheduling</li>\n</ol>\n<p><strong>Checkpoint:</strong> Process created, added to table.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(test_function, </span><span style=\"color:#9ECBFF\">\"test\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(p1 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(p1</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">pid </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(p1</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PROCESS_STATE_READY);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(p1</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">cpu.eip </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">test_function</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-3-context-switch-assembly-5-7-hours\">Phase 3: Context Switch Assembly (5-7 hours)</h3>\n<p><strong>Files:</strong> process/context_switch.h, process/context_switch.asm</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Write assembly context switch function</li>\n<li>Define offsets as constants (match C struct)</li>\n<li>Implement save of old process</li>\n<li>Implement load of new process</li>\n<li>Handle NULL old process (first switch)</li>\n</ol>\n<p><strong>Checkpoint:</strong> Context switch works between two processes.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Create two processes, manually switch</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(proc1_func, </span><span style=\"color:#9ECBFF\">\"proc1\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(proc2_func, </span><span style=\"color:#9ECBFF\">\"proc2\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">current_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> p1;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">p1</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PROCESS_STATE_RUNNING;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This should switch to p2</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">context_switch</span><span style=\"color:#E1E4E8\">(p1, p2);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// If we get here, switch worked</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-4-tss-structure-and-initialization-2-3-hours\">Phase 4: TSS Structure and Initialization (2-3 hours)</h3>\n<p><strong>Files:</strong> tss/tss.h, tss/tss.c</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Define <code>tss_t</code> structure</li>\n<li>Declare <code>kernel_tss</code> global</li>\n<li>Implement <code>tss_init()</code> to zero and configure TSS</li>\n<li>Add TSS descriptor to GDT</li>\n<li>Load TR with TSS selector</li>\n</ol>\n<p><strong>Checkpoint:</strong> TSS loaded, TR valid.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">tss_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// In QEMU monitor: info registers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Should show TR = 0x30</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(kernel_tss.ss0 </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-5-tss-esp0-update-1-2-hours\">Phase 5: TSS ESP0 Update (1-2 hours)</h3>\n<p><strong>Files:</strong> tss/tss.c (update)</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Implement <code>tss_update_esp0()</code></li>\n<li>Integrate into context switch</li>\n<li>Verify ESP0 changes on switch</li>\n</ol>\n<p><strong>Checkpoint:</strong> ESP0 updated on every context switch.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> old_esp0 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> tss_get_esp0</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">context_switch</span><span style=\"color:#E1E4E8\">(p1, p2);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> new_esp0 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> tss_get_esp0</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(new_esp0 </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> p2</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">kernel_stack_top</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(new_esp0 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> old_esp0);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-6-round-robin-scheduler-3-4-hours\">Phase 6: Round-Robin Scheduler (3-4 hours)</h3>\n<p><strong>Files:</strong> scheduler/scheduler.h, scheduler/scheduler.c</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Implement <code>scheduler_init()</code></li>\n<li>Implement <code>scheduler_add_process()</code></li>\n<li>Implement <code>scheduler_remove_process()</code></li>\n<li>Implement <code>scheduler_pick_next()</code></li>\n<li>Test with manually created processes</li>\n</ol>\n<p><strong>Checkpoint:</strong> Scheduler picks next process correctly.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">scheduler_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(func1, </span><span style=\"color:#9ECBFF\">\"p1\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(func2, </span><span style=\"color:#9ECBFF\">\"p2\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">next </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> scheduler_pick_next</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(next </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> p1);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">current_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> p1;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">next </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> scheduler_pick_next</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(next </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> p2);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-7-timer-interrupt-scheduler-hook-2-3-hours\">Phase 7: Timer Interrupt Scheduler Hook (2-3 hours)</h3>\n<p><strong>Files:</strong> scheduler/scheduler.c (update), timer/timer.c (update)</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Add time slice field to process_t</li>\n<li>Implement <code>scheduler_timer_tick()</code></li>\n<li>Hook into timer interrupt handler</li>\n<li>Test preemption</li>\n</ol>\n<p><strong>Checkpoint:</strong> Timer triggers context switch.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Create processes, enable interrupts</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(func1, </span><span style=\"color:#9ECBFF\">\"p1\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(func2, </span><span style=\"color:#9ECBFF\">\"p2\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">__asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">sti</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Wait for timer interrupt</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Should have switched processes</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-8-user-page-directory-creation-3-4-hours\">Phase 8: User Page Directory Creation (3-4 hours)</h3>\n<p><strong>Files:</strong> user/user_memory.h, user/user_memory.c</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Implement <code>user_create_page_directory()</code></li>\n<li>Implement <code>user_map_code()</code></li>\n<li>Implement <code>user_map_stack()</code></li>\n<li>Verify kernel pages are supervisor-only</li>\n</ol>\n<p><strong>Checkpoint:</strong> User page directory created with isolation.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> pd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> user_create_page_directory</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(pd </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Check that kernel entries don't have PAGE_USER</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)pd;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 768</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (p->entries[i] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PAGE_PRESENT) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(p->entries[i] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PAGE_USER));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-9-jump-to-user-mode-3-4-hours\">Phase 9: Jump to User Mode (3-4 hours)</h3>\n<p><strong>Files:</strong> user/user_mode.h, user/user_mode.asm</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Write assembly <code>jump_to_user_mode()</code></li>\n<li>Set up iret stack frame</li>\n<li>Test with simple user function</li>\n<li>Verify CPL=3 after jump</li>\n</ol>\n<p><strong>Checkpoint:</strong> CPU enters ring 3.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Create user process with entry at 0x1000</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">user </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create_user</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"user_test\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">current_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> user;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">jump_to_user_mode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, user</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">user_stack_top</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Should be executing in ring 3 now</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-10-system-call-handler-3-4-hours\">Phase 10: System Call Handler (3-4 hours)</h3>\n<p><strong>Files:</strong> syscall/syscall.h, syscall/syscall.c, syscall/syscall.asm</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Implement syscall entry assembly (isr128)</li>\n<li>Implement syscall table</li>\n<li>Implement <code>syscall_handler()</code></li>\n<li>Register INT 0x80 with DPL=3</li>\n</ol>\n<p><strong>Checkpoint:</strong> Syscall from user mode works.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In user mode:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">__asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#9ECBFF\">int $0x80</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=a</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(result)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">a</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(SYS_GETPID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// result should be current PID</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-11-sys_write-and-sys_exit-implementation-2-3-hours\">Phase 11: sys_write and sys_exit Implementation (2-3 hours)</h3>\n<p><strong>Files:</strong> syscall/syscall.c (update)</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Implement <code>sys_write()</code> to VGA</li>\n<li>Implement <code>sys_exit()</code> with zombie state</li>\n<li>Test from user mode</li>\n</ol>\n<p><strong>Checkpoint:</strong> User programs can output and exit.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In user mode:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">msg </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"Hello from user!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sys_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, msg, </span><span style=\"color:#79B8FF\">17</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sys_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Should print message and terminate</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"phase-12-multi-process-demo-2-3-hours\">Phase 12: Multi-Process Demo (2-3 hours)</h3>\n<p><strong>Files:</strong> main.c (update)</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Create three kernel processes</li>\n<li>Each prints to different screen region</li>\n<li>Verify preemptive multitasking</li>\n<li>Verify processes don&#39;t corrupt each other</li>\n</ol>\n<p><strong>Checkpoint:</strong> Three processes run concurrently.</p>\n<p><strong>Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> proc_a</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> col </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_putc_at</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, col</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'A'</span><span style=\"color:#E1E4E8\">, VGA_COLOR_GREEN);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (col </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 80</span><span style=\"color:#E1E4E8\">) col </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> proc_b</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span><span style=\"color:#6A737D\"> /* similar */</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> proc_c</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span><span style=\"color:#6A737D\"> /* similar */</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">process_create</span><span style=\"color:#E1E4E8\">(proc_a, </span><span style=\"color:#9ECBFF\">\"proc_a\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">process_create</span><span style=\"color:#E1E4E8\">(proc_b, </span><span style=\"color:#9ECBFF\">\"proc_b\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">process_create</span><span style=\"color:#E1E4E8\">(proc_c, </span><span style=\"color:#9ECBFF\">\"proc_c\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">__asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">sti</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Should see A, B, C appearing in different rows</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"test-specification\">Test Specification</h2>\n<h3 id=\"test-process-creation\">Test: Process Creation</h3>\n<p><strong>Setup:</strong> Process table empty</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Create process</li>\n<li>Verify PID assigned</li>\n<li>Verify state is READY</li>\n<li>Verify stack allocated</li>\n<li>Verify CPU state initialized</li>\n</ol>\n<p><strong>Expected:</strong> Process valid and ready</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(test_func, </span><span style=\"color:#9ECBFF\">\"test\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(p </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(p</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">pid </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(p</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PROCESS_STATE_READY);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(p</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">kernel_stack </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(p</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">kernel_stack_top </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> p</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">kernel_stack </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> KERNEL_STACK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(p</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">cpu.eip </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">test_func</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(p</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">cpu.cs </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(p</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">cpu.eflags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // IF set</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-context-switch-preserves-state\">Test: Context Switch Preserves State</h3>\n<p><strong>Setup:</strong> Two processes created</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Set register values in process A</li>\n<li>Switch to process B</li>\n<li>Switch back to process A</li>\n<li>Verify registers preserved</li>\n</ol>\n<p><strong>Expected:</strong> All registers match</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pa </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(func_a, </span><span style=\"color:#9ECBFF\">\"a\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pb </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(func_b, </span><span style=\"color:#9ECBFF\">\"b\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Set some state in pa</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">pa</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">cpu.eax </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">12345678</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">pa</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">cpu.ebx </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">DEADBEEF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">current_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pa;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">context_switch</span><span style=\"color:#E1E4E8\">(pa, pb);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ... in pb ...</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">context_switch</span><span style=\"color:#E1E4E8\">(pb, pa);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Back in pa, verify state</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(pa</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">cpu.eax </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">12345678</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(pa</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">cpu.ebx </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">DEADBEEF</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-tss-esp0-updated\">Test: TSS ESP0 Updated</h3>\n<p><strong>Setup:</strong> TSS initialized</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Get current ESP0</li>\n<li>Switch to process with different kernel stack</li>\n<li>Verify ESP0 changed</li>\n</ol>\n<p><strong>Expected:</strong> ESP0 matches new process</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> old_esp0 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> kernel_tss.esp0;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(func1, </span><span style=\"color:#9ECBFF\">\"p1\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(func2, </span><span style=\"color:#9ECBFF\">\"p2\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">current_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> p1;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">context_switch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, p1);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(kernel_tss.esp0 </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> p1</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">kernel_stack_top</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">context_switch</span><span style=\"color:#E1E4E8\">(p1, p2);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(kernel_tss.esp0 </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> p2</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">kernel_stack_top</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(kernel_tss.esp0 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> old_esp0);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-round-robin-scheduling\">Test: Round-Robin Scheduling</h3>\n<p><strong>Setup:</strong> Three processes in ready queue</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Pick next process</li>\n<li>Verify it&#39;s different from current</li>\n<li>Repeat, verify round-robin order</li>\n</ol>\n<p><strong>Expected:</strong> Processes scheduled in order</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(f1, </span><span style=\"color:#9ECBFF\">\"p1\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(f2, </span><span style=\"color:#9ECBFF\">\"p2\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(f3, </span><span style=\"color:#9ECBFF\">\"p3\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">current_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> p1;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">p1</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PROCESS_STATE_RUNNING;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">next </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> scheduler_pick_next</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(next </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> p2);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">current_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> p2;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">next </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> scheduler_pick_next</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(next </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> p3);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">current_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> p3;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">next </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> scheduler_pick_next</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(next </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> p1);</span><span style=\"color:#6A737D\">  // Wraps around</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-timer-triggers-context-switch\">Test: Timer Triggers Context Switch</h3>\n<p><strong>Setup:</strong> Two processes, timer enabled</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Start in process A</li>\n<li>Enable timer interrupt</li>\n<li>Wait for multiple ticks</li>\n<li>Verify process B runs</li>\n</ol>\n<p><strong>Expected:</strong> Both processes execute</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> a_ran </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, b_ran </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> proc_a</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    a_ran </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) { }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> proc_b</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b_ran </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) { }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">process_create</span><span style=\"color:#E1E4E8\">(proc_a, </span><span style=\"color:#9ECBFF\">\"a\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">process_create</span><span style=\"color:#E1E4E8\">(proc_b, </span><span style=\"color:#9ECBFF\">\"b\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">__asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">sti</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(a_ran </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#FFAB70\"> b_ran</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-user-mode-isolation\">Test: User Mode Isolation</h3>\n<p><strong>Setup:</strong> User process with own page directory</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Create user process</li>\n<li>Switch to its page directory</li>\n<li>Try to access kernel memory</li>\n<li>Verify page fault</li>\n</ol>\n<p><strong>Expected:</strong> Page fault on kernel access</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In user process:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">kernel_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">C0100000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">kernel_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 42</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Should page fault</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// User bit not set on kernel pages</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-system-call-from-user-mode\">Test: System Call from User Mode</h3>\n<p><strong>Setup:</strong> User process, syscalls registered</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Execute INT 0x80 from user mode</li>\n<li>Verify handler called</li>\n<li>Verify return value correct</li>\n</ol>\n<p><strong>Expected:</strong> Syscall executes and returns</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In user process:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> pid;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">__asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#9ECBFF\">int $0x80</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=a</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(pid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">a</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(SYS_GETPID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(pid </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"test-multi-process-concurrent-execution\">Test: Multi-Process Concurrent Execution</h3>\n<p><strong>Setup:</strong> Three kernel processes</p>\n<p><strong>Steps:</strong></p>\n<ol>\n<li>Create three processes</li>\n<li>Each increments a counter</li>\n<li>Let them run for some time</li>\n<li>Verify all counters increased</li>\n</ol>\n<p><strong>Expected:</strong> All processes executed</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#FFAB70\"> counters</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> proc0</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#FFAB70\">counters</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> proc1</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#FFAB70\">counters</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> proc2</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#FFAB70\">counters</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">process_create</span><span style=\"color:#E1E4E8\">(proc0, </span><span style=\"color:#9ECBFF\">\"p0\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">process_create</span><span style=\"color:#E1E4E8\">(proc1, </span><span style=\"color:#9ECBFF\">\"p1\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">process_create</span><span style=\"color:#E1E4E8\">(proc2, </span><span style=\"color:#9ECBFF\">\"p2\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">__asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">sti</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">counters</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">counters</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">counters</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-targets\">Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Target</th>\n<th>How to Measure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Context switch</td>\n<td>&lt; 5 µs</td>\n<td>RDTSC before/after context_switch()</td>\n</tr>\n<tr>\n<td>Scheduler decision</td>\n<td>&lt; 1 µs</td>\n<td>RDTSC before/after scheduler_pick_next()</td>\n</tr>\n<tr>\n<td>Syscall entry</td>\n<td>&lt; 2 µs</td>\n<td>RDTSC before INT 0x80 to handler entry</td>\n</tr>\n<tr>\n<td>User mode entry</td>\n<td>&lt; 3 µs</td>\n<td>RDTSC before jump_to_user_mode to user code</td>\n</tr>\n<tr>\n<td>Timer handler (with scheduling)</td>\n<td>&lt; 10 µs</td>\n<td>RDTSC at timer entry/exit</td>\n</tr>\n<tr>\n<td>CR3 reload + TLB flush</td>\n<td>~100-500 cycles</td>\n<td>Part of context switch</td>\n</tr>\n</tbody></table>\n<p><strong>Measurement Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#B392F0\"> rdtsc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> lo, hi;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">rdtsc</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=a</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(lo), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(hi));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)hi </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> lo;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> benchmark_context_switch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(idle_func, </span><span style=\"color:#9ECBFF\">\"p1\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(idle_func, </span><span style=\"color:#9ECBFF\">\"p2\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> rdtsc</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    context_switch</span><span style=\"color:#E1E4E8\">(p1, p2);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> rdtsc</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Context switch: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> cycles</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)(end </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"hardware-soul\">Hardware Soul</h2>\n<h3 id=\"cache-behavior\">Cache Behavior</h3>\n<table>\n<thead>\n<tr>\n<th>Structure</th>\n<th>Size</th>\n<th>Cache Lines</th>\n<th>Access Pattern</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PCB (cpu_state_t)</td>\n<td>60 bytes</td>\n<td>1</td>\n<td>Sequential save/restore</td>\n</tr>\n<tr>\n<td>Process table</td>\n<td>~1.6KB</td>\n<td>25</td>\n<td>Linear scan for free slot</td>\n</tr>\n<tr>\n<td>TSS</td>\n<td>104 bytes</td>\n<td>2</td>\n<td>Read-only after init (except ESP0)</td>\n</tr>\n<tr>\n<td>Ready queue</td>\n<td>4 bytes per link</td>\n<td>1</td>\n<td>Linear traversal</td>\n</tr>\n</tbody></table>\n<p><strong>Optimization Notes:</strong></p>\n<ul>\n<li>PCB fits in single cache line - optimal for context switch</li>\n<li>Process table scan is prefetch-friendly</li>\n<li>TSS ESP0 update touches only 4 bytes</li>\n</ul>\n<h3 id=\"branch-prediction\">Branch Prediction</h3>\n<table>\n<thead>\n<tr>\n<th>Code Path</th>\n<th>Predictability</th>\n<th>Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Context switch register save</td>\n<td>High (sequential stores)</td>\n<td>Minimal</td>\n</tr>\n<tr>\n<td>Scheduler queue traversal</td>\n<td>Medium (depends on queue length)</td>\n<td>Low overhead</td>\n</tr>\n<tr>\n<td>Syscall dispatch (switch)</td>\n<td>Low (depends on syscall number)</td>\n<td>Table lookup is fast</td>\n</tr>\n<tr>\n<td>Process state check</td>\n<td>Medium (usually READY)</td>\n<td>Minimal</td>\n</tr>\n</tbody></table>\n<h3 id=\"tlb-behavior\">TLB Behavior</h3>\n<p><strong>CRITICAL:</strong> CR3 reload on context switch flushes all non-global TLB entries.</p>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>TLB Entries Lost</th>\n<th>Performance Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Same process (no CR3 reload)</td>\n<td>0</td>\n<td>Minimal</td>\n</tr>\n<tr>\n<td>Different process, shared kernel</td>\n<td>User entries only</td>\n<td>Moderate</td>\n</tr>\n<tr>\n<td>Different process, different kernel</td>\n<td>All entries</td>\n<td>High (~300 cycles)</td>\n</tr>\n</tbody></table>\n<p><strong>Optimization Strategy:</strong></p>\n<ul>\n<li>Mark kernel pages as global (PAGE_GLOBAL flag)</li>\n<li>Use <code>invlpg</code> for single-page invalidation when possible</li>\n<li>Consider 4MB pages for kernel to reduce TLB pressure</li>\n</ul>\n<h3 id=\"simd-considerations\">SIMD Considerations</h3>\n<p>Context switch does NOT save FPU/SSE/AVX state. If kernel or processes use SIMD:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Lazy FPU save/restore (future optimization)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CR0_MP</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CR0_TS</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> enable_fpu_lazy_save</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> cr0;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %%cr0, %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(cr0));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cr0 </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> CR0_MP </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CR0_TS;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %0, %%cr0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(cr0));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Device-not-available handler (exception 7)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> fpu_switch_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Save old FPU state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (last_fpu_process) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">fnsave %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=m</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(last_fpu_process->fpu_state));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Restore new FPU state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">frstor %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">m</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(current_process->fpu_state));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Clear TS bit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> cr0;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    __asm__</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %%cr0, %0 ; clts</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(cr0));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"memory-access-patterns\">Memory Access Patterns</h3>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Pattern</th>\n<th>Cache Friendliness</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PCB save</td>\n<td>Sequential write</td>\n<td>Excellent</td>\n</tr>\n<tr>\n<td>PCB restore</td>\n<td>Sequential read</td>\n<td>Excellent</td>\n</tr>\n<tr>\n<td>Ready queue walk</td>\n<td>Pointer chase</td>\n<td>Poor (but short)</td>\n</tr>\n<tr>\n<td>Syscall dispatch</td>\n<td>Random (table index)</td>\n<td>Good (small table)</td>\n</tr>\n<tr>\n<td>User stack access</td>\n<td>Process-specific</td>\n<td>Depends on working set</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"visual-diagrams\">Visual Diagrams</h2>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-027.svg\" alt=\"Process Control Block: Saved State Layout\"></p>\n<p>PCB structure with cpu_state_t fields and offsets</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-028.svg\" alt=\"Context Switch: Save Old → Load New\"></p>\n<p>Context switch flow: save old → load new → resume</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-029.svg\" alt=\"TSS Structure and ESP0 for Ring Transitions\"></p>\n<p>TSS structure and ESP0 role in ring transitions</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-030.svg\" alt=\"Round-Robin Scheduler Ready Queue\"></p>\n<p>Round-robin scheduler: circular queue traversal</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-031.svg\" alt=\"Timer Interrupt to Context Switch Sequence\"></p>\n<p>Timer interrupt → scheduler → context switch sequence</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-032.svg\" alt=\"User vs Kernel Page Directories\"></p>\n<p>User vs kernel page directories: isolation boundaries</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-033.svg\" alt=\"Jump to User Mode: Stack Setup for iret\"></p>\n<p>iret stack frame for user mode entry</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-034.svg\" alt=\"System Call: INT 0x80 Entry and Exit\"></p>\n<p>INT 0x80 syscall flow: user → kernel → user</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-035.svg\" alt=\"Multi-Process Demo: Three Concurrent Processes\"></p>\n<p>Process lifecycle state machine</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Ftdd-diag-036.svg\" alt=\"Process Management Module Architecture\"></p>\n<p>Multi-process demo: three processes printing concurrently</p>\n<hr>\n<p>[[CRITERIA_JSON: {&quot;module_id&quot;: &quot;build-os-m4&quot;, &quot;criteria&quot;: [&quot;Process control block (PCB) stores PID, register state (EIP, ESP, EBP, general-purpose registers, EFLAGS), page directory pointer (CR3), process state (ready/running/blocked), and kernel stack pointer&quot;, &quot;Context switch saves current process registers to its PCB and loads the next process&#39;s registers using assembly implementation for correctness&quot;, &quot;TSS (Task State Segment) configured with kernel stack pointer (SS0:ESP0) so CPU knows which stack to use for ring 3 to ring 0 transitions&quot;, &quot;Timer interrupt (IRQ0) triggers scheduler which selects next ready process in round-robin order and performs context switch&quot;, &quot;At least 3 kernel-mode processes run concurrently each printing to different screen region demonstrating preemptive multitasking&quot;, &quot;User-mode processes run in ring 3 with own page directory; accessing kernel memory triggers page fault due to supervisor-only bit&quot;, &quot;System call interface via INT 0x80: kernel reads syscall number from EAX and arguments from EBX/ECX/EDX, implementing sys_write and sys_exit at minimum&quot;, &quot;TSS ESP0 updated on every context switch to point to current process kernel stack top&quot;]}]</p>\n<!-- END_TDD_MOD -->\n\n\n<h1 id=\"-beyond-the-atlas-further-reading\">📚 Beyond the Atlas: Further Reading</h1>\n<h2 id=\"bootloader-and-protected-mode\">Bootloader and Protected Mode</h2>\n<h3 id=\"paper\">Paper</h3>\n<p><strong>&quot;The Undocumented PC&quot;</strong> (Frank van Gilluwe, 1994) — Original research on BIOS internals, A20 gate mechanics, and x86 real-to-protected mode transitions.</p>\n<h3 id=\"code\">Code</h3>\n<p><strong>Linux 0.01 Bootloader</strong> — <code>boot/setup.S</code> and <code>boot/bootsect.S</code> in the original Linux 0.01 release. Linus Torvalds&#39; first bootloader implementation, showing the exact A20 enable and GDT setup sequence. Available at <a href=\"https://github.com/mirrors/linux-0.01\">https://github.com/mirrors/linux-0.01</a></p>\n<h3 id=\"best-explanation\">Best Explanation</h3>\n<p><strong>OSDev Wiki: &quot;A20 Line&quot;</strong> — <a href=\"https://wiki.osdev.org/A20_Line\">https://wiki.osdev.org/A20_Line</a> — The definitive practical guide with working code for all three A20 enable methods (fast A20, keyboard controller, BIOS).</p>\n<h3 id=\"why\">Why</h3>\n<p>OSDev combines historical context (why the A20 gate exists) with working code snippets tested across emulators and real hardware.</p>\n<hr>\n<h2 id=\"x86-segmentation-and-gdt\">x86 Segmentation and GDT</h2>\n<h3 id=\"spec\">Spec</h3>\n<p><strong>Intel 64 and IA-32 Architectures Software Developer&#39;s Manual, Volume 3A</strong> — Chapter 3 &quot;Protected-Mode Memory Management&quot; — Official specification of segment descriptors, GDT layout, and the flat memory model.</p>\n<h3 id=\"code\">Code</h3>\n<p><strong>xv6 GDT Setup</strong> — <code>xv6-public/bootmain.c</code> and <code>mp.c</code> — MIT&#39;s teaching OS shows minimal GDT configuration with exactly 5 entries. <a href=\"https://github.com/mit-pdos/xv6-public\">https://github.com/mit-pdos/xv6-public</a></p>\n<h3 id=\"best-explanation\">Best Explanation</h3>\n<p><strong>&quot;GDT Tutorial&quot; by BrokenThorn</strong> — <a href=\"https://wiki.osdev.org/Global_Descriptor_Table\">https://wiki.osdev.org/Global_Descriptor_Table</a> — Byte-by-byte breakdown of each GDT entry field with worked examples.</p>\n<h3 id=\"why\">Why</h3>\n<p>Breaks down the legacy x86 descriptor format into digestible pieces with visual diagrams showing bit positions.</p>\n<hr>\n<h2 id=\"interrupts-and-idt\">Interrupts and IDT</h2>\n<h3 id=\"spec\">Spec</h3>\n<p><strong>Intel 64 and IA-32 Architectures Software Developer&#39;s Manual, Volume 3A</strong> — Chapter 6 &quot;Interrupt and Exception Handling&quot; — Official specification of IDT gate descriptors, interrupt stack frames, and exception error codes.</p>\n<h3 id=\"code\">Code</h3>\n<p><strong>xv6 Interrupt Handling</strong> — <code>xv6-public/trapasm.S</code> and <code>trap.c</code> — Clean implementation of the assembly stub → C handler pattern with proper register save/restore. <a href=\"https://github.com/mit-pdos/xv6-public\">https://github.com/mit-pdos/xv6-public</a></p>\n<h3 id=\"best-explanation\">Best Explanation</h3>\n<p><strong>&quot;Interrupts&quot; chapter in &quot;Operating Systems: Three Easy Pieces&quot;</strong> (Remzi Arpaci-Dusseau and Andrea Arpaci-Dusseau) — Free at <a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/\">https://pages.cs.wisc.edu/~remzi/OSTEP/</a> — Chapter 6 explains the conceptual model before diving into x86 specifics.</p>\n<h3 id=\"why\">Why</h3>\n<p>Builds intuition about <em>why</em> interrupts exist (hardware asynchrony) before the <em>how</em> (IDT gates, stack frames).</p>\n<hr>\n<h2 id=\"8259-pic-programming\">8259 PIC Programming</h2>\n<h3 id=\"spec\">Spec</h3>\n<p><strong>8259A Programmable Interrupt Controller Datasheet</strong> — Original Intel datasheet specifying ICW1-4 initialization sequence and EOI commands.</p>\n<h3 id=\"code\">Code</h3>\n<p><strong>Linux 0.01 PIC Remapping</strong> — <code>kernel/irq.c</code> in Linux 0.01 — Shows the exact ICW sequence used in a real OS. <a href=\"https://github.com/mirrors/linux-0.01\">https://github.com/mirrors/linux-0.01</a></p>\n<h3 id=\"best-explanation\">Best Explanation</h3>\n<p><strong>OSDev Wiki: &quot;8259 PIC&quot;</strong> — <a href=\"https://wiki.osdev.org/8259_PIC\">https://wiki.osdev.org/8259_PIC</a> — Complete initialization sequence with code for remapping IRQs to vectors 32-47.</p>\n<h3 id=\"why\">Why</h3>\n<p>The PIC datasheet is dense; OSDev extracts just the initialization sequence needed for modern OS development.</p>\n<hr>\n<h2 id=\"physical-memory-management\">Physical Memory Management</h2>\n<h3 id=\"code\">Code</h3>\n<p><strong>Linux 2.4 Buddy Allocator</strong> — <code>mm/page_alloc.c</code> — The classic buddy system implementation for physical page allocation. See <code>__alloc_pages()</code> function. <a href=\"https://elixir.bootlin.com/linux/v2.4.0/source/mm/page_alloc.c\">https://elixir.bootlin.com/linux/v2.4.0/source/mm/page_alloc.c</a></p>\n<h3 id=\"best-explanation\">Best Explanation</h3>\n<p><strong>&quot;The Slab Allocator&quot; by Bonwick (USENIX 1994)</strong> — While focused on the slab allocator, Section 2 explains the buddy system it builds upon. <a href=\"https://www.usenix.org/legacy/publications/library/proceedings/bos94/full_papers/bonwick.a\">https://www.usenix.org/legacy/publications/library/proceedings/bos94/full_papers/bonwick.a</a></p>\n<h3 id=\"why\">Why</h3>\n<p>Jeff Bonwick&#39;s paper is the clearest explanation of why simple bitmap allocators don&#39;t scale and how kernel memory allocators evolved.</p>\n<hr>\n<h2 id=\"virtual-memory-and-page-tables\">Virtual Memory and Page Tables</h2>\n<h3 id=\"paper\">Paper</h3>\n<p><strong>&quot;Organization of Intel Memory Management Units&quot;</strong> (Intel, 1990) — Original documentation of the two-level page table hierarchy introduced with the 80386.</p>\n<h3 id=\"spec\">Spec</h3>\n<p><strong>Intel 64 and IA-32 Architectures Software Developer&#39;s Manual, Volume 3A</strong> — Chapter 4 &quot;Paging&quot; — Official specification of PDE/PTE formats, CR3, and TLB behavior.</p>\n<h3 id=\"code\">Code</h3>\n<p><strong>xv6 Page Table Management</strong> — <code>xv6-public/vm.c</code> — Clean implementation of page directory creation, page mapping, and address translation. <a href=\"https://github.com/mit-pdos/xv6-public\">https://github.com/mit-pdos/xv6-public</a></p>\n<h3 id=\"best-explanation\">Best Explanation</h3>\n<p><strong>Chapter 3 &quot;Address Translation&quot; in &quot;Computer Systems: A Programmer&#39;s Perspective&quot; (Bryant &amp; O&#39;Hallaron)</strong> — Section 3.6 builds page tables from first principles with visual diagrams of the translation process.</p>\n<h3 id=\"why\">Why</h3>\n<p>CSAPP builds intuition with simplified examples before showing the full x86 complexity.</p>\n<hr>\n<h2 id=\"tlb-management\">TLB Management</h2>\n<h3 id=\"spec\">Spec</h3>\n<p><strong>Intel 64 and IA-32 Architectures Software Developer&#39;s Manual, Volume 3A</strong> — Section 4.10 &quot;Translation Lookaside Buffers (TLBs)&quot; — Official specification of <code>invlpg</code>, CR3 reload behavior, and global pages.</p>\n<h3 id=\"best-explanation\">Best Explanation</h3>\n<p><strong>&quot;What Every Programmer Should Know About Memory&quot; by Ulrich Drepper</strong> — Section 4.3 covers TLB structure, miss penalties, and the impact of TLB flushes on context switches. <a href=\"https://people.freebsd.org/~lstewart/articles/cpumemory.pdf\">https://people.freebsd.org/~lstewart/articles/cpumemory.pdf</a></p>\n<h3 id=\"why\">Why</h3>\n<p>Drepper&#39;s paper connects hardware TLB behavior to real performance consequences with benchmarks.</p>\n<hr>\n<h2 id=\"page-faults-and-demand-paging\">Page Faults and Demand Paging</h2>\n<h3 id=\"paper\">Paper</h3>\n<p><strong>&quot;The Design and Implementation of a Paging System with Normalized Physical Addressing&quot;</strong> (Dennis, 1965) — Original research on virtual memory and demand paging.</p>\n<h3 id=\"code\">Code</h3>\n<p><strong>Linux 4.x Page Fault Handler</strong> — <code>arch/x86/mm/fault.c</code> — <code>do_page_fault()</code> function shows production-grade handling including demand paging, COW, and stack expansion. <a href=\"https://elixir.bootlin.com/linux/v4.0/source/arch/x86/mm/fault.c\">https://elixir.bootlin.com/linux/v4.0/source/arch/x86/mm/fault.c</a></p>\n<h3 id=\"best-explanation\">Best Explanation</h3>\n<p><strong>&quot;Page Replacement Algorithms&quot; chapter in &quot;Operating Systems: Three Easy Pieces&quot;</strong> — <a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/vm-beyondphys.pdf\">https://pages.cs.wisc.edu/~remzi/OSTEP/vm-beyondphys.pdf</a> — Builds intuition for why page faults enable virtual memory abstraction.</p>\n<h3 id=\"why\">Why</h3>\n<p>OSTEP explains the <em>concept</em> of demand paging before Linux source shows the <em>implementation</em>.</p>\n<hr>\n<h2 id=\"kernel-heap-allocation\">Kernel Heap Allocation</h2>\n<h3 id=\"paper\">Paper</h3>\n<p><strong>&quot;Design and Implementation of a Kernel Memory Allocator&quot;</strong> (Mckusick &amp; Karels, 1988) — Original research on the Berkeley Software Distribution kernel memory allocator.</p>\n<h3 id=\"code\">Code</h3>\n<p><strong>Linux 2.x kmalloc</strong> — <code>mm/slab.c</code> — The slab allocator implementation backing <code>kmalloc()</code>. <a href=\"https://elixir.bootlin.com/linux/v2.4.0/source/mm/slab.c\">https://elixir.bootlin.com/linux/v2.4.0/source/mm/slab.c</a></p>\n<h3 id=\"best-explanation\">Best Explanation</h3>\n<p><strong>&quot;The Slab Allocator: An Object-Caching Kernel Memory Allocator&quot; by Bonwick (USENIX 1994)</strong> — <a href=\"https://www.usenix.org/legacy/publications/library/proceedings/bos94/full_papers/bonwick.a\">https://www.usenix.org/legacy/publications/library/proceedings/bos94/full_papers/bonwick.a</a></p>\n<h3 id=\"why\">Why</h3>\n<p>Bonwick explains the transition from simple first-fit allocators to object-caching allocators with clear performance analysis.</p>\n<hr>\n<h2 id=\"process-control-and-context-switching\">Process Control and Context Switching</h2>\n<h3 id=\"paper\">Paper</h3>\n<p><strong>&quot;Process Structuring in the THE Multiprogramming System&quot;</strong> (Dijkstra, 1968) — Original research establishing the process concept and semaphores for synchronization.</p>\n<h3 id=\"code\">Code</h3>\n<p><strong>xv6 Context Switch</strong> — <code>xv6-public/swtch.S</code> — Minimal assembly context switch (30 lines) showing register save/restore pattern. <a href=\"https://github.com/mit-pdos/xv6-public\">https://github.com/mit-pdos/xv6-public</a></p>\n<h3 id=\"best-explanation\">Best Explanation</h3>\n<p><strong>&quot;Processes&quot; chapter in &quot;Operating Systems: Three Easy Pieces&quot;</strong> — <a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf\">https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf</a> — Chapter 4 builds the mental model of process as &quot;a abstraction for a running program.&quot;</p>\n<h3 id=\"why\">Why</h3>\n<p>OSTEP separates the <em>concept</em> (process abstraction) from the <em>mechanics</em> (register save/restore), which xv6 code demonstrates.</p>\n<hr>\n<h2 id=\"task-state-segment\">Task State Segment</h2>\n<h3 id=\"spec\">Spec</h3>\n<p><strong>Intel 64 and IA-32 Architectures Software Developer&#39;s Manual, Volume 3A</strong> — Chapter 7 &quot;Task Management&quot; — Official specification of TSS structure, TR register, and privilege level transitions.</p>\n<h3 id=\"code\">Code</h3>\n<p><strong>Linux 0.01 TSS Setup</strong> — <code>kernel/sched.c</code> — Shows TSS initialization and ESP0 update on context switch. <a href=\"https://github.com/mirrors/linux-0.01\">https://github.com/mirrors/linux-0.01</a></p>\n<h3 id=\"best-explanation\">Best Explanation</h3>\n<p><strong>OSDev Wiki: &quot;Task State Segment&quot;</strong> — <a href=\"https://wiki.osdev.org/Task_State_Segment\">https://wiki.osdev.org/Task_State_Segment</a> — Explains why modern OSes use TSS only for ESP0 despite its name suggesting full task switching.</p>\n<h3 id=\"why\">Why</h3>\n<p>Clarifies the confusing historical baggage: TSS was designed for hardware task switching, but modern OSes only use ESP0 for ring transitions.</p>\n<hr>\n<h2 id=\"round-robin-scheduling\">Round-Robin Scheduling</h2>\n<h3 id=\"paper\">Paper</h3>\n<p><strong>&quot;Scheduling Algorithms for Multiprogramming in a Hard-Real-Time Environment&quot;</strong> (Liu &amp; Layland, 1973) — Original research on scheduling theory, including round-robin analysis.</p>\n<h3 id=\"code\">Code</h3>\n<p><strong>Linux 2.4 O(1) Scheduler</strong> — <code>kernel/sched.c</code> — Production scheduler showing priority arrays, time slices, and context switch integration. <a href=\"https://elixir.bootlin.com/linux/v2.4.0/source/kernel/sched.c\">https://elixir.bootlin.com/linux/v2.4.0/source/kernel/sched.c</a></p>\n<h3 id=\"best-explanation\">Best Explanation</h3>\n<p><strong>&quot;Scheduling: Introduction&quot; chapter in &quot;Operating Systems: Three Easy Pieces&quot;</strong> — <a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched.pdf\">https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched.pdf</a> — Chapter 7 builds scheduling metrics (turnaround, response) then evaluates round-robin.</p>\n<h3 id=\"why\">Why</h3>\n<p>OSTEP explains <em>why</em> round-robin optimizes for response time, not just <em>how</em> to implement a circular queue.</p>\n<hr>\n<h2 id=\"user-kernel-mode-transitions\">User-Kernel Mode Transitions</h2>\n<h3 id=\"spec\">Spec</h3>\n<p><strong>Intel 64 and IA-32 Architectures Software Developer&#39;s Manual, Volume 3A</strong> — Section 5.8 &quot;Privilege Levels&quot; and Section 5.12 &quot;Procedure Calls and Privilege Checking&quot; — Official specification of CPL, DPL, gate descriptors, and <code>iret</code> semantics.</p>\n<h3 id=\"code\">Code</h3>\n<p><strong>xv6 User Mode Entry</strong> — <code>xv6-public/userinit()</code> in <code>proc.c</code> and the <code>trapret</code> label in <code>trapasm.S</code> — Shows stack setup for <code>iret</code> to user mode. <a href=\"https://github.com/mit-pdos/xv6-public\">https://github.com/mit-pdos/xv6-public</a></p>\n<h3 id=\"best-explanation\">Best Explanation</h3>\n<p><strong>&quot;Privilege Rings&quot; on OSDev Wiki</strong> — <a href=\"https://wiki.osdev.org/Security#Rings\">https://wiki.osdev.org/Security#Rings</a> — Explains ring 0/3 transitions with focus on the stack switch performed by CPU.</p>\n<h3 id=\"why\">Why</h3>\n<p>Connects hardware privilege levels to software security model (kernel vs user space).</p>\n<hr>\n<h2 id=\"system-calls\">System Calls</h2>\n<h3 id=\"paper\">Paper</h3>\n<p><strong>&quot;On the Design of Specialized Processors&quot;</strong> (Dijkstra, 1968) — Early work establishing the concept of controlled entry points between privilege domains.</p>\n<h3 id=\"code\">Code</h3>\n<p><strong>Linux 0.01 Syscall Handler</strong> — <code>kernel/sys.c</code> and <code>sys_call</code> in <code>sys.h</code> — Shows INT 0x80 dispatch and register convention. <a href=\"https://github.com/mirrors/linux-0.01\">https://github.com/mirrors/linux-0.01</a></p>\n<h3 id=\"best-explanation\">Best Explanation</h3>\n<p><strong>&quot;Systems Calls&quot; chapter in &quot;Operating Systems: Three Easy Pieces&quot;</strong> — <a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-mechanisms.pdf\">https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-mechanisms.pdf</a> — Chapter 6 explains user/kernel transitions before x86 specifics.</p>\n<h3 id=\"why\">Why</h3>\n<p>OSTEP establishes the abstraction (protected control transfer) before the implementation (INT instruction, IDT gate).</p>\n<hr>\n<h2 id=\"process-isolation-via-page-tables\">Process Isolation via Page Tables</h2>\n<h3 id=\"paper\">Paper</h3>\n<p><strong>&quot;Multics Virtual Memory&quot;</strong> (Organick, 1972) — Original research on per-process address spaces and memory isolation.</p>\n<h3 id=\"code\">Code</h3>\n<p><strong>Linux 4.x <code>mm/mmap.c</code></strong> — <code>mmap_region()</code> function shows how the kernel isolates process address spaces during memory mapping. <a href=\"https://elixir.bootlin.com/linux/v4.0/source/mm/mmap.c\">https://elixir.bootlin.com/linux/v4.0/source/mm/mmap.c</a></p>\n<h3 id=\"best-explanation\">Best Explanation</h3>\n<p><strong>&quot;Address Spaces&quot; chapter in &quot;Operating Systems: Three Easy Pieces&quot;</strong> — <a href=\"https://pages.cs.wisc.edu/~remzi/OSTEP/vm-addressspaces.pdf\">https://pages.cs.wisc.edu/~remzi/OSTEP/vm-addressspaces.pdf</a> — Chapter 13 explains the goal (isolation) before the mechanism (per-process page tables).</p>\n<h3 id=\"why\">Why</h3>\n<p>Makes clear why each process needs its own page directory (CR3), which is the key insight for understanding context switch cost.</p>\n<hr>\n<h2 id=\"additional-resources\">Additional Resources</h2>\n<h3 id=\"comprehensive-os-development\">Comprehensive OS Development</h3>\n<ul>\n<li><strong>OSDev Wiki</strong> (<a href=\"https://wiki.osdev.org\">https://wiki.osdev.org</a>) — Community-maintained encyclopedia of OS development with code examples</li>\n<li><strong>&quot;Operating Systems: From 0 to 1&quot; by Doxys</strong> (<a href=\"https://tuhdo.github.io/os01/\">https://tuhdo.github.io/os01/</a>) — Free online book building a minimal OS</li>\n</ul>\n<h3 id=\"x86-architecture-reference\">x86 Architecture Reference</h3>\n<ul>\n<li><strong>Intel SDM</strong> (<a href=\"https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html\">https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html</a>) — Official x86 architecture documentation</li>\n<li><strong>AMD APM</strong> (<a href=\"https://developer.amd.com/resources/developer-guides-manuals/\">https://developer.amd.com/resources/developer-guides-manuals/</a>) — AMD&#39;s equivalent documentation with alternative explanations</li>\n</ul>\n<h3 id=\"teaching-operating-systems\">Teaching Operating Systems</h3>\n<ul>\n<li><strong>xv6</strong> (<a href=\"https://github.com/mit-pdos/xv6-public\">https://github.com/mit-pdos/xv6-public</a>) — MIT&#39;s teaching Unix clone for x86, ~6,000 lines</li>\n<li><strong>Pintos</strong> (<a href=\"https://web.stanford.edu/class/cs140/projects/pintos/pintos.html\">https://web.stanford.edu/class/cs140/projects/pintos/pintos.html</a>) — Stanford&#39;s teaching OS with structured projects</li>\n</ul>\n","toc":[{"level":1,"text":"Build Your Own OS","id":"build-your-own-os"},{"level":1,"text":"Milestone 1: Bootloader, GDT, and Kernel Entry","id":"milestone-1-bootloader-gdt-and-kernel-entry"},{"level":2,"text":"The First Breath of Your Operating System","id":"the-first-breath-of-your-operating-system"},{"level":3,"text":"The Fundamental Tension","id":"the-fundamental-tension"},{"level":2,"text":"Stage 1: The Bootloader","id":"stage-1-the-bootloader"},{"level":3,"text":"The BIOS Handoff","id":"the-bios-handoff"},{"level":3,"text":"Enabling the A20 Line","id":"enabling-the-a20-line"},{"level":3,"text":"Loading the Kernel from Disk","id":"loading-the-kernel-from-disk"},{"level":3,"text":"The GDT: Your Translation Table","id":"the-gdt-your-translation-table"},{"level":3,"text":"Entering Protected Mode","id":"entering-protected-mode"},{"level":2,"text":"Stage 2: The Kernel Entry Point","id":"stage-2-the-kernel-entry-point"},{"level":3,"text":"The Linker Script: Section Placement","id":"the-linker-script-section-placement"},{"level":3,"text":"Zeroing BSS: Your Responsibility","id":"zeroing-bss-your-responsibility"},{"level":2,"text":"Stage 3: Output Drivers","id":"stage-3-output-drivers"},{"level":3,"text":"VGA Text Mode","id":"vga-text-mode"},{"level":3,"text":"Serial Port (COM1)","id":"serial-port-com1"},{"level":3,"text":"Combined Output: kprintf","id":"combined-output-kprintf"},{"level":2,"text":"Testing in QEMU","id":"testing-in-qemu"},{"level":2,"text":"The Three-Level View: What Happens When You Call vga_putchar","id":"the-three-level-view-what-happens-when-you-call-vga_putchar"},{"level":2,"text":"Common Pitfalls and Debugging","id":"common-pitfalls-and-debugging"},{"level":2,"text":"Knowledge Cascade","id":"knowledge-cascade"},{"level":1,"text":"Milestone 2: Interrupts, Exceptions, and Keyboard","id":"milestone-2-interrupts-exceptions-and-keyboard"},{"level":2,"text":"The Heartbeat of a Reactive System","id":"the-heartbeat-of-a-reactive-system"},{"level":3,"text":"The Fundamental Tension","id":"the-fundamental-tension"},{"level":2,"text":"The Revelation: Interrupts Are Not Function Pointers","id":"the-revelation-interrupts-are-not-function-pointers"},{"level":2,"text":"Stage 1: The Interrupt Descriptor Table","id":"stage-1-the-interrupt-descriptor-table"},{"level":2,"text":"Stage 2: Interrupt Handlers and the Stack Frame","id":"stage-2-interrupt-handlers-and-the-stack-frame"},{"level":3,"text":"The Assembly Wrapper","id":"the-assembly-wrapper"},{"level":3,"text":"CPU Exception Handlers (Vectors 0-31)","id":"cpu-exception-handlers-vectors-0-31"},{"level":3,"text":"The C Handler","id":"the-c-handler"},{"level":3,"text":"Double Fault: The Last Line of Defense","id":"double-fault-the-last-line-of-defense"},{"level":2,"text":"Stage 3: Remapping the PIC","id":"stage-3-remapping-the-pic"},{"level":3,"text":"EOI Timing: Why Forgetting It Freezes the System","id":"eoi-timing-why-forgetting-it-freezes-the-system"},{"level":2,"text":"Stage 4: Timer Interrupt (IRQ0)","id":"stage-4-timer-interrupt-irq0"},{"level":2,"text":"Stage 5: PS/2 Keyboard Driver (IRQ1)","id":"stage-5-ps2-keyboard-driver-irq1"},{"level":3,"text":"Scancode to ASCII Translation","id":"scancode-to-ascii-translation"},{"level":2,"text":"Stage 6: Putting It All Together","id":"stage-6-putting-it-all-together"},{"level":2,"text":"The Three-Level View: What Happens When You Press a Key","id":"the-three-level-view-what-happens-when-you-press-a-key"},{"level":2,"text":"Hardware Soul: Interrupt Latency","id":"hardware-soul-interrupt-latency"},{"level":2,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":2,"text":"Knowledge Cascade","id":"knowledge-cascade"},{"level":1,"text":"Milestone 3: Physical and Virtual Memory Management","id":"milestone-3-physical-and-virtual-memory-management"},{"level":2,"text":"The Memory Illusion","id":"the-memory-illusion"},{"level":3,"text":"The Fundamental Tension","id":"the-fundamental-tension"},{"level":2,"text":"The Revelation: Paging Is Not Just a Lookup Table","id":"the-revelation-paging-is-not-just-a-lookup-table"},{"level":2,"text":"Stage 1: Physical Memory Map","id":"stage-1-physical-memory-map"},{"level":2,"text":"Stage 2: Physical Frame Allocator","id":"stage-2-physical-frame-allocator"},{"level":2,"text":"Stage 3: Two-Level Page Tables","id":"stage-3-two-level-page-tables"},{"level":2,"text":"Stage 4: Identity Mapping and Higher-Half Kernel","id":"stage-4-identity-mapping-and-higher-half-kernel"},{"level":3,"text":"The Mapping Strategy","id":"the-mapping-strategy"},{"level":3,"text":"The Linker Script Dance","id":"the-linker-script-dance"},{"level":2,"text":"Stage 5: Enabling Paging","id":"stage-5-enabling-paging"},{"level":3,"text":"The Assembly Transition","id":"the-assembly-transition"},{"level":2,"text":"Stage 6: TLB Management","id":"stage-6-tlb-management"},{"level":2,"text":"Stage 7: Page Fault Handler","id":"stage-7-page-fault-handler"},{"level":2,"text":"Stage 8: Kernel Heap Allocator","id":"stage-8-kernel-heap-allocator"},{"level":2,"text":"The Three-Level View: What Happens When You Access Memory","id":"the-three-level-view-what-happens-when-you-access-memory"},{"level":2,"text":"Hardware Soul: TLB Miss Penalty","id":"hardware-soul-tlb-miss-penalty"},{"level":2,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":2,"text":"Knowledge Cascade","id":"knowledge-cascade"},{"level":1,"text":"Milestone 4: Processes and Preemptive Scheduling","id":"milestone-4-processes-and-preemptive-scheduling"},{"level":2,"text":"The Illusion of Simultaneity","id":"the-illusion-of-simultaneity"},{"level":3,"text":"The Fundamental Tension","id":"the-fundamental-tension"},{"level":2,"text":"The Revelation: Context Switching Is Not Just Saving Registers","id":"the-revelation-context-switching-is-not-just-saving-registers"},{"level":2,"text":"Stage 1: The Process Control Block","id":"stage-1-the-process-control-block"},{"level":3,"text":"Process Creation","id":"process-creation"},{"level":2,"text":"Stage 2: The Context Switch","id":"stage-2-the-context-switch"},{"level":3,"text":"The Assembly Context Switch","id":"the-assembly-context-switch"},{"level":2,"text":"Stage 3: The Round-Robin Scheduler","id":"stage-3-the-round-robin-scheduler"},{"level":3,"text":"The Timer Interrupt Hook","id":"the-timer-interrupt-hook"},{"level":2,"text":"Stage 4: The Task State Segment","id":"stage-4-the-task-state-segment"},{"level":3,"text":"TSS Structure","id":"tss-structure"},{"level":2,"text":"Stage 5: User-Mode Processes and Isolation","id":"stage-5-user-mode-processes-and-isolation"},{"level":3,"text":"Creating User Page Directories","id":"creating-user-page-directories"},{"level":3,"text":"Jumping to User Mode","id":"jumping-to-user-mode"},{"level":2,"text":"Stage 6: System Calls via INT 0x80","id":"stage-6-system-calls-via-int-0x80"},{"level":3,"text":"System Call Handler","id":"system-call-handler"},{"level":3,"text":"Assembly Wrapper for INT 0x80","id":"assembly-wrapper-for-int-0x80"},{"level":3,"text":"User-Mode System Call Example","id":"user-mode-system-call-example"},{"level":2,"text":"Stage 7: Multi-Process Demo","id":"stage-7-multi-process-demo"},{"level":3,"text":"Updated Kernel Main","id":"updated-kernel-main"},{"level":2,"text":"The Three-Level View: What Happens During a Context Switch","id":"the-three-level-view-what-happens-during-a-context-switch"},{"level":2,"text":"Hardware Soul: Context Switch Overhead","id":"hardware-soul-context-switch-overhead"},{"level":2,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":2,"text":"Knowledge Cascade","id":"knowledge-cascade"},{"level":1,"text":"TDD","id":"tdd"},{"level":1,"text":"Module: Bootloader, GDT, and Kernel Entry","id":"module-bootloader-gdt-and-kernel-entry"},{"level":2,"text":"Module Charter","id":"module-charter"},{"level":2,"text":"File Structure","id":"file-structure"},{"level":2,"text":"Complete Data Model","id":"complete-data-model"},{"level":3,"text":"GDT Entry (Segment Descriptor)","id":"gdt-entry-segment-descriptor"},{"level":3,"text":"GDT Descriptor (GDTR Load Value)","id":"gdt-descriptor-gdtr-load-value"},{"level":3,"text":"VGA Character Cell","id":"vga-character-cell"},{"level":3,"text":"Serial Port Registers (COM1 at 0x3F8)","id":"serial-port-registers-com1-at-0x3f8"},{"level":2,"text":"Interface Contracts","id":"interface-contracts"},{"level":3,"text":"boot.asm: Stage 1 Bootloader","id":"bootasm-stage-1-bootloader"},{"level":3,"text":"kernel_entry.asm: Assembly Entry Point","id":"kernel_entryasm-assembly-entry-point"},{"level":3,"text":"vga_init / vga_putchar / vga_puts","id":"vga_init-vga_putchar-vga_puts"},{"level":3,"text":"serial_init / serial_putchar / serial_puts","id":"serial_init-serial_putchar-serial_puts"},{"level":3,"text":"kprintf","id":"kprintf"},{"level":2,"text":"Algorithm Specification","id":"algorithm-specification"},{"level":3,"text":"Algorithm: A20 Line Enablement","id":"algorithm-a20-line-enablement"},{"level":3,"text":"Algorithm: Protected Mode Transition","id":"algorithm-protected-mode-transition"},{"level":3,"text":"Algorithm: VGA Scrolling","id":"algorithm-vga-scrolling"},{"level":2,"text":"Error Handling Matrix","id":"error-handling-matrix"},{"level":2,"text":"Implementation Sequence with Checkpoints","id":"implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Stage 1 Bootloader (4-6 hours)","id":"phase-1-stage-1-bootloader-4-6-hours"},{"level":3,"text":"Phase 2: GDT Configuration (2-3 hours)","id":"phase-2-gdt-configuration-2-3-hours"},{"level":3,"text":"Phase 3: Kernel Entry and Linker Script (2-3 hours)","id":"phase-3-kernel-entry-and-linker-script-2-3-hours"},{"level":3,"text":"Phase 4: VGA Driver (2-3 hours)","id":"phase-4-vga-driver-2-3-hours"},{"level":3,"text":"Phase 5: Serial Driver (1-2 hours)","id":"phase-5-serial-driver-1-2-hours"},{"level":3,"text":"Phase 6: kprintf (2-3 hours)","id":"phase-6-kprintf-2-3-hours"},{"level":3,"text":"Phase 7: Integration and Full Test (2-3 hours)","id":"phase-7-integration-and-full-test-2-3-hours"},{"level":2,"text":"Test Specification","id":"test-specification"},{"level":3,"text":"Test: Bootloader Loads and Enters Protected Mode","id":"test-bootloader-loads-and-enters-protected-mode"},{"level":3,"text":"Test: GDT Configuration Valid","id":"test-gdt-configuration-valid"},{"level":3,"text":"Test: VGA Output","id":"test-vga-output"},{"level":3,"text":"Test: Serial Output","id":"test-serial-output"},{"level":3,"text":"Test: kprintf Format Specifiers","id":"test-kprintf-format-specifiers"},{"level":2,"text":"Performance Targets","id":"performance-targets"},{"level":2,"text":"Hardware Soul","id":"hardware-soul"},{"level":3,"text":"Cache Behavior","id":"cache-behavior"},{"level":3,"text":"Branch Prediction","id":"branch-prediction"},{"level":3,"text":"TLB Behavior","id":"tlb-behavior"},{"level":3,"text":"Memory Access Patterns","id":"memory-access-patterns"},{"level":2,"text":"Visual Diagrams","id":"visual-diagrams"},{"level":1,"text":"Module: Interrupts, Exceptions, and Keyboard","id":"module-interrupts-exceptions-and-keyboard"},{"level":2,"text":"Module Charter","id":"module-charter"},{"level":2,"text":"File Structure","id":"file-structure"},{"level":2,"text":"Complete Data Model","id":"complete-data-model"},{"level":3,"text":"IDT Entry (Gate Descriptor)","id":"idt-entry-gate-descriptor"},{"level":3,"text":"IDT Pointer (IDTR Load Value)","id":"idt-pointer-idtr-load-value"},{"level":3,"text":"Interrupt Stack Frame","id":"interrupt-stack-frame"},{"level":3,"text":"PIC Registers","id":"pic-registers"},{"level":3,"text":"PIT (Timer) Registers","id":"pit-timer-registers"},{"level":3,"text":"Keyboard Buffer","id":"keyboard-buffer"},{"level":2,"text":"Interface Contracts","id":"interface-contracts"},{"level":3,"text":"idt_init / idt_set_gate","id":"idt_init-idt_set_gate"},{"level":3,"text":"Exception Handlers (ISR 0-31)","id":"exception-handlers-isr-0-31"},{"level":3,"text":"IRQ Handlers (IRQ 0-15)","id":"irq-handlers-irq-0-15"},{"level":3,"text":"pic_remap / pic_send_eoi","id":"pic_remap-pic_send_eoi"},{"level":3,"text":"timer_init / timer_handler","id":"timer_init-timer_handler"},{"level":3,"text":"keyboard_init / keyboard_handler / keyboard_getchar","id":"keyboard_init-keyboard_handler-keyboard_getchar"},{"level":2,"text":"Algorithm Specification","id":"algorithm-specification"},{"level":3,"text":"Algorithm: IDT Gate Installation","id":"algorithm-idt-gate-installation"},{"level":3,"text":"Algorithm: Interrupt Entry (Assembly Stub)","id":"algorithm-interrupt-entry-assembly-stub"},{"level":3,"text":"Algorithm: Exception with Error Code Handling","id":"algorithm-exception-with-error-code-handling"},{"level":3,"text":"Algorithm: PIC Remapping","id":"algorithm-pic-remapping"},{"level":3,"text":"Algorithm: EOI Handling","id":"algorithm-eoi-handling"},{"level":3,"text":"Algorithm: Timer Frequency Programming","id":"algorithm-timer-frequency-programming"},{"level":3,"text":"Algorithm: Scancode Translation","id":"algorithm-scancode-translation"},{"level":2,"text":"Error Handling Matrix","id":"error-handling-matrix"},{"level":2,"text":"State Machine: Keyboard Modifier State","id":"state-machine-keyboard-modifier-state"},{"level":2,"text":"Implementation Sequence with Checkpoints","id":"implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: IDT Structure and Loading (2-3 hours)","id":"phase-1-idt-structure-and-loading-2-3-hours"},{"level":3,"text":"Phase 2: Exception Handlers (4-5 hours)","id":"phase-2-exception-handlers-4-5-hours"},{"level":3,"text":"Phase 3: Interrupt Stack Frame (3-4 hours)","id":"phase-3-interrupt-stack-frame-3-4-hours"},{"level":3,"text":"Phase 4: PIC Remapping (2-3 hours)","id":"phase-4-pic-remapping-2-3-hours"},{"level":3,"text":"Phase 5: EOI Handling and IRQ Routing (2-3 hours)","id":"phase-5-eoi-handling-and-irq-routing-2-3-hours"},{"level":3,"text":"Phase 6: Timer Interrupt (2-3 hours)","id":"phase-6-timer-interrupt-2-3-hours"},{"level":3,"text":"Phase 7: PS/2 Keyboard Driver (3-4 hours)","id":"phase-7-ps2-keyboard-driver-3-4-hours"},{"level":3,"text":"Phase 8: Circular Keyboard Buffer (1-2 hours)","id":"phase-8-circular-keyboard-buffer-1-2-hours"},{"level":2,"text":"Test Specification","id":"test-specification"},{"level":3,"text":"Test: IDT Loads Without Fault","id":"test-idt-loads-without-fault"},{"level":3,"text":"Test: Exception Handler Catches Divide Error","id":"test-exception-handler-catches-divide-error"},{"level":3,"text":"Test: Exception Handler Catches Page Fault","id":"test-exception-handler-catches-page-fault"},{"level":3,"text":"Test: PIC Remapped Correctly","id":"test-pic-remapped-correctly"},{"level":3,"text":"Test: EOI Sent on Every IRQ","id":"test-eoi-sent-on-every-irq"},{"level":3,"text":"Test: Timer Frequency Accuracy","id":"test-timer-frequency-accuracy"},{"level":3,"text":"Test: Keyboard Scancode Translation","id":"test-keyboard-scancode-translation"},{"level":3,"text":"Test: Shift Key Modifies Output","id":"test-shift-key-modifies-output"},{"level":3,"text":"Test: Circular Buffer Overflow","id":"test-circular-buffer-overflow"},{"level":2,"text":"Performance Targets","id":"performance-targets"},{"level":2,"text":"Hardware Soul","id":"hardware-soul"},{"level":3,"text":"Cache Behavior","id":"cache-behavior"},{"level":3,"text":"Branch Prediction","id":"branch-prediction"},{"level":3,"text":"TLB Behavior","id":"tlb-behavior"},{"level":3,"text":"Memory Access Patterns","id":"memory-access-patterns"},{"level":3,"text":"SIMD Opportunity","id":"simd-opportunity"},{"level":2,"text":"Concurrency Specification","id":"concurrency-specification"},{"level":3,"text":"Interrupt Safety","id":"interrupt-safety"},{"level":3,"text":"Reentrancy","id":"reentrancy"},{"level":3,"text":"Critical Sections","id":"critical-sections"},{"level":2,"text":"Visual Diagrams","id":"visual-diagrams"},{"level":1,"text":"Module: Physical and Virtual Memory Management","id":"module-physical-and-virtual-memory-management"},{"level":2,"text":"Module Charter","id":"module-charter"},{"level":2,"text":"File Structure","id":"file-structure"},{"level":2,"text":"Complete Data Model","id":"complete-data-model"},{"level":3,"text":"Memory Region (E820/Multiboot Entry)","id":"memory-region-e820multiboot-entry"},{"level":3,"text":"Physical Frame Bitmap","id":"physical-frame-bitmap"},{"level":3,"text":"Page Directory Entry (PDE)","id":"page-directory-entry-pde"},{"level":3,"text":"Page Table Entry (PTE)","id":"page-table-entry-pte"},{"level":3,"text":"Page Directory and Page Table Structures","id":"page-directory-and-page-table-structures"},{"level":3,"text":"Kernel Heap Block Header","id":"kernel-heap-block-header"},{"level":2,"text":"Interface Contracts","id":"interface-contracts"},{"level":3,"text":"memory_map_init","id":"memory_map_init"},{"level":3,"text":"pmm_init / pmm_alloc_frame / pmm_free_frame","id":"pmm_init-pmm_alloc_frame-pmm_free_frame"},{"level":3,"text":"vmm_init / vmm_map_page / vmm_unmap_page","id":"vmm_init-vmm_map_page-vmm_unmap_page"},{"level":3,"text":"paging_setup_identity / paging_setup_higher_half / paging_enable","id":"paging_setup_identity-paging_setup_higher_half-paging_enable"},{"level":3,"text":"tlb_invalidate_page / tlb_flush_all","id":"tlb_invalidate_page-tlb_flush_all"},{"level":3,"text":"page_fault_handler","id":"page_fault_handler"},{"level":3,"text":"kmalloc / kfree","id":"kmalloc-kfree"},{"level":2,"text":"Algorithm Specification","id":"algorithm-specification"},{"level":3,"text":"Algorithm: Memory Map Parsing (Multiboot)","id":"algorithm-memory-map-parsing-multiboot"},{"level":3,"text":"Algorithm: Physical Frame Allocation (Bitmap Scan)","id":"algorithm-physical-frame-allocation-bitmap-scan"},{"level":3,"text":"Algorithm: Physical Frame Free","id":"algorithm-physical-frame-free"},{"level":3,"text":"Algorithm: Virtual Address Translation","id":"algorithm-virtual-address-translation"},{"level":3,"text":"Algorithm: Identity Mapping Setup","id":"algorithm-identity-mapping-setup"},{"level":3,"text":"Algorithm: Higher-Half Kernel Mapping","id":"algorithm-higher-half-kernel-mapping"},{"level":3,"text":"Algorithm: Paging Enable Transition","id":"algorithm-paging-enable-transition"},{"level":3,"text":"Algorithm: Page Fault Handling","id":"algorithm-page-fault-handling"},{"level":3,"text":"Algorithm: Kernel Heap Allocation (First-Fit)","id":"algorithm-kernel-heap-allocation-first-fit"},{"level":3,"text":"Algorithm: Kernel Heap Free with Coalescing","id":"algorithm-kernel-heap-free-with-coalescing"},{"level":2,"text":"Error Handling Matrix","id":"error-handling-matrix"},{"level":2,"text":"Concurrency Specification","id":"concurrency-specification"},{"level":3,"text":"Interrupt Safety","id":"interrupt-safety"},{"level":3,"text":"Future Preemptive Kernel Considerations","id":"future-preemptive-kernel-considerations"},{"level":2,"text":"State Machine: Heap Block Lifecycle","id":"state-machine-heap-block-lifecycle"},{"level":2,"text":"Implementation Sequence with Checkpoints","id":"implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Memory Map Parsing (2-3 hours)","id":"phase-1-memory-map-parsing-2-3-hours"},{"level":3,"text":"Phase 2: Physical Frame Allocator (4-5 hours)","id":"phase-2-physical-frame-allocator-4-5-hours"},{"level":3,"text":"Phase 3: Page Directory and Page Table Structures (3-4 hours)","id":"phase-3-page-directory-and-page-table-structures-3-4-hours"},{"level":3,"text":"Phase 4: Virtual Memory Mapping Functions (3-4 hours)","id":"phase-4-virtual-memory-mapping-functions-3-4-hours"},{"level":3,"text":"Phase 5: Identity Mapping Setup (2-3 hours)","id":"phase-5-identity-mapping-setup-2-3-hours"},{"level":3,"text":"Phase 6: Higher-Half Kernel Mapping (3-4 hours)","id":"phase-6-higher-half-kernel-mapping-3-4-hours"},{"level":3,"text":"Phase 7: Paging Enable and Transition (3-4 hours)","id":"phase-7-paging-enable-and-transition-3-4-hours"},{"level":3,"text":"Phase 8: TLB Management (2-3 hours)","id":"phase-8-tlb-management-2-3-hours"},{"level":3,"text":"Phase 9: Page Fault Handler (2-3 hours)","id":"phase-9-page-fault-handler-2-3-hours"},{"level":3,"text":"Phase 10: Kernel Heap Allocator (4-6 hours)","id":"phase-10-kernel-heap-allocator-4-6-hours"},{"level":2,"text":"Test Specification","id":"test-specification"},{"level":3,"text":"Test: Memory Map Parsing","id":"test-memory-map-parsing"},{"level":3,"text":"Test: Frame Allocation","id":"test-frame-allocation"},{"level":3,"text":"Test: Double-Free Detection","id":"test-double-free-detection"},{"level":3,"text":"Test: Page Mapping","id":"test-page-mapping"},{"level":3,"text":"Test: Paging Enable","id":"test-paging-enable"},{"level":3,"text":"Test: TLB Invalidation","id":"test-tlb-invalidation"},{"level":3,"text":"Test: Page Fault Handler","id":"test-page-fault-handler"},{"level":3,"text":"Test: kmalloc Basic","id":"test-kmalloc-basic"},{"level":3,"text":"Test: Heap Coalescing","id":"test-heap-coalescing"},{"level":2,"text":"Performance Targets","id":"performance-targets"},{"level":2,"text":"Hardware Soul","id":"hardware-soul"},{"level":3,"text":"Cache Behavior","id":"cache-behavior"},{"level":3,"text":"Branch Prediction","id":"branch-prediction"},{"level":3,"text":"TLB Behavior","id":"tlb-behavior"},{"level":3,"text":"SIMD Opportunity","id":"simd-opportunity"},{"level":3,"text":"Memory Access Patterns","id":"memory-access-patterns"},{"level":2,"text":"Visual Diagrams","id":"visual-diagrams"},{"level":1,"text":"Module: Processes and Preemptive Scheduling","id":"module-processes-and-preemptive-scheduling"},{"level":2,"text":"Module Charter","id":"module-charter"},{"level":2,"text":"File Structure","id":"file-structure"},{"level":2,"text":"Complete Data Model","id":"complete-data-model"},{"level":3,"text":"Process Control Block (PCB)","id":"process-control-block-pcb"},{"level":3,"text":"Task State Segment (TSS)","id":"task-state-segment-tss"},{"level":3,"text":"GDT TSS Descriptor","id":"gdt-tss-descriptor"},{"level":3,"text":"System Call Registers Convention","id":"system-call-registers-convention"},{"level":3,"text":"Ready Queue Structure","id":"ready-queue-structure"},{"level":2,"text":"Interface Contracts","id":"interface-contracts"},{"level":3,"text":"process_create / process_destroy","id":"process_create-process_destroy"},{"level":3,"text":"context_switch","id":"context_switch"},{"level":3,"text":"tss_init / tss_update_esp0","id":"tss_init-tss_update_esp0"},{"level":3,"text":"scheduler_add / scheduler_remove / scheduler_pick_next","id":"scheduler_add-scheduler_remove-scheduler_pick_next"},{"level":3,"text":"user_create_page_directory / user_map_code","id":"user_create_page_directory-user_map_code"},{"level":3,"text":"jump_to_user_mode","id":"jump_to_user_mode"},{"level":3,"text":"syscall_handler","id":"syscall_handler"},{"level":2,"text":"Algorithm Specification","id":"algorithm-specification"},{"level":3,"text":"Algorithm: Process Creation (Kernel Mode)","id":"algorithm-process-creation-kernel-mode"},{"level":3,"text":"Algorithm: Context Switch (Assembly)","id":"algorithm-context-switch-assembly"},{"level":3,"text":"Algorithm: Round-Robin Scheduling","id":"algorithm-round-robin-scheduling"},{"level":3,"text":"Algorithm: Timer Interrupt Scheduler Hook","id":"algorithm-timer-interrupt-scheduler-hook"},{"level":3,"text":"Algorithm: User Page Directory Creation","id":"algorithm-user-page-directory-creation"},{"level":3,"text":"Algorithm: Jump to User Mode","id":"algorithm-jump-to-user-mode"},{"level":3,"text":"Algorithm: System Call Handler","id":"algorithm-system-call-handler"},{"level":2,"text":"Error Handling Matrix","id":"error-handling-matrix"},{"level":2,"text":"Concurrency Specification","id":"concurrency-specification"},{"level":3,"text":"Interrupt Safety","id":"interrupt-safety"},{"level":3,"text":"Critical Sections","id":"critical-sections"},{"level":3,"text":"Reentrancy Rules","id":"reentrancy-rules"},{"level":2,"text":"State Machine: Process Lifecycle","id":"state-machine-process-lifecycle"},{"level":2,"text":"Implementation Sequence with Checkpoints","id":"implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Process Control Block Structure (2-3 hours)","id":"phase-1-process-control-block-structure-2-3-hours"},{"level":3,"text":"Phase 2: Process Creation (Kernel Mode) (3-4 hours)","id":"phase-2-process-creation-kernel-mode-3-4-hours"},{"level":3,"text":"Phase 3: Context Switch Assembly (5-7 hours)","id":"phase-3-context-switch-assembly-5-7-hours"},{"level":3,"text":"Phase 4: TSS Structure and Initialization (2-3 hours)","id":"phase-4-tss-structure-and-initialization-2-3-hours"},{"level":3,"text":"Phase 5: TSS ESP0 Update (1-2 hours)","id":"phase-5-tss-esp0-update-1-2-hours"},{"level":3,"text":"Phase 6: Round-Robin Scheduler (3-4 hours)","id":"phase-6-round-robin-scheduler-3-4-hours"},{"level":3,"text":"Phase 7: Timer Interrupt Scheduler Hook (2-3 hours)","id":"phase-7-timer-interrupt-scheduler-hook-2-3-hours"},{"level":3,"text":"Phase 8: User Page Directory Creation (3-4 hours)","id":"phase-8-user-page-directory-creation-3-4-hours"},{"level":3,"text":"Phase 9: Jump to User Mode (3-4 hours)","id":"phase-9-jump-to-user-mode-3-4-hours"},{"level":3,"text":"Phase 10: System Call Handler (3-4 hours)","id":"phase-10-system-call-handler-3-4-hours"},{"level":3,"text":"Phase 11: sys_write and sys_exit Implementation (2-3 hours)","id":"phase-11-sys_write-and-sys_exit-implementation-2-3-hours"},{"level":3,"text":"Phase 12: Multi-Process Demo (2-3 hours)","id":"phase-12-multi-process-demo-2-3-hours"},{"level":2,"text":"Test Specification","id":"test-specification"},{"level":3,"text":"Test: Process Creation","id":"test-process-creation"},{"level":3,"text":"Test: Context Switch Preserves State","id":"test-context-switch-preserves-state"},{"level":3,"text":"Test: TSS ESP0 Updated","id":"test-tss-esp0-updated"},{"level":3,"text":"Test: Round-Robin Scheduling","id":"test-round-robin-scheduling"},{"level":3,"text":"Test: Timer Triggers Context Switch","id":"test-timer-triggers-context-switch"},{"level":3,"text":"Test: User Mode Isolation","id":"test-user-mode-isolation"},{"level":3,"text":"Test: System Call from User Mode","id":"test-system-call-from-user-mode"},{"level":3,"text":"Test: Multi-Process Concurrent Execution","id":"test-multi-process-concurrent-execution"},{"level":2,"text":"Performance Targets","id":"performance-targets"},{"level":2,"text":"Hardware Soul","id":"hardware-soul"},{"level":3,"text":"Cache Behavior","id":"cache-behavior"},{"level":3,"text":"Branch Prediction","id":"branch-prediction"},{"level":3,"text":"TLB Behavior","id":"tlb-behavior"},{"level":3,"text":"SIMD Considerations","id":"simd-considerations"},{"level":3,"text":"Memory Access Patterns","id":"memory-access-patterns"},{"level":2,"text":"Visual Diagrams","id":"visual-diagrams"},{"level":1,"text":"📚 Beyond the Atlas: Further Reading","id":"-beyond-the-atlas-further-reading"},{"level":2,"text":"Bootloader and Protected Mode","id":"bootloader-and-protected-mode"},{"level":3,"text":"Paper","id":"paper"},{"level":3,"text":"Code","id":"code"},{"level":3,"text":"Best Explanation","id":"best-explanation"},{"level":3,"text":"Why","id":"why"},{"level":2,"text":"x86 Segmentation and GDT","id":"x86-segmentation-and-gdt"},{"level":3,"text":"Spec","id":"spec"},{"level":3,"text":"Code","id":"code"},{"level":3,"text":"Best Explanation","id":"best-explanation"},{"level":3,"text":"Why","id":"why"},{"level":2,"text":"Interrupts and IDT","id":"interrupts-and-idt"},{"level":3,"text":"Spec","id":"spec"},{"level":3,"text":"Code","id":"code"},{"level":3,"text":"Best Explanation","id":"best-explanation"},{"level":3,"text":"Why","id":"why"},{"level":2,"text":"8259 PIC Programming","id":"8259-pic-programming"},{"level":3,"text":"Spec","id":"spec"},{"level":3,"text":"Code","id":"code"},{"level":3,"text":"Best Explanation","id":"best-explanation"},{"level":3,"text":"Why","id":"why"},{"level":2,"text":"Physical Memory Management","id":"physical-memory-management"},{"level":3,"text":"Code","id":"code"},{"level":3,"text":"Best Explanation","id":"best-explanation"},{"level":3,"text":"Why","id":"why"},{"level":2,"text":"Virtual Memory and Page Tables","id":"virtual-memory-and-page-tables"},{"level":3,"text":"Paper","id":"paper"},{"level":3,"text":"Spec","id":"spec"},{"level":3,"text":"Code","id":"code"},{"level":3,"text":"Best Explanation","id":"best-explanation"},{"level":3,"text":"Why","id":"why"},{"level":2,"text":"TLB Management","id":"tlb-management"},{"level":3,"text":"Spec","id":"spec"},{"level":3,"text":"Best Explanation","id":"best-explanation"},{"level":3,"text":"Why","id":"why"},{"level":2,"text":"Page Faults and Demand Paging","id":"page-faults-and-demand-paging"},{"level":3,"text":"Paper","id":"paper"},{"level":3,"text":"Code","id":"code"},{"level":3,"text":"Best Explanation","id":"best-explanation"},{"level":3,"text":"Why","id":"why"},{"level":2,"text":"Kernel Heap Allocation","id":"kernel-heap-allocation"},{"level":3,"text":"Paper","id":"paper"},{"level":3,"text":"Code","id":"code"},{"level":3,"text":"Best Explanation","id":"best-explanation"},{"level":3,"text":"Why","id":"why"},{"level":2,"text":"Process Control and Context Switching","id":"process-control-and-context-switching"},{"level":3,"text":"Paper","id":"paper"},{"level":3,"text":"Code","id":"code"},{"level":3,"text":"Best Explanation","id":"best-explanation"},{"level":3,"text":"Why","id":"why"},{"level":2,"text":"Task State Segment","id":"task-state-segment"},{"level":3,"text":"Spec","id":"spec"},{"level":3,"text":"Code","id":"code"},{"level":3,"text":"Best Explanation","id":"best-explanation"},{"level":3,"text":"Why","id":"why"},{"level":2,"text":"Round-Robin Scheduling","id":"round-robin-scheduling"},{"level":3,"text":"Paper","id":"paper"},{"level":3,"text":"Code","id":"code"},{"level":3,"text":"Best Explanation","id":"best-explanation"},{"level":3,"text":"Why","id":"why"},{"level":2,"text":"User-Kernel Mode Transitions","id":"user-kernel-mode-transitions"},{"level":3,"text":"Spec","id":"spec"},{"level":3,"text":"Code","id":"code"},{"level":3,"text":"Best Explanation","id":"best-explanation"},{"level":3,"text":"Why","id":"why"},{"level":2,"text":"System Calls","id":"system-calls"},{"level":3,"text":"Paper","id":"paper"},{"level":3,"text":"Code","id":"code"},{"level":3,"text":"Best Explanation","id":"best-explanation"},{"level":3,"text":"Why","id":"why"},{"level":2,"text":"Process Isolation via Page Tables","id":"process-isolation-via-page-tables"},{"level":3,"text":"Paper","id":"paper"},{"level":3,"text":"Code","id":"code"},{"level":3,"text":"Best Explanation","id":"best-explanation"},{"level":3,"text":"Why","id":"why"},{"level":2,"text":"Additional Resources","id":"additional-resources"},{"level":3,"text":"Comprehensive OS Development","id":"comprehensive-os-development"},{"level":3,"text":"x86 Architecture Reference","id":"x86-architecture-reference"},{"level":3,"text":"Teaching Operating Systems","id":"teaching-operating-systems"}],"title":"Build Your Own OS","markdown":"# Build Your Own OS\n\nThis project guides you through building a complete x86 operating system kernel from scratch, starting with the boot process and culminating in preemptive multitasking with user-mode processes. You will implement the fundamental abstractions that every modern OS provides: bootstrapping from firmware, hardware interrupt handling, virtual memory isolation, and fair process scheduling. Each layer reveals how software negotiates with hardware physics—CPU pipelines, cache hierarchies, TLBs, and the memory bus.\n\nThe journey begins with a 512-byte bootloader that wrests control from BIOS, configures the Global Descriptor Table (GDT), and transitions the CPU from 16-bit real mode to 32-bit protected mode. From there, you'll build an interrupt subsystem that handles CPU exceptions and hardware IRQs, implement physical and virtual memory management with page tables, and finally create a preemptive scheduler that safely transitions between ring 0 (kernel) and ring 3 (user) privilege levels.\n\nBy the end, you will have demystified the abstraction layer that underlies every computing platform—from interrupt latency to memory isolation to context switch overhead. You will understand not just what an OS does, but why it must do it, and how hardware constraints shape every design decision.\n\n\n\n<!-- MS_ID: build-os-m1 -->\n# Milestone 1: Bootloader, GDT, and Kernel Entry\n\n## The First Breath of Your Operating System\n\n{{DIAGRAM:diag-boot-sequence}}\n\nWhen you press the power button, nothing about your computer knows what an \"operating system\" is. The CPU wakes up in a primitive state—16-bit real mode—and begins executing firmware code at a fixed address. Your kernel, your C code, your beautiful abstractions? They don't exist yet. They're just bits on a disk, waiting to be loaded.\n\nThis milestone is about the **bootstrap problem**: how do you go from a 512-byte constraint (the Master Boot Record) to a fully running C kernel with memory protection? Every step is your responsibility. The hardware provides mechanisms; you must orchestrate them.\n\n### The Fundamental Tension\n\n**Constraint 1: The 512-Byte Prison**\n\nBIOS loads exactly one sector—512 bytes—from the boot disk into memory at address `0x7C00`. That's it. Your entire bootloader must fit in 512 bytes, or you must be clever enough to load more code from disk.\n\n**Constraint 2: The A20 Gate**\n\nFor historical compatibility with the original IBM PC, the 21st address line (A20) is often disabled at boot. Without it, addresses wrap around at 1MB—the CPU cannot access memory above this boundary. Your kernel needs to live above 1MB (at `0x100000`), so you must enable A20.\n\n**Constraint 3: Real Mode Addressing**\n\nThe CPU starts in **real mode** (16-bit), where addresses are calculated as `segment * 16 + offset`. This gives you access to only the first 1MB of memory. To access 4GB of memory and enable protection features, you must transition to **protected mode** (32-bit).\n\n> **Real Mode vs. Protected Mode (Memory Models)**\n>\n> In **real mode**, memory addressing uses `segment:offset` pairs. The segment value is multiplied by 16 and added to the offset: `segment * 16 + offset = physical_address`. With 16-bit segments and offsets, you can only address up to `0xFFFF0 + 0xFFFF = 0x10FFEF` (about 1MB + 64KB). There's no memory protection—any code can access any memory.\n>\n> In **protected mode**, segmentation works differently. Instead of multiplying by 16, the segment register is a **selector**—an index into the Global Descriptor Table (GDT). Each GDT entry (segment descriptor) contains a 32-bit base address and a 20-bit limit. The CPU translates every memory access through this table. Protected mode also enables paging (Milestone 3) and privilege rings (Ring 0-3).\n\n**Constraint 4: The Pipeline Inconsistency**\n\nSetting the CR0.PE bit (Protection Enable) switches the CPU to protected mode, but the instruction prefetch queue still contains real-mode instructions. A far jump flushes this queue and loads the correct protected-mode code segment.\n\n---\n\n## Stage 1: The Bootloader\n\nThe bootloader has one job: load the kernel from disk and transfer control to it. Let's trace through the sequence.\n\n### The BIOS Handoff\n\nBIOS performs POST (Power-On Self-Test), initializes hardware, then searches for a bootable disk. A disk is bootable if byte 511-512 contain the signature `0x55 0xAA`. BIOS loads the first 512 bytes to `0x7C00` and jumps there.\n\n```asm\n; boot.asm - Stage 1 Bootloader\n[BITS 16]\n[ORG 0x7C00]\n\nstart:\n    ; Disable interrupts during setup\n    cli\n    \n    ; Set up segment registers for real mode\n    xor ax, ax\n    mov ds, ax\n    mov es, ax\n    mov ss, ax\n    mov sp, 0x7C00      ; Stack grows down from bootloader\n```\n\nThe stack pointer starts at `0x7C00` and grows downward. We disable interrupts (`cli`) because we don't have an interrupt table set up yet—any interrupt would crash the system.\n\n### Enabling the A20 Line\n\nThe A20 line is a historical artifact from the 8086/8088 era. The 8086 could only address 1MB, but address calculation could wrap around. Some software relied on this behavior, so when the 286 introduced 24-bit addressing, the A20 line was gated.\n\n```asm\nenable_a20:\n    ; Method 1: Fast A20 (port 0x92)\n    in al, 0x92\n    or al, 2            ; Set A20 bit\n    out 0x92, al\n    \n    ; Alternative: Keyboard controller method (slower but more compatible)\n    ; call kbc_enable_a20\n```\n\nThe fast A20 method uses I/O port `0x92`. Setting bit 1 enables the A20 line. This works on most modern hardware and emulators like QEMU.\n\n### Loading the Kernel from Disk\n\nThe kernel binary lives on disk, starting at some known sector. We use BIOS INT 13h to read sectors into memory.\n\n```asm\nload_kernel:\n    ; Load kernel at 0x100000 (1MB mark)\n    ; We need to use extended BIOS reads for addresses above 1MB\n    \n    mov si, dap          ; Disk Address Packet\n    mov ah, 0x42         ; Extended read function\n    mov dl, 0x80         ; First hard drive\n    int 0x13\n    jc disk_error\n\n; Disk Address Packet (DAP)\ndap:\n    db 0x10              ; Size of packet (16 bytes)\n    db 0x00              ; Reserved\n    dw 50                ; Number of sectors to read (adjust for kernel size)\n    dw 0x0000, 0x1000    ; Buffer address: 0x10000 (segment:offset for real mode)\n                          ; We'll copy to 0x100000 after enabling protected mode\n    dq 1                 ; Starting LBA (sector 1, after MBR)\n```\n\nWait—there's a problem. In real mode, we can only address up to 1MB directly. The kernel needs to be at `0x100000` (1MB). How do we load it there?\n\n**Solution**: We load the kernel to a temporary buffer below 1MB, enable protected mode, then copy it to its final destination.\n\n### The GDT: Your Translation Table\n\nBefore entering protected mode, we must configure the Global Descriptor Table. The GDT defines memory segments—their base addresses, limits, and access permissions.\n\n{{DIAGRAM:diag-gdt-layout}}\n\n```asm\n; GDT Layout\ngdt_start:\n    ; Null descriptor (required)\n    dq 0x0000000000000000\n\ngdt_kernel_code:\n    ; Kernel code segment: base=0, limit=0xFFFFF, 4KB granularity\n    ; Access: present, ring 0, executable, readable\n    dq 0x00CF9A000000FFFF\n\ngdt_kernel_data:\n    ; Kernel data segment: base=0, limit=0xFFFFF, 4KB granularity\n    ; Access: present, ring 0, writable\n    dq 0x00CF92000000FFFF\n\ngdt_user_code:\n    ; User code segment: ring 3, executable, readable\n    dq 0x00CFFA000000FFFF\n\ngdt_user_data:\n    ; User data segment: ring 3, writable\n    dq 0x00CFF2000000FFFF\n\ngdt_end:\n\ngdt_descriptor:\n    dw gdt_end - gdt_start - 1   ; GDT size (limit)\n    dd gdt_start                  ; GDT linear address\n```\n\nLet's decode the kernel code descriptor byte-by-byte:\n\n```\n0x00CF9A000000FFFF\n\nLow 16 bits of limit:     0xFFFF  (65535)\nBase address (bits 16-31): 0x0000\nBase address (bits 32-39): 0x00\nAccess byte:              0x9A    = 10011010\n  - Present (P):          1       (segment is valid)\n  - DPL (privilege):      00      (ring 0)\n  - System (S):           1       (code/data segment, not system)\n  - Executable (E):       1       (code segment)\n  - Direction (DC):       0       (grows up)\n  - Readable (R):         1       (can read)\n  - Accessed (A):         0       (CPU sets this)\nFlags + limit (bits 48-51): 0xC   = 1100\n  - Granularity (G):      1       (4KB blocks, limit * 4096)\n  - Size (D/B):           1       (32-bit)\n  - Long (L):             0       (not 64-bit)\nHigh 4 bits of limit:     0xF\nBase address (bits 56-63): 0x00\n```\n\nWith granularity=4KB and limit=0xFFFFF, the segment spans `0xFFFFF * 4096 = 4GB`. Base=0 means linear addresses equal virtual addresses—**flat addressing**. This makes segmentation a no-op and lets paging (Milestone 3) handle all address translation.\n\n> **Segmentation vs. Paging**\n>\n> Both are address translation mechanisms, but they serve different purposes:\n>\n> **Segmentation** divides memory into variable-sized logical units (code, data, stack). Each segment has a base address and limit. The CPU checks every access against segment bounds. Segmentation is mandatory in x86—you can't disable it.\n>\n> **Paging** divides memory into fixed-size 4KB pages. It provides finer-grained protection (per-page) and enables virtual memory (swapping to disk). Paging is optional in 32-bit mode.\n>\n> The trick: by setting all segment bases to 0 and limits to 4GB, segmentation becomes a no-op. Every linear address passes through unchanged. This is called **flat addressing**, and it lets paging be the sole translation mechanism. Modern OSes use this approach.\n\n### Entering Protected Mode\n\n```asm\nenter_protected_mode:\n    ; Load the GDT\n    lgdt [gdt_descriptor]\n    \n    ; Set CR0.PE bit (Protection Enable)\n    mov eax, cr0\n    or eax, 1\n    mov cr0, eax\n    \n    ; FAR JUMP - This is NOT optional!\n    ; Flushes the prefetch queue and loads CS with kernel code selector\n    jmp 0x08:protected_mode_entry\n\n[BITS 32]\nprotected_mode_entry:\n    ; Now in 32-bit protected mode!\n    ; Load all data segment registers with kernel data selector (0x10)\n    mov ax, 0x10         ; Kernel data selector (index 2 * 8 = 0x10)\n    mov ds, ax\n    mov es, ax\n    mov fs, ax\n    mov gs, ax\n    mov ss, ax\n    mov esp, 0x90000     ; Set up kernel stack\n    \n    ; Copy kernel from temporary buffer to 0x100000\n    ; (implementation depends on where you loaded it)\n    \n    ; Jump to kernel entry point\n    jmp 0x08:0x100000\n```\n\nThe far jump `jmp 0x08:protected_mode_entry` is critical:\n- `0x08` is the segment selector for the kernel code segment (GDT index 1, RPL=0, TI=0)\n- This loads CS with the protected-mode selector and flushes the pipeline\n- Without it, the CPU continues executing real-mode code with a corrupted state\n\n---\n\n## Stage 2: The Kernel Entry Point\n\nThe kernel is now loaded at `0x100000` and the CPU is in protected mode. Time to enter C.\n\n### The Linker Script: Section Placement\n\n\n![Linker Script: Section Placement and Addresses](./diagrams/diag-linker-script.svg)\n\n\n```ld\n/* linker.ld */\nENTRY(kernel_entry)\n\nSECTIONS\n{\n    . = 0x100000;        /* Kernel starts at 1MB */\n    \n    .text : {\n        *(.multiboot)    /* Multiboot header if using GRUB */\n        *(.text)\n    }\n    \n    .rodata : {\n        *(.rodata)\n    }\n    \n    .data : {\n        *(.data)\n    }\n    \n    .bss : {\n        __bss_start = .;\n        *(.COMMON)\n        *(.bss)\n        __bss_end = .;\n    }\n    \n    /DISCARD/ : {\n        *(.comment)\n        *(.eh_frame)\n    }\n}\n```\n\nThe linker script defines where each section goes in memory. `.text` contains code, `.rodata` contains read-only data, `.data` contains initialized global variables, and `.bss` contains uninitialized globals.\n\n### Zeroing BSS: Your Responsibility\n\nIn a hosted C environment (userspace), the C runtime (CRT0) zeros the BSS section before calling `main()`. In freestanding mode (kernel), there's no CRT0—BSS contains garbage until you zero it.\n\n```c\n/* kernel_entry.asm */\n[BITS 32]\n[GLOBAL kernel_entry]\n[EXTERN kernel_main]\n[EXTERN __bss_start]\n[EXTERN __bss_end]\n\nkernel_entry:\n    ; Zero the BSS section\n    mov edi, __bss_start\n    mov ecx, __bss_end\n    sub ecx, edi\n    xor eax, eax\n    rep stosb\n    \n    ; Call kernel main\n    call kernel_main\n    \n    ; Halt if kernel_main returns (it shouldn't)\n    cli\n.halt:\n    hlt\n    jmp .halt\n```\n\n```c\n/* main.c */\n#include \"vga.h\"\n#include \"serial.h\"\n\nvoid kernel_main(void) {\n    vga_init();\n    serial_init(COM1_PORT);\n    \n    kprintf(\"Welcome to MyOS!\\n\");\n    kprintf(\"Kernel loaded at 0x100000\\n\");\n    \n    // Kernel continues...\n}\n```\n\n---\n\n## Stage 3: Output Drivers\n\nYou need to see what's happening. Two output mechanisms: VGA text mode (screen) and serial port (debugging).\n\n### VGA Text Mode\n\nVGA text mode is memory-mapped at `0xB8000`. Each character cell is 2 bytes: character + attribute (color).\n\n{{DIAGRAM:diag-vga-serial-dual}}\n\n```c\n/* vga.h */\n#define VGA_BUFFER ((volatile uint16_t*)0xB8000)\n#define VGA_WIDTH 80\n#define VGA_HEIGHT 25\n\ntypedef enum {\n    VGA_COLOR_BLACK = 0,\n    VGA_COLOR_BLUE = 1,\n    VGA_COLOR_GREEN = 2,\n    VGA_COLOR_CYAN = 3,\n    VGA_COLOR_RED = 4,\n    VGA_COLOR_MAGENTA = 5,\n    VGA_COLOR_BROWN = 6,\n    VGA_COLOR_LIGHT_GREY = 7,\n    VGA_COLOR_WHITE = 15,\n} vga_color_t;\n\nstatic inline uint16_t vga_entry(char c, vga_color_t fg, vga_color_t bg) {\n    return (uint16_t)c | ((uint16_t)(fg | (bg << 4)) << 8);\n}\n\nvoid vga_init(void);\nvoid vga_putchar(char c);\nvoid vga_puts(const char* str);\n```\n\n```c\n/* vga.c */\n#include \"vga.h\"\n\nstatic size_t vga_row = 0;\nstatic size_t vga_col = 0;\nstatic vga_color_t current_fg = VGA_COLOR_WHITE;\nstatic vga_color_t current_bg = VGA_COLOR_BLACK;\n\nvoid vga_init(void) {\n    // Clear screen\n    for (size_t i = 0; i < VGA_WIDTH * VGA_HEIGHT; i++) {\n        VGA_BUFFER[i] = vga_entry(' ', current_fg, current_bg);\n    }\n    vga_row = 0;\n    vga_col = 0;\n}\n\nvoid vga_putchar(char c) {\n    if (c == '\\n') {\n        vga_col = 0;\n        vga_row++;\n        if (vga_row >= VGA_HEIGHT) {\n            // Scroll up (implement if needed)\n            vga_row = VGA_HEIGHT - 1;\n        }\n        return;\n    }\n    \n    size_t index = vga_row * VGA_WIDTH + vga_col;\n    VGA_BUFFER[index] = vga_entry(c, current_fg, current_bg);\n    \n    vga_col++;\n    if (vga_col >= VGA_WIDTH) {\n        vga_col = 0;\n        vga_row++;\n    }\n}\n```\n\n### Serial Port (COM1)\n\nSerial output goes to `0x3F8`. In QEMU, this appears in the console with `-serial stdio`.\n\n```c\n/* serial.h */\n#define COM1_PORT 0x3F8\n\nvoid serial_init(uint16_t port);\nvoid serial_putchar(uint16_t port, char c);\nvoid serial_puts(uint16_t port, const char* str);\n```\n\n```c\n/* serial.c */\n#include \"serial.h\"\n#include \"port_io.h\"\n\nvoid serial_init(uint16_t port) {\n    outb(port + 1, 0x00);    // Disable interrupts\n    outb(port + 3, 0x80);    // Enable DLAB\n    outb(port + 0, 0x03);    // Divisor low byte (38400 baud)\n    outb(port + 1, 0x00);    // Divisor high byte\n    outb(port + 3, 0x03);    // 8 bits, no parity, one stop bit\n    outb(port + 2, 0xC7);    // Enable FIFO\n    outb(port + 4, 0x0B);    // IRQs enabled, RTS/DSR set\n}\n\nstatic int serial_is_transmit_empty(uint16_t port) {\n    return inb(port + 5) & 0x20;\n}\n\nvoid serial_putchar(uint16_t port, char c) {\n    while (serial_is_transmit_empty(port) == 0);\n    outb(port, c);\n}\n```\n\n```c\n/* port_io.h */\nstatic inline void outb(uint16_t port, uint8_t val) {\n    __asm__ volatile (\"outb %0, %1\" : : \"a\"(val), \"Nd\"(port));\n}\n\nstatic inline uint8_t inb(uint16_t port) {\n    uint8_t ret;\n    __asm__ volatile (\"inb %1, %0\" : \"=a\"(ret) : \"Nd\"(port));\n    return ret;\n}\n```\n\n### Combined Output: kprintf\n\nA minimal printf that outputs to both VGA and serial:\n\n```c\n/* kprintf.c */\n#include <stdarg.h>\n#include \"vga.h\"\n#include \"serial.h\"\n\nstatic void print_string(const char* str) {\n    while (*str) {\n        vga_putchar(*str);\n        serial_putchar(COM1_PORT, *str);\n        str++;\n    }\n}\n\nvoid kprintf(const char* fmt, ...) {\n    va_list args;\n    va_start(args, fmt);\n    \n    // Minimal implementation - handle %s, %d, %x, %c\n    while (*fmt) {\n        if (*fmt == '%') {\n            fmt++;\n            switch (*fmt) {\n                case 's':\n                    print_string(va_arg(args, const char*));\n                    break;\n                case 'd': {\n                    int val = va_arg(args, int);\n                    // Convert to string (implement itoa)\n                    break;\n                }\n                case 'x': {\n                    unsigned int val = va_arg(args, unsigned int);\n                    // Convert to hex string\n                    break;\n                }\n                case 'c':\n                    vga_putchar((char)va_arg(args, int));\n                    serial_putchar(COM1_PORT, (char)va_arg(args, int));\n                    break;\n            }\n        } else {\n            vga_putchar(*fmt);\n            serial_putchar(COM1_PORT, *fmt);\n        }\n        fmt++;\n    }\n    \n    va_end(args);\n}\n```\n\n---\n\n## Testing in QEMU\n\nBuild and run:\n\n```bash\n# Assemble bootloader\nnasm -f bin boot.asm -o boot.bin\n\n# Compile kernel\ngcc -m32 -ffreestanding -nostdlib -c main.c -o main.o\ngcc -m32 -ffreestanding -nostdlib -c vga.c -o vga.o\ngcc -m32 -ffreestanding -nostdlib -c serial.c -o serial.o\n\n# Link kernel\nld -T linker.ld -o kernel.elf main.o vga.o serial.o\n\n# Extract raw binary\nobjcopy -O binary kernel.elf kernel.bin\n\n# Create disk image (bootloader + kernel)\ncat boot.bin kernel.bin > os.img\n\n# Run in QEMU\nqemu-system-i386 -drive format=raw,file=os.img -serial stdio\n```\n\nYou should see \"Welcome to MyOS!\" on both the VGA display and the serial console.\n\n---\n\n## The Three-Level View: What Happens When You Call vga_putchar\n\n**Level 1 — Application (Your Code)**:\n```c\nvga_putchar('A');\n```\nA simple function call. You're writing a character to the screen.\n\n**Level 2 — Memory Bus (Hardware Interface)**:\nThe CPU writes a 16-bit value to physical address `0xB8000 + offset`. This address is in the VGA controller's memory-mapped I/O region. The write travels over the memory bus to the VGA hardware, not to RAM.\n\n**Level 3 — Hardware (VGA Controller)**:\nThe VGA controller continuously scans its text buffer, converting character/attribute pairs to analog RGB signals. Each scan (60+ times per second) reads the buffer and generates the video signal. Your write is visible on the next scan.\n\n---\n\n## Common Pitfalls and Debugging\n\n| Symptom | Likely Cause | Fix |\n|---------|--------------|-----|\n| Triple fault immediately after `mov cr0, eax` | No far jump to flush pipeline | Add `jmp 0x08:protected_mode_entry` |\n| Triple fault when accessing memory above 1MB | A20 not enabled | Enable A20 via port 0x92 or keyboard controller |\n| Garbage on screen | Wrong VGA address or attribute bytes | Verify `0xB8000` and check color encoding |\n| Kernel hangs, no output | Serial not initialized or BSS not zeroed | Check serial_init() call order |\n| Linker error: undefined references | Missing freestanding flags | Use `-ffreestanding -nostdlib` |\n\n**Debugging with GDB**:\n```bash\nqemu-system-i386 -drive format=raw,file=os.img -serial stdio -s -S\n# In another terminal:\ngdb\n(gdb) target remote localhost:1234\n(gdb) break *0x7C00      # Break at bootloader entry\n(gdb) break *0x100000    # Break at kernel entry\n(gdb) continue\n```\n\n---\n\n## Knowledge Cascade\n\nYou've built the bootstrap layer of an operating system. Here's where this knowledge connects:\n\n**→ Page Tables (Milestone 3)**: The GDT you configured uses flat addressing (base=0, limit=4GB). This means segmentation does nothing—every linear address passes through unchanged. When you enable paging, page tables become the sole translation mechanism. The GDT stays the same; CR3 points to a page directory instead.\n\n**→ ELF Loaders (Cross-Domain: Compilers and Linkers)**: Your linker script places `.text`, `.data`, and `.bss` at specific addresses. This is exactly what an ELF loader does when loading a userspace program—it reads section headers and maps them to virtual addresses. You're implementing the same logic that `/lib/ld-linux.so` performs for every executable.\n\n**→ UEFI vs. BIOS (Cross-Domain: Firmware Security)**: Modern systems use UEFI instead of BIOS. UEFI starts the CPU in protected mode (or long mode) with paging enabled—no real mode transition needed. But UEFI still requires GDT and page table configuration. Secure Boot adds cryptographic verification: the firmware checks signatures on the bootloader before executing it. The same boot chain you built, but with cryptographic attestation.\n\n**→ Virtualization (Cross-Domain: Cloud Infrastructure)**: Hypervisors like KVM and Xen virtualize the same hardware you're programming. When a VM writes to its GDT, the hypervisor intercepts the `lgdt` instruction and maintains a \"shadow GDT\" or uses hardware-assisted virtualization (VMX/SVM). The VM's CR3 points to guest-physical pages; the hypervisor maintains nested page tables (EPT/NPT) that translate guest-physical to host-physical addresses. You're building the same translation layers that hypervisors virtualize.\n\n**→ JIT Compilation (Cross-Domain: Language Runtimes)**: When a JIT compiler generates machine code at runtime, it must write code bytes to memory and then execute them. This requires understanding memory protection: the page must be writable to store the code, then executable to run it. The same segment descriptor flags (readable, writable, executable) you configured in the GDT apply to page table entries. Modern systems use W^X (write XOR execute) protection, requiring mprotect() calls to change page permissions—directly manipulating the same hardware flags you're setting up.\n\n---\n\n[[CRITERIA_JSON: {\"milestone_id\": \"build-os-m1\", \"criteria\": [\"Bootloader fits in 512 bytes (MBR) or uses a two-stage approach with stage1 in MBR loading stage2 from disk\", \"Bootloader reads kernel binary from disk using BIOS INT 13h and loads it to physical address 0x100000 (1MB mark)\", \"GDT configured with 5 entries: null descriptor, kernel code (ring 0, base=0, limit=4GB, executable+readable), kernel data (ring 0, base=0, limit=4GB, writable), user code (ring 3), user data (ring 3)\", \"Protected mode entered by setting CR0.PE bit after loading GDTR, followed by a far jump to kernel code segment to flush the pipeline\", \"Segment registers DS, ES, FS, GS, SS loaded with kernel data segment selector (0x10) after the far jump to protected mode\", \"Kernel entry point (assembly) zeroes BSS section from __bss_start to __bss_end and calls kernel_main()\", \"VGA text mode driver writes characters with foreground/background color attributes to memory-mapped buffer at 0xB8000\", \"Serial port COM1 (0x3F8) initialized for debug output with kprintf-like function outputting to both VGA and serial\", \"Kernel boots successfully in QEMU displaying welcome message on screen and serial console\"]}]\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-os-m2 -->\n# Milestone 2: Interrupts, Exceptions, and Keyboard\n\n## The Heartbeat of a Reactive System\n\nYour kernel boots. It displays a welcome message. And then... it sits there. Frozen. Not because it crashed—it's just waiting. Waiting for you to type something. Waiting for time to pass. Waiting for the hardware to signal that something happened.\n\nThis milestone transforms your kernel from a passive program into a reactive system. The mechanism is **interrupts**: hardware signals that pause whatever code is running, jump to a handler you define, and then resume. The CPU does this automatically—you just need to tell it *where* to jump.\n\n### The Fundamental Tension\n\n**Constraint 1: Asynchronous Events Demand Immediate Response**\n\nThe keyboard doesn't wait for your code to poll it. When you press a key, the keyboard controller generates an electrical signal that must be handled *now*—the scancode buffer is tiny, and missed keystrokes are lost forever. The timer doesn't ask permission before ticking. Hardware is asynchronous, and your code must be ready.\n\n**Constraint 2: The CPU Pushes Minimal State**\n\nWhen an interrupt fires, the CPU pushes exactly three things: `EIP` (instruction pointer), `CS` (code segment), and `EFLAGS` (processor flags). That's it. Your handler receives control with *all general-purpose registers containing garbage from the interrupted code*. If you modify `EAX` without saving it first, you've corrupted whatever the interrupted code was doing.\n\n**Constraint 3: The PIC's Default Mapping Is Broken**\n\nThe 8259 Programmable Interrupt Controller maps IRQ0-7 to CPU vectors 8-15 by default. But vectors 8-15 are reserved for CPU exceptions—vector 8 is the Double Fault! Without remapping, a timer tick looks exactly like a catastrophic system failure.\n\n**Constraint 4: EOI Is Not Optional**\n\nThe PIC tracks which interrupts are \"in service.\" After your handler finishes, you *must* send End of Interrupt (EOI). Without it, the PIC blocks all lower-priority interrupts forever. The system doesn't crash—it just stops responding to input.\n\n---\n\n## The Revelation: Interrupts Are Not Function Pointers\n\n{{DIAGRAM:diag-idt-entry-layout}}\n\nIf you've written event-driven code in userspace, you might think interrupts work like this:\n\n```c\n// WRONG MENTAL MODEL\nvoid on_timer() { tick_count++; }\nvoid on_keyboard() { read_key(); }\n\nregister_callback(TIMER_IRQ, on_timer);\nregister_callback(KEYBOARD_IRQ, on_keyboard);\n```\n\nThis is a comforting abstraction, but it hides critical details that will crash your kernel:\n\n1. **The IDT contains gate descriptors, not function pointers.** Each 8-byte entry specifies a handler address, a code segment selector, privilege level, and gate type (interrupt vs. trap). The CPU validates all of this before jumping.\n\n2. **The CPU pushes an error code for some exceptions.** Exceptions 8, 10, 11, 12, 13, 14, 17, 21, 29, and 30 push an additional error code onto the stack. Your handler must account for this, or `iret` will return to garbage.\n\n3. **Interrupts run on the current stack.** If a userspace process has a 4KB stack and your handler uses 5KB of local variables, you've corrupted adjacent memory. This is why kernel code must be stack-disciplined.\n\n4. **Interrupt gates disable interrupts automatically; trap gates don't.** This affects whether your handler can be interrupted by a higher-priority IRQ.\n\nLet's build the real thing.\n\n---\n\n## Stage 1: The Interrupt Descriptor Table\n\nThe IDT is an array of 256 gate descriptors. Each descriptor tells the CPU: \"when interrupt N happens, jump to this address in this code segment.\"\n\n```c\n/* idt.h */\n#define IDT_ENTRIES 256\n\ntypedef struct {\n    uint16_t offset_low;    // Lower 16 bits of handler address\n    uint16_t selector;      // Kernel code segment selector\n    uint8_t  zero;          // Reserved, must be 0\n    uint8_t  type_attr;     // Gate type, DPL, present bit\n    uint16_t offset_high;   // Upper 16 bits of handler address\n} __attribute__((packed)) idt_entry_t;\n\ntypedef struct {\n    uint16_t limit;\n    uint32_t base;\n} __attribute__((packed)) idt_ptr_t;\n\nvoid idt_init(void);\nvoid idt_set_gate(uint8_t num, uint32_t handler, uint16_t selector, uint8_t flags);\n```\n\nThe `type_attr` byte encodes the gate type and privilege level:\n\n```\nBit 7:    Present (1 = valid gate)\nBits 5-6: DPL (Descriptor Privilege Level) - 00 for kernel\nBit 4:    Storage segment (0 for interrupt/trap gates)\nBits 0-3: Gate type:\n          0xE = 32-bit interrupt gate (disables interrupts on entry)\n          0xF = 32-bit trap gate (keeps interrupts enabled)\n```\n\n```c\n/* idt.c */\n#include \"idt.h\"\n\nstatic idt_entry_t idt[IDT_ENTRIES];\nidt_ptr_t idt_ptr;\n\nvoid idt_set_gate(uint8_t num, uint32_t handler, uint16_t selector, uint8_t flags) {\n    idt[num].offset_low  = handler & 0xFFFF;\n    idt[num].offset_high = (handler >> 16) & 0xFFFF;\n    idt[num].selector    = selector;\n    idt[num].zero        = 0;\n    idt[num].type_attr   = flags;\n}\n\nvoid idt_init(void) {\n    idt_ptr.limit = sizeof(idt) - 1;\n    idt_ptr.base  = (uint32_t)&idt;\n    \n    // Load IDT\n    __asm__ volatile (\"lidt %0\" : : \"m\"(idt_ptr));\n}\n```\n\n---\n\n## Stage 2: Interrupt Handlers and the Stack Frame\n\n\n![Interrupt Stack Frame: CPU-Pushed vs. Handler-Pushed](./diagrams/diag-interrupt-stack-frame.svg)\n\n\nWhen an interrupt fires, the CPU performs this sequence:\n\n1. **Pushes EFLAGS, CS, EIP** (and error code for some exceptions)\n2. **Loads CS:EIP from the IDT entry**\n3. **For interrupt gates: clears the IF flag** (disables interrupts)\n\nYour handler must save *all* registers it will modify, do its work, restore registers, then execute `iret` (not `ret`!).\n\n### The Assembly Wrapper\n\nThe cleanest pattern is an assembly wrapper that saves/restores registers and calls a C function:\n\n```asm\n; interrupt.asm\n[BITS 32]\n\n; Common interrupt stub - saves context, calls C handler, restores context\nextern c_interrupt_handler\n\nglobal isr_common_stub\nisr_common_stub:\n    pusha                    ; Pushes EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI\n    push ds\n    push es\n    push fs\n    push gs\n    \n    mov ax, 0x10             ; Load kernel data segment\n    mov ds, ax\n    mov es, ax\n    mov fs, ax\n    mov gs, ax\n    \n    push esp                 ; Pass stack pointer to C handler\n    call c_interrupt_handler\n    add esp, 4               ; Clean up argument\n    \n    pop gs\n    pop fs\n    pop es\n    pop ds\n    popa\n    add esp, 8               ; Clean up error code and interrupt number\n    iret                     ; Restores EIP, CS, EFLAGS\n```\n\n### CPU Exception Handlers (Vectors 0-31)\n\nCPU exceptions are synchronous—they occur in response to instruction execution. Some push an error code; some don't.\n\n```asm\n; Exception handlers - no error code pushed by CPU\nglobal isr0   ; Divide by zero\nglobal isr1   ; Debug\nglobal isr2   ; NMI\nglobal isr3   ; Breakpoint\n; ... (handlers 0-31)\n\n; Macros for cleaner definition\n%macro ISR_NO_ERROR 1\nglobal isr%1\nisr%1:\n    cli\n    push byte 0            ; Dummy error code to unify stack frame\n    push byte %1           ; Interrupt number\n    jmp isr_common_stub\n%endmacro\n\n%macro ISR_ERROR 1\nglobal isr%1\nisr%1:\n    cli\n    push byte %1           ; Interrupt number (error code already pushed by CPU)\n    jmp isr_common_stub\n%endmacro\n\n; CPU exceptions without error codes\nISR_NO_ERROR 0    ; Divide by zero\nISR_NO_ERROR 1    ; Debug\nISR_NO_ERROR 2    ; Non-maskable interrupt\nISR_NO_ERROR 3    ; Breakpoint\nISR_NO_ERROR 4    ; Overflow\nISR_NO_ERROR 5    ; Bound range exceeded\nISR_NO_ERROR 6    ; Invalid opcode\nISR_NO_ERROR 7    ; Device not available\nISR_NO_ERROR 9    ; Coprocessor segment overrun\n\n; CPU exceptions with error codes (CPU pushes the error code)\nISR_ERROR 8       ; Double fault\nISR_ERROR 10      ; Invalid TSS\nISR_ERROR 11      ; Segment not present\nISR_ERROR 12      ; Stack-segment fault\nISR_ERROR 13      ; General protection fault\nISR_ERROR 14      ; Page fault\n```\n\n\n![CPU Exception Flow: Divide Error to Handler](./diagrams/diag-exception-handling.svg)\n\n\nThe dummy error code for exceptions 0-7, 9, etc. ensures a uniform stack frame. Every handler can use the same restoration code.\n\n### The C Handler\n\n```c\n/* interrupt.c */\n#include \"interrupt.h\"\n#include \"vga.h\"\n\ntypedef struct {\n    uint32_t gs, fs, es, ds;\n    uint32_t edi, esi, ebp, esp, ebx, edx, ecx, eax;\n    uint32_t int_no, err_code;\n    uint32_t eip, cs, eflags;\n    uint32_t useresp, ss;\n} __attribute__((packed)) registers_t;\n\nvoid c_interrupt_handler(registers_t *regs) {\n    if (regs->int_no < 32) {\n        // CPU exception\n        exception_handler(regs);\n    } else if (regs->int_no >= 32 && regs->int_no < 48) {\n        // Hardware IRQ (IRQ0-15 mapped to vectors 32-47)\n        irq_handler(regs);\n    }\n    // Ignore spurious interrupts (int_no >= 48)\n}\n\nstatic const char *exception_messages[] = {\n    \"Division by zero\",\n    \"Debug\",\n    \"Non-maskable interrupt\",\n    \"Breakpoint\",\n    \"Overflow\",\n    \"Bound range exceeded\",\n    \"Invalid opcode\",\n    \"Device not available\",\n    \"Double fault\",\n    \"Coprocessor segment overrun\",\n    \"Invalid TSS\",\n    \"Segment not present\",\n    \"Stack-segment fault\",\n    \"General protection fault\",\n    \"Page fault\",\n    \"Reserved\",\n    // ... 16-31 are reserved\n};\n\nvoid exception_handler(registers_t *regs) {\n    kprintf(\"\\nEXCEPTION: %s (vector %d)\\n\", \n            exception_messages[regs->int_no], regs->int_no);\n    kprintf(\"Error code: 0x%x\\n\", regs->err_code);\n    kprintf(\"EIP: 0x%x, CS: 0x%x, EFLAGS: 0x%x\\n\", \n            regs->eip, regs->cs, regs->eflags);\n    \n    if (regs->int_no == 14) {\n        // Page fault - read CR2 for faulting address\n        uint32_t fault_addr;\n        __asm__ volatile (\"mov %%cr2, %0\" : \"=r\"(fault_addr));\n        kprintf(\"Faulting address: 0x%x\\n\", fault_addr);\n        \n        // Decode error code bits\n        kprintf(\"Present: %d, Write: %d, User: %d\\n\",\n                regs->err_code & 1,\n                (regs->err_code >> 1) & 1,\n                (regs->err_code >> 2) & 1);\n    }\n    \n    // Halt on exception (for now)\n    kprintf(\"System halted.\\n\");\n    __asm__ volatile (\"cli; hlt\");\n}\n```\n\n### Double Fault: The Last Line of Defense\n\nA double fault occurs when an exception happens while the CPU is trying to invoke another exception handler. The most common causes:\n- Stack corruption (handler can't push to stack)\n- Page fault while reading the IDT\n- Invalid gate descriptor\n\nWithout a double fault handler, the CPU triple-faults and resets.\n\n```c\nvoid double_fault_handler(registers_t *regs) {\n    kprintf(\"\\n!!! DOUBLE FAULT !!!\\n\");\n    kprintf(\"This indicates a cascading failure.\\n\");\n    kprintf(\"Error code: 0x%x\\n\", regs->err_code);\n    kprintf(\"Kernel stack may be corrupted.\\n\");\n    kprintf(\"System halted.\\n\");\n    \n    // Don't try to recover - state is undefined\n    while(1) {\n        __asm__ volatile (\"cli; hlt\");\n    }\n}\n```\n\n---\n\n## Stage 3: Remapping the PIC\n\n\n![PIC Remapping: IRQ to Vector Translation](./diagrams/diag-pic-remapping.svg)\n\n\nThe 8259 PIC has two chips: master (IRQ0-7) and slave (IRQ8-15). By default:\n- Master maps IRQ0-7 → vectors 0x08-0x0F\n- Slave maps IRQ8-15 → vectors 0x70-0x77\n\nThis is catastrophic. Vector 8 is the Double Fault exception! A timer tick (IRQ0) would trigger the double fault handler.\n\n**Remap to vectors 32-47** (above the 32 CPU exceptions):\n\n```c\n/* pic.h */\n#define PIC1_COMMAND 0x20    // Master PIC command port\n#define PIC1_DATA    0x21    // Master PIC data port\n#define PIC2_COMMAND 0xA0    // Slave PIC command port\n#define PIC2_DATA    0xA1    // Slave PIC data port\n\n#define PIC_EOI      0x20    // End of Interrupt command\n\nvoid pic_remap(int offset1, int offset2);\nvoid pic_send_eoi(uint8_t irq);\n```\n\nThe PIC is programmed via Initialization Command Words (ICW1-ICW4):\n\n```c\n/* pic.c */\n#include \"pic.h\"\n#include \"port_io.h\"\n\nvoid pic_remap(int offset1, int offset2) {\n    // ICW1: Start initialization, cascade mode, need ICW4\n    outb(PIC1_COMMAND, 0x11);\n    outb(PIC2_COMMAND, 0x11);\n    \n    // ICW2: Vector offset (where IRQs map to)\n    outb(PIC1_DATA, offset1);    // Master: IRQ0-7 → vectors 32-39\n    outb(PIC2_DATA, offset2);    // Slave: IRQ8-15 → vectors 40-47\n    \n    // ICW3: Tell master there's a slave at IRQ2 (bitmask 0x04)\n    //       Tell slave its cascade identity is 2\n    outb(PIC1_DATA, 0x04);\n    outb(PIC2_DATA, 0x02);\n    \n    // ICW4: 8086 mode, normal EOI\n    outb(PIC1_DATA, 0x01);\n    outb(PIC2_DATA, 0x01);\n    \n    // Clear data registers (no IRQs masked)\n    outb(PIC1_DATA, 0x00);\n    outb(PIC2_DATA, 0x00);\n}\n\nvoid pic_send_eoi(uint8_t irq) {\n    if (irq >= 8) {\n        // IRQ came from slave - send EOI to both\n        outb(PIC2_COMMAND, PIC_EOI);\n    }\n    // Always send EOI to master\n    outb(PIC1_COMMAND, PIC_EOI);\n}\n```\n\n### EOI Timing: Why Forgetting It Freezes the System\n\n\n![EOI Timing: Why Forgetting EOI Freezes the System](./diagrams/diag-eoi-timing.svg)\n\n\nThe PIC maintains an In-Service Register (ISR) that tracks which IRQs are being handled. When an IRQ fires:\n1. PIC sets the corresponding bit in ISR\n2. PIC raises INTR to CPU\n3. CPU acknowledges, PIC sends vector number\n4. **PIC now blocks all lower-priority IRQs** until EOI is received\n\nIf your timer handler forgets EOI:\n- IRQ0 is still marked \"in service\"\n- Keyboard (IRQ1, lower priority) is blocked\n- System appears frozen—it's not crashed, just deaf\n\n```c\nvoid irq_handler(registers_t *regs) {\n    uint8_t irq = regs->int_no - 32;  // Convert vector to IRQ number\n    \n    switch (irq) {\n        case 0:\n            timer_handler();\n            break;\n        case 1:\n            keyboard_handler();\n            break;\n        // ... other IRQs\n    }\n    \n    pic_send_eoi(irq);  // CRITICAL: Never forget this!\n}\n```\n\n---\n\n## Stage 4: Timer Interrupt (IRQ0)\n\nThe Programmable Interval Timer (PIT) channel 0 is connected to IRQ0. It can fire at frequencies from ~18 Hz to several MHz.\n\n```c\n/* timer.h */\n#define PIT_CHANNEL0 0x40\n#define PIT_COMMAND  0x43\n#define PIT_FREQUENCY 1193182  // Base frequency in Hz\n\nextern volatile uint64_t timer_ticks;\n\nvoid timer_init(uint32_t frequency);\nvoid timer_handler(void);\n```\n\n```c\n/* timer.c */\n#include \"timer.h\"\n#include \"port_io.h\"\n\nvolatile uint64_t timer_ticks = 0;\n\nvoid timer_init(uint32_t frequency) {\n    // Calculate divisor\n    uint32_t divisor = PIT_FREQUENCY / frequency;\n    \n    // Command byte: channel 0, lobyte/hibyte, square wave mode\n    outb(PIT_COMMAND, 0x36);\n    \n    // Send divisor\n    outb(PIT_CHANNEL0, divisor & 0xFF);        // Low byte\n    outb(PIT_CHANNEL0, (divisor >> 8) & 0xFF); // High byte\n}\n\nvoid timer_handler(void) {\n    timer_ticks++;\n    \n    // Every 100 ticks (1 second at 100Hz), print something\n    if (timer_ticks % 100 == 0) {\n        kprintf(\"Timer: %d seconds\\n\", timer_ticks / 100);\n    }\n}\n```\n\nAt 100 Hz, the timer fires every 10 milliseconds. This will become the heartbeat of your preemptive scheduler in Milestone 4.\n\n---\n\n## Stage 5: PS/2 Keyboard Driver (IRQ1)\n\n{{DIAGRAM:diag-keyboard-scancode}}\n\nThe keyboard controller sends **scancodes**, not ASCII. When you press 'A', you receive scancode 0x1E. When you release 'A', you receive 0x9E (0x1E | 0x80). The relationship between scancodes and ASCII is arbitrary and layout-dependent.\n\n### Scancode to ASCII Translation\n\n```c\n/* keyboard.h */\n#define KEYBOARD_PORT 0x60\n#define KBUFFER_SIZE 256\n\nvoid keyboard_init(void);\nvoid keyboard_handler(void);\nchar keyboard_getchar(void);\n\nextern volatile char keyboard_buffer[];\nextern volatile uint32_t kb_read_pos;\nextern volatile uint32_t kb_write_pos;\n```\n\n```c\n/* keyboard.c */\n#include \"keyboard.h\"\n#include \"port_io.h\"\n\n// US QWERTY scancode table (scancode set 1)\nstatic const char scancode_to_ascii[] = {\n    0,  0, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', 0,  0,\n    'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', 0,  0,\n    'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\\'', '`', 0, '\\\\',\n    'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', 0,  '*', 0, ' '\n};\n\n// Shifted versions\nstatic const char scancode_to_ascii_shift[] = {\n    0,  0, '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', 0,  0,\n    'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '{', '}', 0,  0,\n    'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ':', '\"', '~', 0, '|',\n    'Z', 'X', 'C', 'V', 'B', 'N', 'M', '<', '>', '?', 0,  '*', 0, ' '\n};\n\nvolatile char keyboard_buffer[KBUFFER_SIZE];\nvolatile uint32_t kb_read_pos = 0;\nvolatile uint32_t kb_write_pos = 0;\n\nstatic int shift_pressed = 0;\n\nvoid keyboard_handler(void) {\n    uint8_t scancode = inb(KEYBOARD_PORT);\n    \n    // Check for key release (bit 7 set)\n    if (scancode & 0x80) {\n        // Key released\n        scancode &= 0x7F;\n        if (scancode == 0x2A || scancode == 0x36) {  // Left or right shift\n            shift_pressed = 0;\n        }\n        return;\n    }\n    \n    // Key pressed\n    if (scancode == 0x2A || scancode == 0x36) {\n        shift_pressed = 1;\n        return;\n    }\n    \n    // Translate to ASCII\n    char ascii = shift_pressed ? scancode_to_ascii_shift[scancode] \n                               : scancode_to_ascii[scancode];\n    \n    if (ascii != 0) {\n        // Add to circular buffer\n        keyboard_buffer[kb_write_pos] = ascii;\n        kb_write_pos = (kb_write_pos + 1) % KBUFFER_SIZE;\n    }\n}\n\nchar keyboard_getchar(void) {\n    // Block until a character is available\n    while (kb_read_pos == kb_write_pos) {\n        __asm__ volatile (\"hlt\");  // Wait for interrupt\n    }\n    \n    char c = keyboard_buffer[kb_read_pos];\n    kb_read_pos = (kb_read_pos + 1) % KBUFFER_SIZE;\n    return c;\n}\n```\n\nThe circular buffer handles the asynchronous nature of keyboard input. The interrupt handler produces characters; `keyboard_getchar()` consumes them.\n\n---\n\n## Stage 6: Putting It All Together\n\n```c\n/* main.c */\n#include \"idt.h\"\n#include \"pic.h\"\n#include \"timer.h\"\n#include \"keyboard.h\"\n#include \"vga.h\"\n\nvoid kernel_main(void) {\n    vga_init();\n    kprintf(\"Initializing IDT...\\n\");\n    \n    idt_init();\n    \n    // Set up exception handlers\n    idt_set_gate(0,  (uint32_t)isr0,  0x08, 0x8E);\n    idt_set_gate(1,  (uint32_t)isr1,  0x08, 0x8E);\n    // ... (set all 32 exception handlers)\n    idt_set_gate(14, (uint32_t)isr14, 0x08, 0x8E);  // Page fault\n    idt_set_gate(8,  (uint32_t)isr8,  0x08, 0x8E);  // Double fault\n    \n    // Set up IRQ handlers\n    idt_set_gate(32, (uint32_t)irq0, 0x08, 0x8E);  // Timer\n    idt_set_gate(33, (uint32_t)irq1, 0x08, 0x8E);  // Keyboard\n    // ... (set remaining IRQ handlers)\n    \n    kprintf(\"Remapping PIC...\\n\");\n    pic_remap(32, 40);\n    \n    kprintf(\"Initializing timer at 100Hz...\\n\");\n    timer_init(100);\n    \n    kprintf(\"Initializing keyboard...\\n\");\n    keyboard_init();\n    \n    kprintf(\"Enabling interrupts...\\n\");\n    __asm__ volatile (\"sti\");\n    \n    kprintf(\"System ready. Type something!\\n\");\n    \n    // Echo keyboard input\n    while (1) {\n        char c = keyboard_getchar();\n        if (c == '\\n') {\n            kprintf(\"\\n\");\n        } else if (c >= ' ') {\n            kprintf(\"%c\", c);\n        }\n    }\n}\n```\n\n---\n\n## The Three-Level View: What Happens When You Press a Key\n\n**Level 1 — Application (Your Handler)**:\n```c\nvoid keyboard_handler(void) {\n    uint8_t scancode = inb(KEYBOARD_PORT);\n    // Translate, buffer, process...\n}\n```\nA simple function that reads a byte and processes it.\n\n**Level 2 — Interrupt Controller (PIC)**:\nThe keyboard controller asserts IRQ1. The master PIC:\n1. Checks if IRQ1 is masked (it's not)\n2. Checks if any higher-priority IRQ is in service (none)\n3. Sets bit 1 in the In-Service Register\n4. Raises INTR to the CPU\n5. Waits for CPU acknowledgment\n6. Sends vector 33 to the CPU\n\n**Level 3 — Hardware (CPU and Keyboard Controller)**:\nThe keyboard controller has been buffering your keystroke in a small internal buffer. When you press 'A', it generates scancode 0x1E and stores it in an output buffer at I/O port 0x60. The `inb` instruction reads this port through the I/O bus. The keyboard controller then clears its buffer—if you don't read fast enough, the next keystroke overwrites it.\n\n---\n\n## Hardware Soul: Interrupt Latency\n\nWhen the keyboard generates an interrupt, a chain of events must occur before your handler runs:\n\n| Stage | Latency | Why It Matters |\n|-------|---------|----------------|\n| Keyboard controller → PIC | ~1 µs | Electrical signal propagation |\n| PIC priority arbitration | ~100 ns | PIC checks higher-priority IRQs |\n| CPU interrupt acknowledge | ~50 ns | CPU finishes current instruction |\n| CPU pushes EFLAGS, CS, EIP | ~10 ns | Memory writes |\n| CPU loads IDT entry | ~20 ns | Memory read (may cache miss) |\n| Your handler prologue (pusha) | ~20 ns | Register saves |\n\n**Total latency**: roughly 1-2 microseconds. But if interrupts are disabled (`cli`), the keyboard event sits waiting. If you hold interrupts disabled for 10 ms, you might miss keystrokes—the keyboard buffer is only a few bytes.\n\nThis is why kernel code must minimize time with interrupts disabled. Critical sections should be short, measured in microseconds, not milliseconds.\n\n---\n\n## Common Pitfalls\n\n| Symptom | Likely Cause | Fix |\n|---------|--------------|-----|\n| System hangs after first interrupt | Forgot EOI | Add `pic_send_eoi(irq)` to end of handler |\n| Keyboard doesn't work | PIC not remapped (IRQ1 → vector 9 = Coprocessor error) | Call `pic_remap(32, 40)` before `sti` |\n| Random crashes after interrupts | Not saving/restoring all registers | Use `pusha`/`popa` in assembly stub |\n| Triple fault on exception | Stack frame mismatch (error code handling) | Check ISR_ERROR vs ISR_NO_ERROR macros |\n| Characters repeat infinitely | Not handling break codes (scancode & 0x80) | Check bit 7 to distinguish press/release |\n| Timer fires once, then stops | IRQ0 handler doesn't send EOI | Every IRQ handler must call `pic_send_eoi` |\n\n---\n\n## Knowledge Cascade\n\nYou've made your kernel reactive to hardware. Here's where this connects:\n\n**→ Preemptive Scheduling (Milestone 4)**: The timer interrupt you just built becomes the heartbeat of multitasking. Every timer tick, the scheduler checks if the current process has run long enough, then performs a context switch. The same interrupt mechanism that increments `timer_ticks` will soon save and restore complete process state.\n\n**→ Signal Handling (Cross-Domain: Unix APIs)**: POSIX signals are userspace's interrupt mechanism. When a process receives `SIGINT` (Ctrl+C), the kernel interrupts whatever code is running and jumps to a signal handler the process registered via `sigaction()`. The same \"save state, jump to handler, restore state\" pattern you implemented in `isr_common_stub` is what the kernel does for signal delivery. The `siginfo_t` structure is analogous to your `registers_t`—it captures the interrupted context.\n\n**→ Exception Handling (Cross-Domain: Language Runtimes)**: When C++ throws an exception, the runtime searches for a matching `catch` block by unwinding the stack. This uses CPU exception mechanisms under the hood—specifically, the unwind tables stored in the `.eh_frame` section. A null pointer dereference triggers a page fault; the runtime's page fault handler catches it, throws `std::bad_null_access`, and unwinds. Java's `NullPointerException` works similarly. Your exception handler is the kernel's equivalent of these runtime mechanisms.\n\n**→ Real-Time Systems (Cross-Domain: Embedded)**: In an RTOS, interrupt latency must be bounded and predictable. A hard real-time system might guarantee \"interrupt handler starts within 10 µs.\" This requires careful PIC priority configuration—high-priority interrupts (motor control, sensors) must preempt lower-priority ones (logging, UI). The same PIC priority hierarchy you're using (IRQ0 highest, IRQ7 lowest) is what RTOS engineers tune for their specific hardware.\n\n**→ Game Development (Cross-Domain: Input Latency)**: Frame-perfect input in competitive games requires understanding interrupt latency. When you press a button, the scancode travels through the keyboard controller, USB bus (for modern keyboards), OS input stack, and finally the game's input polling. The game reads input at a specific point in its frame loop—if the interrupt arrives just after polling, the input is delayed by a full frame (16.67 ms at 60 fps). Fighting game developers measure and minimize this latency; some read input in a high-priority thread that wakes on interrupt.\n\n---\n\n[[CRITERIA_JSON: {\"milestone_id\": \"build-os-m2\", \"criteria\": [\"IDT contains 256 entries with entries 0-31 configured for CPU exceptions including divide error, page fault, and general protection fault with descriptive error messages\", \"All interrupt handlers save general-purpose registers (pusha) and segment registers on entry and restore them before iret; handlers for exceptions 8, 10-14 account for the error code pushed by the CPU\", \"PIC 8259 is remapped so IRQ0-7 map to vectors 32-39 and IRQ8-15 map to vectors 40-47, avoiding conflicts with CPU exception vectors 0-31\", \"EOI is sent to the correct PIC (master for IRQ0-7, both master and slave for IRQ8-15) at the end of each IRQ handler before iret\", \"Timer interrupt (IRQ0 via PIT channel 0) fires at a configurable frequency (e.g., 100Hz) and increments a global tick counter on each interrupt\", \"Keyboard interrupt (IRQ1) reads PS/2 scancode from port 0x60, converts to ASCII using a scancode-to-ASCII table, and places characters in a circular keyboard buffer\", \"Double fault handler (exception 8) catches cascading faults, prints diagnostic information including error code, and halts the system instead of allowing a triple fault\", \"Interrupts are enabled (sti) only after IDT is loaded and PIC is remapped and configured\"]}]\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-os-m3 -->\n# Milestone 3: Physical and Virtual Memory Management\n\n## The Memory Illusion\n\nYour kernel boots. It runs code, handles interrupts, responds to keyboard input. But it has a secret vulnerability: everything runs in the same memory space. One wild pointer write could corrupt the kernel's own data structures. There's no isolation, no protection, no virtual memory.\n\nMore fundamentally, you have no dynamic memory allocation. Every buffer, every structure, every piece of data must be statically allocated at compile time. Want to load a file? You need to know its maximum size beforehand. Want to support multiple processes? You need to pre-allocate space for all of them.\n\nThis milestone solves both problems. You'll build a **physical frame allocator** that tracks which 4KB blocks of RAM are available, implement **two-level page tables** that translate virtual addresses to physical frames, and create a **kernel heap allocator** that provides `kmalloc()` and `kfree()`. By the end, your kernel will have virtual memory—the foundation for process isolation, demand paging, and every advanced memory feature.\n\n### The Fundamental Tension\n\n**Constraint 1: The 4KB Page Boundary**\n\nThe hardware page table enforces 4KB granularity. You cannot allocate 100 bytes of physical memory directly—you allocate a 4096-byte frame and manage the waste. Small allocations fragment memory; large allocations waste it. Your allocator must balance both.\n\n**Constraint 2: The Bootstrap Problem**\n\nEnabling paging is not a simple flag flip. When you set CR0.PG, the CPU immediately starts translating *every* memory access through page tables—including the very next instruction. If that instruction's address isn't properly mapped, you page fault immediately. The CPU doesn't pause, doesn't transition gracefully. You must identity-map the code you're currently executing *before* enabling paging.\n\n**Constraint 3: The TLB Cache**\n\nThe Translation Lookaside Buffer (TLB) caches page table entries. It's essential for performance—without it, every memory access would require two additional memory reads (page directory + page table). But the TLB doesn't automatically invalidate when you modify page tables. Change a mapping without flushing, and the CPU serves stale translations. Debugging this is painful: the code looks correct, the page tables are correct, but the CPU sees the old mapping.\n\n**Constraint 4: Physical Memory Is a Finite Resource**\n\nYour physical frame allocator must track every 4KB block: which are used by the kernel binary, which hold page tables, which contain multiboot data, and which are truly available. Allocating a frame that's already in use corrupts whatever was there. Double-freeing a frame causes subtle corruption later. The allocator must be bulletproof.\n\n---\n\n## The Revelation: Paging Is Not Just a Lookup Table\n\n{{DIAGRAM:diag-page-table-hierarchy}}\n\nIf you've used `malloc()` in userspace, you might think memory allocation is simple: ask for bytes, get a pointer, free it when done. The kernel's memory subsystem is far more complex:\n\n1. **Virtual addresses are not physical addresses.** After paging is enabled, address `0xC0100000` might map to physical frame `0x100000`, or it might not be mapped at all. The page tables define this translation, and they can change at runtime.\n\n2. **The TLB caches translations, not permissions.** When you modify a page table entry—even just to change the writable bit—the TLB still contains the old entry. The CPU will allow writes to a now-read-only page until you flush that TLB entry.\n\n3. **Higher-half mapping requires linker script cooperation.** Your kernel code must be compiled to run at virtual address `0xC0000000+`, but it's loaded at physical address `0x100000`. The linker script uses virtual addresses; the bootloader loads to physical addresses. Until paging is enabled, you're executing code at addresses that don't match what the compiler expected.\n\n4. **Page faults are features, not just errors.** A page fault tells you *which* address failed and *why* (not present, write violation, user access). This is the mechanism behind demand paging (load from disk on fault), copy-on-write (fault on write, then copy), and memory-mapped files.\n\nLet's build this layer by layer.\n\n---\n\n## Stage 1: Physical Memory Map\n\nBefore you can allocate memory, you must know what exists. The BIOS provides a memory map via INT 15h/E820 (real mode) or multiboot info (if using GRUB). This tells you which address ranges are usable RAM, which are reserved (BIOS, ACPI), and which are memory-mapped I/O.\n\n\n![Physical Memory Map: E820/Multiboot Regions](./diagrams/diag-physical-memory-map.svg)\n\n\n```c\n/* memory_map.h */\n\ntypedef enum {\n    MEMORY_TYPE_USABLE = 1,\n    MEMORY_TYPE_RESERVED = 2,\n    MEMORY_TYPE_ACPI_RECLAIMABLE = 3,\n    MEMORY_TYPE_ACPI_NVS = 4,\n    MEMORY_TYPE_BAD = 5\n} memory_type_t;\n\ntypedef struct {\n    uint64_t base;\n    uint64_t length;\n    memory_type_t type;\n} memory_region_t;\n\n#define MAX_MEMORY_REGIONS 64\n\nextern memory_region_t memory_map[MAX_MEMORY_REGIONS];\nextern int memory_map_count;\n\nvoid memory_map_init(multiboot_info_t *mbi);\nvoid memory_map_print(void);\n```\n\nIf you're using multiboot (GRUB loads your kernel), the bootloader passes a pointer to multiboot info in EBX:\n\n```c\n/* memory_map.c */\n#include \"memory_map.h\"\n#include \"multiboot.h\"\n#include \"kprintf.h\"\n\nmemory_region_t memory_map[MAX_MEMORY_REGIONS];\nint memory_map_count = 0;\n\nvoid memory_map_init(multiboot_info_t *mbi) {\n    if (!(mbi->flags & (1 << 6))) {\n        kprintf(\"ERROR: No memory map from bootloader!\\n\");\n        return;\n    }\n    \n    multiboot_memory_map_t *entry = (multiboot_memory_map_t *)mbi->mmap_addr;\n    uint32_t end = mbi->mmap_addr + mbi->mmap_length;\n    \n    while ((uint32_t)entry < end && memory_map_count < MAX_MEMORY_REGIONS) {\n        memory_map[memory_map_count].base = entry->addr;\n        memory_map[memory_map_count].length = entry->len;\n        memory_map[memory_map_count].type = (memory_type_t)entry->type;\n        \n        kprintf(\"Region %d: 0x%x%08x - 0x%x%08x (%s)\\n\",\n                memory_map_count,\n                (uint32_t)(entry->addr >> 32), (uint32_t)entry->addr,\n                (uint32_t)((entry->addr + entry->len) >> 32), \n                (uint32_t)(entry->addr + entry->len),\n                entry->type == 1 ? \"Usable\" : \"Reserved\");\n        \n        memory_map_count++;\n        entry = (multiboot_memory_map_t *)((uint32_t)entry + entry->size + 4);\n    }\n}\n```\n\n> **The E820 Memory Map**\n>\n> The BIOS INT 15h/E820 function returns a list of memory regions. Each entry contains:\n> - Base address (64-bit)\n> - Length (64-bit)\n> - Type (usable, reserved, ACPI, etc.)\n>\n> The kernel must parse this map to know which physical addresses contain actual RAM. The first megabyte is typically reserved (BIOS data, VGA memory). Usable RAM starts around 1MB but may have holes (ACPI tables, memory-mapped I/O). A typical 1GB system might have 3-5 distinct usable regions.\n\nThe memory map tells you *what exists*. Now you need to track *what's available*.\n\n---\n\n## Stage 2: Physical Frame Allocator\n\nThe physical frame allocator manages 4KB blocks of physical memory. Two common approaches:\n\n**Bitmap**: One bit per frame. Bit = 0 means free, bit = 1 means allocated. Simple, constant-time allocation, but requires O(memory_size / 32768) bytes of metadata.\n\n**Free list**: Each free frame contains a pointer to the next free frame. Zero overhead for allocated frames, but allocation is O(1) only if you don't need contiguous blocks.\n\nWe'll use a bitmap for simplicity and predictable performance.\n\n```c\n/* pmm.h */\n#define PAGE_SIZE 4096\n#define FRAME_SIZE 4096\n\n// Bitmap: 1 bit per frame\n// For 4GB of memory: 4GB / 4KB = 1M frames = 128KB bitmap\n#define MAX_FRAMES (1024 * 1024)  // 1M frames for 4GB\n#define BITMAP_SIZE (MAX_FRAMES / 8)\n\nextern uint32_t physical_frame_bitmap[BITMAP_SIZE / 4];\n\n#define FRAME_INDEX(addr) ((addr) / FRAME_SIZE)\n#define BIT_OFFSET(index) ((index) % 32)\n#define WORD_OFFSET(index) ((index) / 32)\n\nvoid pmm_init(memory_region_t *regions, int count);\nuint32_t pmm_alloc_frame(void);\nvoid pmm_free_frame(uint32_t frame_addr);\nvoid pmm_mark_used(uint32_t frame_addr);\nvoid pmm_mark_free(uint32_t frame_addr);\n```\n\n```c\n/* pmm.c */\n#include \"pmm.h\"\n#include \"memory_map.h\"\n#include \"kprintf.h\"\n\nuint32_t physical_frame_bitmap[BITMAP_SIZE / 4];\nstatic uint32_t total_frames = 0;\nstatic uint32_t used_frames = 0;\n\nstatic inline void set_bit(uint32_t index) {\n    physical_frame_bitmap[WORD_OFFSET(index)] |= (1 << BIT_OFFSET(index));\n}\n\nstatic inline void clear_bit(uint32_t index) {\n    physical_frame_bitmap[WORD_OFFSET(index)] &= ~(1 << BIT_OFFSET(index));\n}\n\nstatic inline int test_bit(uint32_t index) {\n    return physical_frame_bitmap[WORD_OFFSET(index)] & (1 << BIT_OFFSET(index));\n}\n\nvoid pmm_init(memory_region_t *regions, int count) {\n    // Initialize all frames as reserved (1 = used)\n    for (uint32_t i = 0; i < BITMAP_SIZE / 4; i++) {\n        physical_frame_bitmap[i] = 0xFFFFFFFF;\n    }\n    \n    // Find the highest addressable frame\n    uint64_t max_addr = 0;\n    for (int i = 0; i < count; i++) {\n        uint64_t end = regions[i].base + regions[i].length;\n        if (end > max_addr) max_addr = end;\n    }\n    total_frames = (uint32_t)(max_addr / FRAME_SIZE);\n    if (total_frames > MAX_FRAMES) total_frames = MAX_FRAMES;\n    \n    // Mark usable regions as free\n    for (int i = 0; i < count; i++) {\n        if (regions[i].type != MEMORY_TYPE_USABLE) continue;\n        \n        uint64_t addr = regions[i].base;\n        uint64_t end = addr + regions[i].length;\n        \n        // Align to frame boundaries\n        addr = (addr + FRAME_SIZE - 1) & ~(FRAME_SIZE - 1);\n        end = end & ~(FRAME_SIZE - 1);\n        \n        for (; addr < end; addr += FRAME_SIZE) {\n            uint32_t index = FRAME_INDEX((uint32_t)addr);\n            if (index < total_frames) {\n                clear_bit(index);\n            }\n        }\n    }\n    \n    // Mark frames 0-1MB as used (BIOS, VGA, kernel load area)\n    // The kernel binary and page tables will also be marked used\n    for (uint32_t addr = 0; addr < 0x100000; addr += FRAME_SIZE) {\n        pmm_mark_used(addr);\n    }\n    \n    kprintf(\"PMM: %d total frames, %d available\\n\", \n            total_frames, total_frames - used_frames);\n}\n\nuint32_t pmm_alloc_frame(void) {\n    // Linear search for first free frame\n    for (uint32_t i = 0; i < total_frames; i++) {\n        if (!test_bit(i)) {\n            set_bit(i);\n            used_frames++;\n            return i * FRAME_SIZE;\n        }\n    }\n    kprintf(\"PMM: Out of memory!\\n\");\n    return 0;  // Out of memory\n}\n\nvoid pmm_free_frame(uint32_t frame_addr) {\n    uint32_t index = FRAME_INDEX(frame_addr);\n    if (index >= total_frames) {\n        kprintf(\"PMM: Invalid frame free: 0x%x\\n\", frame_addr);\n        return;\n    }\n    if (!test_bit(index)) {\n        kprintf(\"PMM: Double free detected: 0x%x\\n\", frame_addr);\n        return;\n    }\n    clear_bit(index);\n    used_frames--;\n}\n\nvoid pmm_mark_used(uint32_t frame_addr) {\n    uint32_t index = FRAME_INDEX(frame_addr);\n    if (index < total_frames && !test_bit(index)) {\n        set_bit(index);\n        used_frames++;\n    }\n}\n```\n\n> **Frame vs. Page: Terminology**\n>\n> A **frame** is a physical 4KB block of RAM. A **page** is a virtual 4KB block of address space. Page tables map pages to frames. The physical frame allocator gives you frames; the page table maps them to pages; the heap allocator carves pages into smaller blocks.\n\n---\n\n## Stage 3: Two-Level Page Tables\n\nx86 uses a two-level hierarchical page table structure:\n\n1. **Page Directory (PD)**: 1024 entries, each pointing to a page table\n2. **Page Table (PT)**: 1024 entries, each pointing to a 4KB frame\n\nA virtual address is split into three parts:\n- Bits 31-22: Page Directory Index (which PD entry)\n- Bits 21-12: Page Table Index (which PT entry)\n- Bits 11-0: Page Offset (offset within the 4KB frame)\n\n{{DIAGRAM:diag-pde-pte-layout}}\n\n```c\n/* vmm.h */\n\n// Page Directory Entry (PDE) and Page Table Entry (PTE) flags\n#define PAGE_PRESENT    (1 << 0)\n#define PAGE_WRITABLE   (1 << 1)\n#define PAGE_USER       (1 << 2)\n#define PAGE_WRITETHROUGH (1 << 3)\n#define PAGE_CACHE_DISABLE (1 << 4)\n#define PAGE_ACCESSED   (1 << 5)\n#define PAGE_DIRTY      (1 << 6)   // PTE only\n#define PAGE_SIZE_4MB   (1 << 7)   // PDE only (for 4MB pages)\n#define PAGE_GLOBAL     (1 << 8)\n\ntypedef uint32_t page_table_entry_t;\ntypedef uint32_t page_directory_entry_t;\n\ntypedef struct {\n    page_table_entry_t entries[1024];\n} __attribute__((aligned(4096))) page_table_t;\n\ntypedef struct {\n    page_directory_entry_t entries[1024];\n} __attribute__((aligned(4096))) page_directory_t;\n\nextern page_directory_t *kernel_page_directory;\n\nvoid vmm_init(void);\nvoid vmm_map_page(page_directory_t *pd, uint32_t virtual_addr, \n                  uint32_t physical_addr, uint32_t flags);\nvoid vmm_unmap_page(page_directory_t *pd, uint32_t virtual_addr);\nuint32_t vmm_get_physical(page_directory_t *pd, uint32_t virtual_addr);\nvoid vmm_enable_paging(void);\n```\n\n```c\n/* vmm.c */\n#include \"vmm.h\"\n#include \"pmm.h\"\n#include \"kprintf.h\"\n\npage_directory_t *kernel_page_directory;\nstatic page_table_t *page_tables[1024];  // Track allocated page tables\n\nstatic inline uint32_t pd_index(uint32_t addr) {\n    return (addr >> 22) & 0x3FF;\n}\n\nstatic inline uint32_t pt_index(uint32_t addr) {\n    return (addr >> 12) & 0x3FF;\n}\n\nstatic inline uint32_t page_offset(uint32_t addr) {\n    return addr & 0xFFF;\n}\n\n// Extract physical address from PDE/PTE (bits 12-31)\nstatic inline uint32_t frame_addr(uint32_t entry) {\n    return entry & 0xFFFFF000;\n}\n\nvoid vmm_init(void) {\n    // Allocate page directory\n    uint32_t pd_frame = pmm_alloc_frame();\n    kernel_page_directory = (page_directory_t *)pd_frame;\n    \n    // Zero the page directory\n    for (int i = 0; i < 1024; i++) {\n        kernel_page_directory->entries[i] = 0;\n    }\n    \n    // Initialize page table tracking\n    for (int i = 0; i < 1024; i++) {\n        page_tables[i] = NULL;\n    }\n    \n    kprintf(\"VMM: Page directory at 0x%x\\n\", (uint32_t)kernel_page_directory);\n}\n\nvoid vmm_map_page(page_directory_t *pd, uint32_t virtual_addr, \n                  uint32_t physical_addr, uint32_t flags) {\n    // Align addresses to page boundaries\n    virtual_addr &= 0xFFFFF000;\n    physical_addr &= 0xFFFFF000;\n    \n    uint32_t pd_idx = pd_index(virtual_addr);\n    uint32_t pt_idx = pt_index(virtual_addr);\n    \n    // Check if page table exists\n    page_table_t *pt;\n    if (!(pd->entries[pd_idx] & PAGE_PRESENT)) {\n        // Allocate new page table\n        uint32_t pt_frame = pmm_alloc_frame();\n        pt = (page_table_t *)pt_frame;\n        \n        // Zero the page table\n        for (int i = 0; i < 1024; i++) {\n            pt->entries[i] = 0;\n        }\n        \n        // Link page table in page directory\n        pd->entries[pd_idx] = pt_frame | PAGE_PRESENT | PAGE_WRITABLE | (flags & PAGE_USER);\n        page_tables[pd_idx] = pt;\n    } else {\n        pt = (page_table_t *)frame_addr(pd->entries[pd_idx]);\n    }\n    \n    // Map the page\n    pt->entries[pt_idx] = physical_addr | flags | PAGE_PRESENT;\n    \n    // Invalidate TLB entry for this page\n    __asm__ volatile (\"invlpg %0\" : : \"m\"(virtual_addr));\n}\n\nvoid vmm_unmap_page(page_directory_t *pd, uint32_t virtual_addr) {\n    virtual_addr &= 0xFFFFF000;\n    \n    uint32_t pd_idx = pd_index(virtual_addr);\n    uint32_t pt_idx = pt_index(virtual_addr);\n    \n    if (!(pd->entries[pd_idx] & PAGE_PRESENT)) {\n        return;  // Page table doesn't exist\n    }\n    \n    page_table_t *pt = (page_table_t *)frame_addr(pd->entries[pd_idx]);\n    pt->entries[pt_idx] = 0;  // Remove mapping\n    \n    // Invalidate TLB entry\n    __asm__ volatile (\"invlpg %0\" : : \"m\"(virtual_addr));\n}\n```\n\n> **Why Two Levels?**\n>\n> A single-level page table for 4GB of address space would require 1M entries (4MB of memory). By splitting into two levels, you only allocate page tables for regions you actually use. A process using 8MB of memory needs only 1 page directory (4KB) + 2 page tables (8KB) = 12KB of page table structures, not 4MB.\n\n---\n\n## Stage 4: Identity Mapping and Higher-Half Kernel\n\n{{DIAGRAM:diag-identity-higher-half}}\n\nThe critical insight: **before enabling paging, you must identity-map the code that enables paging**. Otherwise, the moment you set CR0.PG, the CPU tries to fetch the next instruction using page tables, fails, and triple-faults.\n\n### The Mapping Strategy\n\nWe need two mappings:\n\n1. **Identity map (0x00000000 → 0x00000000)**: Covers the first 4MB (kernel, VGA, boot data). Required during the paging enable transition.\n\n2. **Higher-half map (0xC0000000 → 0x00000000)**: The kernel's permanent home. After setup, we remove the identity map and run purely from higher-half addresses.\n\n```c\n/* higher_half.c */\n#include \"vmm.h\"\n#include \"pmm.h\"\n#include \"kprintf.h\"\n\n#define KERNEL_PHYSICAL_START 0x100000\n#define KERNEL_VIRTUAL_START  0xC0000000\n#define IDENTITY_MAP_END      0x400000   // 4MB\n\nvoid setup_page_tables(void) {\n    vmm_init();\n    \n    // Identity map first 4MB (kernel + VGA + boot data)\n    kprintf(\"Mapping identity region: 0x0 - 0x%x\\n\", IDENTITY_MAP_END);\n    for (uint32_t addr = 0; addr < IDENTITY_MAP_END; addr += PAGE_SIZE) {\n        // VGA region at 0xB8000 - accessible from kernel\n        // Kernel at 0x100000 - accessible from kernel\n        vmm_map_page(kernel_page_directory, addr, addr, \n                     PAGE_WRITABLE);\n    }\n    \n    // Higher-half mapping: 0xC0000000+ maps to 0x0+\n    kprintf(\"Mapping higher-half: 0xC0000000 - 0xC0400000\\n\");\n    for (uint32_t offset = 0; offset < IDENTITY_MAP_END; offset += PAGE_SIZE) {\n        uint32_t virtual_addr = KERNEL_VIRTUAL_START + offset;\n        uint32_t physical_addr = offset;\n        vmm_map_page(kernel_page_directory, virtual_addr, physical_addr, \n                     PAGE_WRITABLE);\n    }\n    \n    kprintf(\"Page tables configured.\\n\");\n}\n```\n\n### The Linker Script Dance\n\nThe linker script must place sections at their *virtual* addresses (0xC0000000+), but the kernel binary is loaded at *physical* addresses (0x100000). This is controlled via the `AT()` directive:\n\n```ld\n/* linker.ld */\nENTRY(kernel_entry)\n\nSECTIONS\n{\n    /* Kernel starts at 0xC0100000 (virtual), loaded at 0x100000 (physical) */\n    . = 0xC0100000;\n    \n    /* Store the physical load address */\n    kernel_physical_start = . - 0xC000000;\n    \n    .text ALIGN(4K) : AT(ADDR(.text) - 0xC000000)\n    {\n        *(.multiboot)\n        *(.text)\n    }\n    \n    .rodata ALIGN(4K) : AT(ADDR(.rodata) - 0xC000000)\n    {\n        *(.rodata)\n    }\n    \n    .data ALIGN(4K) : AT(ADDR(.data) - 0xC000000)\n    {\n        *(.data)\n    }\n    \n    .bss ALIGN(4K) : AT(ADDR(.bss) - 0xC000000)\n    {\n        __bss_start = .;\n        *(.COMMON)\n        *(.bss)\n        __bss_end = .;\n    }\n    \n    kernel_physical_end = . - 0xC000000;\n}\n```\n\nThe `AT()` directive tells the linker: \"this section runs at the virtual address, but load it at the physical address.\" The bootloader loads the binary to physical addresses; after paging is enabled, the CPU accesses it via virtual addresses.\n\n---\n\n## Stage 5: Enabling Paging\n\n\n![TLB Coherency: invlpg vs. CR3 Reload](./diagrams/diag-tlb-flush.svg)\n\n\n```c\n/* paging_enable.c */\n#include \"vmm.h\"\n#include \"kprintf.h\"\n\nextern uint32_t kernel_physical_start;\nextern uint32_t kernel_physical_end;\n\nvoid enable_paging(void) {\n    uint32_t pd_physical = (uint32_t)kernel_page_directory;\n    \n    kprintf(\"Loading CR3 with page directory at 0x%x\\n\", pd_physical);\n    \n    // Load page directory base into CR3\n    __asm__ volatile (\"mov %0, %%cr3\" : : \"r\"(pd_physical));\n    \n    // Enable paging by setting CR0.PG (bit 31)\n    uint32_t cr0;\n    __asm__ volatile (\"mov %%cr0, %0\" : \"=r\"(cr0));\n    cr0 |= (1 << 31);  // Set PG bit\n    __asm__ volatile (\"mov %0, %%cr0\" : : \"r\"(cr0));\n    \n    kprintf(\"Paging enabled!\\n\");\n    \n    // Now running with virtual addresses\n    // Can safely jump to higher-half code\n}\n```\n\n### The Assembly Transition\n\nThe trickiest part: the code that enables paging must handle the address transition. Before paging, you're at physical address. After paging, you're at virtual address. A normal function call would use the wrong return address.\n\n```asm\n; paging_transition.asm\n[BITS 32]\n\nextern enable_paging\nextern kernel_main_higher_half\n\nglobal paging_transition\npaging_transition:\n    ; We're still running at physical addresses (e.g., 0x100000)\n    \n    ; Set up page tables (still using physical addresses)\n    call setup_page_tables\n    \n    ; Enable paging (this function uses physical addresses internally)\n    call enable_paging\n    \n    ; CRITICAL: Now paging is enabled. The return address pushed by\n    ; the 'call enable_paging' is a PHYSICAL address, but we're now\n    ; executing at VIRTUAL addresses. We need to jump to the higher half.\n    \n    ; Jump to higher-half kernel main\n    ; This must be an absolute jump to the virtual address\n    mov eax, kernel_main_higher_half\n    jmp eax\n    \n    ; Should never reach here\n.halt:\n    hlt\n    jmp .halt\n```\n\n```c\n/* main.c - after paging is enabled */\nvoid kernel_main_higher_half(void) {\n    // Now we're running at 0xC0100000+\n    // All addresses are virtual\n    \n    kprintf(\"Kernel running in higher half!\\n\");\n    kprintf(\"Kernel virtual start: 0xC0100000\\n\");\n    kprintf(\"VGA still accessible at 0xB8000 (identity mapped)\\n\");\n    \n    // Initialize heap, start scheduler, etc.\n    kernel_main_continued();\n}\n```\n\n---\n\n## Stage 6: TLB Management\n\n\n![TLB Coherency: invlpg vs. CR3 Reload](./diagrams/diag-tlb-flush.svg)\n\n\nThe TLB caches page table translations. It's a small, fast cache (typically 32-64 entries) that avoids the two-level page table walk on every memory access.\n\n**Problem**: The TLB doesn't automatically invalidate when you modify page tables.\n\n```c\n// WRONG: Modify page table without flushing\npt->entries[pt_idx] = 0;  // Unmap the page\n\n// The TLB still contains the old translation!\n// Accessing the virtual address will succeed (stale entry)\n// until something causes a TLB miss or flush\n```\n\n**Solutions**:\n\n1. **`invlpg`**: Invalidate a single TLB entry\n   ```c\n   __asm__ volatile (\"invlpg %0\" : : \"m\"(virtual_addr));\n   ```\n\n2. **CR3 reload**: Invalidate all TLB entries (except global pages)\n   ```c\n   __asm__ volatile (\"mov %0, %%cr3\" : : \"r\"(pd_physical));\n   ```\n\n3. **`invlpg` is preferred** when modifying a single page—it's faster than a full CR3 reload.\n\n> **Global Pages**\n>\n> Pages marked with the `PAGE_GLOBAL` flag aren't flushed on CR3 reload. This is useful for kernel code that's mapped in every process's address space—the kernel's TLB entries persist across context switches, improving performance.\n\n---\n\n## Stage 7: Page Fault Handler\n\n{{DIAGRAM:diag-page-fault-handling}}\n\nPage faults (exception 14) are your window into the memory subsystem. When a page fault occurs:\n\n1. **CR2** contains the faulting virtual address (not the instruction address!)\n2. **Error code** (pushed by CPU) tells you why:\n   - Bit 0 (P): 0 = page not present, 1 = protection violation\n   - Bit 1 (W): 0 = read access, 1 = write access\n   - Bit 2 (U): 0 = kernel mode, 1 = user mode\n   - Bit 3 (R): 1 = reserved bit set in page table\n   - Bit 4 (I): 1 = instruction fetch (NX bit violation)\n\n```c\n/* page_fault.c */\n#include \"interrupt.h\"\n#include \"kprintf.h\"\n\nvoid page_fault_handler(registers_t *regs) {\n    uint32_t faulting_addr;\n    __asm__ volatile (\"mov %%cr2, %0\" : \"=r\"(faulting_addr));\n    \n    uint32_t err = regs->err_code;\n    \n    kprintf(\"\\n===== PAGE FAULT =====\\n\");\n    kprintf(\"Faulting address: 0x%x\\n\", faulting_addr);\n    kprintf(\"Error code: 0x%x\\n\", err);\n    \n    kprintf(\"Reason: \");\n    if (!(err & 0x1)) {\n        kprintf(\"Page not present\\n\");\n    } else if (err & 0x2) {\n        kprintf(\"Write to read-only page\\n\");\n    } else if (err & 0x4) {\n        kprintf(\"User access to kernel page\\n\");\n    } else if (err & 0x10) {\n        kprintf(\"Instruction fetch from NX page\\n\");\n    } else {\n        kprintf(\"Unknown\\n\");\n    }\n    \n    kprintf(\"Access type: %s\\n\", (err & 0x2) ? \"Write\" : \"Read\");\n    kprintf(\"Privilege: %s\\n\", (err & 0x4) ? \"User\" : \"Kernel\");\n    kprintf(\"EIP at fault: 0x%x\\n\", regs->eip);\n    \n    // For now, halt. Later: implement demand paging, COW, etc.\n    kprintf(\"System halted.\\n\");\n    __asm__ volatile (\"cli; hlt\");\n}\n```\n\n> **CR2 vs. EIP**\n>\n> CR2 contains the *data address* that caused the fault—the address you tried to read or write. EIP (in regs->eip) contains the *instruction address* that caused the fault. They're different! A `mov [0xDEADBEEF], eax` instruction at address 0x1000 would have CR2=0xDEADBEEF and EIP=0x1000.\n\n---\n\n## Stage 8: Kernel Heap Allocator\n\nWith paging and a physical frame allocator, you can build `kmalloc()`. The simplest approach: a linked list of free blocks, each with a header containing size and status.\n\n\n![kmalloc Internals: Block Headers and Free Lists](./diagrams/diag-kmalloc-internals.svg)\n\n\n```c\n/* kmalloc.h */\n#define KHEAP_START   0xD0000000\n#define KHEAP_SIZE    0x10000000   // 256MB virtual space for heap\n\nvoid kmalloc_init(void);\nvoid *kmalloc(size_t size);\nvoid kfree(void *ptr);\n```\n\n```c\n/* kmalloc.c */\n#include \"kmalloc.h\"\n#include \"vmm.h\"\n#include \"pmm.h\"\n#include \"kprintf.h\"\n\ntypedef struct block_header {\n    uint32_t size;\n    uint32_t free;\n    struct block_header *next;\n} block_header_t;\n\n#define HEADER_SIZE sizeof(block_header_t)\n#define ALIGN(x) (((x) + 15) & ~15)  // 16-byte alignment\n\nstatic block_header_t *heap_head = NULL;\nstatic uint32_t heap_current_end = KHEAP_START;\n\nstatic void *heap_grow(uint32_t size) {\n    // Allocate physical frames and map them\n    uint32_t frames_needed = (size + PAGE_SIZE - 1) / PAGE_SIZE;\n    uint32_t start_addr = heap_current_end;\n    \n    for (uint32_t i = 0; i < frames_needed; i++) {\n        uint32_t frame = pmm_alloc_frame();\n        if (frame == 0) {\n            kprintf(\"kmalloc: Out of physical memory!\\n\");\n            return NULL;\n        }\n        vmm_map_page(kernel_page_directory, heap_current_end, frame, \n                     PAGE_WRITABLE);\n        heap_current_end += PAGE_SIZE;\n    }\n    \n    return (void *)start_addr;\n}\n\nvoid kmalloc_init(void) {\n    // Allocate initial heap page\n    heap_head = (block_header_t *)heap_grow(PAGE_SIZE);\n    if (!heap_head) {\n        kprintf(\"kmalloc: Failed to initialize heap!\\n\");\n        return;\n    }\n    \n    heap_head->size = PAGE_SIZE - HEADER_SIZE;\n    heap_head->free = 1;\n    heap_head->next = NULL;\n    \n    kprintf(\"kmalloc: Heap initialized at 0x%x\\n\", KHEAP_START);\n}\n\nvoid *kmalloc(size_t size) {\n    if (size == 0) return NULL;\n    \n    size = ALIGN(size);\n    \n    // Find a free block (first-fit)\n    block_header_t *current = heap_head;\n    block_header_t *prev = NULL;\n    \n    while (current != NULL) {\n        if (current->free && current->size >= size) {\n            // Found a suitable block\n            \n            // Split if block is much larger\n            if (current->size > size + HEADER_SIZE + 32) {\n                block_header_t *new_block = (block_header_t *)\n                    ((uint32_t)current + HEADER_SIZE + size);\n                new_block->size = current->size - size - HEADER_SIZE;\n                new_block->free = 1;\n                new_block->next = current->next;\n                \n                current->size = size;\n                current->next = new_block;\n            }\n            \n            current->free = 0;\n            return (void *)((uint32_t)current + HEADER_SIZE);\n        }\n        \n        prev = current;\n        current = current->next;\n    }\n    \n    // No suitable block found, grow heap\n    uint32_t alloc_size = size + HEADER_SIZE;\n    if (alloc_size < PAGE_SIZE) alloc_size = PAGE_SIZE;\n    \n    block_header_t *new_block = (block_header_t *)heap_grow(alloc_size);\n    if (!new_block) return NULL;\n    \n    new_block->size = alloc_size - HEADER_SIZE;\n    new_block->free = 0;\n    new_block->next = NULL;\n    \n    if (prev) prev->next = new_block;\n    \n    return (void *)((uint32_t)new_block + HEADER_SIZE);\n}\n\nvoid kfree(void *ptr) {\n    if (ptr == NULL) return;\n    \n    block_header_t *header = (block_header_t *)((uint32_t)ptr - HEADER_SIZE);\n    header->free = 1;\n    \n    // Coalesce with next block if free\n    if (header->next && header->next->free) {\n        header->size += header->next->size + HEADER_SIZE;\n        header->next = header->next->next;\n    }\n    \n    // Could also coalesce with previous block (requires doubly-linked list)\n}\n```\n\nThis is a simple first-fit allocator. It's not optimal (fragmentation, no coalescing with previous blocks), but it demonstrates the key concept: **kmalloc requests page frames from the physical allocator, maps them to virtual addresses, and carves them into smaller blocks**.\n\n---\n\n## The Three-Level View: What Happens When You Access Memory\n\n**Level 1 — Application (Your Code)**:\n```c\nint *ptr = (int *)0xD0001000;\n*ptr = 42;\n```\nA simple memory write. You're storing a value at a virtual address.\n\n**Level 2 — Memory Management Unit (MMU)**:\nThe CPU's MMU translates the virtual address:\n1. Extract PD index: `(0xD0001000 >> 22) = 832`\n2. Read PDE from page directory at index 832\n3. PDE points to page table at physical address X\n4. Extract PT index: `(0xD0001000 >> 12) & 0x3FF = 1`\n5. Read PTE from page table at index 1\n6. PTE points to frame at physical address Y\n7. Combine frame address + offset: `Y + 0x000 = final physical address`\n\nEach step requires a memory access—unless cached in the TLB.\n\n**Level 3 — Hardware (Cache and Memory Bus)**:\nThe page table walk reads from memory (or cache). The final data write goes through the cache hierarchy (L1 → L2 → L3 → RAM). A TLB hit saves two memory accesses; a TLB miss costs two additional memory reads.\n\n---\n\n## Hardware Soul: TLB Miss Penalty\n\n| Scenario | Memory Accesses | Approximate Latency |\n|----------|-----------------|---------------------|\n| TLB hit, cache hit | 1 (data only) | ~4 cycles |\n| TLB hit, cache miss | 1 + RAM access | ~100 cycles |\n| TLB miss (page table in cache) | 2 (PD + PT) + 1 (data) | ~12 cycles |\n| TLB miss (page table in RAM) | 2 × RAM + 1 × RAM | ~300 cycles |\n\nA TLB miss is 75× slower than a TLB hit with cached data. This is why:\n- The kernel uses identity-mapped or higher-half addresses (TLB entries stay valid)\n- Global pages (kernel code) aren't flushed on context switch\n- Memory-intensive code benefits from huge pages (4MB instead of 4KB = 1/1024th the TLB entries)\n\n---\n\n## Common Pitfalls\n\n| Symptom | Likely Cause | Fix |\n|---------|--------------|-----|\n| Triple fault immediately after setting CR0.PG | Code not identity-mapped | Map pages 0x0-0x400000 before enabling paging |\n| Page fault on valid address | TLB contains stale entry | Call `invlpg` after modifying page tables |\n| Random corruption after kmalloc | Double-free or heap overflow | Audit all kfree() calls, add heap guards |\n| VGA output stops working after paging | VGA not mapped | Identity-map 0xB8000 or map at fixed virtual address |\n| Page fault handler crashes | Handler code not mapped | Ensure handler is in identity-mapped region |\n| Cannot access memory above 4MB | Page table not allocated | Check PDE present bit before accessing PTE |\n\n---\n\n## Knowledge Cascade\n\nYou've built the memory management layer. Here's where this connects:\n\n**→ Process Isolation (Milestone 4)**: Each process gets its own page directory. Switching CR3 on context switch provides complete memory isolation—process A cannot see process B's memory, even though they run on the same CPU. The page tables you just built become the foundation of process separation.\n\n**→ Demand Paging (Cross-Domain: Databases)**: A page fault on a not-present page doesn't have to crash the system. It can trigger a disk read to load the page from swap or a memory-mapped file. Databases use this extensively: `mmap()` a 100GB file, and the OS loads only the pages you actually access. The page fault handler you wrote is the entry point for this mechanism.\n\n**→ Copy-on-Write (Cross-Domain: Unix fork)**: When a process calls `fork()`, the kernel creates a copy of the page table (not the actual pages) and marks all pages read-only. When either process writes, a page fault occurs, the kernel copies just that one page, and updates permissions. This is why `fork()` is fast—it doesn't copy memory, it copies page tables.\n\n**→ Containerization (Cross-Domain: DevOps)**: Docker containers use cgroups and namespaces, but memory limits are enforced through page frame tracking. When a container exceeds its memory limit, the kernel's OOM killer selects a process to terminate. The same frame allocator you built tracks which cgroup owns which frames.\n\n**→ Garbage Collection (Cross-Domain: Language Runtimes)**: Generational garbage collectors use page protection bits to implement write barriers. A generational GC marks \"old\" pages as read-only; any write triggers a page fault, which the runtime intercepts to track references from old to young objects. The same hardware mechanism you're using for protection becomes a GC synchronization primitive.\n\n---\n\n[[CRITERIA_JSON: {\"milestone_id\": \"build-os-m3\", \"criteria\": [\"Physical memory map obtained from multiboot info or E820 with regions classified as usable, reserved, or ACPI\", \"Physical frame allocator (bitmap or free-list) allocates and frees 4KB frames with double-free prevention\", \"Page directory and page tables configured for identity-mapping (kernel + VGA + MMIO) and higher-half kernel mapping (0xC0000000+)\", \"Paging enabled by loading CR3 with page directory physical address and setting CR0.PG bit\", \"TLB flushed with invlpg or CR3 reload after modifying page table entries\", \"Page fault handler reads CR2 for faulting address and prints diagnostic (address, error code bits for present/write/user)\", \"Kernel heap allocator (kmalloc/kfree) provides dynamic allocation from dedicated virtual range using page allocator for backing frames\", \"Identity map maintained for low memory so VGA (0xB8000) and MMIO regions remain accessible at physical addresses\"]}]\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-os-m4 -->\n# Milestone 4: Processes and Preemptive Scheduling\n\n## The Illusion of Simultaneity\n\nYour kernel boots. It handles interrupts, manages memory, responds to keyboard input. But it's fundamentally single-tasking—one thread of execution, one instruction pointer marching forward. If your keyboard handler enters an infinite loop, the entire system freezes. If one function corrupts memory, everything crashes.\n\nReal operating systems create an illusion: dozens of processes appear to run simultaneously. You can compile code while listening to music while browsing the web. The CPU executes one instruction at a time, but it switches between processes so fast that each one seems to have the entire machine to itself.\n\nThis milestone builds that illusion. You'll create **process control blocks** to capture complete execution state, implement **context switching** to atomically save one process and restore another, configure the **Task State Segment** for safe privilege transitions, and build a **round-robin scheduler** triggered by timer interrupts. By the end, three processes will run concurrently, each printing to its own screen region—and you'll understand exactly how the CPU juggles them.\n\n### The Fundamental Tension\n\n**Constraint 1: The CPU Has One Set of Registers**\n\nThe CPU has exactly one EAX, one EBX, one EIP, one ESP. When Process A is running, its values occupy these registers. To switch to Process B, you must somehow preserve A's state, load B's state, and do it atomically—if an interrupt fires mid-switch, you'll have corrupted state from both processes.\n\n**Constraint 2: The Stack Is the Execution Record**\n\nThe stack contains return addresses, local variables, saved registers. A process's stack defines where it is in its execution. But the CPU has only one ESP. To have multiple processes, each needs its own stack, and context switching must swap ESP values correctly.\n\n**Constraint 3: User Mode Cannot Access Kernel Memory**\n\nWhen a userspace process makes a system call, it transitions from ring 3 to ring 0. The CPU must switch to a kernel stack—the userspace stack might be corrupted or malicious. But which stack? The CPU needs to be told, via the TSS, where the kernel stack for this process lives.\n\n**Constraint 4: Preemption Requires Interrupt Safety**\n\nThe timer interrupt will trigger context switches. But the context switch code itself must not be interrupted—if an IRQ fires while you're halfway through saving registers, you'll save garbage. The switch must be atomic.\n\n---\n\n## The Revelation: Context Switching Is Not Just Saving Registers\n\n\n![Process Control Block: Saved State Layout](./diagrams/diag-pcb-structure.svg)\n\n\nIf you've swapped variables in a program, you might think context switching works like this:\n\n```c\n// WRONG MENTAL MODEL\nvoid context_switch(process_t *old, process_t *new) {\n    old->eax = eax;  // Save current registers\n    old->ebx = ebx;\n    // ... save all registers\n    eax = new->eax;  // Load new registers\n    ebx = new->ebx;\n    // ... load all registers\n    // Done!\n}\n```\n\nThis mental model misses critical details that will crash your kernel:\n\n1. **EFLAGS contains the interrupt flag.** If you save EFLAGS from a process that had interrupts disabled, then restore it during context switch, you've just disabled interrupts in the middle of your scheduler. The system freezes.\n\n2. **The stack pointer swap is the actual switch.** When you change ESP, you're not just saving a value—you're literally changing which stack the CPU uses. The next `push` or `call` will use the new process's stack.\n\n3. **The return address is on the stack.** After saving registers, you need to somehow \"return\" into the new process. This isn't a normal function return—you're resuming execution at whatever EIP the new process was at when it was switched out.\n\n4. **EIP is not directly accessible.** You can't `mov eax, eip` in x86. The instruction pointer is implicit—you manipulate it through control flow instructions (call, ret, jmp). To save/restore EIP, you must use the stack.\n\n5. **The TSS ESP0 field must be updated.** When a userspace process makes a syscall, the CPU loads SS:ESP from the TSS. If ESP0 points to the wrong process's kernel stack, the syscall will corrupt state.\n\nLet's build the real thing, step by step.\n\n---\n\n## Stage 1: The Process Control Block\n\nThe PCB captures everything needed to resume a process. If you save all this state, swap to a different PCB, and restore its state, the process will resume exactly where it left off—as if nothing happened.\n\n```c\n/* process.h */\n\n#define MAX_PROCESSES 16\n#define KERNEL_STACK_SIZE 4096\n\ntypedef enum {\n    PROCESS_STATE_READY,\n    PROCESS_STATE_RUNNING,\n    PROCESS_STATE_BLOCKED,\n    PROCESS_STATE_ZOMBIE\n} process_state_t;\n\ntypedef struct {\n    uint32_t eax, ebx, ecx, edx;\n    uint32_t esi, edi, ebp;\n    uint32_t esp, eip;\n    uint32_t eflags;\n    uint32_t cs, ds, es, fs, gs, ss;\n    uint32_t cr3;           // Page directory physical address\n} cpu_state_t;\n\ntypedef struct process {\n    uint32_t pid;\n    process_state_t state;\n    cpu_state_t cpu;\n    \n    // Kernel stack for this process (used during syscalls/interrupts)\n    uint32_t kernel_stack;\n    uint32_t kernel_stack_top;\n    \n    // Scheduling\n    struct process *next;\n    \n    // For user-mode processes\n    uint32_t user_stack;\n    int is_user;\n} process_t;\n```\n\n\n![Process Control Block: Saved State Layout](./diagrams/diag-pcb-structure.svg)\n\n\nThe key insight: `cpu_state_t` contains *exactly* what the CPU needs to resume execution. The general-purpose registers (EAX-EDI), the stack pointer (ESP), the instruction pointer (EIP), the flags (EFLAGS), the segment registers (CS-SS), and the page directory (CR3). If you can restore all of these atomically, you've switched processes.\n\n### Process Creation\n\n```c\n/* process.c */\n#include \"process.h\"\n#include \"pmm.h\"\n#include \"vmm.h\"\n#include \"kprintf.h\"\n\nstatic process_t process_table[MAX_PROCESSES];\nstatic uint32_t next_pid = 1;\n\nprocess_t *current_process = NULL;\nprocess_t *ready_queue = NULL;\n\nprocess_t *process_create(void (*entry_point)(void), int is_user) {\n    // Find a free slot\n    process_t *proc = NULL;\n    for (int i = 0; i < MAX_PROCESSES; i++) {\n        if (process_table[i].state == PROCESS_STATE_ZOMBIE || \n            process_table[i].pid == 0) {\n            proc = &process_table[i];\n            break;\n        }\n    }\n    \n    if (!proc) {\n        kprintf(\"process_create: No free process slots!\\n\");\n        return NULL;\n    }\n    \n    // Initialize PCB\n    proc->pid = next_pid++;\n    proc->state = PROCESS_STATE_READY;\n    proc->is_user = is_user;\n    \n    // Allocate kernel stack\n    uint32_t kstack_frame = pmm_alloc_frame();\n    proc->kernel_stack = kstack_frame;\n    proc->kernel_stack_top = kstack_frame + KERNEL_STACK_SIZE;\n    \n    // Set up initial CPU state\n    proc->cpu.eip = (uint32_t)entry_point;\n    proc->cpu.eflags = 0x202;  // IF=1 (interrupts enabled), bit 1 always set\n    \n    if (is_user) {\n        // User-mode process: allocate user stack and set up segments\n        uint32_t ustack_frame = pmm_alloc_frame();\n        proc->user_stack = ustack_frame;\n        proc->cpu.esp = ustack_frame + KERNEL_STACK_SIZE;\n        proc->cpu.cs = 0x1B;   // User code segment (GDT index 4, RPL=3)\n        proc->cpu.ds = 0x23;   // User data segment (GDT index 5, RPL=3)\n        proc->cpu.es = 0x23;\n        proc->cpu.fs = 0x23;\n        proc->cpu.gs = 0x23;\n        proc->cpu.ss = 0x23;\n        \n        // Create user page directory (copy kernel mappings)\n        proc->cpu.cr3 = create_user_page_directory();\n    } else {\n        // Kernel-mode process: use kernel segments\n        proc->cpu.esp = proc->kernel_stack_top;\n        proc->cpu.cs = 0x08;   // Kernel code segment\n        proc->cpu.ds = 0x10;   // Kernel data segment\n        proc->cpu.es = 0x10;\n        proc->cpu.fs = 0x10;\n        proc->cpu.gs = 0x10;\n        proc->cpu.ss = 0x10;\n        proc->cpu.cr3 = (uint32_t)kernel_page_directory;\n    }\n    \n    // Add to ready queue\n    proc->next = ready_queue;\n    ready_queue = proc;\n    \n    kprintf(\"Created process PID=%d, entry=0x%x, %s mode\\n\",\n            proc->pid, entry_point, is_user ? \"user\" : \"kernel\");\n    \n    return proc;\n}\n```\n\n> **The EFLAGS Value 0x202**\n>\n> EFLAGS bit 1 is always 1 (reserved). Bit 9 (IF, Interrupt Flag) must be set for the process to receive interrupts. 0x202 = binary `0010 0000 0010` = IF set + reserved bit set. If you forget IF, the process will never respond to timer ticks and will run forever.\n\n---\n\n## Stage 2: The Context Switch\n\n\n![Context Switch: Save Old → Load New](./diagrams/diag-context-switch-flow.svg)\n\n\nContext switching is the most critical code in your kernel. It must be written in assembly—C cannot directly control register saving/restoration with the precision needed.\n\n### The Assembly Context Switch\n\n```asm\n; context_switch.asm\n[BITS 32]\n\nextern current_process\nextern next_process\n\nglobal context_switch\ncontext_switch:\n    ; Save current process state\n    ; We're called from the scheduler, which was called from the timer interrupt\n    ; The timer handler already pushed general registers via pusha\n    \n    ; Get pointer to current_process->cpu\n    mov eax, [current_process]\n    test eax, eax\n    jz .load_new           ; No current process, just load new\n    \n    ; Save registers into PCB\n    ; The caller (scheduler) passes us a pointer to old CPU state on stack\n    mov ebx, [esp + 4]     ; Pointer to old cpu_state_t\n    \n    ; Save general-purpose registers (already saved by interrupt handler)\n    ; But we need to save the stack pointer as it will be after iret\n    mov [ebx + 28], esp    ; Save ESP offset in cpu_state_t\n    \n    ; Save segment registers\n    mov ax, ds\n    mov [ebx + 44], ax     ; ds\n    mov ax, es\n    mov [ebx + 46], ax     ; es\n    mov ax, fs\n    mov [ebx + 48], ax     ; fs\n    mov ax, gs\n    mov [ebx + 50], ax     ; gs\n    \n    ; Save CR3 (page directory)\n    mov eax, cr3\n    mov [ebx + 56], eax    ; cr3\n    \n    ; Save EIP - this is the return address that will be used after context switch\n    ; We need to set up for \"returning\" to the new process\n    mov eax, [esp + 0]     ; Return address to scheduler\n    mov [ebx + 24], eax    ; eip - but this needs adjustment\n\n.load_new:\n    ; Load new process state\n    mov eax, [next_process]\n    mov [current_process], eax\n    \n    ; Get pointer to new process's cpu state\n    lea ebx, [eax + 8]     ; Offset of cpu field in process_t\n    \n    ; Load CR3 (page directory)\n    mov eax, [ebx + 56]    ; cr3\n    mov cr3, eax\n    \n    ; Load segment registers\n    mov ax, [ebx + 44]     ; ds\n    mov ds, ax\n    mov ax, [ebx + 46]     ; es\n    mov es, ax\n    mov ax, [ebx + 48]     ; fs\n    mov fs, ax\n    mov ax, [ebx + 50]     ; gs\n    mov gs, ax\n    \n    ; Load stack pointer\n    mov esp, [ebx + 28]    ; esp\n    \n    ; The stack now contains the saved state of the new process\n    ; Return to restore registers and iret\n    ret\n```\n\nActually, let me show you a cleaner approach that integrates with your interrupt handler:\n\n```asm\n; context_switch.asm - cleaner version\n[BITS 32]\n\nextern current_process\nextern schedule_next\n\nglobal context_switch_entry\ncontext_switch_entry:\n    ; This is called from the timer interrupt handler\n    ; The stack contains: pushed registers, error code, int number, EIP, CS, EFLAGS\n    ; For user mode: also ESP, SS\n    \n    cli                     ; Disable interrupts during context switch!\n    \n    ; Save current process state\n    mov eax, [current_process]\n    test eax, eax\n    jz .no_current\n    \n    ; Get pointer to cpu state (offset in process_t)\n    lea ebx, [eax + 8]      ; process_t.cpu starts at offset 8\n    \n    ; Save general-purpose registers from stack\n    ; The interrupt handler pushed: eax, ecx, edx, ebx, esp, ebp, esi, edi (pusha order)\n    ; But we need to be careful about esp\n    \n    pop dword [ebx + 0]     ; edi\n    pop dword [ebx + 4]     ; esi\n    pop dword [ebx + 8]     ; ebp\n    pop dword [ebx + 12]    ; esp (will be ignored, we save real esp below)\n    pop dword [ebx + 16]    ; ebx\n    pop dword [ebx + 20]    ; edx\n    pop dword [ebx + 24]    ; ecx\n    pop dword [ebx + 28]    ; eax\n    \n    ; Save actual ESP (after all the pops)\n    mov [ebx + 32], esp\n    \n    ; Save EIP, CS, EFLAGS from stack\n    pop dword [ebx + 36]    ; eip\n    pop dword [ebx + 40]    ; cs\n    pop dword [ebx + 44]    ; eflags\n    \n    ; Check if we need to save user ESP/SS\n    test byte [ebx + 40], 3  ; Check CS RPL (bits 0-1)\n    jz .kernel_mode_save\n    pop dword [ebx + 48]    ; useresp\n    pop dword [ebx + 52]    ; ss\n    jmp .save_segments\n\n.kernel_mode_save:\n    ; For kernel mode, ESP/SS are already saved\n    \n.save_segments:\n    ; Save segment registers\n    mov ax, ds\n    mov [ebx + 56], ax\n    mov ax, es\n    mov [ebx + 58], ax\n    \n    ; Save CR3\n    mov eax, cr3\n    mov [ebx + 60], eax\n\n.no_current:\n    ; Call scheduler to pick next process\n    call schedule_next\n    \n    ; Load new process\n    mov eax, [current_process]\n    lea ebx, [eax + 8]      ; cpu state pointer\n    \n    ; Load CR3\n    mov eax, [ebx + 60]\n    mov cr3, eax\n    \n    ; Load segments\n    mov ax, [ebx + 56]\n    mov ds, ax\n    mov ax, [ebx + 58]\n    mov es, ax\n    \n    ; Check if returning to user mode\n    test byte [ebx + 40], 3  ; CS RPL\n    jz .kernel_mode_restore\n    \n    ; User mode: push SS, ESP for iret\n    push dword [ebx + 52]   ; ss\n    push dword [ebx + 48]   ; useresp\n\n.kernel_mode_restore:\n    ; Push EFLAGS, CS, EIP for iret\n    push dword [ebx + 44]   ; eflags\n    push dword [ebx + 40]   ; cs\n    push dword [ebx + 36]   ; eip\n    \n    ; Push general-purpose registers\n    push dword [ebx + 28]   ; eax\n    push dword [ebx + 24]   ; ecx\n    push dword [ebx + 20]   ; edx\n    push dword [ebx + 16]   ; ebx\n    push dword [ebx + 12]   ; esp (placeholder, will be overwritten)\n    push dword [ebx + 8]    ; ebp\n    push dword [ebx + 4]    ; esi\n    push dword [ebx + 0]    ; edi\n    \n    ; Restore registers and iret\n    popa\n    iret\n```\n\n> **Why Interrupts Must Be Disabled During Context Switch**\n>\n> Imagine this scenario:\n> 1. Timer fires, you start saving Process A's registers\n> 2. Halfway through, keyboard interrupt fires\n> 3. Keyboard handler uses the stack, overwriting data\n> 4. You return, load Process B's state\n> 5. Process B's stack is corrupted → crash\n>\n> The `cli` at the start of context switch prevents this. Interrupts are re-enabled by `iret` (which restores EFLAGS, including IF).\n\n---\n\n## Stage 3: The Round-Robin Scheduler\n\n\n![Round-Robin Scheduler: Ready Queue Rotation](./diagrams/diag-scheduler-round-robin.svg)\n\n\nThe scheduler is simple: maintain a queue of ready processes, pick the next one on each timer tick.\n\n```c\n/* scheduler.c */\n#include \"scheduler.h\"\n#include \"process.h\"\n#include \"kprintf.h\"\n\nextern void context_switch_entry(void);\n\nvoid schedule_next(void) {\n    if (current_process == NULL) {\n        // First process ever\n        if (ready_queue != NULL) {\n            current_process = ready_queue;\n            current_process->state = PROCESS_STATE_RUNNING;\n        }\n        return;\n    }\n    \n    // Find next ready process after current\n    process_t *next = current_process->next;\n    if (next == NULL) {\n        next = ready_queue;  // Wrap around to front\n    }\n    \n    // Search for a ready process\n    process_t *start = next;\n    while (next->state != PROCESS_STATE_READY) {\n        next = next->next;\n        if (next == NULL) next = ready_queue;\n        if (next == start) {\n            // No ready processes, keep running current\n            return;\n        }\n    }\n    \n    // Mark old process as ready\n    current_process->state = PROCESS_STATE_READY;\n    \n    // Mark new process as running\n    current_process = next;\n    current_process->state = PROCESS_STATE_RUNNING;\n    \n    // Update TSS ESP0 for this process\n    tss_update_esp0(current_process->kernel_stack_top);\n}\n```\n\n### The Timer Interrupt Hook\n\n```c\n/* timer.c - updated for scheduling */\n#include \"timer.h\"\n#include \"scheduler.h\"\n\nextern uint32_t timer_ticks;\n\nvoid timer_handler(void) {\n    timer_ticks++;\n    \n    // Trigger scheduler every 10 ms (at 100Hz, every tick)\n    // You could add a counter here for different quantum sizes\n    schedule();\n}\n\nvoid schedule(void) {\n    // Only switch if there are multiple processes\n    if (ready_queue != NULL && ready_queue->next != NULL) {\n        context_switch_entry();\n    }\n}\n```\n\n---\n\n## Stage 4: The Task State Segment\n\n\n![TSS and ESP0: Ring 3 → Ring 0 Stack Switch](./diagrams/diag-tss-esp0.svg)\n\n\nThe TSS is mandatory for ring 3 → ring 0 transitions. When a userspace process triggers an interrupt or syscall, the CPU:\n\n1. Looks up the TSS (via TR register)\n2. Loads SS0 and ESP0 from the TSS\n3. Switches to the kernel stack\n4. Pushes the userspace SS, ESP, EFLAGS, CS, EIP\n5. Jumps to the interrupt handler\n\nWithout a valid TSS, the CPU has nowhere to push the userspace state—it triple faults.\n\n### TSS Structure\n\n```c\n/* tss.h */\n\ntypedef struct {\n    uint16_t link, _pad0;\n    uint32_t esp0;          // Stack pointer for ring 0\n    uint16_t ss0, _pad1;    // Stack segment for ring 0\n    uint32_t esp1;\n    uint16_t ss1, _pad2;\n    uint32_t esp2;\n    uint16_t ss2, _pad3;\n    uint32_t cr3;\n    uint32_t eip;\n    uint32_t eflags;\n    uint32_t eax, ecx, edx, ebx, esp, ebp, esi, edi;\n    uint16_t es, _pad4;\n    uint16_t cs, _pad5;\n    uint16_t ss, _pad6;\n    uint16_t ds, _pad7;\n    uint16_t fs, _pad8;\n    uint16_t gs, _pad9;\n    uint16_t ldtr, _pad10;\n    uint16_t _pad11;\n    uint16_t iomap_base;\n} __attribute__((packed)) tss_t;\n\nextern tss_t kernel_tss;\n\nvoid tss_init(void);\nvoid tss_update_esp0(uint32_t esp0);\n```\n\n```c\n/* tss.c */\n#include \"tss.h\"\n#include \"gdt.h\"\n#include \"kprintf.h\"\n\ntss_t kernel_tss;\n\nvoid tss_init(void) {\n    // Zero the TSS\n    for (uint32_t i = 0; i < sizeof(tss_t); i++) {\n        ((uint8_t *)&kernel_tss)[i] = 0;\n    }\n    \n    // Set up kernel stack for ring 0\n    kernel_tss.ss0 = 0x10;      // Kernel data segment\n    kernel_tss.esp0 = 0x90000;  // Initial kernel stack (will be updated)\n    \n    // Set IO bitmap offset (beyond TSS = no IO permissions)\n    kernel_tss.iomap_base = sizeof(tss_t);\n    \n    // Add TSS to GDT (you need a TSS descriptor in the GDT)\n    // TSS descriptor at index 6 (adjust based on your GDT)\n    gdt_set_gate(6, (uint32_t)&kernel_tss, sizeof(tss_t) - 1,\n                 0x89,  // Present, ring 0, type=64 (TSS available)\n                 0x00);\n    \n    // Load TR (Task Register) with TSS selector\n    uint16_t tr = 6 * 8;  // GDT index 6, RPL=0, TI=0\n    __asm__ volatile (\"ltr %0\" : : \"r\"(tr));\n    \n    kprintf(\"TSS initialized at 0x%x, TR=%d\\n\", &kernel_tss, tr);\n}\n\nvoid tss_update_esp0(uint32_t esp0) {\n    kernel_tss.esp0 = esp0;\n}\n```\n\n> **The TSS Is Not Optional for User Mode**\n>\n> You might wonder: \"Can't I just switch stacks manually in my interrupt handler?\" No. The CPU *automatically* loads SS0:ESP0 from the TSS before pushing anything. If ESP0 is garbage, the push writes to garbage addresses. Triple fault is immediate and unrecoverable.\n\n---\n\n## Stage 5: User-Mode Processes and Isolation\n\n\n![User vs. Kernel Page Directories: Isolation](./diagrams/diag-user-kernel-pages.svg)\n\n\nA user-mode process runs at ring 3 with its own page directory. The kernel pages must be mapped but marked supervisor-only—the user bit (bit 2) must be 0 for kernel pages.\n\n### Creating User Page Directories\n\n```c\n/* user_memory.c */\n#include \"user_memory.h\"\n#include \"vmm.h\"\n#include \"pmm.h\"\n#include \"kprintf.h\"\n\nuint32_t create_user_page_directory(void) {\n    // Allocate a page for the new page directory\n    uint32_t pd_frame = pmm_alloc_frame();\n    page_directory_t *user_pd = (page_directory_t *)pd_frame;\n    \n    // Zero the page directory\n    for (int i = 0; i < 1024; i++) {\n        user_pd->entries[i] = 0;\n    }\n    \n    // Copy kernel mappings (higher half: entries 768-1023)\n    // These are supervisor-only (no PAGE_USER flag)\n    for (int i = 768; i < 1024; i++) {\n        user_pd->entries[i] = kernel_page_directory->entries[i];\n        // Ensure kernel pages are NOT user-accessible\n        user_pd->entries[i] &= ~PAGE_USER;\n    }\n    \n    // Allocate and map user code/data pages\n    // For simplicity, we'll create a simple user address space:\n    // 0x00000000 - 0x00400000: user code/data (4MB)\n    // 0xBFFFF000 - 0xC0000000: user stack (4KB)\n    \n    // Map user code at 0x00001000\n    uint32_t user_code_frame = pmm_alloc_frame();\n    vmm_map_page_user(user_pd, 0x00001000, user_code_frame, \n                      PAGE_PRESENT | PAGE_WRITABLE | PAGE_USER);\n    \n    // Map user stack at 0xBFFFF000\n    uint32_t user_stack_frame = pmm_alloc_frame();\n    vmm_map_page_user(user_pd, 0xBFFFF000, user_stack_frame,\n                      PAGE_PRESENT | PAGE_WRITABLE | PAGE_USER);\n    \n    return pd_frame;\n}\n\n// Helper function to map a page in a user page directory\nvoid vmm_map_page_user(page_directory_t *pd, uint32_t virtual_addr,\n                       uint32_t physical_addr, uint32_t flags) {\n    // Similar to vmm_map_page, but operates on the specified PD\n    // and respects the user flags\n    \n    virtual_addr &= 0xFFFFF000;\n    physical_addr &= 0xFFFFF000;\n    \n    uint32_t pd_idx = (virtual_addr >> 22) & 0x3FF;\n    uint32_t pt_idx = (virtual_addr >> 12) & 0x3FF;\n    \n    // Get or create page table\n    page_table_t *pt;\n    if (!(pd->entries[pd_idx] & PAGE_PRESENT)) {\n        uint32_t pt_frame = pmm_alloc_frame();\n        pt = (page_table_t *)pt_frame;\n        for (int i = 0; i < 1024; i++) {\n            pt->entries[i] = 0;\n        }\n        pd->entries[pd_idx] = pt_frame | PAGE_PRESENT | PAGE_WRITABLE | PAGE_USER;\n    } else {\n        pt = (page_table_t *)(pd->entries[pd_idx] & 0xFFFFF000);\n    }\n    \n    // Map the page with user-accessible flag\n    pt->entries[pt_idx] = physical_addr | flags;\n}\n```\n\n### Jumping to User Mode\n\nThe first entry into user mode is special—you can't just call a function. You must use `iret` with the user CS, SS, ESP, EIP, and EFLAGS properly set up on the stack.\n\n```asm\n; jump_to_user.asm\n[BITS 32]\n\nglobal jump_to_user_mode\nextern kernel_tss\n\njump_to_user_mode:\n    ; Args: EAX = user EIP, EBX = user ESP, ECX = user stack top (for TSS)\n    \n    ; Update TSS ESP0 before entering user mode\n    mov [kernel_tss + 4], ecx   ; tss_t.esp0 offset is 4\n    \n    ; Set up stack for iret to user mode\n    ; Stack must contain: SS, ESP, EFLAGS, CS, EIP\n    \n    ; Set up data segments\n    mov ax, 0x23        ; User data segment (index 5 * 8 = 0x28, OR 3 = 0x2B... wait, let me recalculate)\n                        ; Actually: index 4 = user code (0x20 | 3 = 0x23 for data? No...)\n                        ; GDT: 0=null, 1=kcode(0x08), 2=kdata(0x10), 3=ucode(0x18|3=0x1B), 4=udata(0x20|3=0x23)\n    mov ds, ax\n    mov es, ax\n    mov fs, ax\n    mov gs, ax\n    \n    ; Push user stack segment and pointer\n    push 0x23           ; User data segment (SS)\n    push ebx            ; User ESP\n    \n    ; Push EFLAGS with IF set\n    pushf\n    or dword [esp], 0x200   ; Set IF\n    popf\n    pushf              ; Push EFLAGS\n    \n    ; Push user code segment and EIP\n    push 0x1B           ; User code segment (CS)\n    push eax            ; User EIP\n    \n    ; iret jumps to user mode!\n    iret\n```\n\n```c\n/* user_mode.c */\n#include \"user_mode.h\"\n\nextern void jump_to_user_mode(uint32_t eip, uint32_t esp, uint32_t kernel_esp);\n\nvoid enter_user_mode(uint32_t entry_point, uint32_t stack_top) {\n    // We need to provide the kernel stack top for TSS ESP0\n    uint32_t kstack = current_process->kernel_stack_top;\n    \n    // Jump to user mode - never returns\n    jump_to_user_mode(entry_point, stack_top, kstack);\n}\n```\n\n---\n\n## Stage 6: System Calls via INT 0x80\n\n\n![System Call: INT 0x80 Entry and Exit](./diagrams/diag-syscall-int-0x80.svg)\n\n\nSystem calls are the controlled entry point from user mode to kernel mode. The user process triggers INT 0x80, the CPU switches to ring 0 (using TSS ESP0), and the kernel handler executes with full privileges.\n\n### System Call Handler\n\n```c\n/* syscall.h */\n\n#define SYS_EXIT  0\n#define SYS_WRITE 1\n#define SYS_READ  2\n\nvoid syscall_init(void);\nvoid syscall_handler(registers_t *regs);\n```\n\n```c\n/* syscall.c */\n#include \"syscall.h\"\n#include \"process.h\"\n#include \"vga.h\"\n#include \"kprintf.h\"\n\nvoid syscall_init(void) {\n    // Register INT 0x80 handler\n    idt_set_gate(0x80, (uint32_t)isr128, 0x08, 0x8E);  // DPL=3 allows user mode to call\n}\n\nvoid syscall_handler(registers_t *regs) {\n    // Syscall number in EAX\n    // Arguments in EBX, ECX, EDX\n    \n    switch (regs->eax) {\n        case SYS_WRITE: {\n            // sys_write(int fd, const char *buf, int len)\n            int fd = regs->ebx;\n            const char *buf = (const char *)regs->ecx;\n            int len = regs->edx;\n            \n            // Simple implementation: write to VGA\n            for (int i = 0; i < len; i++) {\n                vga_putchar(buf[i]);\n            }\n            \n            regs->eax = len;  // Return bytes written\n            break;\n        }\n        \n        case SYS_EXIT: {\n            // sys_exit(int status)\n            int status = regs->ebx;\n            kprintf(\"Process %d exited with status %d\\n\", \n                    current_process->pid, status);\n            \n            // Mark process as zombie\n            current_process->state = PROCESS_STATE_ZOMBIE;\n            \n            // Force immediate reschedule\n            schedule();\n            break;\n        }\n        \n        case SYS_READ: {\n            // sys_read(int fd, char *buf, int len)\n            // For now, read from keyboard buffer\n            int fd = regs->ebx;\n            char *buf = (char *)regs->ecx;\n            int len = regs->edx;\n            \n            int count = 0;\n            while (count < len) {\n                char c = keyboard_getchar_nonblocking();\n                if (c == 0) break;\n                buf[count++] = c;\n            }\n            \n            regs->eax = count;\n            break;\n        }\n        \n        default:\n            kprintf(\"Unknown syscall: %d\\n\", regs->eax);\n            regs->eax = -1;  // Return error\n    }\n}\n```\n\n### Assembly Wrapper for INT 0x80\n\n```asm\n; syscall.asm\n[BITS 32]\n\nglobal sys_exit\nglobal sys_write\n\nsys_exit:\n    ; void sys_exit(int status)\n    mov eax, 0       ; SYS_EXIT\n    mov ebx, [esp + 4]  ; status\n    int 0x80\n    ret\n\nsys_write:\n    ; int sys_write(int fd, const char *buf, int len)\n    mov eax, 1       ; SYS_WRITE\n    mov ebx, [esp + 4]  ; fd\n    mov ecx, [esp + 8]  ; buf\n    mov edx, [esp + 12] ; len\n    int 0x80\n    ret\n```\n\n### User-Mode System Call Example\n\n```c\n/* user_program.c - linked into user process */\n\n// These are declared in the syscall assembly wrapper\nextern void sys_exit(int status);\nextern int sys_write(int fd, const char *buf, int len);\n\nvoid user_main(void) {\n    const char *msg = \"Hello from user mode!\\n\";\n    sys_write(0, msg, 23);\n    sys_exit(0);\n}\n```\n\n---\n\n## Stage 7: Multi-Process Demo\n\n{{DIAGRAM:diag-multi-process-demo}}\n\nLet's create three kernel-mode processes that print to different screen regions, demonstrating preemptive multitasking.\n\n```c\n/* process_demo.c */\n#include \"process.h\"\n#include \"vga.h\"\n\n// Process A: prints 'A' to top-left region\nvoid process_a(void) {\n    int col = 0;\n    while (1) {\n        vga_putc_at(0, col, 'A', VGA_COLOR_GREEN);\n        col = (col + 1) % 26;\n        for (volatile int i = 0; i < 1000000; i++);  // Busy wait\n    }\n}\n\n// Process B: prints 'B' to middle region\nvoid process_b(void) {\n    int col = 0;\n    while (1) {\n        vga_putc_at(10, col, 'B', VGA_COLOR_BLUE);\n        col = (col + 1) % 26;\n        for (volatile int i = 0; i < 1000000; i++);\n    }\n}\n\n// Process C: prints 'C' to bottom region\nvoid process_c(void) {\n    int col = 0;\n    while (1) {\n        vga_putc_at(20, col, 'C', VGA_COLOR_RED);\n        col = (col + 1) % 26;\n        for (volatile int i = 0; i < 1000000; i++);\n    }\n}\n\nvoid demo_create_processes(void) {\n    process_create(process_a, 0);  // Kernel mode\n    process_create(process_b, 0);\n    process_create(process_c, 0);\n    \n    kprintf(\"Created 3 demo processes\\n\");\n}\n```\n\n### Updated Kernel Main\n\n```c\n/* main.c */\n#include \"vga.h\"\n#include \"idt.h\"\n#include \"pic.h\"\n#include \"timer.h\"\n#include \"keyboard.h\"\n#include \"pmm.h\"\n#include \"vmm.h\"\n#include \"kmalloc.h\"\n#include \"tss.h\"\n#include \"process.h\"\n#include \"syscall.h\"\n#include \"process_demo.h\"\n\nvoid kernel_main(void) {\n    vga_init();\n    serial_init(COM1_PORT);\n    kprintf(\"=== MyOS Kernel ===\\n\");\n    \n    // Initialize IDT and interrupts\n    idt_init();\n    pic_remap(32, 40);\n    \n    // Initialize memory management\n    memory_map_init(multiboot_info);\n    pmm_init(memory_map, memory_map_count);\n    vmm_init();\n    setup_page_tables();\n    enable_paging();\n    kmalloc_init();\n    \n    // Initialize TSS (required for user mode)\n    tss_init();\n    \n    // Initialize devices\n    timer_init(100);  // 100 Hz = 10ms quantum\n    keyboard_init();\n    \n    // Set up interrupt handlers\n    idt_set_gate(0, (uint32_t)isr0, 0x08, 0x8E);\n    // ... set all exception handlers\n    idt_set_gate(14, (uint32_t)isr14, 0x08, 0x8E);  // Page fault\n    idt_set_gate(32, (uint32_t)irq0, 0x08, 0x8E);   // Timer\n    idt_set_gate(33, (uint32_t)irq1, 0x08, 0x8E);   // Keyboard\n    \n    // Set up system calls\n    syscall_init();\n    idt_set_gate(0x80, (uint32_t)isr128, 0x08, 0xEE);  // DPL=3 for user mode\n    \n    // Enable interrupts\n    __asm__ volatile (\"sti\");\n    \n    kprintf(\"Creating demo processes...\\n\");\n    demo_create_processes();\n    \n    kprintf(\"Starting scheduler...\\n\");\n    \n    // Become the idle process\n    while (1) {\n        __asm__ volatile (\"hlt\");\n    }\n}\n```\n\n---\n\n## The Three-Level View: What Happens During a Context Switch\n\n**Level 1 — Application (Process Code)**:\n```c\nvoid process_a(void) {\n    while (1) {\n        do_work();\n        // Timer fires here!\n    }\n}\n```\nProcess A is running, blissfully unaware. It calls `do_work()`, the timer fires mid-function, and... nothing. From A's perspective, time simply skipped forward.\n\n**Level 2 — Kernel (Scheduler)**:\n1. Timer interrupt fires (IRQ0)\n2. CPU pushes EIP, CS, EFLAGS to A's stack\n3. CPU jumps to timer handler\n4. Handler saves A's general registers\n5. Handler calls `schedule()`\n6. Scheduler picks Process B\n7. `context_switch()` saves A's complete state to PCB\n8. `context_switch()` loads B's state from PCB\n9. `context_switch()` executes `iret`\n10. CPU pops B's EIP, CS, EFLAGS and resumes B\n\n**Level 3 — Hardware (CPU and Memory)**:\n- The CR3 register changes from A's page directory to B's page directory. The TLB is flushed (unless global pages are used).\n- The TSS ESP0 field is updated to point to B's kernel stack.\n- The stack pointer (ESP) now points somewhere completely different in physical memory.\n- The CPU's pipeline is flushed and refilled with instructions from B's code.\n\nThe entire switch takes ~1-5 microseconds on modern hardware. Process A was interrupted mid-instruction-stream; Process B resumes mid-instruction-stream. Neither knows anything happened.\n\n---\n\n## Hardware Soul: Context Switch Overhead\n\n| Component | Cost | Why |\n|-----------|------|-----|\n| General register save/restore | ~20 cycles | 8 registers × 2 (push/pop) |\n| CR3 reload (TLB flush) | ~100-500 cycles | All non-global TLB entries invalidated |\n| Pipeline flush | ~10-20 cycles | CPU fetches from new EIP |\n| Cache effects | Variable | B's working set may not be cached |\n| Total | ~150-1000 cycles | ~0.15-1 microsecond |\n\nThe TLB flush is the most expensive part. If both processes are small (working set fits in TLB), the overhead is minimal. If processes are large (TLB misses on every access), the cost skyrockets. This is why:\n- Servers use process pools (reuse processes, avoid CR3 reload)\n- Games use thread pools (threads share address space, no CR3 reload)\n- Kernels map themselves into every process (global pages, avoid TLB flush for kernel entries)\n\n---\n\n## Common Pitfalls\n\n| Symptom | Likely Cause | Fix |\n|---------|--------------|-----|\n| System hangs after first context switch | Forgot to re-enable interrupts | Ensure EFLAGS has IF=1 (0x202) |\n| Page fault on user-mode entry | TSS ESP0 not set or invalid | Update TSS before `iret` to user mode |\n| Kernel memory accessible from user mode | User bit set on kernel pages | Clear PAGE_USER for kernel mappings |\n| Triple fault on syscall | IDT gate 0x80 not configured or DPL=0 | Set DPL=3 (0xEE) for INT 0x80 |\n| Process state corrupted | Context switch not atomic | Disable interrupts during switch |\n| Wrong process resumes | Ready queue not circular | Check queue links and wraparound |\n| Stack overflow in interrupt | Nested interrupts without guard | Use `cli` during critical sections |\n\n---\n\n## Knowledge Cascade\n\nYou've built the foundation of multitasking. Here's where this connects:\n\n**→ Kernel Preemption (Advanced OS)**: Your scheduler is voluntary—it only runs on timer ticks. A preemptive kernel allows context switches *anywhere* in kernel code, not just on timer interrupts. Linux tracks `preempt_count` to know when preemption is safe (not holding locks, not in interrupt context). The same context switch mechanism you built enables this finer-grained concurrency.\n\n**→ Thread Pools (Cross-Domain: Web Servers)**: A web server creates N worker threads at startup. Each thread waits for work, processes a request, then waits again. This is exactly your process model—PCBs waiting on a queue, being scheduled, then returning to the queue. The difference: threads share an address space (same CR3), so switching is faster (no TLB flush).\n\n**→ Coroutine Runtimes (Cross-Domain: Async/Await)**: Go's goroutines, Rust's async tasks, and JavaScript's promises all use the same fundamental technique: save registers to a structure, swap stack pointers, resume. The difference is they do it in userspace, without kernel involvement. A goroutine's \"PCB\" is just a Go runtime structure; the \"context switch\" is just a function call that swaps ESP.\n\n**→ Virtualization (Cross-Domain: Cloud)**: When a VM executes a privileged instruction, the CPU triggers a \"VM exit\"—the hypervisor takes over. This is exactly a context switch: guest registers are saved to a VMCS (Virtual Machine Control Structure), host registers are restored, the hypervisor runs. The hypervisor's scheduler then decides which VM to run next. Your PCB is their VMCS; your context switch is their VM entry/exit.\n\n**→ Signal Delivery (Cross-Domain: Unix APIs)**: When a process receives a signal, the kernel injects a \"function call\" into the process's execution. It modifies the saved user stack pointer to include the signal handler's arguments, then sets EIP to the handler's address. When the process resumes via `iret`, it \"returns\" into the signal handler. This is a controlled form of context switching—the same saved register manipulation you do in context_switch, but targeted at signal handling.\n\n---\n\n[[CRITERIA_JSON: {\"milestone_id\": \"build-os-m4\", \"criteria\": [\"Process control block (PCB) stores PID, register state (EIP, ESP, EBP, general-purpose registers, EFLAGS), page directory pointer (CR3), process state (ready/running/blocked), and kernel stack pointer\", \"Context switch saves current process registers to its PCB and loads the next process's registers using assembly implementation for correctness\", \"TSS (Task State Segment) configured with kernel stack pointer (SS0:ESP0) so CPU knows which stack to use for ring 3 to ring 0 transitions\", \"Timer interrupt (IRQ0) triggers scheduler which selects next ready process in round-robin order and performs context switch\", \"At least 3 kernel-mode processes run concurrently each printing to different screen region demonstrating preemptive multitasking\", \"User-mode processes run in ring 3 with own page directory; accessing kernel memory triggers page fault due to supervisor-only bit\", \"System call interface via INT 0x80: kernel reads syscall number from EAX and arguments from EBX/ECX/EDX, implementing sys_write and sys_exit at minimum\", \"TSS ESP0 updated on every context switch to point to current process kernel stack top\"]}]\n<!-- END_MS -->\n\n\n\n\n# TDD\n\nA complete x86 operating system kernel built from scratch, demonstrating mastery of the hardware-software boundary. From the 512-byte bootloader constraint to preemptive multitasking with user-mode isolation, this project reveals how every software abstraction—processes, virtual memory, interrupts—negotiates with hardware physics: CPU pipelines, cache hierarchies, TLBs, and the memory bus. Each milestone is a layer in the stack that transforms raw hardware into a usable computing platform.\n\n\n\n<!-- TDD_MOD_ID: build-os-m1 -->\n# Module: Bootloader, GDT, and Kernel Entry\n\n## Module Charter\n\nThis module transforms a powered-on x86 CPU from 16-bit real mode into 32-bit protected mode running a C kernel. It handles the bootstrap problem: BIOS loads only 512 bytes, the CPU starts in a primitive state, and your kernel must be loaded from disk and given control. This module configures the GDT for flat addressing (base=0, limit=4GB), enables the A20 line for memory access above 1MB, loads the kernel binary to physical address 0x100000, and establishes VGA and serial output for debugging. It does NOT handle interrupts (Milestone 2), memory management (Milestone 3), or process scheduling (Milestone 4). The invariant is: after this module completes, the CPU is in protected mode with paging disabled, executing C code at a known address, with working output drivers.\n\n---\n\n## File Structure\n\n```\nkernel/\n├── boot/\n│   ├── boot.asm              # 1. Stage 1 bootloader (MBR)\n│   ├── gdt.asm               # 3. GDT definitions\n│   └── kernel_entry.asm      # 5. Assembly entry point, BSS zeroing\n├── drivers/\n│   ├── vga.h                 # 6. VGA text mode header\n│   ├── vga.c                 # 6. VGA implementation\n│   ├── serial.h              # 7. Serial port header\n│   ├── serial.c              # 7. Serial implementation\n│   └── port_io.h             # 7. Inline I/O functions\n├── kernel/\n│   ├── main.c                # 5. Kernel C entry point\n│   ├── kprintf.h             # 7. Printf header\n│   └── kprintf.c             # 7. Printf implementation\n├── linker.ld                 # 4. Linker script\n└── Makefile                  # Build system\n```\n\nFiles are numbered by creation order. Read existing files before editing.\n\n---\n\n## Complete Data Model\n\n### GDT Entry (Segment Descriptor)\n\nEvery GDT entry is 8 bytes. The layout is legacy x86 with split fields.\n\n```\nOffset  Size  Field\n------  ----  -----\n0       16    Limit bits 0-15\n2       24    Base bits 0-23\n4       1     Byte 6: flags + limit bits 16-19\n5       1     Byte 7: base bits 24-31\n\nByte 4 (Access Byte):\n  Bit 7: Present (P) - 1 for valid segments\n  Bits 5-6: DPL (Descriptor Privilege Level) - 00=ring 0, 11=ring 3\n  Bit 4: System (S) - 1 for code/data, 0 for system (TSS, gates)\n  Bit 3: Executable (E) - 1 for code, 0 for data\n  Bit 2: Direction/Conforming (DC) - for data: 0=grows up, for code: 0=non-conforming\n  Bit 1: Readable/Writable (RW) - for code: readable, for data: writable\n  Bit 0: Accessed (A) - CPU sets this when accessed\n\nByte 5 (Flags + Limit High):\n  Bit 7: Granularity (G) - 1 = 4KB blocks, 0 = 1 byte blocks\n  Bit 6: Size (D/B) - 1 = 32-bit, 0 = 16-bit\n  Bit 5: Long (L) - 1 = 64-bit (for long mode)\n  Bit 4: Available (AVL) - free for OS use\n  Bits 0-3: Limit bits 16-19\n```\n\n**Memory Layout (8 bytes, little-endian):**\n\n```\nByte:    [0]   [1]   [2]   [3]   [4]   [5]   [6]   [7]\nField:   |----limit----| |-----base----| |acc| |flg| |base|\n         lo    hi      lo    mid       byte  lim+flg hi\n         0-7   8-15    0-15  16-23           16-19  24-31\n\nKernel Code Descriptor (0x00CF9A000000FFFF):\n  [0-1]: 0xFFFF  - limit low = 0xFFFF\n  [2-3]: 0x0000  - base low = 0\n  [4]:   0x00    - base mid = 0\n  [5]:   0x9A    - access: P=1, DPL=0, S=1, E=1, DC=0, RW=1, A=0\n  [6]:   0xCF    - flags: G=1, D=1, L=0, AVL=0; limit high = 0xF\n  [7]:   0x00    - base high = 0\n\nResult: base=0, limit=0xFFFFF with G=1 (4KB granularity) = 4GB\n```\n\n### GDT Descriptor (GDTR Load Value)\n\n```c\nstruct {\n    uint16_t limit;   // Size of GDT - 1 (in bytes)\n    uint32_t base;    // Linear address of GDT\n} __attribute__((packed));\n```\n\nSize: 6 bytes. Loaded via `lgdt`.\n\n### VGA Character Cell\n\n```c\nstruct {\n    char     character;  // ASCII code (0-255)\n    uint8_t  attribute;  // Color: high nibble = background, low nibble = foreground\n} __attribute__((packed));\n```\n\nSize: 2 bytes per cell. Buffer starts at 0xB8000. 80×25 = 2000 cells = 4000 bytes total.\n\n**Attribute Byte Encoding:**\n```\nBits 7-6-5-4: Background color (0-15, but 8-15 may blink)\nBits 3-2-1-0: Foreground color (0-15)\n\nColors:\n  0=Black, 1=Blue, 2=Green, 3=Cyan, 4=Red, 5=Magenta, 6=Brown, 7=Light Grey\n  8=Dark Grey, 9=Light Blue, 10=Light Green, 11=Light Cyan, 12=Light Red,\n  13=Light Magenta, 14=Yellow, 15=White\n```\n\n### Serial Port Registers (COM1 at 0x3F8)\n\n```\nOffset  Register (DLAB=0)      Register (DLAB=1)\n------  -----------------      -----------------\n+0      Transmit/Receive       Divisor Latch Low\n+1      Interrupt Enable       Divisor Latch High\n+2      FIFO Control           (same)\n+3      Line Control           (same)\n+4      Modem Control          (same)\n+5      Line Status            (read-only)\n+6      Modem Status           (read-only)\n\nDLAB (Divisor Latch Access Bit) is bit 7 of Line Control Register (+3).\n```\n\n**Line Status Register (offset +5):**\n```\nBit 5: Transmitter Holding Register Empty (THRE)\n       1 = Ready to transmit next byte\n```\n\n---\n\n## Interface Contracts\n\n### boot.asm: Stage 1 Bootloader\n\n**Entry:** CPU state after BIOS handoff\n- CS:IP = 0x0000:0x7C00\n- DL = boot drive number (0x80 for first HDD)\n- Interrupts enabled, real mode (16-bit)\n\n**Exit:** Protected mode, kernel loaded\n- CPU in 32-bit protected mode\n- CS = 0x08 (kernel code selector)\n- DS/ES/FS/GS/SS = 0x10 (kernel data selector)\n- ESP = 0x90000 (kernel stack)\n- Kernel binary at 0x100000\n- Control transferred to kernel_entry\n\n**Error Conditions:**\n| Error | Detection | Recovery |\n|-------|-----------|----------|\n| Disk read failure | INT 13h CF set | Print error, halt |\n| No boot signature | BIOS check | BIOS displays error |\n| A20 enable failure | Test memory wrap | Try alternate method, continue anyway |\n\n### kernel_entry.asm: Assembly Entry Point\n\n```c\n// Called from bootloader at physical address 0x100000\n// No parameters, no return value\nvoid kernel_entry(void);\n```\n\n**Preconditions:**\n- Protected mode enabled\n- GDT loaded with flat selectors\n- Stack valid at 0x90000\n\n**Postconditions:**\n- BSS section zeroed\n- kernel_main() called\n- System halted if kernel_main returns (shouldn't happen)\n\n**Memory Layout Assumptions:**\n- `__bss_start` and `__bss_end` defined by linker script\n- BSS may be 0 bytes (check before zeroing)\n\n### vga_init / vga_putchar / vga_puts\n\n```c\n// Initialize VGA to known state (clear screen, cursor at 0,0)\nvoid vga_init(void);\n\n// Output single character with current colors\n// Handles '\\n' (newline), '\\r' (carriage return), '\\t' (tab to next 8-column boundary)\n// Scrolls screen when row 24 overflows (move lines 1-24 up, clear line 24)\nvoid vga_putchar(char c);\n\n// Output null-terminated string\nvoid vga_puts(const char *str);\n\n// Set foreground/background colors for subsequent output\nvoid vga_set_color(vga_color_t fg, vga_color_t bg);\n```\n\n**Preconditions:** VGA buffer accessible at 0xB8000\n\n**Edge Cases:**\n| Input | Behavior |\n|-------|----------|\n| '\\n' | Move to column 0, increment row, scroll if needed |\n| '\\r' | Move to column 0 only |\n| '\\t' | Move to next column where (col % 8 == 0) |\n| '\\b' | Move back one column, clear cell |\n| Row 25 | Scroll: copy rows 1-24 to 0-23, clear row 24 |\n\n### serial_init / serial_putchar / serial_puts\n\n```c\n#define COM1_PORT 0x3F8\n#define COM2_PORT 0x2F8\n\n// Initialize serial port at 38400 baud, 8N1\n// Returns 0 on success, -1 if port not present\nint serial_init(uint16_t port);\n\n// Output single byte, blocks until transmitter ready\nvoid serial_putchar(uint16_t port, char c);\n\n// Output null-terminated string\nvoid serial_puts(uint16_t port, const char *str);\n```\n\n**Preconditions:** Port I/O instructions available (in protected mode)\n\n**Error Handling:**\n| Error | Detection | Behavior |\n|-------|-----------|----------|\n| Port not present | No response to initialization | Return -1 from init |\n| Transmitter timeout | Loop without THRE bit | Infinite loop (hardware failure) |\n\n### kprintf\n\n```c\n// Formatted output to VGA and serial\n// Supports: %s (string), %c (char), %d (int), %x (hex), %p (pointer)\n// Returns number of characters printed\nint kprintf(const char *fmt, ...);\n```\n\n**Format Specifiers:**\n| Specifier | Type | Output |\n|-----------|------|--------|\n| %s | const char* | Null-terminated string |\n| %c | int | Single character |\n| %d | int | Signed decimal |\n| %u | unsigned int | Unsigned decimal |\n| %x | unsigned int | Hexadecimal (lowercase) |\n| %X | unsigned int | Hexadecimal (uppercase) |\n| %p | void* | Pointer as hex with 0x prefix |\n\n---\n\n## Algorithm Specification\n\n### Algorithm: A20 Line Enablement\n\n**Purpose:** Enable address line 20 to access memory above 1MB.\n\n**Inputs:** None\n**Outputs:** A20 enabled (memory at 0x100000 accessible)\n\n**Procedure:**\n1. Try fast A20 method (port 0x92):\n   - Read port 0x92\n   - Set bit 1 (A20), clear bit 0 (reset)\n   - Write back to port 0x92\n   - Wait 1µs (I/O delay)\n   - Test if A20 is enabled\n\n2. If fast A20 failed, try keyboard controller method:\n   - Disable keyboard (command 0xAD)\n   - Read controller output port (command 0xD0)\n   - Write output port with bit 1 set (command 0xD1, data with A20 bit)\n   - Enable keyboard (command 0xAE)\n   - Wait for controller ready between each step\n\n3. Test A20:\n   - Write 0x00 to 0x0000:0x0500\n   - Write 0xFF to 0xFFFF:0x0510 (wraps to 0x0000:0x0500 if A20 disabled)\n   - Compare values at 0x0000:0x0500\n   - If different, A20 is enabled\n\n**Invariants:**\n- Memory below 1MB remains accessible throughout\n- Keyboard controller not left in undefined state\n\n### Algorithm: Protected Mode Transition\n\n**Purpose:** Switch CPU from 16-bit real mode to 32-bit protected mode.\n\n**Inputs:** GDT at known address\n**Outputs:** CPU in protected mode, CS=0x08, data segments=0x10\n\n**Procedure:**\n1. Disable interrupts (cli)\n2. Load GDTR with GDT address and limit\n3. Set CR0.PE bit (bit 0)\n4. Far jump to flush pipeline: `jmp 0x08:protected_mode_entry`\n5. In 32-bit code:\n   - Load data segment registers with 0x10\n   - Set up stack pointer\n   - Continue execution\n\n**Critical:** Step 4 must immediately follow step 3. The far jump is not optional—the prefetch queue contains 16-bit instructions.\n\n### Algorithm: VGA Scrolling\n\n**Purpose:** Scroll screen up one line when cursor reaches bottom.\n\n**Inputs:** None (operates on VGA buffer)\n**Outputs:** Screen scrolled, cursor at start of last row\n\n**Procedure:**\n1. Copy rows 1-24 to rows 0-23:\n   - Source: 0xB8000 + 160 (row 1)\n   - Dest: 0xB8000 (row 0)\n   - Count: 160 × 24 = 3840 bytes\n2. Clear row 24:\n   - Write space character (0x20) with current attribute\n   - Count: 80 cells = 160 bytes\n3. Set cursor to row 24, column 0\n\n**Invariants:**\n- VGA buffer memory unchanged outside rows 0-24\n- Cursor position valid after scroll\n\n---\n\n## Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n|-------|-------------|----------|---------------|\n| Disk read failure (INT 13h error) | Carry flag set after INT 13h | Print \"Disk error\" via BIOS teletype, halt | Yes, on screen |\n| No boot signature | BIOS before loading MBR | BIOS displays \"No bootable device\" | Yes, BIOS message |\n| A20 line stuck disabled | Memory wrap test fails | Print warning, continue (may crash later) | Yes, serial debug |\n| GDT too large | Compile-time (must be < 64KB) | N/A (compile error) | No |\n| Triple fault after CR0.PE | CPU resets | System reboots | Yes, visible reboot |\n| BSS overlap with code | Linker script error | Link fails | No |\n| VGA buffer not accessible | Page fault (if paging enabled) | Crash | Yes, blank screen |\n| Serial port not present | No THRE bit timeout | Skip serial output | No, VGA still works |\n\n---\n\n## Implementation Sequence with Checkpoints\n\n### Phase 1: Stage 1 Bootloader (4-6 hours)\n\n**Files:** boot/boot.asm\n\n**Steps:**\n1. Set up real mode segment registers and stack\n2. Print boot message via BIOS INT 10h\n3. Enable A20 line\n4. Load kernel from disk to temporary buffer (below 1MB)\n5. Configure GDT\n6. Enter protected mode with far jump\n7. Copy kernel to 0x100000\n8. Jump to kernel entry\n\n**Checkpoint:** Bootloader prints \"Loading...\" and reaches protected mode without triple fault.\n\n**Test:** `qemu-system-i386 -drive format=raw,file=boot.bin -d int,cpu_reset 2>&1 | grep \"SMM: enter\"`\n\n---\n\n### Phase 2: GDT Configuration (2-3 hours)\n\n**Files:** boot/gdt.asm (or inline in boot.asm)\n\n**Steps:**\n1. Define GDT with 5 entries: null, kcode, kdata, ucode, udata\n2. Create GDT descriptor (limit, base)\n3. Verify GDT entries byte-by-byte\n\n**Checkpoint:** GDT loads without fault. Use `info gdt` in QEMU monitor.\n\n**Test:** \n```bash\nqemu-system-i386 -drive format=raw,file=os.img -monitor stdio\n# In monitor: info gdt\n```\n\n---\n\n### Phase 3: Kernel Entry and Linker Script (2-3 hours)\n\n**Files:** boot/kernel_entry.asm, linker.ld, kernel/main.c\n\n**Steps:**\n1. Create linker script placing kernel at 0x100000\n2. Write assembly entry that zeros BSS and calls main\n3. Write minimal main() that halts\n\n**Checkpoint:** Kernel entry reached, main() called.\n\n**Test:** Add infinite loop in main(), verify QEMU doesn't crash.\n\n---\n\n### Phase 4: VGA Driver (2-3 hours)\n\n**Files:** drivers/vga.h, drivers/vga.c\n\n**Steps:**\n1. Define VGA buffer pointer at 0xB8000\n2. Implement vga_init() to clear screen\n3. Implement vga_putchar() with newline and scrolling\n4. Implement vga_puts()\n5. Test from main()\n\n**Checkpoint:** \"Hello from kernel!\" appears on screen.\n\n**Test:** \n```c\nvga_init();\nvga_puts(\"VGA test passed!\\n\");\n```\n\n---\n\n### Phase 5: Serial Driver (1-2 hours)\n\n**Files:** drivers/serial.h, drivers/serial.c, drivers/port_io.h\n\n**Steps:**\n1. Implement outb/inb inline functions\n2. Implement serial_init() with 38400 baud, 8N1\n3. Implement serial_putchar() with THRE wait\n4. Test output to serial\n\n**Checkpoint:** Serial output visible in QEMU console with `-serial stdio`.\n\n**Test:**\n```bash\nqemu-system-i386 -drive format=raw,file=os.img -serial stdio\n# Should see output in terminal\n```\n\n---\n\n### Phase 6: kprintf (2-3 hours)\n\n**Files:** kernel/kprintf.h, kernel/kprintf.c\n\n**Steps:**\n1. Implement string output (call vga_putchar and serial_putchar)\n2. Implement %s, %c, %d, %x\n3. Handle width padding (optional)\n4. Test all format specifiers\n\n**Checkpoint:** kprintf(\"Kernel loaded at 0x%x\\n\", 0x100000) outputs correctly.\n\n**Test:**\n```c\nkprintf(\"Testing: %s %d %x %c\\n\", \"string\", 42, 0xDEAD, 'X');\n// Expected: \"Testing: string 42 dead X\"\n```\n\n---\n\n### Phase 7: Integration and Full Test (2-3 hours)\n\n**Files:** Makefile\n\n**Steps:**\n1. Write Makefile to assemble, compile, link, create disk image\n2. Build complete disk image\n3. Test in QEMU with VGA and serial output\n4. Verify boot sequence with GDB\n\n**Checkpoint:** Kernel boots, displays welcome message on both VGA and serial.\n\n**Test Command:**\n```bash\nmake run\n# Should see: \"Welcome to MyOS!\" on screen and serial\n```\n\n**GDB Debug:**\n```bash\nqemu-system-i386 -drive format=raw,file=os.img -s -S &\ngdb -ex \"target remote localhost:1234\" -ex \"break *0x7C00\" -ex \"continue\"\n```\n\n---\n\n## Test Specification\n\n### Test: Bootloader Loads and Enters Protected Mode\n\n**Setup:** Create boot.bin with boot signature\n**Steps:**\n1. Run QEMU with disk image\n2. Check QEMU doesn't reset (triple fault)\n\n**Expected:** QEMU continues running, no reset\n\n```bash\ntimeout 5 qemu-system-i386 -drive format=raw,file=boot.bin -d cpu_reset 2>&1 | grep -c \"CPU reset\"\n# Expected: 0\n```\n\n---\n\n### Test: GDT Configuration Valid\n\n**Setup:** Bootloader with GDT, halted in protected mode\n\n**Steps:**\n1. Boot in QEMU with monitor\n2. Inspect GDT\n\n**Expected:** 5 entries, base=0, limit=0xFFFFF, correct access bytes\n\n```bash\n# In QEMU monitor:\ninfo gdt\n# Check: entry 1 = code, entry 2 = data, both ring 0\n```\n\n---\n\n### Test: VGA Output\n\n**Setup:** Kernel with VGA driver\n\n**Steps:**\n1. Call vga_init()\n2. Call vga_puts(\"Test\")\n3. Read VGA buffer at 0xB8000\n\n**Expected:** 'T', 'e', 's', 't' at positions 0-3\n\n```c\n// In kernel:\nvga_init();\nvga_puts(\"Test\");\n\n// Verification (could be separate test):\nextern volatile uint16_t *VGA_BUFFER;\nassert(VGA_BUFFER[0] == ('T' | (0x0F << 8)));\n```\n\n---\n\n### Test: Serial Output\n\n**Setup:** Kernel with serial driver\n\n**Steps:**\n1. Initialize COM1\n2. Output test string\n3. Capture serial output in QEMU\n\n**Expected:** String appears on serial console\n\n```bash\nqemu-system-i386 -drive format=raw,file=os.img -serial file:serial.out\n# After boot, serial.out contains expected string\n```\n\n---\n\n### Test: kprintf Format Specifiers\n\n**Setup:** Kernel with kprintf\n\n**Test Cases:**\n| Input | Expected Output |\n|-------|-----------------|\n| `kprintf(\"Hello\")` | \"Hello\" |\n| `kprintf(\"%s\", \"world\")` | \"world\" |\n| `kprintf(\"%d\", 42)` | \"42\" |\n| `kprintf(\"%d\", -17)` | \"-17\" |\n| `kprintf(\"%x\", 0xDEAD)` | \"dead\" |\n| `kprintf(\"%c\", 'X')` | \"X\" |\n\n---\n\n## Performance Targets\n\n| Operation | Target | How to Measure |\n|-----------|--------|----------------|\n| Boot to kernel entry | < 100ms | QEMU `-d` flag with timestamps |\n| VGA putchar | < 1µs | Not critical (human reading speed) |\n| Serial putchar | < 10µs | Baud rate limited (38400 = ~260µs/char) |\n| BSS zeroing (1KB) | < 10µs | `rep stosb` at ~100 MB/s |\n\n---\n\n## Hardware Soul\n\n### Cache Behavior\n\n- **GDT (48 bytes):** Fits in single L1 cache line (64 bytes). `lgdt` loads entire GDT to internal CPU registers; subsequent memory access doesn't re-read GDT.\n- **VGA buffer (4KB):** Memory-mapped I/O, marked uncacheable (UC). Writes go directly to bus, not cache. This is why VGA output is slow—every character incurs bus latency (~100ns).\n\n### Branch Prediction\n\nBoot code is linear:\n- No loops except A20 test (runs once)\n- No function calls except far jump\n- Pipeline flush on far jump is intentional (required for mode switch)\n\n### TLB Behavior\n\nN/A before paging enabled. After paging (Milestone 3), VGA buffer must have a TLB entry.\n\n### Memory Access Patterns\n\n- **Disk read:** Sequential (LBA 0, 1, 2, ...) — prefetch-friendly\n- **VGA write:** Random access (cursor position varies) — cache-hostile, but doesn't matter (MMIO)\n- **BSS zeroing:** Sequential write — maximum bandwidth\n\n---\n\n## Visual Diagrams\n\n\n![Boot Sequence: BIOS to Kernel Entry](./diagrams/tdd-diag-001.svg)\n\nBoot sequence: BIOS → MBR → Protected Mode → Kernel Entry\n\n{{DIAGRAM:tdd-diag-002}}\nGDT entry layout with byte-by-byte breakdown\n\n\n![Real Mode to Protected Mode Transition](./diagrams/tdd-diag-003.svg)\n\nMemory map: bootloader at 0x7C00, kernel at 0x100000, stack at 0x90000\n\n\n![Linker Script: Section Placement](./diagrams/tdd-diag-004.svg)\n\nVGA buffer layout: 80×25 cells, 2 bytes per cell\n\n\n![VGA Text Buffer Memory Layout](./diagrams/tdd-diag-005.svg)\n\nSerial port register map and initialization sequence\n\n\n![Serial Port Initialization Sequence](./diagrams/tdd-diag-006.svg)\n\nProtected mode transition: CR0.PE → far jump → segment reload\n\n\n![kprintf Data Flow](./diagrams/tdd-diag-007.svg)\n\nLinker script section placement: .text, .rodata, .data, .bss\n\n{{DIAGRAM:tdd-diag-008}}\nDual output: kprintf → VGA + Serial\n\n---\n\n[[CRITERIA_JSON: {\"module_id\": \"build-os-m1\", \"criteria\": [\"Bootloader fits in 512 bytes (MBR) or uses a two-stage approach with stage1 in MBR loading stage2 from disk\", \"Bootloader reads kernel binary from disk using BIOS INT 13h and loads it to physical address 0x100000 (1MB mark)\", \"GDT configured with 5 entries: null descriptor, kernel code (ring 0, base=0, limit=4GB, executable+readable), kernel data (ring 0, base=0, limit=4GB, writable), user code (ring 3), user data (ring 3)\", \"Protected mode entered by setting CR0.PE bit after loading GDTR, followed by a far jump to kernel code segment to flush the pipeline\", \"Segment registers DS, ES, FS, GS, SS loaded with kernel data segment selector (0x10) after the far jump to protected mode\", \"Kernel entry point (assembly) zeroes BSS section from __bss_start to __bss_end and calls kernel_main()\", \"VGA text mode driver writes characters with foreground/background color attributes to memory-mapped buffer at 0xB8000\", \"Serial port COM1 (0x3F8) initialized for debug output with kprintf-like function outputting to both VGA and serial\", \"Kernel boots successfully in QEMU displaying welcome message on screen and serial console\"]}]\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-os-m2 -->\n# Module: Interrupts, Exceptions, and Keyboard\n\n## Module Charter\n\nThis module transforms your kernel from a passive program into a reactive system by implementing the interrupt subsystem. It configures the Interrupt Descriptor Table (IDT) with 256 gate descriptors, establishes CPU exception handlers (vectors 0-31) that capture and report processor faults, remaps the 8259 Programmable Interrupt Controller to route hardware IRQs to vectors 32-47, implements a timer interrupt (IRQ0) that provides the scheduling heartbeat, and builds a PS/2 keyboard driver that translates scancodes to ASCII characters. The module does NOT implement preemptive scheduling (Milestone 4), system calls (Milestone 4), or advanced interrupt controllers like APIC. The invariant is: after this module completes, every hardware event (timer tick, keystroke) and CPU exception (page fault, divide error) is captured, processed with full register preservation, and the system remains in a consistent state.\n\n---\n\n## File Structure\n\n```\nkernel/\n├── interrupt/\n│   ├── idt.h                 # 1. IDT structures and declarations\n│   ├── idt.c                 # 1. IDT initialization and gate setting\n│   ├── interrupt.h           # 3. Common interrupt handler interface\n│   ├── interrupt.c           # 3. C handler dispatch\n│   ├── isr.asm               # 2. Exception handler assembly stubs\n│   ├── irq.asm               # 5. IRQ handler assembly stubs\n│   ├── exception.h           # 2. Exception handler declarations\n│   └── exception.c           # 2. Exception-specific handling\n├── pic/\n│   ├── pic.h                 # 4. PIC interface\n│   └── pic.c                 # 4. PIC remapping and EOI\n├── timer/\n│   ├── timer.h               # 6. Timer interface\n│   └── timer.c               # 6. PIT channel 0 programming\n├── keyboard/\n│   ├── keyboard.h            # 7. Keyboard interface\n│   ├── keyboard.c            # 7. Scancode translation\n│   └── scancode.h            # 7. Scancode-to-ASCII tables\n└── Makefile                  # Updated build system\n```\n\n---\n\n## Complete Data Model\n\n### IDT Entry (Gate Descriptor)\n\nEvery IDT entry is 8 bytes, defining where to jump when an interrupt occurs.\n\n```\nOffset  Size  Field\n------  ----  -----\n0       16    Offset bits 0-15 (handler address low)\n2       16    Segment selector (code segment to use)\n4       8     Reserved (must be 0)\n5       8     Type and attributes\n6       16    Offset bits 16-31 (handler address high)\n\nByte 5 (Type/Attributes):\n  Bit 7: Present (P) - 1 = valid gate\n  Bits 5-6: DPL (Descriptor Privilege Level) - 00=ring 0 only, 11=ring 3 can invoke\n  Bit 4: Storage Segment (S) - 0 for interrupt/trap gates\n  Bits 0-3: Gate Type:\n    0x5 = 32-bit task gate (rarely used)\n    0x6 = 16-bit interrupt gate\n    0x7 = 16-bit trap gate\n    0xE = 32-bit interrupt gate (interrupts disabled on entry)\n    0xF = 32-bit trap gate (interrupts stay enabled)\n```\n\n**Memory Layout (8 bytes, little-endian):**\n\n```\nByte:    [0]   [1]   [2]   [3]   [4]   [5]   [6]   [7]\nField:   |--offset_low--| |--selector--| |res| |typ| |--offset_high-|\n         handler_addr    code_seg       0    attrs  handler_addr+16\n\nInterrupt Gate Example (handler at 0x00101234, CS=0x08, DPL=0):\n  [0-1]: 0x1234  - offset low\n  [2-3]: 0x0008  - selector (kernel code)\n  [4]:   0x00    - reserved\n  [5]:   0x8E    - P=1, DPL=0, S=0, Type=0xE (32-bit interrupt gate)\n  [6-7]: 0x0010  - offset high\n```\n\n### IDT Pointer (IDTR Load Value)\n\n```c\ntypedef struct {\n    uint16_t limit;    // Size of IDT - 1 (in bytes): 256 * 8 - 1 = 0x7FF\n    uint32_t base;     // Linear address of IDT array\n} __attribute__((packed)) idt_ptr_t;\n```\n\nSize: 6 bytes. Loaded via `lidt`.\n\n### Interrupt Stack Frame\n\nWhen an interrupt fires, the CPU pushes a specific frame to the stack. The layout depends on privilege level transition.\n\n```\nKernel-to-Kernel (same privilege):\nOffset  Field\n------  -----\n+0      EFLAGS\n+4      CS\n+8      EIP\n+12     [Error code if exception 8, 10-14, 17, 21, 29, 30]\n\nUser-to-Kernel (privilege transition):\nOffset  Field\n------  -----\n+0      SS (old)\n+4      ESP (old)\n+8      EFLAGS\n+12     CS\n+16     EIP\n+20     [Error code if applicable]\n```\n\n**Handler-Pushed State (after CPU pushes):**\n\n```c\ntypedef struct {\n    // Segment registers (pushed by handler)\n    uint32_t gs, fs, es, ds;\n    \n    // General-purpose registers (pushed by pusha)\n    // pusha order: EDI, ESI, EBP, ESP (original), EBX, EDX, ECX, EAX\n    uint32_t edi, esi, ebp, esp_ignored, ebx, edx, ecx, eax;\n    \n    // Handler-pushed interrupt number and error code\n    uint32_t int_no;\n    uint32_t err_code;\n    \n    // CPU-pushed state\n    uint32_t eip;\n    uint32_t cs;\n    uint32_t eflags;\n    \n    // Only present if privilege transition occurred\n    uint32_t useresp;\n    uint32_t ss;\n} __attribute__((packed)) registers_t;\n```\n\n**Memory Layout (stack grows down):**\n\n```\nHigh addresses\n│\n│  [useresp]     <- only if CS.RPL != 0\n│  [ss]          <- only if CS.RPL != 0\n│  eflags\n│  cs\n│  eip\n│  err_code      <- only for exceptions 8,10-14,17,21,29,30\n│  int_no        <- pushed by our stub\n│  eax           <- pusha: last pushed = lowest address\n│  ecx\n│  edx\n│  ebx\n│  esp_ignored   <- value before pusha\n│  ebp\n│  esi\n│  edi           <- pusha: first pushed\n│  ds\n│  es\n│  fs\n│  gs            <- stack pointer points here after all pushes\n│\nLow addresses (ESP points here)\n```\n\n### PIC Registers\n\nThe 8259 PIC has two chips, each with command and data ports.\n\n```\nMaster PIC (IRQ0-7):\n  0x20 - Command port (ICW1, OCW2, OCW3)\n  0x21 - Data port (ICW2, ICW3, ICW4, OCW1 - mask)\n\nSlave PIC (IRQ8-15):\n  0xA0 - Command port\n  0xA1 - Data port\n\nInitialization Command Words (ICW):\n  ICW1 (command port): \n    Bit 0: IC4 - need ICW4\n    Bit 1: SNGL - single (0) vs cascade (1)\n    Bit 4: Init - must be 1\n    Others: 0\n  \n  ICW2 (data port): Vector offset base (IRQ0 → vector N)\n  \n  ICW3 (data port):\n    Master: bit mask of which IRQ has slave (bit 2 = IRQ2)\n    Slave: slave ID (2)\n  \n  ICW4 (data port):\n    Bit 0: 8086 mode (1)\n    Bit 1: Auto-EOI (0 for manual)\n    Bits 4-5: Buffer mode (0)\n\nOperation Control Words:\n  OCW1 (data port): IRQ mask (1 = masked)\n  OCW2 (command port): EOI and priority\n    0x20 = Non-specific EOI\n    0x60 = Specific EOI for IRQ0 (not used)\n```\n\n### PIT (Timer) Registers\n\n```\n0x40 - Channel 0 data port (IRQ0)\n0x41 - Channel 1 data port (DRAM refresh, unused)\n0x42 - Channel 2 data port (speaker)\n0x43 - Mode/Command register\n\nCommand byte (write to 0x43):\n  Bits 6-7: Channel select (00=0, 01=1, 10=2, 11=read-back)\n  Bits 4-5: Access mode (00=latch, 01=low, 10=high, 11=low then high)\n  Bits 1-3: Operating mode (000=int on TC, 011=square wave, etc.)\n  Bit 0: BCD (0=binary)\n\nSquare wave command: 0x36 = 00 11 011 0 = channel 0, lobyte/hibyte, square wave, binary\n```\n\n### Keyboard Buffer\n\nCircular buffer for decoupling interrupt-driven scancode arrival from synchronous character consumption.\n\n```c\n#define KBUFFER_SIZE 256  // Must be power of 2 for efficient modulo\n\ntypedef struct {\n    char buffer[KBUFFER_SIZE];\n    volatile uint32_t read_pos;   // Consumer index\n    volatile uint32_t write_pos;  // Producer index (IRQ handler)\n} keyboard_buffer_t;\n\n// Buffer full: (write_pos + 1) % KBUFFER_SIZE == read_pos\n// Buffer empty: read_pos == write_pos\n// Available: (write_pos - read_pos) % KBUFFER_SIZE\n```\n\n**Cache Line Analysis:**\n- `keyboard_buffer_t` is ~260 bytes = 5 cache lines\n- `read_pos` and `write_pos` are on separate cache lines from `buffer` (good for false sharing)\n- Producer (IRQ) and consumer (main) access different cache lines primarily\n\n---\n\n## Interface Contracts\n\n### idt_init / idt_set_gate\n\n```c\n// Initialize IDT with 256 entries, all set to present but pointing to dummy handler\nvoid idt_init(void);\n\n// Set a specific IDT gate\n// num: vector number (0-255)\n// handler: 32-bit address of handler function\n// selector: code segment selector (typically 0x08 for kernel)\n// flags: type/attributes byte (0x8E for interrupt gate, 0x8F for trap gate)\nvoid idt_set_gate(uint8_t num, uint32_t handler, uint16_t selector, uint8_t flags);\n\n// Load IDT (called internally by idt_init)\nvoid idt_load(void);\n```\n\n**Preconditions:** GDT loaded with valid code segment at selector\n\n**Postconditions:** IDT loaded, CPU will jump to handlers on interrupt\n\n### Exception Handlers (ISR 0-31)\n\n```c\n// Each exception has a dedicated assembly entry point\n// These are declared global in isr.asm, referenced in idt.c\n\n// Assembly stubs (in isr.asm):\nvoid isr0(void);   // Divide by zero\nvoid isr1(void);   // Debug\nvoid isr2(void);   // Non-maskable interrupt\nvoid isr3(void);   // Breakpoint\nvoid isr4(void);   // Overflow\nvoid isr5(void);   // Bound range exceeded\nvoid isr6(void);   // Invalid opcode\nvoid isr7(void);   // Device not available\nvoid isr8(void);   // Double fault (has error code)\nvoid isr9(void);   // Coprocessor segment overrun\nvoid isr10(void);  // Invalid TSS (has error code)\nvoid isr11(void);  // Segment not present (has error code)\nvoid isr12(void);  // Stack-segment fault (has error code)\nvoid isr13(void);  // General protection fault (has error code)\nvoid isr14(void);  // Page fault (has error code)\n// ... 15-31 reserved\n\n// C handler called by assembly stub\nvoid exception_handler(registers_t *regs);\n```\n\n**Error Code Presence (CPU-pushed):**\n| Vector | Exception | Error Code? | Error Code Meaning |\n|--------|-----------|-------------|-------------------|\n| 0 | Divide error | No | N/A |\n| 1 | Debug | No | N/A |\n| 2 | NMI | No | N/A |\n| 3 | Breakpoint | No | N/A |\n| 6 | Invalid opcode | No | N/A |\n| 7 | Device not available | No | N/A |\n| 8 | Double fault | Yes | 0 (always) |\n| 10 | Invalid TSS | Yes | Selector index |\n| 11 | Segment not present | Yes | Selector index |\n| 12 | Stack fault | Yes | Selector index |\n| 13 | General protection | Yes | Selector index or 0 |\n| 14 | Page fault | Yes | P, W, U bits (see below) |\n\n**Page Fault Error Code (Exception 14):**\n```\nBit 0 (P): 0 = page not present, 1 = protection violation\nBit 1 (W): 0 = read access, 1 = write access\nBit 2 (U): 0 = kernel mode, 1 = user mode\nBit 3 (R): 1 = reserved bit set in page table\nBit 4 (I): 1 = instruction fetch (NX violation)\n```\n\n### IRQ Handlers (IRQ 0-15)\n\n```c\n// Assembly stubs (in irq.asm):\nvoid irq0(void);   // Timer (PIT channel 0)\nvoid irq1(void);   // Keyboard (PS/2)\nvoid irq2(void);   // Cascade (slave PIC)\nvoid irq3(void);   // COM2\nvoid irq4(void);   // COM1\nvoid irq5(void);   // LPT2\nvoid irq6(void);   // Floppy\nvoid irq7(void);   // LPT1\nvoid irq8(void);   // RTC\nvoid irq9(void);   // Free\nvoid irq10(void);  // Free\nvoid irq11(void);  // Free\nvoid irq12(void);  // PS/2 mouse\nvoid irq13(void);  // FPU\nvoid irq14(void);  // Primary ATA\nvoid irq15(void);  // Secondary ATA\n\n// C handler called by assembly stub\nvoid irq_handler(registers_t *regs);\n```\n\n**Vector Mapping (after PIC remap):**\n| IRQ | Vector | Source |\n|-----|--------|--------|\n| 0 | 32 | Timer (PIT) |\n| 1 | 33 | Keyboard |\n| 2 | 34 | Cascade |\n| 3-7 | 35-39 | Various |\n| 8 | 40 | RTC |\n| 9-15 | 41-47 | Various |\n\n### pic_remap / pic_send_eoi\n\n```c\n// Remap PIC to route IRQs to vectors starting at offset1 (master) and offset2 (slave)\n// Must be called before enabling interrupts\n// Standard: offset1=32, offset2=40\nvoid pic_remap(int offset1, int offset2);\n\n// Send End of Interrupt to PIC(s)\n// Must be called at end of every IRQ handler\n// irq: IRQ number (0-15), not vector number\nvoid pic_send_eoi(uint8_t irq);\n\n// Mask/unmask specific IRQ\nvoid pic_mask_irq(uint8_t irq);\nvoid pic_unmask_irq(uint8_t irq);\n```\n\n**Preconditions:** PIC exists and is responsive\n\n**Postconditions:** IRQs routed to correct vectors, EOI mechanism working\n\n**CRITICAL:** `pic_send_eoi` must be called for every IRQ. Forgetting this freezes the system.\n\n### timer_init / timer_handler\n\n```c\n#define PIT_BASE_FREQUENCY 1193182  // Hz\n\n// Initialize PIT channel 0 to fire at specified frequency\n// frequency: desired interrupt rate in Hz (typically 100-1000)\nvoid timer_init(uint32_t frequency);\n\n// Called by IRQ handler on timer interrupt\nvoid timer_handler(void);\n\n// Global tick counter (incremented every timer interrupt)\nextern volatile uint64_t timer_ticks;\n```\n\n**Preconditions:** PIC remapped, IRQ0 unmasked, IDT gate 32 set\n\n**Edge Cases:**\n| Frequency | Behavior |\n|-----------|----------|\n| < 19 | Clamped to 19 (PIT minimum) |\n| > 1.19 MHz | Clamped to max (divisor=1) |\n| 0 | Division error, halt |\n\n### keyboard_init / keyboard_handler / keyboard_getchar\n\n```c\n#define KEYBOARD_PORT 0x60\n\n// Initialize keyboard driver (clear buffer, reset state)\nvoid keyboard_init(void);\n\n// Called by IRQ handler on keyboard interrupt\n// Reads scancode from port 0x60, translates to ASCII, stores in buffer\nvoid keyboard_handler(void);\n\n// Blocking read: returns next ASCII character from buffer\n// Waits (via hlt) until character available\nchar keyboard_getchar(void);\n\n// Non-blocking read: returns character or 0 if buffer empty\nchar keyboard_getchar_nonblocking(void);\n\n// Check if characters available\nint keyboard_has_char(void);\n```\n\n**Preconditions:** PIC remapped, IRQ1 unmasked, IDT gate 33 set\n\n**Edge Cases:**\n| Scancode | Behavior |\n|----------|----------|\n| 0x2A, 0x36 | Shift pressed, set flag |\n| 0xAA, 0xB6 | Shift released, clear flag |\n| 0x3A | Caps lock toggle |\n| 0xE0 | Extended scancode prefix (arrow keys, etc.) |\n| 0x80+ | Break code (key released), ignore |\n\n---\n\n## Algorithm Specification\n\n### Algorithm: IDT Gate Installation\n\n**Purpose:** Configure a single IDT entry to jump to a handler.\n\n**Inputs:** \n- Vector number (0-255)\n- Handler address (32-bit)\n- Selector (16-bit code segment)\n- Flags (8-bit type/attributes)\n\n**Outputs:** IDT entry populated, handler reachable\n\n**Procedure:**\n1. Calculate array index (same as vector number)\n2. Store offset_low = handler & 0xFFFF\n3. Store selector as-is\n4. Store reserved byte = 0\n5. Store flags byte (type, DPL, present)\n6. Store offset_high = (handler >> 16) & 0xFFFF\n\n**Invariants:**\n- All 256 entries exist after initialization\n- Present bit set only for installed handlers\n- Handler address is within code segment\n\n### Algorithm: Interrupt Entry (Assembly Stub)\n\n**Purpose:** Save CPU state, call C handler, restore state, return.\n\n**Inputs:** None (triggered by CPU on interrupt)\n**Outputs:** C handler called, EOI sent (for IRQs), system state preserved\n\n**Procedure:**\n1. **Save segment registers:**\n   ```\n   push ds, es, fs, gs\n   ```\n\n2. **Load kernel data segment:**\n   ```\n   mov ax, 0x10\n   mov ds, ax\n   mov es, ax\n   mov fs, ax\n   mov gs, ax\n   ```\n\n3. **Save general-purpose registers:**\n   ```\n   pusha  ; pushes EDI, ESI, EBP, ESP, EBX, EDX, ECX, EAX\n   ```\n\n4. **Push interrupt number:**\n   ```\n   push byte <int_no>\n   ```\n\n5. **Call C handler:**\n   ```\n   push esp        ; pass pointer to saved state\n   call c_interrupt_handler\n   add esp, 4      ; clean up argument\n   ```\n\n6. **Restore general-purpose registers:**\n   ```\n   popa\n   ```\n\n7. **Restore segment registers:**\n   ```\n   pop gs, fs, es, ds\n   ```\n\n8. **Clean up interrupt number and error code:**\n   ```\n   add esp, 8      ; int_no + (error_code or dummy)\n   ```\n\n9. **Return from interrupt:**\n   ```\n   iret\n   ```\n\n**Critical:** For exceptions that don't push error code, the stub must push a dummy 0 before pushing int_no. This ensures uniform stack frame.\n\n### Algorithm: Exception with Error Code Handling\n\n**Purpose:** Handle the fact that some exceptions push error codes and some don't.\n\n**Inputs:** Exception vector number\n**Outputs:** Uniform stack frame for C handler\n\n**Procedure:**\n\nFor exceptions WITHOUT error code (use macro):\n```\nisrN:\n    cli\n    push byte 0        ; Dummy error code\n    push byte N        ; Interrupt number\n    jmp isr_common_stub\n```\n\nFor exceptions WITH error code (use macro):\n```\nisrM:\n    cli\n    push byte M        ; Interrupt number (error already pushed by CPU)\n    jmp isr_common_stub\n```\n\n**Vectors requiring error code handling:**\n- WITH error code: 8, 10, 11, 12, 13, 14, 17, 21, 29, 30\n- WITHOUT error code: 0-7, 9, 15, 16, 18-20, 22-28, 31\n\n### Algorithm: PIC Remapping\n\n**Purpose:** Change IRQ-to-vector mapping from broken defaults to usable range.\n\n**Inputs:** Offset1 (master base vector), offset2 (slave base vector)\n**Outputs:** IRQ0-7 → vectors 32-39, IRQ8-15 → vectors 40-47\n\n**Procedure:**\n1. **Save current masks:**\n   ```\n   in al, 0x21   ; Master mask\n   mov [master_mask], al\n   in al, 0xA1   ; Slave mask\n   mov [slave_mask], al\n   ```\n\n2. **Start initialization (ICW1):**\n   ```\n   out 0x20, 0x11   ; Master: init + need ICW4\n   out 0xA0, 0x11   ; Slave: init + need ICW4\n   ```\n\n3. **Set vector offsets (ICW2):**\n   ```\n   out 0x21, offset1   ; Master: IRQ0 → vector 32\n   out 0xA1, offset2   ; Slave: IRQ8 → vector 40\n   ```\n\n4. **Configure cascade (ICW3):**\n   ```\n   out 0x21, 0x04   ; Master: slave at IRQ2 (bit 2 set)\n   out 0xA1, 0x02   ; Slave: I am slave ID 2\n   ```\n\n5. **Set mode (ICW4):**\n   ```\n   out 0x21, 0x01   ; Master: 8086 mode, manual EOI\n   out 0xA1, 0x01   ; Slave: 8086 mode, manual EOI\n   ```\n\n6. **Restore masks:**\n   ```\n   mov al, [master_mask]\n   out 0x21, al\n   mov al, [slave_mask]\n   out 0xA1, al\n   ```\n\n**Invariants:**\n- Master and slave both in 8086 mode\n- Slave connected to master IRQ2\n- No IRQs lost during remap (interrupts disabled)\n\n### Algorithm: EOI Handling\n\n**Purpose:** Tell PIC that interrupt handling is complete, allow next IRQ.\n\n**Inputs:** IRQ number (0-15)\n**Outputs:** PIC in-service register updated\n\n**Procedure:**\n1. If IRQ >= 8 (from slave):\n   ```\n   out 0xA0, 0x20   ; EOI to slave\n   ```\n2. Always send EOI to master:\n   ```\n   out 0x20, 0x20   ; EOI to master\n   ```\n\n**CRITICAL:** Order matters. Slave EOI first, then master.\n\n**Why this matters:** Without EOI, the PIC's In-Service Register keeps the IRQ marked active. The PIC will not deliver any lower-priority IRQs. System appears frozen.\n\n### Algorithm: Timer Frequency Programming\n\n**Purpose:** Configure PIT channel 0 to fire at desired frequency.\n\n**Inputs:** Desired frequency in Hz\n**Outputs:** IRQ0 firing at specified rate\n\n**Procedure:**\n1. Calculate divisor:\n   ```\n   divisor = PIT_BASE_FREQUENCY / frequency\n   if divisor < 1: divisor = 1\n   if divisor > 65535: divisor = 65535\n   ```\n\n2. Send command byte:\n   ```\n   out 0x43, 0x36   ; Channel 0, lobyte/hibyte, square wave, binary\n   ```\n\n3. Send divisor (low byte first):\n   ```\n   out 0x40, divisor & 0xFF\n   out 0x40, (divisor >> 8) & 0xFF\n   ```\n\n**Example:** 100 Hz frequency\n- divisor = 1193182 / 100 = 11931\n- Low byte: 0x1B\n- High byte: 0x2E\n\n### Algorithm: Scancode Translation\n\n**Purpose:** Convert hardware scancode to ASCII character.\n\n**Inputs:** Scancode byte from port 0x60\n**Outputs:** ASCII character (or 0 for non-printable)\n\n**Procedure:**\n1. Read scancode from port 0x60\n\n2. Check if break code (bit 7 set):\n   ```\n   if scancode & 0x80:\n       scancode &= 0x7F\n       if scancode == LEFT_SHIFT or RIGHT_SHIFT:\n           shift_pressed = 0\n       return  ; Ignore other break codes\n   ```\n\n3. Handle modifier keys:\n   ```\n   if scancode == LEFT_SHIFT or scancode == RIGHT_SHIFT:\n       shift_pressed = 1\n       return\n   if scancode == CAPS_LOCK:\n       caps_lock = !caps_lock\n       return\n   ```\n\n4. Translate using table:\n   ```\n   if shift_pressed xor caps_lock:\n       ascii = scancode_shift_table[scancode]\n   else:\n       ascii = scancode_table[scancode]\n   ```\n\n5. Store in buffer if printable:\n   ```\n   if ascii != 0:\n       buffer[write_pos] = ascii\n       write_pos = (write_pos + 1) % KBUFFER_SIZE\n   ```\n\n**Scancode Set 1 (US QWERTY) Partial Table:**\n```\nScancode  Key      Normal  Shift\n--------  ---      ------  -----\n0x02      1        1       !\n0x03      2        2       @\n0x04      3        3       #\n...\n0x10      Q        q       Q\n0x11      W        w       W\n0x12      E        e       E\n...\n0x1E      A        a       A\n0x1F      S        s       S\n...\n0x39      Space    ' '     ' '\n```\n\n---\n\n## Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n|-------|-------------|----------|---------------|\n| Triple fault | CPU reset | System reboots | Yes, reboot loop |\n| Missing EOI | System hangs (no more IRQs) | N/A (prevent by code review) | Yes, frozen system |\n| Stack overflow in handler | Page fault or random crash | Increase stack size | Yes, crash |\n| Exception during exception | Double fault (vector 8) | Print diagnostic, halt | Yes, error message |\n| Invalid IDT entry | General protection fault | GPF handler prints info | Yes, error message |\n| PIC not responding | Timeout on I/O | Continue, warn on serial | Debug only |\n| Keyboard buffer overflow | write_pos catches read_pos | Drop oldest character | No (or key lost) |\n| Unknown scancode | No table entry | Ignore, no buffer write | No |\n| Page fault in handler | Infinite page fault loop | Use task gate or reserved stack | Yes, crash |\n\n---\n\n## State Machine: Keyboard Modifier State\n\n```\n           +-----------------+\n           |    NORMAL       |\n           +-------+---------+\n                   |\n        +----------+----------+\n        |                     |\n  Shift press            Caps lock press\n        |                     |\n        v                     v\n+---------------+      +-------------+\n| SHIFT_ACTIVE  |      | CAPS_ACTIVE |\n+-------+-------+      +------+------+\n        |                     |\n  Shift release          Caps lock press\n        |                     |\n        v                     v\n+-------+-------+      +-------------+\n|    NORMAL     |      |   NORMAL    |\n+---------------+      +-------------+\n\nTranslation logic:\n  uppercase = shift_pressed XOR caps_lock\n```\n\n---\n\n## Implementation Sequence with Checkpoints\n\n### Phase 1: IDT Structure and Loading (2-3 hours)\n\n**Files:** interrupt/idt.h, interrupt/idt.c\n\n**Steps:**\n1. Define `idt_entry_t` and `idt_ptr_t` structures\n2. Declare IDT array (256 entries)\n3. Implement `idt_set_gate()`\n4. Implement `idt_load()` with inline assembly\n5. Implement `idt_init()` to clear all entries\n\n**Checkpoint:** IDT loads without fault. `info idt` in QEMU shows 256 entries.\n\n**Test:**\n```bash\nqemu-system-i386 -drive format=raw,file=os.img -monitor stdio\n# In monitor: info idt\n# Should show IDT at loaded address\n```\n\n---\n\n### Phase 2: Exception Handlers (4-5 hours)\n\n**Files:** interrupt/isr.asm, interrupt/exception.h, interrupt/exception.c\n\n**Steps:**\n1. Define macros `ISR_NO_ERROR` and `ISR_ERROR`\n2. Implement all 32 exception stubs\n3. Implement `isr_common_stub` that saves/restores all registers\n4. Implement `exception_handler()` in C with descriptive messages\n5. Register exception handlers in IDT\n\n**Checkpoint:** Trigger divide by zero, see exception message.\n\n**Test:**\n```c\n// In kernel_main, after IDT init:\nint a = 1;\nint b = 0;\nint c = a / b;  // Should trigger exception 0\n```\n\n---\n\n### Phase 3: Interrupt Stack Frame (3-4 hours)\n\n**Files:** interrupt/interrupt.h, interrupt/interrupt.c\n\n**Steps:**\n1. Define `registers_t` structure matching stack layout\n2. Implement `c_interrupt_handler()` that dispatches based on int_no\n3. Update assembly stub to pass stack pointer to C handler\n4. Add debug output to dump registers on exception\n\n**Checkpoint:** Exception handler prints all register values correctly.\n\n**Test:** Trigger page fault by accessing invalid address:\n```c\nint *ptr = (int *)0xDEADBEEF;\n*ptr = 42;  // Page fault\n```\n\n---\n\n### Phase 4: PIC Remapping (2-3 hours)\n\n**Files:** pic/pic.h, pic/pic.c\n\n**Steps:**\n1. Implement `pic_remap()` with ICW1-ICW4 sequence\n2. Implement `pic_send_eoi()`\n3. Implement `pic_mask_irq()` and `pic_unmask_irq()`\n4. Call `pic_remap(32, 40)` before enabling interrupts\n\n**Checkpoint:** IRQ0 (timer) doesn't trigger double fault.\n\n**Test:**\n```c\npic_remap(32, 40);\npic_unmask_irq(0);  // Enable timer\n__asm__ volatile (\"sti\");\n// If no double fault, remap succeeded\n```\n\n---\n\n### Phase 5: EOI Handling and IRQ Routing (2-3 hours)\n\n**Files:** interrupt/irq.asm, pic/pic.c (update)\n\n**Steps:**\n1. Define IRQ stubs (irq0-irq15) in assembly\n2. Implement `irq_common_stub` similar to ISR stub\n3. Implement `irq_handler()` in C that calls `pic_send_eoi()`\n4. Register IRQ handlers in IDT at vectors 32-47\n\n**Checkpoint:** Timer interrupt fires repeatedly without hanging.\n\n**Test:**\n```c\ntimer_init(100);\npic_unmask_irq(0);\n__asm__ volatile (\"sti\");\n// Wait 1 second, check timer_ticks ≈ 100\n```\n\n---\n\n### Phase 6: Timer Interrupt (2-3 hours)\n\n**Files:** timer/timer.h, timer/timer.c\n\n**Steps:**\n1. Implement `timer_init()` to program PIT channel 0\n2. Implement `timer_handler()` to increment tick counter\n3. Register timer handler in IRQ dispatch\n4. Add `timer_get_seconds()` helper\n\n**Checkpoint:** Timer ticks increment at expected rate.\n\n**Test:**\n```c\ntimer_init(100);  // 100 Hz\nuint64_t start = timer_ticks;\n// Wait ~1 second (busy loop or hlt loop)\nuint64_t elapsed = timer_ticks - start;\nkprintf(\"Ticks: %d (expected ~100)\\n\", elapsed);\n```\n\n---\n\n### Phase 7: PS/2 Keyboard Driver (3-4 hours)\n\n**Files:** keyboard/keyboard.h, keyboard/keyboard.c, keyboard/scancode.h\n\n**Steps:**\n1. Implement `keyboard_init()` to clear buffer\n2. Define scancode-to-ASCII tables (normal and shifted)\n3. Implement `keyboard_handler()` to read scancode, translate, store\n4. Handle shift press/release\n5. Register keyboard handler in IRQ dispatch\n\n**Checkpoint:** Keystrokes appear in buffer.\n\n**Test:**\n```c\nkeyboard_init();\npic_unmask_irq(1);  // Enable keyboard IRQ\n__asm__ volatile (\"sti\");\n// Press keys, check buffer contents\n```\n\n---\n\n### Phase 8: Circular Keyboard Buffer (1-2 hours)\n\n**Files:** keyboard/keyboard.c (update)\n\n**Steps:**\n1. Implement circular buffer with read_pos/write_pos\n2. Implement `keyboard_getchar()` with blocking (hlt)\n3. Implement `keyboard_getchar_nonblocking()`\n4. Handle buffer overflow (drop oldest or ignore new)\n\n**Checkpoint:** `keyboard_getchar()` returns typed characters.\n\n**Test:**\n```c\nkprintf(\"Type something: \");\nwhile (1) {\n    char c = keyboard_getchar();\n    kprintf(\"%c\", c);\n    if (c == 'q') break;\n}\n```\n\n---\n\n## Test Specification\n\n### Test: IDT Loads Without Fault\n\n**Setup:** IDT initialized with 256 entries\n\n**Steps:**\n1. Call `idt_init()`\n2. Verify `lidt` executed (check with QEMU monitor)\n\n**Expected:** No triple fault, IDT visible in QEMU\n\n```bash\nqemu-system-i386 -drive format=raw,file=os.img -monitor stdio\n# In monitor:\ninfo idt\n# Should show: IDT base=0x... limit=0x7ff\n```\n\n---\n\n### Test: Exception Handler Catches Divide Error\n\n**Setup:** Exception 0 handler registered\n\n**Steps:**\n1. Execute division by zero\n2. Verify exception handler called\n\n**Expected:** \"Division by zero\" message printed\n\n```c\nvolatile int x = 1;\nvolatile int y = 0;\nvolatile int z = x / y;  // Exception 0\n// Should not reach here\n```\n\n---\n\n### Test: Exception Handler Catches Page Fault\n\n**Setup:** Exception 14 handler registered, paging enabled\n\n**Steps:**\n1. Access invalid memory address\n2. Verify CR2 read and error code decoded\n\n**Expected:** Page fault message with faulting address\n\n```c\nuint32_t *ptr = (uint32_t *)0xDEADBEEF;\n*ptr = 42;  // Page fault\n// Should not reach here\n```\n\n**Verify CR2:** Handler should print CR2 = 0xDEADBEEF\n\n---\n\n### Test: PIC Remapped Correctly\n\n**Setup:** PIC remapped to vectors 32-47\n\n**Steps:**\n1. Enable timer interrupt\n2. Verify no double fault\n\n**Expected:** Timer fires without triggering exception 8\n\n```c\npic_remap(32, 40);\nidt_set_gate(32, (uint32_t)irq0, 0x08, 0x8E);\npic_unmask_irq(0);\ntimer_init(100);\n__asm__ volatile (\"sti\");\n// If we get here, remap succeeded\n```\n\n---\n\n### Test: EOI Sent on Every IRQ\n\n**Setup:** Timer interrupt enabled\n\n**Steps:**\n1. Let timer fire multiple times\n2. Verify ticks increment\n\n**Expected:** Multiple timer interrupts without system freeze\n\n```c\ntimer_init(100);\n__asm__ volatile (\"sti\");\nfor (volatile int i = 0; i < 10000000; i++);  // Busy wait\n// timer_ticks should be > 0\nassert(timer_ticks > 0);\n```\n\n---\n\n### Test: Timer Frequency Accuracy\n\n**Setup:** Timer at 100 Hz\n\n**Steps:**\n1. Record start ticks\n2. Wait approximately 1 second\n3. Record end ticks\n\n**Expected:** ~100 ticks (±10%)\n\n```c\ntimer_init(100);\nuint64_t start = timer_ticks;\n// Wait ~1 second (could use PIT channel 2 for precise timing)\nfor (volatile int i = 0; i < 50000000; i++);\nuint64_t elapsed = timer_ticks - start;\nkprintf(\"Elapsed ticks: %d (expected ~100)\\n\", (int)elapsed);\n```\n\n---\n\n### Test: Keyboard Scancode Translation\n\n**Setup:** Keyboard interrupt enabled\n\n**Steps:**\n1. Press 'A' key\n2. Check buffer contains 'a'\n\n**Expected:** 'a' (lowercase) in buffer\n\n```c\nkeyboard_init();\n__asm__ volatile (\"sti\");\n// User presses 'A'\nchar c = keyboard_getchar();\nassert(c == 'a');\n```\n\n---\n\n### Test: Shift Key Modifies Output\n\n**Setup:** Keyboard interrupt enabled\n\n**Steps:**\n1. Hold shift, press 'A'\n2. Check buffer contains 'A'\n\n**Expected:** 'A' (uppercase) in buffer\n\n```c\n// User holds shift and presses 'A'\nchar c = keyboard_getchar();\nassert(c == 'A');\n```\n\n---\n\n### Test: Circular Buffer Overflow\n\n**Setup:** Keyboard buffer size 16 (for testing)\n\n**Steps:**\n1. Type 20 characters without reading\n2. Verify oldest characters dropped or newest rejected\n\n**Expected:** Buffer contains last 15 characters (or first 15)\n\n```c\n// Modify KBUFFER_SIZE to 16 for testing\n// Type 20 characters\n// Check that buffer state is consistent\n```\n\n---\n\n## Performance Targets\n\n| Operation | Target | How to Measure |\n|-----------|--------|----------------|\n| IRQ to handler entry | < 2 µs | QEMU `-d int` with timestamps |\n| Exception handler complete | < 10 µs | Cycle counter before/after |\n| Timer handler (tick++) | < 5 µs | Same as above |\n| Keyboard scancode to buffer | < 50 µs | Port read + table lookup + buffer write |\n| EOI to next IRQ allowed | < 1 µs | I/O port write timing |\n| Full context save/restore | < 1 µs | pusha/popa timing (~20 cycles) |\n\n**Measurement Method:**\n```bash\nqemu-system-i386 -drive format=raw,file=os.img -d int 2>&1 | head -100\n# Shows interrupt entry/exit with timestamps\n```\n\n---\n\n## Hardware Soul\n\n### Cache Behavior\n\n- **IDT (2KB):** Spans 32 cache lines. Frequently accessed entries (timer, keyboard, page fault) will be cached. First access on each entry causes cache miss (~50 cycles).\n- **Keyboard buffer (256B):** Fits in 4 cache lines. Producer (IRQ handler) and consumer (main loop) may cause cache coherency traffic if on different cores (not applicable for single-core).\n- **Interrupt stack:** Assumes 4KB kernel stack. If handler uses >4KB local variables, stack overflow corrupts adjacent memory.\n\n### Branch Prediction\n\n- **Exception handlers:** Unpredictable (rare events). Branch misprediction on error handling paths is acceptable.\n- **Timer handler:** Highly predictable (straight-line, increment counter). Good IPC.\n- **Keyboard handler:** Moderately predictable (check shift state, table lookup). Shift state branch is predictable (usually not pressed).\n\n### TLB Behavior\n\n- **Handler code:** Must be in identity-mapped region or always-present pages. Page fault during exception handling = double fault.\n- **Keyboard buffer:** Should be in kernel memory (always mapped). If in user memory, page fault on IRQ = crash.\n\n### Memory Access Patterns\n\n- **Stack (pusha/popa):** Sequential, cache-line aligned after first push. Maximum bandwidth.\n- **Keyboard buffer:** Circular with random access pattern from consumer. Producer is append-only (sequential).\n- **Scancode table:** Random access (scancode as index). 128-entry table fits in single cache line if using uint8_t.\n\n### SIMD Opportunity\n\nNone. Interrupt handlers save/restore all state; SIMD (SSE/AVX) would require saving 512+ bytes of register state. Not worth the overhead for simple handlers.\n\n---\n\n## Concurrency Specification\n\n### Interrupt Safety\n\n| Data Structure | Access Pattern | Protection |\n|----------------|----------------|------------|\n| IDT entries | Write once at boot, read by CPU | No protection needed |\n| timer_ticks | Write by IRQ, read by main | `volatile`, atomic on x86 |\n| keyboard buffer | Write by IRQ, read by main | Circular buffer with volatile indices |\n| shift_pressed | Write by IRQ, read by IRQ | Single-threaded (IRQ context) |\n| VGA buffer | Write by IRQ or main | Not protected (race OK for debug output) |\n\n### Reentrancy\n\n- **Exception handlers:** NOT reentrant. If exception occurs during exception handling, double fault.\n- **IRQ handlers:** CAN be interrupted by higher-priority IRQs (if IF=1). Timer and keyboard handlers must be reentrant-safe.\n- **Solution:** Use per-CPU data (not needed for single-core). Disable interrupts during critical sections.\n\n### Critical Sections\n\n```c\n// Example: safely reading timer_ticks\nuint64_t get_timer_ticks(void) {\n    // On 32-bit, reading 64-bit value is not atomic\n    // But IRQ won't corrupt it—only increment\n    // Safe for single-reader, single-writer\n    return timer_ticks;\n}\n\n// Example: safely reading keyboard buffer\nchar keyboard_getchar(void) {\n    while (read_pos == write_pos) {\n        __asm__ volatile (\"hlt\");  // Wait for IRQ\n    }\n    // IRQ won't corrupt this read (single consumer)\n    char c = buffer[read_pos];\n    read_pos = (read_pos + 1) % KBUFFER_SIZE;\n    return c;\n}\n```\n\n---\n\n## Visual Diagrams\n\n{{DIAGRAM:tdd-diag-009}}\nIDT entry layout with byte-by-byte breakdown\n\n\n![Interrupt Stack Frame: CPU-Pushed vs Handler-Pushed](./diagrams/tdd-diag-010.svg)\n\nInterrupt stack frame: CPU-pushed vs handler-pushed\n\n\n![CPU Exception Flow: Divide Error to Handler](./diagrams/tdd-diag-011.svg)\n\nPIC cascade: master (IRQ0-7) and slave (IRQ8-15)\n\n\n![PIC Remapping: IRQ to Vector Translation](./diagrams/tdd-diag-012.svg)\n\nEOI timing: In-Service Register state transitions\n\n\n![EOI Timing: Why Forgetting EOI Freezes the System](./diagrams/tdd-diag-013.svg)\n\nPIT channel 0 programming: divisor calculation\n\n{{DIAGRAM:tdd-diag-014}}\nKeyboard scancode flow: port 0x60 → translation → buffer\n\n\n![Circular Keyboard Buffer State Machine](./diagrams/tdd-diag-015.svg)\n\nCircular buffer indices: read_pos and write_pos\n\n{{DIAGRAM:tdd-diag-016}}\nException handling flow: CPU → stub → C handler → EOI (for IRQs) → iret\n\n---\n\n[[CRITERIA_JSON: {\"module_id\": \"build-os-m2\", \"criteria\": [\"IDT contains 256 entries with entries 0-31 configured for CPU exceptions including divide error, page fault, and general protection fault with descriptive error messages\", \"All interrupt handlers save general-purpose registers (pusha) and segment registers on entry and restore them before iret; handlers for exceptions 8, 10-14 account for the error code pushed by the CPU\", \"PIC 8259 is remapped so IRQ0-7 map to vectors 32-39 and IRQ8-15 map to vectors 40-47, avoiding conflicts with CPU exception vectors 0-31\", \"EOI is sent to the correct PIC (master for IRQ0-7, both master and slave for IRQ8-15) at the end of each IRQ handler before iret\", \"Timer interrupt (IRQ0 via PIT channel 0) fires at a configurable frequency (e.g., 100Hz) and increments a global tick counter on each interrupt\", \"Keyboard interrupt (IRQ1) reads PS/2 scancode from port 0x60, converts to ASCII using a scancode-to-ASCII table, and places characters in a circular keyboard buffer\", \"Double fault handler (exception 8) catches cascading faults, prints diagnostic information including error code, and halts the system instead of allowing a triple fault\", \"Interrupts are enabled (sti) only after IDT is loaded and PIC is remapped and configured\"]}]\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-os-m3 -->\n# Module: Physical and Virtual Memory Management\n\n## Module Charter\n\nThis module implements the memory management layer that transforms raw physical RAM into a virtualized address space. It parses the BIOS memory map (E820 or multiboot) to identify usable regions, manages physical frames through a bitmap allocator (1 bit per 4KB frame), constructs two-level page tables (page directory + page tables) for virtual-to-physical translation, establishes both identity mapping (for bootstrap) and higher-half kernel mapping (for isolation), provides TLB management through `invlpg` and CR3 reload, handles page faults by reading CR2 and decoding error codes, and implements a kernel heap allocator (`kmalloc`/`kfree`) for dynamic memory. This module does NOT implement demand paging from disk, copy-on-write semantics, swap, or per-process address spaces (Milestone 4). The invariant is: after this module completes, every virtual address translates correctly to a physical frame (or faults with diagnostic information), physical frames are never double-allocated, and dynamic memory is available through the heap.\n\n---\n\n## File Structure\n\n```\nkernel/\n├── mm/\n│   ├── memory_map.h          # 1. Memory region structures\n│   ├── memory_map.c          # 1. E820/multiboot parsing\n│   ├── pmm.h                 # 2. Physical frame allocator interface\n│   ├── pmm.c                 # 2. Bitmap implementation\n│   ├── vmm.h                 # 3-4. Virtual memory structures and API\n│   ├── vmm.c                 # 3-4. Page table management\n│   ├── paging.h              # 5-7. Identity/higher-half setup\n│   ├── paging.c              # 5-7. Paging enable and transition\n│   ├── tlb.h                 # 8. TLB management interface\n│   ├── tlb.c                 # 8. invlpg and CR3 helpers\n│   ├── page_fault.h          # 9. Page fault handler interface\n│   ├── page_fault.c          # 9. CR2 reading and diagnostics\n│   ├── kmalloc.h             # 10. Kernel heap interface\n│   └── kmalloc.c             # 10. Linked-list allocator\n├── linker.ld                 # Updated for higher-half addresses\n└── Makefile                  # Updated build system\n```\n\n---\n\n## Complete Data Model\n\n### Memory Region (E820/Multiboot Entry)\n\nEach region describes a contiguous range of physical memory with a type classification.\n\n```c\n/* memory_map.h */\n\ntypedef enum {\n    MEMORY_TYPE_USABLE = 1,           // Available RAM\n    MEMORY_TYPE_RESERVED = 2,         // Reserved (BIOS, etc.)\n    MEMORY_TYPE_ACPI_RECLAIMABLE = 3, // ACPI tables (can reclaim after use)\n    MEMORY_TYPE_NVS = 4,              // ACPI Non-Volatile Storage\n    MEMORY_TYPE_BAD = 5               // Bad memory\n} memory_type_t;\n\ntypedef struct {\n    uint64_t base;       // Physical start address\n    uint64_t length;     // Region length in bytes\n    memory_type_t type;  // Region classification\n    uint32_t acpi_attrs; // ACPI extended attributes (if available)\n} memory_region_t;\n\n#define MAX_MEMORY_REGIONS 64\n\nextern memory_region_t memory_regions[MAX_MEMORY_REGIONS];\nextern int memory_region_count;\n```\n\n**Memory Layout:**\n\n```\nOffset  Size  Field\n------  ----  -----\n0       8     base (64-bit, little-endian)\n8       8     length (64-bit, little-endian)\n16      4     type (enum as uint32_t)\n20      4     acpi_attrs (optional, may be padding)\nTotal: 24 bytes per entry\n```\n\n**Multiboot1 mmap Entry (from bootloader):**\n\n```\nOffset  Size  Field\n------  ----  -----\n0       4     entry_size (size of this entry minus this field)\n4       8     base_addr (64-bit)\n12      8     length (64-bit)\n20      4     type (uint32_t)\n```\n\n### Physical Frame Bitmap\n\nThe frame allocator uses a bitmap where each bit represents one 4KB frame.\n\n```c\n/* pmm.h */\n\n#define FRAME_SIZE       4096                // 4KB per frame\n#define FRAME_SHIFT      12                  // log2(4096)\n#define MAX_PHYSICAL_MB  4096                // Support up to 4GB\n#define MAX_FRAMES       (MAX_PHYSICAL_MB * 1024 / 4)  // 1M frames for 4GB\n#define BITMAP_SIZE      (MAX_FRAMES / 8)    // 128KB bitmap for 4GB\n#define BITMAP_WORDS     (BITMAP_SIZE / 4)   // 32768 uint32_t words\n\nextern uint32_t frame_bitmap[BITMAP_WORDS];\n\n// Frame state encoding:\n//   bit = 0: frame is FREE\n//   bit = 1: frame is USED\n\n// Bit manipulation helpers\n#define FRAME_INDEX(addr)    ((addr) >> FRAME_SHIFT)\n#define WORD_INDEX(frame)    ((frame) >> 5)       // frame / 32\n#define BIT_INDEX(frame)     ((frame) & 0x1F)     // frame % 32\n\n#define SET_BIT(frame)       (frame_bitmap[WORD_INDEX(frame)] |= (1U << BIT_INDEX(frame)))\n#define CLEAR_BIT(frame)     (frame_bitmap[WORD_INDEX(frame)] &= ~(1U << BIT_INDEX(frame)))\n#define TEST_BIT(frame)      (frame_bitmap[WORD_INDEX(frame)] & (1U << BIT_INDEX(frame)))\n```\n\n**Memory Layout (128KB for 4GB):**\n\n```\nAddress         Content\n----------      -------\nbitmap[0]       Frames 0-31    (physical 0x00000000 - 0x0001FFFF)\nbitmap[1]       Frames 32-63   (physical 0x00020000 - 0x0003FFFF)\n...\nbitmap[32767]   Frames 1048544-1048575 (physical 0xFFF80000 - 0xFFFFFFFF)\n\nFrame address calculation:\n  frame_index = physical_address / 4096\n  physical_address = frame_index * 4096\n```\n\n### Page Directory Entry (PDE)\n\nEach PDE points to a page table or represents a 4MB page. For 4KB pages:\n\n```c\n/* vmm.h */\n\ntypedef uint32_t page_directory_entry_t;\ntypedef uint32_t page_table_entry_t;\n\n// PDE/PTE flag bits (same layout for both on x86)\n#define PDE_PRESENT     (1U << 0)   // Page/table is present in memory\n#define PDE_WRITABLE    (1U << 1)   // Read/write (0=read-only, 1=read-write)\n#define PDE_USER        (1U << 2)   // User/supervisor (0=ring0 only, 1=ring3 OK)\n#define PDE_PWT         (1U << 3)   // Page-level write-through\n#define PDE_PCD         (1U << 4)   // Page-level cache disable\n#define PDE_ACCESSED    (1U << 5)   // Has been read (CPU sets)\n#define PDE_DIRTY       (1U << 6)   // Has been written (CPU sets, PTE only)\n#define PDE_PS          (1U << 7)   // Page size (0=4KB, 1=4MB for PDE)\n#define PDE_GLOBAL      (1U << 8)   // Global page (not flushed on CR3 load)\n#define PDE_AVAILABLE   (0x7U << 9) // Available for OS use (bits 9-11)\n#define PDE_FRAME       (0xFFFFF000U) // Frame address mask (bits 12-31)\n\n// Extract frame address from entry\n#define PDE_GET_FRAME(pde)  ((pde) & PDE_FRAME)\n\n// Create PDE from frame address and flags\n#define PDE_CREATE(frame, flags) (((frame) & PDE_FRAME) | ((flags) & 0xFFF) | PDE_PRESENT)\n```\n\n**PDE Memory Layout (4 bytes):**\n\n```\nBits    Field           Description\n----    -----           -----------\n0       Present         1 = valid entry\n1       Read/Write      1 = writable\n2       User/Supervisor 1 = user-accessible\n3       PWT             Write-through caching\n4       PCD             Cache disabled\n5       Accessed        CPU sets on read\n6       Reserved        0 for PDE (4KB pages)\n7       PS              0 for 4KB pages\n8       G               Global page\n9-11    Available       OS-defined\n12-31   Frame Address   Physical address of page table (4KB aligned)\n```\n\n### Page Table Entry (PTE)\n\nEach PTE maps one 4KB virtual page to a 4KB physical frame.\n\n```c\n// PTE uses same flag definitions as PDE, plus:\n// PDE_DIRTY (bit 6) indicates the page has been written\n\n// PTE structure is identical to PDE for 4KB pages\n// Both are uint32_t with bits 12-31 containing frame address\n```\n\n**Virtual Address Decomposition:**\n\n```\n32-bit virtual address:\n┌─────────────┬─────────────┬─────────────┐\n│ PD Index    │ PT Index    │ Page Offset │\n│ (10 bits)   │ (10 bits)   │ (12 bits)   │\n└─────────────┴─────────────┴─────────────┘\n  31        22 21         12 11          0\n\nPD Index:   bits 31-22 (1024 entries)\nPT Index:   bits 21-12 (1024 entries)\nPage Offset: bits 11-0  (4096 bytes per page)\n\nTranslation:\n  PDE = page_directory[pd_index]\n  PT  = (page_table_t*)PDE_GET_FRAME(PDE)\n  PTE = PT->entries[pt_index]\n  physical_addr = PDE_GET_FRAME(PTE) | page_offset\n```\n\n### Page Directory and Page Table Structures\n\n```c\n/* vmm.h */\n\ntypedef struct {\n    page_table_entry_t entries[1024];\n} __attribute__((aligned(4096))) page_table_t;\n\ntypedef struct {\n    page_directory_entry_t entries[1024];\n} __attribute__((aligned(4096))) page_directory_t;\n\n// Each structure is exactly 4096 bytes (1024 × 4 bytes)\n// Alignment ensures they fit in single pages\n```\n\n**Memory Layout (both 4KB):**\n\n```\nOffset    Entry Index\n------    -----------\n0x000     entry[0]\n0x004     entry[1]\n0x008     entry[2]\n...\n0xFFC     entry[1023]\n\nTotal: 0x1000 (4096) bytes\n```\n\n### Kernel Heap Block Header\n\nThe heap allocator maintains free blocks with headers containing metadata.\n\n```c\n/* kmalloc.h */\n\n#define KHEAP_VIRTUAL_START   0xD0000000   // Heap starts at 3.5GB virtual\n#define KHEAP_VIRTUAL_END     0xE0000000   // Heap ends at 3.5GB + 256MB\n#define KHEAP_INITIAL_SIZE    (64 * 1024)  // Start with 64KB\n\ntypedef struct block_header {\n    uint32_t magic;               // Magic number for corruption detection\n    uint32_t size;                // Size of usable space (not including header)\n    uint8_t  free;                // 1 = free, 0 = allocated\n    uint8_t  padding[3];          // Align to 4 bytes\n    struct block_header *next;    // Next block in list\n    struct block_header *prev;    // Previous block in list (for coalescing)\n} __attribute__((packed)) block_header_t;\n\n#define HEAP_MAGIC       0x4B484250  // \"KHPB\" - Kernel Heap Block\n#define HEADER_SIZE      sizeof(block_header_t)\n#define MIN_BLOCK_SIZE   16          // Minimum allocation size\n#define ALIGN_SIZE       16          // 16-byte alignment for all allocations\n\n// Block layout in memory:\n//   [header][usable space]\n//    ^      ^\n//    |      |\n//    |      +-- Pointer returned to caller\n//    +---------- Start of allocated frame(s)\n```\n\n**Memory Layout (24 bytes header):**\n\n```\nOffset  Size  Field\n------  ----  -----\n0       4     magic (0x4B484250)\n4       4     size (usable bytes)\n8       1     free flag\n9       3     padding\n12      4     next pointer\n16      4     prev pointer\n20      4     (padding to 24 bytes for alignment)\nTotal: 24 bytes\n\nAlignment:\n  Block start address % ALIGN_SIZE == 0\n  User pointer = block_start + HEADER_SIZE\n  User pointer % ALIGN_SIZE == 0\n```\n\n---\n\n## Interface Contracts\n\n### memory_map_init\n\n```c\n/* memory_map.h */\n\n// Parse memory map from multiboot info\n// Must be called before any memory allocation\n// mbi: pointer to multiboot_info_t from bootloader (passed in EBX)\nvoid memory_map_init(void *mbi);\n\n// Get total usable memory in bytes\nuint64_t memory_map_get_total_usable(void);\n\n// Print memory map for debugging\nvoid memory_map_print(void);\n```\n\n**Preconditions:**\n- Called before `pmm_init()`\n- `mbi` points to valid multiboot info structure\n- Interrupts disabled (safety)\n\n**Postconditions:**\n- `memory_regions[]` populated with all detected regions\n- `memory_region_count` set correctly\n- First 1MB marked as reserved (BIOS/VGA)\n\n**Error Handling:**\n| Condition | Detection | Recovery |\n|-----------|-----------|----------|\n| No mmap in multiboot | flags bit 6 clear | Panic with message |\n| Too many regions | count >= MAX | Truncate, log warning |\n| Invalid region | length == 0 | Skip entry |\n\n### pmm_init / pmm_alloc_frame / pmm_free_frame\n\n```c\n/* pmm.h */\n\n// Initialize physical frame allocator from memory map\n// Must be called after memory_map_init()\nvoid pmm_init(void);\n\n// Allocate a single 4KB frame\n// Returns physical address of frame, or 0 if out of memory\nuint32_t pmm_alloc_frame(void);\n\n// Free a previously allocated frame\n// addr: physical address returned by pmm_alloc_frame (must be 4KB aligned)\nvoid pmm_free_frame(uint32_t addr);\n\n// Mark a specific frame as used (for kernel, page tables, etc.)\n// addr: physical address (must be 4KB aligned)\nvoid pmm_mark_used(uint32_t addr);\n\n// Get statistics\nuint32_t pmm_get_total_frames(void);\nuint32_t pmm_get_used_frames(void);\nuint32_t pmm_get_free_frames(void);\n```\n\n**Preconditions:**\n- `memory_map_init()` called successfully\n- Bitmap fits in available memory\n\n**Postconditions:**\n- All usable frames available for allocation\n- Kernel binary, page tables, bitmap itself marked used\n\n**Edge Cases:**\n| Input | Behavior |\n|-------|----------|\n| `pmm_alloc_frame()` when full | Returns 0, logs warning |\n| `pmm_free_frame(0)` | Logs error, ignored |\n| `pmm_free_frame(unaligned)` | Logs error, ignored |\n| `pmm_free_frame(already free)` | Logs double-free warning, ignored |\n\n### vmm_init / vmm_map_page / vmm_unmap_page\n\n```c\n/* vmm.h */\n\n// Current page directory (set after vmm_init)\nextern page_directory_t *current_page_directory;\n\n// Initialize virtual memory manager\n// Allocates and clears initial page directory\nvoid vmm_init(void);\n\n// Map a virtual page to a physical frame\n// vaddr: virtual address (will be page-aligned)\n// paddr: physical address (will be page-aligned)\n// flags: PDE_WRITABLE, PDE_USER, etc.\n// Returns 0 on success, -1 on failure (out of memory for page table)\nint vmm_map_page(uint32_t vaddr, uint32_t paddr, uint32_t flags);\n\n// Unmap a virtual page\n// vaddr: virtual address to unmap\nvoid vmm_unmap_page(uint32_t vaddr);\n\n// Get physical address for a virtual address\n// Returns physical address, or 0 if not mapped\nuint32_t vmm_get_physical(uint32_t vaddr);\n\n// Check if virtual address is mapped\nint vmm_is_mapped(uint32_t vaddr);\n\n// Create a new page directory (for user processes)\n// Returns pointer to new directory, or NULL on failure\npage_directory_t *vmm_create_directory(void);\n\n// Switch to a different page directory\nvoid vmm_switch_directory(page_directory_t *pd);\n```\n\n**Preconditions:**\n- `pmm_init()` called successfully\n- Interrupts disabled during mapping (to prevent race with page faults)\n\n**Postconditions:**\n- Page tables created/updated as needed\n- TLB entry for page invalidated\n\n**Error Handling:**\n| Error | Detection | Recovery |\n|-------|-----------|----------|\n| No frame for page table | `pmm_alloc_frame()` returns 0 | Return -1 |\n| Invalid flags | Reserved bits set | Ignore reserved bits |\n| Already mapped | PTE present | Remap (update PTE) |\n\n### paging_setup_identity / paging_setup_higher_half / paging_enable\n\n```c\n/* paging.h */\n\n// Identity map the first 4MB (kernel + VGA + boot data)\n// Required for safe paging enable\nvoid paging_setup_identity(void);\n\n// Set up higher-half kernel mapping\n// Maps 0xC0000000-0xC0400000 to 0x00000000-0x00400000\nvoid paging_setup_higher_half(void);\n\n// Enable paging (set CR0.PG)\n// CRITICAL: Must have identity map active when called\n// After this, all addresses are virtual\nvoid paging_enable(void);\n\n// Complete paging initialization sequence\n// Calls identity, higher-half, then enables paging\nvoid paging_init(void);\n```\n\n**Preconditions:**\n- `vmm_init()` called\n- GDT configured with flat segments\n\n**Postconditions:**\n- Paging enabled\n- Identity map for first 4MB active\n- Higher-half map for kernel active\n- Kernel executing at virtual addresses\n\n**CRITICAL:** The transition must be handled carefully. The code that enables paging must be identity-mapped, or the CPU will fault on the next instruction fetch.\n\n### tlb_invalidate_page / tlb_flush_all\n\n```c\n/* tlb.h */\n\n// Invalidate TLB entry for a single page\n// addr: virtual address of page to invalidate\nstatic inline void tlb_invalidate_page(uint32_t addr) {\n    __asm__ volatile (\"invlpg (%0)\" : : \"r\"(addr) : \"memory\");\n}\n\n// Flush entire TLB (except global pages)\n// Reloads CR3 with current page directory\nstatic inline void tlb_flush_all(void) {\n    uint32_t cr3;\n    __asm__ volatile (\"mov %%cr3, %0\" : \"=r\"(cr3));\n    __asm__ volatile (\"mov %0, %%cr3\" : : \"r\"(cr3) : \"memory\");\n}\n\n// Flush entire TLB including global pages\n// Requires CR4.PGE toggle\nvoid tlb_flush_all_global(void);\n```\n\n**Preconditions:**\n- Paging enabled\n\n**Postconditions:**\n- Specified TLB entries invalidated\n- Subsequent accesses will re-walk page tables\n\n### page_fault_handler\n\n```c\n/* page_fault.h */\n\n// Register page fault handler (called from interrupt init)\nvoid page_fault_register_handler(void);\n\n// Page fault handler (called from interrupt.asm)\n// regs: saved register state from interrupt\nvoid page_fault_handler(registers_t *regs);\n\n// Read CR2 (faulting address)\nstatic inline uint32_t read_cr2(void) {\n    uint32_t addr;\n    __asm__ volatile (\"mov %%cr2, %0\" : \"=r\"(addr));\n    return addr;\n}\n```\n\n**Preconditions:**\n- IDT entry 14 configured\n- Handler registered\n\n**Postconditions:**\n- Diagnostic information printed\n- System halted (for now; demand paging in future)\n\n**Page Fault Error Code Decoding:**\n\n```c\n// Error code bits from page fault\n#define PF_ERROR_PRESENT  (1 << 0)  // 0 = not present, 1 = protection violation\n#define PF_ERROR_WRITE    (1 << 1)  // 0 = read, 1 = write\n#define PF_ERROR_USER     (1 << 2)  // 0 = kernel, 1 = user\n#define PF_ERROR_RESERVED (1 << 3)  // Reserved bit set in page table\n#define PF_ERROR_FETCH    (1 << 4)  // Instruction fetch (NX bit)\n```\n\n### kmalloc / kfree\n\n```c\n/* kmalloc.h */\n\n// Initialize kernel heap\n// Must be called after paging is enabled\nvoid kmalloc_init(void);\n\n// Allocate memory from kernel heap\n// size: bytes to allocate (will be aligned to ALIGN_SIZE)\n// Returns pointer to allocated memory, or NULL on failure\nvoid *kmalloc(size_t size);\n\n// Free previously allocated memory\n// ptr: pointer returned by kmalloc (or NULL, which is a no-op)\nvoid kfree(void *ptr);\n\n// Allocate and zero-initialize memory\nvoid *kcalloc(size_t num, size_t size);\n\n// Reallocate memory (change size of allocation)\nvoid *krealloc(void *ptr, size_t size);\n\n// Get heap statistics\nsize_t kmalloc_get_total_size(void);\nsize_t kmalloc_get_used_size(void);\nsize_t kmalloc_get_free_size(void);\n```\n\n**Preconditions:**\n- Paging enabled\n- Heap virtual range mapped\n\n**Postconditions:**\n- Memory allocated with 16-byte alignment\n- Adjacent free blocks coalesced\n\n**Edge Cases:**\n| Input | Behavior |\n|-------|----------|\n| `kmalloc(0)` | Returns NULL |\n| `kmalloc(very_large)` | Returns NULL if can't grow heap |\n| `kfree(NULL)` | No-op |\n| `kfree(bad_pointer)` | Magic check fails, log error, ignore |\n\n---\n\n## Algorithm Specification\n\n### Algorithm: Memory Map Parsing (Multiboot)\n\n**Purpose:** Extract memory regions from multiboot info structure.\n\n**Inputs:** \n- Multiboot info pointer (from bootloader)\n- Multiboot magic (from bootloader, in EAX)\n\n**Outputs:** \n- `memory_regions[]` populated\n- `memory_region_count` set\n\n**Procedure:**\n1. Verify multiboot magic (0x2BADB002)\n2. Check if mmap field is valid (flags bit 6)\n3. Iterate through mmap entries:\n   - Read base, length, type from entry\n   - Store in `memory_regions[count]`\n   - Advance to next entry (entry_size varies)\n4. Sort regions by base address (optional, for debugging)\n5. Merge adjacent regions of same type (optional)\n\n**Invariants:**\n- No overlapping regions\n- All regions aligned to at least page boundaries (for our use)\n\n```c\nvoid memory_map_init(void *mbi_ptr) {\n    multiboot_info_t *mbi = (multiboot_info_t *)mbi_ptr;\n    \n    if (!(mbi->flags & (1 << 6))) {\n        panic(\"No memory map from bootloader!\");\n    }\n    \n    uint32_t mmap_addr = mbi->mmap_addr;\n    uint32_t mmap_end = mmap_addr + mbi->mmap_length;\n    \n    memory_region_count = 0;\n    \n    while (mmap_addr < mmap_end && memory_region_count < MAX_MEMORY_REGIONS) {\n        multiboot_mmap_entry_t *entry = (multiboot_mmap_entry_t *)mmap_addr;\n        \n        memory_regions[memory_region_count].base = entry->base_addr;\n        memory_regions[memory_region_count].length = entry->length;\n        memory_regions[memory_region_count].type = (memory_type_t)entry->type;\n        \n        memory_region_count++;\n        mmap_addr += entry->size + 4;  // size field doesn't include itself\n    }\n    \n    // Mark first 1MB as reserved (even if reported as usable)\n    // (BIOS data structures, VGA memory, etc.)\n}\n```\n\n### Algorithm: Physical Frame Allocation (Bitmap Scan)\n\n**Purpose:** Find and allocate a free physical frame.\n\n**Inputs:** None\n**Outputs:** Physical address of allocated frame, or 0 if none available\n\n**Procedure:**\n1. For each word in bitmap:\n   - If word != 0xFFFFFFFF (not all used):\n     - Find first zero bit using `bsf` (Bit Scan Forward)\n     - Set the bit\n     - Calculate frame address\n     - Return address\n2. If no free bits found, return 0\n\n**Optimization with BSF:**\n\n```c\nuint32_t pmm_alloc_frame(void) {\n    for (uint32_t word_idx = 0; word_idx < BITMAP_WORDS; word_idx++) {\n        if (frame_bitmap[word_idx] != 0xFFFFFFFF) {\n            // Find first zero bit\n            uint32_t word = frame_bitmap[word_idx];\n            uint32_t bit_idx;\n            \n            // bsf finds index of least significant 1 bit\n            // We want first 0 bit, so invert\n            __asm__ volatile (\"bsf %1, %0\" : \"=r\"(bit_idx) : \"r\"(~word));\n            \n            uint32_t frame = (word_idx << 5) | bit_idx;\n            \n            // Verify frame is within valid range\n            if (frame >= total_frames) {\n                continue;\n            }\n            \n            SET_BIT(frame);\n            used_frames++;\n            \n            return frame << FRAME_SHIFT;  // Convert to physical address\n        }\n    }\n    \n    kprintf(\"PMM: Out of memory!\\n\");\n    return 0;\n}\n```\n\n**Invariants:**\n- Each frame allocated exactly once\n- No frame returned twice before being freed\n\n### Algorithm: Physical Frame Free\n\n**Purpose:** Mark a frame as available for reuse.\n\n**Inputs:** Physical address of frame to free\n**Outputs:** None (bitmap updated)\n\n**Procedure:**\n1. Check address is 4KB aligned\n2. Calculate frame index\n3. Verify frame is currently allocated (TEST_BIT)\n4. Clear the bit\n5. Decrement used count\n\n**Error Detection:**\n\n```c\nvoid pmm_free_frame(uint32_t addr) {\n    if (addr == 0) {\n        kprintf(\"PMM: Attempt to free NULL frame\\n\");\n        return;\n    }\n    \n    if (addr & 0xFFF) {\n        kprintf(\"PMM: Unaligned free: 0x%x\\n\", addr);\n        return;\n    }\n    \n    uint32_t frame = FRAME_INDEX(addr);\n    \n    if (frame >= total_frames) {\n        kprintf(\"PMM: Frame out of range: 0x%x\\n\", addr);\n        return;\n    }\n    \n    if (!TEST_BIT(frame)) {\n        kprintf(\"PMM: Double free detected: 0x%x\\n\", addr);\n        return;\n    }\n    \n    CLEAR_BIT(frame);\n    used_frames--;\n}\n```\n\n### Algorithm: Virtual Address Translation\n\n**Purpose:** Map a virtual page to a physical frame.\n\n**Inputs:**\n- Virtual address (will be page-aligned)\n- Physical address (will be page-aligned)\n- Flags (writable, user, etc.)\n\n**Outputs:** Page table entry created/updated\n\n**Procedure:**\n1. Extract PD index and PT index from virtual address\n2. Check if page table exists for this PD entry:\n   - If not present, allocate frame for new page table\n   - Clear the page table (all zeros = not present)\n   - Set PD entry with page table physical address\n3. Set PT entry with frame address and flags\n4. Invalidate TLB entry for this page\n\n```c\nint vmm_map_page(uint32_t vaddr, uint32_t paddr, uint32_t flags) {\n    // Align addresses\n    vaddr &= ~0xFFF;\n    paddr &= ~0xFFF;\n    \n    uint32_t pd_idx = (vaddr >> 22) & 0x3FF;\n    uint32_t pt_idx = (vaddr >> 12) & 0x3FF;\n    \n    page_directory_entry_t *pde = &current_page_directory->entries[pd_idx];\n    \n    // Check if page table exists\n    if (!(*pde & PDE_PRESENT)) {\n        // Allocate new page table\n        uint32_t pt_frame = pmm_alloc_frame();\n        if (pt_frame == 0) {\n            return -1;  // Out of memory\n        }\n        \n        // Clear page table\n        page_table_t *pt = (page_table_t *)pt_frame;\n        for (int i = 0; i < 1024; i++) {\n            pt->entries[i] = 0;\n        }\n        \n        // Set PDE to point to page table\n        *pde = PDE_CREATE(pt_frame, flags & (PDE_WRITABLE | PDE_USER));\n    }\n    \n    // Get page table\n    page_table_t *pt = (page_table_t *)PDE_GET_FRAME(*pde);\n    \n    // Set PTE\n    pt->entries[pt_idx] = PDE_CREATE(paddr, flags);\n    \n    // Invalidate TLB\n    tlb_invalidate_page(vaddr);\n    \n    return 0;\n}\n```\n\n### Algorithm: Identity Mapping Setup\n\n**Purpose:** Map virtual addresses 0x0-0x400000 to physical addresses 0x0-0x400000.\n\n**Inputs:** None\n**Outputs:** First 4MB identity-mapped\n\n**Procedure:**\n1. For each 4KB page from 0 to 4MB:\n   - Call `vmm_map_page(vaddr, paddr, PDE_WRITABLE)`\n   - Where vaddr = paddr = loop variable\n\n```c\nvoid paging_setup_identity(void) {\n    for (uint32_t addr = 0; addr < 0x400000; addr += PAGE_SIZE) {\n        // Map with writable, kernel-only access\n        vmm_map_page(addr, addr, PDE_WRITABLE);\n    }\n    \n    // Special handling for VGA (0xB8000) - already covered by above\n    // But could add different flags if needed:\n    // vmm_map_page(0xB8000, 0xB8000, PDE_WRITABLE | PDE_PCD);\n}\n```\n\n### Algorithm: Higher-Half Kernel Mapping\n\n**Purpose:** Map 0xC0000000+ to physical 0x0+.\n\n**Inputs:** None\n**Outputs:** Kernel accessible at higher-half virtual addresses\n\n**Procedure:**\n1. For each 4KB page from 0 to 4MB:\n   - vaddr = 0xC0000000 + addr\n   - paddr = addr\n   - Call `vmm_map_page(vaddr, paddr, PDE_WRITABLE)`\n\n```c\nvoid paging_setup_higher_half(void) {\n    for (uint32_t offset = 0; offset < 0x400000; offset += PAGE_SIZE) {\n        uint32_t vaddr = KERNEL_VIRTUAL_START + offset;\n        uint32_t paddr = offset;\n        \n        vmm_map_page(vaddr, paddr, PDE_WRITABLE);\n    }\n}\n```\n\n### Algorithm: Paging Enable Transition\n\n**Purpose:** Enable paging while maintaining execution continuity.\n\n**Inputs:** None (uses global page directory)\n**Outputs:** Paging enabled, executing at virtual addresses\n\n**CRITICAL:** This is the most delicate operation. The code that sets CR0.PG must be identity-mapped, or the CPU faults immediately.\n\n**Procedure:**\n1. Ensure identity mapping is active\n2. Load CR3 with page directory physical address\n3. Set CR0.PG bit\n4. Far jump to higher-half code (optional, for higher-half kernel)\n\n```c\nvoid paging_enable(void) {\n    uint32_t pd_phys = (uint32_t)current_page_directory;\n    \n    // CRITICAL: We must be executing from identity-mapped code here\n    \n    // Load page directory base\n    __asm__ volatile (\"mov %0, %%cr3\" : : \"r\"(pd_phys));\n    \n    // Enable paging\n    uint32_t cr0;\n    __asm__ volatile (\"mov %%cr0, %0\" : \"=r\"(cr0));\n    cr0 |= (1 << 31);  // Set PG bit\n    __asm__ volatile (\"mov %0, %%cr0\" : : \"r\"(cr0));\n    \n    // Now paging is enabled!\n    // All addresses are virtual\n}\n```\n\n**Assembly Transition (for higher-half):**\n\n```asm\n; paging_transition.asm\nglobal paging_enable_and_jump\nextern kernel_main_higher_half\n\npaging_enable_and_jump:\n    ; Load CR3\n    mov eax, [page_directory_phys]\n    mov cr3, eax\n    \n    ; Enable paging\n    mov eax, cr0\n    or eax, (1 << 31)\n    mov cr0, eax\n    \n    ; Now paging is enabled\n    ; We're still at identity-mapped address\n    ; Jump to higher-half\n    \n    mov eax, kernel_main_higher_half\n    jmp eax\n    \n    ; Never returns\n```\n\n### Algorithm: Page Fault Handling\n\n**Purpose:** Capture and diagnose page faults.\n\n**Inputs:** \n- CR2 (faulting address)\n- Error code (from stack)\n\n**Outputs:** Diagnostic information printed\n\n**Procedure:**\n1. Read CR2 to get faulting address\n2. Decode error code bits\n3. Print diagnostic information\n4. Halt system (for now)\n\n```c\nvoid page_fault_handler(registers_t *regs) {\n    uint32_t fault_addr = read_cr2();\n    uint32_t err = regs->err_code;\n    \n    kprintf(\"\\n========== PAGE FAULT ==========\\n\");\n    kprintf(\"Faulting address: 0x%08x\\n\", fault_addr);\n    kprintf(\"Error code: 0x%x\\n\", err);\n    \n    kprintf(\"Cause: \");\n    if (!(err & PF_ERROR_PRESENT)) {\n        kprintf(\"Page not present\\n\");\n    } else if (err & PF_ERROR_WRITE) {\n        kprintf(\"Write to read-only page\\n\");\n    } else if (err & PF_ERROR_USER) {\n        kprintf(\"User access to kernel page\\n\");\n    } else {\n        kprintf(\"Unknown\\n\");\n    }\n    \n    kprintf(\"Access type: %s\\n\", (err & PF_ERROR_WRITE) ? \"Write\" : \"Read\");\n    kprintf(\"Mode: %s\\n\", (err & PF_ERROR_USER) ? \"User\" : \"Kernel\");\n    kprintf(\"EIP at fault: 0x%08x\\n\", regs->eip);\n    \n    // Dump current page table state for debugging\n    if (vmm_is_mapped(fault_addr)) {\n        kprintf(\"Mapped to: 0x%08x\\n\", vmm_get_physical(fault_addr));\n    }\n    \n    panic(\"Page fault\");\n}\n```\n\n### Algorithm: Kernel Heap Allocation (First-Fit)\n\n**Purpose:** Allocate memory from kernel heap.\n\n**Inputs:** Size in bytes\n**Outputs:** Pointer to allocated memory, or NULL\n\n**Procedure:**\n1. Align size to ALIGN_SIZE (16 bytes)\n2. Calculate total size needed (size + HEADER_SIZE)\n3. Walk free list looking for first block >= total size\n4. If found:\n   - If block is much larger, split into two blocks\n   - Mark block as allocated\n   - Return pointer to usable space\n5. If not found:\n   - Grow heap by mapping new pages\n   - Create new block\n   - Return pointer\n\n```c\nvoid *kmalloc(size_t size) {\n    if (size == 0) return NULL;\n    \n    // Align size\n    size = (size + ALIGN_SIZE - 1) & ~(ALIGN_SIZE - 1);\n    if (size < MIN_BLOCK_SIZE) size = MIN_BLOCK_SIZE;\n    \n    uint32_t total_needed = size + HEADER_SIZE;\n    \n    // Search free list (first-fit)\n    block_header_t *block = heap_head;\n    while (block != NULL) {\n        if (block->free && block->size >= size) {\n            // Found a suitable block\n            \n            // Split if large enough\n            if (block->size >= size + HEADER_SIZE + MIN_BLOCK_SIZE) {\n                block_header_t *new_block = (block_header_t *)\n                    ((uint32_t)block + HEADER_SIZE + size);\n                \n                new_block->magic = HEAP_MAGIC;\n                new_block->size = block->size - size - HEADER_SIZE;\n                new_block->free = 1;\n                new_block->next = block->next;\n                new_block->prev = block;\n                \n                if (block->next) {\n                    block->next->prev = new_block;\n                }\n                \n                block->size = size;\n                block->next = new_block;\n            }\n            \n            block->free = 0;\n            return (void *)((uint32_t)block + HEADER_SIZE);\n        }\n        \n        block = block->next;\n    }\n    \n    // No suitable block, grow heap\n    return heap_grow(total_needed);\n}\n```\n\n### Algorithm: Kernel Heap Free with Coalescing\n\n**Purpose:** Free memory and merge adjacent free blocks.\n\n**Inputs:** Pointer to allocated memory\n**Outputs:** None (block marked free, coalesced)\n\n**Procedure:**\n1. Get header from pointer\n2. Verify magic number\n3. Mark block as free\n4. Coalesce with next block if free\n5. Coalesce with previous block if free\n\n```c\nvoid kfree(void *ptr) {\n    if (ptr == NULL) return;\n    \n    block_header_t *block = (block_header_t *)((uint32_t)ptr - HEADER_SIZE);\n    \n    // Verify magic\n    if (block->magic != HEAP_MAGIC) {\n        kprintf(\"kmalloc: Bad magic in kfree: 0x%x\\n\", block->magic);\n        return;\n    }\n    \n    // Already free?\n    if (block->free) {\n        kprintf(\"kmalloc: Double free detected\\n\");\n        return;\n    }\n    \n    block->free = 1;\n    \n    // Coalesce with next block\n    if (block->next && block->next->free && block->next->magic == HEAP_MAGIC) {\n        block->size += block->next->size + HEADER_SIZE;\n        block->next = block->next->next;\n        if (block->next) {\n            block->next->prev = block;\n        }\n    }\n    \n    // Coalesce with previous block\n    if (block->prev && block->prev->free && block->prev->magic == HEAP_MAGIC) {\n        block->prev->size += block->size + HEADER_SIZE;\n        block->prev->next = block->next;\n        if (block->next) {\n            block->next->prev = block->prev;\n        }\n    }\n}\n```\n\n---\n\n## Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n|-------|-------------|----------|---------------|\n| No memory map from bootloader | Multiboot flags check | Panic with message | Yes, halt |\n| Frame allocation failure | `pmm_alloc_frame()` returns 0 | Return NULL to caller | Caller handles |\n| Double frame free | `TEST_BIT()` check | Log warning, ignore | Debug log |\n| Unaligned frame free | Address check | Log warning, ignore | Debug log |\n| Page table allocation failure | `pmm_alloc_frame()` returns 0 | Return -1 from `vmm_map_page()` | Caller handles |\n| Page fault on paging enable | Immediate triple fault | None (system resets) | Yes, reboot |\n| TLB staleness | Stale data access | Fix by `invlpg` after map | Debug symptoms |\n| Heap corruption | Magic number check | Log error, ignore free | Debug log |\n| Heap exhausted | No suitable block found | Return NULL from `kmalloc()` | Caller handles |\n| Invalid kfree pointer | Magic check | Log error, ignore | Debug log |\n\n---\n\n## Concurrency Specification\n\n### Interrupt Safety\n\n| Data Structure | Access Pattern | Protection |\n|----------------|----------------|------------|\n| Frame bitmap | Read/write from kernel | Disable IRQs during alloc/free |\n| Page tables | Read/write from kernel | Disable IRQs during map/unmap |\n| Heap free list | Read/write from kernel | Disable IRQs during malloc/free |\n| Memory regions | Read-only after init | No protection needed |\n\n**Critical Sections:**\n\n```c\n// Frame allocation with interrupt safety\nuint32_t pmm_alloc_frame_safe(void) {\n    uint32_t flags;\n    __asm__ volatile (\"pushf; pop %0; cli\" : \"=r\"(flags));\n    \n    uint32_t frame = pmm_alloc_frame();\n    \n    if (!(flags & 0x200)) {\n        __asm__ volatile (\"sti\");\n    }\n    \n    return frame;\n}\n```\n\n### Future Preemptive Kernel Considerations\n\nWhen the kernel becomes preemptive (Milestone 4), all memory operations must use spinlocks:\n\n```c\n// Future: spinlock for frame allocator\nstatic spinlock_t pmm_lock = SPINLOCK_INIT;\n\nuint32_t pmm_alloc_frame(void) {\n    spinlock_acquire(&pmm_lock);\n    // ... allocation code ...\n    spinlock_release(&pmm_lock);\n    return frame;\n}\n```\n\n---\n\n## State Machine: Heap Block Lifecycle\n\n```\n                 +-----------------+\n                 |    ALLOCATED    |\n                 +--------+--------+\n                          |\n                     kfree(ptr)\n                          |\n                          v\n                 +-----------------+\n                 |      FREE       |\n                 +--------+--------+\n                          |\n         +----------------+----------------+\n         |                                 |\n   Coalesce with next              Coalesce with prev\n         |                                 |\n         v                                 v\n+----------------+                 +----------------+\n| MERGED (larger)|                 | MERGED (larger)|\n|    FREE block  |                 |    FREE block  |\n+--------+-------+                 +--------+-------+\n         |                                  |\n         +------------------+---------------+\n                            |\n                      kmalloc(size)\n                            |\n                            v\n                 +-----------------+\n                 |   ALLOCATED     |\n                 |  (possibly      |\n                 |   split)        |\n                 +-----------------+\n\nBlock states:\n  - ALLOCATED: magic valid, free=0\n  - FREE: magic valid, free=1\n  - CORRUPT: magic invalid (error state)\n```\n\n---\n\n## Implementation Sequence with Checkpoints\n\n### Phase 1: Memory Map Parsing (2-3 hours)\n\n**Files:** mm/memory_map.h, mm/memory_map.c\n\n**Steps:**\n1. Define `memory_region_t` structure\n2. Implement `memory_map_init()` to parse multiboot mmap\n3. Implement `memory_map_print()` for debugging\n4. Test with QEMU memory configuration\n\n**Checkpoint:** Memory regions printed correctly.\n\n**Test:**\n```c\nmemory_map_init(mbi);\nmemory_map_print();\n// Should show usable regions, reserved regions\n```\n\n---\n\n### Phase 2: Physical Frame Allocator (4-5 hours)\n\n**Files:** mm/pmm.h, mm/pmm.c\n\n**Steps:**\n1. Define bitmap array and constants\n2. Implement `pmm_init()` to mark usable/used frames\n3. Implement `pmm_alloc_frame()` with BSF optimization\n4. Implement `pmm_free_frame()` with double-free detection\n5. Implement statistics functions\n\n**Checkpoint:** Allocate and free frames successfully.\n\n**Test:**\n```c\npmm_init();\nuint32_t f1 = pmm_alloc_frame();\nuint32_t f2 = pmm_alloc_frame();\nkprintf(\"Allocated frames: 0x%x, 0x%x\\n\", f1, f2);\npmm_free_frame(f1);\nuint32_t f3 = pmm_alloc_frame();\nkprintf(\"After free, allocated: 0x%x\\n\", f3);  // Should be f1\n```\n\n---\n\n### Phase 3: Page Directory and Page Table Structures (3-4 hours)\n\n**Files:** mm/vmm.h, mm/vmm.c (partial)\n\n**Steps:**\n1. Define PDE/PTE flag constants\n2. Define `page_table_t` and `page_directory_t` structures\n3. Implement `vmm_init()` to allocate initial page directory\n4. Implement helper macros for address extraction\n\n**Checkpoint:** Page directory allocated and cleared.\n\n**Test:**\n```c\nvmm_init();\nkprintf(\"Page directory at: 0x%x\\n\", current_page_directory);\n// Check that all entries are 0\n```\n\n---\n\n### Phase 4: Virtual Memory Mapping Functions (3-4 hours)\n\n**Files:** mm/vmm.c (continued)\n\n**Steps:**\n1. Implement `vmm_map_page()` with page table allocation\n2. Implement `vmm_unmap_page()`\n3. Implement `vmm_get_physical()`\n4. Implement `vmm_is_mapped()`\n\n**Checkpoint:** Map and unmap pages, verify translation.\n\n**Test:**\n```c\nuint32_t frame = pmm_alloc_frame();\nvmm_map_page(0xC0000000, frame, PDE_WRITABLE);\nuint32_t phys = vmm_get_physical(0xC0000000);\nkprintf(\"Mapped 0xC0000000 -> 0x%x\\n\", phys);\nassert(phys == frame);\n```\n\n---\n\n### Phase 5: Identity Mapping Setup (2-3 hours)\n\n**Files:** mm/paging.h, mm/paging.c\n\n**Steps:**\n1. Implement `paging_setup_identity()`\n2. Mark VGA region appropriately\n3. Verify all entries present\n\n**Checkpoint:** First 4MB identity-mapped.\n\n**Test:**\n```c\npaging_setup_identity();\nfor (uint32_t addr = 0; addr < 0x400000; addr += PAGE_SIZE) {\n    assert(vmm_is_mapped(addr));\n    assert(vmm_get_physical(addr) == addr);\n}\n```\n\n---\n\n### Phase 6: Higher-Half Kernel Mapping (3-4 hours)\n\n**Files:** mm/paging.c (continued), linker.ld (update)\n\n**Steps:**\n1. Update linker script for higher-half addresses\n2. Implement `paging_setup_higher_half()`\n3. Verify mapping without enabling paging yet\n\n**Checkpoint:** Higher-half entries present in page directory.\n\n**Test:**\n```c\npaging_setup_higher_half();\nfor (uint32_t offset = 0; offset < 0x400000; offset += PAGE_SIZE) {\n    uint32_t vaddr = 0xC0000000 + offset;\n    assert(vmm_is_mapped(vaddr));\n    assert(vmm_get_physical(vaddr) == offset);\n}\n```\n\n---\n\n### Phase 7: Paging Enable and Transition (3-4 hours)\n\n**Files:** mm/paging.c (continued), boot/paging_transition.asm (new)\n\n**Steps:**\n1. Implement `paging_enable()` with CR0.PG set\n2. Write assembly transition code\n3. Handle the identity-to-higher-half jump\n4. Test carefully in QEMU with GDB\n\n**Checkpoint:** Paging enabled, kernel runs at higher-half address.\n\n**Test:**\n```c\npaging_init();  // identity + higher-half + enable\nkprintf(\"Paging enabled! Running at 0x%x\\n\", &&here);\nhere:\n// If we get here, paging works\n```\n\n---\n\n### Phase 8: TLB Management (2-3 hours)\n\n**Files:** mm/tlb.h, mm/tlb.c\n\n**Steps:**\n1. Implement `tlb_invalidate_page()` with `invlpg`\n2. Implement `tlb_flush_all()` with CR3 reload\n3. Implement `tlb_flush_all_global()` with CR4.PGE toggle\n4. Integrate with `vmm_map_page()`\n\n**Checkpoint:** TLB invalidation working.\n\n**Test:**\n```c\n// Map a page\nvmm_map_page(0xD0000000, pmm_alloc_frame(), PDE_WRITABLE);\n// Write to it\n*(volatile uint32_t *)0xD0000000 = 0xDEADBEEF;\n// Unmap\nvmm_unmap_page(0xD0000000);\n// TLB should be invalidated, access should fault\n// *(volatile uint32_t *)0xD0000000 = 0;  // Should page fault\n```\n\n---\n\n### Phase 9: Page Fault Handler (2-3 hours)\n\n**Files:** mm/page_fault.h, mm/page_fault.c\n\n**Steps:**\n1. Implement `read_cr2()` helper\n2. Implement `page_fault_handler()` with diagnostics\n3. Register handler in IDT (update interrupt.c)\n4. Test with intentional faults\n\n**Checkpoint:** Page faults produce diagnostic output.\n\n**Test:**\n```c\n// Trigger page fault\n*(volatile uint32_t *)0xDEADBEEF = 42;\n// Should see page fault handler output\n```\n\n---\n\n### Phase 10: Kernel Heap Allocator (4-6 hours)\n\n**Files:** mm/kmalloc.h, mm/kmalloc.c\n\n**Steps:**\n1. Define heap constants and block header\n2. Implement `kmalloc_init()` with initial heap mapping\n3. Implement `kmalloc()` with first-fit and splitting\n4. Implement `kfree()` with coalescing\n5. Implement `kcalloc()` and `krealloc()`\n6. Test thoroughly\n\n**Checkpoint:** Dynamic memory allocation working.\n\n**Test:**\n```c\nkmalloc_init();\n\nvoid *p1 = kmalloc(100);\nvoid *p2 = kmalloc(200);\nvoid *p3 = kmalloc(50);\n\nkprintf(\"Allocated: 0x%x, 0x%x, 0x%x\\n\", p1, p2, p3);\n\nkfree(p2);\nvoid *p4 = kmalloc(150);  // Should reuse p2's space\n\nkprintf(\"After free, allocated: 0x%x\\n\", p4);\n```\n\n---\n\n## Test Specification\n\n### Test: Memory Map Parsing\n\n**Setup:** Boot with multiboot, pass mbi to kernel\n\n**Steps:**\n1. Call `memory_map_init(mbi)`\n2. Verify region count > 0\n3. Verify at least one usable region exists\n\n**Expected:** Regions printed, usable memory detected\n\n```c\nassert(memory_region_count > 0);\nint has_usable = 0;\nfor (int i = 0; i < memory_region_count; i++) {\n    if (memory_regions[i].type == MEMORY_TYPE_USABLE) {\n        has_usable = 1;\n        break;\n    }\n}\nassert(has_usable);\n```\n\n---\n\n### Test: Frame Allocation\n\n**Setup:** PMM initialized\n\n**Steps:**\n1. Allocate 10 frames\n2. Verify all addresses are 4KB aligned\n3. Verify no duplicates\n4. Free all frames\n5. Verify frames can be re-allocated\n\n**Expected:** Clean allocation/deallocation\n\n```c\nuint32_t frames[10];\nfor (int i = 0; i < 10; i++) {\n    frames[i] = pmm_alloc_frame();\n    assert(frames[i] != 0);\n    assert((frames[i] & 0xFFF) == 0);  // 4KB aligned\n}\n// Check no duplicates\nfor (int i = 0; i < 10; i++) {\n    for (int j = i + 1; j < 10; j++) {\n        assert(frames[i] != frames[j]);\n    }\n}\n```\n\n---\n\n### Test: Double-Free Detection\n\n**Setup:** PMM initialized\n\n**Steps:**\n1. Allocate a frame\n2. Free it\n3. Try to free it again\n\n**Expected:** Warning logged, no crash\n\n```c\nuint32_t frame = pmm_alloc_frame();\npmm_free_frame(frame);\n// Should log warning but not crash\npmm_free_frame(frame);\n```\n\n---\n\n### Test: Page Mapping\n\n**Setup:** VMM initialized\n\n**Steps:**\n1. Allocate a physical frame\n2. Map it to a virtual address\n3. Verify translation\n4. Write to virtual address\n5. Read back\n\n**Expected:** Correct translation, data written/read\n\n```c\nuint32_t frame = pmm_alloc_frame();\nuint32_t vaddr = 0xC0100000;\n\nvmm_map_page(vaddr, frame, PDE_WRITABLE);\n\nassert(vmm_is_mapped(vaddr));\nassert(vmm_get_physical(vaddr) == frame);\n\n*(volatile uint32_t *)vaddr = 0x12345678;\nassert(*(volatile uint32_t *)vaddr == 0x12345678);\n```\n\n---\n\n### Test: Paging Enable\n\n**Setup:** Identity and higher-half mapping set up\n\n**Steps:**\n1. Enable paging\n2. Verify kernel still executing\n3. Access higher-half address\n\n**Expected:** No triple fault, kernel continues\n\n```c\npaging_init();\n// If we get here, paging is enabled\nkprintf(\"Paging enabled successfully!\\n\");\n```\n\n---\n\n### Test: TLB Invalidation\n\n**Setup:** Paging enabled\n\n**Steps:**\n1. Map a page\n2. Write to it\n3. Unmap it\n4. Verify TLB invalidated (access should fault)\n\n**Expected:** Page fault on access after unmap\n\n```c\nuint32_t vaddr = 0xD0001000;\nvmm_map_page(vaddr, pmm_alloc_frame(), PDE_WRITABLE);\n*(volatile uint32_t *)vaddr = 42;\nvmm_unmap_page(vaddr);\n// Should page fault:\n// *(volatile uint32_t *)vaddr = 0;\n```\n\n---\n\n### Test: Page Fault Handler\n\n**Setup:** Page fault handler registered\n\n**Steps:**\n1. Access unmapped address\n2. Verify handler called\n3. Verify CR2 and error code printed\n\n**Expected:** Diagnostic output with faulting address\n\n```c\n// This should trigger page fault handler\n*(volatile uint32_t *)0xDEADBEEF = 42;\n// Handler should print:\n// \"PAGE FAULT at 0xDEADBEEF, cause: not present\"\n```\n\n---\n\n### Test: kmalloc Basic\n\n**Setup:** Heap initialized\n\n**Steps:**\n1. Allocate various sizes\n2. Verify alignment\n3. Write to allocated memory\n4. Free and reallocate\n\n**Expected:** All allocations succeed, data intact\n\n```c\nvoid *p1 = kmalloc(16);\nvoid *p2 = kmalloc(100);\nvoid *p3 = kmalloc(1024);\n\nassert(p1 != NULL);\nassert(p2 != NULL);\nassert(p3 != NULL);\nassert(((uint32_t)p1 & 0xF) == 0);  // 16-byte aligned\n\nmemset(p1, 'A', 16);\nmemset(p2, 'B', 100);\nmemset(p3, 'C', 1024);\n\nkfree(p2);\nvoid *p4 = kmalloc(50);  // Should reuse p2's space\nassert(p4 != NULL);\n```\n\n---\n\n### Test: Heap Coalescing\n\n**Setup:** Heap initialized\n\n**Steps:**\n1. Allocate three blocks\n2. Free middle block\n3. Free first block\n4. Verify coalescing (allocate larger block)\n\n**Expected:** Blocks merged, larger allocation succeeds\n\n```c\nvoid *p1 = kmalloc(100);\nvoid *p2 = kmalloc(100);\nvoid *p3 = kmalloc(100);\n\nkfree(p1);\nkfree(p2);  // Should coalesce with p1\n\nvoid *p4 = kmalloc(180);  // Should fit in coalesced space\nassert(p4 != NULL);\n```\n\n---\n\n## Performance Targets\n\n| Operation | Target | How to Measure |\n|-----------|--------|----------------|\n| Frame allocation | < 1 µs | Cycle counter around `pmm_alloc_frame()` |\n| Frame free | < 0.5 µs | Cycle counter around `pmm_free_frame()` |\n| Page mapping | < 2 µs | Cycle counter around `vmm_map_page()` |\n| Page unmapping | < 1 µs | Cycle counter around `vmm_unmap_page()` |\n| TLB invalidate (single) | < 50 cycles | `invlpg` instruction timing |\n| TLB flush (full) | < 500 cycles | CR3 reload timing |\n| kmalloc (small, < 64B) | < 5 µs | Cycle counter around `kmalloc()` |\n| kmalloc (large, > 1KB) | < 20 µs | Cycle counter around `kmalloc()` |\n| kfree | < 3 µs | Cycle counter around `kfree()` |\n| Page fault handler | < 50 µs | Time from fault to diagnostic output |\n\n**Measurement Code:**\n\n```c\nstatic inline uint64_t rdtsc(void) {\n    uint32_t lo, hi;\n    __asm__ volatile (\"rdtsc\" : \"=a\"(lo), \"=d\"(hi));\n    return ((uint64_t)hi << 32) | lo;\n}\n\nvoid benchmark_pmm(void) {\n    uint64_t start = rdtsc();\n    uint32_t frame = pmm_alloc_frame();\n    uint64_t end = rdtsc();\n    kprintf(\"Frame alloc: %d cycles\\n\", (int)(end - start));\n}\n```\n\n---\n\n## Hardware Soul\n\n### Cache Behavior\n\n| Structure | Size | Cache Lines | Access Pattern |\n|-----------|------|-------------|----------------|\n| Page directory | 4KB | 64 | Sequential on walk, random on lookup |\n| Page table | 4KB | 64 | Sequential on walk, random on lookup |\n| Frame bitmap | 128KB | 2048 | Linear scan (predictable) |\n| Heap headers | ~24B each | 1 per 2 blocks | Random (allocation dependent) |\n\n**Cache Optimization Notes:**\n- Frame bitmap scan is prefetch-friendly (sequential reads)\n- Page table walks benefit from having PD/PT in cache\n- Heap fragmentation leads to cache misses on header traversal\n\n### Branch Prediction\n\n| Code Path | Predictability | Why |\n|-----------|----------------|-----|\n| Bitmap scan | High | Linear scan, bit check usually fails |\n| Page table lookup | Medium | Depends on access pattern |\n| Heap first-fit | Low | Depends on allocation history |\n| Coalescing | Low | Depends on free pattern |\n\n### TLB Behavior\n\n**CRITICAL:** Every TLB miss costs 2 memory accesses (PD read + PT read).\n\n| Working Set Size | TLB Entries Needed | Performance Impact |\n|------------------|-------------------|-------------------|\n| < 128 KB | < 32 | Minimal (fits in L1 TLB) |\n| 128 KB - 4 MB | 32 - 1024 | Moderate (L2 TLB helps) |\n| > 4 MB | > 1024 | Significant (frequent TLB misses) |\n\n**Optimization Strategies:**\n- Use 4MB pages for kernel code (single PDE, no PT walk)\n- Map frequently accessed structures with global pages\n- Keep page tables in physically contiguous memory\n\n### SIMD Opportunity\n\n| Operation | SIMD Potential | Notes |\n|-----------|----------------|-------|\n| Page table zeroing | High | Use SSE `movdqa` or `rep stosd` |\n| Bitmap operations | Medium | Could use SSE for bulk set/clear |\n| Memory copy | High | SSE for `memcpy` implementation |\n| Heap operations | Low | Pointer manipulation, not data |\n\n**Example: SSE Page Zeroing**\n\n```c\nvoid zero_page_sse(void *page) {\n    __asm__ volatile (\n        \"pxor %%xmm0, %%xmm0\\n\"\n        \"movdqa %%xmm0, (%0)\\n\"\n        \"movdqa %%xmm0, 16(%0)\\n\"\n        \"movdqa %%xmm0, 32(%0)\\n\"\n        \"movdqa %%xmm0, 48(%0)\\n\"\n        // ... repeat for 4096 bytes\n        : : \"r\"(page) : \"xmm0\", \"memory\"\n    );\n}\n```\n\n### Memory Access Patterns\n\n| Operation | Pattern | Cache Friendliness |\n|-----------|---------|-------------------|\n| Bitmap scan | Sequential | Excellent (prefetch) |\n| Page table walk | 2-level tree | Moderate (depends on locality) |\n| Heap allocation | Linked list | Poor (pointer chasing) |\n| Page fault | Random | N/A (exception) |\n\n---\n\n## Visual Diagrams\n\n\n![Physical Memory Map: E820/Multiboot Regions](./diagrams/tdd-diag-017.svg)\n\nMemory map regions: usable vs. reserved address ranges\n\n{{DIAGRAM:tdd-diag-018}}\nFrame bitmap: address to bit mapping\n\n{{DIAGRAM:tdd-diag-019}}\nTwo-level page table: virtual address decomposition\n\n\n![PDE and PTE Entry Layout (4 bytes each)](./diagrams/tdd-diag-020.svg)\n\nPDE and PTE structure: flag bits and frame address\n\n\n![Identity Mapping vs Higher-Half Mapping](./diagrams/tdd-diag-021.svg)\n\nIdentity mapping vs. higher-half mapping\n\n\n![Paging Enable Transition Sequence](./diagrams/tdd-diag-022.svg)\n\nPaging enable transition: identity to virtual\n\n\n![TLB Coherency: invlpg vs CR3 Reload](./diagrams/tdd-diag-023.svg)\n\nTLB invalidation: invlpg vs. CR3 reload\n\n\n![Page Fault Handling: CR2 and Error Code](./diagrams/tdd-diag-024.svg)\n\nPage fault handling: CR2 and error code\n\n\n![kmalloc Block Header and Free List](./diagrams/tdd-diag-025.svg)\n\nHeap block structure: header and usable space\n\n\n![Memory Management Module Architecture](./diagrams/tdd-diag-026.svg)\n\nHeap coalescing: merging adjacent free blocks\n\n---\n\n[[CRITERIA_JSON: {\"module_id\": \"build-os-m3\", \"criteria\": [\"Physical memory map obtained from multiboot info or E820 with regions classified as usable, reserved, or ACPI\", \"Physical frame allocator (bitmap or free-list) allocates and frees 4KB frames with double-free prevention\", \"Page directory and page tables configured for identity-mapping (kernel + VGA + MMIO) and higher-half kernel mapping (0xC0000000+)\", \"Paging enabled by loading CR3 with page directory physical address and setting CR0.PG bit\", \"TLB flushed with invlpg or CR3 reload after modifying page table entries\", \"Page fault handler reads CR2 for faulting address and prints diagnostic (address, error code bits for present/write/user)\", \"Kernel heap allocator (kmalloc/kfree) provides dynamic allocation from dedicated virtual range using page allocator for backing frames\", \"Identity map maintained for low memory so VGA (0xB8000) and MMIO regions remain accessible at physical addresses\"]}]\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-os-m4 -->\n# Module: Processes and Preemptive Scheduling\n\n## Module Charter\n\nThis module implements preemptive multitasking, transforming the kernel from a single-threaded program into a multi-process system. It defines the Process Control Block (PCB) as the complete capture of CPU state (general registers, segment registers, EIP, ESP, EFLAGS, CR3), implements context switching in assembly to atomically save one process and restore another, configures the Task State Segment (TSS) for safe ring 3 → ring 0 transitions by providing the kernel stack pointer (ESP0), builds a round-robin scheduler triggered by timer interrupts that fairly distributes CPU time, creates isolated user-mode processes with their own page directories where kernel pages are supervisor-only, and establishes a system call interface via INT 0x80 with DPL=3 allowing user mode to request kernel services. This module does NOT implement priority scheduling, blocking I/O, signals, or multi-core support. The invariant is: after this module completes, multiple processes run concurrently with complete isolation, context switches preserve all state atomically, user processes cannot access kernel memory, and syscalls provide controlled kernel entry.\n\n---\n\n## File Structure\n\n```\nkernel/\n├── process/\n│   ├── process.h             # 1. PCB structure and process API\n│   ├── process.c             # 1-2. Process creation and management\n│   ├── context_switch.h      # 3. Context switch interface\n│   └── context_switch.asm    # 3. Assembly context switch implementation\n├── tss/\n│   ├── tss.h                 # 4. TSS structure and interface\n│   └── tss.c                 # 4-5. TSS initialization and ESP0 update\n├── scheduler/\n│   ├── scheduler.h           # 6. Scheduler interface\n│   └── scheduler.c           # 6-7. Round-robin implementation\n├── user/\n│   ├── user_memory.h         # 8. User address space management\n│   ├── user_memory.c         # 8. User page directory creation\n│   ├── user_mode.h           # 9. User mode entry interface\n│   └── user_mode.asm         # 9. Assembly iret to user mode\n├── syscall/\n│   ├── syscall.h             # 10. System call interface\n│   ├── syscall.c             # 10-11. Syscall dispatch and implementations\n│   └── syscall.asm           # 10. Syscall assembly entry\n└── Makefile                  # Updated build system\n```\n\n---\n\n## Complete Data Model\n\n### Process Control Block (PCB)\n\nThe PCB captures all state needed to suspend and resume a process. Every field exists because the CPU requires it to resume execution correctly.\n\n```c\n/* process.h */\n\n#define MAX_PROCESSES       16\n#define KERNEL_STACK_SIZE   4096\n#define USER_STACK_SIZE     4096\n#define MAX_NAME_LEN        16\n\ntypedef enum {\n    PROCESS_STATE_UNUSED = 0,\n    PROCESS_STATE_READY,\n    PROCESS_STATE_RUNNING,\n    PROCESS_STATE_BLOCKED,\n    PROCESS_STATE_ZOMBIE\n} process_state_t;\n\n// CPU state saved on context switch\n// This matches the stack layout created by interrupt entry + our pushes\ntypedef struct {\n    // General-purpose registers (pushed by pusha in reverse order)\n    uint32_t edi;\n    uint32_t esi;\n    uint32_t ebp;\n    uint32_t esp;        // Kernel ESP at time of switch (not user ESP!)\n    uint32_t ebx;\n    uint32_t edx;\n    uint32_t ecx;\n    uint32_t eax;\n    \n    // Segment registers (pushed manually)\n    uint16_t ds;\n    uint16_t es;\n    uint16_t fs;\n    uint16_t gs;\n    uint16_t ss;         // Stack segment at interrupt time\n    uint16_t padding;    // Align to 4 bytes\n    \n    // Control registers and pointers\n    uint32_t eip;        // Instruction pointer (from stack)\n    uint32_t eflags;     // CPU flags (from stack)\n    uint32_t cs;         // Code segment (from stack)\n    uint32_t cr3;        // Page directory physical address\n} __attribute__((packed)) cpu_state_t;\n\n// Complete process descriptor\ntypedef struct process {\n    // Identification\n    uint32_t pid;\n    char name[MAX_NAME_LEN];\n    process_state_t state;\n    \n    // CPU state (must be aligned for efficient save/restore)\n    cpu_state_t cpu;\n    \n    // Memory management\n    uint32_t kernel_stack;      // Physical address of kernel stack\n    uint32_t kernel_stack_top;  // Top of kernel stack (ESP value)\n    uint32_t user_stack;        // Physical address of user stack (if user mode)\n    uint32_t user_stack_top;    // Top of user stack\n    uint32_t page_directory;    // Physical address of page directory (CR3)\n    \n    // Scheduling\n    struct process *next;       // Next process in ready queue\n    struct process *prev;       // Previous process (for removal)\n    uint32_t time_slice;        // Remaining time slice (for future priority)\n    uint32_t total_ticks;       // Total CPU time consumed\n    \n    // Process type\n    int is_user;                // 1 = user mode, 0 = kernel mode\n    \n    // Exit status (for zombie state)\n    int exit_status;\n} process_t;\n```\n\n**Memory Layout of cpu_state_t:**\n\n```\nOffset  Size  Field         Notes\n------  ----  -----         -----\n0       4     edi           pusha pushes this first\n4       4     esi\n8       4     ebp\n12      4     esp           Value before pusha (ignored on restore)\n16      4     ebx\n20      4     edx\n24      4     ecx\n28      4     eax           pusha pushes this last\n30      2     ds\n32      2     es\n34      2     fs\n36      2     gs\n38      2     ss\n40      2     padding\n44      4     eip           From interrupt stack frame\n48      4     eflags        From interrupt stack frame\n52      4     cs            From interrupt stack frame\n56      4     cr3           Page directory\nTotal: 60 bytes\n```\n\n**Cache Line Analysis:**\n- `cpu_state_t` is 60 bytes = 1 cache line (64 bytes)\n- `process_t` is ~100 bytes = 2 cache lines\n- During context switch, we access ~2 cache lines per process\n- Critical for performance: keep PCB small, aligned\n\n### Task State Segment (TSS)\n\nThe TSS is used solely for ring 3 → ring 0 stack switching. The CPU loads SS0:ESP0 automatically on privilege level transitions.\n\n```c\n/* tss.h */\n\ntypedef struct {\n    uint16_t link;     uint16_t _pad0;   // Previous task link (for task switches)\n    uint32_t esp0;                       // Stack pointer for ring 0\n    uint16_t ss0;      uint16_t _pad1;   // Stack segment for ring 0\n    uint32_t esp1;                       // Stack pointer for ring 1 (unused)\n    uint16_t ss1;      uint16_t _pad2;   // Stack segment for ring 1 (unused)\n    uint32_t esp2;                       // Stack pointer for ring 2 (unused)\n    uint16_t ss2;      uint16_t _pad3;   // Stack segment for ring 2 (unused)\n    uint32_t cr3;                        // Page directory (not used by us)\n    uint32_t eip;                        // Instruction pointer (not used)\n    uint32_t eflags;                     // CPU flags (not used)\n    uint32_t eax, ecx, edx, ebx;         // General registers (not used)\n    uint32_t esp, ebp, esi, edi;         // General registers (not used)\n    uint16_t es;       uint16_t _pad4;\n    uint16_t cs;       uint16_t _pad5;\n    uint16_t ss;       uint16_t _pad6;\n    uint16_t ds;       uint16_t _pad7;\n    uint16_t fs;       uint16_t _pad8;\n    uint16_t gs;       uint16_t _pad9;\n    uint16_t ldtr;     uint16_t _pad10;  // LDT selector (unused)\n    uint16_t _pad11;\n    uint16_t iomap_base;                 // I/O permission bitmap offset\n} __attribute__((packed)) tss_t;\n\n// TSS is 104 bytes minimum (without I/O bitmap)\n// We place iomap_base = sizeof(tss_t) to indicate no I/O bitmap\n\nextern tss_t kernel_tss;\n```\n\n**Memory Layout (104 bytes):**\n\n```\nOffset  Field\n------  -----\n0x00    link (2) + padding (2)\n0x04    esp0 (4)           <-- CRITICAL: updated on every context switch\n0x08    ss0 (2) + padding (2)\n0x0C    esp1, ss1 (unused)\n0x14    esp2, ss2 (unused)\n0x1C    cr3 (unused)\n0x20    eip, eflags (unused)\n0x28    eax-edi (unused)\n0x48    es, cs, ss, ds, fs, gs (unused)\n0x58    ldtr (unused)\n0x60    iomap_base (2)\n0x64    End (104 bytes total)\n```\n\n**CRITICAL FIELDS:**\n- `esp0`: Must point to top of current process's kernel stack\n- `ss0`: Must be kernel data segment selector (0x10)\n- `iomap_base`: Set to `sizeof(tss_t)` = 104 to indicate no I/O bitmap\n\n### GDT TSS Descriptor\n\nThe TSS must be referenced by a descriptor in the GDT.\n\n```c\n// TSS descriptor in GDT (8 bytes)\n// Placed at GDT index 6 (selector 0x30)\n\n// Structure of TSS descriptor:\n// Bits 0-15:  Limit low (sizeof(tss_t) - 1)\n// Bits 16-39: Base low (address bits 0-23)\n// Bit 40:     Present (1)\n// Bits 41-42: DPL (00 for ring 0 only, 11 for ring 3 can use)\n// Bit 43:     S (0 for system segment)\n// Bits 44-47: Type (1001 = 32-bit TSS available)\n// Bits 48-51: Limit high\n// Bit 52:     AVL (0)\n// Bit 53:     L (0)\n// Bit 54:     D/B (0)\n// Bit 55:     G (0 = byte granularity)\n// Bits 56-63: Base high (address bits 24-31)\n\n#define TSS_DESCRIPTOR(base, limit, dpl) \\\n    (((uint64_t)(base) & 0xFF000000) << 56 | \\\n     ((uint64_t)(limit) & 0x000F0000) << 32 | \\\n     (1ULL << 47) | \\\n     ((uint64_t)(dpl) << 45) | \\\n     (0x9ULL << 40) | \\\n     (((uint64_t)(base) & 0x00FF0000) << 16) | \\\n     (((uint64_t)(limit) & 0x0000FFFF) << 0) | \\\n     (((uint64_t)(base) & 0x0000FFFF) << 16))\n```\n\n### System Call Registers Convention\n\nSystem calls use registers for arguments, following a simple convention.\n\n```c\n/* syscall.h */\n\n// System call numbers (in EAX)\n#define SYS_EXIT    0\n#define SYS_WRITE   1\n#define SYS_READ    2\n#define SYS_GETPID  3\n\n// Register convention for INT 0x80:\n// EAX = syscall number\n// EBX = first argument\n// ECX = second argument\n// EDX = third argument\n// ESI = fourth argument (if needed)\n// EDI = fifth argument (if needed)\n//\n// Return value in EAX\n// Error: EAX = -errno (negative error code)\n\ntypedef struct {\n    uint32_t syscall_num;  // EAX\n    uint32_t arg0;         // EBX\n    uint32_t arg1;         // ECX\n    uint32_t arg2;         // EDX\n    uint32_t arg3;         // ESI\n    uint32_t arg4;         // EDI\n} syscall_args_t;\n\n// Syscall handler type\ntypedef int32_t (*syscall_handler_t)(uint32_t arg0, uint32_t arg1, \n                                      uint32_t arg2, uint32_t arg3, \n                                      uint32_t arg4);\n```\n\n### Ready Queue Structure\n\nThe scheduler maintains a circular doubly-linked list of ready processes.\n\n```c\n/* scheduler.h */\n\n// Ready queue: circular doubly-linked list\nextern process_t *ready_queue_head;\nextern process_t *current_process;\n\n// Scheduler functions\nvoid scheduler_init(void);\nvoid scheduler_add_process(process_t *proc);\nvoid scheduler_remove_process(process_t *proc);\nprocess_t *scheduler_pick_next(void);\nvoid scheduler_yield(void);\nvoid scheduler_block(void);\nvoid scheduler_unblock(process_t *proc);\n\n// Timer hook\nvoid scheduler_timer_tick(void);\n```\n\n**Queue State Diagram:**\n\n```\nEmpty queue:\n    ready_queue_head = NULL\n    current_process = NULL\n\nSingle process:\n    ready_queue_head --> [P1] <--+\n                         ^  |    |\n                         +--+    |\n                         current_process\n\nMultiple processes (circular):\n    ready_queue_head --> [P1] <--> [P2] <--> [P3] <--+\n                         ^                           |\n                         |---------------------------+\n                         current_process\n```\n\n---\n\n## Interface Contracts\n\n### process_create / process_destroy\n\n```c\n/* process.h */\n\n// Create a new kernel-mode process\n// entry_point: function to execute\n// name: process name for debugging\n// Returns pointer to PCB, or NULL on failure\nprocess_t *process_create(void (*entry_point)(void), const char *name);\n\n// Create a new user-mode process\n// entry_point: virtual address of entry function (in user address space)\n// name: process name for debugging\n// Returns pointer to PCB, or NULL on failure\nprocess_t *process_create_user(void (*entry_point)(void), const char *name);\n\n// Get current process\nprocess_t *process_get_current(void);\n\n// Terminate current process\n// status: exit status code\nvoid process_exit(int status) __attribute__((noreturn));\n\n// Find process by PID\nprocess_t *process_find_by_pid(uint32_t pid);\n```\n\n**Preconditions:**\n- Memory management initialized (kmalloc available)\n- GDT configured with kernel and user segments\n\n**Postconditions:**\n- PCB allocated and initialized\n- Kernel stack allocated\n- Process added to ready queue\n- For user processes: page directory created with isolated address space\n\n**Error Handling:**\n| Error | Detection | Recovery |\n|-------|-----------|----------|\n| No free PCB slots | Loop finds no unused entry | Return NULL |\n| Stack allocation failed | `kmalloc` returns NULL | Return NULL |\n| Page directory failed | `pmm_alloc_frame` returns 0 | Return NULL |\n\n### context_switch\n\n```c\n/* context_switch.h */\n\n// Switch from current process to next process\n// This is called from scheduler after picking next process\n// Does NOT return normally - it \"returns\" into the new process\nvoid context_switch(process_t *old, process_t *new);\n\n// Assembly entry point for context switch from interrupt\n// Called with interrupts disabled, after saving interrupt state to stack\nvoid context_switch_from_interrupt(void);\n```\n\n**Preconditions:**\n- Interrupts disabled\n- `old` process state already saved to PCB (by interrupt handler)\n- `new` process has valid state in PCB\n\n**Postconditions:**\n- All registers restored from `new->cpu`\n- CR3 loaded with `new->page_directory`\n- ESP0 in TSS updated to `new->kernel_stack_top`\n- Execution resumes at `new->cpu.eip`\n\n**CRITICAL:** This function does not return in the normal sense. It \"returns\" into the new process at whatever EIP the new process was at when switched out.\n\n### tss_init / tss_update_esp0\n\n```c\n/* tss.h */\n\n// Initialize TSS and load TR\n// Must be called after GDT is configured\nvoid tss_init(void);\n\n// Update ESP0 field for current process\n// Must be called after every context switch\nvoid tss_update_esp0(uint32_t esp0);\n\n// Get current ESP0 value\nuint32_t tss_get_esp0(void);\n```\n\n**Preconditions:**\n- GDT configured with TSS descriptor at index 6\n\n**Postconditions:**\n- TSS zeroed and initialized\n- SS0 set to kernel data segment (0x10)\n- TR loaded with TSS selector (0x30)\n- ESP0 valid\n\n### scheduler_add / scheduler_remove / scheduler_pick_next\n\n```c\n/* scheduler.h */\n\n// Add process to end of ready queue\nvoid scheduler_add_process(process_t *proc);\n\n// Remove process from ready queue\nvoid scheduler_remove_process(process_t *proc);\n\n// Pick next process to run (round-robin)\n// Returns process to run, or NULL if no processes ready\nprocess_t *scheduler_pick_next(void);\n\n// Voluntarily yield CPU\nvoid scheduler_yield(void);\n\n// Called from timer interrupt\nvoid scheduler_timer_tick(void);\n```\n\n**Preconditions:**\n- Process state is PROCESS_STATE_READY (for add)\n\n**Postconditions:**\n- Process linked into ready queue\n- On pick_next: selected process state = PROCESS_STATE_RUNNING\n\n### user_create_page_directory / user_map_code\n\n```c\n/* user_memory.h */\n\n// Create a new page directory for user process\n// Copies kernel mappings (higher half) but marks them supervisor-only\n// Returns physical address of page directory, or 0 on failure\nuint32_t user_create_page_directory(void);\n\n// Map user code at virtual address 0x00001000\n// pd_phys: physical address of user page directory\n// code: pointer to code data (will be copied)\n// size: size of code\n// Returns 0 on success, -1 on failure\nint user_map_code(uint32_t pd_phys, const void *code, size_t size);\n\n// Map user stack at virtual address 0xBFFFF000\n// pd_phys: physical address of user page directory\n// Returns 0 on success, -1 on failure\nint user_map_stack(uint32_t pd_phys);\n```\n\n**Preconditions:**\n- PMM and VMM initialized\n- Paging enabled\n\n**Postconditions:**\n- User page directory created\n- Kernel pages mapped but supervisor-only\n- User code and stack mapped with user-accessible flag\n\n### jump_to_user_mode\n\n```c\n/* user_mode.h */\n\n// Jump to user mode using iret\n// This function never returns\n// entry: virtual address of user entry point\n// stack_top: virtual address of user stack top\nvoid jump_to_user_mode(uint32_t entry, uint32_t stack_top) __attribute__((noreturn));\n```\n\n**Preconditions:**\n- User page directory loaded (CR3)\n- User code and stack mapped\n- TSS ESP0 set to valid kernel stack\n\n**Postconditions:**\n- CPU in ring 3 (CPL = 3)\n- CS = user code selector (0x1B)\n- SS = user data selector (0x23)\n- ESP = stack_top\n- EIP = entry\n\n### syscall_handler\n\n```c\n/* syscall.h */\n\n// Main syscall dispatcher\n// regs: pointer to saved register state\nvoid syscall_handler(registers_t *regs);\n\n// Register a syscall handler\nvoid syscall_register(uint32_t num, syscall_handler_t handler);\n\n// Individual syscall implementations\nint32_t sys_exit(int status);\nint32_t sys_write(int fd, const char *buf, int len);\nint32_t sys_read(int fd, char *buf, int len);\nint32_t sys_getpid(void);\n```\n\n**Preconditions:**\n- IDT gate 0x80 configured with DPL=3 (0xEE)\n- Syscall table initialized\n\n**Postconditions:**\n- Syscall executed\n- Return value in EAX\n- If error: EAX = negative error code\n\n---\n\n## Algorithm Specification\n\n### Algorithm: Process Creation (Kernel Mode)\n\n**Purpose:** Create a new kernel-mode process ready to execute.\n\n**Inputs:**\n- Entry point function pointer\n- Process name\n\n**Outputs:** Pointer to initialized PCB\n\n**Procedure:**\n1. Find unused slot in process table\n2. Allocate PID\n3. Zero PCB structure\n4. Set initial CPU state:\n   - EIP = entry_point\n   - CS = kernel code selector (0x08)\n   - DS/ES/FS/GS/SS = kernel data selector (0x10)\n   - EFLAGS = 0x202 (IF set, reserved bit set)\n   - CR3 = kernel page directory\n5. Allocate kernel stack\n6. Set ESP = kernel_stack_top\n7. Set state = PROCESS_STATE_READY\n8. Add to scheduler ready queue\n\n```c\nprocess_t *process_create(void (*entry_point)(void), const char *name) {\n    // Find free slot\n    process_t *proc = NULL;\n    for (int i = 0; i < MAX_PROCESSES; i++) {\n        if (process_table[i].state == PROCESS_STATE_UNUSED) {\n            proc = &process_table[i];\n            break;\n        }\n    }\n    if (!proc) return NULL;\n    \n    // Initialize PCB\n    proc->pid = next_pid++;\n    proc->state = PROCESS_STATE_READY;\n    proc->is_user = 0;\n    strncpy(proc->name, name, MAX_NAME_LEN - 1);\n    \n    // Allocate kernel stack\n    proc->kernel_stack = (uint32_t)kmalloc(KERNEL_STACK_SIZE);\n    if (!proc->kernel_stack) {\n        proc->state = PROCESS_STATE_UNUSED;\n        return NULL;\n    }\n    proc->kernel_stack_top = proc->kernel_stack + KERNEL_STACK_SIZE;\n    \n    // Set initial CPU state\n    proc->cpu.eip = (uint32_t)entry_point;\n    proc->cpu.cs = 0x08;\n    proc->cpu.ds = 0x10;\n    proc->cpu.es = 0x10;\n    proc->cpu.fs = 0x10;\n    proc->cpu.gs = 0x10;\n    proc->cpu.ss = 0x10;\n    proc->cpu.esp = proc->kernel_stack_top;\n    proc->cpu.eflags = 0x202;  // IF set\n    proc->cpu.cr3 = (uint32_t)kernel_page_directory;\n    \n    // Add to ready queue\n    scheduler_add_process(proc);\n    \n    return proc;\n}\n```\n\n**Invariants:**\n- Process is in ready queue\n- Kernel stack is valid and 4KB aligned\n- EFLAGS.IF = 1 (process can receive interrupts)\n\n### Algorithm: Context Switch (Assembly)\n\n**Purpose:** Atomically switch from one process to another.\n\n**Inputs:**\n- `old`: PCB of current process (to save state)\n- `new`: PCB of next process (to restore state)\n\n**Outputs:** None (execution resumes in new process)\n\n**Procedure:**\n1. Disable interrupts (cli)\n2. Save current segment registers to old PCB\n3. Save current general registers to old PCB\n4. Save old ESP to old PCB\n5. Load new CR3 (page directory)\n6. Update TSS ESP0 to new kernel stack top\n7. Load new segment registers from new PCB\n8. Load new general registers from new PCB\n9. Load new ESP from new PCB\n10. Enable interrupts (restore from new EFLAGS)\n11. Return (actually \"returns\" to new EIP)\n\n```asm\n; context_switch.asm\n[BITS 32]\n\nglobal context_switch\nextern kernel_tss\nextern tss_update_esp0\n\n; void context_switch(process_t *old, process_t *new)\n; Stack: [ret_addr] [old] [new]\ncontext_switch:\n    push ebp\n    mov ebp, esp\n    push ebx\n    push esi\n    push edi\n    \n    mov ebx, [ebp + 8]     ; old process\n    mov ecx, [ebp + 12]    ; new process\n    \n    ; ===== SAVE OLD PROCESS STATE =====\n    test ebx, ebx\n    jz .load_new           ; Skip save if old is NULL\n    \n    ; Save general-purpose registers\n    mov [ebx + process_t.cpu + cpu_state_t.eax], eax\n    mov [ebx + process_t.cpu + cpu_state_t.ebx], ebx\n    mov [ebx + process_t.cpu + cpu_state_t.ecx], ecx\n    mov [ebx + process_t.cpu + cpu_state_t.edx], edx\n    mov [ebx + process_t.cpu + cpu_state_t.esi], esi\n    mov [ebx + process_t.cpu + cpu_state_t.edi], edi\n    mov [ebx + process_t.cpu + cpu_state_t.ebp], ebp\n    \n    ; Save ESP (current stack pointer after our pushes)\n    lea eax, [ebp + 16]    ; ESP before function call\n    mov [ebx + process_t.cpu + cpu_state_t.esp], eax\n    \n    ; Save return address as EIP\n    mov eax, [ebp + 4]     ; Return address\n    mov [ebx + process_t.cpu + cpu_state_t.eip], eax\n    \n    ; Save EFLAGS\n    pushf\n    pop eax\n    mov [ebx + process_t.cpu + cpu_state_t.eflags], eax\n    \n    ; Save segment registers\n    mov ax, ds\n    mov [ebx + process_t.cpu + cpu_state_t.ds], ax\n    mov ax, es\n    mov [ebx + process_t.cpu + cpu_state_t.es], ax\n    mov ax, fs\n    mov [ebx + process_t.cpu + cpu_state_t.fs], ax\n    mov ax, gs\n    mov [ebx + process_t.cpu + cpu_state_t.gs], ax\n    mov ax, ss\n    mov [ebx + process_t.cpu + cpu_state_t.ss], ax\n    \n    ; Save CR3\n    mov eax, cr3\n    mov [ebx + process_t.cpu + cpu_state_t.cr3], eax\n\n.load_new:\n    ; ===== LOAD NEW PROCESS STATE =====\n    mov ecx, [ebp + 12]    ; new process\n    \n    ; Update TSS ESP0\n    mov eax, [ecx + process_t.kernel_stack_top]\n    mov [kernel_tss + tss_t.esp0], eax\n    \n    ; Load CR3 (page directory)\n    mov eax, [ecx + process_t.cpu + cpu_state_t.cr3]\n    mov cr3, eax\n    \n    ; Load segment registers\n    mov ax, [ecx + process_t.cpu + cpu_state_t.ds]\n    mov ds, ax\n    mov ax, [ecx + process_t.cpu + cpu_state_t.es]\n    mov es, ax\n    mov ax, [ecx + process_t.cpu + cpu_state_t.fs]\n    mov fs, ax\n    mov ax, [ecx + process_t.cpu + cpu_state_t.gs]\n    mov gs, ax\n    \n    ; Load EFLAGS\n    push dword [ecx + process_t.cpu + cpu_state_t.eflags]\n    popf\n    \n    ; Load general registers\n    mov eax, [ecx + process_t.cpu + cpu_state_t.eax]\n    mov ebx, [ecx + process_t.cpu + cpu_state_t.ebx]\n    mov ecx, [ecx + process_t.cpu + cpu_state_t.ecx]\n    mov edx, [ecx + process_t.cpu + cpu_state_t.edx]\n    mov esi, [ecx + process_t.cpu + cpu_state_t.esi]\n    mov edi, [ecx + process_t.cpu + cpu_state_t.edi]\n    mov ebp, [ecx + process_t.cpu + cpu_state_t.ebp]\n    \n    ; Load ESP and EIP simultaneously via stack\n    mov esp, [ecx + process_t.cpu + cpu_state_t.esp]\n    \n    ; Return to new EIP (this is the magic!)\n    jmp [ecx + process_t.cpu + cpu_state_t.eip]\n    \n    ; Never reaches here\n```\n\n**CRITICAL INSIGHTS:**\n1. The return address is saved as EIP - when we later \"return\" to this address, we resume the old process\n2. ESP is loaded last, after all other registers - this is the actual switch point\n3. CR3 reload flushes TLB (unless global pages used) - expensive but necessary\n4. EFLAGS.IF is restored from new process, re-enabling interrupts\n\n### Algorithm: Round-Robin Scheduling\n\n**Purpose:** Fairly distribute CPU time among ready processes.\n\n**Inputs:** None (uses ready queue)\n**Outputs:** Next process to run\n\n**Procedure:**\n1. If no current process, return head of ready queue\n2. Find next process in circular queue after current\n3. Skip processes that are not READY\n4. Return found process\n\n```c\nprocess_t *scheduler_pick_next(void) {\n    if (ready_queue_head == NULL) {\n        return NULL;\n    }\n    \n    if (current_process == NULL) {\n        current_process = ready_queue_head;\n        current_process->state = PROCESS_STATE_RUNNING;\n        return current_process;\n    }\n    \n    // Start from current, find next ready process\n    process_t *next = current_process->next;\n    \n    while (next != current_process) {\n        if (next->state == PROCESS_STATE_READY) {\n            current_process->state = PROCESS_STATE_READY;\n            next->state = PROCESS_STATE_RUNNING;\n            current_process = next;\n            return next;\n        }\n        next = next->next;\n    }\n    \n    // Only current process is ready, continue running it\n    return current_process;\n}\n```\n\n**Invariants:**\n- Ready queue is circular\n- At least one process is RUNNING if any exist\n- No process appears twice in queue\n\n### Algorithm: Timer Interrupt Scheduler Hook\n\n**Purpose:** Trigger context switch on timer tick.\n\n**Inputs:** Timer interrupt\n**Outputs:** Possible context switch\n\n**Procedure:**\n1. Increment tick counter\n2. Increment current process's total_ticks\n3. Decrement time slice\n4. If time slice expired:\n   - Reset time slice\n   - Pick next process\n   - If different from current, do context switch\n\n```c\nvoid scheduler_timer_tick(void) {\n    if (current_process == NULL) return;\n    \n    current_process->total_ticks++;\n    current_process->time_slice--;\n    \n    if (current_process->time_slice == 0) {\n        // Time slice expired, switch process\n        current_process->time_slice = DEFAULT_TIME_SLICE;\n        \n        process_t *next = scheduler_pick_next();\n        if (next != NULL && next != current_process) {\n            process_t *old = current_process;\n            current_process = next;\n            context_switch(old, next);\n        }\n    }\n}\n```\n\n### Algorithm: User Page Directory Creation\n\n**Purpose:** Create isolated address space for user process.\n\n**Inputs:** None\n**Outputs:** Physical address of new page directory\n\n**Procedure:**\n1. Allocate frame for page directory\n2. Zero the page directory\n3. Copy kernel mappings (entries 768-1023 for higher half)\n4. Clear user-accessible bit on kernel pages\n5. Allocate and map user code page at 0x00001000\n6. Allocate and map user stack page at 0xBFFFF000\n\n```c\nuint32_t user_create_page_directory(void) {\n    // Allocate page directory\n    uint32_t pd_phys = pmm_alloc_frame();\n    if (pd_phys == 0) return 0;\n    \n    page_directory_t *pd = (page_directory_t *)pd_phys;\n    \n    // Zero page directory\n    for (int i = 0; i < 1024; i++) {\n        pd->entries[i] = 0;\n    }\n    \n    // Copy kernel mappings (higher half: 0xC0000000+)\n    // These are supervisor-only (no PAGE_USER flag)\n    for (int i = 768; i < 1024; i++) {\n        pd->entries[i] = kernel_page_directory->entries[i];\n        // Ensure kernel pages are NOT user-accessible\n        pd->entries[i] &= ~PAGE_USER;\n    }\n    \n    return pd_phys;\n}\n\nint user_map_code(uint32_t pd_phys, const void *code, size_t size) {\n    page_directory_t *pd = (page_directory_t *)pd_phys;\n    \n    // Allocate frame for code\n    uint32_t code_frame = pmm_alloc_frame();\n    if (code_frame == 0) return -1;\n    \n    // Map at 0x00001000 (user virtual address)\n    uint32_t vaddr = 0x00001000;\n    uint32_t pd_idx = (vaddr >> 22) & 0x3FF;\n    uint32_t pt_idx = (vaddr >> 12) & 0x3FF;\n    \n    // Create page table if needed\n    if (!(pd->entries[pd_idx] & PAGE_PRESENT)) {\n        uint32_t pt_frame = pmm_alloc_frame();\n        if (pt_frame == 0) return -1;\n        \n        page_table_t *pt = (page_table_t *)pt_frame;\n        for (int i = 0; i < 1024; i++) {\n            pt->entries[i] = 0;\n        }\n        \n        pd->entries[pd_idx] = pt_frame | PAGE_PRESENT | PAGE_WRITABLE | PAGE_USER;\n    }\n    \n    // Map the page\n    page_table_t *pt = (page_table_t *)(pd->entries[pd_idx] & 0xFFFFF000);\n    pt->entries[pt_idx] = code_frame | PAGE_PRESENT | PAGE_WRITABLE | PAGE_USER;\n    \n    // Copy code to frame (need temporary mapping)\n    // ... implementation depends on your VMM\n    \n    return 0;\n}\n```\n\n**CRITICAL:** Kernel pages MUST NOT have PAGE_USER flag set, or user processes can read kernel memory.\n\n### Algorithm: Jump to User Mode\n\n**Purpose:** Transition from kernel mode to user mode.\n\n**Inputs:**\n- User entry point address\n- User stack top address\n\n**Outputs:** Never returns (executes in user mode)\n\n**Procedure:**\n1. Load user data segment selectors\n2. Push user SS (0x23)\n3. Push user ESP\n4. Push user EFLAGS (with IF set)\n5. Push user CS (0x1B)\n6. Push user EIP\n7. Execute `iret`\n\n```asm\n; user_mode.asm\n[BITS 32]\n\nglobal jump_to_user_mode\n\n; void jump_to_user_mode(uint32_t entry, uint32_t stack_top)\n; [ret] [entry] [stack_top]\njump_to_user_mode:\n    mov eax, [esp + 4]     ; entry\n    mov ebx, [esp + 8]     ; stack_top\n    \n    ; Load user data segments\n    mov ax, 0x23           ; User data selector (index 4, RPL=3)\n    mov ds, ax\n    mov es, ax\n    mov fs, ax\n    mov gs, ax\n    \n    ; Set up stack for iret\n    ; Stack must contain: SS, ESP, EFLAGS, CS, EIP\n    \n    push 0x23              ; SS = user data segment\n    push ebx               ; ESP = user stack top\n    \n    ; Set up EFLAGS with IF=1\n    pushf\n    or dword [esp], 0x200  ; Set IF\n    and dword [esp], ~0x4000  ; Clear NT (nested task)\n    \n    push 0x1B              ; CS = user code segment (index 3, RPL=3)\n    push eax               ; EIP = entry point\n    \n    ; iret pops: EIP, CS, EFLAGS, [ESP, SS if CPL change]\n    iret\n    \n    ; Never returns\n```\n\n**CRITICAL:** The selector values must have RPL=3 (bits 0-1 = 11) for the CPU to enter ring 3.\n\n### Algorithm: System Call Handler\n\n**Purpose:** Dispatch system calls from user mode.\n\n**Inputs:**\n- EAX = syscall number\n- EBX-EDI = arguments\n\n**Outputs:** EAX = return value\n\n**Procedure:**\n1. Save all registers (already done by interrupt entry)\n2. Validate syscall number\n3. Look up handler in syscall table\n4. Call handler with arguments\n5. Store return value in regs->eax\n6. Return (iret restores registers)\n\n```c\n// Syscall table\nstatic syscall_handler_t syscall_table[32] = {0};\n\nvoid syscall_handler(registers_t *regs) {\n    uint32_t num = regs->eax;\n    \n    if (num >= 32 || syscall_table[num] == NULL) {\n        regs->eax = -1;  // ENOSYS\n        return;\n    }\n    \n    // Call handler\n    int32_t result = syscall_table[num](\n        regs->ebx,  // arg0\n        regs->ecx,  // arg1\n        regs->edx,  // arg2\n        regs->esi,  // arg3\n        regs->edi   // arg4\n    );\n    \n    regs->eax = (uint32_t)result;\n}\n\n// sys_exit: terminate current process\nint32_t sys_exit(int status) {\n    current_process->state = PROCESS_STATE_ZOMBIE;\n    current_process->exit_status = status;\n    \n    // Force immediate reschedule\n    scheduler_yield();\n    \n    // Never returns\n    return 0;\n}\n\n// sys_write: write to file descriptor\nint32_t sys_write(int fd, const char *buf, int len) {\n    // For now, fd 0 = console output\n    if (fd != 0) return -9;  // EBADF\n    \n    // Validate buffer is in user space\n    if ((uint32_t)buf >= 0xC0000000) return -14;  // EFAULT\n    \n    for (int i = 0; i < len; i++) {\n        vga_putchar(buf[i]);\n        serial_putchar(COM1_PORT, buf[i]);\n    }\n    \n    return len;\n}\n\n// sys_getpid: get current process ID\nint32_t sys_getpid(void) {\n    return (int32_t)current_process->pid;\n}\n```\n\n**IDT Gate Configuration:**\n```c\n// Gate 0x80 must have DPL=3 (bits 5-6 = 11) for user mode to call\n// 0xEE = P=1, DPL=3, S=0, Type=0xE (32-bit interrupt gate)\nidt_set_gate(0x80, (uint32_t)isr128, 0x08, 0xEE);\n```\n\n---\n\n## Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n|-------|-------------|----------|---------------|\n| Context switch corrupts registers | Assembly bug, manifests as random crashes | Debug with register dump | Yes, crash |\n| TSS ESP0 invalid | Triple fault on ring 3→ring0 transition | Validate before context switch | Yes, reboot |\n| User can access kernel memory | Page fault on kernel access (if PAGE_USER set wrong) | Audit page table flags | No (security hole) |\n| Syscall with wrong DPL | General protection fault on INT 0x80 | Fix IDT gate flags | Yes, crash |\n| Process table full | Loop finds no unused slot | Return NULL from create | Caller handles |\n| Stack overflow | Page fault or corruption | Increase stack size | Yes, crash |\n| Circular queue broken | Infinite loop in scheduler | Validate queue integrity | Yes, hang |\n| Double context switch | Reentrant interrupt | Disable IRQs during switch | Yes, corruption |\n| Invalid syscall number | Bounds check | Return -ENOSYS | No, returns error |\n| Bad user pointer | Page fault in syscall | Return -EFAULT | No, returns error |\n\n---\n\n## Concurrency Specification\n\n### Interrupt Safety\n\n| Data Structure | Access Pattern | Protection |\n|----------------|----------------|------------|\n| Process table | Read/write from IRQ context | Disable IRQs during modification |\n| Ready queue | Read/write from IRQ context | Disable IRQs during modification |\n| Current process pointer | Read/write from IRQ context | Disable IRQs during modification |\n| TSS ESP0 | Write from context switch | IRQs already disabled |\n\n### Critical Sections\n\n```c\n// Context switch MUST be atomic\nvoid do_context_switch(void) {\n    uint32_t flags;\n    __asm__ volatile (\"pushf; pop %0; cli\" : \"=r\"(flags));\n    \n    process_t *old = current_process;\n    process_t *new = scheduler_pick_next();\n    \n    if (new != old) {\n        context_switch(old, new);\n    }\n    \n    // Restore interrupts if they were enabled\n    if (flags & 0x200) {\n        __asm__ volatile (\"sti\");\n    }\n}\n```\n\n### Reentrancy Rules\n\n- **Timer interrupt:** CAN interrupt kernel code, MUST NOT interrupt context switch\n- **Context switch:** MUST NOT be interrupted (IRQs disabled)\n- **Scheduler:** CAN be called from interrupt context only\n- **Syscall handler:** CAN be interrupted, MUST NOT cause context switch directly\n\n---\n\n## State Machine: Process Lifecycle\n\n```\n                    +------------------+\n                    |     UNUSED       |\n                    +--------+---------+\n                             |\n                      process_create()\n                             |\n                             v\n                    +------------------+\n            +------>|      READY       |<------+\n            |       +--------+---------+       |\n            |                |                 |\n            |         scheduler_pick()         |\n            |                |                 |\n            |                v                 |\n            |       +------------------+       |\n            |       |     RUNNING      |-------+\n            |       +--------+---------+  time_slice=0\n            |                |\n            |         block() or\n            |         wait for I/O\n            |                |\n            |                v\n            |       +------------------+\n            |       |     BLOCKED      |\n            |       +--------+---------+\n            |                |\n            |         I/O complete\n            |         or event\n            |                |\n            +----------------+\n            \n            sys_exit() or\n            fatal exception\n                    |\n                    v\n           +------------------+\n           |      ZOMBIE      |\n           +--------+---------+\n                    |\n             parent reaps\n                    |\n                    v\n           +------------------+\n           |     UNUSED       |\n           +------------------+\n\nStates:\n  - UNUSED: PCB slot available\n  - READY: Process can run, waiting for CPU\n  - RUNNING: Currently executing\n  - BLOCKED: Waiting for I/O or event (not implemented yet)\n  - ZOMBIE: Terminated, waiting for parent to reap\n```\n\n---\n\n## Implementation Sequence with Checkpoints\n\n### Phase 1: Process Control Block Structure (2-3 hours)\n\n**Files:** process/process.h\n\n**Steps:**\n1. Define `process_state_t` enum\n2. Define `cpu_state_t` structure with all registers\n3. Define `process_t` structure\n4. Define constants (MAX_PROCESSES, stack sizes)\n5. Calculate offsets for assembly access\n\n**Checkpoint:** Structures compile, sizes verified.\n\n**Test:**\n```c\n#include \"process.h\"\nassert(sizeof(cpu_state_t) == 60);\nassert(offsetof(process_t, cpu) == 20);  // After pid, name, state\n```\n\n---\n\n### Phase 2: Process Creation (Kernel Mode) (3-4 hours)\n\n**Files:** process/process.c\n\n**Steps:**\n1. Declare process table and current_process\n2. Implement `process_create()`\n3. Implement `process_get_current()`\n4. Test process creation without scheduling\n\n**Checkpoint:** Process created, added to table.\n\n**Test:**\n```c\nprocess_t *p1 = process_create(test_function, \"test\");\nassert(p1 != NULL);\nassert(p1->pid == 1);\nassert(p1->state == PROCESS_STATE_READY);\nassert(p1->cpu.eip == (uint32_t)test_function);\n```\n\n---\n\n### Phase 3: Context Switch Assembly (5-7 hours)\n\n**Files:** process/context_switch.h, process/context_switch.asm\n\n**Steps:**\n1. Write assembly context switch function\n2. Define offsets as constants (match C struct)\n3. Implement save of old process\n4. Implement load of new process\n5. Handle NULL old process (first switch)\n\n**Checkpoint:** Context switch works between two processes.\n\n**Test:**\n```c\n// Create two processes, manually switch\nprocess_t *p1 = process_create(proc1_func, \"proc1\");\nprocess_t *p2 = process_create(proc2_func, \"proc2\");\n\ncurrent_process = p1;\np1->state = PROCESS_STATE_RUNNING;\n\n// This should switch to p2\ncontext_switch(p1, p2);\n// If we get here, switch worked\n```\n\n---\n\n### Phase 4: TSS Structure and Initialization (2-3 hours)\n\n**Files:** tss/tss.h, tss/tss.c\n\n**Steps:**\n1. Define `tss_t` structure\n2. Declare `kernel_tss` global\n3. Implement `tss_init()` to zero and configure TSS\n4. Add TSS descriptor to GDT\n5. Load TR with TSS selector\n\n**Checkpoint:** TSS loaded, TR valid.\n\n**Test:**\n```c\ntss_init();\n// In QEMU monitor: info registers\n// Should show TR = 0x30\nassert(kernel_tss.ss0 == 0x10);\n```\n\n---\n\n### Phase 5: TSS ESP0 Update (1-2 hours)\n\n**Files:** tss/tss.c (update)\n\n**Steps:**\n1. Implement `tss_update_esp0()`\n2. Integrate into context switch\n3. Verify ESP0 changes on switch\n\n**Checkpoint:** ESP0 updated on every context switch.\n\n**Test:**\n```c\nuint32_t old_esp0 = tss_get_esp0();\ncontext_switch(p1, p2);\nuint32_t new_esp0 = tss_get_esp0();\nassert(new_esp0 == p2->kernel_stack_top);\nassert(new_esp0 != old_esp0);\n```\n\n---\n\n### Phase 6: Round-Robin Scheduler (3-4 hours)\n\n**Files:** scheduler/scheduler.h, scheduler/scheduler.c\n\n**Steps:**\n1. Implement `scheduler_init()`\n2. Implement `scheduler_add_process()`\n3. Implement `scheduler_remove_process()`\n4. Implement `scheduler_pick_next()`\n5. Test with manually created processes\n\n**Checkpoint:** Scheduler picks next process correctly.\n\n**Test:**\n```c\nscheduler_init();\nprocess_t *p1 = process_create(func1, \"p1\");\nprocess_t *p2 = process_create(func2, \"p2\");\n\nprocess_t *next = scheduler_pick_next();\nassert(next == p1);\ncurrent_process = p1;\nnext = scheduler_pick_next();\nassert(next == p2);\n```\n\n---\n\n### Phase 7: Timer Interrupt Scheduler Hook (2-3 hours)\n\n**Files:** scheduler/scheduler.c (update), timer/timer.c (update)\n\n**Steps:**\n1. Add time slice field to process_t\n2. Implement `scheduler_timer_tick()`\n3. Hook into timer interrupt handler\n4. Test preemption\n\n**Checkpoint:** Timer triggers context switch.\n\n**Test:**\n```c\n// Create processes, enable interrupts\nprocess_t *p1 = process_create(func1, \"p1\");\nprocess_t *p2 = process_create(func2, \"p2\");\n__asm__ volatile (\"sti\");\n\n// Wait for timer interrupt\nfor (volatile int i = 0; i < 10000000; i++);\n// Should have switched processes\n```\n\n---\n\n### Phase 8: User Page Directory Creation (3-4 hours)\n\n**Files:** user/user_memory.h, user/user_memory.c\n\n**Steps:**\n1. Implement `user_create_page_directory()`\n2. Implement `user_map_code()`\n3. Implement `user_map_stack()`\n4. Verify kernel pages are supervisor-only\n\n**Checkpoint:** User page directory created with isolation.\n\n**Test:**\n```c\nuint32_t pd = user_create_page_directory();\nassert(pd != 0);\n\n// Check that kernel entries don't have PAGE_USER\npage_directory_t *p = (page_directory_t *)pd;\nfor (int i = 768; i < 1024; i++) {\n    if (p->entries[i] & PAGE_PRESENT) {\n        assert(!(p->entries[i] & PAGE_USER));\n    }\n}\n```\n\n---\n\n### Phase 9: Jump to User Mode (3-4 hours)\n\n**Files:** user/user_mode.h, user/user_mode.asm\n\n**Steps:**\n1. Write assembly `jump_to_user_mode()`\n2. Set up iret stack frame\n3. Test with simple user function\n4. Verify CPL=3 after jump\n\n**Checkpoint:** CPU enters ring 3.\n\n**Test:**\n```c\n// Create user process with entry at 0x1000\nprocess_t *user = process_create_user((void*)0x1000, \"user_test\");\ncurrent_process = user;\njump_to_user_mode(0x1000, user->user_stack_top);\n// Should be executing in ring 3 now\n```\n\n---\n\n### Phase 10: System Call Handler (3-4 hours)\n\n**Files:** syscall/syscall.h, syscall/syscall.c, syscall/syscall.asm\n\n**Steps:**\n1. Implement syscall entry assembly (isr128)\n2. Implement syscall table\n3. Implement `syscall_handler()`\n4. Register INT 0x80 with DPL=3\n\n**Checkpoint:** Syscall from user mode works.\n\n**Test:**\n```c\n// In user mode:\nint result;\n__asm__ volatile (\n    \"int $0x80\"\n    : \"=a\"(result)\n    : \"a\"(SYS_GETPID)\n);\n// result should be current PID\n```\n\n---\n\n### Phase 11: sys_write and sys_exit Implementation (2-3 hours)\n\n**Files:** syscall/syscall.c (update)\n\n**Steps:**\n1. Implement `sys_write()` to VGA\n2. Implement `sys_exit()` with zombie state\n3. Test from user mode\n\n**Checkpoint:** User programs can output and exit.\n\n**Test:**\n```c\n// In user mode:\nconst char *msg = \"Hello from user!\\n\";\nsys_write(0, msg, 17);\nsys_exit(0);\n// Should print message and terminate\n```\n\n---\n\n### Phase 12: Multi-Process Demo (2-3 hours)\n\n**Files:** main.c (update)\n\n**Steps:**\n1. Create three kernel processes\n2. Each prints to different screen region\n3. Verify preemptive multitasking\n4. Verify processes don't corrupt each other\n\n**Checkpoint:** Three processes run concurrently.\n\n**Test:**\n```c\nvoid proc_a(void) {\n    int col = 0;\n    while (1) {\n        vga_putc_at(0, col++, 'A', VGA_COLOR_GREEN);\n        if (col >= 80) col = 0;\n        for (volatile int i = 0; i < 100000; i++);\n    }\n}\n\nvoid proc_b(void) { /* similar */ }\nvoid proc_c(void) { /* similar */ }\n\nprocess_create(proc_a, \"proc_a\");\nprocess_create(proc_b, \"proc_b\");\nprocess_create(proc_c, \"proc_c\");\n__asm__ volatile (\"sti\");\n\n// Should see A, B, C appearing in different rows\n```\n\n---\n\n## Test Specification\n\n### Test: Process Creation\n\n**Setup:** Process table empty\n\n**Steps:**\n1. Create process\n2. Verify PID assigned\n3. Verify state is READY\n4. Verify stack allocated\n5. Verify CPU state initialized\n\n**Expected:** Process valid and ready\n\n```c\nprocess_t *p = process_create(test_func, \"test\");\nassert(p != NULL);\nassert(p->pid > 0);\nassert(p->state == PROCESS_STATE_READY);\nassert(p->kernel_stack != 0);\nassert(p->kernel_stack_top == p->kernel_stack + KERNEL_STACK_SIZE);\nassert(p->cpu.eip == (uint32_t)test_func);\nassert(p->cpu.cs == 0x08);\nassert(p->cpu.eflags & 0x200);  // IF set\n```\n\n---\n\n### Test: Context Switch Preserves State\n\n**Setup:** Two processes created\n\n**Steps:**\n1. Set register values in process A\n2. Switch to process B\n3. Switch back to process A\n4. Verify registers preserved\n\n**Expected:** All registers match\n\n```c\nprocess_t *pa = process_create(func_a, \"a\");\nprocess_t *pb = process_create(func_b, \"b\");\n\n// Set some state in pa\npa->cpu.eax = 0x12345678;\npa->cpu.ebx = 0xDEADBEEF;\n\ncurrent_process = pa;\ncontext_switch(pa, pb);\n\n// ... in pb ...\n\ncontext_switch(pb, pa);\n\n// Back in pa, verify state\nassert(pa->cpu.eax == 0x12345678);\nassert(pa->cpu.ebx == 0xDEADBEEF);\n```\n\n---\n\n### Test: TSS ESP0 Updated\n\n**Setup:** TSS initialized\n\n**Steps:**\n1. Get current ESP0\n2. Switch to process with different kernel stack\n3. Verify ESP0 changed\n\n**Expected:** ESP0 matches new process\n\n```c\nuint32_t old_esp0 = kernel_tss.esp0;\n\nprocess_t *p1 = process_create(func1, \"p1\");\nprocess_t *p2 = process_create(func2, \"p2\");\n\ncurrent_process = p1;\ncontext_switch(NULL, p1);\nassert(kernel_tss.esp0 == p1->kernel_stack_top);\n\ncontext_switch(p1, p2);\nassert(kernel_tss.esp0 == p2->kernel_stack_top);\nassert(kernel_tss.esp0 != old_esp0);\n```\n\n---\n\n### Test: Round-Robin Scheduling\n\n**Setup:** Three processes in ready queue\n\n**Steps:**\n1. Pick next process\n2. Verify it's different from current\n3. Repeat, verify round-robin order\n\n**Expected:** Processes scheduled in order\n\n```c\nprocess_t *p1 = process_create(f1, \"p1\");\nprocess_t *p2 = process_create(f2, \"p2\");\nprocess_t *p3 = process_create(f3, \"p3\");\n\ncurrent_process = p1;\np1->state = PROCESS_STATE_RUNNING;\n\nprocess_t *next = scheduler_pick_next();\nassert(next == p2);\n\ncurrent_process = p2;\nnext = scheduler_pick_next();\nassert(next == p3);\n\ncurrent_process = p3;\nnext = scheduler_pick_next();\nassert(next == p1);  // Wraps around\n```\n\n---\n\n### Test: Timer Triggers Context Switch\n\n**Setup:** Two processes, timer enabled\n\n**Steps:**\n1. Start in process A\n2. Enable timer interrupt\n3. Wait for multiple ticks\n4. Verify process B runs\n\n**Expected:** Both processes execute\n\n```c\nvolatile int a_ran = 0, b_ran = 0;\n\nvoid proc_a(void) {\n    a_ran = 1;\n    while (1) { }\n}\n\nvoid proc_b(void) {\n    b_ran = 1;\n    while (1) { }\n}\n\nprocess_create(proc_a, \"a\");\nprocess_create(proc_b, \"b\");\n__asm__ volatile (\"sti\");\n\nfor (volatile int i = 0; i < 10000000; i++);\n\nassert(a_ran && b_ran);\n```\n\n---\n\n### Test: User Mode Isolation\n\n**Setup:** User process with own page directory\n\n**Steps:**\n1. Create user process\n2. Switch to its page directory\n3. Try to access kernel memory\n4. Verify page fault\n\n**Expected:** Page fault on kernel access\n\n```c\n// In user process:\nuint32_t *kernel_ptr = (uint32_t *)0xC0100000;\n*kernel_ptr = 42;  // Should page fault\n// User bit not set on kernel pages\n```\n\n---\n\n### Test: System Call from User Mode\n\n**Setup:** User process, syscalls registered\n\n**Steps:**\n1. Execute INT 0x80 from user mode\n2. Verify handler called\n3. Verify return value correct\n\n**Expected:** Syscall executes and returns\n\n```c\n// In user process:\nint pid;\n__asm__ volatile (\n    \"int $0x80\"\n    : \"=a\"(pid)\n    : \"a\"(SYS_GETPID)\n);\nassert(pid > 0);\n```\n\n---\n\n### Test: Multi-Process Concurrent Execution\n\n**Setup:** Three kernel processes\n\n**Steps:**\n1. Create three processes\n2. Each increments a counter\n3. Let them run for some time\n4. Verify all counters increased\n\n**Expected:** All processes executed\n\n```c\nvolatile int counters[3] = {0, 0, 0};\n\nvoid proc0(void) { while (1) counters[0]++; }\nvoid proc1(void) { while (1) counters[1]++; }\nvoid proc2(void) { while (1) counters[2]++; }\n\nprocess_create(proc0, \"p0\");\nprocess_create(proc1, \"p1\");\nprocess_create(proc2, \"p2\");\n__asm__ volatile (\"sti\");\n\nfor (volatile int i = 0; i < 10000000; i++);\n\nassert(counters[0] > 0);\nassert(counters[1] > 0);\nassert(counters[2] > 0);\n```\n\n---\n\n## Performance Targets\n\n| Operation | Target | How to Measure |\n|-----------|--------|----------------|\n| Context switch | < 5 µs | RDTSC before/after context_switch() |\n| Scheduler decision | < 1 µs | RDTSC before/after scheduler_pick_next() |\n| Syscall entry | < 2 µs | RDTSC before INT 0x80 to handler entry |\n| User mode entry | < 3 µs | RDTSC before jump_to_user_mode to user code |\n| Timer handler (with scheduling) | < 10 µs | RDTSC at timer entry/exit |\n| CR3 reload + TLB flush | ~100-500 cycles | Part of context switch |\n\n**Measurement Code:**\n\n```c\nstatic inline uint64_t rdtsc(void) {\n    uint32_t lo, hi;\n    __asm__ volatile (\"rdtsc\" : \"=a\"(lo), \"=d\"(hi));\n    return ((uint64_t)hi << 32) | lo;\n}\n\nvoid benchmark_context_switch(void) {\n    process_t *p1 = process_create(idle_func, \"p1\");\n    process_t *p2 = process_create(idle_func, \"p2\");\n    \n    uint64_t start = rdtsc();\n    context_switch(p1, p2);\n    uint64_t end = rdtsc();\n    \n    kprintf(\"Context switch: %d cycles\\n\", (int)(end - start));\n}\n```\n\n---\n\n## Hardware Soul\n\n### Cache Behavior\n\n| Structure | Size | Cache Lines | Access Pattern |\n|-----------|------|-------------|----------------|\n| PCB (cpu_state_t) | 60 bytes | 1 | Sequential save/restore |\n| Process table | ~1.6KB | 25 | Linear scan for free slot |\n| TSS | 104 bytes | 2 | Read-only after init (except ESP0) |\n| Ready queue | 4 bytes per link | 1 | Linear traversal |\n\n**Optimization Notes:**\n- PCB fits in single cache line - optimal for context switch\n- Process table scan is prefetch-friendly\n- TSS ESP0 update touches only 4 bytes\n\n### Branch Prediction\n\n| Code Path | Predictability | Impact |\n|-----------|----------------|--------|\n| Context switch register save | High (sequential stores) | Minimal |\n| Scheduler queue traversal | Medium (depends on queue length) | Low overhead |\n| Syscall dispatch (switch) | Low (depends on syscall number) | Table lookup is fast |\n| Process state check | Medium (usually READY) | Minimal |\n\n### TLB Behavior\n\n**CRITICAL:** CR3 reload on context switch flushes all non-global TLB entries.\n\n| Scenario | TLB Entries Lost | Performance Impact |\n|----------|------------------|-------------------|\n| Same process (no CR3 reload) | 0 | Minimal |\n| Different process, shared kernel | User entries only | Moderate |\n| Different process, different kernel | All entries | High (~300 cycles) |\n\n**Optimization Strategy:**\n- Mark kernel pages as global (PAGE_GLOBAL flag)\n- Use `invlpg` for single-page invalidation when possible\n- Consider 4MB pages for kernel to reduce TLB pressure\n\n### SIMD Considerations\n\nContext switch does NOT save FPU/SSE/AVX state. If kernel or processes use SIMD:\n\n```c\n// Lazy FPU save/restore (future optimization)\n#define CR0_MP (1 << 1)\n#define CR0_TS (1 << 3)\n\nvoid enable_fpu_lazy_save(void) {\n    uint32_t cr0;\n    __asm__ volatile (\"mov %%cr0, %0\" : \"=r\"(cr0));\n    cr0 |= CR0_MP | CR0_TS;\n    __asm__ volatile (\"mov %0, %%cr0\" : : \"r\"(cr0));\n}\n\n// Device-not-available handler (exception 7)\nvoid fpu_switch_handler(registers_t *regs) {\n    // Save old FPU state\n    if (last_fpu_process) {\n        __asm__ volatile (\"fnsave %0\" : \"=m\"(last_fpu_process->fpu_state));\n    }\n    // Restore new FPU state\n    __asm__ volatile (\"frstor %0\" : : \"m\"(current_process->fpu_state));\n    \n    // Clear TS bit\n    uint32_t cr0;\n    __asm__ volatile (\"mov %%cr0, %0 ; clts\" : \"=r\"(cr0));\n}\n```\n\n### Memory Access Patterns\n\n| Operation | Pattern | Cache Friendliness |\n|-----------|---------|-------------------|\n| PCB save | Sequential write | Excellent |\n| PCB restore | Sequential read | Excellent |\n| Ready queue walk | Pointer chase | Poor (but short) |\n| Syscall dispatch | Random (table index) | Good (small table) |\n| User stack access | Process-specific | Depends on working set |\n\n---\n\n## Visual Diagrams\n\n\n![Process Control Block: Saved State Layout](./diagrams/tdd-diag-027.svg)\n\nPCB structure with cpu_state_t fields and offsets\n\n\n![Context Switch: Save Old → Load New](./diagrams/tdd-diag-028.svg)\n\nContext switch flow: save old → load new → resume\n\n\n![TSS Structure and ESP0 for Ring Transitions](./diagrams/tdd-diag-029.svg)\n\nTSS structure and ESP0 role in ring transitions\n\n\n![Round-Robin Scheduler Ready Queue](./diagrams/tdd-diag-030.svg)\n\nRound-robin scheduler: circular queue traversal\n\n\n![Timer Interrupt to Context Switch Sequence](./diagrams/tdd-diag-031.svg)\n\nTimer interrupt → scheduler → context switch sequence\n\n\n![User vs Kernel Page Directories](./diagrams/tdd-diag-032.svg)\n\nUser vs kernel page directories: isolation boundaries\n\n\n![Jump to User Mode: Stack Setup for iret](./diagrams/tdd-diag-033.svg)\n\niret stack frame for user mode entry\n\n\n![System Call: INT 0x80 Entry and Exit](./diagrams/tdd-diag-034.svg)\n\nINT 0x80 syscall flow: user → kernel → user\n\n\n![Multi-Process Demo: Three Concurrent Processes](./diagrams/tdd-diag-035.svg)\n\nProcess lifecycle state machine\n\n\n![Process Management Module Architecture](./diagrams/tdd-diag-036.svg)\n\nMulti-process demo: three processes printing concurrently\n\n---\n\n[[CRITERIA_JSON: {\"module_id\": \"build-os-m4\", \"criteria\": [\"Process control block (PCB) stores PID, register state (EIP, ESP, EBP, general-purpose registers, EFLAGS), page directory pointer (CR3), process state (ready/running/blocked), and kernel stack pointer\", \"Context switch saves current process registers to its PCB and loads the next process's registers using assembly implementation for correctness\", \"TSS (Task State Segment) configured with kernel stack pointer (SS0:ESP0) so CPU knows which stack to use for ring 3 to ring 0 transitions\", \"Timer interrupt (IRQ0) triggers scheduler which selects next ready process in round-robin order and performs context switch\", \"At least 3 kernel-mode processes run concurrently each printing to different screen region demonstrating preemptive multitasking\", \"User-mode processes run in ring 3 with own page directory; accessing kernel memory triggers page fault due to supervisor-only bit\", \"System call interface via INT 0x80: kernel reads syscall number from EAX and arguments from EBX/ECX/EDX, implementing sys_write and sys_exit at minimum\", \"TSS ESP0 updated on every context switch to point to current process kernel stack top\"]}]\n<!-- END_TDD_MOD -->\n\n\n# 📚 Beyond the Atlas: Further Reading\n\n## Bootloader and Protected Mode\n\n### Paper\n**\"The Undocumented PC\"** (Frank van Gilluwe, 1994) — Original research on BIOS internals, A20 gate mechanics, and x86 real-to-protected mode transitions.\n\n### Code\n**Linux 0.01 Bootloader** — `boot/setup.S` and `boot/bootsect.S` in the original Linux 0.01 release. Linus Torvalds' first bootloader implementation, showing the exact A20 enable and GDT setup sequence. Available at https://github.com/mirrors/linux-0.01\n\n### Best Explanation\n**OSDev Wiki: \"A20 Line\"** — https://wiki.osdev.org/A20_Line — The definitive practical guide with working code for all three A20 enable methods (fast A20, keyboard controller, BIOS).\n\n### Why\nOSDev combines historical context (why the A20 gate exists) with working code snippets tested across emulators and real hardware.\n\n---\n\n## x86 Segmentation and GDT\n\n### Spec\n**Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A** — Chapter 3 \"Protected-Mode Memory Management\" — Official specification of segment descriptors, GDT layout, and the flat memory model.\n\n### Code\n**xv6 GDT Setup** — `xv6-public/bootmain.c` and `mp.c` — MIT's teaching OS shows minimal GDT configuration with exactly 5 entries. https://github.com/mit-pdos/xv6-public\n\n### Best Explanation\n**\"GDT Tutorial\" by BrokenThorn** — https://wiki.osdev.org/Global_Descriptor_Table — Byte-by-byte breakdown of each GDT entry field with worked examples.\n\n### Why\nBreaks down the legacy x86 descriptor format into digestible pieces with visual diagrams showing bit positions.\n\n---\n\n## Interrupts and IDT\n\n### Spec\n**Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A** — Chapter 6 \"Interrupt and Exception Handling\" — Official specification of IDT gate descriptors, interrupt stack frames, and exception error codes.\n\n### Code\n**xv6 Interrupt Handling** — `xv6-public/trapasm.S` and `trap.c` — Clean implementation of the assembly stub → C handler pattern with proper register save/restore. https://github.com/mit-pdos/xv6-public\n\n### Best Explanation\n**\"Interrupts\" chapter in \"Operating Systems: Three Easy Pieces\"** (Remzi Arpaci-Dusseau and Andrea Arpaci-Dusseau) — Free at https://pages.cs.wisc.edu/~remzi/OSTEP/ — Chapter 6 explains the conceptual model before diving into x86 specifics.\n\n### Why\nBuilds intuition about *why* interrupts exist (hardware asynchrony) before the *how* (IDT gates, stack frames).\n\n---\n\n## 8259 PIC Programming\n\n### Spec\n**8259A Programmable Interrupt Controller Datasheet** — Original Intel datasheet specifying ICW1-4 initialization sequence and EOI commands.\n\n### Code\n**Linux 0.01 PIC Remapping** — `kernel/irq.c` in Linux 0.01 — Shows the exact ICW sequence used in a real OS. https://github.com/mirrors/linux-0.01\n\n### Best Explanation\n**OSDev Wiki: \"8259 PIC\"** — https://wiki.osdev.org/8259_PIC — Complete initialization sequence with code for remapping IRQs to vectors 32-47.\n\n### Why\nThe PIC datasheet is dense; OSDev extracts just the initialization sequence needed for modern OS development.\n\n---\n\n## Physical Memory Management\n\n### Code\n**Linux 2.4 Buddy Allocator** — `mm/page_alloc.c` — The classic buddy system implementation for physical page allocation. See `__alloc_pages()` function. https://elixir.bootlin.com/linux/v2.4.0/source/mm/page_alloc.c\n\n### Best Explanation\n**\"The Slab Allocator\" by Bonwick (USENIX 1994)** — While focused on the slab allocator, Section 2 explains the buddy system it builds upon. https://www.usenix.org/legacy/publications/library/proceedings/bos94/full_papers/bonwick.a\n\n### Why\nJeff Bonwick's paper is the clearest explanation of why simple bitmap allocators don't scale and how kernel memory allocators evolved.\n\n---\n\n## Virtual Memory and Page Tables\n\n### Paper\n**\"Organization of Intel Memory Management Units\"** (Intel, 1990) — Original documentation of the two-level page table hierarchy introduced with the 80386.\n\n### Spec\n**Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A** — Chapter 4 \"Paging\" — Official specification of PDE/PTE formats, CR3, and TLB behavior.\n\n### Code\n**xv6 Page Table Management** — `xv6-public/vm.c` — Clean implementation of page directory creation, page mapping, and address translation. https://github.com/mit-pdos/xv6-public\n\n### Best Explanation\n**Chapter 3 \"Address Translation\" in \"Computer Systems: A Programmer's Perspective\" (Bryant & O'Hallaron)** — Section 3.6 builds page tables from first principles with visual diagrams of the translation process.\n\n### Why\nCSAPP builds intuition with simplified examples before showing the full x86 complexity.\n\n---\n\n## TLB Management\n\n### Spec\n**Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A** — Section 4.10 \"Translation Lookaside Buffers (TLBs)\" — Official specification of `invlpg`, CR3 reload behavior, and global pages.\n\n### Best Explanation\n**\"What Every Programmer Should Know About Memory\" by Ulrich Drepper** — Section 4.3 covers TLB structure, miss penalties, and the impact of TLB flushes on context switches. https://people.freebsd.org/~lstewart/articles/cpumemory.pdf\n\n### Why\nDrepper's paper connects hardware TLB behavior to real performance consequences with benchmarks.\n\n---\n\n## Page Faults and Demand Paging\n\n### Paper\n**\"The Design and Implementation of a Paging System with Normalized Physical Addressing\"** (Dennis, 1965) — Original research on virtual memory and demand paging.\n\n### Code\n**Linux 4.x Page Fault Handler** — `arch/x86/mm/fault.c` — `do_page_fault()` function shows production-grade handling including demand paging, COW, and stack expansion. https://elixir.bootlin.com/linux/v4.0/source/arch/x86/mm/fault.c\n\n### Best Explanation\n**\"Page Replacement Algorithms\" chapter in \"Operating Systems: Three Easy Pieces\"** — https://pages.cs.wisc.edu/~remzi/OSTEP/vm-beyondphys.pdf — Builds intuition for why page faults enable virtual memory abstraction.\n\n### Why\nOSTEP explains the *concept* of demand paging before Linux source shows the *implementation*.\n\n---\n\n## Kernel Heap Allocation\n\n### Paper\n**\"Design and Implementation of a Kernel Memory Allocator\"** (Mckusick & Karels, 1988) — Original research on the Berkeley Software Distribution kernel memory allocator.\n\n### Code\n**Linux 2.x kmalloc** — `mm/slab.c` — The slab allocator implementation backing `kmalloc()`. https://elixir.bootlin.com/linux/v2.4.0/source/mm/slab.c\n\n### Best Explanation\n**\"The Slab Allocator: An Object-Caching Kernel Memory Allocator\" by Bonwick (USENIX 1994)** — https://www.usenix.org/legacy/publications/library/proceedings/bos94/full_papers/bonwick.a\n\n### Why\nBonwick explains the transition from simple first-fit allocators to object-caching allocators with clear performance analysis.\n\n---\n\n## Process Control and Context Switching\n\n### Paper\n**\"Process Structuring in the THE Multiprogramming System\"** (Dijkstra, 1968) — Original research establishing the process concept and semaphores for synchronization.\n\n### Code\n**xv6 Context Switch** — `xv6-public/swtch.S` — Minimal assembly context switch (30 lines) showing register save/restore pattern. https://github.com/mit-pdos/xv6-public\n\n### Best Explanation\n**\"Processes\" chapter in \"Operating Systems: Three Easy Pieces\"** — https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf — Chapter 4 builds the mental model of process as \"a abstraction for a running program.\"\n\n### Why\nOSTEP separates the *concept* (process abstraction) from the *mechanics* (register save/restore), which xv6 code demonstrates.\n\n---\n\n## Task State Segment\n\n### Spec\n**Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A** — Chapter 7 \"Task Management\" — Official specification of TSS structure, TR register, and privilege level transitions.\n\n### Code\n**Linux 0.01 TSS Setup** — `kernel/sched.c` — Shows TSS initialization and ESP0 update on context switch. https://github.com/mirrors/linux-0.01\n\n### Best Explanation\n**OSDev Wiki: \"Task State Segment\"** — https://wiki.osdev.org/Task_State_Segment — Explains why modern OSes use TSS only for ESP0 despite its name suggesting full task switching.\n\n### Why\nClarifies the confusing historical baggage: TSS was designed for hardware task switching, but modern OSes only use ESP0 for ring transitions.\n\n---\n\n## Round-Robin Scheduling\n\n### Paper\n**\"Scheduling Algorithms for Multiprogramming in a Hard-Real-Time Environment\"** (Liu & Layland, 1973) — Original research on scheduling theory, including round-robin analysis.\n\n### Code\n**Linux 2.4 O(1) Scheduler** — `kernel/sched.c` — Production scheduler showing priority arrays, time slices, and context switch integration. https://elixir.bootlin.com/linux/v2.4.0/source/kernel/sched.c\n\n### Best Explanation\n**\"Scheduling: Introduction\" chapter in \"Operating Systems: Three Easy Pieces\"** — https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched.pdf — Chapter 7 builds scheduling metrics (turnaround, response) then evaluates round-robin.\n\n### Why\nOSTEP explains *why* round-robin optimizes for response time, not just *how* to implement a circular queue.\n\n---\n\n## User-Kernel Mode Transitions\n\n### Spec\n**Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A** — Section 5.8 \"Privilege Levels\" and Section 5.12 \"Procedure Calls and Privilege Checking\" — Official specification of CPL, DPL, gate descriptors, and `iret` semantics.\n\n### Code\n**xv6 User Mode Entry** — `xv6-public/userinit()` in `proc.c` and the `trapret` label in `trapasm.S` — Shows stack setup for `iret` to user mode. https://github.com/mit-pdos/xv6-public\n\n### Best Explanation\n**\"Privilege Rings\" on OSDev Wiki** — https://wiki.osdev.org/Security#Rings — Explains ring 0/3 transitions with focus on the stack switch performed by CPU.\n\n### Why\nConnects hardware privilege levels to software security model (kernel vs user space).\n\n---\n\n## System Calls\n\n### Paper\n**\"On the Design of Specialized Processors\"** (Dijkstra, 1968) — Early work establishing the concept of controlled entry points between privilege domains.\n\n### Code\n**Linux 0.01 Syscall Handler** — `kernel/sys.c` and `sys_call` in `sys.h` — Shows INT 0x80 dispatch and register convention. https://github.com/mirrors/linux-0.01\n\n### Best Explanation\n**\"Systems Calls\" chapter in \"Operating Systems: Three Easy Pieces\"** — https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-mechanisms.pdf — Chapter 6 explains user/kernel transitions before x86 specifics.\n\n### Why\nOSTEP establishes the abstraction (protected control transfer) before the implementation (INT instruction, IDT gate).\n\n---\n\n## Process Isolation via Page Tables\n\n### Paper\n**\"Multics Virtual Memory\"** (Organick, 1972) — Original research on per-process address spaces and memory isolation.\n\n### Code\n**Linux 4.x `mm/mmap.c`** — `mmap_region()` function shows how the kernel isolates process address spaces during memory mapping. https://elixir.bootlin.com/linux/v4.0/source/mm/mmap.c\n\n### Best Explanation\n**\"Address Spaces\" chapter in \"Operating Systems: Three Easy Pieces\"** — https://pages.cs.wisc.edu/~remzi/OSTEP/vm-addressspaces.pdf — Chapter 13 explains the goal (isolation) before the mechanism (per-process page tables).\n\n### Why\nMakes clear why each process needs its own page directory (CR3), which is the key insight for understanding context switch cost.\n\n---\n\n## Additional Resources\n\n### Comprehensive OS Development\n- **OSDev Wiki** (https://wiki.osdev.org) — Community-maintained encyclopedia of OS development with code examples\n- **\"Operating Systems: From 0 to 1\" by Doxys** (https://tuhdo.github.io/os01/) — Free online book building a minimal OS\n\n### x86 Architecture Reference\n- **Intel SDM** (https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html) — Official x86 architecture documentation\n- **AMD APM** (https://developer.amd.com/resources/developer-guides-manuals/) — AMD's equivalent documentation with alternative explanations\n\n### Teaching Operating Systems\n- **xv6** (https://github.com/mit-pdos/xv6-public) — MIT's teaching Unix clone for x86, ~6,000 lines\n- **Pintos** (https://web.stanford.edu/class/cs140/projects/pintos/pintos.html) — Stanford's teaching OS with structured projects"}