{"html":"<h1 id=\"build-your-own-os\">Build Your Own OS</h1>\n<p>This project guides you through building a complete x86 operating system kernel from the first BIOS instruction to a preemptively multitasking system with user-mode processes. You will implement the critical path that every operating system must navigate: bootstrapping from firmware, configuring CPU data structures (GDT, IDT, TSS), managing physical and virtual memory, and implementing preemptive scheduling with privilege-level transitions.</p>\n<p>The x86 architecture presents unique challenges—the transition from 16-bit real mode to 32-bit protected mode requires precise configuration of segmentation, paging, and interrupt handling. Every decision negotiates with hardware constraints: the 4KB page granularity, the 256 interrupt vectors, the privilege ring hierarchy, and the cache line boundaries that affect context switch performance.</p>\n<p>By the end, you will understand not just how an OS works, but why it works that way—the physical and architectural forces that shaped these designs. This knowledge transfers directly to understanding container isolation, virtual machine introspection, real-time scheduling, and low-level security exploits.</p>\n<!-- MS_ID: build-os-m1 -->\n<h1 id=\"milestone-1-bootloader-gdt-and-kernel-entry\">Milestone 1: Bootloader, GDT, and Kernel Entry</h1>\n<h2 id=\"the-tension-hardware-doesn39t-want-to-run-your-code\">The Tension: Hardware Doesn&#39;t Want to Run Your Code</h2>\n<p>When you press the power button, your 3GHz CPU with billions of transistors wakes up in a shockingly primitive state:</p>\n<ul>\n<li><strong>16-bit mode</strong> — only 64KB addressable per segment, 1MB total</li>\n<li><strong>Real mode segmentation</strong> — addresses computed as <code>segment * 16 + offset</code></li>\n<li><strong>No memory protection</strong> — any code can overwrite anything</li>\n<li><strong>BIOS in control</strong> — interrupt vectors point to 16-bit BIOS routines</li>\n</ul>\n<p>Your kernel is 32-bit code expecting flat memory, protected segments, and C runtime conventions. The gap between these two worlds is not bridged by magic — you must build every plank of that bridge yourself.</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-boot-sequence.svg\" alt=\"x86 Boot Sequence: BIOS to C Entry\"></p>\n<p>The numbers make this concrete:</p>\n<ul>\n<li>BIOS loads exactly <strong>512 bytes</strong> from the disk&#39;s first sector — that&#39;s your entire stage 1 bootloader</li>\n<li>The A20 line, disabled for IBM PC/XT compatibility, blocks addresses above 1MB — your kernel at 0x100000 is unreachable until you enable it</li>\n<li>Entering protected mode without flushing the pipeline leaves the CPU decoding 16-bit instructions as 32-bit — instant crash</li>\n</ul>\n<p>This milestone is about building the bootstrap sequence that transforms a 16-bit relic into a 32-bit modern CPU, then handing control to C code you wrote.</p>\n<hr>\n<h2 id=\"system-map-where-we-are\">System Map: Where We Are</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>┌─────────────────────────────────────────────────────────────────┐\n│                         YOUR OS KERNEL                          │\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐              │\n│  │  Bootloader │→ │     GDT     │→ │  C Kernel   │              │\n│  │  (16-bit)   │  │ (Segments)  │  │  (32-bit)   │              │\n│  └─────────────┘  └─────────────┘  └─────────────┘              │\n│         ↓                ↓                ↓                     │\n│  ┌─────────────────────────────────────────────────────────────┐│\n│  │                    HARDWARE STATE                           ││\n│  │  Real Mode → Protected Mode → Paging (later)               ││\n│  │  CR0.PE=0  → CR0.PE=1      → CR0.PG=1                      ││\n│  └─────────────────────────────────────────────────────────────┘│\n└─────────────────────────────────────────────────────────────────┘</code></pre></div>\n\n<p>We&#39;re building the left side: bootloader, GDT, and the protected mode transition. Without this, nothing else exists.</p>\n<hr>\n<h2 id=\"the-boot-process-from-power-on-to-your-first-instruction\">The Boot Process: From Power-On to Your First Instruction</h2>\n<h3 id=\"what-the-bios-does-so-you-don39t-have-to\">What the BIOS Does (So You Don&#39;t Have To)</h3>\n<p>The BIOS (Basic Input/Output System) — or its modern successor UEFI — performs essential hardware initialization:</p>\n<ol>\n<li><strong>POST</strong> (Power-On Self-Test) — verifies RAM, CPU, and critical hardware</li>\n<li><strong>Hardware enumeration</strong> — discovers disks, keyboards, display adapters</li>\n<li><strong>Boot device selection</strong> — checks configured boot order</li>\n<li><strong>MBR load</strong> — reads sector 0 (first 512 bytes) from the boot disk into memory at <strong>0x7C00</strong></li>\n<li><strong>Jump to 0x7C00</strong> — transfers control to your bootloader with <code>CS:IP = 0x0000:0x7C00</code></li>\n</ol>\n<p>The magic address 0x7C00 isn&#39;t arbitrary — it&#39;s in the original IBM PC memory map, placed low enough to be addressable in real mode but high enough to not conflict with BIOS data structures.</p>\n<h3 id=\"your-bootloader39s-job\">Your Bootloader&#39;s Job</h3>\n<p>512 bytes. That&#39;s all you get for stage 1. In that space, you must:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; boot.asm - Stage 1 Bootloader (must fit in 512 bytes)\n[BITS 16]\n[ORG 0x7C00]\n\nstart:\n    ; Set up segments for real mode\n    xor ax, ax\n    mov ds, ax\n    mov es, ax\n    mov ss, ax\n    mov sp, 0x7C00          ; Stack grows down from bootloader\n\n    ; Enable A20 line (access memory above 1MB)\n    call enable_a20\n\n    ; Load stage 2 bootloader from disk\n    call load_stage2\n\n    ; Set up GDT\n    lgdt [gdt_descriptor]\n\n    ; Enter protected mode\n    mov eax, cr0\n    or eax, 1               ; Set PE bit (Protection Enable)\n    mov cr0, eax\n\n    ; Far jump to flush pipeline and load new CS\n    jmp 0x08:protected_mode_entry\n\n    ; ... GDT and helper functions follow ...\n\ntimes 510-($-$$) db 0       ; Pad to 510 bytes\ndw 0xAA55                   ; Boot signature (BIOS requires this)</code></pre></div>\n\n<p>The boot signature <code>0xAA55</code> is the final checksum — the BIOS scans the last two bytes of sector 0 and only executes the code if it finds this signature. Without it, the BIOS moves to the next boot device.</p>\n<h3 id=\"the-a20-line-a-historical-anomaly-you-must-handle\">The A20 Line: A Historical Anomaly You Must Handle</h3>\n<p>The A20 line is a quirk of PC history. The original 8086 had 20 address lines (A0-A19), addressing 1MB. Memory wrapped around — address 0x100000 (1MB + 0) accessed the same physical memory as 0x00000.</p>\n<p>IBM designed the PC/AT (286) with 24 address lines, but to maintain compatibility with 8086 software that relied on wraparound, they added a gate to disable A20. By default, <strong>A20 is disabled</strong>, meaning you cannot access memory above 1MB.</p>\n<p>Your kernel loads at 0x100000 — unreachable until you enable A20:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>enable_a20:\n    ; Method 1: Fast A20 gate (port 0x92)\n    in al, 0x92\n    or al, 2\n    out 0x92, al\n    ret\n\n    ; Method 2: Keyboard controller (more reliable on old hardware)\n    ; ... involves sending commands to port 0x64/0x60 ...</code></pre></div>\n\n<p>The fast A20 gate via port 0x92 works on most modern systems and virtual machines. For maximum compatibility, production bootloaders try multiple methods.</p>\n<hr>\n<h2 id=\"segmentation-the-gdt-and-why-x86-still-has-it\">Segmentation: The GDT and Why x86 Still Has It</h2>\n<h3 id=\"the-tension-why-segmentation-exists\">The Tension: Why Segmentation Exists</h3>\n<p>You might wonder: why configure segments at all? Why not just use flat memory?</p>\n<p>The answer lies in x86 history. The 8086 (1978) was a 16-bit processor needing to address more than 64KB. <strong>Segmentation</strong> was the solution: addresses are computed as <code>segment * 16 + offset</code>, giving 20-bit addresses (1MB).</p>\n<p>Protected mode (386, 1985) extended this with <strong>segment descriptors</strong> — rich metadata about each segment:</p>\n<ul>\n<li>Base address (32-bit) — where the segment starts</li>\n<li>Limit (20-bit) — how large the segment is</li>\n<li>Access rights — readable? writable? executable?</li>\n<li>Privilege level — ring 0 (kernel) or ring 3 (user)</li>\n<li>Granularity — limit in bytes or 4KB pages</li>\n</ul>\n<p>The <strong>Global Descriptor Table (GDT)</strong> is an array of these descriptors. The GDTR register holds the table&#39;s base address and limit. Every memory access uses a segment selector (index into GDT) combined with an offset.</p>\n<p>{{DIAGRAM:diag-gdt-structure}}</p>\n<h3 id=\"the-flat-memory-model-your-goal\">The Flat Memory Model: Your Goal</h3>\n<p>For a modern OS, you want <strong>flat segmentation</strong> — segments with base=0, limit=4GB. This makes segmentation transparent; logical addresses equal linear addresses. Paging (which you&#39;ll add in Milestone 3) handles the real memory protection and isolation.</p>\n<p>Your GDT needs five entries:</p>\n<table>\n<thead>\n<tr>\n<th>Index</th>\n<th>Type</th>\n<th>Base</th>\n<th>Limit</th>\n<th>Privilege</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>Null</td>\n<td>0</td>\n<td>0</td>\n<td>—</td>\n<td>Required by CPU</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Code</td>\n<td>0</td>\n<td>4GB</td>\n<td>Ring 0</td>\n<td>Kernel code</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Data</td>\n<td>0</td>\n<td>4GB</td>\n<td>Ring 0</td>\n<td>Kernel data</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Code</td>\n<td>0</td>\n<td>4GB</td>\n<td>Ring 3</td>\n<td>User code</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Data</td>\n<td>0</td>\n<td>4GB</td>\n<td>Ring 3</td>\n<td>User data</td>\n</tr>\n</tbody></table>\n<p>The null descriptor (index 0) is mandatory — the CPU uses selector 0 as a &quot;null selector&quot; for error conditions. Loading a segment register with 0 doesn&#39;t cause a fault, but using it for memory access will.</p>\n<h3 id=\"gdt-entry-structure-64-bits-of-configuration\">GDT Entry Structure: 64 Bits of Configuration</h3>\n<p>Each GDT entry is 8 bytes (64 bits), packed with specific fields:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Byte 0-1:  Limit [15:0]      (bits 0-15 of limit)\nByte 2-3:  Base [15:0]       (bits 0-15 of base)\nByte 4:    Base [23:16]      (bits 16-23 of base)\nByte 5:    Access Byte       (present, ring, type flags)\nByte 6:    Flags + Limit[19:16]\nByte 7:    Base [31:24]      (bits 24-31 of base)</code></pre></div>\n\n<p>The <strong>access byte</strong> (byte 5) controls privilege and type:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Bit 7: Present (1 = segment exists)\nBit 6-5: DPL (Descriptor Privilege Level: 00=ring 0, 11=ring 3)\nBit 4: S (System: 1=code/data, 0=system like TSS)\nBit 3: Type bit 3 (Executable: 1=code, 0=data)\nBit 2: Type bit 2 (Direction/Conforming for code, Expand-down for data)\nBit 1: Type bit 1 (Readable for code, Writable for data)\nBit 0: Accessed (CPU sets this when segment is accessed)</code></pre></div>\n\n<p>The <strong>flags byte</strong> (high 4 bits of byte 6):</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Bit 7: Granularity (0=limit in bytes, 1=limit in 4KB pages)\nBit 6: Size (0=16-bit, 1=32-bit)\nBit 5: Long (1=64-bit code segment for x86-64)\nBit 4: Reserved</code></pre></div>\n\n<p>Here&#39;s a concrete GDT setup:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>gdt_start:\n    ; Null descriptor (required)\n    dq 0x0000000000000000\n\ngdt_code_kernel:             ; Index 1: Kernel code segment\n    ; Base=0, Limit=0xFFFFF, 4KB granularity, 32-bit, ring 0, executable+readable\n    dw 0xFFFF               ; Limit [15:0]\n    dw 0x0000               ; Base [15:0]\n    db 0x00                 ; Base [23:16]\n    db 10011010b            ; Present, ring 0, code, executable, readable\n    db 11001111b            ; 4KB granularity, 32-bit, Limit [19:16]\n    db 0x00                 ; Base [31:24]\n\ngdt_data_kernel:             ; Index 2: Kernel data segment\n    ; Base=0, Limit=0xFFFFF, 4KB granularity, 32-bit, ring 0, writable\n    dw 0xFFFF\n    dw 0x0000\n    db 0x00\n    db 10010010b            ; Present, ring 0, data, writable\n    db 11001111b\n    db 0x00\n\ngdt_code_user:               ; Index 3: User code segment (ring 3)\n    dw 0xFFFF\n    dw 0x0000\n    db 0x00\n    db 11111010b            ; Present, ring 3 (DPL=11), code, executable, readable\n    db 11001111b\n    db 0x00\n\ngdt_data_user:               ; Index 4: User data segment (ring 3)\n    dw 0xFFFF\n    dw 0x0000\n    db 0x00\n    db 11110010b            ; Present, ring 3, data, writable\n    db 11001111b\n    db 0x00\n\ngdt_descriptor:\n    dw gdt_descriptor - gdt_start - 1  ; Size (limit)\n    dd gdt_start                        ; Base address</code></pre></div>\n\n<p>The segment selectors (what you load into segment registers) are computed as:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Selector = (Index &lt;&lt; 3) | (TI &lt;&lt; 2) | RPL\n\nWhere:\n  Index = position in GDT (0, 1, 2, ...)\n  TI = Table Indicator (0=GDT, 1=LDT — you'll use 0)\n  RPL = Requested Privilege Level (0 or 3)\n\nKernel code selector = (1 &lt;&lt; 3) | 0 = 0x08\nKernel data selector = (2 &lt;&lt; 3) | 0 = 0x10\nUser code selector = (3 &lt;&lt; 3) | 3 = 0x1B\nUser data selector = (4 &lt;&lt; 3) | 3 = 0x23</code></pre></div>\n\n<hr>\n<h2 id=\"the-protected-mode-transition-a-precise-sequence\">The Protected Mode Transition: A Precise Sequence</h2>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-protected-mode-transition.svg\" alt=\"Protected Mode Transition: Before and After\"></p>\n<p>Entering protected mode isn&#39;t a single instruction — it&#39;s a sequence where getting any step wrong causes a <strong>triple fault</strong> (CPU exception → handler crashes → double fault → handler crashes → triple fault → CPU reset).</p>\n<h3 id=\"step-by-step-transition\">Step-by-Step Transition</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; 1. Disable interrupts (CRITICAL — real-mode IVT is now invalid)\ncli\n\n; 2. Load the GDT\nlgdt [gdt_descriptor]\n\n; 3. Enable protected mode\nmov eax, cr0\nor eax, 1                ; Set PE (Protection Enable) bit\nmov cr0, eax\n\n; 4. Far jump to flush the pipeline and load CS with kernel code selector\njmp 0x08:protected_mode_entry\n\n[BITS 32]\nprotected_mode_entry:\n    ; 5. Now in 32-bit protected mode! Reload segment registers.\n    mov ax, 0x10         ; Kernel data selector\n    mov ds, ax\n    mov es, ax\n    mov fs, ax\n    mov gs, ax\n    mov ss, ax\n    mov esp, 0x90000     ; Set up kernel stack (below 1MB for now)\n\n    ; 6. Jump to kernel C entry point\n    jmp 0x08:0x100000    ; Kernel loaded at 1MB physical</code></pre></div>\n\n<h3 id=\"why-each-step-matters\">Why Each Step Matters</h3>\n<p><strong>Disable interrupts (<code>cli</code>)</strong>: The real-mode IVT (Interrupt Vector Table) at 0x0-0x3FF contains BIOS interrupt handlers. Once you enter protected mode, these addresses are interpreted completely differently. An interrupt before you set up the IDT (Milestone 2) will crash.</p>\n<p><strong>Load GDT (<code>lgdt</code>)</strong>: The CPU needs to know where segment descriptors live. This must happen <em>before</em> setting CR0.PE.</p>\n<p><strong>Set CR0.PE</strong>: This is the actual mode switch. But the pipeline still contains 16-bit instructions decoded as 16-bit.</p>\n<p><strong>Far jump</strong>: <code>jmp 0x08:protected_mode_entry</code> does two things:</p>\n<ol>\n<li>Loads CS with selector 0x08 (kernel code segment)</li>\n<li>Flushes the prefetch queue (pipeline), forcing fresh instruction fetch in 32-bit mode</li>\n</ol>\n<p>Without this jump, the CPU continues executing what it thinks are 16-bit instructions, but they&#39;re actually your 32-bit code — garbage execution.</p>\n<p><strong>Reload segment registers</strong>: After the far jump, CS is valid, but DS/ES/FS/GS/SS still contain real-mode values. Loading them with the kernel data selector (0x10) ensures all memory access uses your flat segments.</p>\n<hr>\n<h2 id=\"loading-the-kernel-from-disk\">Loading the Kernel from Disk</h2>\n<p>The stage 1 bootloader (512 bytes) usually loads a larger stage 2, which then loads the kernel. BIOS interrupt <strong>INT 13h</strong> provides disk access in real mode:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>load_kernel:\n    ; Reset disk system\n    xor ah, ah\n    xor dl, dl            ; dl = boot drive number (passed by BIOS)\n    int 0x13\n\n    ; Read sectors using CHS (Cylinder-Head-Sector) addressing\n    ; ah=02h (read), al=number of sectors, ch=cylinder, cl=sector, dh=head, dl=drive\n    mov ah, 0x02\n    mov al, 32            ; Read 32 sectors (16KB — adjust based on kernel size)\n    mov ch, 0             ; Cylinder 0\n    mov cl, 2             ; Start at sector 2 (sector 1 is the MBR)\n    mov dh, 0             ; Head 0\n    mov dl, [boot_drive]\n    mov bx, 0x100000      ; Destination: 1MB (es:bx = destination)\n    mov es, bx\n    xor bx, bx\n    int 0x13\n    jc disk_error         ; Carry flag set on error\n\n    ret\n\nboot_drive: db 0</code></pre></div>\n\n<p>The destination 0x100000 (1MB) is traditional — it&#39;s the first available memory above the low memory region used by BIOS and real-mode structures.</p>\n<hr>\n<h2 id=\"the-linker-script-where-code-lives-in-memory\">The Linker Script: Where Code Lives in Memory</h2>\n<p>Your C kernel doesn&#39;t know its own addresses — the linker decides where every function and variable lives. The linker script controls this.</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-linker-script.svg\" alt=\"Kernel Memory Map: Linker Script Layout\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">ld</span><pre class=\"arch-pre shiki-highlighted\"><code>/* linker.ld */\nENTRY(kernel_entry)\n\nSECTIONS\n{\n    /* Kernel starts at 1MB physical */\n    . = 0x100000;\n\n    .text : {\n        *(.multiboot)      /* Multiboot header if using GRUB */\n        *(.text)\n    }\n\n    .rodata : {\n        *(.rodata)\n    }\n\n    .data : {\n        *(.data)\n    }\n\n    .bss : {\n        __bss_start = .;\n        *(COMMON)\n        *(.bss)\n        __bss_end = .;\n    }\n\n    /DISCARD/ : {\n        *(.comment)\n        *(.eh_frame)\n    }\n}</code></pre></div>\n\n<p>The symbols <code>__bss_start</code> and <code>__bss_end</code> are crucial — they mark the range of uninitialized global/static variables that must be zeroed at startup. In a hosted C environment, the C runtime (crt0) does this. In your kernel, you do it.</p>\n<hr>\n<h2 id=\"the-c-entry-point-no-runtime-no-safety-net\">The C Entry Point: No Runtime, No Safety Net</h2>\n<p>When control reaches your C code, you have:</p>\n<ul>\n<li><strong>No zeroed BSS</strong> — uninitialized globals contain garbage</li>\n<li><strong>No initialized globals</strong> — the loader handles .data, but verify this</li>\n<li><strong>No stack setup</strong> — you set SS:ESP in assembly</li>\n<li><strong>No libc</strong> — no printf, no malloc, no memcpy</li>\n</ul>\n<p>Here&#39;s a minimal kernel entry:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* kernel_entry.asm — called from bootloader */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">[BITS </span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#E1E4E8\"> kernel_main</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">global kernel_entry</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">kernel_entry:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ; Set up </span><span style=\"color:#B392F0\">stack</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> not already </span><span style=\"color:#FFAB70\">done</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mov esp, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">90000</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ; Zero the BSS section</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    extern</span><span style=\"color:#E1E4E8\"> __bss_start</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    extern</span><span style=\"color:#E1E4E8\"> __bss_end</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mov edi, __bss_start</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mov ecx, __bss_end</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sub ecx, edi</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    xor eax, eax</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rep stosb</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ; Call kernel main</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    call kernel_main</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ; Halt </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> kernel_main returns</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">.halt:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cli</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hlt</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    jmp .halt</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* kernel_main.c */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> kernel_main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // At this point: GDT is loaded, protected mode is active,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // BSS is zeroed, stack is valid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize VGA text mode (0xB8000)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Welcome to MyOS!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize serial port for debug output</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    serial_init</span><span style=\"color:#E1E4E8\">(COM1_PORT);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    serial_puts</span><span style=\"color:#E1E4E8\">(COM1_PORT, </span><span style=\"color:#9ECBFF\">\"Kernel booted successfully.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Your OS begins here...</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">hlt</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"vga-text-mode-your-first-display-driver\">VGA Text Mode: Your First Display Driver</h2>\n<p>The VGA text buffer at <strong>0xB8000</strong> is memory-mapped I/O — writing to this address displays characters on screen. Each character is 2 bytes:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Byte 0: ASCII character\nByte 1: Attribute byte:\n  - Bits 0-3: Foreground color (0-15)\n  - Bits 4-6: Background color (0-7)\n  - Bit 7: Blink (or bright background if enabled)</code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> VGA_BUFFER</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> uint16_t*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">B8000</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> VGA_WIDTH</span><span style=\"color:#79B8FF\"> 80</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> VGA_HEIGHT</span><span style=\"color:#79B8FF\"> 25</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> vga_row </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> vga_col </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VGA_BLACK </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VGA_BLUE </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VGA_GREEN </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VGA_CYAN </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VGA_RED </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VGA_MAGENTA </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VGA_BROWN </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VGA_LIGHT_GREY </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 7</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... more colors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} vga_color;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint16_t</span><span style=\"color:#B392F0\"> vga_entry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> c</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> fg</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> bg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\">)c </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\">)(fg </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> (bg </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vga_putchar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> c</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (c </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vga_col </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vga_row</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    VGA_BUFFER</span><span style=\"color:#E1E4E8\">[vga_row </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> VGA_WIDTH </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> vga_col] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> vga_entry</span><span style=\"color:#E1E4E8\">(c, VGA_LIGHT_GREY, VGA_BLACK);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vga_col</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (vga_col </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> VGA_WIDTH) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vga_col </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vga_row</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (vga_row </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> VGA_HEIGHT) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Scroll (copy all rows up by one)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (VGA_HEIGHT </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> VGA_WIDTH; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            VGA_BUFFER</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> VGA_BUFFER</span><span style=\"color:#E1E4E8\">[i </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> VGA_WIDTH];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Clear last row</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (VGA_HEIGHT </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> VGA_WIDTH; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> VGA_HEIGHT </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> VGA_WIDTH; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            VGA_BUFFER</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> vga_entry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">' '</span><span style=\"color:#E1E4E8\">, VGA_LIGHT_GREY, VGA_BLACK);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vga_row </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> VGA_HEIGHT </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"serial-port-debug-output-your-lifeline\">Serial Port Debug Output: Your Lifeline</h2>\n<p>When the kernel crashes before VGA works, or when you need to log data that scrolls off screen, serial output is essential. COM1 is at I/O port <strong>0x3F8</strong>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> COM1_PORT</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">3F8</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> outb</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> val</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">outb %0, %1</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">a</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(val), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">Nd</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(port));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint8_t</span><span style=\"color:#B392F0\"> inb</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">inb %1, %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=a</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(ret) : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">Nd</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(port));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> serial_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(port </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">    // Disable all interrupts</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(port </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">    // Enable DLAB (set baud rate divisor)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(port </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">03</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">    // Set divisor to 3 (lo byte) 38400 baud</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(port </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">    //                  (hi byte)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(port </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">03</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">    // 8 bits, no parity, one stop bit</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(port </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">C7</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">    // Enable FIFO, clear them, with 14-byte threshold</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(port </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">0B</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">    // IRQs enabled, RTS/DSR set</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> serial_is_transmit_empty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> inb</span><span style=\"color:#E1E4E8\">(port </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> serial_putchar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> c</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">serial_is_transmit_empty</span><span style=\"color:#E1E4E8\">(port) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(port, c);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> serial_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> str</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">str) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        serial_putchar</span><span style=\"color:#E1E4E8\">(port, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">str</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>With QEMU, you can redirect serial output to a file or stdio:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -kernel</span><span style=\"color:#9ECBFF\"> myos.bin</span><span style=\"color:#79B8FF\"> -serial</span><span style=\"color:#9ECBFF\"> stdio</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Or save to file:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -kernel</span><span style=\"color:#9ECBFF\"> myos.bin</span><span style=\"color:#79B8FF\"> -serial</span><span style=\"color:#9ECBFF\"> file:debug.log</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"hardware-soul-what39s-actually-happening\">Hardware Soul: What&#39;s Actually Happening</h2>\n<p>Every step of this boot sequence has hardware implications:</p>\n<p><strong>Cache behavior</strong>: The GDT, loaded via <code>lgdt</code>, is read by the CPU into internal registers. Subsequent segment accesses don&#39;t read memory — they use the cached descriptor. Modifying the GDT requires a reload.</p>\n<p><strong>TLB state</strong>: In protected mode without paging, linear addresses = physical addresses. When you enable paging (Milestone 3), the TLB (Translation Lookaside Buffer) caches page table entries. For now, it&#39;s unused.</p>\n<p><strong>Pipeline flush</strong>: The far jump after <code>mov cr0, eax</code> forces a pipeline flush. On modern CPUs, this costs 10-30 cycles. In the boot sequence, this is negligible, but the same principle applies to every context switch.</p>\n<p><strong>Memory access patterns</strong>: The VGA text buffer at 0xB8000 is <strong>uncacheable</strong> memory-mapped I/O. Writing to it goes directly to the video controller, not through the cache hierarchy. This is why we use <code>volatile</code> — the compiler must not optimize away or reorder these writes.</p>\n<hr>\n<h2 id=\"debugging-your-bootloader-when-nothing-works\">Debugging Your Bootloader: When Nothing Works</h2>\n<p>Bootloader bugs are brutal — you often get no output, just a black screen or reset. Here&#39;s your debugging toolkit:</p>\n<h3 id=\"qemu-with-gdb\">QEMU with GDB</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Terminal 1: Start QEMU with GDB stub</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -kernel</span><span style=\"color:#9ECBFF\"> myos.bin</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#79B8FF\"> -S</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Terminal 2: Connect GDB</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gdb</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">gdb</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">target</span><span style=\"color:#9ECBFF\"> remote</span><span style=\"color:#9ECBFF\"> :1234</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">gdb</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">break</span><span style=\"color:#79B8FF\"> *</span><span style=\"color:#9ECBFF\">0x7C00</span><span style=\"color:#6A737D\">        # Break at bootloader entry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">gdb</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">continue</span></span></code></pre></div>\n\n<h3 id=\"serial-output\">Serial Output</h3>\n<p>Before VGA works, serial is your only output. Initialize it early:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; In stage 1, after setting segments:\nmov dx, 0x3F8 + 1\nxor al, al\nout dx, al          ; Disable serial interrupts\n; ... minimal init ...\n\n; Debug: output 'A' to confirm we got here\nmov dx, 0x3F8\nmov al, 'A'\nout dx, al</code></pre></div>\n\n<h3 id=\"triple-fault-detection\">Triple Fault Detection</h3>\n<p>A triple fault (exception → crash → double fault → crash → triple fault → reset) means your CPU state is corrupted. Common causes:</p>\n<ul>\n<li>GDT misconfiguration (wrong base/limit/access bytes)</li>\n<li>Far jump with wrong selector</li>\n<li>Forgetting to reload segment registers after mode switch</li>\n<li>Stack corruption (SS:ESP invalid)</li>\n</ul>\n<p>Use QEMU&#39;s <code>-d int,cpu_reset</code> to log interrupts and resets.</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-triple-fault-chain.svg\" alt=\"Fault Cascade: Triple Fault Cause Chain\"></p>\n<hr>\n<h2 id=\"design-decision-one-stage-vs-two-stage-bootloader\">Design Decision: One-Stage vs Two-Stage Bootloader</h2>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Used By</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>One-Stage (512 bytes)</strong></td>\n<td>Simpler, single file</td>\n<td>Must fit everything in 510 bytes, limited kernel size</td>\n<td>Educational OSes, tiny kernels</td>\n</tr>\n<tr>\n<td><strong>Two-Stage</strong></td>\n<td>Stage 2 can be large, more features</td>\n<td>More complex loading, stage 2 must find kernel</td>\n<td>Most real bootloaders (GRUB, Linux)</td>\n</tr>\n<tr>\n<td><strong>Multiboot (GRUB)</strong></td>\n<td>GRUB handles all boot complexity</td>\n<td>Requires multiboot header, depends on GRUB</td>\n<td>Many hobby OSes, Xen</td>\n</tr>\n</tbody></table>\n<p>For learning, a simple two-stage approach is practical:</p>\n<ul>\n<li>Stage 1 (512 bytes): Enable A20, load GDT, load stage 2, enter protected mode</li>\n<li>Stage 2 (larger): Load kernel from disk (using INT 13h in real mode or your own driver in protected mode), verify, jump to kernel</li>\n</ul>\n<hr>\n<h2 id=\"building-and-running\">Building and Running</h2>\n<p>A typical build process:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Assemble bootloader</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">nasm</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> bin</span><span style=\"color:#9ECBFF\"> boot.asm</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> boot.bin</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Compile kernel (freestanding, no stdlib)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -m32</span><span style=\"color:#79B8FF\"> -ffreestanding</span><span style=\"color:#79B8FF\"> -fno-pic</span><span style=\"color:#79B8FF\"> -fno-pie</span><span style=\"color:#79B8FF\"> -nostdlib</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> kernel_main.c</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> kernel_main.o</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -m32</span><span style=\"color:#79B8FF\"> -ffreestanding</span><span style=\"color:#79B8FF\"> -fno-pic</span><span style=\"color:#79B8FF\"> -fno-pie</span><span style=\"color:#79B8FF\"> -nostdlib</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> vga.c</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> vga.o</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -m32</span><span style=\"color:#79B8FF\"> -ffreestanding</span><span style=\"color:#79B8FF\"> -fno-pic</span><span style=\"color:#79B8FF\"> -fno-pie</span><span style=\"color:#79B8FF\"> -nostdlib</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> serial.c</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> serial.o</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Link kernel</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ld</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> elf_i386</span><span style=\"color:#79B8FF\"> -T</span><span style=\"color:#9ECBFF\"> linker.ld</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> kernel.elf</span><span style=\"color:#9ECBFF\"> kernel_main.o</span><span style=\"color:#9ECBFF\"> vga.o</span><span style=\"color:#9ECBFF\"> serial.o</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Extract raw binary (for direct loading)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">objcopy</span><span style=\"color:#79B8FF\"> -O</span><span style=\"color:#9ECBFF\"> binary</span><span style=\"color:#9ECBFF\"> kernel.elf</span><span style=\"color:#9ECBFF\"> kernel.bin</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create disk image with bootloader and kernel</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dd</span><span style=\"color:#9ECBFF\"> if=/dev/zero</span><span style=\"color:#9ECBFF\"> of=os.img</span><span style=\"color:#9ECBFF\"> bs=</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#9ECBFF\"> count=</span><span style=\"color:#79B8FF\">2880</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dd</span><span style=\"color:#9ECBFF\"> if=boot.bin</span><span style=\"color:#9ECBFF\"> of=os.img</span><span style=\"color:#9ECBFF\"> bs=</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#9ECBFF\"> count=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#9ECBFF\"> conv=notrunc</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dd</span><span style=\"color:#9ECBFF\"> if=kernel.bin</span><span style=\"color:#9ECBFF\"> of=os.img</span><span style=\"color:#9ECBFF\"> bs=</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#9ECBFF\"> seek=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#9ECBFF\"> conv=notrunc</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run in QEMU</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> -serial</span><span style=\"color:#9ECBFF\"> stdio</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"knowledge-cascade\">Knowledge Cascade</h2>\n<p>You&#39;ve now built the foundation of an operating system. Here&#39;s where this knowledge connects:</p>\n<p><strong>Virtualization and Hypervisors</strong>: The GDT, IDT, and paging machinery you configure is exactly what hypervisors (VMware, KVM, Hyper-V) virtualize. A &quot;VM entry&quot; from hypervisor to guest is analogous to your protected mode transition — the hypervisor loads the guest&#39;s IDT, GDT, and CR3 before transferring control. Understanding this boot sequence is the first step to understanding VM introspection and escape exploits.</p>\n<p><strong>Linker Scripts and Memory Layout (Cross-Domain)</strong>: The <code>.text</code>, <code>.data</code>, <code>.bss</code> section concepts and LMA (Load Memory Address) vs VMA (Virtual Memory Address) distinction apply to embedded firmware, UEFI drivers, and even position-independent code in security exploits. ROP chains rely on knowing exact offsets in memory — knowledge that starts with understanding linker scripts.</p>\n<p><strong>BIOS/UEFI Exploitation</strong>: The real-mode IVT at 0x0 is still relevant — BIOS bootkits hook INT 13h to infect boot sectors. UEFI&#39;s Secure Boot targets exactly the boot path you implemented, verifying signatures before allowing code execution. Understanding the attack surface of boot requires understanding legitimate boot.</p>\n<p><strong>No-std Rust and Freestanding Environments</strong>: The absence of libc, crt0, and runtime services you experience here is exactly what embedded Rust, Linux kernel modules, and WASM runtimes handle. The <code>#![no_std]</code> attribute in Rust means &quot;I will provide my own panic handler and memory allocator&quot; — the same contract you&#39;re fulfilling in C.</p>\n<p><strong>Forward: What You Can Now Build</strong>: With a booting kernel, you can now:</p>\n<ul>\n<li>Implement an IDT and handle CPU exceptions (Milestone 2)</li>\n<li>Build a physical memory allocator and enable paging (Milestone 3)</li>\n<li>Create preemptive multitasking with context switching (Milestone 4)</li>\n</ul>\n<hr>\n<h2 id=\"summary\">Summary</h2>\n<p>You&#39;ve crossed the first great divide in OS development:</p>\n<ol>\n<li><strong>Boot process</strong>: BIOS → MBR (your bootloader at 0x7C00) → protected mode → kernel entry</li>\n<li><strong>GDT</strong>: Five descriptors (null, kernel code/data, user code/data) with flat memory model</li>\n<li><strong>Protected mode transition</strong>: <code>cli</code> → <code>lgdt</code> → set CR0.PE → far jump → reload segments</li>\n<li><strong>C environment</strong>: Zero BSS, set stack, call kernel_main — no runtime provided</li>\n<li><strong>Output drivers</strong>: VGA text mode (0xB8000) and serial port (COM1 at 0x3F8)</li>\n</ol>\n<p>The hardware constraints — 512-byte MBR, A20 line, pipeline flush requirements — shaped every decision. You negotiated with physics, and your kernel boots.</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-satellite-system.svg\" alt=\"OS Kernel Architecture: Satellite View\"></p>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-os-m2 -->\n<!-- MS_ID: build-os-m2 -->\n<h1 id=\"milestone-2-interrupts-exceptions-and-keyboard\">Milestone 2: Interrupts, Exceptions, and Keyboard</h1>\n<h2 id=\"the-tension-hardware-can39t-wait-for-you\">The Tension: Hardware Can&#39;t Wait For You</h2>\n<p>Your kernel from Milestone 1 sits in a loop, dutifully executing instructions one after another. But the real world doesn&#39;t wait:</p>\n<ul>\n<li>The user presses a key — the keyboard controller has data <em>now</em></li>\n<li>The timer chip fires — the scheduler needs to run <em>now</em></li>\n<li>Your code divides by zero — the CPU detects an error <em>now</em></li>\n<li>A page isn&#39;t in memory — the MMU needs resolution <em>now</em></li>\n</ul>\n<p><strong>Polling</strong> (checking &quot;is there input?&quot; in a loop) wastes millions of cycles. At 3GHz, checking the keyboard 1000 times per second means 3 million wasted cycles between checks — and you still might miss a keystroke if the user types faster than you poll.</p>\n<p>The solution: let hardware interrupt your code. But here&#39;s the constraint — the CPU must save exactly enough state to resume later, transfer control to your handler, and do this in <strong>microseconds</strong>. The mechanism must be:</p>\n<ol>\n<li><strong>Deterministic</strong>: Same interrupt → same handler → same stack frame</li>\n<li><strong>Fast</strong>: No searching, no dynamic dispatch — direct table lookup</li>\n<li><strong>Precise</strong>: Every register preserved, every byte accounted for</li>\n</ol>\n<p>The x86 answer is the <strong>Interrupt Descriptor Table (IDT)</strong>: 256 entries, each 8 bytes, containing the address and metadata for one handler. When interrupt N occurs, the CPU loads CS:EIP from entry N and jumps — no function calls, no callbacks, just raw hardware-driven control transfer.</p>\n<p>And here&#39;s what surprises most developers: <strong>CPU exceptions and hardware IRQs use the same mechanism</strong>. Division by zero (exception 0), keyboard input (IRQ1 via vector 33), and your own <code>int 0x80</code> syscall — all route through the IDT. The CPU doesn&#39;t distinguish &quot;software problems&quot; from &quot;hardware events&quot; at the dispatch level.</p>\n<hr>\n<h2 id=\"revelation-it39s-not-a-callback\">Revelation: It&#39;s Not a Callback</h2>\n<p><strong>What you might think</strong>: &quot;I register a handler function, and when the keyboard has data, the hardware calls it like an event handler in JavaScript.&quot;</p>\n<p><strong>What actually happens</strong>: The 8259 PIC doesn&#39;t call anything. It asserts an electrical signal on the CPU&#39;s INTR pin. The CPU:</p>\n<ol>\n<li>Finishes the current instruction</li>\n<li>Looks up the IDT entry for the interrupt vector</li>\n<li><strong>Pushes EFLAGS, CS, EIP onto the stack</strong> (and optionally an error code)</li>\n<li>Loads CS:EIP from the IDT entry</li>\n<li>Jumps to your handler</li>\n</ol>\n<p>Your handler is now running. The PIC is waiting. And here&#39;s the critical part: <strong>the PIC will not deliver another interrupt until you send EOI (End of Interrupt)</strong>. Forget this, and your system appears to &quot;freeze&quot; — the keyboard stops responding, the timer stops ticking, everything halts.</p>\n<p>This isn&#39;t magic. It&#39;s a protocol. You must:</p>\n<ol>\n<li>Save all registers (the CPU only saved EFLAGS, CS, EIP)</li>\n<li>Handle the interrupt</li>\n<li>Send EOI to the PIC</li>\n<li>Restore all registers</li>\n<li>Execute <code>iret</code> (which pops EFLAGS, CS, EIP)</li>\n</ol>\n<p>Miss any step, and you corrupt the interrupted code — or lock up the interrupt system entirely.</p>\n<p>{{DIAGRAM:diag-idt-entry}}</p>\n<hr>\n<h2 id=\"system-map-where-we-are\">System Map: Where We Are</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>┌─────────────────────────────────────────────────────────────────┐\n│                         YOUR OS KERNEL                          │\n│                                                                 │\n│  ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐         │\n│  │   IDT   │   │   PIC   │   │   PIT   │   │ Keyboard│         │\n│  │  256    │   │  8259   │   │  Timer  │   │  Driver │         │\n│  │ entries │   │ Master/ │   │ 100Hz   │   │ Scancode│         │\n│  │         │   │ Slave   │   │         │   │ →ASCII  │         │\n│  └────┬────┘   └────┬────┘   └────┬────┘   └────┬────┘         │\n│       │             │             │             │               │\n│       └─────────────┴─────────────┴─────────────┘              │\n│                           │                                     │\n│  ┌────────────────────────┴────────────────────────┐           │\n│  │                  HARDWARE                        │           │\n│  │  CPU exceptions (0-31) + IRQs (32-47)           │           │\n│  │  All vector through IDT → Your handlers          │           │\n│  └─────────────────────────────────────────────────┘           │\n└─────────────────────────────────────────────────────────────────┘</code></pre></div>\n\n<p>We&#39;re building the center column: IDT for dispatch, PIC for hardware routing, PIT for timing, and keyboard for input. These are the nervous system of your kernel.</p>\n<hr>\n<h2 id=\"the-idt-256-doors-to-your-code\">The IDT: 256 Doors to Your Code</h2>\n<h3 id=\"structure-of-an-idt-entry\">Structure of an IDT Entry</h3>\n<p>Each IDT entry is an 8-byte <strong>gate descriptor</strong>. The structure mirrors the GDT entry but with different fields:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Bytes 0-1:  Offset [15:0]      (low 16 bits of handler address)\nBytes 2-3:  Segment Selector   (code segment to run handler in)\nByte 4:     Reserved (always 0)\nByte 5:     Access Byte:\n  - Bit 7: Present (1 = valid entry)\n  - Bits 6-5: DPL (who can call via INT instruction)\n  - Bit 4: Always 0 (system segment)\n  - Bits 3-0: Gate type (1110 = interrupt gate, 1111 = trap gate)\nBytes 6-7:  Offset [31:16]     (high 16 bits of handler address)</code></pre></div>\n\n<p><strong>Interrupt gate vs Trap gate</strong>: The only difference is whether interrupts are automatically disabled. An interrupt gate clears the IF flag (disables interrupts) on entry; a trap gate doesn&#39;t. For hardware IRQs, use interrupt gates to prevent nested interrupts. For CPU exceptions that might need to handle interrupts, trap gates can be appropriate.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> idt_entry {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> offset_low;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> selector;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\">  zero;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\">  type_attr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> offset_high;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed));</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> idt_ptr {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> limit;</span><span style=\"color:#6A737D\">           // Size of IDT - 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> base;</span><span style=\"color:#6A737D\">            // Address of IDT</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed));</span></span></code></pre></div>\n\n<h3 id=\"loading-the-idt\">Loading the IDT</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> IDT_ENTRIES</span><span style=\"color:#79B8FF\"> 256</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> idt_entry </span><span style=\"color:#FFAB70\">idt</span><span style=\"color:#E1E4E8\">[IDT_ENTRIES];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> idt_ptr idtr;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> handler</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> sel</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> flags</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    idt</span><span style=\"color:#E1E4E8\">[num].offset_low </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> handler </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    idt</span><span style=\"color:#E1E4E8\">[num].offset_high </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (handler </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    idt</span><span style=\"color:#E1E4E8\">[num].selector </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sel;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    idt</span><span style=\"color:#E1E4E8\">[num].zero </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    idt</span><span style=\"color:#E1E4E8\">[num].type_attr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> flags;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> idt_load</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    idtr.limit </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(idt) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    idtr.base </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">idt;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">lidt %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">m</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(idtr));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"cpu-exception-vectors-0-31\">CPU Exception Vectors: 0-31</h3>\n<p>Intel reserved the first 32 vectors for CPU-detected conditions:</p>\n<table>\n<thead>\n<tr>\n<th>Vector</th>\n<th>Name</th>\n<th>Error Code?</th>\n<th>Cause</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>#DE Divide Error</td>\n<td>No</td>\n<td>Division by zero or overflow</td>\n</tr>\n<tr>\n<td>1</td>\n<td>#DB Debug</td>\n<td>No</td>\n<td>Debug trap (single step, breakpoint)</td>\n</tr>\n<tr>\n<td>2</td>\n<td>NMI</td>\n<td>No</td>\n<td>Non-maskable interrupt</td>\n</tr>\n<tr>\n<td>3</td>\n<td>#BP Breakpoint</td>\n<td>No</td>\n<td>INT 3 instruction</td>\n</tr>\n<tr>\n<td>6</td>\n<td>#UD Invalid Opcode</td>\n<td>No</td>\n<td>CPU encountered unknown instruction</td>\n</tr>\n<tr>\n<td>8</td>\n<td>#DF Double Fault</td>\n<td>Yes</td>\n<td>Exception during handling another exception</td>\n</tr>\n<tr>\n<td>10</td>\n<td>#TS Invalid TSS</td>\n<td>Yes</td>\n<td>TSS segment invalid</td>\n</tr>\n<tr>\n<td>11</td>\n<td>#NP Segment Not Present</td>\n<td>Yes</td>\n<td>Segment descriptor P=0</td>\n</tr>\n<tr>\n<td>12</td>\n<td>#SS Stack-Segment Fault</td>\n<td>Yes</td>\n<td>Stack operation outside limit</td>\n</tr>\n<tr>\n<td>13</td>\n<td>#GP General Protection</td>\n<td>Yes</td>\n<td>Privilege violation, invalid segment</td>\n</tr>\n<tr>\n<td>14</td>\n<td>#PF Page Fault</td>\n<td>Yes</td>\n<td>Page not present or protection violation</td>\n</tr>\n</tbody></table>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-exception-vectors.svg\" alt=\"CPU Exception Vectors and Error Codes\"></p>\n<p>The <strong>error code</strong> column is critical. Some exceptions push an error code onto the stack; others don&#39;t. Your handler must know which, or <code>iret</code> will pop the wrong value into EIP and crash.</p>\n<hr>\n<h2 id=\"interrupt-stack-frame-what-the-cpu-pushes\">Interrupt Stack Frame: What the CPU Pushes</h2>\n<p>{{DIAGRAM:diag-interrupt-stack-frame}}</p>\n<p>When an interrupt occurs, the CPU pushes this stack frame:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>High addresses\n┌─────────────────┐\n│    SS (old)     │  ← Only if privilege change (ring 3 → ring 0)\n│    ESP (old)    │  ← Only if privilege change\n├─────────────────┤\n│    EFLAGS       │  ← Always pushed\n├─────────────────┤\n│    CS (old)     │  ← Always pushed\n│    EIP (old)    │  ← Always pushed\n├─────────────────┤\n│  Error Code     │  ← Only for exceptions 8, 10-14\n└─────────────────┘\nLow addresses (stack grows down)</code></pre></div>\n\n<p><strong>Your handler receives this stack</strong>. The CPU did NOT save EAX, EBX, ECX, EDX, ESI, EDI, EBP, or DS/ES/FS/GS. If you use any of these registers (and you will), you must save and restore them yourself.</p>\n<hr>\n<h2 id=\"writing-an-interrupt-handler-the-assembly-shim\">Writing an Interrupt Handler: The Assembly Shim</h2>\n<p>You can&#39;t write an interrupt handler entirely in C because C has no way to:</p>\n<ol>\n<li>Control exactly what&#39;s pushed/popped</li>\n<li>Execute <code>iret</code> instead of <code>ret</code></li>\n<li>Handle the optional error code</li>\n</ol>\n<p>The standard pattern is an <strong>assembly stub</strong> that calls a C function:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; Common interrupt stub macro\n%macro ISR_NOERR 1       ; For exceptions WITHOUT error code\nglobal isr%1\nisr%1:\n    push dword 0         ; Push dummy error code to unify stack frame\n    push dword %1        ; Push interrupt number\n    jmp isr_common_stub\n%endmacro\n\n%macro ISR_ERR 1         ; For exceptions WITH error code\nglobal isr%1\nisr%1:\n    push dword %1        ; Push interrupt number (error code already on stack)\n    jmp isr_common_stub\n%endmacro\n\n; Declare all CPU exception handlers\nISR_NOERR 0              ; Divide Error\nISR_NOERR 1              ; Debug\nISR_NOERR 2              ; NMI\nISR_NOERR 3              ; Breakpoint\nISR_NOERR 4              ; Overflow\nISR_NOERR 5              ; BOUND Range Exceeded\nISR_NOERR 6              ; Invalid Opcode\nISR_NOERR 7              ; Device Not Available\nISR_ERR   8              ; Double Fault (has error code)\nISR_NOERR 9              ; Coprocessor Segment Overrun\nISR_ERR   10             ; Invalid TSS\nISR_ERR   11             ; Segment Not Present\nISR_ERR   12             ; Stack-Segment Fault\nISR_ERR   13             ; General Protection Fault\nISR_ERR   14             ; Page Fault\n; ... continue for 0-31\n\n; Common handler stub\nextern isr_handler       ; C function to handle the interrupt\n\nisr_common_stub:\n    ; Save all general-purpose registers\n    pusha                ; Pushes EAX, ECX, EDX, EBX, ESP (old), EBP, ESI, EDI\n    push ds\n    push es\n    push fs\n    push gs\n\n    ; Save current stack pointer (passes pointer to stack frame to C)\n    mov eax, esp\n    push eax\n\n    ; Load kernel data segment\n    mov ax, 0x10\n    mov ds, ax\n    mov es, ax\n    mov fs, ax\n    mov gs, ax\n\n    ; Call C handler\n    call isr_handler\n\n    ; Restore stack pointer (C may have returned a value in EAX, ignore)\n    add esp, 4\n\n    ; Restore segment registers\n    pop gs\n    pop fs\n    pop es\n    pop ds\n\n    ; Restore general-purpose registers\n    popa\n\n    ; Remove error code and interrupt number\n    add esp, 8\n\n    ; Return from interrupt\n    iret</code></pre></div>\n\n<p>The <code>pusha</code> instruction (Push All) saves EAX, ECX, EDX, EBX, ESP (the value before pusha), EBP, ESI, EDI in that order. <code>popa</code> restores all except ESP (which is restored automatically).</p>\n<h3 id=\"the-c-handler\">The C Handler</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> gs, fs, es, ds;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> edi, esi, ebp, esp, ebx, edx, ecx, eax;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> int_no, err_code;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eip, cs, eflags;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> useresp, ss;</span><span style=\"color:#6A737D\">  // Only valid if privilege change occurred</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> isr_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if this is an exception (0-31) or IRQ (32+)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (regs->int_no </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // CPU exception</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">exception_messages</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Division By Zero\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Debug\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Non Maskable Interrupt\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Breakpoint\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Into Detected Overflow\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Out of Bounds\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Invalid Opcode\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"No Coprocessor\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Double Fault\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Coprocessor Segment Overrun\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Bad TSS\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Segment Not Present\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Stack Fault\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"General Protection Fault\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Page Fault\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Unknown Interrupt\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // ... more messages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"EXCEPTION: \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">exception_messages</span><span style=\"color:#E1E4E8\">[regs->int_no]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Special handling for page fault</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (regs->int_no </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 14</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint32_t</span><span style=\"color:#E1E4E8\"> faulting_address;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %%cr2, %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(faulting_address));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Faulting address: \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            vga_put_hex</span><span style=\"color:#E1E4E8\">(faulting_address);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Error code: \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            vga_put_hex</span><span style=\"color:#E1E4E8\">(regs->err_code);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\" (\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(regs->err_code </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not-present \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (regs->err_code </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"write \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (regs->err_code </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"user-mode \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\")</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // For double fault, halt with diagnostic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (regs->int_no </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"DOUBLE FAULT - System halted.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">cli; hlt</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // For other exceptions, halt for now</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"System halted.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">cli; hlt</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"the-8259-pic-routing-hardware-interrupts\">The 8259 PIC: Routing Hardware Interrupts</h2>\n<p>The <strong>Programmable Interrupt Controller (PIC)</strong> is a separate chip that collects interrupt signals from devices and presents them to the CPU one at a time. The original 8259 handled 8 IRQs; modern systems cascade two PICs for 15 IRQs (IRQ2 is the cascade connection).</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-pic-remapping.svg\" alt=\"PIC Remapping: IRQ to Vector Mapping\"></p>\n<h3 id=\"the-remapping-problem\">The Remapping Problem</h3>\n<p>By default, the PIC maps IRQs 0-7 to CPU vectors 8-15 and IRQs 8-15 to vectors 0x70-0x77. But vectors 8-15 are CPU exceptions! When the timer fires (IRQ0), it looks like a double fault (vector 8).</p>\n<p>You must <strong>remap</strong> the PICs to use vectors that don&#39;t conflict:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Master PIC: IRQ0-7 → vectors 32-39 (0x20-0x27)\nSlave PIC:  IRQ8-15 → vectors 40-47 (0x28-0x2F)</code></pre></div>\n\n<h3 id=\"programming-the-pic\">Programming the PIC</h3>\n<p>The PIC is programmed via I/O ports:</p>\n<ul>\n<li>Master: Command at 0x20, Data at 0x21</li>\n<li>Slave: Command at 0xA0, Data at 0xA1</li>\n</ul>\n<p>The initialization sequence sends <strong>ICW1-ICW4</strong> (Initialization Command Words):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIC1_CMD</span><span style=\"color:#F97583\">  0x</span><span style=\"color:#79B8FF\">20</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIC1_DATA</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">21</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIC2_CMD</span><span style=\"color:#F97583\">  0x</span><span style=\"color:#79B8FF\">A0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIC2_DATA</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">A1</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pic_remap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> offset1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> offset2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ICW1: Start initialization, expect ICW4</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC1_CMD, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">11</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // 0x11 = initialize + ICW4 needed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC2_CMD, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">11</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ICW2: Vector offsets</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC1_DATA, offset1);</span><span style=\"color:#6A737D\">  // Master offset (e.g., 32)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC2_DATA, offset2);</span><span style=\"color:#6A737D\">  // Slave offset (e.g., 40)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ICW3: Tell Master there's a slave at IRQ2 (00000100)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //       Tell Slave its cascade identity (00000010)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC1_DATA, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">04</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC2_DATA, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">02</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ICW4: 8086 mode, non-automatic EOI</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC1_DATA, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">01</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC2_DATA, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">01</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Clear data registers (mask all IRQs initially)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC1_DATA, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC2_DATA, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pic_send_eoi</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> irq</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Send End of Interrupt to the PIC(s)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC1_CMD, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">          // EOI to master</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (irq </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        outb</span><span style=\"color:#E1E4E8\">(PIC2_CMD, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">      // EOI to slave if IRQ came from it</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"irq-handlers\">IRQ Handlers</h3>\n<p>For hardware IRQs (vectors 32-47), you need separate stubs that send EOI:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; IRQ handlers\n%macro IRQ 2\nglobal irq%1\nirq%1:\n    push dword 0           ; Dummy error code\n    push dword %1          ; IRQ number\n    jmp irq_common_stub\n%endmacro\n\nIRQ 0,  32                 ; Timer\nIRQ 1,  33                 ; Keyboard\nIRQ 2,  34                 ; Cascade\nIRQ 3,  35                 ; COM2\nIRQ 4,  36                 ; COM1\n; ... continue for IRQs 0-15\n\nextern irq_handler\n\nirq_common_stub:\n    pusha\n    push ds\n    push es\n    push fs\n    push gs\n    \n    mov eax, esp\n    push eax\n    \n    mov ax, 0x10\n    mov ds, ax\n    mov es, ax\n    mov fs, ax\n    mov gs, ax\n    \n    call irq_handler\n    \n    add esp, 4\n    \n    pop gs\n    pop fs\n    pop es\n    pop ds\n    popa\n    \n    add esp, 8\n    \n    iret</code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// C handler for IRQs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> irq_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Send EOI to PIC</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pic_send_eoi</span><span style=\"color:#E1E4E8\">(regs->int_no </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Dispatch to specific handler</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (regs->int_no </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        timer_handler</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (regs->int_no </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 33</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        keyboard_handler</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... other IRQ handlers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"the-pit-timer-your-first-clock\">The PIT Timer: Your First Clock</h2>\n<p>The <strong>Programmable Interval Timer (8253/8254)</strong> generates periodic interrupts at a configurable frequency. Channel 0 is connected to IRQ0.</p>\n<p>The base frequency is 1,193,182 Hz (≈1.193 MHz). You configure the divisor to get your desired frequency:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Output frequency = 1,193,182 / divisor\nDivisor for 100Hz = 1,193,182 / 100 = 11931 (0x2E9B)</code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIT_CHANNEL0</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">40</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIT_CMD</span><span style=\"color:#F97583\">      0x</span><span style=\"color:#79B8FF\">43</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> tick_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> timer_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> frequency</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> divisor </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1193182</span><span style=\"color:#F97583\"> /</span><span style=\"color:#E1E4E8\"> frequency;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Command byte: channel 0, access mode: lobyte/hibyte, mode 3 (square wave)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIT_CMD, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">36</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Send divisor</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIT_CHANNEL0, divisor </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FF</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">        // Low byte</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIT_CHANNEL0, (divisor </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FF</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\"> // High byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> timer_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tick_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Every 100 ticks (1 second at 100Hz), print a message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (tick_count </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Tick: \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_put_dec</span><span style=\"color:#E1E4E8\">(tick_count </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\" seconds</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The <code>volatile</code> keyword on <code>tick_count</code> prevents the compiler from caching it in a register — necessary because it&#39;s modified in an interrupt handler that the compiler can&#39;t see.</p>\n<hr>\n<h2 id=\"ps2-keyboard-scancodes-to-characters\">PS/2 Keyboard: Scancodes to Characters</h2>\n<p>The keyboard doesn&#39;t send ASCII. It sends <strong>scancodes</strong> — raw key identifiers. When you press &#39;A&#39;, the keyboard sends scancode 0x1E. When you release &#39;A&#39;, it sends 0x9E (break code = make code | 0x80).</p>\n<p>{{DIAGRAM:diag-keyboard-scancode-flow}}</p>\n<h3 id=\"reading-from-the-keyboard\">Reading from the Keyboard</h3>\n<p>The keyboard controller presents data at I/O port 0x60. When a key is pressed:</p>\n<ol>\n<li>Keyboard controller sends scancode to port 0x60</li>\n<li>Keyboard controller asserts IRQ1</li>\n<li>CPU vectors through IDT to your IRQ1 handler</li>\n<li>Your handler reads port 0x60 to get the scancode</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KB_DATA_PORT</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">60</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KB_CMD_PORT</span><span style=\"color:#F97583\">  0x</span><span style=\"color:#79B8FF\">64</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KB_BUFFER_SIZE</span><span style=\"color:#79B8FF\"> 128</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> char</span><span style=\"color:#FFAB70\"> kb_buffer</span><span style=\"color:#E1E4E8\">[KB_BUFFER_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> kb_buffer_head </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> kb_buffer_tail </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// US QWERTY scancode to ASCII table (lowercase)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\"> scancode_to_ascii</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    0</span><span style=\"color:#E1E4E8\">,    </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,   </span><span style=\"color:#9ECBFF\">'1'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'2'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'3'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'4'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'5'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'6'</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">   // 0x00-0x07</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '7'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'8'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'9'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'0'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'-'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'='</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\b</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\t</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">  // 0x08-0x0F (backspace, tab)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'q'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'w'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'e'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'r'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'t'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'y'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'u'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'i'</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">   // 0x10-0x17</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'o'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'p'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'['</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">']'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">              // 0x18-0x1D (enter, left ctrl)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'a'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'s'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'d'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'f'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'g'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'h'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'j'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'k'</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">   // 0x1E-0x25</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'l'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">';'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\'</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'`'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\\\</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">             // 0x26-0x2B (no key, shift, backslash)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'z'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'x'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'c'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'v'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'b'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'n'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'m'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">','</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">   // 0x2C-0x33</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '.'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'/'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">' '</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">                   // 0x34-0x39 (shift, alt, space)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Extended scancodes (prefixed with 0xE0) need separate handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> extended_scancode </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> keyboard_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> scancode </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> inb</span><span style=\"color:#E1E4E8\">(KB_DATA_PORT);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle extended scancodes (arrow keys, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (scancode </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">E0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        extended_scancode </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check for break code (key release)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> released </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (scancode </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    scancode </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">7F</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (released) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Handle key release (for shift/ctrl tracking)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (scancode </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">2A</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> scancode </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">36</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Left or right shift released</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            shift_pressed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle modifier keys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (scancode </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">2A</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> scancode </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">36</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        shift_pressed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Convert to ASCII</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (scancode </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(scancode_to_ascii)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> scancode_to_ascii</span><span style=\"color:#E1E4E8\">[scancode];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (shift_pressed </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">>=</span><span style=\"color:#9ECBFF\"> 'a'</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#9ECBFF\"> 'z'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            c </span><span style=\"color:#F97583\">-=</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Convert to uppercase</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Add to circular buffer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> next_head </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (kb_buffer_head </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> KB_BUFFER_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (next_head </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> kb_buffer_tail) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            kb_buffer</span><span style=\"color:#E1E4E8\">[kb_buffer_head] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> c;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            kb_buffer_head </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next_head;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Non-blocking read from keyboard buffer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> kb_getchar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (kb_buffer_head </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> kb_buffer_tail) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Buffer empty</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> kb_buffer</span><span style=\"color:#E1E4E8\">[kb_buffer_tail];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    kb_buffer_tail </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (kb_buffer_tail </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> KB_BUFFER_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> c;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"handling-special-cases\">Handling Special Cases</h3>\n<p>The PS/2 keyboard has quirks:</p>\n<ol>\n<li><strong>Extended scancodes</strong> (0xE0 prefix): Arrow keys, navigation cluster, and right-side modifiers send a two-byte sequence starting with 0xE0</li>\n<li><strong>Pause/Break</strong>: Sends 0xE1 0x1D 0x45 0xE1 0x9D 0xC5 (8 bytes total!)</li>\n<li><strong>Print Screen</strong>: Sends 0xE0 0x2A 0xE0 0x37 on press</li>\n</ol>\n<p>Production keyboard drivers use state machines. For now, handling basic alphanumeric keys is sufficient.</p>\n<hr>\n<h2 id=\"double-fault-your-last-line-of-defense\">Double Fault: Your Last Line of Defense</h2>\n<p>A <strong>double fault</strong> (exception 8) occurs when an exception happens while handling another exception. Common causes:</p>\n<ul>\n<li>Page fault while handling a page fault</li>\n<li>Segment not present while handling an exception</li>\n<li>Stack overflow during exception handling</li>\n</ul>\n<p>Without a double fault handler, the CPU <strong>triple faults</strong> and resets. With a handler, you can at least print a diagnostic before halting:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> double_fault_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_set_color</span><span style=\"color:#E1E4E8\">(VGA_WHITE, VGA_RED);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">!!! DOUBLE FAULT !!!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"System state corrupted. Halting.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"EIP: \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_put_hex</span><span style=\"color:#E1E4E8\">(regs->eip);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  CS: \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_put_hex</span><span style=\"color:#E1E4E8\">(regs->cs);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">Error code: \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_put_hex</span><span style=\"color:#E1E4E8\">(regs->err_code);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // No recovery possible from double fault</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">cli; hlt</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The error code for double fault indicates what went wrong:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Bits 0-1: Which table (0=GDT, 1=IDT, 2=LDT, 3=IDT)\nBit 2:    Type of access (0=instruction fetch or segment load)\nBits 3-15: Index of selector</code></pre></div>\n\n\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-triple-fault-chain.svg\" alt=\"Fault Cascade: Triple Fault Cause Chain\"></p>\n<hr>\n<h2 id=\"putting-it-all-together-initialization-sequence\">Putting It All Together: Initialization Sequence</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> idt_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set up exception handlers (0-31)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,  (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)isr0,  </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">8E</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Divide Error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,  (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)isr1,  </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">8E</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Debug</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... all 32 exceptions ...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">,  (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)isr8,  </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">8E</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Double Fault</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">14</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)isr14, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">8E</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Page Fault</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remap PIC and set up IRQ handlers (32-47)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pic_remap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">40</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)irq0, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">8E</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Timer</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">33</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)irq1, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">8E</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Keyboard</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... remaining IRQs ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Load IDT</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_load</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> kernel_main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    serial_init</span><span style=\"color:#E1E4E8\">(COM1_PORT);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Initializing IDT...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Initializing timer (100Hz)...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    timer_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Unmask IRQ0 (timer) and IRQ1 (keyboard)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC1_DATA, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">FC</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 11111100 - enable IRQ0 and IRQ1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Enabling interrupts...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">sti</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"System ready. Type something!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kb_getchar</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (c </span><span style=\"color:#F97583\">!=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            vga_putchar</span><span style=\"color:#E1E4E8\">(c);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">hlt</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Wait for interrupt</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"hardware-soul-what39s-happening-on-the-metal\">Hardware Soul: What&#39;s Happening on the Metal</h2>\n<p><strong>Interrupt latency</strong>: From IRQ assertion to your handler&#39;s first instruction, the CPU spends 50-100 cycles on the automatic stack operations. Your pusha/push ds-es adds another 40 cycles. That&#39;s 100-150 cycles of pure overhead before any useful work.</p>\n<p><strong>Cache impact</strong>: Interrupt handlers run with whatever&#39;s in the cache. A timer interrupt that fires while running a memory-intensive loop will find a cold cache. This is why interrupt handlers should be small.</p>\n<p><strong>PIC priority</strong>: The PIC has a fixed priority scheme — IRQ0 (timer) is highest, IRQ7 lowest. If IRQ0 is pending when IRQ7 arrives, IRQ0 wins. If you&#39;re in an IRQ0 handler and IRQ7 fires, it waits (unless you re-enable interrupts with <code>sti</code> in the handler).</p>\n<p><strong>The EOI timing window</strong>: Between your handler returning and <code>iret</code> executing, interrupts are still disabled. But after <code>iret</code>, if EOI was sent, the next pending IRQ fires immediately. There&#39;s no &quot;settle time.&quot;</p>\n<p><strong>Keyboard controller buffer</strong>: The keyboard controller has a small internal buffer (typically 16 bytes). If you don&#39;t read port 0x60 fast enough, the controller discards old keystrokes. Your interrupt handler needs to be responsive.</p>\n<hr>\n<h2 id=\"debugging-interrupt-issues\">Debugging Interrupt Issues</h2>\n<p><strong>Symptom: System freezes immediately after enabling interrupts</strong></p>\n<ul>\n<li>Check: Did you remap the PIC? Default vectors 8-15 conflict with CPU exceptions</li>\n<li>Check: Is the IDT loaded? Add a debug print after <code>lidt</code></li>\n<li>Check: Are your IDT entry addresses correct? Use GDB to inspect</li>\n</ul>\n<p><strong>Symptom: One interrupt works, then nothing</strong></p>\n<ul>\n<li>You forgot to send EOI. The PIC is waiting.</li>\n<li>Check: <code>pic_send_eoi()</code> is called at the end of every IRQ handler</li>\n</ul>\n<p><strong>Symptom: Keyboard produces wrong characters</strong></p>\n<ul>\n<li>Scancode table mismatch. Are you using US QWERTY?</li>\n<li>Extended scancode handling missing. Arrow keys send 0xE0 prefix</li>\n</ul>\n<p><strong>Symptom: Random crashes, corrupted variables</strong></p>\n<ul>\n<li>You&#39;re not saving/restoring all registers</li>\n<li>Check: <code>pusha</code>/<code>popa</code> plus segment registers</li>\n<li>Check: Error code handling (some exceptions push it, some don&#39;t)</li>\n</ul>\n<p><strong>Symptom: Triple fault</strong></p>\n<ul>\n<li>Check: Double fault handler is installed and correct</li>\n<li>Check: Stack pointer is valid (your handler needs stack space)</li>\n<li>Use QEMU: <code>qemu-system-i386 -d int -serial stdio</code> to log all interrupts</li>\n</ul>\n<hr>\n<h2 id=\"design-decision-interrupt-gates-vs-trap-gates\">Design Decision: Interrupt Gates vs Trap Gates</h2>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Interrupt Gate</th>\n<th>Trap Gate</th>\n<th>Recommendation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IF flag</td>\n<td>Cleared (interrupts disabled)</td>\n<td>Unchanged</td>\n<td>IRQs: interrupt gate</td>\n</tr>\n<tr>\n<td>Nested interrupts</td>\n<td>Prevented automatically</td>\n<td>Must handle manually</td>\n<td>Exceptions: trap gate OK</td>\n</tr>\n<tr>\n<td>Used by Linux</td>\n<td>All hardware IRQs</td>\n<td>Software interrupts</td>\n<td>Follow Linux</td>\n</tr>\n</tbody></table>\n<p>For this project, use interrupt gates (0x8E in type_attr) for all entries. The simplicity outweighs the minor latency cost of re-enabling interrupts if needed.</p>\n<hr>\n<h2 id=\"knowledge-cascade\">Knowledge Cascade</h2>\n<p>You&#39;ve built the interrupt subsystem — the nervous system of your kernel. Here&#39;s where this knowledge connects:</p>\n<p><strong>Signal Handling in Unix/Linux</strong>: Every signal mechanism traces back to what you just built. <code>SIGSEGV</code> (segmentation fault) is your page fault handler reporting to user space. <code>SIGALRM</code> is your timer interrupt delivering a notification. The <code>sigaction()</code> system call is essentially letting user programs register their own &quot;IDT entries&quot; for software signals. When you understand that signals are just user-space-visible interrupts, the POSIX signal API makes perfect sense.</p>\n<p><strong>Rust Panic and Go Recover (Cross-Domain)</strong>: Language-level exception handling is built on CPU exceptions. When Rust code panics, the runtime either unwinds the stack or aborts — similar to how your exception handlers choose between recovery and halt. Go&#39;s <code>recover()</code> function catches panics, analogous to a high-level double fault handler. The difference is scope: CPU exceptions are per-instruction, language exceptions are per-call-frame.</p>\n<p><strong>Real-Time Systems and Interrupt Latency</strong>: The EOI timing you learned — send it too late and latency increases, send it too early and risk re-entrancy — is central to real-time systems. The Linux PREEMPT_RT patch converts hard IRQs to threaded interrupts for this reason. Audio buffer underruns (glitches) happen when interrupt handlers take too long. Your timer handler&#39;s execution time directly affects the system&#39;s worst-case interrupt latency.</p>\n<p><strong>Input Subsystem Architecture</strong>: Your scancode-to-ASCII table is the ancestor of Linux&#39;s input subsystem. The modern Linux keyboard driver handles multiple keyboard types, keyboard layouts (via user-space keymaps), and even multiple keyboards simultaneously. But at the core: scancode in from hardware, character out to buffer. You&#39;ve implemented the essential path.</p>\n<p><strong>Interrupt Storm Debugging</strong>: When a faulty network card asserts IRQ continuously and your handler forgets EOI, the system &quot;freezes&quot; — but it&#39;s actually spending 100% of CPU time in your handler. Server administrators see this with <code>/proc/interrupts</code> showing millions of IRQs per second. You now understand why: the PIC keeps delivering, the CPU keeps vectoring, nothing else runs.</p>\n<p><strong>Forward: What You Can Now Build</strong>: With a working interrupt system, you can:</p>\n<ul>\n<li>Implement preemptive scheduling (timer interrupt triggers context switch)</li>\n<li>Add demand paging (page fault handler loads pages from disk)</li>\n<li>Build a system call interface (INT 0x80 is just another interrupt)</li>\n<li>Write drivers for any hardware with an IRQ</li>\n</ul>\n<hr>\n<h2 id=\"summary\">Summary</h2>\n<p>You&#39;ve built the interrupt subsystem — the mechanism by which hardware events and software exceptions reach your code:</p>\n<ol>\n<li><strong>IDT</strong>: 256 entries, each 8 bytes, mapping vector numbers to handler addresses</li>\n<li><strong>Exception handlers</strong>: CPU-detected conditions (0-31), some with error codes</li>\n<li><strong>PIC remapping</strong>: Move IRQs from conflicting vectors (8-15) to 32-47</li>\n<li><strong>EOI protocol</strong>: Tell the PIC when you&#39;re done, or interrupts stop forever</li>\n<li><strong>PIT timer</strong>: Configure divisor for desired frequency, increment tick counter</li>\n<li><strong>PS/2 keyboard</strong>: Read scancodes from port 0x60, convert to ASCII, buffer for reading</li>\n<li><strong>Double fault handler</strong>: Catch cascading failures before they cause triple fault</li>\n</ol>\n<p>The revelation: interrupts are not callbacks. The CPU pushes a defined stack frame, jumps to your handler, and expects you to clean up. The PIC asserts a signal but doesn&#39;t &quot;call&quot; anything. You send EOI as a message, not a return value. This is hardware communication at its most fundamental.</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-satellite-system.svg\" alt=\"OS Kernel Architecture: Satellite View\"></p>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-os-m3 -->\n<h1 id=\"milestone-3-physical-and-virtual-memory-management\">Milestone 3: Physical and Virtual Memory Management</h1>\n<h2 id=\"the-tension-memory-isn39t-what-you-think-it-is\">The Tension: Memory Isn&#39;t What You Think It Is</h2>\n<p>Here&#39;s what most developers believe about memory:</p>\n<blockquote>\n<p>&quot;Memory is a big byte array. <code>malloc(100)</code> gives me 100 bytes at some address like 0x1000. That address points to physical RAM. Virtual memory is just swap to disk.&quot;</p>\n</blockquote>\n<p>Every part of this mental model is wrong.</p>\n<p><strong>Reality #1: Physical memory is a collection of 4KB chunks called frames.</strong> There is no giant contiguous array. The 1GB of RAM in your system is 262,144 separate frames, each individually addressable, each potentially allocated to a different purpose.</p>\n<p><strong>Reality #2: Virtual addresses are translated on every single access.</strong> When you read <code>*ptr</code> where <code>ptr = 0xC0123456</code>, the CPU doesn&#39;t &quot;look up&quot; the translation once. It walks the page table hierarchy every time—or relies on the TLB (Translation Lookaside Buffer) cache. That translation happens in hardware, in parallel with the cache lookup, adding ~10-30 cycles to every memory access.</p>\n<p><strong>Reality #3: The TLB is not coherent with your page table writes.</strong> Modify a page table entry, and the TLB still holds the old translation. The CPU will happily use stale data. You must explicitly invalidate entries with <code>invlpg</code> or reload CR3.</p>\n<p><strong>Reality #4: Enabling paging without mapping your current code causes immediate crash.</strong> The moment you set CR0.PG, the CPU starts translating <em>the very next instruction fetch</em>. If that instruction&#39;s virtual address doesn&#39;t map to its physical location, you page fault before executing another instruction.</p>\n<p>{{DIAGRAM:diag-page-table-hierarchy}}</p>\n<p>The numbers that matter:</p>\n<ul>\n<li><strong>4KB frame size</strong> — the atomic unit of physical allocation</li>\n<li><strong>4MB per page directory entry</strong> — each PDE covers a 4MB virtual region</li>\n<li><strong>1024 entries per page directory</strong> — covers 4GB virtual address space</li>\n<li><strong>1024 entries per page table</strong> — covers 4MB per page table</li>\n<li><strong>TLB: 64-128 entries</strong> — tiny cache, misses cost hundreds of cycles</li>\n</ul>\n<p>This milestone is about building the memory management layer that makes virtual addresses work: parsing the physical memory map, allocating frames, constructing page tables, enabling paging, and building a kernel heap on top of it all.</p>\n<hr>\n<h2 id=\"revelation-the-address-translation-happens-every-time\">Revelation: The Address Translation Happens Every Time</h2>\n<p><strong>What you might think</strong>: &quot;When I call <code>malloc</code>, the kernel sets up a mapping. After that, accessing that pointer goes directly to RAM.&quot;</p>\n<p><strong>What actually happens</strong>:</p>\n<p>Every memory access—every instruction fetch, every data read, every stack push—goes through this sequence:</p>\n<ol>\n<li>CPU generates a <strong>virtual address</strong> (e.g., 0xC0101234)</li>\n<li>Extract page directory index: bits 22-31 → 0x300 (768)</li>\n<li>Read Page Directory Entry (PDE) at CR3 + 768*4</li>\n<li>Check present bit—if 0, raise page fault</li>\n<li>Extract page table index: bits 12-21 → 0x101 (257)</li>\n<li>Read Page Table Entry (PTE) at PDE.frame + 257*4</li>\n<li>Check present bit—if 0, raise page fault</li>\n<li>Extract offset: bits 0-11 → 0x234</li>\n<li>Physical address = PTE.frame + 0x234</li>\n<li>Access cache/memory at that physical address</li>\n</ol>\n<p>Steps 2-9 happen in hardware, in parallel with the L1 cache lookup. But here&#39;s the critical part: the TLB caches the <em>result</em> of steps 2-9. If you modify the page table entry in step 7, the TLB still holds the old translation.</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-page-directory-entry.svg\" alt=\"Page Directory/Table Entry Bits\"></p>\n<p>This has profound implications:</p>\n<ul>\n<li><strong>Context switches must reload CR3</strong> — each process has its own page directory, and the TLB is full of the old process&#39;s translations</li>\n<li><strong>Modifying page tables requires invlpg</strong> — or the CPU uses stale translations</li>\n<li><strong>Identity mapping is mandatory during transition</strong> — enabling paging while executing code at 0x100000 requires a mapping from virtual 0x100000 to physical 0x100000</li>\n</ul>\n<hr>\n<h2 id=\"system-map-where-we-are\">System Map: Where We Are</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>┌─────────────────────────────────────────────────────────────────┐\n│                         YOUR OS KERNEL                          │\n│                                                                 │\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │\n│  │   Memory    │  │   Physical  │  │   Virtual   │             │\n│  │   Map       │→ │   Frame     │→ │   Memory    │             │\n│  │  (E820)     │  │   Allocator │  │   Manager   │             │\n│  └─────────────┘  └─────────────┘  └─────────────┘             │\n│         │                │                │                     │\n│         │                │                ↓                     │\n│         │                │         ┌─────────────┐              │\n│         │                │         │   Kernel    │              │\n│         │                └────────→│   Heap      │              │\n│         │                          │ (kmalloc)   │              │\n│         │                          └─────────────┘              │\n│         │                                │                      │\n│  ┌──────┴────────────────────────────────┴──────────────┐      │\n│  │                    HARDWARE                          │      │\n│  │  CR3 → Page Directory → Page Tables → Physical RAM  │      │\n│  │  TLB caches translations (NOT coherent with writes) │      │\n│  └─────────────────────────────────────────────────────┘      │\n└─────────────────────────────────────────────────────────────────┘</code></pre></div>\n\n<p>We&#39;re building the entire memory management stack: physical memory discovery, frame allocation, page table construction, paging enablement, and kernel heap allocation.</p>\n<hr>\n<h2 id=\"physical-memory-map-discovering-what-exists\">Physical Memory Map: Discovering What Exists</h2>\n<h3 id=\"the-e820-bios-query\">The E820 BIOS Query</h3>\n<p>Before you can allocate memory, you need to know what memory exists. The BIOS provides this via the E820 query (INT 15h, AX=E820), which returns a list of memory regions with their types.</p>\n<p>{{DIAGRAM:diag-e820-memory-map}}</p>\n<p>Each E820 entry is 20+ bytes:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> e820_entry {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> base;</span><span style=\"color:#6A737D\">      // Base address of region</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> length;</span><span style=\"color:#6A737D\">    // Length of region</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> type;</span><span style=\"color:#6A737D\">      // Type of memory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> acpi;</span><span style=\"color:#6A737D\">      // ACPI extended attributes (optional)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed));</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> E820_USABLE</span><span style=\"color:#79B8FF\">    1</span><span style=\"color:#6A737D\">   // Normal RAM, can be used</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> E820_RESERVED</span><span style=\"color:#79B8FF\">  2</span><span style=\"color:#6A737D\">   // Reserved, do not use</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> E820_ACPI_RECL</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#6A737D\">   // ACPI reclaimable after reading tables</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> E820_ACPI_NVS</span><span style=\"color:#79B8FF\">  4</span><span style=\"color:#6A737D\">   // ACPI non-volatile storage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> E820_BAD</span><span style=\"color:#79B8FF\">       5</span><span style=\"color:#6A737D\">   // Bad memory, contains errors</span></span></code></pre></div>\n\n<p>If you&#39;re using a multiboot bootloader (GRUB), the multiboot info structure already contains the memory map:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> multiboot_mmap_entry {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> base_addr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> length;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> type;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed));</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> parse_memory_map</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">multiboot_info_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">mbi</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if memory map is present</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(mbi->flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">))) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"No memory map from bootloader!\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> total_usable </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    multiboot_mmap_entry_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">entry </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">multiboot_mmap_entry_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)mbi->mmap_addr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)entry </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> mbi->mmap_addr </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> mbi->mmap_length) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Memory: 0x</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\"> - 0x</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)entry->base_addr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)(entry->base_addr </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> entry->length </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        switch</span><span style=\"color:#E1E4E8\"> (entry->type) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> E820_USABLE:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"(usable)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                total_usable </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> entry->length;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> E820_RESERVED:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"(reserved)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> E820_ACPI_RECL:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"(ACPI reclaimable)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> E820_ACPI_NVS:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"(ACPI NVS)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"(type </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, entry</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">type</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entry </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">multiboot_mmap_entry_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)entry </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> entry->size </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Total usable memory: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> MB</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, total_usable </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"typical-memory-layout\">Typical Memory Layout</h3>\n<p>A typical 512MB system might have:</p>\n<table>\n<thead>\n<tr>\n<th>Start</th>\n<th>End</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0x000000</td>\n<td>0x000FFF</td>\n<td>Reserved</td>\n<td>Real-mode IVT, BDA</td>\n</tr>\n<tr>\n<td>0x001000</td>\n<td>0x07FFFF</td>\n<td>Usable</td>\n<td>Low memory (conventional)</td>\n</tr>\n<tr>\n<td>0x07FFFF</td>\n<td>0x080000</td>\n<td>Reserved</td>\n<td>EBDA (Extended BIOS Data Area)</td>\n</tr>\n<tr>\n<td>0x080000</td>\n<td>0x0FFFFF</td>\n<td>Reserved</td>\n<td>ROM area, video memory</td>\n</tr>\n<tr>\n<td>0x100000</td>\n<td>0x1FFFFFF</td>\n<td>Usable</td>\n<td>Extended memory (your kernel lives here)</td>\n</tr>\n<tr>\n<td>0x2000000+</td>\n<td>...</td>\n<td>Usable</td>\n<td>More RAM</td>\n</tr>\n</tbody></table>\n<p><strong>Critical insight</strong>: Not all &quot;usable&quot; memory is actually available. Your kernel binary, page tables, and bootloader data occupy physical frames. Your allocator must skip these.</p>\n<hr>\n<h2 id=\"physical-frame-allocator-managing-4kb-chunks\">Physical Frame Allocator: Managing 4KB Chunks</h2>\n<h3 id=\"bitmap-allocator\">Bitmap Allocator</h3>\n<p>A bitmap allocator uses one bit per frame to track allocation status. For 4GB of memory with 4KB frames, you need 128KB of bitmap (4GB / 4KB / 8 bits = 131,072 bytes).</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FRAME_SIZE</span><span style=\"color:#79B8FF\"> 4096</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FRAMES_PER_BITMAP_ENTRY</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#6A737D\">  // 32 bits per uint32_t</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">frame_bitmap;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> total_frames;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> first_usable_frame;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Calculate which frame a physical address belongs to</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FRAME_FROM_ADDR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">addr</span><span style=\"color:#E1E4E8\">) ((addr) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> FRAME_SIZE)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bitmap operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> set_frame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> frame</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    frame_bitmap</span><span style=\"color:#E1E4E8\">[frame </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> (frame </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> clear_frame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> frame</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    frame_bitmap</span><span style=\"color:#E1E4E8\">[frame </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> (frame </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> test_frame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> frame</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#FFAB70\"> frame_bitmap</span><span style=\"color:#E1E4E8\">[frame </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> (frame </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Find first free frame</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> find_free_frame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> first_usable_frame </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> total_frames </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">frame_bitmap</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFFFFFF</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // At least one bit is free</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; j </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">; j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frame_bitmap</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> j))) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    return</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> j;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Out of memory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Allocate a single frame, returns physical address</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">alloc_frame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> find_free_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (frame </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Out of memory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    set_frame</span><span style=\"color:#E1E4E8\">(frame);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)(frame </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> FRAME_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Free a frame by physical address</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> free_frame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> FRAME_FROM_ADDR</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)addr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Safety checks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (frame </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> first_usable_frame </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> total_frames) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"free_frame: invalid frame number </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, frame);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Double-free detection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">test_frame</span><span style=\"color:#E1E4E8\">(frame)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"free_frame: double free at frame </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (addr 0x</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, frame, addr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    clear_frame</span><span style=\"color:#E1E4E8\">(frame);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"initializing-the-frame-allocator\">Initializing the Frame Allocator</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> frame_allocator_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">multiboot_info_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">mbi</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate total physical memory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> max_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    multiboot_mmap_entry_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">entry </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">multiboot_mmap_entry_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)mbi->mmap_addr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)entry </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> mbi->mmap_addr </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> mbi->mmap_length) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> entry->base_addr </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> entry->length;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (end </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> max_addr) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            max_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> end;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entry </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">multiboot_mmap_entry_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)entry </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> entry->size </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    total_frames </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> max_addr </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> FRAME_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate bitmap (must be in identity-mapped region)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> bitmap_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (total_frames </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 31</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frame_bitmap </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">placement_alloc</span><span style=\"color:#E1E4E8\">(bitmap_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mark everything as reserved initially</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(frame_bitmap, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">FF</span><span style=\"color:#E1E4E8\">, bitmap_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mark usable regions as free</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    first_usable_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> total_frames;</span><span style=\"color:#6A737D\">  // Start with max</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entry </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">multiboot_mmap_entry_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)mbi->mmap_addr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)entry </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> mbi->mmap_addr </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> mbi->mmap_length) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (entry->type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> E820_USABLE) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint32_t</span><span style=\"color:#E1E4E8\"> start_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> FRAME_FROM_ADDR</span><span style=\"color:#E1E4E8\">(entry->base_addr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint32_t</span><span style=\"color:#E1E4E8\"> end_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> FRAME_FROM_ADDR</span><span style=\"color:#E1E4E8\">(entry->base_addr </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> entry->length);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Align to frame boundaries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (start_frame </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> FRAME_SIZE </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> entry->base_addr) start_frame</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (end_frame </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> FRAME_SIZE </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> entry->base_addr </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> entry->length) end_frame</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> f </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> start_frame; f </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> end_frame; f</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                clear_frame</span><span style=\"color:#E1E4E8\">(f);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (f </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> first_usable_frame) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    first_usable_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> f;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entry </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">multiboot_mmap_entry_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)entry </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> entry->size </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Reserve kernel and already-allocated memory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    extern</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> _kernel_start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    extern</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> _kernel_end;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> kernel_start_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> FRAME_FROM_ADDR</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">_kernel_start);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> kernel_end_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> FRAME_FROM_ADDR</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">_kernel_end) </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> f </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> kernel_start_frame; f </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> kernel_end_frame; f</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        set_frame</span><span style=\"color:#E1E4E8\">(f);</span><span style=\"color:#6A737D\">  // Mark as used</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Frame allocator initialized: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> frames, first usable at 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            total_frames, first_usable_frame </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> FRAME_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"alternative-linked-list-allocator\">Alternative: Linked List Allocator</h3>\n<p>A free-list allocator tracks free frames by linking them together:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> free_frame {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> free_frame </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> free_frame </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">alloc_frame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (free_list </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> free_frame </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> free_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> free_list->next;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)frame;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> free_frame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> free_frame </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> free_frame </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)addr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frame->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> free_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> frame;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Trade-off</strong>: The free-list is O(1) for both allocation and freeing, but requires careful handling of the initial population and doesn&#39;t handle double-free detection as naturally.</p>\n<hr>\n<h2 id=\"page-tables-the-two-level-hierarchy\">Page Tables: The Two-Level Hierarchy</h2>\n<h3 id=\"x86-32-bit-paging-structure\">x86 32-bit Paging Structure</h3>\n<p>On x86 without PAE (Physical Address Extension), paging uses a two-level hierarchy:</p>\n<p>{{DIAGRAM:diag-page-table-hierarchy}}</p>\n<ol>\n<li><strong>Page Directory (PD)</strong>: 1024 entries, each covering 4MB of virtual space</li>\n<li><strong>Page Table (PT)</strong>: 1024 entries, each covering 4KB of virtual space</li>\n</ol>\n<p>The CR3 register holds the <strong>physical address</strong> of the page directory.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_SIZE</span><span style=\"color:#79B8FF\"> 4096</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ENTRIES_PER_TABLE</span><span style=\"color:#79B8FF\"> 1024</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Page Directory/Table Entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#79B8FF\"> pte_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Entry flags</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_PRESENT</span><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_WRITABLE</span><span style=\"color:#E1E4E8\">   (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_USER</span><span style=\"color:#E1E4E8\">       (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_WRITETHRU</span><span style=\"color:#E1E4E8\">  (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_CACHE_DIS</span><span style=\"color:#E1E4E8\">  (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_ACCESSED</span><span style=\"color:#E1E4E8\">   (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_DIRTY</span><span style=\"color:#E1E4E8\">      (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">   // Page tables only</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_PAGE_SIZE</span><span style=\"color:#E1E4E8\">  (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 7</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">   // 4MB pages in PD</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_GLOBAL</span><span style=\"color:#E1E4E8\">     (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">   // Not flushed on CR3 reload</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_FRAME_MASK</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFFF000</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pte_t</span><span style=\"color:#FFAB70\"> entries</span><span style=\"color:#E1E4E8\">[ENTRIES_PER_TABLE];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pte_t</span><span style=\"color:#FFAB70\"> entries</span><span style=\"color:#E1E4E8\">[ENTRIES_PER_TABLE];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Current page directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">current_directory;</span></span></code></pre></div>\n\n<h3 id=\"extracting-address-components\">Extracting Address Components</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Extract indices from a virtual address</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PD_INDEX</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">addr</span><span style=\"color:#E1E4E8\">) (((addr) </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 22</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">3FF</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PT_INDEX</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">addr</span><span style=\"color:#E1E4E8\">) (((addr) </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">3FF</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_OFFSET</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">addr</span><span style=\"color:#E1E4E8\">) ((addr) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFF</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get frame address from PTE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_FRAME</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pte</span><span style=\"color:#E1E4E8\">) ((pte) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_FRAME_MASK)</span></span></code></pre></div>\n\n<h3 id=\"mapping-virtual-to-physical\">Mapping Virtual to Physical</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Map a virtual page to a physical frame</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> map_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">dir</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> virt</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> phys</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> flags</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Align addresses to page boundaries</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    virt </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> ~0x</span><span style=\"color:#79B8FF\">FFF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    phys </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> ~0x</span><span style=\"color:#79B8FF\">FFF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pd_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> PD_INDEX</span><span style=\"color:#E1E4E8\">(virt);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pt_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> PT_INDEX</span><span style=\"color:#E1E4E8\">(virt);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get or create page table</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pte_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pde </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">dir->entries[pd_idx];</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pt;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pde </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_PRESENT)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Allocate new page table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">pt) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to allocate page table for 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, virt);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Clear the page table</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memset</span><span style=\"color:#E1E4E8\">(pt, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Set page directory entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">pde </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)pt) </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PTE_PRESENT </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PTE_WRITABLE </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> (flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_USER);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">PTE_FRAME</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pde);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set page table entry</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pte_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">pt->entries[pt_idx];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> phys </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> flags </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PTE_PRESENT;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Invalidate TLB entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">invlpg (%0)</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(virt));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Unmap a virtual page</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> unmap_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">dir</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> virt</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pd_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> PD_INDEX</span><span style=\"color:#E1E4E8\">(virt);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pt_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> PT_INDEX</span><span style=\"color:#E1E4E8\">(virt);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(dir->entries[pd_idx] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_PRESENT)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Nothing mapped</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">PTE_FRAME</span><span style=\"color:#E1E4E8\">(dir->entries[pd_idx]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pt->entries[pt_idx] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Clear present bit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Invalidate TLB entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">invlpg (%0)</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(virt));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get physical address for a virtual address (returns 0 if not mapped)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> get_physical</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">dir</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> virt</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pd_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> PD_INDEX</span><span style=\"color:#E1E4E8\">(virt);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pt_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> PT_INDEX</span><span style=\"color:#E1E4E8\">(virt);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(dir->entries[pd_idx] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_PRESENT)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">PTE_FRAME</span><span style=\"color:#E1E4E8\">(dir->entries[pd_idx]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(pt->entries[pt_idx] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_PRESENT)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> PTE_FRAME</span><span style=\"color:#E1E4E8\">(pt->entries[pt_idx]) </span><span style=\"color:#F97583\">|</span><span style=\"color:#B392F0\"> PAGE_OFFSET</span><span style=\"color:#E1E4E8\">(virt);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"identity-mapping-higher-half-kernel\">Identity Mapping + Higher-Half Kernel</h2>\n<h3 id=\"the-address-space-layout-problem\">The Address Space Layout Problem</h3>\n<p>Your kernel needs to be accessible from every process (for system calls, interrupt handlers). But user processes need isolated address spaces. The solution: <strong>higher-half kernel</strong>.</p>\n<p>{{DIAGRAM:diag-identity-higher-half}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Virtual Address Space:\n┌─────────────────┐ 0xFFFFFFFF\n│   Kernel Space  │ (1GB, reserved)\n│   0xC0000000+   │\n├─────────────────┤ 0xC0000000 (3GB)\n│                 │\n│   User Space    │ (3GB, per-process)\n│   0x00000000+   │\n│                 │\n└─────────────────┘ 0x00000000</code></pre></div>\n\n<p>The kernel is linked to run at 0xC0000000+ but loaded at 0x100000 physical. The page tables create both:</p>\n<ul>\n<li><strong>Identity mapping</strong>: 0x00000000-0x00FFFFFF → 0x00000000-0x00FFFFFF (for VGA, MMIO)</li>\n<li><strong>Higher-half mapping</strong>: 0xC0000000-0xC0FFFFFF → 0x00000000-0x00FFFFFF (for kernel code)</li>\n</ul>\n<h3 id=\"setting-up-the-initial-page-tables\">Setting Up the Initial Page Tables</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KERNEL_VIRTUAL_BASE</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">C0000000</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KERNEL_PHYSICAL_BASE</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">100000</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Identity-map the first N MB and map the kernel at higher half</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> paging_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate page directory</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">dir </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(dir, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Identity map first 16MB (kernel + VGA + MMIO)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This allows VGA at 0xB8000 to still work</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; addr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">; addr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> PAGE_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Supervisor-only, writable, present</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        map_page</span><span style=\"color:#E1E4E8\">(dir, addr, addr, PTE_WRITABLE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Higher-half mapping for kernel (0xC0000000+)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Map first 16MB at 0xC0000000 as well</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; offset </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">; offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> PAGE_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> virt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> KERNEL_VIRTUAL_BASE </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> offset;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> phys </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> offset;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        map_page</span><span style=\"color:#E1E4E8\">(dir, virt, phys, PTE_WRITABLE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_directory </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> dir;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Load CR3 and enable paging</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    load_cr3</span><span style=\"color:#E1E4E8\">(dir);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    enable_paging</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"enabling-paging-the-critical-sequence\">Enabling Paging: The Critical Sequence</h3>\n<p>{{DIAGRAM:diag-paging-enable}}</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> load_cr3</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">dir</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> phys </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)dir;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %0, %%cr3</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(phys));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> enable_paging</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> cr0;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %%cr0, %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(cr0));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cr0 </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 31</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Set PG bit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %0, %%cr0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(cr0));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>CRITICAL</strong>: The identity mapping must exist <em>before</em> you enable paging. The instruction that sets CR0.PG is at some virtual address V. The very next instruction fetch uses V, which must translate to the correct physical address. Without identity mapping, V doesn&#39;t map to anything, and you page fault immediately.</p>\n<h3 id=\"tlb-flushing\">TLB Flushing</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Flush a single TLB entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> invlpg</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">invlpg (%0)</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(addr) : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">memory</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Flush entire TLB (by reloading CR3)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> flush_tlb</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> cr3;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %%cr3, %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(cr3));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %0, %%cr3</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(cr3));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>When to flush:</p>\n<ul>\n<li>After modifying any page table entry: <code>invlpg(addr)</code></li>\n<li>On context switch: reload CR3 (implicit flush)</li>\n<li>After changing page directory entries: reload CR3</li>\n</ul>\n<hr>\n<h2 id=\"page-fault-handler-diagnosis-and-recovery\">Page Fault Handler: Diagnosis and Recovery</h2>\n<p>The page fault handler (exception 14) is your window into the paging system. When a translation fails, the CPU:</p>\n<ol>\n<li>Pushes error code onto stack</li>\n<li>Loads CR2 with the faulting virtual address</li>\n<li>Vectors through IDT to your handler</li>\n</ol>\n<p>{{DIAGRAM:diag-page-fault-handler}}</p>\n<h3 id=\"the-error-code\">The Error Code</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Bit 0 (P): Present\n  0 = page not present\n  1 = protection violation\n\nBit 1 (W): Write\n  0 = read access\n  1 = write access\n\nBit 2 (U): User\n  0 = supervisor mode\n  1 = user mode\n\nBit 3 (R): Reserved bit\n  0 = not caused by reserved bit\n  1 = reserved bit set in page tables\n\nBit 4 (I): Instruction fetch\n  0 = data access\n  1 = instruction fetch (NX bit violation)</code></pre></div>\n\n<h3 id=\"handler-implementation\">Handler Implementation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> page_fault_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> faulting_addr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %%cr2, %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(faulting_addr));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> present </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">(regs->err_code </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> write </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> regs->err_code </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> user </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> regs->err_code </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> reserved </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> regs->err_code </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> exec </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> regs->err_code </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">=== PAGE FAULT ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Faulting address: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, faulting_addr);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Error code: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, regs->err_code);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Cause: \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (present) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Protection violation (\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Page not present (\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (write) </span><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"write \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#B392F0\"> kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"read \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (user) </span><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"user-mode \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#B392F0\"> kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"kernel-mode \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (reserved) </span><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"reserved-bit \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (exec) </span><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"instruction-fetch \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\")</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Print where we were</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"EIP: 0x</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\">, CS: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, regs->eip, regs->cs);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if address is in valid ranges</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (faulting_addr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">100000</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Address in low memory (below 1MB)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (faulting_addr </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> KERNEL_VIRTUAL_BASE </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               faulting_addr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> KERNEL_VIRTUAL_BASE </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Address in kernel space (higher-half)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (faulting_addr </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">100000</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> faulting_addr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Address in identity-mapped region</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Address outside mapped regions</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For now, halt on any page fault</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Later: implement demand paging, copy-on-write, etc.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Page fault - system halted</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"kernel-heap-dynamic-memory-allocation\">Kernel Heap: Dynamic Memory Allocation</h2>\n<h3 id=\"the-need-for-kmalloc\">The Need for kmalloc</h3>\n<p>The frame allocator gives you 4KB chunks. But often you need 100 bytes for a string, or 48 bytes for a process structure. The kernel heap bridges this gap.</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-kmalloc-internals.svg\" alt=\"Kernel Heap Allocator: kmalloc/kfree\"></p>\n<h3 id=\"simple-heap-implementation-linked-list-of-blocks\">Simple Heap Implementation: Linked List of Blocks</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> HEAP_START</span><span style=\"color:#F97583\">    0x</span><span style=\"color:#79B8FF\">C0400000</span><span style=\"color:#6A737D\">  // Virtual address for heap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> HEAP_SIZE</span><span style=\"color:#E1E4E8\">     (</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  // 4MB initial heap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BLOCK_MAGIC</span><span style=\"color:#F97583\">   0x</span><span style=\"color:#79B8FF\">DEADBEEF</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> heap_block {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> magic;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> size;</span><span style=\"color:#6A737D\">          // Size of data area (not including header)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> free;</span><span style=\"color:#6A737D\">               // 1 if free, 0 if allocated</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> heap_block </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">next;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> heap_block </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">prev;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">heap_block_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> heap_block_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">heap_head </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> heap_current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> HEAP_START;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> heap_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate first page for heap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    map_page</span><span style=\"color:#E1E4E8\">(current_directory, heap_current, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)frame, PTE_WRITABLE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize first block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    heap_head </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">heap_block_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)heap_current;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    heap_head->magic </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BLOCK_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    heap_head->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PAGE_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">heap_block_t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    heap_head->free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    heap_head->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    heap_head->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    heap_current </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> PAGE_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Expand heap by one page</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> heap_expand</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">frame) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"kmalloc: out of physical memory</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    map_page</span><span style=\"color:#E1E4E8\">(current_directory, heap_current, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)frame, PTE_WRITABLE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find last block</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    heap_block_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">last </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> heap_head;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (last->next) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        last </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> last->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If last block is free, expand it</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (last->free) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        last->size </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> PAGE_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Create new free block</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        heap_block_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">new_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">heap_block_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)heap_current;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        new_block->magic </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BLOCK_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        new_block->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PAGE_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">heap_block_t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        new_block->free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        new_block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        new_block->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> last;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        last->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    heap_current </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> PAGE_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Align size to 4 bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (size </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find a free block large enough (first-fit)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    heap_block_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> heap_head;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (block) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (block->magic </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> BLOCK_MAGIC) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"kmalloc: heap corruption detected</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (block->free </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> block->size </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> size) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Found a suitable block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Split block if it's much larger</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (block->size </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> size </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">heap_block_t</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                heap_block_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">new_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">heap_block_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)block </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                          sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">heap_block_t</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                new_block->magic </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BLOCK_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                new_block->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> size </span><span style=\"color:#F97583\">-</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">heap_block_t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                new_block->free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                new_block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                new_block->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (block->next) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    block->next->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                block->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            block->free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)block </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">heap_block_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // No suitable block found, expand heap</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    heap_expand</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Try again (should succeed now)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> kfree</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">ptr) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    heap_block_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">heap_block_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)ptr </span><span style=\"color:#F97583\">-</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">heap_block_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (block->magic </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> BLOCK_MAGIC) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"kfree: invalid pointer or heap corruption</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Coalesce with next block if free</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (block->next </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> block->next->free) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        block->size </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">heap_block_t</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> block->next->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->next->next;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (block->next) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            block->next->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Coalesce with previous block if free</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (block->prev </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> block->prev->free) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        block->prev->size </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">heap_block_t</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        block->prev->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->next;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (block->next) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            block->next->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->prev;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"a-simpler-alternative-placement-allocator\">A Simpler Alternative: Placement Allocator</h3>\n<p>For early boot (before heap is ready), a simple bump allocator works:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> placement_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">100000</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Start after kernel</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">placement_alloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Align to 4 bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (size </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)placement_addr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    placement_addr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> addr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>This never frees memory—use only for allocations that persist for the kernel&#39;s lifetime (like the frame bitmap).</p>\n<hr>\n<h2 id=\"hardware-soul-the-physical-reality-of-virtual-memory\">Hardware Soul: The Physical Reality of Virtual Memory</h2>\n<p><strong>TLB miss cost</strong>: A TLB miss triggers a hardware page table walk. On x86, this is 2-4 memory accesses (PD + PT). With DDR4 latency around 70ns, a TLB miss costs 140-280ns. At 3GHz, that&#39;s 400-800 cycles. The TLB is tiny (64-128 entries on modern CPUs) because fully-associative lookups are expensive—every TLB entry must be compared against the virtual address in parallel.</p>\n<p><strong>Cache behavior of page tables</strong>: Page tables live in regular memory and are cached in L1/L2/L3 like any other data. A process with good locality has its page tables hot in cache. A random-access workload (database hash join, graph traversal) thrashes not just data cache but page table cache too.</p>\n<p><strong>Context switch TLB flush</strong>: Reloading CR3 flushes the TLB on x86 (unless PCID is used). This is 100-500 cycles of pure overhead per context switch. This is why kernel threads share the same address space—they don&#39;t need CR3 reload. Linux uses &quot;lazy TLB flushing&quot; for kernel threads.</p>\n<p><strong>Page fault overhead</strong>: A page fault is a full context switch to the kernel, plus CR2 read, plus handler execution, plus potential I/O wait. Even for demand paging from RAM (not disk), this is thousands of cycles. This is why madvise(MADV_WILLNEED) exists—prefault pages before the critical path.</p>\n<p><strong>Memory access pattern matters</strong>: Sequential access through a 4KB page costs 1 TLB miss for 1024 32-bit accesses. Random access across 1000 pages costs 1000 TLB misses. Same data size, 1000x difference in TLB overhead. This is why structure-of-arrays (SoA) beats array-of-structures (AoS) for cache and TLB efficiency.</p>\n<hr>\n<h2 id=\"debugging-memory-management\">Debugging Memory Management</h2>\n<p><strong>Symptom: Immediate page fault when enabling paging</strong></p>\n<ul>\n<li>Identity mapping missing or incorrect</li>\n<li>Check: Is the code you&#39;re executing identity-mapped?</li>\n<li>Debug: Print the virtual address of <code>enable_paging()</code> and verify it maps correctly</li>\n</ul>\n<p><strong>Symptom: Page fault with garbage address (0xCCCCCCCC or similar)</strong></p>\n<ul>\n<li>Uninitialized pointer</li>\n<li>Check: All pointers initialized before use</li>\n<li>Debug: Use magic patterns (0xDEADBEEF) to detect uninitialized memory</li>\n</ul>\n<p><strong>Symptom: Page fault in kernel at reasonable address</strong></p>\n<ul>\n<li>Page not mapped or protection violation</li>\n<li>Check: Is the page table entry present? Writable?</li>\n<li>Debug: Print page directory and page table entries for the faulting address</li>\n</ul>\n<p><strong>Symptom: Random corruption, crashes after varying time</strong></p>\n<ul>\n<li>Double-free in heap allocator</li>\n<li>Buffer overflow</li>\n<li>Use-after-free</li>\n<li>Debug: Add magic numbers to heap blocks, check on alloc/free</li>\n</ul>\n<p><strong>Symptom: System hangs, no interrupts processed</strong></p>\n<ul>\n<li>Ran out of physical frames</li>\n<li>Page table allocation failing silently</li>\n<li>Debug: Track total free frames, warn when low</li>\n</ul>\n<p><strong>Symptom: VGA stops working after enabling paging</strong></p>\n<ul>\n<li>Identity mapping for 0xB8000 missing</li>\n<li>Check: First 16MB identity mapped?</li>\n<li>Debug: Print PTE for address 0xB8000</li>\n</ul>\n<hr>\n<h2 id=\"design-decision-bitmap-vs-free-list-allocator\">Design Decision: Bitmap vs Free-List Allocator</h2>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Bitmap</th>\n<th>Free-List</th>\n<th>Recommendation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Allocation</td>\n<td>O(n) scan for free bit</td>\n<td>O(1) pop from list</td>\n<td>Free-list for speed</td>\n</tr>\n<tr>\n<td>Freeing</td>\n<td>O(1) clear bit</td>\n<td>O(1) push to list</td>\n<td>Equal</td>\n</tr>\n<tr>\n<td>Double-free detection</td>\n<td>Easy (test before clear)</td>\n<td>Hard (corrupts list)</td>\n<td>Bitmap wins</td>\n</tr>\n<tr>\n<td>Memory overhead</td>\n<td>Fixed (1 bit per frame)</td>\n<td>Variable (list pointers)</td>\n<td>Bitmap predictable</td>\n</tr>\n<tr>\n<td>Fragmentation tracking</td>\n<td>Hard to see patterns</td>\n<td>Easy (list order)</td>\n<td>Free-list wins</td>\n</tr>\n<tr>\n<td>Used by Linux</td>\n<td>Buddy allocator (not bitmap)</td>\n<td>Per-zone free lists</td>\n<td>Hybrid</td>\n</tr>\n</tbody></table>\n<p>For a learning OS, start with bitmap for simplicity and double-free detection. A free-list is faster but harder to debug.</p>\n<hr>\n<h2 id=\"knowledge-cascade\">Knowledge Cascade</h2>\n<p>You&#39;ve built the memory management system—the foundation that everything else in your kernel stands on. Here&#39;s where this knowledge connects:</p>\n<p><strong>Container and VM Memory Isolation</strong>: The user/supervisor bits in page table entries are exactly what Docker, KVM, and every sandboxing technology relies on. When a container process tries to read kernel memory, the CPU checks the user bit—0 means supervisor-only, page fault. A missing supervisor bit is a kernel memory disclosure vulnerability (CVE-2019-18683 was exactly this). Hypervisors use the same mechanism: guest physical → host physical mappings with privilege isolation. Understanding page table bits is understanding the attack surface of isolation.</p>\n<p><strong>Memory-Mapped I/O and Device Drivers (Cross-Domain)</strong>: The identity mapping you keep for VGA (0xB8000) is the same technique used for every memory-mapped device: NIC registers, GPU command buffers, DMA engines. A network driver maps the NIC&#39;s BAR (Base Address Register) region and writes descriptor pointers directly. The CPU doesn&#39;t know it&#39;s writing to a device—it&#39;s just a store to a memory address. This is why <code>volatile</code> is mandatory for MMIO: the compiler must not optimize away or reorder these accesses.</p>\n<p><strong>Game Engine Asset Streaming</strong>: The higher-half kernel mapping you implemented teaches address space layout that game engines use for streaming. A game might reserve virtual address 0x10000000-0x20000000 for texture streaming, mapping and unmapping physical pages as assets load/unload. The virtual address stays constant; the backing physical memory changes. This is exactly what your <code>map_page()</code> function does, just called at runtime instead of boot.</p>\n<p><strong>Garbage Collector Write Barriers</strong>: The dirty and accessed bits in page tables are used by generational garbage collectors to track which pages need scanning. A GC can mark all pages read-only, let the dirty bit track which pages were written to, and only scan those pages in the next collection cycle. This is called &quot;page-level write barrier&quot; and reduces GC pause times dramatically for large heaps.</p>\n<p><strong>Page Cache and File-Backed Memory</strong>: The concepts here—virtual to physical mapping, demand allocation, lazy evaluation—are exactly what Linux&#39;s page cache does. When you read a file, Linux doesn&#39;t copy data into your buffer. It maps the file&#39;s page cache pages into your address space. Same physical page, mapped in multiple processes. Copy-on-write (which you can implement by clearing the writable bit) enables fork() efficiency.</p>\n<p><strong>Forward: What You Can Now Build</strong>: With working memory management, you can:</p>\n<ul>\n<li>Implement per-process address spaces (each process gets its own page directory)</li>\n<li>Add demand paging (page fault handler loads from disk)</li>\n<li>Build copy-on-write fork (map pages read-only, copy on write fault)</li>\n<li>Create shared memory for IPC (map same physical pages in multiple processes)</li>\n<li>Implement memory-mapped files (map file contents into address space)</li>\n</ul>\n<hr>\n<h2 id=\"summary\">Summary</h2>\n<p>You&#39;ve built the memory management layer that transforms physical RAM into virtual address spaces:</p>\n<ol>\n<li><strong>Physical memory map</strong>: Parse E820/multiboot to discover usable, reserved, and ACPI regions</li>\n<li><strong>Frame allocator</strong>: Bitmap or free-list tracking of 4KB frames with double-free detection</li>\n<li><strong>Page tables</strong>: Two-level hierarchy (PD + PT) translating 32-bit virtual to physical addresses</li>\n<li><strong>Identity + higher-half mapping</strong>: Low memory identity-mapped for VGA/MMIO; kernel at 0xC0000000+</li>\n<li><strong>Paging enablement</strong>: Load CR3, set CR0.PG, maintain TLB coherence with invlpg</li>\n<li><strong>Page fault handler</strong>: Read CR2 for faulting address, diagnose from error code</li>\n<li><strong>Kernel heap</strong>: kmalloc/kfree providing arbitrary-size allocations backed by frame allocator</li>\n</ol>\n<p>The revelation: memory is not a byte array. It&#39;s a two-level translation structure cached in a tiny, non-coherent TLB. Every access walks this hierarchy or hits the cache. Modify a page table entry, and the CPU will happily use stale translations until you explicitly invalidate them.</p>\n<p>The physical constraints—4KB frames, two-level translation, TLB cache behavior, CR3 reload cost—shape every decision. This is systems programming: negotiating with hardware, not abstracting it away.</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-satellite-system.svg\" alt=\"OS Kernel Architecture: Satellite View\"></p>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-os-m4 -->\n<h1 id=\"milestone-4-processes-and-preemptive-scheduling\">Milestone 4: Processes and Preemptive Scheduling</h1>\n<h2 id=\"the-tension-one-cpu-many-tasksthe-illusion-of-simultaneity\">The Tension: One CPU, Many Tasks—The Illusion of Simultaneity</h2>\n<p>You have one CPU core. Your user wants to type in a text editor while music plays in the background and a compiler runs in another window. Three distinct instruction streams, one execution engine.</p>\n<p>The hardware offers no magic &quot;run multiple things&quot; instruction. What it does offer is precise enough to build the illusion yourself:</p>\n<ul>\n<li><strong>Timer interrupt</strong>: Fire IRQ0 every N milliseconds, giving you a foothold back in the kernel</li>\n<li><strong>Register save/restore</strong>: Push all registers to memory, pop them back—exactly the mechanism function calls use, applied to an entire process</li>\n<li><strong>Privilege levels</strong>: Ring 0 (kernel) and ring 3 (user) with hardware-enforced boundaries</li>\n</ul>\n<p>But here&#39;s the brutal constraint: when the timer fires, the currently running process is mid-instruction. Its EIP points somewhere in its code. Its stack has local variables. Its registers hold intermediate computation results. If you don&#39;t save <em>every single byte of state</em> and restore it perfectly later, that process crashes—or worse, produces silent corruption.</p>\n<p>The numbers that matter:</p>\n<ul>\n<li><strong>Context switch overhead</strong>: 100-500 cycles saving/restoring registers, plus TLB flush if address spaces differ</li>\n<li><strong>Timer quantum</strong>: 10ms typical (100Hz timer), meaning 10-50ms of useful work between switches</li>\n<li><strong>Cache impact</strong>: A process evicts ~100KB of L1 cache per millisecond; after 10ms, the next process finds a cold cache</li>\n<li><strong>TLB entries</strong>: 64-128 entries, all flushed on CR3 reload—every virtual address translation starts cold</li>\n</ul>\n<p>This milestone implements preemptive multitasking: the mechanism by which your kernel creates the illusion of parallelism through rapid, precise, hardware-assisted context switching.</p>\n<hr>\n<h2 id=\"revelation-it39s-not-parallelismit39s-perfect-amnesia\">Revelation: It&#39;s Not Parallelism—It&#39;s Perfect Amnesia</h2>\n<p><strong>What you might think</strong>: &quot;The scheduler runs multiple processes at once, switching between them so fast they all appear to run simultaneously.&quot;</p>\n<p><strong>What actually happens</strong>:</p>\n<p>Only ONE process executes at any instant. The &quot;concurrent&quot; illusion requires this exact sequence:</p>\n<ol>\n<li>Timer interrupt fires (IRQ0 → IDT vector 32)</li>\n<li>CPU pushes EFLAGS, CS, EIP onto current stack (and SS:ESP if ring 3 → ring 0)</li>\n<li>Your IRQ handler saves <em>every other register</em> to the current process&#39;s PCB</li>\n<li>Scheduler picks the next ready process</li>\n<li>Your context switch code loads the new process&#39;s saved registers</li>\n<li>TSS.ESP0 is updated to the new process&#39;s kernel stack</li>\n<li><code>iret</code> pops EFLAGS, CS, EIP—and you&#39;re now running the new process</li>\n</ol>\n<p>{{DIAGRAM:diag-context-switch-flow}}</p>\n<p>The magic: the interrupted process has <strong>zero awareness</strong> it was suspended. When it resumes later, its registers are restored, its stack is intact, its EIP points to the next instruction—and it continues as if nothing happened.</p>\n<p>But here&#39;s what surprises most developers: <strong>system calls are not function calls</strong>.</p>\n<p>When user code executes <code>int 0x80</code>, the CPU:</p>\n<ol>\n<li>Looks up IDT entry 0x80</li>\n<li>Checks privilege transition (DPL of gate vs CPL of caller)</li>\n<li><strong>Switches stacks</strong> using TSS.SS0:ESP0</li>\n<li>Pushes user SS, ESP, EFLAGS, CS, EIP</li>\n<li>Loads kernel CS:EIP from IDT entry</li>\n<li>Begins executing kernel code at ring 0</li>\n</ol>\n<p>You cannot implement this with a function call. The hardware <em>must</em> be involved because ring transitions require stack switching for security—the kernel stack is not accessible from user mode, so the CPU can&#39;t trust a user-supplied stack pointer.</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-ring-transition.svg\" alt=\"Ring 3 → Ring 0 Transition: Stack Switch\"></p>\n<p>And the TSS (Task State Segment)? Not optional. Without TSS.SS0:ESP0 configured, the CPU has nowhere to put the kernel stack during a ring 3 → ring 0 transition. The result: triple fault, system reset.</p>\n<hr>\n<h2 id=\"system-map-where-we-are\">System Map: Where We Are</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>┌─────────────────────────────────────────────────────────────────┐\n│                         YOUR OS KERNEL                          │\n│                                                                 │\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │\n│  │    PCB      │  │   Context   │  │     TSS     │             │\n│  │   Manager   │  │   Switch    │  │   Config    │             │\n│  │  (create,   │  │  (assembly) │  │  (SS0:ESP0) │             │\n│  │   destroy)  │  │             │  │             │             │\n│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘             │\n│         │                │                │                     │\n│         └────────────────┼────────────────┘                     │\n│                          │                                      │\n│  ┌───────────────────────┴───────────────────────┐             │\n│  │                 SCHEDULER                      │             │\n│  │  Round-robin: timer IRQ → pick next → switch   │             │\n│  └───────────────────────┬───────────────────────┘             │\n│                          │                                      │\n│         ┌────────────────┼────────────────┐                     │\n│         ↓                ↓                ↓                     │\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │\n│  │  Process A  │  │  Process B  │  │  Process C  │             │\n│  │  (running)  │  │   (ready)   │  │   (ready)   │             │\n│  │   ring 0    │  │   ring 0    │  │   ring 3    │             │\n│  └─────────────┘  └─────────────┘  └─────────────┘             │\n│                                                                 │\n│  ┌─────────────────────────────────────────────────────────────┐│\n│  │                    HARDWARE                                 ││\n│  │  Timer IRQ0 → IDT → Scheduler → Context Switch → iret      ││\n│  │  TSS provides SS0:ESP0 for ring 3→0 stack switch          ││\n│  └─────────────────────────────────────────────────────────────┘│\n└─────────────────────────────────────────────────────────────────┘</code></pre></div>\n\n<p>We&#39;re building the process management layer: PCB structures to hold process state, context switch assembly to swap register sets, TSS configuration for privilege transitions, a round-robin scheduler, and system call infrastructure.</p>\n<hr>\n<h2 id=\"the-process-control-block-capturing-a-process39s-soul\">The Process Control Block: Capturing a Process&#39;s Soul</h2>\n<h3 id=\"what-must-be-saved\">What Must Be Saved</h3>\n<p>A process is defined entirely by its register state and memory. To suspend and resume it perfectly, you need:</p>\n<p>{{DIAGRAM:diag-pcb-structure}}</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROCESS_READY,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROCESS_RUNNING,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROCESS_BLOCKED,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROCESS_ZOMBIE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">process_state_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> process {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Identification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pid;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_state_t</span><span style=\"color:#E1E4E8\"> state;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Register state (saved on context switch)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eax, ebx, ecx, edx;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esi, edi, ebp;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esp, eip;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eflags;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> cs, ds, es, fs, gs, ss;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Memory management</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">page_directory;</span><span style=\"color:#6A737D\">  // Virtual address space</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> kernel_stack;</span><span style=\"color:#6A737D\">             // Top of kernel stack (for TSS.ESP0)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Scheduling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> process </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">next;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> process </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">prev;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> wake_time;</span><span style=\"color:#6A737D\">                // For sleep/wakeup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p>The fields fall into categories:</p>\n<p><strong>Register state</strong>: Everything the CPU uses. Miss one, and the resumed process corrupts data or crashes.</p>\n<p><strong>Memory management</strong>: Each process gets its own page directory (address space isolation). The kernel stack pointer is crucial—when a user-mode process traps to the kernel (interrupt or syscall), the CPU switches to this stack.</p>\n<p><strong>Scheduling</strong>: Linked list pointers for the run queue, plus any state for blocking/waking.</p>\n<h3 id=\"pcb-storage\">PCB Storage</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_PROCESSES</span><span style=\"color:#79B8FF\"> 64</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KERNEL_STACK_SIZE</span><span style=\"color:#79B8FF\"> 4096</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> process_t</span><span style=\"color:#FFAB70\"> process_table</span><span style=\"color:#E1E4E8\">[MAX_PROCESSES];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> next_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">current_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">ready_queue </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">create_process</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">entry_point)(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> is_user</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find free slot</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> MAX_PROCESSES; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">process_table</span><span style=\"color:#E1E4E8\">[i].state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PROCESS_ZOMBIE </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            process_table</span><span style=\"color:#E1E4E8\">[i].pid </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#FFAB70\">process_table</span><span style=\"color:#E1E4E8\">[i];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">proc) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Process table full</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize PCB</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(proc, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next_pid</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strncpy</span><span style=\"color:#E1E4E8\">(proc->name, name, </span><span style=\"color:#79B8FF\">15</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PROCESS_READY;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate kernel stack</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">stack_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->kernel_stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)stack_frame </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> KERNEL_STACK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set up initial register state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->eip </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)entry_point;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->esp </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc->kernel_stack;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->ebp </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc->kernel_stack;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->eflags </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">202</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // IF=1 (interrupts enabled), bit 1 always set</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Segment selectors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (is_user) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->cs </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">1B</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // User code selector (ring 3)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->ds </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc->es </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc->fs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc->gs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc->ss </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">23</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // User data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->esp </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">BFFFFFFF</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // User stack at top of user space</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Create user page directory (copy kernel mappings)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->page_directory </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> clone_page_directory</span><span style=\"color:#E1E4E8\">(current_directory);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->cs </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Kernel code selector (ring 0)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->ds </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc->es </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc->fs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc->gs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc->ss </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Kernel data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->page_directory </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current_directory;</span><span style=\"color:#6A737D\">  // Share kernel space</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add to ready queue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ready_queue;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ready_queue) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ready_queue->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ready_queue </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> proc;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"setting-up-the-first-process\">Setting Up the First Process</h3>\n<p>The first process isn&#39;t &quot;created&quot;—it <em>is</em> the kernel&#39;s current execution state. You construct its PCB by capturing what&#39;s already running:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create PCB for current (kernel) process</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">kernel_proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#FFAB70\">process_table</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(kernel_proc, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    kernel_proc->pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next_pid</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strcpy</span><span style=\"color:#E1E4E8\">(kernel_proc->name, </span><span style=\"color:#9ECBFF\">\"kernel\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    kernel_proc->state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PROCESS_RUNNING;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    kernel_proc->page_directory </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current_directory;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    kernel_proc->kernel_stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">90000</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Current kernel stack</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> kernel_proc;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"context-switch-the-assembly-core\">Context Switch: The Assembly Core</h2>\n<h3 id=\"why-assembly-is-mandatory\">Why Assembly is Mandatory</h3>\n<p>C provides no control over:</p>\n<ul>\n<li>Which registers are saved and in what order</li>\n<li>Stack pointer manipulation during the save</li>\n<li>The exact layout of the register dump</li>\n<li>Loading CR3 (page directory base)</li>\n</ul>\n<p>The context switch must be written in assembly.</p>\n<p>{{DIAGRAM:diag-context-switch-flow}}</p>\n<h3 id=\"the-assembly-implementation\">The Assembly Implementation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; context_switch.asm\n; void context_switch(process_t *old, process_t *new)\n\nglobal context_switch\nextern current_process\n\nsection .text\n\n; Process struct offsets (must match C struct)\n%define PCB_PID         0\n%define PCB_EAX         8\n%define PCB_EBX         12\n%define PCB_ECX         16\n%define PCB_EDX         20\n%define PCB_ESI         24\n%define PCB_EDI         28\n%define PCB_EBP         32\n%define PCB_ESP         36\n%define PCB_EIP         40\n%define PCB_EFLAGS      44\n%define PCB_CS          48\n%define PCB_DS          52\n%define PCB_ES          56\n%define PCB_FS          60\n%define PCB_GS          64\n%define PCB_SS          68\n%define PCB_PAGE_DIR    72\n%define PCB_KERNEL_STACK 76\n\ncontext_switch:\n    ; Arguments: [esp+4] = old process, [esp+8] = new process\n    push ebp\n    mov ebp, esp\n    \n    pushfd                    ; Save EFLAGS\n    pushad                    ; Save EAX, ECX, EDX, EBX, ESP (old), EBP, ESI, EDI\n    \n    ; Save segment registers\n    push ds\n    push es\n    push fs\n    push gs\n    \n    ; Get pointer to old process\n    mov eax, [ebp + 8]        ; old process pointer\n    test eax, eax\n    jz .load_new              ; If old is NULL, skip saving\n    \n    ; Save registers to old PCB\n    mov [eax + PCB_EAX], eax  ; ... actually need to be careful here\n    ; Better: use edi as temp since we pushed it\n    \n    ; Actually, reload old pointer and save properly\n    mov edi, [ebp + 8]        ; old process\n    \n    ; Get stack position before we pushed stuff\n    mov ecx, [ebp - 4]        ; pushed ebp\n    mov [edi + PCB_EBP], ecx\n    \n    ; We need the ESP value from BEFORE pushad\n    ; pushad pushes: EAX, ECX, EDX, EBX, ESP(original), EBP, ESI, EDI\n    ; The ESP in pushad is at offset 16 from start of pushad area\n    mov ecx, [esp + 16]       ; Original ESP from pushad\n    mov [edi + PCB_ESP], ecx\n    \n    ; Save other registers from pushad\n    mov ecx, [esp + 0]        ; EDI\n    mov [edi + PCB_EDI], ecx\n    mov ecx, [esp + 4]        ; ESI\n    mov [edi + PCB_ESI], ecx\n    mov ecx, [esp + 20]       ; EBX\n    mov [edi + PCB_EBX], ecx\n    mov ecx, [esp + 24]       ; EDX\n    mov [edi + PCB_EDX], ecx\n    mov ecx, [esp + 28]       ; ECX\n    mov [edi + PCB_ECX], ecx\n    mov ecx, [esp + 32]       ; EAX\n    mov [edi + PCB_EAX], ecx\n    \n    ; Save EFLAGS\n    mov ecx, [esp + 36]       ; EFLAGS (after pushad + segs)\n    add ecx, 16               ; Adjust for segment registers\n    mov [edi + PCB_EFLAGS], ecx\n    \n    ; Save instruction pointer (return address from context_switch call)\n    mov ecx, [ebp + 4]\n    mov [edi + PCB_EIP], ecx\n    \n    ; Save segment registers\n    mov [edi + PCB_DS], ds\n    mov [edi + PCB_ES], es\n    mov [edi + PCB_FS], fs\n    mov [edi + PCB_GS], gs\n    mov [edi + PCB_CS], cs\n    mov [edi + PCB_SS], ss\n\n.load_new:\n    ; Load new process\n    mov esi, [ebp + 12]       ; new process\n    \n    ; Update current_process\n    mov [current_process], esi\n    \n    ; Load page directory if different\n    mov eax, [current_directory]\n    mov ebx, [esi + PCB_PAGE_DIR]\n    cmp eax, ebx\n    je .same_page_dir\n    \n    ; Switch to new page directory\n    mov cr3, ebx\n    mov [current_directory], ebx\n    \n.same_page_dir:\n    ; Update TSS.ESP0 for ring 3 processes\n    extern tss_update_esp0\n    push dword [esi + PCB_KERNEL_STACK]\n    call tss_update_esp0\n    add esp, 4\n    \n    ; Restore segment registers\n    mov ds, [esi + PCB_DS]\n    mov es, [esi + PCB_ES]\n    mov fs, [esi + PCB_FS]\n    mov gs, [esi + PCB_GS]\n    \n    ; Restore general registers\n    mov eax, [esi + PCB_EAX]\n    mov ebx, [esi + PCB_EBX]\n    mov ecx, [esi + PCB_ECX]\n    mov edx, [esi + PCB_EDX]\n    mov edi, [esi + PCB_EDI]\n    \n    ; Restore stack pointer and EBP\n    mov esp, [esi + PCB_ESP]\n    mov ebp, [esi + PCB_EBP]\n    \n    ; Restore ESI last (we were using it)\n    mov esi, [esi + PCB_ESI]\n    \n    ; Restore EFLAGS and return\n    pushfd\n    popfd\n    \n    ret</code></pre></div>\n\n<h3 id=\"a-cleaner-approach-using-iret\">A Cleaner Approach: Using iret</h3>\n<p>A more robust approach uses <code>iret</code> to restore EIP, CS, EFLAGS, and optionally ESP/SS:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; Simpler context switch using iret\nglobal switch_to_process\n\nswitch_to_process:\n    ; [esp+4] = new process PCB pointer\n    mov eax, [esp + 4]\n    \n    ; Update current_process global\n    extern current_process\n    mov [current_process], eax\n    \n    ; Switch page directory\n    mov ebx, [eax + PCB_PAGE_DIR]\n    mov cr3, ebx\n    \n    ; Update TSS.ESP0\n    extern tss\n    mov ecx, [eax + PCB_KERNEL_STACK]\n    mov [tss + 4], ecx        ; tss.esp0 offset\n    \n    ; Set up stack for iret\n    ; Need: EIP, CS, EFLAGS, (ESP, SS if user mode)\n    mov ebx, [eax + PCB_ESP]\n    mov ecx, [eax + PCB_EFLAGS]\n    mov edx, [eax + PCB_EIP]\n    \n    ; Check if user mode (CS = 0x1B)\n    cmp word [eax + PCB_CS], 0x1B\n    je .user_mode\n    \n.kernel_mode:\n    ; Build kernel-mode iret frame\n    push ecx                  ; EFLAGS\n    push dword [eax + PCB_CS] ; CS\n    push edx                  ; EIP\n    push dword [eax + PCB_GS]\n    push dword [eax + PCB_FS]\n    push dword [eax + PCB_ES]\n    push dword [eax + PCB_DS]\n    push dword [eax + PCB_EDI]\n    push dword [eax + PCB_ESI]\n    push dword [eax + PCB_EBP]\n    push ebx                  ; ESP (will be loaded before iret)\n    push dword [eax + PCB_EBX]\n    push dword [eax + PCB_EDX]\n    push dword [eax + PCB_ECX]\n    push dword [eax + PCB_EAX]\n    \n    ; Restore registers\n    pop eax\n    pop ecx\n    pop edx\n    pop ebx\n    add esp, 4                ; Skip ESP (already set)\n    pop ebp\n    pop esi\n    pop edi\n    pop ds\n    pop es\n    pop fs\n    pop gs\n    \n    iret\n    \n.user_mode:\n    ; Build user-mode iret frame (includes SS:ESP)\n    push dword [eax + PCB_SS] ; User SS\n    push ebx                  ; User ESP\n    push ecx                  ; EFLAGS\n    push dword [eax + PCB_CS] ; User CS\n    push edx                  ; EIP\n    ; ... restore other registers ...\n    iret</code></pre></div>\n\n<hr>\n<h2 id=\"the-tss-required-for-ring-transitions\">The TSS: Required for Ring Transitions</h2>\n<h3 id=\"what-the-tss-does-and-doesn39t-do\">What the TSS Does (and Doesn&#39;t Do)</h3>\n<p>The <strong>Task State Segment</strong> is a holdover from Intel&#39;s original multitasking design. Modern OSes use it for exactly one thing: <strong>stack switching on privilege transitions</strong>.</p>\n<p>{{DIAGRAM:diag-tss-structure}}</p>\n<p>When the CPU transitions from ring 3 to ring 0 (via interrupt, exception, or syscall), it needs a trusted stack. It can&#39;t use the user&#39;s stack—that would be a security hole. So it loads SS:ESP from TSS.SS0:ESP0.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// TSS structure (only essential fields shown)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> prev_task;</span><span style=\"color:#6A737D\">       // 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved0;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esp0;</span><span style=\"color:#6A737D\">            // 4: Stack pointer for ring 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ss0;</span><span style=\"color:#6A737D\">             // 8: Stack segment for ring 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved1;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esp1;</span><span style=\"color:#6A737D\">            // 12: For ring 1 (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ss1;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved2;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esp2;</span><span style=\"color:#6A737D\">            // 20: For ring 2 (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ss2;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved3;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> cr3;</span><span style=\"color:#6A737D\">             // 28: Page directory (not used for software switching)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eip;</span><span style=\"color:#6A737D\">             // 32</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eflags;</span><span style=\"color:#6A737D\">          // 36</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eax, ecx, edx, ebx, esp, ebp, esi, edi;</span><span style=\"color:#6A737D\">  // 40-64</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> es;</span><span style=\"color:#6A737D\">              // 68</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved4;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> cs;</span><span style=\"color:#6A737D\">              // 72</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved5;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ss;</span><span style=\"color:#6A737D\">              // 76</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved6;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ds;</span><span style=\"color:#6A737D\">              // 80</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved7;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> fs;</span><span style=\"color:#6A737D\">              // 84</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved8;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> gs;</span><span style=\"color:#6A737D\">              // 88</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved9;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ldt;</span><span style=\"color:#6A737D\">             // 92</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved10;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> trap;</span><span style=\"color:#6A737D\">            // 96</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> iomap_base;</span><span style=\"color:#6A737D\">      // 102</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed)) </span><span style=\"color:#79B8FF\">tss_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> tss_t</span><span style=\"color:#E1E4E8\"> tss;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tss_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tss, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tss_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tss.ss0 </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">           // Kernel data segment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tss.esp0 </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">90000</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">       // Initial kernel stack (will be updated)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tss.iomap_base </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tss_t</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // No I/O bitmap</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add TSS to GDT (entry 5)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TSS descriptor is a system segment (S=0 in access byte)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> base </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tss;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> limit </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tss_t</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gdt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">, base, limit, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">E9</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Present, ring 0, TSS type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Load TR (Task Register)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">ltr %w0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">28</span><span style=\"color:#E1E4E8\">));</span><span style=\"color:#6A737D\">  // Selector: index 5, TI=0, RPL=0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tss_update_esp0</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> esp0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tss.esp0 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> esp0;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"when-tssesp0-must-be-updated\">When TSS.ESP0 Must Be Updated</h3>\n<p>Every time you switch to a new process that might run in user mode, you must update TSS.ESP0 to point to that process&#39;s kernel stack:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_yield</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">old </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current_process;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">new </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pick_next_process</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (new </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> new </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> old) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        old->state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PROCESS_READY;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        new->state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PROCESS_RUNNING;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Critical: update TSS before context switch</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        tss_update_esp0</span><span style=\"color:#E1E4E8\">(new->kernel_stack);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        context_switch</span><span style=\"color:#E1E4E8\">(old, new);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>If you forget this, a user-mode process traps to the kernel with a stale ESP0, and the kernel stack pointer points to the <em>previous</em> process&#39;s stack. Corruption ensues.</p>\n<hr>\n<h2 id=\"round-robin-scheduler-the-heart-of-multitasking\">Round-Robin Scheduler: The Heart of Multitasking</h2>\n<h3 id=\"the-algorithm\">The Algorithm</h3>\n<p>Round-robin is the simplest fair scheduling algorithm:</p>\n<ol>\n<li>Maintain a queue of READY processes</li>\n<li>On timer interrupt, move current process to end of queue</li>\n<li>Pick the first READY process</li>\n<li>Context switch to it</li>\n</ol>\n<p>{{DIAGRAM:diag-scheduler-queue}}</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_tick</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Called from timer interrupt handler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">current_process) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Scheduler not initialized</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Current process used its time slice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Move it to the back of the ready queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (current_process->state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PROCESS_RUNNING) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current_process->state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PROCESS_READY;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Move to end of queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (ready_queue </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> ready_queue->next) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">last </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ready_queue;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            while</span><span style=\"color:#E1E4E8\"> (last->next) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                last </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> last->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Remove current from front</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ready_queue </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current_process->next;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (ready_queue) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                ready_queue->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Add to back</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            last->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current_process;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current_process->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> last;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current_process->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Pick next process</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ready_queue;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (next) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (next->state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PROCESS_READY) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (next </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> next </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> current_process) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        schedule_switch</span><span style=\"color:#E1E4E8\">(next);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> schedule_switch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">next</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current_process;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    next->state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PROCESS_RUNNING;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remove from ready queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (next->prev) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        next->prev->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ready_queue </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (next->next) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        next->next->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next->prev;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    next->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    next->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update TSS before switch</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    tss_update_esp0</span><span style=\"color:#E1E4E8\">(next->kernel_stack);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Perform context switch</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    context_switch</span><span style=\"color:#E1E4E8\">(prev, next);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"integration-with-timer-interrupt\">Integration with Timer Interrupt</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In interrupt handler (from Milestone 2)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> irq_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> irq </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> regs->int_no </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> (irq) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#6A737D\">  // Timer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            timer_ticks</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            scheduler_tick</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#6A737D\">  // Keyboard</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            keyboard_handler</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // ... other IRQs ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pic_send_eoi</span><span style=\"color:#E1E4E8\">(irq);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"demonstration-three-kernel-processes\">Demonstration: Three Kernel Processes</h2>\n<p>To prove preemptive multitasking works, create three processes that each print to a different screen region:</p>\n<p>{{DIAGRAM:diag-multi-process-demo}}</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> process_a</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_set_cursor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[Process A] Count: \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_put_dec</span><span style=\"color:#E1E4E8\">(count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Busy loop to consume time slice</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> process_b</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_set_cursor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[Process B] Count: \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_put_dec</span><span style=\"color:#E1E4E8\">(count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> process_c</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_set_cursor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[Process C] Count: \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_put_dec</span><span style=\"color:#E1E4E8\">(count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> demo_multitasking</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Creating kernel processes...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    create_process</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"proc_a\"</span><span style=\"color:#E1E4E8\">, process_a, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 0 = kernel mode</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    create_process</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"proc_b\"</span><span style=\"color:#E1E4E8\">, process_b, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    create_process</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"proc_c\"</span><span style=\"color:#E1E4E8\">, process_c, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Enabling scheduler...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Enable timer interrupt</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> mask </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> inb</span><span style=\"color:#E1E4E8\">(PIC1_DATA);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mask </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> ~0x</span><span style=\"color:#79B8FF\">01</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Enable IRQ0</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(PIC1_DATA, mask);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Enable interrupts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">sti</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Yield to let scheduler take over</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scheduler_yield</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // We never reach here</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The three counters increment independently, each process unaware it&#39;s being interrupted dozens of times per second.</p>\n<hr>\n<h2 id=\"user-mode-crossing-the-ring-boundary\">User Mode: Crossing the Ring Boundary</h2>\n<h3 id=\"creating-a-user-process\">Creating a User Process</h3>\n<p>A user process differs from a kernel process in three ways:</p>\n<ol>\n<li><strong>Segment selectors</strong>: CS=0x1B, DS/ES/SS=0x23 (ring 3, CPL=3)</li>\n<li><strong>Page directory</strong>: Isolated from kernel, with kernel pages marked supervisor-only</li>\n<li><strong>Stack</strong>: Located in user space, not kernel space</li>\n</ol>\n<p>{{DIAGRAM:diag-user-kernel-memory}}</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">create_user_process</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">entry)(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_process</span><span style=\"color:#E1E4E8\">(name, entry, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">proc) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate user stack (at top of user space: 0xBFFFF000)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> user_stack_virt </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">BFFFF000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">user_stack_phys </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Map user stack in process's page directory</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    map_page</span><span style=\"color:#E1E4E8\">(proc->page_directory, user_stack_virt, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">             (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)user_stack_phys, PTE_WRITABLE </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PTE_USER);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->esp </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> user_stack_virt </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> PAGE_SIZE;</span><span style=\"color:#6A737D\">  // Top of stack</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->ss </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">23</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // User data segment (ring 3)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Copy user code (for now, assume it's somewhere in kernel memory)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // In a real OS, you'd load from an executable file</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> proc;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"entering-user-mode-the-iret-trick\">Entering User Mode: The iret Trick</h3>\n<p>To transition from kernel to user mode, you use <code>iret</code> with a specially crafted stack frame:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; enter_user_mode(entry_point, user_stack_top)\nglobal enter_user_mode\n\nenter_user_mode:\n    mov eax, [esp + 4]    ; Entry point\n    mov ebx, [esp + 8]    ; User stack top\n    \n    ; Set up segment registers for user mode\n    mov cx, 0x23          ; User data selector\n    mov ds, cx\n    mov es, cx\n    mov fs, cx\n    mov gs, cx\n    \n    ; Push user mode stack frame for iret\n    push 0x23             ; SS (user data)\n    push ebx              ; ESP (user stack)\n    pushf                 ; EFLAGS\n    push 0x1B             ; CS (user code)\n    push eax              ; EIP (entry point)\n    \n    ; Enable interrupts in EFLAGS\n    or dword [esp + 8], 0x200\n    \n    ; Jump to user mode\n    iret</code></pre></div>\n\n<p>The <code>iret</code> instruction pops SS, ESP, EFLAGS, CS, EIP from the stack. Because CS=0x1B (CPL=3), the CPU transitions to ring 3, loads the user stack from your pushed value, and begins executing user code.</p>\n<h3 id=\"isolation-verification\">Isolation Verification</h3>\n<p>A user process should NOT be able to access kernel memory:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> user_process_test</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This should trigger a page fault</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">kernel_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">C0100000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">kernel_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">DEADBEEF</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Write to kernel memory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should never reach here</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sys_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"This should never print</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>When this runs in ring 3, the page table entry for 0xC0100000 has the user/supervisor bit clear (supervisor-only). The CPU raises a page fault with error code bit 2 set (user-mode access).</p>\n<hr>\n<h2 id=\"system-calls-user-to-kernel-communication\">System Calls: User-to-Kernel Communication</h2>\n<h3 id=\"the-int-0x80-interface\">The INT 0x80 Interface</h3>\n<p>System calls use software interrupts to transition from user to kernel mode. The convention:</p>\n<ul>\n<li><strong>EAX</strong>: System call number</li>\n<li><strong>EBX, ECX, EDX</strong>: Arguments (up to 3)</li>\n<li><strong>EAX (return)</strong>: Return value</li>\n</ul>\n<p>{{DIAGRAM:diag-syscall-interface}}</p>\n<h3 id=\"setting-up-the-syscall-gate\">Setting Up the Syscall Gate</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SYSCALL_WRITE</span><span style=\"color:#79B8FF\">  0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SYSCALL_EXIT</span><span style=\"color:#79B8FF\">   1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SYSCALL_READ</span><span style=\"color:#79B8FF\">   2</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> syscall_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> (regs->eax) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> SYSCALL_WRITE:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // sys_write(fd, buf, len)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            regs->eax </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> sys_write</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)regs</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">ebx</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                (</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)regs</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">ecx</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)regs</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">edx</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            );</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> SYSCALL_EXIT:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // sys_exit(status)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            sys_exit</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)regs</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">ebx</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> SYSCALL_READ:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // sys_read(fd, buf, len)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            regs->eax </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> sys_read</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)regs</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">ebx</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                (</span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)regs</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">ecx</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)regs</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">edx</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            );</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Unknown syscall: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, regs</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">eax</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            regs->eax </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> syscall_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Register syscall handler at IDT entry 0x80</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // DPL=3 allows user mode to call via INT 0x80</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)isr128, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">EE</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 0xEE = DPL 3, present, interrupt gate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"implementing-sys_write\">Implementing sys_write</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> sys_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> len</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validate file descriptor</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> MAX_FDS) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // EBADF</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validate buffer pointer (must be in user space)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)buf </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> KERNEL_VIRTUAL_BASE) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // EFAULT</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For now, just write to VGA</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> len; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_putchar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> len;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"implementing-sys_exit\">Implementing sys_exit</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> sys_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> status</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Process </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> exiting with status </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current_process->pid, status);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mark process as zombie</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_process->state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PROCESS_ZOMBIE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Free resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (current_process->page_directory </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> current_directory) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Free user page directory and frames</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // (implementation depends on your memory manager)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remove from ready queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (current_process->prev) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current_process->prev->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current_process->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (current_process->next) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current_process->next->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current_process->prev;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Schedule next process</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scheduler_yield</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Never returns</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"user-space-syscall-wrapper\">User-Space Syscall Wrapper</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In user code (or a libc-like library)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> syscall0</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> num</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">int $0x80</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=a</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(ret) : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">a</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(num));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> syscall3</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> b</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> c</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">int $0x80</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=a</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(ret) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">a</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(num), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">b</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(a), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">c</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(b), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(c));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> user_print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> len </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#E1E4E8\">[len]) len</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    syscall3</span><span style=\"color:#E1E4E8\">(SYSCALL_WRITE, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)msg, len);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> user_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> status</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    syscall1</span><span style=\"color:#E1E4E8\">(SYSCALL_EXIT, status);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"hardware-soul-the-physical-cost-of-multitasking\">Hardware Soul: The Physical Cost of Multitasking</h2>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-cache-analysis-context-switch.svg\" alt=\"Context Switch: Cache and TLB Impact\"></p>\n<p><strong>Context switch overhead breakdown</strong>:</p>\n<ul>\n<li>Register save/restore: 50-100 cycles (pushad/popad + segments)</li>\n<li>CR3 reload: 10-20 cycles, plus TLB flush cost</li>\n<li>TLB refill: 100-500 cycles per miss, ~64 entries = potentially 32,000 cycles worst case</li>\n<li>Cache cold start: L1 miss is ~4 cycles, L2 miss is ~12 cycles, L3 miss is ~40 cycles, memory is ~150 cycles</li>\n</ul>\n<p><strong>The TLB flush problem</strong>: Reloading CR3 flushes the TLB (unless PCID is used). A process with good locality might have 50 TLB entries populated. After a switch, all 50 are gone. The next instruction might trigger a TLB miss, then another, then another. This is why kernel threads share the same address space—no TLB flush.</p>\n<p><strong>Cache pollution</strong>: Process A runs for 10ms, filling L1 with its data. Context switch to process B. Process B&#39;s working set evicts process A&#39;s. When process A runs again, it finds a cold cache. This is the working set size problem: if a process&#39;s working set exceeds L1 cache, it suffers cache misses every time it&#39;s scheduled.</p>\n<p><strong>Interrupt latency vs scheduling latency</strong>: Timer interrupt fires every 10ms. But if you&#39;re in an interrupt handler or critical section with interrupts disabled, the scheduler can&#39;t run. Worst-case scheduling latency = timer quantum + maximum interrupt handler time + maximum critical section time. This is why real-time systems minimize interrupt handler work and keep critical sections short.</p>\n<p><strong>The scheduling granularity trade-off</strong>:</p>\n<ul>\n<li>Shorter quantum (1ms): Better responsiveness, more context switch overhead</li>\n<li>Longer quantum (100ms): Less overhead, worse interactivity</li>\n</ul>\n<p>At 100Hz (10ms quantum) with 5 processes, each gets 2 CPU seconds per wall-clock second. But context switch overhead at 100Hz is 0.1% of CPU time—negligible. At 1000Hz, it&#39;s 1%. At 10000Hz, it&#39;s 10%. There&#39;s a reason 100-1000Hz is typical.</p>\n<hr>\n<h2 id=\"debugging-scheduler-issues\">Debugging Scheduler Issues</h2>\n<p><strong>Symptom: System freezes after enabling scheduler</strong></p>\n<ul>\n<li>Timer interrupt not firing: Check PIC mask, IDT entry for IRQ0</li>\n<li>No ready processes: Check that processes were created</li>\n<li>Context switch corrupts state: Add serial debug prints before/after switch</li>\n</ul>\n<p><strong>Symptom: Processes run once, then crash</strong></p>\n<ul>\n<li>EIP not saved correctly: Check PCB offset calculations</li>\n<li>Stack corruption: Verify ESP is saved/restored correctly</li>\n<li>Page directory not switched: Check CR3 loading</li>\n</ul>\n<p><strong>Symptom: User-mode process causes triple fault</strong></p>\n<ul>\n<li>TSS not initialized: Check <code>ltr</code> was called</li>\n<li>TSS.ESP0 not updated: Must update on every context switch</li>\n<li>User page tables missing kernel mapping: Kernel pages must be mapped but supervisor-only</li>\n</ul>\n<p><strong>Symptom: Syscall returns garbage or crashes</strong></p>\n<ul>\n<li>Arguments not passed correctly: Check EBX/ECX/EDX handling</li>\n<li>Return value not in EAX: Check that handler sets regs-&gt;eax</li>\n<li>IDT gate DPL wrong: Must be 3 to allow user-mode <code>int 0x80</code></li>\n</ul>\n<p><strong>Symptom: Page fault in user mode accessing valid address</strong></p>\n<ul>\n<li>User bit not set on page table entry</li>\n<li>Page not mapped in user&#39;s page directory</li>\n<li>Stack overflow (user stack too small)</li>\n</ul>\n<hr>\n<h2 id=\"design-decision-cooperative-vs-preemptive-scheduling\">Design Decision: Cooperative vs Preemptive Scheduling</h2>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Cooperative</th>\n<th>Preemptive</th>\n<th>Used By</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Switch trigger</td>\n<td>Process yields</td>\n<td>Timer interrupt</td>\n<td>Preemptive: Linux, Windows</td>\n</tr>\n<tr>\n<td>Latency</td>\n<td>Unbounded</td>\n<td>Bounded</td>\n<td>Cooperative: Green threads</td>\n</tr>\n<tr>\n<td>Implementation</td>\n<td>Simple</td>\n<td>Complex (interrupt-safety)</td>\n<td></td>\n</tr>\n<tr>\n<td>Fault isolation</td>\n<td>Bad (crash hangs system)</td>\n<td>Good (can kill stuck process)</td>\n<td></td>\n</tr>\n<tr>\n<td>Real-time</td>\n<td>Impossible</td>\n<td>Possible with priority</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>Preemptive scheduling is mandatory for a general-purpose OS. Cooperative can work for specific workloads (event-driven servers, embedded loops) but can&#39;t guarantee responsiveness.</p>\n<hr>\n<h2 id=\"knowledge-cascade\">Knowledge Cascade</h2>\n<p>You&#39;ve built preemptive multitasking—the mechanism that makes modern computing possible. Here&#39;s where this knowledge connects:</p>\n<p><strong>Thread Pools and Async Runtimes</strong>: The context switch you implemented is exactly what green threads do in software. Go&#39;s goroutines save registers to a structure, switch to the next runnable goroutine, and restore—same mechanism, user-space implementation. Tokio tasks in Rust, Erlang processes, and Java virtual threads all use this technique. The difference is they don&#39;t need ring transitions or TSS manipulation—they&#39;re all in user space. Understanding register save/restore is fundamental to designing coroutine systems.</p>\n<p><strong>Virtualization and VM Exits (Cross-Domain)</strong>: When a VM executes a privileged instruction (like accessing CR3), the CPU performs a &quot;VM exit&quot;—analogous to your ring 3→ring 0 transition. The VMCS (Virtual Machine Control Structure) saves guest state (registers, segment selectors, CR3) just like your PCB saves process state. The hypervisor handles the exit, potentially emulates the instruction, then does a &quot;VM entry&quot; to resume the guest. VMware, KVM, and Hyper-V all implement this loop. Understanding your TSS and ring transitions is the first step to understanding VM introspection and escape exploits.</p>\n<p><strong>Real-Time Scheduling</strong>: Your round-robin scheduler is the foundation for understanding advanced schedulers. Linux&#39;s CFS (Completely Fair Scheduler) uses a red-black tree instead of a queue, tracking &quot;virtual runtime&quot; to ensure fairness. SCHED_FIFO and SCHED_RR provide real-time guarantees—the timer interrupt doesn&#39;t demote them, only explicit yield or blocking does. Deadline scheduling (EDF—Earliest Deadline First) is used in hard real-time systems. All of these are variations on the context switch you just built.</p>\n<p><strong>Security: Privilege Escalation Attacks</strong>: The ring boundary and TSS mechanism you implemented is exactly what kernel exploits try to bypass. A privilege escalation exploit might: (1) find a kernel bug that writes to user-controlled address, (2) overwrite a function pointer with user-controlled code, (3) trigger kernel execution of that code. The CPU is now executing ring 3 code with ring 0 privileges. Meltdown and Spectre attacks target the same isolation machinery—speculative execution crossing protection boundaries. Understanding ring transitions is understanding the attack surface.</p>\n<p><strong>Coroutine Implementations in Game Engines</strong>: Fiber-based job systems in game engines (Unity&#39;s Jobs system, Unreal&#39;s task graph) use the same context-switching techniques. A game might have 10,000 &quot;fibers&quot; (lightweight threads) that yield when waiting for animation, physics, or I/O. The fiber switch saves registers to a fiber-local context, just like your PCB. The difference is fibers never cross privilege levels—pure user-space switching. This is how modern games achieve massive parallelism without OS thread overhead.</p>\n<p><strong>Forward: What You Can Now Build</strong>: With preemptive multitasking, you can:</p>\n<ul>\n<li>Implement blocking I/O (process blocks on read, scheduler runs others)</li>\n<li>Add process priorities (higher priority processes run first)</li>\n<li>Build signals (interrupt a process asynchronously, like SIGKILL)</li>\n<li>Create /proc filesystem (expose PCB information to user space)</li>\n<li>Implement fork/exec (create new processes from user space)</li>\n</ul>\n<hr>\n<h2 id=\"summary\">Summary</h2>\n<p>You&#39;ve built preemptive multitasking—the illusion of parallelism through precise, hardware-assisted context switching:</p>\n<ol>\n<li><strong>Process Control Block (PCB)</strong>: Stores PID, all registers, page directory, kernel stack pointer</li>\n<li><strong>Context switch</strong>: Assembly routine that saves old process state and loads new process state</li>\n<li><strong>TSS (Task State Segment)</strong>: Provides SS0:ESP0 for ring 3→ring 0 stack switching</li>\n<li><strong>Round-robin scheduler</strong>: Timer interrupt triggers queue rotation and context switch</li>\n<li><strong>User-mode processes</strong>: Ring 3 execution with isolated address spaces</li>\n<li><strong>System calls</strong>: INT 0x80 with DPL=3 enables user→kernel transitions</li>\n</ol>\n<p>The revelation: only ONE process runs at a time. &quot;Concurrent&quot; execution is achieved by saving every register, loading the next process&#39;s registers, and jumping to its saved EIP. The interrupted process has no awareness it was suspended. System calls are not function calls—they trigger hardware privilege transitions through IDT gates, with stack switching via TSS.</p>\n<p>The physical constraints—TLB flush on CR3 reload, cache pollution between processes, interrupt latency affecting scheduling latency—shape every design decision. This is systems programming at its most fundamental.</p>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-satellite-system.svg\" alt=\"OS Kernel Architecture: Satellite View\"></p>\n<hr>\n<!-- END_MS -->\n\n\n\n\n<h1 id=\"tdd\">TDD</h1>\n<p>A complete x86 operating system kernel implementing the critical path from BIOS bootstrap to preemptive multitasking with user-mode processes. The design negotiates with x86 hardware constraints at every layer: 512-byte MBR limit, A20 line legacy, GDT/IDT configuration, 4KB page granularity, TLB non-coherence, and ring-level transitions. The kernel provides interrupt-driven I/O, virtual memory with higher-half mapping, and preemptive round-robin scheduling with privilege isolation.</p>\n<!-- TDD_MOD_ID: mod-boot -->\n<h1 id=\"technical-design-specification-bootloader-and-protected-mode-entry\">Technical Design Specification: Bootloader and Protected Mode Entry</h1>\n<h2 id=\"module-charter\">Module Charter</h2>\n<p>The bootloader module transforms the CPU from its 16-bit real mode state (as left by BIOS) into 32-bit protected mode with flat segmentation, then loads and transfers control to the C kernel. It handles the A20 line enabling, GDT configuration, protected mode transition, and kernel loading from disk.</p>\n<p><strong>What it does NOT do</strong>: This module does not set up paging (CR0.PG remains 0), does not configure the IDT or enable interrupts, does not perform any memory allocation, and does not handle user-mode (ring 3) transitions.</p>\n<p><strong>Upstream dependencies</strong>: BIOS has loaded the MBR at 0x7C00 and passed the boot drive number in DL.</p>\n<p><strong>Downstream consumers</strong>: The C kernel entry point expects protected mode with flat segments (CS=0x08, DS/ES/SS=0x10), a valid stack, and zeroed BSS section.</p>\n<p><strong>Invariants</strong>: Stage 1 must fit in 510 bytes; GDT must contain at least null + kernel code + kernel data descriptors; protected mode transition must use a far jump to flush the pipeline; kernel must be loaded at a known physical address (0x100000).</p>\n<hr>\n<h2 id=\"file-structure\">File Structure</h2>\n<p>Create files in this order:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>1. boot/stage1.asm          # Stage 1 bootloader (fits in 512-byte MBR)\n2. boot/stage2.asm          # Stage 2 bootloader (larger, loaded by stage 1)\n3. boot/gdt.asm             # GDT definitions and loader\n4. boot/a20.asm             # A20 line enablement routines\n5. boot/disk.asm            # Disk read routines using INT 13h\n6. boot/kernel_entry.asm    # Kernel entry shim (BSS zeroing, stack setup)\n7. kernel/linker.ld         # Linker script for kernel placement\n8. kernel/main.c            # Kernel C entry point (minimal, for testing)\n9. Makefile                 # Build system</code></pre></div>\n\n<hr>\n<h2 id=\"complete-data-model\">Complete Data Model</h2>\n<h3 id=\"gdt-entry-structure-8-bytes-each\">GDT Entry Structure (8 bytes each)</h3>\n<p>Each GDT entry is 64 bits with specific field packing:</p>\n<table>\n<thead>\n<tr>\n<th>Offset</th>\n<th>Bits</th>\n<th>Field</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0-1</td>\n<td>16</td>\n<td>Limit[15:0]</td>\n<td>Low 16 bits of segment limit</td>\n</tr>\n<tr>\n<td>2-3</td>\n<td>16</td>\n<td>Base[15:0]</td>\n<td>Low 16 bits of base address</td>\n</tr>\n<tr>\n<td>4</td>\n<td>8</td>\n<td>Base[23:16]</td>\n<td>Bits 16-23 of base address</td>\n</tr>\n<tr>\n<td>5</td>\n<td>8</td>\n<td>Access Byte</td>\n<td>Present, DPL, Type flags</td>\n</tr>\n<tr>\n<td>6</td>\n<td>8</td>\n<td>Flags + Limit[19:16]</td>\n<td>Granularity, size, high limit bits</td>\n</tr>\n<tr>\n<td>7</td>\n<td>8</td>\n<td>Base[31:24]</td>\n<td>Bits 24-31 of base address</td>\n</tr>\n</tbody></table>\n<p><strong>Access Byte (byte 5) bit layout:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Bit</th>\n<th>Name</th>\n<th>Value for Kernel Code</th>\n<th>Value for Kernel Data</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>7</td>\n<td>Present</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>6-5</td>\n<td>DPL</td>\n<td>00 (ring 0)</td>\n<td>00 (ring 0)</td>\n</tr>\n<tr>\n<td>4</td>\n<td>S (System)</td>\n<td>1 (code/data)</td>\n<td>1 (code/data)</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Executable</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>2</td>\n<td>DC (Direction/Conforming)</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>1</td>\n<td>RW (Read/Writable)</td>\n<td>1 (readable)</td>\n<td>1 (writable)</td>\n</tr>\n<tr>\n<td>0</td>\n<td>Accessed</td>\n<td>0 (CPU sets)</td>\n<td>0</td>\n</tr>\n</tbody></table>\n<p><strong>Access byte values:</strong></p>\n<ul>\n<li>Kernel Code: <code>0x9A</code> (10011010b)</li>\n<li>Kernel Data: <code>0x92</code> (10010010b)</li>\n</ul>\n<p><strong>Flags (high 4 bits of byte 6):</strong></p>\n<table>\n<thead>\n<tr>\n<th>Bit</th>\n<th>Name</th>\n<th>Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>7</td>\n<td>Granularity</td>\n<td>1 (4KB pages)</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Size</td>\n<td>1 (32-bit)</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Long</td>\n<td>0 (not 64-bit)</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Reserved</td>\n<td>0</td>\n</tr>\n</tbody></table>\n<p><strong>Flags value: <code>0xC</code></strong> (1100b shifted to high nibble = <code>0xC0</code> when combined with limit)</p>\n<p><strong>Complete GDT entry bytes:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Null Descriptor (index 0):\n  Bytes: 00 00 00 00 00 00 00 00\n\nKernel Code (index 1, selector 0x08):\n  Base=0x00000000, Limit=0xFFFFF (4GB with 4KB granularity)\n  Bytes: FF FF 00 00 00 9A CF 00\n\nKernel Data (index 2, selector 0x10):\n  Base=0x00000000, Limit=0xFFFFF (4GB with 4KB granularity)\n  Bytes: FF FF 00 00 00 92 CF 00</code></pre></div>\n\n<h3 id=\"gdtr-structure-6-bytes\">GDTR Structure (6 bytes)</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Offset 0-1: Limit (16-bit, size of GDT - 1)\nOffset 2-5: Base (32-bit, linear address of GDT)</code></pre></div>\n\n<h3 id=\"memory-layout-at-boot\">Memory Layout at Boot</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Physical Address    Contents\n─────────────────────────────────────────\n0x000000 - 0x0003FF  Real-mode IVT (DO NOT TOUCH)\n0x000400 - 0x0004FF  BDA (BIOS Data Area)\n0x000500 - 0x0007BF  Free (can use for stage 2)\n0x0007C0 - 0x0007FF  Stage 1 bootloader (MBR)\n0x0007FF - 0x000FFF  Free (stack can grow down from 0x7C00)\n0x001000 - 0x00FFFF  Free (low memory)\n0x010000 - 0x01FFFF  EBDA, video RAM, ROM (AVOID)\n0x020000 - 0x0FFFFF  ROM area, video memory (AVOID)\n0x100000 - N         Kernel loaded here (1MB mark)</code></pre></div>\n\n<h3 id=\"kernel-stack-layout\">Kernel Stack Layout</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>The kernel stack is set up at 0x90000 (below 1MB, in identity-mappable region)\nStack grows downward from 0x90000</code></pre></div>\n\n<hr>\n<h2 id=\"interface-contracts\">Interface Contracts</h2>\n<h3 id=\"stage1asm-entry-point\">stage1.asm Entry Point</h3>\n<p><strong>Entry</strong>: BIOS jumps to 0x7C00 with:</p>\n<ul>\n<li><code>CS:IP = 0x0000:0x7C00</code></li>\n<li><code>DL = boot drive number</code> (0x00 = floppy, 0x80 = first HDD)</li>\n<li>Interrupts enabled</li>\n<li>Real mode (CR0.PE = 0)</li>\n</ul>\n<p><strong>Exit</strong>: Stage 1 jumps to stage 2 (or directly enters protected mode)</p>\n<p><strong>Constraints</strong>:</p>\n<ul>\n<li>Must fit in 510 bytes (bytes 510-511 are boot signature 0xAA55)</li>\n<li>Must not modify memory outside 0x7C00-0x7DFF without care</li>\n<li>BIOS disk services (INT 13h) are only available in real mode</li>\n</ul>\n<h3 id=\"a20_enable\">a20_enable()</h3>\n<p><strong>Purpose</strong>: Enable the A20 line to access memory above 1MB</p>\n<p><strong>Parameters</strong>: None</p>\n<p><strong>Returns</strong>: </p>\n<ul>\n<li><code>AX = 1</code> on success</li>\n<li><code>AX = 0</code> on failure</li>\n</ul>\n<p><strong>Side effects</strong>: Modifies keyboard controller state, port 0x92</p>\n<p><strong>Error handling</strong>: Tries multiple methods; if all fail, returns 0 but does not halt (some emulators don&#39;t need A20)</p>\n<h3 id=\"gdt_load\">gdt_load()</h3>\n<p><strong>Purpose</strong>: Load the GDT register with the descriptor table</p>\n<p><strong>Parameters</strong>: None (GDT address is embedded)</p>\n<p><strong>Returns</strong>: None</p>\n<p><strong>Side effects</strong>: Loads GDTR; does NOT enable protected mode</p>\n<p><strong>Constraints</strong>: Must be called before setting CR0.PE</p>\n<h3 id=\"protected_mode_enter\">protected_mode_enter()</h3>\n<p><strong>Purpose</strong>: Transition from real mode to protected mode</p>\n<p><strong>Parameters</strong>: None</p>\n<p><strong>Returns</strong>: Never returns (far jump to 32-bit code)</p>\n<p><strong>Side effects</strong>:</p>\n<ul>\n<li>Sets CR0.PE = 1</li>\n<li>Performs far jump to flush pipeline</li>\n<li>Loads all segment registers with kernel data selector</li>\n</ul>\n<p><strong>Constraints</strong>:</p>\n<ul>\n<li>GDT must be loaded</li>\n<li>Interrupts must be disabled (<code>cli</code>)</li>\n<li>A20 should be enabled</li>\n<li>Identity-mapped code must exist at the jump target</li>\n</ul>\n<h3 id=\"disk_readsectorsdrive-cylinder-head-sector-count-esbx\">disk_read.sectors(drive, cylinder, head, sector, count, es:bx)</h3>\n<p><strong>Purpose</strong>: Read sectors from disk using BIOS INT 13h</p>\n<p><strong>Parameters</strong>:</p>\n<ul>\n<li><code>DL = drive</code> (passed from BIOS)</li>\n<li><code>CH = cylinder</code> (low 8 bits)</li>\n<li><code>CL = sector</code> (bits 0-5) | cylinder high bits (bits 6-7)</li>\n<li><code>DH = head</code></li>\n<li><code>AL = count</code> (sectors to read)</li>\n<li><code>ES:BX = destination buffer</code></li>\n</ul>\n<p><strong>Returns</strong>:</p>\n<ul>\n<li><code>CF = 0</code> on success</li>\n<li><code>CF = 1</code> on error, <code>AH = error code</code></li>\n</ul>\n<p><strong>Error codes</strong>:</p>\n<ul>\n<li><code>0x01</code>: Invalid command</li>\n<li><code>0x02</code>: Address mark not found</li>\n<li><code>0x03</code>: Write protect (not applicable)</li>\n<li><code>0x04</code>: Sector not found</li>\n<li><code>0x05</code>: Reset failed</li>\n<li><code>0x06</code>: Disk changed</li>\n<li><code>0x08</code>: DMA overrun</li>\n<li><code>0x09</code>: DMA boundary error</li>\n<li><code>0x0C</code>: Invalid media</li>\n<li><code>0x10</code>: CRC error</li>\n<li><code>0x20</code>: Controller failure</li>\n<li><code>0x40</code>: Seek failed</li>\n<li><code>0x80</code>: Timeout (no response)</li>\n</ul>\n<p><strong>Recovery</strong>: Reset disk system (INT 13h, AH=0) and retry up to 3 times</p>\n<h3 id=\"kernel_entry-assembly-shim\">kernel_entry (assembly shim)</h3>\n<p><strong>Entry</strong>: Called after protected mode transition with:</p>\n<ul>\n<li><code>CS = 0x08</code> (kernel code selector)</li>\n<li><code>DS/ES/SS = 0x10</code> (kernel data selector)</li>\n<li><code>ESP = 0x90000</code> (kernel stack)</li>\n</ul>\n<p><strong>Exit</strong>: Calls <code>kernel_main()</code> in C</p>\n<p><strong>Responsibilities</strong>:</p>\n<ol>\n<li>Ensure stack is valid</li>\n<li>Zero BSS section from <code>__bss_start</code> to <code>__bss_end</code></li>\n<li>Call <code>kernel_main()</code></li>\n<li>Halt if kernel_main returns</li>\n</ol>\n<hr>\n<h2 id=\"algorithm-specification\">Algorithm Specification</h2>\n<h3 id=\"stage-1-bootloader-sequence\">Stage 1 Bootloader Sequence</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>STAGE1_BOOT:\n  1. Set up real-mode segments:\n     DS = ES = SS = 0\n     SP = 0x7C00 (stack grows down from bootloader)\n  \n  2. Save boot drive number:\n     Store DL to [boot_drive]\n  \n  3. Display boot message (optional, INT 10h)\n  \n  4. Reset disk system:\n     AH = 0, INT 13h\n  \n  5. Load stage 2 from sectors 2-N:\n     CALL disk_load_stage2\n     IF error: display error, halt\n  \n  6. Enable A20 line:\n     CALL a20_enable\n     IF error: display warning, continue anyway\n  \n  7. Load GDT:\n     LGDT [gdt_descriptor]\n  \n  8. Disable interrupts:\n     CLI\n  \n  9. Enter protected mode:\n     MOV EAX, CR0\n     OR EAX, 1\n     MOV CR0, EAX\n  \n  10. Far jump to 32-bit code:\n      JMP 0x08:protected_mode_entry\n  \n  ; After this point, we're in 32-bit protected mode\n  \n  11. Reload segment registers:\n      MOV AX, 0x10\n      MOV DS, AX\n      MOV ES, AX\n      MOV FS, AX\n      MOV GS, AX\n      MOV SS, AX\n      MOV ESP, 0x90000\n  \n  12. Jump to kernel entry point:\n      JMP 0x08:0x100000</code></pre></div>\n\n<h3 id=\"a20-line-enablement-multiple-methods\">A20 Line Enablement (Multiple Methods)</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>A20_ENABLE:\n  ; Method 1: Fast A20 gate (port 0x92)\n  ; Works on most modern systems and emulators\n  \n  IN AL, 0x92\n  TEST AL, 2        ; Check if A20 already enabled\n  JNZ .a20_done\n  \n  OR AL, 2          ; Set A20 bit\n  AND AL, 0xFE      ; Clear reset bit (safety)\n  OUT 0x92, AL\n  JMP .a20_done\n  \n  ; Method 2: Keyboard controller (more compatible)\n  ; The keyboard controller's output port bit 1 controls A20\n  \n  CALL kbc_wait_input   ; Wait for input buffer empty\n  MOV AL, 0xD0          ; Read output port command\n  OUT 0x64, AL\n  CALL kbc_wait_output  ; Wait for output buffer full\n  IN AL, 0x60           ; Read current output port value\n  PUSH AX\n  \n  CALL kbc_wait_input\n  MOV AL, 0xD1          ; Write output port command\n  OUT 0x64, AL\n  \n  CALL kbc_wait_input\n  POP AX\n  OR AL, 2              ; Set A20 bit\n  OUT 0x60, AL\n  \n  CALL kbc_wait_input\n  \n.a20_done:\n  ; Verify A20 is enabled\n  CALL a20_verify\n  RET\n\nKBC_WAIT_INPUT:\n  ; Wait until keyboard controller input buffer is empty\n  IN AL, 0x64\n  TEST AL, 2\n  JNZ KBC_WAIT_INPUT\n  RET\n\nKBC_WAIT_OUTPUT:\n  ; Wait until keyboard controller output buffer is full\n  IN AL, 0x64\n  TEST AL, 1\n  JZ KBC_WAIT_OUTPUT\n  RET\n\nA20_VERIFY:\n  ; Verify A20 is actually enabled by testing memory wraparound\n  ; Write different values to 0x0000:0x0500 and 0xFFFF:0x0510\n  ; If A20 disabled, they alias to the same physical address\n  \n  MOV AX, 0x0000\n  MOV ES, AX\n  MOV DI, 0x0500\n  MOV BYTE [ES:DI], 0x00\n  \n  MOV AX, 0xFFFF\n  MOV ES, AX\n  MOV DI, 0x0510       ; 0xFFFF0 + 0x0510 = 0x100500 (wraps to 0x0500 if A20 off)\n  MOV BYTE [ES:DI], 0xFF\n  \n  MOV AX, 0x0000\n  MOV ES, AX\n  MOV DI, 0x0500\n  CMP BYTE [ES:DI], 0x00\n  \n  JE .a20_is_on        ; If still 0x00, addresses don't alias\n  MOV AX, 0            ; A20 is off\n  RET\n  \n.a20_is_on:\n  MOV AX, 1\n  RET</code></pre></div>\n\n<h3 id=\"disk-read-with-retry\">Disk Read with Retry</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>DISK_READ:\n  ; Input: CH = cylinder, CL = sector, DH = head, DL = drive\n  ;        AL = count, ES:BX = buffer\n  ; Output: CF set on error, AH = error code\n  \n  PUSH AX             ; Save sector count\n  MOV SI, 3           ; Retry count\n  \n.retry:\n  POP AX\n  PUSH AX\n  MOV AH, 0x02        ; BIOS read sectors function\n  PUSH SI\n  INT 0x13\n  POP SI\n  JNC .success\n  \n  ; Error occurred - reset disk and retry\n  PUSH AX             ; Save error code\n  XOR AH, AH          ; Reset disk system\n  INT 0x13\n  POP AX\n  \n  DEC SI\n  JNZ .retry\n  \n  ; All retries exhausted\n  POP AX\n  STC                 ; Set carry flag to indicate error\n  RET\n  \n.success:\n  POP AX\n  CLC                 ; Clear carry flag\n  RET</code></pre></div>\n\n<h3 id=\"bss-zeroing\">BSS Zeroing</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>KERNEL_ENTRY:\n  ; Set up stack (if not already done)\n  MOV ESP, 0x90000\n  \n  ; Zero BSS section\n  ; __bss_start and __bss_end are defined in linker script\n  MOV EDI, __bss_start\n  MOV ECX, __bss_end\n  SUB ECX, EDI        ; Length = end - start\n  XOR EAX, EAX        ; Zero\n  REP STOSB           ; Fill BSS with zeros\n  \n  ; Call C kernel entry point\n  CALL kernel_main\n  \n  ; If kernel_main returns, halt\n.halt:\n  CLI\n  HLT\n  JMP .halt</code></pre></div>\n\n<hr>\n<h2 id=\"error-handling-matrix\">Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th>Error</th>\n<th>Detected By</th>\n<th>Recovery</th>\n<th>User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Disk read failure</td>\n<td>INT 13h returns CF=1</td>\n<td>Reset disk, retry up to 3 times</td>\n<td>Yes, error message on screen</td>\n</tr>\n<tr>\n<td>A20 line stuck</td>\n<td>a20_verify returns 0</td>\n<td>Continue anyway (emulators may not need it)</td>\n<td>Warning message</td>\n</tr>\n<tr>\n<td>No boot signature</td>\n<td>BIOS checks bytes 510-511</td>\n<td>N/A (BIOS moves to next device)</td>\n<td>&quot;No bootable device&quot;</td>\n</tr>\n<tr>\n<td>GDT misconfiguration</td>\n<td>Triple fault on mode switch</td>\n<td>Debug with QEMU <code>-d int</code></td>\n<td>System reset</td>\n</tr>\n<tr>\n<td>Kernel not found</td>\n<td>Disk read returns error</td>\n<td>Halt with error message</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Stage 1 too large</td>\n<td>Build-time (nasm error)</td>\n<td>Remove debug code, optimize</td>\n<td>Build fails</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"implementation-sequence-with-checkpoints\">Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-stage-1-bootloader-assembly-4-6-hours\">Phase 1: Stage 1 Bootloader Assembly (4-6 hours)</h3>\n<p><strong>Goal</strong>: Create a bootable MBR that displays a message and halts</p>\n<p><strong>Files to create</strong>:</p>\n<ol>\n<li><code>boot/stage1.asm</code></li>\n</ol>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Set up the ORG directive at 0x7C00</li>\n<li>Initialize segment registers (DS, ES, SS)</li>\n<li>Set up stack pointer at 0x7C00</li>\n<li>Save boot drive number</li>\n<li>Display &quot;Booting...&quot; message using INT 10h</li>\n<li>Add padding and boot signature</li>\n</ol>\n<p><strong>Checkpoint</strong>: Build and run in QEMU. Should display message and halt.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">nasm</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> bin</span><span style=\"color:#9ECBFF\"> boot/stage1.asm</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> boot.bin</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=boot.bin</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: \"Booting...\" message, then system sits idle</span></span></code></pre></div>\n\n<h3 id=\"phase-2-a20-line-enablement-2-3-hours\">Phase 2: A20 Line Enablement (2-3 hours)</h3>\n<p><strong>Goal</strong>: Implement and verify A20 line enabling</p>\n<p><strong>Files to create</strong>:</p>\n<ol>\n<li><code>boot/a20.asm</code></li>\n</ol>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Implement fast A20 gate method (port 0x92)</li>\n<li>Implement keyboard controller method (ports 0x60/0x64)</li>\n<li>Implement A20 verification routine</li>\n<li>Add debug output showing A20 status</li>\n</ol>\n<p><strong>Checkpoint</strong>: Display &quot;A20: enabled&quot; or &quot;A20: disabled&quot; on boot</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Build with a20.asm included</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: \"A20: enabled\" message</span></span></code></pre></div>\n\n<h3 id=\"phase-3-gdt-configuration-and-loading-3-4-hours\">Phase 3: GDT Configuration and Loading (3-4 hours)</h3>\n<p><strong>Goal</strong>: Define and load a valid GDT</p>\n<p><strong>Files to create</strong>:</p>\n<ol>\n<li><code>boot/gdt.asm</code></li>\n</ol>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Define GDT with null, kernel code, and kernel data descriptors</li>\n<li>Define GDTR structure (limit and base)</li>\n<li>Implement lgdt wrapper</li>\n<li>Add debug output showing GDT address</li>\n</ol>\n<p><strong>Checkpoint</strong>: GDT loads without error (no visible crash before protected mode)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Add message \"GDT loaded\" after lgdt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Message appears, system continues</span></span></code></pre></div>\n\n<h3 id=\"phase-4-protected-mode-transition-2-3-hours\">Phase 4: Protected Mode Transition (2-3 hours)</h3>\n<p><strong>Goal</strong>: Successfully enter 32-bit protected mode</p>\n<p><strong>Files to modify</strong>:</p>\n<ol>\n<li><code>boot/stage1.asm</code></li>\n</ol>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Add <code>cli</code> before mode switch</li>\n<li>Set CR0.PE bit</li>\n<li>Add far jump to 32-bit code section</li>\n<li>Create 32-bit code section with segment register reloads</li>\n<li>Display &quot;Protected mode!&quot; message</li>\n</ol>\n<p><strong>Checkpoint</strong>: Successfully enter protected mode and display message</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Expected: \"Protected mode!\" message in 32-bit code</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># QEMU should not reset or triple fault</span></span></code></pre></div>\n\n<h3 id=\"phase-5-kernel-loader-3-4-hours\">Phase 5: Kernel Loader (3-4 hours)</h3>\n<p><strong>Goal</strong>: Load kernel binary from disk</p>\n<p><strong>Files to create</strong>:</p>\n<ol>\n<li><code>boot/disk.asm</code></li>\n<li><code>boot/stage2.asm</code> (optional, for larger loader)</li>\n</ol>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Implement disk_read routine with retry logic</li>\n<li>Calculate CHS geometry for kernel location</li>\n<li>Load kernel to 0x100000</li>\n<li>Verify kernel was loaded (check first bytes)</li>\n</ol>\n<p><strong>Checkpoint</strong>: Kernel binary loaded to 0x100000</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Create a simple kernel.bin (just a few bytes for testing)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dd</span><span style=\"color:#9ECBFF\"> if=/dev/zero</span><span style=\"color:#9ECBFF\"> of=disk.img</span><span style=\"color:#9ECBFF\"> bs=</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#9ECBFF\"> count=</span><span style=\"color:#79B8FF\">2880</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dd</span><span style=\"color:#9ECBFF\"> if=boot.bin</span><span style=\"color:#9ECBFF\"> of=disk.img</span><span style=\"color:#9ECBFF\"> bs=</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#9ECBFF\"> count=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#9ECBFF\"> conv=notrunc</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dd</span><span style=\"color:#9ECBFF\"> if=kernel.bin</span><span style=\"color:#9ECBFF\"> of=disk.img</span><span style=\"color:#9ECBFF\"> bs=</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#9ECBFF\"> seek=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#9ECBFF\"> conv=notrunc</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># In protected mode, display value at 0x100000</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Matches first bytes of kernel.bin</span></span></code></pre></div>\n\n<h3 id=\"phase-6-kernel-entry-shim-2-3-hours\">Phase 6: Kernel Entry Shim (2-3 hours)</h3>\n<p><strong>Goal</strong>: Create assembly entry point that calls C code</p>\n<p><strong>Files to create</strong>:</p>\n<ol>\n<li><code>boot/kernel_entry.asm</code></li>\n</ol>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Set up kernel stack at 0x90000</li>\n<li>Zero BSS section using linker symbols</li>\n<li>Call kernel_main</li>\n<li>Add halt loop if kernel_main returns</li>\n</ol>\n<p><strong>Checkpoint</strong>: C kernel_main is called and can print a message</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># kernel_main just prints \"Hello from C!\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Message appears on screen</span></span></code></pre></div>\n\n<h3 id=\"phase-7-linker-script-design-2-3-hours\">Phase 7: Linker Script Design (2-3 hours)</h3>\n<p><strong>Goal</strong>: Define kernel memory layout</p>\n<p><strong>Files to create</strong>:</p>\n<ol>\n<li><code>kernel/linker.ld</code></li>\n</ol>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Set entry point to kernel_entry</li>\n<li>Place .text at 0x100000</li>\n<li>Define .rodata, .data, .bss sections</li>\n<li>Export __bss_start and __bss_end symbols</li>\n<li>Add /DISCARD/ for unwanted sections</li>\n</ol>\n<p><strong>Checkpoint</strong>: Kernel links successfully, BSS is properly zeroed</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">ld</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> elf_i386</span><span style=\"color:#79B8FF\"> -T</span><span style=\"color:#9ECBFF\"> kernel/linker.ld</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> kernel.elf</span><span style=\"color:#9ECBFF\"> kernel_entry.o</span><span style=\"color:#9ECBFF\"> main.o</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">nm</span><span style=\"color:#9ECBFF\"> kernel.elf</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> bss</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: __bss_start and __bss_end defined</span></span></code></pre></div>\n\n<h3 id=\"final-integration-2-3-hours\">Final Integration (2-3 hours)</h3>\n<p><strong>Goal</strong>: Complete bootable system</p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Create Makefile with all build rules</li>\n<li>Create disk image with bootloader and kernel</li>\n<li>Add VGA and serial output to kernel_main</li>\n<li>Test in QEMU with serial output</li>\n</ol>\n<p><strong>Checkpoint</strong>: Kernel boots, displays welcome message on VGA and serial</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">make</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> -serial</span><span style=\"color:#9ECBFF\"> stdio</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Welcome message on screen and serial console</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run tests: make test (all pass)</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"test-specification\">Test Specification</h2>\n<h3 id=\"test-1-boot-signature-valid\">Test 1: Boot Signature Valid</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># test_boot_signature.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_boot_signature</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    with</span><span style=\"color:#79B8FF\"> open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'boot.bin'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'rb'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> f:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> f.read()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(data) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 512</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Boot sector must be exactly 512 bytes\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#E1E4E8\"> data[</span><span style=\"color:#79B8FF\">510</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">55</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Byte 510 must be 0x55\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#E1E4E8\"> data[</span><span style=\"color:#79B8FF\">511</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">AA</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Byte 511 must be 0xAA\"</span></span></code></pre></div>\n\n<h3 id=\"test-2-gdt-structure-valid\">Test 2: GDT Structure Valid</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># test_gdt.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_gdt_null_descriptor</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Null descriptor must be all zeros</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Locate GDT in binary and verify first 8 bytes are 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_gdt_code_descriptor</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Kernel code descriptor:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Base = 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Limit = 0xFFFFF</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Access = 0x9A (present, ring 0, code, readable)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Flags = 0xC (4KB granularity, 32-bit)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_gdt_data_descriptor</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Kernel data descriptor:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Base = 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Limit = 0xFFFFF</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Access = 0x92 (present, ring 0, data, writable)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Flags = 0xC</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h3 id=\"test-3-protected-mode-entry\">Test 3: Protected Mode Entry</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># test_protected_mode.sh</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run QEMU with GDB to verify protected mode entry</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#79B8FF\"> -S</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">QEMU_PID</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">$!</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gdb</span><span style=\"color:#79B8FF\"> -batch</span><span style=\"color:#79B8FF\"> -ex</span><span style=\"color:#9ECBFF\"> \"target remote :1234\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    -ex</span><span style=\"color:#9ECBFF\"> \"break *0x7C00\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    -ex</span><span style=\"color:#9ECBFF\"> \"continue\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    -ex</span><span style=\"color:#9ECBFF\"> \"x/i </span><span style=\"color:#79B8FF\">\\$</span><span style=\"color:#9ECBFF\">pc\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    -ex</span><span style=\"color:#9ECBFF\"> \"stepi 100\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    -ex</span><span style=\"color:#9ECBFF\"> \"info registers cr0\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    -ex</span><span style=\"color:#9ECBFF\"> \"quit\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">kill</span><span style=\"color:#E1E4E8\"> $QEMU_PID</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify CR0.PE bit is set</span></span></code></pre></div>\n\n<h3 id=\"test-4-kernel-load-address\">Test 4: Kernel Load Address</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># test_kernel_load.sh</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify kernel is loaded at correct address</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create test kernel with known pattern</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#9ECBFF\"> \"KERNEL_TEST_PATTERN\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> test_pattern.bin</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dd</span><span style=\"color:#9ECBFF\"> if=test_pattern.bin</span><span style=\"color:#9ECBFF\"> of=os.img</span><span style=\"color:#9ECBFF\"> bs=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#9ECBFF\"> seek=</span><span style=\"color:#E1E4E8\">$((</span><span style=\"color:#B392F0\">0x100000</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#9ECBFF\">conv=notrunc</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run in QEMU and check memory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># (This requires QEMU monitor or GDB)</span></span></code></pre></div>\n\n<h3 id=\"test-5-bss-zeroing\">Test 5: BSS Zeroing</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// kernel/test_bss.c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// These should be in BSS (uninitialized)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> test_var1;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> test_var2;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> char</span><span style=\"color:#FFAB70\"> test_buffer</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_bss_zeroed</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // After kernel entry, all BSS should be zero</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (test_var1 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> test_var2 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"FAIL: BSS variables not zeroed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        halt</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 256</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">test_buffer</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"FAIL: BSS buffer not zeroed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            halt</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PASS: BSS zeroed correctly</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-6-serial-output\">Test 6: Serial Output</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># test_serial.sh</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify serial output works</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">OUTPUT</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> -serial</span><span style=\"color:#9ECBFF\"> stdio</span><span style=\"color:#79B8FF\"> -display</span><span style=\"color:#9ECBFF\"> none</span><span style=\"color:#79B8FF\"> -nographic</span><span style=\"color:#F97583\"> 2>&#x26;1</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> timeout</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#9ECBFF\"> cat</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> echo</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$OUTPUT</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -q</span><span style=\"color:#9ECBFF\"> \"Welcome\"</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"PASS: Serial output working\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"FAIL: No welcome message on serial\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    exit</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span></code></pre></div>\n\n<h3 id=\"test-7-vga-output\">Test 7: VGA Output</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># test_vga.sh</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify VGA text mode output works</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># This requires checking VGA buffer in QEMU or visual inspection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># For automation, we check that the kernel doesn't crash</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> -nographic</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">QEMU_PID</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">$!</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#B392F0\"> ps</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#E1E4E8\"> $QEMU_PID </span><span style=\"color:#F97583\">></span><span style=\"color:#9ECBFF\"> /dev/null</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"PASS: Kernel running (VGA likely working)\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    kill</span><span style=\"color:#E1E4E8\"> $QEMU_PID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"FAIL: Kernel crashed\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    exit</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-targets\">Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Target</th>\n<th>How to Measure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Boot to C entry</td>\n<td>&lt; 1 second</td>\n<td>Time from QEMU start to first serial output</td>\n</tr>\n<tr>\n<td>Stage 1 size</td>\n<td>≤ 510 bytes</td>\n<td><code>wc -c boot.bin</code> must show 512 (including signature)</td>\n</tr>\n<tr>\n<td>GDT load</td>\n<td>&lt; 100 cycles</td>\n<td>Single <code>lgdt</code> instruction</td>\n</tr>\n<tr>\n<td>Protected mode switch</td>\n<td>&lt; 50 cycles</td>\n<td>CR0 write + far jump</td>\n</tr>\n<tr>\n<td>Disk read (16KB)</td>\n<td>&lt; 100ms</td>\n<td>Measure time for loading kernel</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"visual-diagrams\">Visual Diagrams</h2>\n<h3 id=\"boot-sequence\">Boot Sequence</h3>\n<p><img src=\"/api/project/build-os/architecture-doc/asset?path=diagrams%2Fdiag-boot-sequence.svg\" alt=\"x86 Boot Sequence: BIOS to C Entry\"></p>\n<h3 id=\"gdt-structure\">GDT Structure</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>GDT Memory Layout:\n┌────────────────────────────────────────────────────────────────┐\n│ Offset 0x00: Null Descriptor                                   │\n│   00 00 00 00 00 00 00 00                                      │\n├────────────────────────────────────────────────────────────────┤\n│ Offset 0x08: Kernel Code Descriptor                            │\n│   ┌──────────────────────────────────────────────────────────┐ │\n│   │ Limit[15:0]  │ Base[15:0] │ Base[23:16] │ Access │ Flags │ │\n│   │    0xFFFF    │   0x0000   │    0x00     │ 0x9A   │0xC*   │ │\n│   │              │            │             │        │ +Lim  │ │\n│   └──────────────────────────────────────────────────────────┘ │\n│   Base[31:24] = 0x00                                           │\n│   Decoded: Base=0, Limit=0xFFFFF (4KB gran = 4GB), 32-bit code │\n├────────────────────────────────────────────────────────────────┤\n│ Offset 0x10: Kernel Data Descriptor                            │\n│   Same as code but Access = 0x92 (data, writable)              │\n│   Decoded: Base=0, Limit=0xFFFFF (4KB gran = 4GB), 32-bit data │\n└────────────────────────────────────────────────────────────────┘\n\nGDTR Register:\n┌────────────────┬────────────────────────────────────────────────┐\n│ Limit (16-bit) │ Base (32-bit)                                  │\n│    0x0017      │ Address of gdt_start                           │\n│  (24-1=23)     │                                                │\n└────────────────┴────────────────────────────────────────────────┘</code></pre></div>\n\n<h3 id=\"protected-mode-transition\">Protected Mode Transition</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>BEFORE (Real Mode):\n┌─────────────────────────────────────────┐\n│ CR0.PE = 0                              │\n│ CS:IP = 0x0000:0x7C00 (real mode addr)  │\n│ GDTR = undefined                        │\n│ Segment registers = real mode values    │\n│ Paging = disabled                       │\n└─────────────────────────────────────────┘\n              │\n              ▼ cli (disable interrupts)\n              │\n              ▼ lgdt [gdt_descriptor]\n              │\n              ▼ mov eax, cr0 / or eax, 1 / mov cr0, eax\n              │\n┌─────────────────────────────────────────┐\n│ CR0.PE = 1                              │\n│ CS:IP = 0x0000:0x7C00 (still real mode! │\n│         CPU is in inconsistent state)   │\n│ GDTR = valid                            │\n│ Pipeline contains 16-bit decoded inst.  │\n└─────────────────────────────────────────┘\n              │\n              ▼ jmp 0x08:protected_mode_entry\n              │  (far jump flushes pipeline,\n              │   loads CS with selector 0x08)\n              │\n┌─────────────────────────────────────────┐\n│ AFTER (Protected Mode):                 │\n│ CR0.PE = 1                              │\n│ CS = 0x08 (kernel code, GDT index 1)    │\n│ EIP = protected_mode_entry              │\n│ DS/ES/SS = still real mode values!      │\n│ (Must reload immediately)               │\n└─────────────────────────────────────────┘\n              │\n              ▼ mov ax, 0x10 / mov ds, ax / ...\n              │\n┌─────────────────────────────────────────┐\n│ FULLY IN PROTECTED MODE:                │\n│ All segment registers = 0x10            │\n│ ESP = 0x90000 (kernel stack)            │\n│ Ready to execute 32-bit kernel code     │\n└─────────────────────────────────────────┘</code></pre></div>\n\n<h3 id=\"triple-fault-chain\">Triple Fault Chain</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Normal Fault Flow:\n┌──────────────────┐\n│ CPU Exception    │──▶ IDT Entry ──▶ Handler ──▶ iret ──▶ Resume\n└──────────────────┘\n\nDouble Fault:\n┌──────────────────┐\n│ CPU Exception    │──▶ IDT Entry ──▶ Handler CRASHES\n└──────────────────┘         │\n                              ▼\n                    ┌──────────────────┐\n                    │ Double Fault (8) │──▶ IDT[8] ──▶ Handler\n                    └──────────────────┘\n\nTriple Fault (System Reset):\n┌──────────────────┐\n│ CPU Exception    │──▶ IDT Entry ──▶ Handler CRASHES\n└──────────────────┘         │\n                              ▼\n                    ┌──────────────────┐\n                    │ Double Fault (8) │──▶ IDT[8] ──▶ Handler CRASHES\n                    └──────────────────┘         │\n                                                 ▼\n                                       ┌──────────────────┐\n                                       │ Triple Fault     │──▶ CPU RESET\n                                       │ (No handler!)    │\n                                       └──────────────────┘\n\nCommon Causes in Bootloader:\n1. GDT not loaded before setting CR0.PE\n2. Far jump with invalid selector\n3. Segment register load with invalid selector\n4. Stack pointer invalid after mode switch\n5. Code at jump target is not 32-bit</code></pre></div>\n\n<hr>\n<h2 id=\"hardware-soul\">Hardware Soul</h2>\n<h3 id=\"cache-lines-touched\">Cache Lines Touched</h3>\n<ul>\n<li><strong>GDT load</strong>: The GDT itself (24 bytes for 3 entries) is read by the CPU into internal descriptor caches. This does NOT go through the normal cache hierarchy—it&#39;s a special register load.</li>\n<li><strong>Stage 1 execution</strong>: Runs from BIOS ROM shadow or RAM at 0x7C00. First execution likely has cache misses.</li>\n<li><strong>Kernel load</strong>: Sequential disk reads are buffered by BIOS. The destination at 0x100000 is likely cache-cold.</li>\n</ul>\n<h3 id=\"pipeline-behavior\">Pipeline Behavior</h3>\n<ul>\n<li><strong>Real mode code</strong>: 16-bit decoding path</li>\n<li><strong>Mode switch</strong>: Setting CR0.PE doesn&#39;t flush the pipeline—the far jump does</li>\n<li><strong>Far jump cost</strong>: 10-30 cycles to flush and refill pipeline with 32-bit code</li>\n<li><strong>After switch</strong>: CPU now uses 32-bit decoding path</li>\n</ul>\n<h3 id=\"memory-access-patterns\">Memory Access Patterns</h3>\n<ul>\n<li><strong>Disk reads</strong>: Sequential sector reads via INT 13h. BIOS may optimize this with multi-sector reads.</li>\n<li><strong>GDT access</strong>: Single 24-byte read when <code>lgdt</code> executes</li>\n<li><strong>BSS zeroing</strong>: Sequential writes from <code>__bss_start</code> to <code>__bss_end</code>. This is cache-friendly (sequential stores).</li>\n</ul>\n<h3 id=\"io-port-access\">I/O Port Access</h3>\n<table>\n<thead>\n<tr>\n<th>Port</th>\n<th>Purpose</th>\n<th>Timing</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0x92</td>\n<td>Fast A20 gate</td>\n<td>~1 microsecond</td>\n</tr>\n<tr>\n<td>0x64</td>\n<td>KBC command</td>\n<td>~10 microseconds wait</td>\n</tr>\n<tr>\n<td>0x60</td>\n<td>KBC data</td>\n<td>~10 microseconds wait</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"implementation-notes\">Implementation Notes</h2>\n<h3 id=\"stage-1-size-optimization\">Stage 1 Size Optimization</h3>\n<p>If stage 1 exceeds 510 bytes:</p>\n<ol>\n<li>Remove string messages (use single characters)</li>\n<li>Use shorter instruction encodings (<code>xor ax, ax</code> instead of <code>mov ax, 0</code>)</li>\n<li>Combine operations (<code>push cs / pop ds</code> instead of <code>mov ax, cs / mov ds, ax</code>)</li>\n<li>Move complex code to stage 2</li>\n</ol>\n<h3 id=\"two-stage-vs-direct-kernel-load\">Two-Stage vs Direct Kernel Load</h3>\n<p><strong>Two-stage approach</strong> (recommended):</p>\n<ul>\n<li>Stage 1: Minimal—just load stage 2 and enter protected mode</li>\n<li>Stage 2: Larger—load kernel, set up environment, transfer control</li>\n</ul>\n<p><strong>Direct load</strong>:</p>\n<ul>\n<li>Stage 1 loads kernel directly before protected mode</li>\n<li>Simpler but limited to what fits in 510 bytes</li>\n</ul>\n<h3 id=\"debugging-with-qemu\">Debugging with QEMU</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Log all interrupts and CPU resets</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> -d</span><span style=\"color:#9ECBFF\"> int,cpu_reset</span><span style=\"color:#79B8FF\"> -serial</span><span style=\"color:#9ECBFF\"> stdio</span><span style=\"color:#F97583\"> 2>&#x26;1</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tee</span><span style=\"color:#9ECBFF\"> debug.log</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Use GDB</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#79B8FF\"> -S</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gdb</span><span style=\"color:#79B8FF\"> -ex</span><span style=\"color:#9ECBFF\"> \"target remote :1234\"</span><span style=\"color:#79B8FF\"> -ex</span><span style=\"color:#9ECBFF\"> \"break *0x7c00\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Monitor commands (in QEMU)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">qemu</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">info</span><span style=\"color:#9ECBFF\"> registers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">qemu</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">x/10i</span><span style=\"color:#E1E4E8\"> $eip</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">qemu</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">xp</span><span style=\"color:#9ECBFF\"> /10x</span><span style=\"color:#79B8FF\"> 0x100000</span><span style=\"color:#6A737D\">  # physical memory view</span></span></code></pre></div>\n\n<hr>\n<!-- TDD_MOD_ID: mod-interrupts -->\n<h1 id=\"technical-design-specification-interrupt-and-exception-handling\">Technical Design Specification: Interrupt and Exception Handling</h1>\n<h2 id=\"module-charter\">Module Charter</h2>\n<p>The interrupt module implements the IDT (Interrupt Descriptor Table) with 256 entries, CPU exception handlers for vectors 0-31, and hardware IRQ handlers for vectors 32-47. It configures the 8259 PIC to remap IRQs away from CPU exception vectors, implements PIT timer and PS/2 keyboard drivers, and provides the infrastructure for asynchronous hardware event handling.</p>\n<p><strong>What it does NOT do</strong>: This module does not implement scheduling (timer just increments a counter), does not handle system calls (vector 0x80), does not implement APIC (uses legacy 8259 PIC only), and does not handle page fault recovery (just prints diagnostics).</p>\n<p><strong>Upstream dependencies</strong>: GDT must be loaded with kernel code (0x08) and data (0x10) selectors; protected mode must be active.</p>\n<p><strong>Downstream consumers</strong>: Scheduler (Milestone 4) uses timer interrupt for preemption; keyboard buffer consumed by shell/TTY; exception handlers provide crash diagnostics.</p>\n<p><strong>Invariants</strong>: All interrupt handlers must save/restore complete register state; EOI must be sent to PIC for all IRQs; IDT must be loaded before interrupts are enabled; PIC must be remapped before any IRQs are unmasked.</p>\n<hr>\n<h2 id=\"file-structure\">File Structure</h2>\n<p>Create files in this order:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>1. kernel/idt.h              # IDT structures and function declarations\n2. kernel/idt.c              # IDT initialization and gate management\n3. kernel/isr.asm            # Assembly ISR stubs for exceptions 0-31\n4. kernel/irq.asm            # Assembly IRQ stubs for IRQs 0-15\n5. kernel/interrupt_handler.c # Common C handler dispatcher\n6. kernel/pic.h              # PIC interface declarations\n7. kernel/pic.c              # PIC remapping and EOI functions\n8. kernel/timer.h            # PIT timer interface\n9. kernel/timer.c            # PIT initialization and handler\n10. kernel/keyboard.h        # Keyboard interface declarations\n11. kernel/keyboard.c        # PS/2 keyboard driver with scancode table\n12. kernel/registers.h       # Register frame structure definition</code></pre></div>\n\n<hr>\n<h2 id=\"complete-data-model\">Complete Data Model</h2>\n<h3 id=\"idt-entry-structure-8-bytes\">IDT Entry Structure (8 bytes)</h3>\n<p>Each IDT entry is a gate descriptor with this exact layout:</p>\n<table>\n<thead>\n<tr>\n<th>Offset</th>\n<th>Size</th>\n<th>Field</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>16 bits</td>\n<td>Offset Low</td>\n<td>Bits 15:0 of handler address</td>\n</tr>\n<tr>\n<td>2</td>\n<td>16 bits</td>\n<td>Segment Selector</td>\n<td>Code segment for handler (0x08)</td>\n</tr>\n<tr>\n<td>4</td>\n<td>8 bits</td>\n<td>Reserved</td>\n<td>Must be 0</td>\n</tr>\n<tr>\n<td>5</td>\n<td>8 bits</td>\n<td>Type/Attributes</td>\n<td>Gate type and flags</td>\n</tr>\n<tr>\n<td>6</td>\n<td>16 bits</td>\n<td>Offset High</td>\n<td>Bits 31:16 of handler address</td>\n</tr>\n</tbody></table>\n<p><strong>Type/Attributes byte (byte 5) bit layout:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Bit</th>\n<th>Name</th>\n<th>Value</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>7</td>\n<td>Present</td>\n<td>1</td>\n<td>Gate is valid</td>\n</tr>\n<tr>\n<td>6-5</td>\n<td>DPL</td>\n<td>00 or 11</td>\n<td>Descriptor Privilege Level (0=kernel only, 3=user callable)</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Storage</td>\n<td>0</td>\n<td>Must be 0 for interrupt/trap gates</td>\n</tr>\n<tr>\n<td>3-0</td>\n<td>Type</td>\n<td>1110 or 1111</td>\n<td>1110=Interrupt gate (IF=0), 1111=Trap gate (IF unchanged)</td>\n</tr>\n</tbody></table>\n<p><strong>Standard attribute values:</strong></p>\n<ul>\n<li>Interrupt gate (kernel only): <code>0x8E</code> (10001110b)</li>\n<li>Trap gate (kernel only): <code>0x8F</code> (10001111b)</li>\n<li>User-callable interrupt gate: <code>0xEE</code> (11101110b) — for syscalls</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// kernel/idt.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> offset_low;</span><span style=\"color:#6A737D\">    // Offset bits 15:0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> selector;</span><span style=\"color:#6A737D\">      // Code segment selector</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\">  zero;</span><span style=\"color:#6A737D\">          // Reserved, must be 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\">  type_attr;</span><span style=\"color:#6A737D\">     // Type and attributes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> offset_high;</span><span style=\"color:#6A737D\">   // Offset bits 31:16</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed)) </span><span style=\"color:#79B8FF\">idt_entry_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> limit;</span><span style=\"color:#6A737D\">         // Size of IDT - 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> base;</span><span style=\"color:#6A737D\">          // Address of IDT</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed)) </span><span style=\"color:#79B8FF\">idt_ptr_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> IDT_ENTRIES</span><span style=\"color:#79B8FF\"> 256</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> IDT_INTERRUPT_GATE</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">8E</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> IDT_TRAP_GATE</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">8F</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> IDT_USER_GATE</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">EE</span></span></code></pre></div>\n\n<h3 id=\"idtr-6-bytes\">IDTR (6 bytes)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Loaded via lidt instruction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// limit = sizeof(idt_entry_t) * IDT_ENTRIES - 1 = 2047</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// base = (uint32_t)&#x26;idt</span></span></code></pre></div>\n\n<h3 id=\"register-frame-structure\">Register Frame Structure</h3>\n<p>This structure matches what the assembly stubs push onto the stack:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// kernel/registers.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Pushed by our assembly stub (manual)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> gs, fs, es, ds;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Pushed by pusha (EAX, ECX, EDX, EBX, ESP(original), EBP, ESI, EDI)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> edi, esi, ebp, esp, ebx, edx, ecx, eax;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Pushed by our assembly stub</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> int_no;</span><span style=\"color:#6A737D\">        // Interrupt number</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> err_code;</span><span style=\"color:#6A737D\">      // Error code (0 for exceptions without one)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Pushed by CPU automatically</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eip, cs, eflags;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Only present if privilege change occurred (ring 3 -> ring 0)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> useresp, ss;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed)) </span><span style=\"color:#79B8FF\">registers_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p><strong>Stack layout at handler entry (grows downward):</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>High addresses\n┌─────────────────┐\n│    SS (old)     │  ← Only if privilege change\n│    ESP (old)    │  ← Only if privilege change\n├─────────────────┤\n│    EFLAGS       │  ← CPU pushes\n├─────────────────┤\n│    CS (old)     │  ← CPU pushes\n│    EIP (old)    │  ← CPU pushes\n├─────────────────┤\n│  Error Code     │  ← CPU pushes (for some exceptions) or stub pushes 0\n├─────────────────┤\n│  Interrupt #    │  ← Stub pushes\n├─────────────────┤\n│      EAX        │  ← pusha\n│      ECX        │\n│      EDX        │\n│      EBX        │\n│      ESP (old)  │  ← Value before pusha\n│      EBP        │\n│      ESI        │\n│      EDI        │  ← pusha ends\n├─────────────────┤\n│      DS         │  ← Stub pushes\n│      ES         │\n│      FS         │\n│      GS         │  ← Stub pushes\n└─────────────────┘ ← ESP points here\nLow addresses</code></pre></div>\n\n<h3 id=\"cpu-exception-vectors\">CPU Exception Vectors</h3>\n<table>\n<thead>\n<tr>\n<th>Vector</th>\n<th>Mnemonic</th>\n<th>Error Code?</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>#DE</td>\n<td>No</td>\n<td>Fault</td>\n<td>Divide Error</td>\n</tr>\n<tr>\n<td>1</td>\n<td>#DB</td>\n<td>No</td>\n<td>Fault/Trap</td>\n<td>Debug Exception</td>\n</tr>\n<tr>\n<td>2</td>\n<td>NMI</td>\n<td>No</td>\n<td>Interrupt</td>\n<td>Non-Maskable Interrupt</td>\n</tr>\n<tr>\n<td>3</td>\n<td>#BP</td>\n<td>No</td>\n<td>Trap</td>\n<td>Breakpoint (INT 3)</td>\n</tr>\n<tr>\n<td>4</td>\n<td>#OF</td>\n<td>No</td>\n<td>Trap</td>\n<td>Overflow (INTO)</td>\n</tr>\n<tr>\n<td>5</td>\n<td>#BR</td>\n<td>No</td>\n<td>Fault</td>\n<td>BOUND Range Exceeded</td>\n</tr>\n<tr>\n<td>6</td>\n<td>#UD</td>\n<td>No</td>\n<td>Fault</td>\n<td>Invalid Opcode</td>\n</tr>\n<tr>\n<td>7</td>\n<td>#NM</td>\n<td>No</td>\n<td>Fault</td>\n<td>Device Not Available (no FPU)</td>\n</tr>\n<tr>\n<td>8</td>\n<td>#DF</td>\n<td>Yes</td>\n<td>Abort</td>\n<td>Double Fault</td>\n</tr>\n<tr>\n<td>9</td>\n<td>—</td>\n<td>No</td>\n<td>Fault</td>\n<td>Coprocessor Segment Overrun (legacy)</td>\n</tr>\n<tr>\n<td>10</td>\n<td>#TS</td>\n<td>Yes</td>\n<td>Fault</td>\n<td>Invalid TSS</td>\n</tr>\n<tr>\n<td>11</td>\n<td>#NP</td>\n<td>Yes</td>\n<td>Fault</td>\n<td>Segment Not Present</td>\n</tr>\n<tr>\n<td>12</td>\n<td>#SS</td>\n<td>Yes</td>\n<td>Fault</td>\n<td>Stack-Segment Fault</td>\n</tr>\n<tr>\n<td>13</td>\n<td>#GP</td>\n<td>Yes</td>\n<td>Fault</td>\n<td>General Protection</td>\n</tr>\n<tr>\n<td>14</td>\n<td>#PF</td>\n<td>Yes</td>\n<td>Fault</td>\n<td>Page Fault</td>\n</tr>\n<tr>\n<td>15</td>\n<td>—</td>\n<td>No</td>\n<td>Fault</td>\n<td>Reserved</td>\n</tr>\n<tr>\n<td>16</td>\n<td>#MF</td>\n<td>No</td>\n<td>Fault</td>\n<td>x87 FPU Floating-Point Error</td>\n</tr>\n<tr>\n<td>17</td>\n<td>#AC</td>\n<td>Yes</td>\n<td>Fault</td>\n<td>Alignment Check</td>\n</tr>\n<tr>\n<td>18</td>\n<td>#MC</td>\n<td>No</td>\n<td>Abort</td>\n<td>Machine Check</td>\n</tr>\n<tr>\n<td>19</td>\n<td>#XM</td>\n<td>No</td>\n<td>Fault</td>\n<td>SIMD Floating-Point Exception</td>\n</tr>\n<tr>\n<td>20-31</td>\n<td>—</td>\n<td>No</td>\n<td>—</td>\n<td>Reserved</td>\n</tr>\n</tbody></table>\n<h3 id=\"error-code-format-for-vectors-8-10-14-17\">Error Code Format (for vectors 8, 10-14, 17)</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>For exceptions 8, 10-14 (segment-related):\n┌────────────────────────────────────────────────────────────────┐\n│ Bits 15-3: Selector Index  │ Bit 2: TI │ Bits 1-0: IDT/GDT/LDT│\n│                            │(0=GDT,    │ 00=GDT, 01=IDT,      │\n│                            │ 1=LDT)    │ 10=LDT, 11=IDT       │\n└────────────────────────────────────────────────────────────────┘\n\nFor page fault (exception 14):\n┌────────────────────────────────────────────────────────────────┐\n│ Bit 0 (P): 0=page not present, 1=protection violation          │\n│ Bit 1 (W): 0=read access, 1=write access                       │\n│ Bit 2 (U): 0=supervisor mode, 1=user mode                      │\n│ Bit 3 (R): 1=reserved bit set in paging structures             │\n│ Bit 4 (I): 1=instruction fetch (NX bit violation)              │\n│ Bits 5-31: Reserved                                            │\n└────────────────────────────────────────────────────────────────┘</code></pre></div>\n\n<h3 id=\"pic-configuration\">PIC Configuration</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// kernel/pic.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIC1_CMD</span><span style=\"color:#F97583\">  0x</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#6A737D\">    // Master PIC command port</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIC1_DATA</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">21</span><span style=\"color:#6A737D\">    // Master PIC data port</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIC2_CMD</span><span style=\"color:#F97583\">  0x</span><span style=\"color:#79B8FF\">A0</span><span style=\"color:#6A737D\">    // Slave PIC command port</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIC2_DATA</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">A1</span><span style=\"color:#6A737D\">    // Slave PIC data port</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIC_EOI</span><span style=\"color:#F97583\">   0x</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#6A737D\">    // End of Interrupt command</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Vector offsets after remapping</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> IRQ_BASE</span><span style=\"color:#79B8FF\">  32</span><span style=\"color:#6A737D\">      // Master IRQs start at vector 32</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> IRQ_BASE2</span><span style=\"color:#79B8FF\"> 40</span><span style=\"color:#6A737D\">      // Slave IRQs start at vector 40</span></span></code></pre></div>\n\n<h3 id=\"pit-timer-configuration\">PIT Timer Configuration</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// kernel/timer.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIT_CHANNEL0</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">40</span><span style=\"color:#6A737D\">   // Channel 0 data port</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIT_CHANNEL1</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">41</span><span style=\"color:#6A737D\">   // Channel 1 data port (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIT_CHANNEL2</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">42</span><span style=\"color:#6A737D\">   // Channel 2 data port (speaker)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIT_CMD</span><span style=\"color:#F97583\">      0x</span><span style=\"color:#79B8FF\">43</span><span style=\"color:#6A737D\">   // Mode/Command register</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIT_FREQ</span><span style=\"color:#79B8FF\">     1193182</span><span style=\"color:#6A737D\">  // Base frequency in Hz</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Command byte format:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bits 7-6: Channel (00=0, 01=1, 10=2, 11=read-back)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bits 5-4: Access mode (00=latch, 01=low, 10=high, 11=both)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bits 3-1: Mode (000=int on TC, 001=one-shot, 010=rate gen, 011=square wave, ...)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bit 0: BCD (0=binary, 1=BCD)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PIT_CMD_CHANNEL0</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">36</span><span style=\"color:#6A737D\">  // 00110110b: ch0, lobyte/hibyte, mode 3, binary</span></span></code></pre></div>\n\n<h3 id=\"keyboard-buffer-and-scancode-table\">Keyboard Buffer and Scancode Table</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// kernel/keyboard.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KB_DATA_PORT</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">60</span><span style=\"color:#6A737D\">   // Keyboard data register</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KB_CMD_PORT</span><span style=\"color:#F97583\">  0x</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#6A737D\">   // Keyboard command/status register</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KB_BUFFER_SIZE</span><span style=\"color:#79B8FF\"> 128</span><span style=\"color:#6A737D\">  // Circular buffer size</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> buffer</span><span style=\"color:#E1E4E8\">[KB_BUFFER_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> head;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> tail;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">kb_buffer_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Scancode Set 1 (US QWERTY) - make codes only</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Index = scancode, value = ASCII character (0 if not printable)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#FFAB70\"> scancode_to_ascii</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    0</span><span style=\"color:#E1E4E8\">,    </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,   </span><span style=\"color:#9ECBFF\">'1'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'2'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'3'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'4'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'5'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'6'</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">     // 0x00-0x07</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '7'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'8'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'9'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'0'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'-'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'='</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\b</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\t</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">    // 0x08-0x0F</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'q'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'w'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'e'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'r'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'t'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'y'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'u'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'i'</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">     // 0x10-0x17</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'o'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'p'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'['</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">']'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,   </span><span style=\"color:#9ECBFF\">'a'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'s'</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">    // 0x18-0x1F (0x1D=ctrl)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'd'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'f'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'g'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'h'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'j'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'k'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'l'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">';'</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">     // 0x20-0x27</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '</span><span style=\"color:#79B8FF\">\\'</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'`'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,   </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\\\</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'z'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'x'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'c'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'v'</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">   // 0x28-0x2F (0x2A=shift)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'b'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'n'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'m'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">','</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'.'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'/'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,   </span><span style=\"color:#9ECBFF\">'*'</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">     // 0x30-0x37 (0x36=shift, 0x37=* on keypad)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    0</span><span style=\"color:#E1E4E8\">,   </span><span style=\"color:#9ECBFF\">' '</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">                                    // 0x38-0x39 (0x38=alt, 0x39=space)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 0x3A-0x45: capslock, F1-F10, numlock, scrolllock, etc.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Extended codes (0xE0 prefix) handled separately</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"interface-contracts\">Interface Contracts</h2>\n<h3 id=\"idt_init\">idt_init()</h3>\n<p><strong>Purpose</strong>: Initialize the IDT with 256 entries</p>\n<p><strong>Parameters</strong>: None</p>\n<p><strong>Returns</strong>: None</p>\n<p><strong>Side effects</strong>:</p>\n<ul>\n<li>Zeros all 256 IDT entries</li>\n<li>Loads IDTR via <code>lidt</code></li>\n<li>Does NOT enable interrupts</li>\n</ul>\n<p><strong>Preconditions</strong>: GDT must be loaded</p>\n<p><strong>Postconditions</strong>: IDT is ready to have handlers registered</p>\n<h3 id=\"idt_set_gateuint8_t-num-uint32_t-handler-uint16_t-sel-uint8_t-flags\">idt_set_gate(uint8_t num, uint32_t handler, uint16_t sel, uint8_t flags)</h3>\n<p><strong>Purpose</strong>: Register an interrupt handler in the IDT</p>\n<p><strong>Parameters</strong>:</p>\n<ul>\n<li><code>num</code>: Vector number (0-255)</li>\n<li><code>handler</code>: Address of handler function</li>\n<li><code>sel</code>: Code segment selector (typically 0x08)</li>\n<li><code>flags</code>: Type/attributes byte (e.g., IDT_INTERRUPT_GATE)</li>\n</ul>\n<p><strong>Returns</strong>: None</p>\n<p><strong>Side effects</strong>: Modifies IDT entry at index <code>num</code></p>\n<p><strong>Constraints</strong>:</p>\n<ul>\n<li>Handler must be a valid 32-bit address</li>\n<li>Selector must point to a valid code segment</li>\n</ul>\n<h3 id=\"isr_handlerregisters_t-regs-c-function-called-from-assembly\">isr_handler(registers_t *regs) [C function called from assembly]</h3>\n<p><strong>Purpose</strong>: Common dispatcher for CPU exceptions</p>\n<p><strong>Parameters</strong>: <code>regs</code> — pointer to saved register frame on stack</p>\n<p><strong>Returns</strong>: None (returns via <code>iret</code> in assembly)</p>\n<p><strong>Responsibilities</strong>:</p>\n<ul>\n<li>Dispatch to specific exception handler based on <code>regs-&gt;int_no</code></li>\n<li>Print diagnostic for unhandled exceptions</li>\n<li>Halt on fatal exceptions (double fault, GPF, etc.)</li>\n</ul>\n<h3 id=\"irq_handlerregisters_t-regs-c-function-called-from-assembly\">irq_handler(registers_t *regs) [C function called from assembly]</h3>\n<p><strong>Purpose</strong>: Common dispatcher for hardware IRQs</p>\n<p><strong>Parameters</strong>: <code>regs</code> — pointer to saved register frame on stack</p>\n<p><strong>Returns</strong>: None (returns via <code>iret</code> in assembly)</p>\n<p><strong>Responsibilities</strong>:</p>\n<ul>\n<li>Call device-specific handler (timer, keyboard, etc.)</li>\n<li>Send EOI to PIC</li>\n<li>Never return without sending EOI</li>\n</ul>\n<h3 id=\"pic_remapuint8_t-offset1-uint8_t-offset2\">pic_remap(uint8_t offset1, uint8_t offset2)</h3>\n<p><strong>Purpose</strong>: Remap PIC IRQs to non-conflicting vectors</p>\n<p><strong>Parameters</strong>:</p>\n<ul>\n<li><code>offset1</code>: Vector offset for master PIC (typically 32)</li>\n<li><code>offset2</code>: Vector offset for slave PIC (typically 40)</li>\n</ul>\n<p><strong>Returns</strong>: None</p>\n<p><strong>Side effects</strong>:</p>\n<ul>\n<li>Sends ICW1-ICW4 to both PICs</li>\n<li>Masks all IRQs initially</li>\n<li>Changes IRQ-to-vector mapping permanently</li>\n</ul>\n<p><strong>Preconditions</strong>: Must be called before any IRQs are unmasked</p>\n<p><strong>Critical</strong>: Without remapping, IRQ0 fires at vector 8 (double fault!)</p>\n<h3 id=\"pic_send_eoiuint8_t-irq\">pic_send_eoi(uint8_t irq)</h3>\n<p><strong>Purpose</strong>: Signal End of Interrupt to PIC</p>\n<p><strong>Parameters</strong>: <code>irq</code> — IRQ number (0-15)</p>\n<p><strong>Returns</strong>: None</p>\n<p><strong>Side effects</strong>: Allows PIC to deliver next interrupt</p>\n<p><strong>Critical</strong>: MUST be called at end of every IRQ handler, or system hangs</p>\n<h3 id=\"pic_mask_irquint8_t-irq\">pic_mask_irq(uint8_t irq)</h3>\n<p><strong>Purpose</strong>: Mask (disable) a specific IRQ</p>\n<p><strong>Parameters</strong>: <code>irq</code> — IRQ number (0-15)</p>\n<p><strong>Returns</strong>: None</p>\n<h3 id=\"pic_unmask_irquint8_t-irq\">pic_unmask_irq(uint8_t irq)</h3>\n<p><strong>Purpose</strong>: Unmask (enable) a specific IRQ</p>\n<p><strong>Parameters</strong>: <code>irq</code> — IRQ number (0-15)</p>\n<p><strong>Returns</strong>: None</p>\n<h3 id=\"timer_inituint32_t-frequency\">timer_init(uint32_t frequency)</h3>\n<p><strong>Purpose</strong>: Initialize PIT to fire at specified frequency</p>\n<p><strong>Parameters</strong>: <code>frequency</code> — desired frequency in Hz (typically 100)</p>\n<p><strong>Returns</strong>: None</p>\n<p><strong>Side effects</strong>:</p>\n<ul>\n<li>Programs PIT channel 0</li>\n<li>Does NOT unmask IRQ0 (caller must do this)</li>\n</ul>\n<p><strong>Constraints</strong>: Frequency should be 18Hz to 1.193MHz (divisor 1-65535)</p>\n<h3 id=\"timer_handlervoid\">timer_handler(void)</h3>\n<p><strong>Purpose</strong>: Handle timer interrupt (IRQ0)</p>\n<p><strong>Parameters</strong>: None (called from irq_handler)</p>\n<p><strong>Returns</strong>: None</p>\n<p><strong>Side effects</strong>: Increments global tick counter</p>\n<h3 id=\"keyboard_initvoid\">keyboard_init(void)</h3>\n<p><strong>Purpose</strong>: Initialize PS/2 keyboard driver</p>\n<p><strong>Parameters</strong>: None</p>\n<p><strong>Returns</strong>: None</p>\n<p><strong>Side effects</strong>: Clears keyboard buffer</p>\n<h3 id=\"keyboard_handlervoid\">keyboard_handler(void)</h3>\n<p><strong>Purpose</strong>: Handle keyboard interrupt (IRQ1)</p>\n<p><strong>Parameters</strong>: None (called from irq_handler)</p>\n<p><strong>Returns</strong>: None</p>\n<p><strong>Side effects</strong>: Reads scancode, converts to ASCII, stores in buffer</p>\n<h3 id=\"kb_getcharvoid\">kb_getchar(void)</h3>\n<p><strong>Purpose</strong>: Non-blocking read from keyboard buffer</p>\n<p><strong>Parameters</strong>: None</p>\n<p><strong>Returns</strong>: </p>\n<ul>\n<li>ASCII character if available</li>\n<li>-1 if buffer empty</li>\n</ul>\n<p><strong>Thread safety</strong>: Buffer is lock-free but safe for single consumer</p>\n<hr>\n<h2 id=\"algorithm-specification\">Algorithm Specification</h2>\n<h3 id=\"idt-initialization\">IDT Initialization</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>IDT_INIT:\n  1. Zero all 256 IDT entries\n     FOR i = 0 TO 255:\n       idt[i].offset_low = 0\n       idt[i].selector = 0\n       idt[i].zero = 0\n       idt[i].type_attr = 0\n       idt[i].offset_high = 0\n  \n  2. Set up IDTR\n     idtr.limit = sizeof(idt_entry_t) * 256 - 1  // 2047\n     idtr.base = (uint32_t)&amp;idt\n  \n  3. Load IDT\n     asm volatile(&quot;lidt %0&quot; : : &quot;m&quot;(idtr))</code></pre></div>\n\n<h3 id=\"setting-an-idt-gate\">Setting an IDT Gate</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>IDT_SET_GATE(num, handler, sel, flags):\n  1. Extract handler address bytes\n     offset_low = handler &amp; 0xFFFF\n     offset_high = (handler &gt;&gt; 16) &amp; 0xFFFF\n  \n  2. Populate entry\n     idt[num].offset_low = offset_low\n     idt[num].selector = sel\n     idt[num].zero = 0\n     idt[num].type_attr = flags\n     idt[num].offset_high = offset_high</code></pre></div>\n\n<h3 id=\"assembly-isr-stub-exceptions-without-error-code\">Assembly ISR Stub (exceptions without error code)</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>; Macro for exceptions that DON'T push error code\n%macro ISR_NOERRCODE 1\nglobal isr%1\nisr%1:\n    push dword 0            ; Push dummy error code to unify stack frame\n    push dword %1           ; Push interrupt number\n    jmp isr_common_stub\n%endmacro</code></pre></div>\n\n<h3 id=\"assembly-isr-stub-exceptions-with-error-code\">Assembly ISR Stub (exceptions with error code)</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>; Macro for exceptions that DO push error code\n%macro ISR_ERRCODE 1\nglobal isr%1\nisr%1:\n    push dword %1           ; Push interrupt number (error code already on stack)\n    jmp isr_common_stub\n%endmacro</code></pre></div>\n\n<h3 id=\"common-isr-stub\">Common ISR Stub</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>isr_common_stub:\n    ; Save all general-purpose registers\n    pusha                   ; EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI\n    \n    ; Save segment registers\n    push ds\n    push es\n    push fs\n    push gs\n    \n    ; Load kernel data segment\n    mov ax, 0x10\n    mov ds, ax\n    mov es, ax\n    mov fs, ax\n    mov gs, ax\n    \n    ; Push pointer to stack frame\n    mov eax, esp\n    push eax\n    \n    ; Call C handler\n    extern isr_handler\n    call isr_handler\n    \n    ; Restore stack pointer (ignore return value)\n    add esp, 4\n    \n    ; Restore segment registers\n    pop gs\n    pop fs\n    pop es\n    pop ds\n    \n    ; Restore general-purpose registers\n    popa\n    \n    ; Remove error code and interrupt number\n    add esp, 8\n    \n    ; Return from interrupt\n    iret</code></pre></div>\n\n<h3 id=\"common-irq-stub\">Common IRQ Stub</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>irq_common_stub:\n    pusha\n    push ds\n    push es\n    push fs\n    push gs\n    \n    mov ax, 0x10\n    mov ds, ax\n    mov es, ax\n    mov fs, ax\n    mov gs, ax\n    \n    mov eax, esp\n    push eax\n    \n    extern irq_handler\n    call irq_handler\n    \n    add esp, 4\n    \n    pop gs\n    pop fs\n    pop es\n    pop ds\n    popa\n    \n    add esp, 8\n    \n    iret</code></pre></div>\n\n<h3 id=\"pic-remapping-sequence\">PIC Remapping Sequence</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>PIC_REMAP(offset1, offset2):\n  1. Save current masks\n     a = inb(PIC1_DATA)\n     b = inb(PIC2_DATA)\n  \n  2. Start initialization (ICW1)\n     outb(PIC1_CMD, 0x11)   ; ICW4 needed, cascade mode\n     outb(PIC2_CMD, 0x11)\n  \n  3. Set vector offsets (ICW2)\n     outb(PIC1_DATA, offset1)  ; Master: IRQ0 -&gt; vector 32\n     outb(PIC2_DATA, offset2)  ; Slave: IRQ8 -&gt; vector 40\n  \n  4. Tell master about slave (ICW3)\n     outb(PIC1_DATA, 0x04)  ; Slave at IRQ2 (bit 2 set)\n     outb(PIC2_DATA, 0x02)  ; Slave cascade identity\n  \n  5. Set 8086 mode (ICW4)\n     outb(PIC1_DATA, 0x01)  ; 8086 mode, normal EOI\n     outb(PIC2_DATA, 0x01)\n  \n  6. Restore masks\n     outb(PIC1_DATA, a)\n     outb(PIC2_DATA, b)</code></pre></div>\n\n<h3 id=\"eoi-sending\">EOI Sending</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>PIC_SEND_EOI(irq):\n  1. Always send EOI to master\n     outb(PIC1_CMD, 0x20)\n  \n  2. If IRQ &gt;= 8, also send to slave\n     IF irq &gt;= 8:\n       outb(PIC2_CMD, 0x20)</code></pre></div>\n\n<h3 id=\"pit-timer-initialization\">PIT Timer Initialization</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>TIMER_INIT(frequency):\n  1. Calculate divisor\n     divisor = 1193182 / frequency\n     IF divisor &gt; 65535: divisor = 65535\n     IF divisor &lt; 1: divisor = 1\n  \n  2. Send command byte\n     ; Channel 0, lobyte/hibyte, mode 3 (square wave), binary\n     outb(PIT_CMD, 0x36)\n  \n  3. Send divisor\n     outb(PIT_CHANNEL0, divisor &amp; 0xFF)        ; Low byte\n     outb(PIT_CHANNEL0, (divisor &gt;&gt; 8) &amp; 0xFF) ; High byte\n  \n  4. Initialize tick counter\n     timer_ticks = 0</code></pre></div>\n\n<h3 id=\"keyboard-handler\">Keyboard Handler</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>KEYBOARD_HANDLER:\n  1. Read scancode\n     scancode = inb(KB_DATA_PORT)\n  \n  2. Check for extended prefix\n     IF scancode == 0xE0:\n       extended_mode = 1\n       RETURN  // Wait for next byte\n  \n  3. Check for break code (key release)\n     released = (scancode &amp; 0x80)\n     scancode &amp;= 0x7F  // Remove break bit\n  \n  4. Handle key release\n     IF released:\n       IF scancode == LSHIFT or RSHIFT:\n         shift_held = 0\n       IF scancode == CTRL:\n         ctrl_held = 0\n       RETURN\n  \n  5. Handle modifier press\n     IF scancode == LSHIFT or RSHIFT:\n       shift_held = 1\n       RETURN\n     IF scancode == CTRL:\n       ctrl_held = 1\n       RETURN\n  \n  6. Convert to ASCII\n     IF scancode &gt;= 128:\n       RETURN  // Unknown scancode\n     c = scancode_to_ascii[scancode]\n     IF c == 0:\n       RETURN  // Non-printable key\n  \n  7. Apply modifiers\n     IF shift_held AND c &gt;= 'a' AND c &lt;= 'z':\n       c -= 32  // Uppercase\n  \n  8. Store in buffer (if space)\n     next_head = (buffer_head + 1) % KB_BUFFER_SIZE\n     IF next_head != buffer_tail:\n       buffer[buffer_head] = c\n       buffer_head = next_head</code></pre></div>\n\n<h3 id=\"double-fault-handler\">Double Fault Handler</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>DOUBLE_FAULT_HANDLER(regs):\n  1. Print banner\n     vga_set_color(RED, WHITE)\n     vga_puts(&quot;\\n!!! DOUBLE FAULT !!!\\n&quot;)\n  \n  2. Print diagnostics\n     vga_puts(&quot;EIP: &quot;); vga_put_hex(regs-&gt;eip)\n     vga_puts(&quot;  CS: &quot;); vga_put_hex(regs-&gt;cs)\n     vga_puts(&quot;\\nError code: &quot;); vga_put_hex(regs-&gt;err_code)\n  \n  3. Decode error code\n     index = (regs-&gt;err_code &gt;&gt; 3) &amp; 0x1FFF\n     table = regs-&gt;err_code &amp; 0x3\n     vga_puts(&quot;  Table: &quot;)\n     IF table == 0: vga_puts(&quot;GDT&quot;)\n     IF table == 1: vga_puts(&quot;IDT&quot;)\n     IF table == 2: vga_puts(&quot;LDT&quot;)\n     IF table == 3: vga_puts(&quot;IDT&quot;)\n     vga_puts(&quot;  Index: &quot;); vga_put_hex(index)\n  \n  4. Halt\n     vga_puts(&quot;\\nSystem halted.\\n&quot;)\n     cli\n     hlt</code></pre></div>\n\n<hr>\n<h2 id=\"error-handling-matrix\">Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th>Error</th>\n<th>Detected By</th>\n<th>Recovery</th>\n<th>User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PIC not remapped</td>\n<td>IRQ0 fires at vector 8 (double fault)</td>\n<td>Remap PIC before enabling interrupts</td>\n<td>Yes, double fault message</td>\n</tr>\n<tr>\n<td>Missing EOI</td>\n<td>System appears frozen</td>\n<td>Always call <code>pic_send_eoi</code> in IRQ handler</td>\n<td>No (just hangs)</td>\n</tr>\n<tr>\n<td>Register corruption</td>\n<td>Mysterious crashes later</td>\n<td>Ensure pusha/popa + segment saves match</td>\n<td>Yes, random faults</td>\n</tr>\n<tr>\n<td>Stack frame misalignment</td>\n<td><code>iret</code> pops wrong values</td>\n<td>Error code handling must match exception</td>\n<td>Yes, GPF or garbage EIP</td>\n</tr>\n<tr>\n<td>Double fault unhandled</td>\n<td>Triple fault (CPU reset)</td>\n<td>Install handler at IDT[8]</td>\n<td>Yes, system resets</td>\n</tr>\n<tr>\n<td>Page fault (kernel)</td>\n<td>Page fault at valid address</td>\n<td>Print CR2 and error code, halt</td>\n<td>Yes, PF message</td>\n</tr>\n<tr>\n<td>Unknown opcode</td>\n<td>#UD exception</td>\n<td>Print EIP, halt</td>\n<td>Yes, UD message</td>\n</tr>\n<tr>\n<td>Keyboard buffer overflow</td>\n<td>Buffer full</td>\n<td>Drop character, ring buffer protects</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Invalid IRQ number</td>\n<td>Array bounds</td>\n<td>Ignore invalid IRQs</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"state-machine-keyboard-scancode-parsing\">State Machine: Keyboard Scancode Parsing</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>                    ┌─────────────────┐\n                    │     IDLE        │\n                    └────────┬────────┘\n                             │\n                    ┌────────▼────────┐\n              ┌─────│  Read Scancode  │─────┐\n              │     └────────┬────────┘     │\n              │              │              │\n     ┌────────▼───┐   ┌──────▼──────┐   ┌──▼─────────┐\n     │ 0xE0 (ext) │   │ 0x00-0x7F   │   │ 0x80-0xFF │\n     │ Next byte  │   │ (make code) │   │(break code)│\n     │ is ext     │   │             │   │            │\n     └────────┬───┘   └──────┬──────┘   └─────┬──────┘\n              │              │                │\n              │       ┌──────▼──────┐   ┌─────▼──────┐\n              │       │ Modifier?   │   │ Clear held │\n              │       │ (Shift/Ctrl)│   │ flag       │\n              │       └──────┬──────┘   └────────────┘\n              │              │\n              │       ┌──────▼──────┐\n              │       │ ASCII?      │\n              │       │ Lookup table│\n              │       └──────┬──────┘\n              │              │\n              │       ┌──────▼──────┐\n              │       │ Apply mods  │\n              │       │ (shift)     │\n              │       └──────┬──────┘\n              │              │\n              │       ┌──────▼──────┐\n              │       │ Buffer full?│\n              │       └──────┬──────┘\n              │              │\n              │       ┌──────▼──────┐\n              │       │ Store char  │\n              │       │ in buffer   │\n              │       └──────┬──────┘\n              │              │\n              └──────────────►\n                    ┌───────▼───────┐\n                    │ Return (wait  │\n                    │ for next IRQ) │\n                    └───────────────┘</code></pre></div>\n\n<hr>\n<h2 id=\"implementation-sequence-with-checkpoints\">Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-idt-structure-and-loading-2-3-hours\">Phase 1: IDT Structure and Loading (2-3 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/idt.h</code>, <code>kernel/idt.c</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Define <code>idt_entry_t</code> and <code>idt_ptr_t</code> structures</li>\n<li>Declare global IDT array (256 entries)</li>\n<li>Implement <code>idt_init()</code> to zero all entries</li>\n<li>Implement <code>idt_set_gate()</code> to populate entries</li>\n<li>Implement <code>idt_load()</code> with inline assembly <code>lidt</code></li>\n</ol>\n<p><strong>Checkpoint</strong>: IDT loads without error</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Add to kernel_main.c:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">idt_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"IDT initialized</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Verify: no crash, message appears</span></span></code></pre></div>\n\n<p><strong>Test</strong>: Run in QEMU, verify no triple fault after <code>lidt</code></p>\n<h3 id=\"phase-2-assembly-isr-stubs-3-4-hours\">Phase 2: Assembly ISR Stubs (3-4 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/isr.asm</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Create macros <code>ISR_NOERRCODE</code> and <code>ISR_ERRCODE</code></li>\n<li>Generate stubs for all 32 CPU exceptions</li>\n<li>Implement <code>isr_common_stub</code> with full register save</li>\n<li>Declare global symbols for each stub</li>\n</ol>\n<p><strong>Checkpoint</strong>: Assembly compiles without error</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">nasm</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> elf32</span><span style=\"color:#9ECBFF\"> kernel/isr.asm</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> isr.o</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># No errors or warnings</span></span></code></pre></div>\n\n<p><strong>Test</strong>: Link with kernel, verify symbols exist</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">nm</span><span style=\"color:#9ECBFF\"> kernel.elf</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> isr</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show isr0, isr1, ..., isr31</span></span></code></pre></div>\n\n<h3 id=\"phase-3-register-frame-and-c-handler-2-3-hours\">Phase 3: Register Frame and C Handler (2-3 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/registers.h</code>, <code>kernel/interrupt_handler.c</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Define <code>registers_t</code> structure matching assembly push order</li>\n<li>Implement <code>isr_handler()</code> to dispatch based on <code>int_no</code></li>\n<li>Add exception messages array</li>\n<li>Implement page fault handler with CR2 read</li>\n</ol>\n<p><strong>Checkpoint</strong>: Exception handler prints diagnostics</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Trigger divide by zero:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> x </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> /</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // After interrupts enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Expected: \"EXCEPTION: Divide By Zero\" message</span></span></code></pre></div>\n\n<p><strong>Test</strong>: Force each exception, verify correct message</p>\n<h3 id=\"phase-4-pic-remapping-2-3-hours\">Phase 4: PIC Remapping (2-3 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/pic.h</code>, <code>kernel/pic.c</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Implement <code>outb</code> and <code>inb</code> inline functions</li>\n<li>Implement <code>pic_remap()</code> with ICW1-ICW4 sequence</li>\n<li>Implement <code>pic_send_eoi()</code></li>\n<li>Implement <code>pic_mask_irq()</code> and <code>pic_unmask_irq()</code></li>\n</ol>\n<p><strong>Checkpoint</strong>: PIC remaps without error</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In kernel_main, after idt_init:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pic_remap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">40</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PIC remapped</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Enable timer and keyboard:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pic_unmask_irq</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Timer</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pic_unmask_irq</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Keyboard</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Expected: No immediate crash</span></span></code></pre></div>\n\n<p><strong>Test</strong>: Unmask IRQ0, verify timer fires at vector 32 (not 8)</p>\n<h3 id=\"phase-5-irq-handlers-with-eoi-2-3-hours\">Phase 5: IRQ Handlers with EOI (2-3 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/irq.asm</code>, modify <code>kernel/interrupt_handler.c</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Create IRQ stub macros (irq0 through irq15)</li>\n<li>Implement <code>irq_common_stub</code></li>\n<li>Implement <code>irq_handler()</code> in C</li>\n<li>Add <code>pic_send_eoi()</code> call</li>\n</ol>\n<p><strong>Checkpoint</strong>: IRQ handlers run without hanging</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// After enabling IRQ0, system should not freeze</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Timer counter should increment</span></span></code></pre></div>\n\n<p><strong>Test</strong>: Enable timer IRQ, verify tick counter increases</p>\n<h3 id=\"phase-6-pit-timer-driver-2-3-hours\">Phase 6: PIT Timer Driver (2-3 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/timer.h</code>, <code>kernel/timer.c</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Implement <code>timer_init()</code> with divisor calculation</li>\n<li>Implement <code>timer_handler()</code> to increment counter</li>\n<li>Add <code>timer_get_ticks()</code> accessor</li>\n<li>Register timer handler in <code>irq_handler()</code></li>\n</ol>\n<p><strong>Checkpoint</strong>: Timer fires at configured frequency</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">timer_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 100Hz</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pic_unmask_irq</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sti</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Print tick count every second:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> last </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">timer_get_ticks</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#F97583\"> !=</span><span style=\"color:#E1E4E8\"> last) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        last </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> timer_get_ticks</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_put_dec</span><span style=\"color:#E1E4E8\">(last);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\" seconds</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    hlt</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Test</strong>: Verify seconds counter increments at correct rate</p>\n<h3 id=\"phase-7-ps2-keyboard-driver-3-4-hours\">Phase 7: PS/2 Keyboard Driver (3-4 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/keyboard.h</code>, <code>kernel/keyboard.c</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Define scancode-to-ASCII table</li>\n<li>Implement circular buffer</li>\n<li>Implement <code>keyboard_handler()</code> with scancode parsing</li>\n<li>Handle shift modifier</li>\n<li>Implement <code>kb_getchar()</code> for non-blocking read</li>\n<li>Register keyboard handler in <code>irq_handler()</code></li>\n</ol>\n<p><strong>Checkpoint</strong>: Keyboard input appears in buffer</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">keyboard_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pic_unmask_irq</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sti</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Type something: \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kb_getchar</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (c </span><span style=\"color:#F97583\">!=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_putchar</span><span style=\"color:#E1E4E8\">(c);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    hlt</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Test</strong>: Type on keyboard, verify characters appear on screen</p>\n<h3 id=\"phase-8-double-fault-handler-1-2-hours\">Phase 8: Double Fault Handler (1-2 hours)</h3>\n<p><strong>Files</strong>: Modify <code>kernel/interrupt_handler.c</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Add special case for <code>int_no == 8</code> in <code>isr_handler()</code></li>\n<li>Print detailed diagnostics (EIP, CS, error code)</li>\n<li>Halt instead of returning</li>\n</ol>\n<p><strong>Checkpoint</strong>: Double fault is caught, not triple fault</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Trigger double fault by corrupting IDT:</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">idt</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">].offset_low </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">DEAD</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Invalid handler</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">idt</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">].offset_high </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">DEAD</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">int $8</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Trigger double fault</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Expected: Double fault message, system halts (not resets)</span></span></code></pre></div>\n\n<p><strong>Test</strong>: Verify double fault handler prints message and halts</p>\n<h3 id=\"final-integration-2-3-hours\">Final Integration (2-3 hours)</h3>\n<p><strong>Goal</strong>: Complete interrupt system with all handlers working</p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Integrate all components in <code>kernel_main()</code></li>\n<li>Add proper initialization order:<ul>\n<li>GDT (already done)</li>\n<li>IDT init</li>\n<li>PIC remap</li>\n<li>Timer init</li>\n<li>Keyboard init</li>\n<li>Unmask IRQs</li>\n<li><code>sti</code></li>\n</ul>\n</li>\n<li>Create interactive test: display typed characters with timestamp</li>\n</ol>\n<p><strong>Checkpoint</strong>: All tests pass</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> kernel_main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    serial_init</span><span style=\"color:#E1E4E8\">(COM1_PORT);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Initializing IDT...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Remapping PIC...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pic_remap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">40</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Initializing timer (100Hz)...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    timer_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Initializing keyboard...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    keyboard_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Unmask timer and keyboard IRQs</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pic_unmask_irq</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pic_unmask_irq</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Enabling interrupts...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">sti</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"System ready. Type something!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kb_getchar</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (c </span><span style=\"color:#F97583\">!=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            vga_put_dec</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">timer_get_ticks</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"] \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            vga_putchar</span><span style=\"color:#E1E4E8\">(c);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">hlt</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Test Commands</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">make</span><span style=\"color:#9ECBFF\"> clean</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#B392F0\">make</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> -serial</span><span style=\"color:#9ECBFF\"> stdio</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Boot messages appear</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - \"System ready. Type something!\" appears</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Typing shows \"[tickcount] character\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Timer increments correctly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - No crashes, hangs, or triple faults</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"test-specification\">Test Specification</h2>\n<h3 id=\"test-1-idt-loads-without-crash\">Test 1: IDT Loads Without Crash</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># test_idt_load.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> subprocess</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_idt_load</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Build kernel</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> subprocess.run([</span><span style=\"color:#9ECBFF\">'make'</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#FFAB70\">capture_output</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#E1E4E8\"> result.returncode </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Build failed: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">result.stderr.decode()</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Run QEMU briefly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> subprocess.Popen(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        [</span><span style=\"color:#9ECBFF\">'qemu-system-i386'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'-drive'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'format=raw,file=os.img'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">         '-serial'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'stdio'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'-display'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'none'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'-nographic'</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        stdout</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">subprocess.</span><span style=\"color:#79B8FF\">PIPE</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        stderr</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">subprocess.</span><span style=\"color:#79B8FF\">PIPE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    time.sleep(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc.terminate()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    output, _ </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc.communicate(</span><span style=\"color:#FFAB70\">timeout</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Check for IDT init message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#F97583\"> b</span><span style=\"color:#9ECBFF\">'IDT'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> output, </span><span style=\"color:#9ECBFF\">\"IDT initialization message not found\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#F97583\"> b</span><span style=\"color:#9ECBFF\">'triple fault'</span><span style=\"color:#F97583\"> not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> output.lower(), </span><span style=\"color:#9ECBFF\">\"Triple fault detected\"</span></span></code></pre></div>\n\n<h3 id=\"test-2-pic-remaps-correctly\">Test 2: PIC Remaps Correctly</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># test_pic_remap.sh</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify IRQ0 triggers vector 32, not 8</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run QEMU with interrupt logging</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">timeout</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#9ECBFF\"> qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    -d</span><span style=\"color:#9ECBFF\"> int</span><span style=\"color:#79B8FF\"> -serial</span><span style=\"color:#9ECBFF\"> stdio</span><span style=\"color:#79B8FF\"> -display</span><span style=\"color:#9ECBFF\"> none</span><span style=\"color:#F97583\"> 2>&#x26;1</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tee</span><span style=\"color:#9ECBFF\"> int_log.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check that interrupt 32 (0x20) appears, not 8 with PIC origin</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -q</span><span style=\"color:#9ECBFF\"> \"irq 0\"</span><span style=\"color:#9ECBFF\"> int_log.txt</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"PASS: IRQ0 fires correctly\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"FAIL: No IRQ0 detected\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    exit</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span></code></pre></div>\n\n<h3 id=\"test-3-timer-fires-at-correct-frequency\">Test 3: Timer Fires at Correct Frequency</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># test_timer_frequency.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> subprocess</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_timer_frequency</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> subprocess.Popen(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        [</span><span style=\"color:#9ECBFF\">'qemu-system-i386'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'-drive'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'format=raw,file=os.img'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">         '-serial'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'stdio'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'-display'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'none'</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        stdout</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">subprocess.</span><span style=\"color:#79B8FF\">PIPE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    time.sleep(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Wait 3 seconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc.terminate()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    output, _ </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc.communicate(</span><span style=\"color:#FFAB70\">timeout</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    text </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> output.decode()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Find tick counts at different times</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Assuming we print ticks, look for increasing values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tick_pattern </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#85E89D;font-weight:bold\">\\[</span><span style=\"color:#79B8FF\">(\\d</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">)</span><span style=\"color:#85E89D;font-weight:bold\">\\]</span><span style=\"color:#9ECBFF\">'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    matches </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> re.findall(tick_pattern, text)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(matches) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#6A737D\">  # Not enough data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ticks </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">(m) </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> m </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> matches]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    elapsed_ticks </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ticks[</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> ticks[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # At 100Hz, 3 seconds should be ~300 ticks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Allow 20% tolerance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#79B8FF\"> 200</span><span style=\"color:#F97583\"> &#x3C;=</span><span style=\"color:#E1E4E8\"> elapsed_ticks </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 400</span><span style=\"color:#E1E4E8\">, \\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        f</span><span style=\"color:#9ECBFF\">\"Timer frequency off: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">elapsed_ticks</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> ticks in ~3 seconds\"</span></span></code></pre></div>\n\n<h3 id=\"test-4-keyboard-buffer-works\">Test 4: Keyboard Buffer Works</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># test_keyboard_buffer.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> subprocess</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_keyboard_buffer</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Run QEMU with keyboard input</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> subprocess.Popen(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        [</span><span style=\"color:#9ECBFF\">'qemu-system-i386'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'-drive'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'format=raw,file=os.img'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">         '-serial'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'stdio'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'-display'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'none'</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        stdin</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">subprocess.</span><span style=\"color:#79B8FF\">PIPE</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        stdout</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">subprocess.</span><span style=\"color:#79B8FF\">PIPE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Wait for ready</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    time.sleep(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Send some keystrokes via QEMU monitor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # (This is tricky; usually done with expect or pexpect)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # For now, just verify keyboard init message appears</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc.terminate()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    output, _ </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc.communicate(</span><span style=\"color:#FFAB70\">timeout</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#F97583\"> b</span><span style=\"color:#9ECBFF\">'keyboard'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> output.lower(), </span><span style=\"color:#9ECBFF\">\"Keyboard init message missing\"</span></span></code></pre></div>\n\n<h3 id=\"test-5-exception-handlers-print-diagnostics\">Test 5: Exception Handlers Print Diagnostics</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// kernel/test_exceptions.c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_divide_by_zero</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> x </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> y </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> z </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> x </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> y;</span><span style=\"color:#6A737D\">  // Should trigger #DE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)z;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_invalid_opcode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">.byte 0x06, 0x07</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Invalid on modern x86</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_page_fault</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">DEADBEEF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 42</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Should trigger #PF</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// In kernel_main, after IDT init:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Uncomment ONE test at a time:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// test_divide_by_zero();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Expected: \"EXCEPTION: Divide By Zero\" then halt</span></span></code></pre></div>\n\n<h3 id=\"test-6-eoi-is-sent\">Test 6: EOI is Sent</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># test_eoi.sh</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># If EOI is missing, system hangs after first interrupt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">timeout</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#9ECBFF\"> qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    -serial</span><span style=\"color:#9ECBFF\"> stdio</span><span style=\"color:#79B8FF\"> -display</span><span style=\"color:#9ECBFF\"> none</span><span style=\"color:#F97583\"> 2>&#x26;1</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tee</span><span style=\"color:#9ECBFF\"> eoi_log.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check for multiple timer ticks (proves EOI is working)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">tick_count</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">grep</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"seconds\"</span><span style=\"color:#9ECBFF\"> eoi_log.txt</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> echo</span><span style=\"color:#9ECBFF\"> \"0\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> [ </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$tick_count</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> -gt</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"PASS: EOI sent correctly (multiple ticks seen)\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"FAIL: System may have hung (EOI not sent?)\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    exit</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span></code></pre></div>\n\n<h3 id=\"test-7-double-fault-caught\">Test 7: Double Fault Caught</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># test_double_fault.sh</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Trigger double fault and verify handler runs (not reset)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Modify kernel to corrupt IDT[0] after setup:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># idt[0].offset_low = 0xDEAD;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># asm volatile(\"int $0\");</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Then trigger int 0 again</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: \"DOUBLE FAULT\" message, not QEMU reset</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-targets\">Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Target</th>\n<th>How to Measure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ISR entry (pusha + segs)</td>\n<td>&lt; 50 cycles</td>\n<td>Count instructions: pusha (17), push ds-es-fs-gs (3×), mov ax/mov ds (2×4) ≈ 35 cycles</td>\n</tr>\n<tr>\n<td>C handler call overhead</td>\n<td>&lt; 20 cycles</td>\n<td>Call/ret pair ≈ 5-10 cycles</td>\n</tr>\n<tr>\n<td>Total ISR entry to handler</td>\n<td>&lt; 150 cycles</td>\n<td>Sum of above plus stack manipulation</td>\n</tr>\n<tr>\n<td>EOI send</td>\n<td>&lt; 10 cycles</td>\n<td>Single <code>outb</code> instruction</td>\n</tr>\n<tr>\n<td>Keyboard scancode to buffer</td>\n<td>&lt; 500 cycles</td>\n<td>Inb (1), table lookup (5), buffer store (5)</td>\n</tr>\n<tr>\n<td>Timer tick (counter increment)</td>\n<td>&lt; 100 cycles</td>\n<td>Memory increment with lock prefix if needed</td>\n</tr>\n<tr>\n<td>Timer accuracy</td>\n<td>Within 1%</td>\n<td>Compare tick count to wall clock over 10 seconds</td>\n</tr>\n<tr>\n<td>Keyboard latency (IRQ to buffer)</td>\n<td>&lt; 1ms</td>\n<td>Measure from QEMU input to buffer write</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"hardware-soul\">Hardware Soul</h2>\n<h3 id=\"cache-lines-touched\">Cache Lines Touched</h3>\n<p><strong>IDT access</strong>: The IDT (2048 bytes) fits in 32 cache lines. The CPU reads the relevant entry during interrupt dispatch, which is cached in L1. Frequently used vectors (timer at 32, keyboard at 33) stay hot in cache.</p>\n<p><strong>Handler code</strong>: Interrupt handlers should be small and stay in cache. A 64-byte cache line holds <del>16-20 instructions. Timer handler (</del>20 instructions) and keyboard handler (~50 instructions) should remain L1-resident.</p>\n<p><strong>Keyboard buffer</strong>: 128-byte circular buffer = 2 cache lines. The head/tail indices share a cache line with the buffer.</p>\n<h3 id=\"branch-prediction\">Branch Prediction</h3>\n<p><strong>Interrupt dispatch</strong>: Fully predictable — direct table lookup using vector number. No branches in the dispatch path until the C handler&#39;s switch statement.</p>\n<p><strong>Scancode parsing</strong>: Branch-heavy due to modifier checks and table lookups. The CPU&#39;s branch predictor learns the pattern (most keys are alphanumeric, shift state changes infrequently).</p>\n<p><strong>Timer handler</strong>: Minimal branching — just increment counter. Highly predictable.</p>\n<h3 id=\"io-port-access\">I/O Port Access</h3>\n<table>\n<thead>\n<tr>\n<th>Port</th>\n<th>Access Type</th>\n<th>Latency</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0x20/0xA0 (PIC cmd)</td>\n<td>Out</td>\n<td>~1 µs</td>\n<td>EOI command</td>\n</tr>\n<tr>\n<td>0x21/0xA1 (PIC data)</td>\n<td>In/Out</td>\n<td>~1 µs</td>\n<td>Mask registers</td>\n</tr>\n<tr>\n<td>0x60 (Keyboard data)</td>\n<td>In</td>\n<td>~1 µs</td>\n<td>Scancode read</td>\n</tr>\n<tr>\n<td>0x64 (Keyboard status)</td>\n<td>In</td>\n<td>~1 µs</td>\n<td>Status check</td>\n</tr>\n<tr>\n<td>0x40/0x43 (PIT)</td>\n<td>Out</td>\n<td>~1 µs</td>\n<td>Timer programming</td>\n</tr>\n</tbody></table>\n<p>All I/O port accesses bypass the cache hierarchy entirely.</p>\n<h3 id=\"tlb-considerations\">TLB Considerations</h3>\n<p>Handlers must be in always-mapped memory. With paging enabled:</p>\n<ul>\n<li>IDT should be in identity-mapped or kernel region</li>\n<li>Handler code must be mapped in all address spaces</li>\n<li>Stack must be valid (kernel stack at known address)</li>\n</ul>\n<h3 id=\"interrupt-latency-components\">Interrupt Latency Components</h3>\n<ol>\n<li><strong>Hardware latency</strong>: IRQ assertion to CPU response (~1-2 µs)</li>\n<li><strong>CPU dispatch</strong>: Vector lookup, privilege check, stack switch (~50-100 cycles)</li>\n<li><strong>Software save</strong>: pusha + segment saves (~40 cycles)</li>\n<li><strong>Handler execution</strong>: Variable (timer: ~20 cycles, keyboard: ~100 cycles)</li>\n<li><strong>Restore + iret</strong>: popa + segment restores + iret (~50 cycles)</li>\n<li><strong>EOI</strong>: outb to PIC (~1 µs)</li>\n</ol>\n<p>Total minimum latency: ~2-5 µs for timer, ~5-10 µs for keyboard</p>\n<hr>\n<h2 id=\"concurrency-specification\">Concurrency Specification</h2>\n<h3 id=\"interrupt-context\">Interrupt Context</h3>\n<p>Interrupt handlers run in a special context:</p>\n<ul>\n<li><strong>Atomic entry</strong>: CPU automatically disables interrupts (for interrupt gates) during dispatch</li>\n<li><strong>No preemption</strong>: Handler cannot be preempted by same or lower priority interrupt</li>\n<li><strong>No blocking</strong>: Handler must not sleep, wait, or call any blocking function</li>\n<li><strong>No per-process state</strong>: Handler may run in context of any process</li>\n</ul>\n<h3 id=\"shared-data\">Shared Data</h3>\n<table>\n<thead>\n<tr>\n<th>Data</th>\n<th>Access Pattern</th>\n<th>Protection</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Timer tick counter</td>\n<td>Write (IRQ), Read (any)</td>\n<td><code>volatile</code>, atomic increment</td>\n</tr>\n<tr>\n<td>Keyboard buffer</td>\n<td>Write (IRQ), Read (any)</td>\n<td>Lock-free circular buffer</td>\n</tr>\n<tr>\n<td>Keyboard head/tail</td>\n<td>Write (IRQ updates head, user updates tail)</td>\n<td>Index variables, careful ordering</td>\n</tr>\n<tr>\n<td>IDT entries</td>\n<td>Write (init only), Read (CPU)</td>\n<td>No protection needed (one-time init)</td>\n</tr>\n<tr>\n<td>PIC masks</td>\n<td>Read/Write (any)</td>\n<td>No concurrent access expected</td>\n</tr>\n</tbody></table>\n<h3 id=\"critical-sections\">Critical Sections</h3>\n<p>During IDT/PIC initialization:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> interrupt_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cli</span><span style=\"color:#E1E4E8\">();</span><span style=\"color:#6A737D\">  // Disable interrupts during setup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pic_remap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">40</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Register handlers...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sti</span><span style=\"color:#E1E4E8\">();</span><span style=\"color:#6A737D\">  // Re-enable after complete setup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"re-entrancy\">Re-entrancy</h3>\n<p>Handlers are NOT re-entrant by default (interrupt gates clear IF). If re-entrancy is needed:</p>\n<ol>\n<li>Use trap gate instead of interrupt gate</li>\n<li>Manually re-enable interrupts with <code>sti</code> in handler</li>\n<li>Protect shared data with per-vector locks</li>\n</ol>\n<hr>\n<h2 id=\"implementation-notes\">Implementation Notes</h2>\n<h3 id=\"register-save-order\">Register Save Order</h3>\n<p>The order MUST match the <code>registers_t</code> structure:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; Assembly pushes:\npush gs       ; Offset +0\npush fs       ; Offset +4\npush es       ; Offset +8\npush ds       ; Offset +12\npusha         ; EDI+16, ESI+20, EBP+24, ESP+28, EBX+32, EDX+36, ECX+40, EAX+44\npush int_no   ; Offset +48\npush err_code ; Offset +52\n; CPU already pushed: EIP+56, CS+60, EFLAGS+64\n; If ring change: ESP+68, SS+72</code></pre></div>\n\n<h3 id=\"error-code-handling\">Error Code Handling</h3>\n<p>Some exceptions push error code, some don&#39;t:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; Exceptions WITHOUT error code (use dummy push):\nISR_NOERRCODE 0   ; #DE\nISR_NOERRCODE 1   ; #DB\nISR_NOERRCODE 2   ; NMI\nISR_NOERRCODE 3   ; #BP\nISR_NOERRCODE 4   ; #OF\nISR_NOERRCODE 5   ; #BR\nISR_NOERRCODE 6   ; #UD\nISR_NOERRCODE 7   ; #NM\nISR_ERRCODE   8   ; #DF (HAS error code)\nISR_NOERRCODE 9   ; Coprocessor Segment Overrun\nISR_ERRCODE   10  ; #TS\nISR_ERRCODE   11  ; #NP\nISR_ERRCODE   12  ; #SS\nISR_ERRCODE   13  ; #GP\nISR_ERRCODE   14  ; #PF\n; ... continue pattern</code></pre></div>\n\n<h3 id=\"pic-mask-management\">PIC Mask Management</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Unmask IRQ:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pic_unmask_irq</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> irq</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> port;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> value;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (irq </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PIC1_DATA;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PIC2_DATA;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        irq </span><span style=\"color:#F97583\">-=</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    value </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> inb</span><span style=\"color:#E1E4E8\">(port) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> irq);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(port, value);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Mask IRQ:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pic_mask_irq</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> irq</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> port;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> value;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (irq </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PIC1_DATA;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PIC2_DATA;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        irq </span><span style=\"color:#F97583\">-=</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    value </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> inb</span><span style=\"color:#E1E4E8\">(port) </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> irq);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    outb</span><span style=\"color:#E1E4E8\">(port, value);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"extended-scancodes\">Extended Scancodes</h3>\n<p>Arrow keys and navigation cluster send 0xE0 prefix:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> extended_scancode </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> keyboard_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> scancode </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> inb</span><span style=\"color:#E1E4E8\">(KB_DATA_PORT);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (scancode </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">E0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        extended_scancode </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Wait for next byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (extended_scancode) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        extended_scancode </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Handle extended code: scancode is the second byte</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Arrow keys: 0x48=up, 0x50=down, 0x4B=left, 0x4D=right</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // ...</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Normal scancode handling...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"visual-diagrams\">Visual Diagrams</h2>\n<h3 id=\"idt-entry-structure\">IDT Entry Structure</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>IDT Gate Descriptor (8 bytes):\n┌─────────────────────────────────────────────────────────────────┐\n│ 63       48│47       32│31   24│23 16│15      0│               │\n│  Offset    │  Offset   │       │ Seg │  Offset │               │\n│  High      │  High     │ Zero  │ Sel │  Low    │               │\n│  [31:16]   │  [31:16]  │       │     │  [15:0] │               │\n└─────────────────────────────────────────────────────────────────┘\n              │           │       │     │         │\n              │           │       │     │         └─ Handler address bits 15:0\n              │           │       │     └─ Code segment selector (0x08)\n              │           │       └─ Reserved (must be 0)\n              │           └─ Type/Attributes:\n              │              ┌──────────────────────────┐\n              │              │ P DPL 0 Type             │\n              │              │ 1 00  0 1110 = 0x8E      │\n              │              │ ↑  ↑   ↑ ↑               │\n              │              │ │  │   │ └─ Gate type    │\n              │              │ │  │   └─ System (0)    │\n              │              │ │  └─ Privilege level   │\n              │              │ └─ Present              │\n              └─ Handler address bits 31:16</code></pre></div>\n\n<h3 id=\"interrupt-stack-frame\">Interrupt Stack Frame</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>                 High Addresses\n                 ┌─────────────────┐\n                 │    SS (old)     │ ← Only if privilege change (ring 3→0)\n                 │    ESP (old)    │\n                 ├─────────────────┤\n                 │    EFLAGS       │ ← CPU pushes\n                 ├─────────────────┤\n                 │    CS (old)     │ ← CPU pushes\n                 │    EIP (old)    │ ← CPU pushes\n                 ├─────────────────┤\n                 │  Error Code     │ ← CPU (some) or stub (dummy 0)\n                 ├─────────────────┤\n                 │  Interrupt #    │ ← Stub pushes\n                 ├─────────────────┤\n                 │      EAX        │ ← pusha\n                 │      ECX        │\n                 │      EDX        │\n                 │      EBX        │\n                 │   ESP (before   │\n                 │    pusha)       │\n                 │      EBP        │\n                 │      ESI        │\n                 │      EDI        │ ← pusha ends\n                 ├─────────────────┤\n                 │      DS         │ ← Stub pushes\n                 │      ES         │\n                 │      FS         │\n                 │      GS         │ ← Stub pushes\n                 └─────────────────┘ ← ESP points here\n                 Low Addresses\n\nregisters_t structure maps this exactly:\n  gs, fs, es, ds                    (offset 0-15)\n  edi, esi, ebp, esp, ebx, edx, ecx, eax  (offset 16-47)\n  int_no, err_code                  (offset 48-55)\n  eip, cs, eflags                   (offset 56-67)\n  useresp, ss                       (offset 68-75, optional)</code></pre></div>\n\n<h3 id=\"pic-remapping\">PIC Remapping</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>BEFORE Remapping (Default):\n┌──────────────────────────────────────────────────────────┐\n│ IRQ 0 1 2 3 4 5 6 7 │ IRQ 8  9  10 11 12 13 14 15      │\n│     ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ │    ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓        │\n│ Vec 8 9 A B C D E F │   70 71 72 73 74 75 76 77        │\n│     ↑ CONFLICT!     │                                   │\n│     #DF is vec 8!   │                                   │\n└──────────────────────────────────────────────────────────┘\n\nAFTER Remapping:\n┌──────────────────────────────────────────────────────────┐\n│ IRQ 0 1 2 3 4 5 6 7 │ IRQ 8  9  10 11 12 13 14 15      │\n│     ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ │    ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓        │\n│ Vec 32 33 34 35 36 37 38 39 │ 40 41 42 43 44 45 46 47  │\n│     ↑ Timer  ↑ Keyb │    ↑ RTC                          │\n│     (no conflict)   │                                   │\n└──────────────────────────────────────────────────────────┘\n\nCPU Exception Vectors (0-31) remain for CPU-detected faults:\n┌──────────────────────────────────────────────────────────┐\n│ 0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 ...    │\n│ #DE #DB NMI #BP #OF #BR #UD #NM #DF -- #TS #NP #SS #GP #PF│\n└──────────────────────────────────────────────────────────┘</code></pre></div>\n\n<h3 id=\"exception-vectors-and-error-codes\">Exception Vectors and Error Codes</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>CPU Exception Vectors (0-31):\n\n┌────┬───────┬────────┬───────────────────────────────────────┐\n│Vec │ Name  │ Error? │                Cause                  │\n├────┼───────┼────────┼───────────────────────────────────────┤\n│ 0  │ #DE   │ No     │ Division by zero or overflow          │\n│ 1  │ #DB   │ No     │ Debug trap (single step, breakpoint)  │\n│ 2  │ NMI   │ No     │ Hardware NMI (parity error, etc.)     │\n│ 3  │ #BP   │ No     │ INT 3 instruction (debugger)          │\n│ 4  │ #OF   │ No     │ INTO instruction with OF flag set     │\n│ 5  │ #BR   │ No     │ BOUND instruction range exceeded      │\n│ 6  │ #UD   │ No     │ Invalid or privileged instruction     │\n│ 7  │ #NM   │ No     │ FPU instruction with no FPU present   │\n│ 8  │ #DF   │ Yes    │ Exception during exception handling   │\n│ 9  │ --    │ No     │ (Reserved, coprocessor segment overrun)│\n│ 10 │ #TS   │ Yes    │ Invalid TSS during task switch        │\n│ 11 │ #NP   │ Yes    │ Segment or gate not present           │\n│ 12 │ #SS   │ Yes    │ Stack segment limit violation         │\n│ 13 │ #GP   │ Yes    │ General protection violation          │\n│ 14 │ #PF   │ Yes    │ Page not present or protection fault  │\n│ 15 │ --    │ No     │ Reserved                              │\n│ 16 │ #MF   │ No     │ x87 FPU error                         │\n│ 17 │ #AC   │ Yes    │ Alignment check (alignment mode)      │\n│ 18 │ #MC   │ No     │ Machine check (hardware error)        │\n│ 19 │ #XM   │ No     │ SIMD floating-point exception         │\n│20-31│ --   │ No     │ Reserved                              │\n└────┴───────┴────────┴───────────────────────────────────────┘\n\nPage Fault Error Code (vector 14):\n┌────┬─────────────────────────────────────────────────────────┐\n│Bit │                         Meaning                         │\n├────┼─────────────────────────────────────────────────────────┤\n│ 0  │ P: 0=page not present, 1=protection violation           │\n│ 1  │ W: 0=read access, 1=write access                        │\n│ 2  │ U: 0=supervisor mode, 1=user mode                       │\n│ 3  │ R: 1=reserved bit set in paging structures              │\n│ 4  │ I: 1=instruction fetch (NX bit violation)               │\n│5-31│ Reserved                                                │\n└────┴─────────────────────────────────────────────────────────┘</code></pre></div>\n\n<h3 id=\"keyboard-scancode-flow\">Keyboard Scancode Flow</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Keyboard Scancode Processing:\n\n┌─────────────────────────────────────────────────────────────────┐\n│                     KEYBOARD CONTROLLER                         │\n│                    (sends scancode)                             │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │ IRQ1\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│                     IRQ1 HANDLER                                │\n│  1. Read scancode from port 0x60                                │\n│  2. Check for 0xE0 (extended prefix)                            │\n│  3. Check for break code (bit 7)                                │\n│  4. Update modifier state (shift, ctrl, alt)                    │\n│  5. Lookup ASCII in scancode table                              │\n│  6. Apply modifiers (shift -&gt; uppercase)                        │\n│  7. Store in circular buffer                                    │\n│  8. Send EOI                                                    │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│                   CIRCULAR BUFFER                               │\n│  ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐ │\n│  │ H │ e │ l │ l │ o │   │   │   │   │   │   │   │   │   │   │ │\n│  └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘ │\n│        ↑                                                   ↑   │\n│       tail                                                head │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │ kb_getchar()\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│                     APPLICATION                                │\n│  int c = kb_getchar();                                          │\n│  if (c != -1) { vga_putchar(c); }                              │\n└─────────────────────────────────────────────────────────────────┘\n\nScancode Table (Set 1, partial):\n┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐\n│ 01 │ 02 │ 03 │ 04 │ 05 │ 06 │ 07 │ 08 │ 09 │ 0A │ 0B │ 0C │\n│Esc │ 1  │ 2  │ 3  │ 4  │ 5  │ 6  │ 7  │ 8  │ 9  │ 0  │ -  │\n├────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┤\n│ 0D │ 0E │ 0F │ 10 │ 11 │ 12 │ 13 │ 14 │ 15 │ 16 │ 17 │ 18 │\n│ =  │BkSp│Tab │ q  │ w  │ e  │ r  │ t  │ y  │ u  │ i  │ o  │\n├────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┤\n│ 19 │ 1A │ 1B │ 1C │ 1E │ 1F │ 20 │ 21 │ 22 │ 23 │ 24 │ 25 │\n│ p  │ [  │ ]  │Enter│ a │ s  │ d  │ f  │ g  │ h  │ j  │ k  │\n├────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┤\n│ 26 │ 27 │ 28 │ 29 │ 2B │ 2C │ 2D │ 2E │ 2F │ 30 │ 31 │ 32 │\n│ l  │ ;  │ '  │ `  │ \\  │ z  │ x  │ c  │ v  │ b  │ n  │ m  │\n├────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┤\n│ 33 │ 34 │ 35 │ 39 │                                              \n│ ,  │ .  │ /  │Space│ ...etc...                                   \n└────┴────┴────┴────┴───────────────────────────────────────────┘</code></pre></div>\n\n<h3 id=\"isr-state-machine\">ISR State Machine</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ISR/IRQ Processing State Machine:\n\n                    ┌──────────────────┐\n                    │   CPU Running    │\n                    │   User/Kernel    │\n                    │     Code         │\n                    └────────┬─────────┘\n                             │\n              Interrupt/IRQ  │\n              ──────────────▶│\n                             ▼\n                    ┌──────────────────┐\n                    │  CPU Pushes:     │\n                    │  EFLAGS, CS, EIP │\n                    │  (SS, ESP if     │\n                    │   ring change)   │\n                    └────────┬─────────┘\n                             │\n                             ▼\n                    ┌──────────────────┐\n                    │  IDT Lookup      │\n                    │  (vector → gate) │\n                    └────────┬─────────┘\n                             │\n                    ┌────────▼─────────┐\n                    │   Our Stub:      │\n                    │   Push err/dummy │\n                    │   Push int_no    │\n                    └────────┬─────────┘\n                             │\n                    ┌────────▼─────────┐\n                    │   pusha          │\n                    │   push segs      │\n                    └────────┬─────────┘\n                             │\n                    ┌────────▼─────────┐\n                    │ Load kernel DS   │\n                    │ Call C handler   │\n                    └────────┬─────────┘\n                             │\n              ┌──────────────┴──────────────┐\n              │                             │\n              ▼                             ▼\n     ┌─────────────────┐          ┌─────────────────┐\n     │   ISR Handler   │          │   IRQ Handler   │\n     │  (Exception)    │          │  (Hardware)     │\n     │                 │          │                 │\n     │ Print message   │          │ Call device     │\n     │ Halt if fatal   │          │ handler         │\n     └────────┬────────┘          │ Send EOI to PIC │\n              │                   └────────┬────────┘\n              │                             │\n              └──────────────┬──────────────┘\n                             │\n                    ┌────────▼─────────┐\n                    │   pop segs       │\n                    │   popa           │\n                    │   add esp, 8     │\n                    │   iret           │\n                    └────────┬─────────┘\n                             │\n                             ▼\n                    ┌──────────────────┐\n                    │   Resume         │\n                    │   Interrupted    │\n                    │   Code           │\n                    └──────────────────┘</code></pre></div>\n\n<hr>\n<!-- TDD_MOD_ID: mod-memory -->\n<h1 id=\"technical-design-specification-physical-and-virtual-memory-management\">Technical Design Specification: Physical and Virtual Memory Management</h1>\n<h2 id=\"module-charter\">Module Charter</h2>\n<p>The memory management module implements physical frame allocation using a bitmap allocator, two-level x86 page tables (page directory + page tables) for virtual memory, identity mapping for the first 16MB plus higher-half kernel mapping at 0xC0000000, and a kernel heap allocator (kmalloc/kfree). It parses the E820/multiboot memory map to discover usable physical memory regions.</p>\n<p><strong>What it does NOT do</strong>: This module does not implement per-process address spaces (all processes share kernel mapping), does not implement demand paging or swap, does not implement copy-on-write, does not handle memory-mapped files, and does not implement user-space malloc (only kernel kmalloc).</p>\n<p><strong>Upstream dependencies</strong>: GDT must be loaded with flat kernel segments; IDT must have page fault handler registered at vector 14; multiboot bootloader must provide memory map.</p>\n<p><strong>Downstream consumers</strong>: Process manager (Milestone 4) will use page directory cloning for per-process address spaces; all kernel code uses kmalloc/kfree for dynamic allocation; device drivers use identity-mapped MMIO regions.</p>\n<p><strong>Invariants</strong>: Frame allocator must never return a frame containing kernel code/data; page tables must always have kernel region (0xC0000000+) mapped identically across all page directories; TLB must be invalidated after any page table modification; kmalloc must never return memory below 0xC0400000 (kernel heap region).</p>\n<hr>\n<h2 id=\"file-structure\">File Structure</h2>\n<p>Create files in this order:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>1. kernel/memory/e820.h          # E820/multiboot memory map structures\n2. kernel/memory/e820.c          # Memory map parser and printer\n3. kernel/memory/frame.h         # Frame allocator interface\n4. kernel/memory/frame.c         # Bitmap frame allocator implementation\n5. kernel/memory/paging.h        # Page table structures and interface\n6. kernel/memory/paging.c        # Page directory/table management\n7. kernel/memory/heap.h          # kmalloc/kfree interface\n8. kernel/memory/heap.c          # Kernel heap implementation\n9. kernel/memory/memory.c        # Top-level memory init integrating all components\n10. kernel/linker.ld             # Updated linker script with higher-half symbols</code></pre></div>\n\n<hr>\n<h2 id=\"complete-data-model\">Complete Data Model</h2>\n<h3 id=\"e820-memory-map-entry-20-bytes\">E820 Memory Map Entry (20 bytes)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// kernel/memory/e820.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> base;</span><span style=\"color:#6A737D\">          // Base address of region</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> length;</span><span style=\"color:#6A737D\">        // Length of region in bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> type;</span><span style=\"color:#6A737D\">          // Type of memory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> acpi;</span><span style=\"color:#6A737D\">          // ACPI extended attributes (optional)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed)) </span><span style=\"color:#79B8FF\">e820_entry_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Memory region types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> E820_USABLE</span><span style=\"color:#79B8FF\">         1</span><span style=\"color:#6A737D\">   // Normal RAM</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> E820_RESERVED</span><span style=\"color:#79B8FF\">       2</span><span style=\"color:#6A737D\">   // Reserved, do not use</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> E820_ACPI_RECLAIM</span><span style=\"color:#79B8FF\">   3</span><span style=\"color:#6A737D\">   // ACPI reclaimable (read tables first)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> E820_ACPI_NVS</span><span style=\"color:#79B8FF\">       4</span><span style=\"color:#6A737D\">   // ACPI non-volatile storage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> E820_BAD</span><span style=\"color:#79B8FF\">            5</span><span style=\"color:#6A737D\">   // Bad memory (errors)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parsed memory region for internal use</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> base;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> length;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> type;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">memory_region_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_MEMORY_REGIONS</span><span style=\"color:#79B8FF\">  64</span></span></code></pre></div>\n\n<h3 id=\"multiboot-memory-map-header\">Multiboot Memory Map Header</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// From multiboot specification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> size;</span><span style=\"color:#6A737D\">              // Size of this structure (minus size field)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> base_addr;</span><span style=\"color:#6A737D\">         // Base address</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> length;</span><span style=\"color:#6A737D\">            // Length</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> type;</span><span style=\"color:#6A737D\">              // Type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed)) </span><span style=\"color:#79B8FF\">multiboot_mmap_entry_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Multiboot info structure (partial)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> flags;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> mem_lower;</span><span style=\"color:#6A737D\">         // KB of low memory (0-640KB)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> mem_upper;</span><span style=\"color:#6A737D\">         // KB of high memory (1MB+)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... other fields ...</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> mmap_length;</span><span style=\"color:#6A737D\">       // Memory map length</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> mmap_addr;</span><span style=\"color:#6A737D\">         // Memory map address</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed)) </span><span style=\"color:#79B8FF\">multiboot_info_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<h3 id=\"frame-allocator-state\">Frame Allocator State</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// kernel/memory/frame.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FRAME_SIZE</span><span style=\"color:#79B8FF\">          4096</span><span style=\"color:#6A737D\">        // 4KB per frame</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FRAME_SHIFT</span><span style=\"color:#79B8FF\">         12</span><span style=\"color:#6A737D\">          // log2(4096)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BITS_PER_DWORD</span><span style=\"color:#79B8FF\">      32</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Frame allocator state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">bitmap;</span><span style=\"color:#6A737D\">                 // Bitmap: 1 = allocated, 0 = free</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> bitmap_size;</span><span style=\"color:#6A737D\">             // Number of uint32_t entries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> total_frames;</span><span style=\"color:#6A737D\">            // Total frames in system</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> free_frames;</span><span style=\"color:#6A737D\">             // Currently free frames</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> first_usable;</span><span style=\"color:#6A737D\">            // First frame number that's usable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> kernel_end_frame;</span><span style=\"color:#6A737D\">        // First frame after kernel</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">frame_allocator_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#79B8FF\"> frame_allocator_t</span><span style=\"color:#E1E4E8\"> frame_alloc;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Convert between physical address and frame number</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ADDR_TO_FRAME</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">addr</span><span style=\"color:#E1E4E8\">)     ((addr) </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> FRAME_SHIFT)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FRAME_TO_ADDR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frame</span><span style=\"color:#E1E4E8\">)    ((frame) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> FRAME_SHIFT)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Bitmap operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> frame_set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> frame</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frame_alloc.bitmap[frame </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> BITS_PER_DWORD] </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> (frame </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> BITS_PER_DWORD));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> frame_clear</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> frame</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frame_alloc.bitmap[frame </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> BITS_PER_DWORD] </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> (frame </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> BITS_PER_DWORD));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> frame_test</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> frame</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> frame_alloc.bitmap[frame </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> BITS_PER_DWORD] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> (frame </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> BITS_PER_DWORD));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"page-directorytable-entry-4-bytes-each\">Page Directory/Table Entry (4 bytes each)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// kernel/memory/paging.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#79B8FF\"> pte_t</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">       // Page Table Entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#79B8FF\"> pde_t</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">       // Page Directory Entry</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Page entry flags (bits in pte_t/pde_t)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_PRESENT</span><span style=\"color:#E1E4E8\">       (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">    // Page is present in memory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_WRITABLE</span><span style=\"color:#E1E4E8\">      (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">    // Read/Write (1 = writable)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_USER</span><span style=\"color:#E1E4E8\">          (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">    // User/supervisor (1 = user accessible)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_WRITETHROUGH</span><span style=\"color:#E1E4E8\">  (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">    // Write-through caching</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_CACHE_DISABLE</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">    // Disable cache for this page</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_ACCESSED</span><span style=\"color:#E1E4E8\">      (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">    // Page has been accessed (read)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_DIRTY</span><span style=\"color:#E1E4E8\">         (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">    // Page has been written to (PT only)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_PAGE_SIZE</span><span style=\"color:#E1E4E8\">     (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 7</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">    // 4MB page (PD only)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_GLOBAL</span><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">U</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">    // Global page (not flushed on CR3 reload)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_FRAME_MASK</span><span style=\"color:#F97583\">    0x</span><span style=\"color:#79B8FF\">FFFFF000</span><span style=\"color:#6A737D\">   // Frame address mask (bits 31:12)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Extract fields from entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_FRAME</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pte</span><span style=\"color:#E1E4E8\">)          ((pte) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_FRAME_MASK)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_FLAGS</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pte</span><span style=\"color:#E1E4E8\">)          ((pte) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#E1E4E8\">PTE_FRAME_MASK)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Common flag combinations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_KERNEL_CODE</span><span style=\"color:#E1E4E8\">         (PTE_PRESENT </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PTE_WRITABLE)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_KERNEL_DATA</span><span style=\"color:#E1E4E8\">         (PTE_PRESENT </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PTE_WRITABLE)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_USER_CODE</span><span style=\"color:#E1E4E8\">           (PTE_PRESENT </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PTE_WRITABLE </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PTE_USER)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_USER_DATA</span><span style=\"color:#E1E4E8\">           (PTE_PRESENT </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PTE_WRITABLE </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PTE_USER)</span></span></code></pre></div>\n\n<p><strong>Page Table Entry bit layout:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Bits</th>\n<th>Field</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>Present</td>\n<td>1 = page in memory</td>\n</tr>\n<tr>\n<td>1</td>\n<td>R/W</td>\n<td>1 = writable</td>\n</tr>\n<tr>\n<td>2</td>\n<td>U/S</td>\n<td>1 = user-mode accessible</td>\n</tr>\n<tr>\n<td>3</td>\n<td>PWT</td>\n<td>Write-through caching</td>\n</tr>\n<tr>\n<td>4</td>\n<td>PCD</td>\n<td>Cache disable</td>\n</tr>\n<tr>\n<td>5</td>\n<td>A</td>\n<td>Accessed (CPU sets on read)</td>\n</tr>\n<tr>\n<td>6</td>\n<td>D</td>\n<td>Dirty (CPU sets on write, PT only)</td>\n</tr>\n<tr>\n<td>7</td>\n<td>PS</td>\n<td>Page size (0 = 4KB)</td>\n</tr>\n<tr>\n<td>8</td>\n<td>G</td>\n<td>Global (ignore on CR3 reload)</td>\n</tr>\n<tr>\n<td>9-11</td>\n<td>Available</td>\n<td>OS-defined</td>\n</tr>\n<tr>\n<td>12-31</td>\n<td>Frame Address</td>\n<td>Physical frame address (4KB aligned)</td>\n</tr>\n</tbody></table>\n<h3 id=\"page-directory-and-page-table-structures\">Page Directory and Page Table Structures</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ENTRIES_PER_TABLE</span><span style=\"color:#79B8FF\">    1024</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_SIZE</span><span style=\"color:#79B8FF\">            4096</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pte_t</span><span style=\"color:#FFAB70\"> entries</span><span style=\"color:#E1E4E8\">[ENTRIES_PER_TABLE];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#B392F0\">aligned</span><span style=\"color:#E1E4E8\">(PAGE_SIZE))) </span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pde_t</span><span style=\"color:#FFAB70\"> entries</span><span style=\"color:#E1E4E8\">[ENTRIES_PER_TABLE];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#B392F0\">aligned</span><span style=\"color:#E1E4E8\">(PAGE_SIZE))) </span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Extract indices from virtual address</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PD_INDEX</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">vaddr</span><span style=\"color:#E1E4E8\">)      (((vaddr) </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 22</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">3FF</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PT_INDEX</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">vaddr</span><span style=\"color:#E1E4E8\">)      (((vaddr) </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">3FF</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_OFFSET</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">vaddr</span><span style=\"color:#E1E4E8\">)   ((vaddr) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFF</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Current page directory (physical address in CR3)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#79B8FF\"> page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">current_page_directory;</span></span></code></pre></div>\n\n<h3 id=\"heap-block-header\">Heap Block Header</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// kernel/memory/heap.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> HEAP_MAGIC</span><span style=\"color:#F97583\">           0x</span><span style=\"color:#79B8FF\">DEADBEEF</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> HEAP_MIN_BLOCK_SIZE</span><span style=\"color:#79B8FF\">  16</span><span style=\"color:#6A737D\">        // Minimum allocation size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> HEAP_START</span><span style=\"color:#F97583\">           0x</span><span style=\"color:#79B8FF\">C0400000</span><span style=\"color:#6A737D\">  // Virtual address for heap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> HEAP_INITIAL_SIZE</span><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  // 4MB initial</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> heap_block {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> magic;</span><span style=\"color:#6A737D\">                   // HEAP_MAGIC for integrity check</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> size;</span><span style=\"color:#6A737D\">                    // Size of data area (excluding header)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\">  free;</span><span style=\"color:#6A737D\">                    // 1 = free, 0 = allocated</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\">  padding</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">              // Align to 4 bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> heap_block </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">next;</span><span style=\"color:#6A737D\">          // Next block in list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> heap_block </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">prev;</span><span style=\"color:#6A737D\">          // Previous block in list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed)) </span><span style=\"color:#79B8FF\">heap_block_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BLOCK_HEADER_SIZE</span><span style=\"color:#F97583\">    sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">heap_block_t</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BLOCK_DATA</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">block</span><span style=\"color:#E1E4E8\">)    ((</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)(block) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> BLOCK_HEADER_SIZE))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DATA_TO_BLOCK</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#E1E4E8\">)   ((</span><span style=\"color:#79B8FF\">heap_block_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)(ptr) </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> BLOCK_HEADER_SIZE))</span></span></code></pre></div>\n\n<h3 id=\"memory-layout-constants\">Memory Layout Constants</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// kernel/memory/memory.h</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Physical memory layout</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KERNEL_PHYSICAL_BASE</span><span style=\"color:#F97583\">   0x</span><span style=\"color:#79B8FF\">00100000</span><span style=\"color:#6A737D\">    // 1 MB - where kernel is loaded</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> LOW_MEMORY_END</span><span style=\"color:#F97583\">         0x</span><span style=\"color:#79B8FF\">00100000</span><span style=\"color:#6A737D\">    // 1 MB - end of low memory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> VGA_PHYSICAL</span><span style=\"color:#F97583\">           0x</span><span style=\"color:#79B8FF\">000B8000</span><span style=\"color:#6A737D\">    // VGA text buffer</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Virtual memory layout</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KERNEL_VIRTUAL_BASE</span><span style=\"color:#F97583\">    0x</span><span style=\"color:#79B8FF\">C0000000</span><span style=\"color:#6A737D\">    // 3 GB - higher-half kernel</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KERNEL_HEAP_START</span><span style=\"color:#F97583\">      0x</span><span style=\"color:#79B8FF\">C0400000</span><span style=\"color:#6A737D\">    // 3 GB + 4 MB - kernel heap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KERNEL_HEAP_END</span><span style=\"color:#F97583\">        0x</span><span style=\"color:#79B8FF\">C0800000</span><span style=\"color:#6A737D\">    // 3 GB + 8 MB - heap end (expandable)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> USER_SPACE_START</span><span style=\"color:#F97583\">       0x</span><span style=\"color:#79B8FF\">00000000</span><span style=\"color:#6A737D\">    // User space base</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> USER_SPACE_END</span><span style=\"color:#F97583\">         0x</span><span style=\"color:#79B8FF\">BFFFFFFF</span><span style=\"color:#6A737D\">    // User space end (3 GB - 1)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> USER_STACK_TOP</span><span style=\"color:#F97583\">         0x</span><span style=\"color:#79B8FF\">BFFFF000</span><span style=\"color:#6A737D\">    // User stack (grows down)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Identity mapping range</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> IDENTITY_MAP_END</span><span style=\"color:#E1E4E8\">       (</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  // Identity map first 16 MB</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"interface-contracts\">Interface Contracts</h2>\n<h3 id=\"e820_initmultiboot_info_t-mbi\">e820_init(multiboot_info_t *mbi)</h3>\n<p><strong>Purpose</strong>: Parse multiboot memory map and store usable regions</p>\n<p><strong>Parameters</strong>: </p>\n<ul>\n<li><code>mbi</code>: Pointer to multiboot info structure from bootloader</li>\n</ul>\n<p><strong>Returns</strong>: 0 on success, -1 on error</p>\n<p><strong>Side effects</strong>: </p>\n<ul>\n<li>Populates global <code>memory_regions</code> array</li>\n<li>Sets <code>num_memory_regions</code></li>\n</ul>\n<p><strong>Preconditions</strong>: Called early in kernel init before frame allocator</p>\n<p><strong>Postconditions</strong>: Memory map available for frame allocator initialization</p>\n<h3 id=\"frame_allocator_initvoid\">frame_allocator_init(void)</h3>\n<p><strong>Purpose</strong>: Initialize bitmap frame allocator from parsed memory map</p>\n<p><strong>Parameters</strong>: None</p>\n<p><strong>Returns</strong>: 0 on success, -1 on error</p>\n<p><strong>Side effects</strong>:</p>\n<ul>\n<li>Allocates bitmap (using placement allocator during boot)</li>\n<li>Marks kernel frames as used</li>\n<li>Marks reserved/acpi regions as used</li>\n</ul>\n<p><strong>Preconditions</strong>: e820_init() must have been called</p>\n<p><strong>Postconditions</strong>: Frame allocator ready to allocate free frames</p>\n<h3 id=\"alloc_framevoid\">alloc_frame(void)</h3>\n<p><strong>Purpose</strong>: Allocate a single 4KB physical frame</p>\n<p><strong>Parameters</strong>: None</p>\n<p><strong>Returns</strong>: </p>\n<ul>\n<li>Physical address of allocated frame on success</li>\n<li>NULL (0) if out of memory</li>\n</ul>\n<p><strong>Side effects</strong>:</p>\n<ul>\n<li>Marks frame as allocated in bitmap</li>\n<li>Decrements <code>free_frames</code> counter</li>\n</ul>\n<p><strong>Thread safety</strong>: NOT thread-safe. Caller must disable interrupts if needed.</p>\n<h3 id=\"free_framevoid-addr\">free_frame(void *addr)</h3>\n<p><strong>Purpose</strong>: Free a previously allocated physical frame</p>\n<p><strong>Parameters</strong>:</p>\n<ul>\n<li><code>addr</code>: Physical address of frame to free</li>\n</ul>\n<p><strong>Returns</strong>: None</p>\n<p><strong>Side effects</strong>:</p>\n<ul>\n<li>Clears frame bit in bitmap</li>\n<li>Increments <code>free_frames</code> counter</li>\n</ul>\n<p><strong>Error handling</strong>:</p>\n<ul>\n<li>Panics on double-free (frame already free)</li>\n<li>Panics if address not frame-aligned</li>\n<li>Panics if frame outside valid range</li>\n</ul>\n<h3 id=\"paging_initvoid\">paging_init(void)</h3>\n<p><strong>Purpose</strong>: Set up initial page tables and enable paging</p>\n<p><strong>Parameters</strong>: None</p>\n<p><strong>Returns</strong>: None</p>\n<p><strong>Side effects</strong>:</p>\n<ul>\n<li>Creates initial page directory</li>\n<li>Identity maps first 16MB</li>\n<li>Maps kernel at 0xC0000000+ (higher-half)</li>\n<li>Loads CR3 and sets CR0.PG</li>\n</ul>\n<p><strong>Preconditions</strong>: Frame allocator initialized</p>\n<p><strong>Postconditions</strong>: Paging enabled, kernel running in higher-half</p>\n<h3 id=\"map_pagepage_directory_t-dir-uint32_t-vaddr-uint32_t-paddr-uint32_t-flags\">map_page(page_directory_t *dir, uint32_t vaddr, uint32_t paddr, uint32_t flags)</h3>\n<p><strong>Purpose</strong>: Map a virtual page to a physical frame</p>\n<p><strong>Parameters</strong>:</p>\n<ul>\n<li><code>dir</code>: Page directory to modify</li>\n<li><code>vaddr</code>: Virtual address (will be page-aligned)</li>\n<li><code>paddr</code>: Physical address (will be page-aligned)</li>\n<li><code>flags</code>: PTE flags (PTE_PRESENT | PTE_WRITABLE | ...)</li>\n</ul>\n<p><strong>Returns</strong>: 0 on success, -1 on failure (out of memory for page table)</p>\n<p><strong>Side effects</strong>:</p>\n<ul>\n<li>May allocate new page table</li>\n<li>Invalidates TLB entry for vaddr</li>\n</ul>\n<p><strong>Preconditions</strong>: Paging enabled (or dir is valid)</p>\n<h3 id=\"unmap_pagepage_directory_t-dir-uint32_t-vaddr\">unmap_page(page_directory_t *dir, uint32_t vaddr)</h3>\n<p><strong>Purpose</strong>: Remove a virtual-to-physical mapping</p>\n<p><strong>Parameters</strong>:</p>\n<ul>\n<li><code>dir</code>: Page directory to modify</li>\n<li><code>vaddr</code>: Virtual address to unmap</li>\n</ul>\n<p><strong>Returns</strong>: None</p>\n<p><strong>Side effects</strong>: Invalidates TLB entry for vaddr</p>\n<h3 id=\"get_physicalpage_directory_t-dir-uint32_t-vaddr\">get_physical(page_directory_t *dir, uint32_t vaddr)</h3>\n<p><strong>Purpose</strong>: Translate virtual address to physical address</p>\n<p><strong>Parameters</strong>:</p>\n<ul>\n<li><code>dir</code>: Page directory to query</li>\n<li><code>vaddr</code>: Virtual address to translate</li>\n</ul>\n<p><strong>Returns</strong>:</p>\n<ul>\n<li>Physical address on success</li>\n<li>0 if not mapped</li>\n</ul>\n<h3 id=\"kmallocuint32_t-size\">kmalloc(uint32_t size)</h3>\n<p><strong>Purpose</strong>: Allocate kernel heap memory</p>\n<p><strong>Parameters</strong>:</p>\n<ul>\n<li><code>size</code>: Number of bytes to allocate</li>\n</ul>\n<p><strong>Returns</strong>:</p>\n<ul>\n<li>Pointer to allocated memory (in kernel virtual space)</li>\n<li>NULL if out of memory</li>\n</ul>\n<p><strong>Side effects</strong>: May expand heap by mapping new pages</p>\n<p><strong>Alignment</strong>: Returns 4-byte aligned pointers</p>\n<p><strong>Minimum allocation</strong>: HEAP_MIN_BLOCK_SIZE bytes</p>\n<h3 id=\"kfreevoid-ptr\">kfree(void *ptr)</h3>\n<p><strong>Purpose</strong>: Free previously allocated heap memory</p>\n<p><strong>Parameters</strong>:</p>\n<ul>\n<li><code>ptr</code>: Pointer returned by kmalloc (or NULL)</li>\n</ul>\n<p><strong>Returns</strong>: None</p>\n<p><strong>Side effects</strong>:</p>\n<ul>\n<li>Coalesces with adjacent free blocks</li>\n<li>May reduce heap (optional optimization)</li>\n</ul>\n<p><strong>Error handling</strong>:</p>\n<ul>\n<li>Panics on invalid pointer (magic mismatch)</li>\n<li>Panics on double-free</li>\n<li>Silently ignores NULL</li>\n</ul>\n<hr>\n<h2 id=\"algorithm-specification\">Algorithm Specification</h2>\n<h3 id=\"memory-map-parsing\">Memory Map Parsing</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>E820_INIT(mbi):\n  1. Verify multiboot flags indicate memory map present\n     IF !(mbi-&gt;flags &amp; (1 &lt;&lt; 6)):\n       RETURN error  // No memory map!\n  \n  2. Initialize region counter\n     num_regions = 0\n  \n  3. Iterate through memory map entries\n     entry = mbi-&gt;mmap_addr\n     WHILE entry &lt; mbi-&gt;mmap_addr + mbi-&gt;mmap_length:\n       // Skip entries above 4GB (we're 32-bit)\n       IF entry-&gt;base + entry-&gt;length &gt; 0xFFFFFFFF:\n         entry = next_entry\n         CONTINUE\n       \n       // Store region info\n       regions[num_regions].base = entry-&gt;base\n       regions[num_regions].length = entry-&gt;length\n       regions[num_regions].type = entry-&gt;type\n       \n       num_regions++\n       IF num_regions &gt;= MAX_MEMORY_REGIONS:\n         BREAK  // Too many regions\n       \n       entry = next_entry (entry + entry-&gt;size + 4)\n  \n  4. Calculate total usable memory\n     total_memory = 0\n     FOR each region:\n       IF region.type == E820_USABLE:\n         total_memory += region.length\n  \n  5. RETURN success</code></pre></div>\n\n<h3 id=\"frame-allocator-initialization\">Frame Allocator Initialization</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>FRAME_ALLOCATOR_INIT():\n  1. Calculate total frames from highest address\n     max_addr = 0\n     FOR each region:\n       IF region.base + region.length &gt; max_addr:\n         max_addr = region.base + region.length\n     \n     total_frames = max_addr / FRAME_SIZE\n  \n  2. Allocate bitmap using placement allocator\n     bitmap_dwords = (total_frames + 31) / 32\n     bitmap = placement_alloc(bitmap_dwords * 4)\n     \n     // Mark ALL frames as reserved initially\n     FOR i = 0 TO bitmap_dwords - 1:\n       bitmap[i] = 0xFFFFFFFF\n  \n  3. Find first usable frame\n     first_usable = total_frames  // Start with max\n     FOR each region:\n       IF region.type == E820_USABLE:\n         start_frame = ALIGN_UP(region.base, FRAME_SIZE) / FRAME_SIZE\n         IF start_frame &lt; first_usable:\n           first_usable = start_frame\n  \n  4. Mark usable frames as free\n     free_frames = 0\n     FOR each region:\n       IF region.type == E820_USABLE:\n         start_frame = ALIGN_UP(region.base, FRAME_SIZE) / FRAME_SIZE\n         end_frame = ALIGN_DOWN(region.base + region.length, FRAME_SIZE) / FRAME_SIZE\n         \n         FOR frame = start_frame TO end_frame - 1:\n           clear_frame(frame)\n           free_frames++\n  \n  5. Reserve kernel frames\n     kernel_start = ADDR_TO_FRAME(&amp;_kernel_start)\n     kernel_end = ADDR_TO_FRAME(&amp;_kernel_end) + 1  // +1 for partial frame\n     \n     FOR frame = kernel_start TO kernel_end - 1:\n       IF frame_test(frame) == 0:  // Was free\n         set_frame(frame)\n         free_frames--\n     \n     kernel_end_frame = kernel_end\n  \n  6. Reserve already-allocated placement memory\n     placement_start = first_usable  // Rough estimate\n     placement_end = ADDR_TO_FRAME(placement_addr)\n     \n     FOR frame = placement_start TO placement_end:\n       IF frame_test(frame) == 0:\n         set_frame(frame)\n         free_frames--\n  \n  7. RETURN success</code></pre></div>\n\n<h3 id=\"frame-allocation-bitmap-scan\">Frame Allocation (Bitmap Scan)</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALLOC_FRAME():\n  1. Check if any frames available\n     IF free_frames == 0:\n       RETURN NULL  // Out of memory\n  \n  2. Scan bitmap for free bit\n     FOR i = first_usable / 32 TO total_frames / 32:\n       IF bitmap[i] != 0xFFFFFFFF:  // At least one free bit\n         FOR j = 0 TO 31:\n           frame = i * 32 + j\n           IF frame &gt;= first_usable AND frame_test(frame) == 0:\n             // Found free frame\n             set_frame(frame)\n             free_frames--\n             RETURN FRAME_TO_ADDR(frame)\n  \n  3. No free frame found (shouldn't happen if free_frames &gt; 0)\n     RETURN NULL</code></pre></div>\n\n<h3 id=\"frame-freeing\">Frame Freeing</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>FREE_FRAME(addr):\n  1. Validate address\n     IF addr == NULL:\n       RETURN  // Ignore NULL\n     \n     IF addr % FRAME_SIZE != 0:\n       PANIC(&quot;free_frame: unaligned address 0x%x\\n&quot;, addr)\n  \n  2. Calculate frame number\n     frame = ADDR_TO_FRAME(addr)\n     \n     IF frame &gt;= total_frames:\n       PANIC(&quot;free_frame: frame %d out of range\\n&quot;, frame)\n  \n  3. Check for double-free\n     IF frame_test(frame) == 0:\n       PANIC(&quot;free_frame: double free at frame %d (addr 0x%x)\\n&quot;, frame, addr)\n  \n  4. Mark as free\n     clear_frame(frame)\n     free_frames++</code></pre></div>\n\n<h3 id=\"page-mapping\">Page Mapping</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>MAP_PAGE(dir, vaddr, paddr, flags):\n  1. Align addresses to page boundaries\n     vaddr = vaddr &amp; ~0xFFF\n     paddr = paddr &amp; ~0xFFF\n  \n  2. Get page directory index\n     pd_idx = PD_INDEX(vaddr)\n     pde = &amp;dir-&gt;entries[pd_idx]\n  \n  3. Get or create page table\n     IF *pde &amp; PTE_PRESENT:\n       // Page table exists\n       pt = (page_table_t*)PTE_FRAME(*pde)\n     ELSE:\n       // Need to create page table\n       pt_phys = alloc_frame()\n       IF pt_phys == NULL:\n         RETURN -1  // Out of memory\n       \n       pt = (page_table_t*)pt_phys  // Identity-mapped during init\n       \n       // Clear page table\n       FOR i = 0 TO 1023:\n         pt-&gt;entries[i] = 0\n       \n       // Set page directory entry\n       *pde = (uint32_t)pt_phys | PTE_PRESENT | PTE_WRITABLE | PTE_USER\n  \n  4. Set page table entry\n     pt_idx = PT_INDEX(vaddr)\n     pt-&gt;entries[pt_idx] = paddr | flags | PTE_PRESENT\n  \n  5. Invalidate TLB entry\n     asm volatile(&quot;invlpg (%0)&quot; : : &quot;r&quot;(vaddr) : &quot;memory&quot;)\n  \n  6. RETURN 0</code></pre></div>\n\n<h3 id=\"page-unmapping\">Page Unmapping</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>UNMAP_PAGE(dir, vaddr):\n  1. Get page directory entry\n     pd_idx = PD_INDEX(vaddr)\n     pde = &amp;dir-&gt;entries[pd_idx]\n     \n     IF !(*pde &amp; PTE_PRESENT):\n       RETURN  // Nothing mapped\n  \n  2. Get page table\n     pt = (page_table_t*)PTE_FRAME(*pde)\n  \n  3. Clear page table entry\n     pt_idx = PT_INDEX(vaddr)\n     pt-&gt;entries[pt_idx] = 0\n  \n  4. Invalidate TLB entry\n     asm volatile(&quot;invlpg (%0)&quot; : : &quot;r&quot;(vaddr) : &quot;memory&quot;)</code></pre></div>\n\n<h3 id=\"identity-and-higher-half-mapping\">Identity and Higher-Half Mapping</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>PAGING_INIT():\n  1. Allocate page directory\n     pd_phys = alloc_frame()\n     pd = (page_directory_t*)pd_phys\n     \n     // Clear all entries (not present)\n     FOR i = 0 TO 1023:\n       pd-&gt;entries[i] = 0\n  \n  2. Identity map first 16 MB\n     FOR addr = 0 TO 16*1024*1024 STEP PAGE_SIZE:\n       map_page(pd, addr, addr, PTE_PRESENT | PTE_WRITABLE)\n       // Note: supervisor-only (no PTE_USER)\n  \n  3. Higher-half kernel mapping (0xC0000000+)\n     FOR offset = 0 TO 16*1024*1024 STEP PAGE_SIZE:\n       vaddr = KERNEL_VIRTUAL_BASE + offset\n       paddr = offset\n       map_page(pd, vaddr, paddr, PTE_PRESENT | PTE_WRITABLE)\n  \n  4. Load CR3\n     asm volatile(&quot;mov %0, %%cr3&quot; : : &quot;r&quot;(pd_phys))\n  \n  5. Enable paging\n     asm volatile(&quot;mov %%cr0, %0&quot; : &quot;=r&quot;(cr0))\n     cr0 |= (1 &lt;&lt; 31)  // Set PG bit\n     asm volatile(&quot;mov %0, %%cr0&quot; : : &quot;r&quot;(cr0))\n  \n  6. Update global pointer\n     current_page_directory = (page_directory_t*)(KERNEL_VIRTUAL_BASE + (uint32_t)pd_phys)\n     // Now we need to access via higher-half address!</code></pre></div>\n\n<h3 id=\"page-fault-handler\">Page Fault Handler</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>PAGE_FAULT_HANDLER(regs):\n  1. Read faulting address from CR2\n     asm volatile(&quot;mov %%cr2, %0&quot; : &quot;=r&quot;(fault_addr))\n  \n  2. Decode error code\n     present = !(regs-&gt;err_code &amp; 0x1)   // Bit 0: 0=not present\n     write = regs-&gt;err_code &amp; 0x2        // Bit 1: write access\n     user = regs-&gt;err_code &amp; 0x4         // Bit 2: user mode\n     reserved = regs-&gt;err_code &amp; 0x8     // Bit 3: reserved bit\n     exec = regs-&gt;err_code &amp; 0x10        // Bit 4: instruction fetch\n  \n  3. Print diagnostic\n     kprintf(&quot;=== PAGE FAULT ===\\n&quot;)\n     kprintf(&quot;Address: 0x%x\\n&quot;, fault_addr)\n     kprintf(&quot;Error: %s %s %s %s\\n&quot;,\n             present ? &quot;protection&quot; : &quot;not-present&quot;,\n             write ? &quot;write&quot; : &quot;read&quot;,\n             user ? &quot;user&quot; : &quot;kernel&quot;,\n             exec ? &quot;exec&quot; : &quot;&quot;)\n     kprintf(&quot;EIP: 0x%x\\n&quot;, regs-&gt;eip)\n  \n  4. Check if address is in valid ranges\n     IF fault_addr &gt;= KERNEL_VIRTUAL_BASE:\n       kprintf(&quot;In kernel space\\n&quot;)\n     ELSE IF fault_addr &lt; IDENTITY_MAP_END:\n       kprintf(&quot;In identity-mapped region\\n&quot;)\n     ELSE:\n       kprintf(&quot;Outside mapped regions\\n&quot;)\n  \n  5. Halt (no demand paging in this version)\n     PANIC(&quot;Page fault - system halted\\n&quot;)</code></pre></div>\n\n<h3 id=\"kernel-heap-allocation\">Kernel Heap Allocation</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>KMALLOC(size):\n  1. Handle edge cases\n     IF size == 0:\n       RETURN NULL\n  \n  2. Align size to 4 bytes\n     size = (size + 3) &amp; ~3\n     \n     IF size &lt; HEAP_MIN_BLOCK_SIZE:\n       size = HEAP_MIN_BLOCK_SIZE\n  \n  3. Find free block (first-fit)\n     block = heap_head\n     WHILE block != NULL:\n       IF block-&gt;magic != HEAP_MAGIC:\n         PANIC(&quot;kmalloc: heap corruption at 0x%x\\n&quot;, block)\n       \n       IF block-&gt;free AND block-&gt;size &gt;= size:\n         // Found suitable block\n         GOTO found_block\n       \n       block = block-&gt;next\n  \n  4. No suitable block - expand heap\n     IF !heap_expand(size + BLOCK_HEADER_SIZE):\n       RETURN NULL  // Out of memory\n     \n     // Try again (should succeed now)\n     RETURN kmalloc(size)\n  \n  found_block:\n  5. Split block if large enough\n     remaining = block-&gt;size - size\n     IF remaining &gt; BLOCK_HEADER_SIZE + HEAP_MIN_BLOCK_SIZE:\n       // Create new free block after this one\n       new_block = (heap_block_t*)((uint8_t*)block + BLOCK_HEADER_SIZE + size)\n       new_block-&gt;magic = HEAP_MAGIC\n       new_block-&gt;size = remaining - BLOCK_HEADER_SIZE\n       new_block-&gt;free = 1\n       new_block-&gt;next = block-&gt;next\n       new_block-&gt;prev = block\n       \n       IF block-&gt;next:\n         block-&gt;next-&gt;prev = new_block\n       \n       block-&gt;next = new_block\n       block-&gt;size = size\n  \n  6. Mark block as allocated\n     block-&gt;free = 0\n     \n     RETURN BLOCK_DATA(block)</code></pre></div>\n\n<h3 id=\"kernel-heap-freeing\">Kernel Heap Freeing</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>KFREE(ptr):\n  1. Handle NULL\n     IF ptr == NULL:\n       RETURN\n  \n  2. Get block header\n     block = DATA_TO_BLOCK(ptr)\n  \n  3. Validate magic\n     IF block-&gt;magic != HEAP_MAGIC:\n       PANIC(&quot;kfree: invalid pointer 0x%x (magic=0x%x)\\n&quot;, ptr, block-&gt;magic)\n  \n  4. Check for double-free\n     IF block-&gt;free:\n       PANIC(&quot;kfree: double free at 0x%x\\n&quot;, ptr)\n  \n  5. Mark as free\n     block-&gt;free = 1\n  \n  6. Coalesce with next block\n     IF block-&gt;next AND block-&gt;next-&gt;free AND block-&gt;next-&gt;magic == HEAP_MAGIC:\n       block-&gt;size += BLOCK_HEADER_SIZE + block-&gt;next-&gt;size\n       block-&gt;next = block-&gt;next-&gt;next\n       IF block-&gt;next:\n         block-&gt;next-&gt;prev = block\n  \n  7. Coalesce with previous block\n     IF block-&gt;prev AND block-&gt;prev-&gt;free AND block-&gt;prev-&gt;magic == HEAP_MAGIC:\n       block-&gt;prev-&gt;size += BLOCK_HEADER_SIZE + block-&gt;size\n       block-&gt;prev-&gt;next = block-&gt;next\n       IF block-&gt;next:\n         block-&gt;next-&gt;prev = block-&gt;prev</code></pre></div>\n\n<hr>\n<h2 id=\"error-handling-matrix\">Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th>Error</th>\n<th>Detected By</th>\n<th>Recovery</th>\n<th>User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>No memory map from bootloader</td>\n<td><code>e820_init</code> checks flags</td>\n<td>Panic with message</td>\n<td>Yes, &quot;No memory map&quot;</td>\n</tr>\n<tr>\n<td>Out of physical frames</td>\n<td><code>alloc_frame</code> returns NULL</td>\n<td>kmalloc returns NULL, caller handles</td>\n<td>Depends on caller</td>\n</tr>\n<tr>\n<td>Double-free in frame allocator</td>\n<td><code>free_frame</code> tests bit</td>\n<td>Panic with address</td>\n<td>Yes, panic message</td>\n</tr>\n<tr>\n<td>Invalid frame address</td>\n<td><code>free_frame</code> checks alignment/range</td>\n<td>Panic</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Page table allocation failure</td>\n<td><code>map_page</code> checks alloc_frame result</td>\n<td>Return -1, caller handles</td>\n<td>Depends on caller</td>\n</tr>\n<tr>\n<td>Page fault (kernel)</td>\n<td>Exception 14 handler</td>\n<td>Print diagnostics, halt</td>\n<td>Yes, fault message</td>\n</tr>\n<tr>\n<td>Page fault during paging init</td>\n<td>Triple fault</td>\n<td>System reset</td>\n<td>Yes (reset)</td>\n</tr>\n<tr>\n<td>TLB stale entry</td>\n<td>Various</td>\n<td>Always call invlpg</td>\n<td>No (prevention)</td>\n</tr>\n<tr>\n<td>Heap corruption (bad magic)</td>\n<td><code>kmalloc</code>/<code>kfree</code> check magic</td>\n<td>Panic</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Heap double-free</td>\n<td><code>kfree</code> checks free flag</td>\n<td>Panic</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Heap expansion failure</td>\n<td><code>heap_expand</code> returns 0</td>\n<td>kmalloc returns NULL</td>\n<td>Depends on caller</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"implementation-sequence-with-checkpoints\">Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-memory-map-parser-3-4-hours\">Phase 1: Memory Map Parser (3-4 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/memory/e820.h</code>, <code>kernel/memory/e820.c</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Define e820_entry_t and memory_region_t structures</li>\n<li>Implement <code>e820_init()</code> to parse multiboot mmap</li>\n<li>Add <code>e820_print()</code> for debugging</li>\n<li>Store parsed regions in global array</li>\n</ol>\n<p><strong>Checkpoint</strong>: Memory map parsed and displayed</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In kernel_main after basic init:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">e820_init</span><span style=\"color:#E1E4E8\">(mbi);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">e820_print</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Expected: List of memory regions with types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// \"Memory: 0x000000 - 0x09FFFF (usable)\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// \"Memory: 0x100000 - 0x3FFFFFF (usable)\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// etc.</span></span></code></pre></div>\n\n<p><strong>Test</strong>: Verify region count and total memory match QEMU configuration</p>\n<h3 id=\"phase-2-bitmap-frame-allocator-4-5-hours\">Phase 2: Bitmap Frame Allocator (4-5 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/memory/frame.h</code>, <code>kernel/memory/frame.c</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Implement placement allocator for boot-time allocations</li>\n<li>Calculate total frames from memory map</li>\n<li>Allocate bitmap using placement allocator</li>\n<li>Mark usable regions as free</li>\n<li>Reserve kernel frames</li>\n<li>Implement <code>alloc_frame()</code> with bitmap scan</li>\n<li>Implement <code>free_frame()</code> with double-free check</li>\n</ol>\n<p><strong>Checkpoint</strong>: Frame allocator works</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">frame1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">frame2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Allocated frames: 0x</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\">, 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, frame1, frame2);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">free_frame</span><span style=\"color:#E1E4E8\">(frame1);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">frame3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"After free+alloc: 0x</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\"> (should reuse 0x</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, frame3, frame1);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Expected: frame3 == frame1 (first-fit reuses freed frame)</span></span></code></pre></div>\n\n<p><strong>Test</strong>: Allocate all frames, verify NULL return; free and reallocate</p>\n<h3 id=\"phase-3-page-table-structures-3-4-hours\">Phase 3: Page Table Structures (3-4 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/memory/paging.h</code>, <code>kernel/memory/paging.c</code> (partial)</p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Define pte_t, pde_t and flag constants</li>\n<li>Define page_table_t, page_directory_t structures</li>\n<li>Implement PD_INDEX, PT_INDEX macros</li>\n<li>Implement <code>get_physical()</code> for address translation</li>\n</ol>\n<p><strong>Checkpoint</strong>: Structures compile, indices calculate correctly</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PD_INDEX(0xC0000000) = </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (expected 768)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">PD_INDEX</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">C0000000</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PT_INDEX(0xC0001000) = </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (expected 1)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">PT_INDEX</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">C0001000</span><span style=\"color:#E1E4E8\">));</span></span></code></pre></div>\n\n<h3 id=\"phase-4-map_pageunmap_page-4-5-hours\">Phase 4: map_page/unmap_page (4-5 hours)</h3>\n<p><strong>Files</strong>: Continue <code>kernel/memory/paging.c</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Implement <code>map_page()</code> with page table allocation</li>\n<li>Implement <code>unmap_page()</code></li>\n<li>Add invlpg inline assembly</li>\n<li>Test with identity-mapped addresses initially</li>\n</ol>\n<p><strong>Checkpoint</strong>: Manual mapping works</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">test_pd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">memset</span><span style=\"color:#E1E4E8\">(test_pd, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, PAGE_SIZE);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">map_page</span><span style=\"color:#E1E4E8\">(test_pd, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">400000</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">frame</span><span style=\"color:#E1E4E8\">, PTE_PRESENT </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PTE_WRITABLE);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> phys </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_physical</span><span style=\"color:#E1E4E8\">(test_pd, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">400000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Mapped 0x400000 -> 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, phys);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Expected: phys == frame address</span></span></code></pre></div>\n\n<h3 id=\"phase-5-identity-mapping-2-3-hours\">Phase 5: Identity Mapping (2-3 hours)</h3>\n<p><strong>Files</strong>: Continue <code>kernel/memory/paging.c</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Create initial page directory</li>\n<li>Identity map first 16MB (0x00000000 - 0x00FFFFFF)</li>\n<li>Verify VGA (0xB8000) still accessible</li>\n</ol>\n<p><strong>Checkpoint</strong>: Identity mapping works</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Create PD and identity map</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">paging_init_identity_only</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// VGA should still work</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Identity mapping works!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<h3 id=\"phase-6-higher-half-kernel-mapping-3-4-hours\">Phase 6: Higher-Half Kernel Mapping (3-4 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/memory/paging.c</code>, update <code>kernel/linker.ld</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Update linker script with higher-half addresses</li>\n<li>Add higher-half mapping (0xC0000000+ -&gt; 0x00000000+)</li>\n<li>Handle the transition carefully (code runs at physical until paging enabled)</li>\n<li>Test kernel functions via higher-half addresses</li>\n</ol>\n<p><strong>Checkpoint</strong>: Kernel runs in higher half</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// After paging_init():</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Kernel running at 0x</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\"> (virtual)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">kernel_main</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Physical address: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">get_physical</span><span style=\"color:#E1E4E8\">(current_page_directory, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">kernel_main</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Expected: Virtual ~0xC0100000, Physical ~0x00100000</span></span></code></pre></div>\n\n<p><strong>Critical</strong>: Update linker script:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">ld</span><pre class=\"arch-pre shiki-highlighted\"><code>ENTRY(kernel_entry)\n\nSECTIONS\n{\n    . = 0xC0100000;  /* Higher-half + 1MB offset */\n    \n    .text ALIGN(4K) : AT(ADDR(.text) - 0xC0000000)\n    {\n        *(.multiboot)\n        *(.text)\n    }\n    \n    .rodata ALIGN(4K) : AT(ADDR(.rodata) - 0xC0000000)\n    {\n        *(.rodata)\n    }\n    \n    .data ALIGN(4K) : AT(ADDR(.data) - 0xC0000000)\n    {\n        *(.data)\n    }\n    \n    .bss ALIGN(4K) : AT(ADDR(.bss) - 0xC0000000)\n    {\n        __bss_start = .;\n        *(COMMON)\n        *(.bss)\n        __bss_end = .;\n    }\n    \n    _kernel_end = .;\n}</code></pre></div>\n\n<h3 id=\"phase-7-paging-enablement-sequence-2-3-hours\">Phase 7: Paging Enablement Sequence (2-3 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/memory/paging.c</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Ensure identity mapping exists before enabling</li>\n<li>Load CR3 with page directory physical address</li>\n<li>Set CR0.PG bit</li>\n<li>Handle the instruction fetch after paging enabled</li>\n<li>Reload segment registers if needed</li>\n</ol>\n<p><strong>Checkpoint</strong>: Paging enables without triple fault</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run in QEMU with interrupt logging</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> -d</span><span style=\"color:#9ECBFF\"> int,cpu_reset</span><span style=\"color:#79B8FF\"> -serial</span><span style=\"color:#9ECBFF\"> stdio</span><span style=\"color:#F97583\"> 2>&#x26;1</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> head</span><span style=\"color:#79B8FF\"> -100</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: No triple fault or reset after \"Enabling paging\" message</span></span></code></pre></div>\n\n<h3 id=\"phase-8-page-fault-handler-2-3-hours\">Phase 8: Page Fault Handler (2-3 hours)</h3>\n<p><strong>Files</strong>: Update <code>kernel/interrupt_handler.c</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Add case for vector 14 in <code>isr_handler()</code></li>\n<li>Read CR2 for faulting address</li>\n<li>Decode error code bits</li>\n<li>Print comprehensive diagnostic</li>\n<li>Halt (no recovery in this version)</li>\n</ol>\n<p><strong>Checkpoint</strong>: Page faults are diagnosed</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Trigger a page fault:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">bad </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">DEADBEEF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">bad </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">12345678</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Expected: Page fault message with address 0xDEADBEEF</span></span></code></pre></div>\n\n<h3 id=\"phase-9-kernel-heap-5-7-hours\">Phase 9: Kernel Heap (5-7 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/memory/heap.h</code>, <code>kernel/memory/heap.c</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Define heap_block_t structure</li>\n<li>Implement <code>heap_init()</code> to create initial heap region</li>\n<li>Map heap pages using frame allocator</li>\n<li>Implement <code>kmalloc()</code> with first-fit and block splitting</li>\n<li>Implement <code>kfree()</code> with coalescing</li>\n<li>Implement <code>heap_expand()</code> for growth</li>\n</ol>\n<p><strong>Checkpoint</strong>: Heap allocation works</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">heap_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">50</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Allocated: 0x</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\">, 0x</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\">, 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, p1, p2, p3);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kfree</span><span style=\"color:#E1E4E8\">(p2);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p4 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">150</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Should fit in p2's space</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"After free+alloc: 0x</span><span style=\"color:#79B8FF\">%x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, p4);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Expected: p4 is near p2 (reused space)</span></span></code></pre></div>\n\n<p><strong>Test</strong>: Stress test with many allocations/frees, verify no corruption</p>\n<h3 id=\"final-integration-2-3-hours\">Final Integration (2-3 hours)</h3>\n<p><strong>Goal</strong>: Complete memory management system</p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Create <code>kernel/memory/memory.c</code> with <code>memory_init(mbi)</code></li>\n<li>Call all init functions in correct order:<ul>\n<li>e820_init</li>\n<li>frame_allocator_init</li>\n<li>paging_init</li>\n<li>heap_init</li>\n</ul>\n</li>\n<li>Update kernel_main to use memory_init</li>\n<li>Add memory status command for debugging</li>\n</ol>\n<p><strong>Checkpoint</strong>: All tests pass</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> kernel_main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">multiboot_info_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">mbi</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    serial_init</span><span style=\"color:#E1E4E8\">(COM1_PORT);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Initializing memory...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memory_init</span><span style=\"color:#E1E4E8\">(mbi);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Memory status:</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Total frames: \"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#B392F0\">vga_put_dec</span><span style=\"color:#E1E4E8\">(frame_alloc.total_frames);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">  Free frames: \"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#B392F0\">vga_put_dec</span><span style=\"color:#E1E4E8\">(frame_alloc.free_frames);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">  Kernel heap: 0x\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#B392F0\">vga_put_hex</span><span style=\"color:#E1E4E8\">(HEAP_START);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test allocations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"kmalloc(1024) = 0x\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#B392F0\">vga_put_hex</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)p);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kfree</span><span style=\"color:#E1E4E8\">(p);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"kfree done</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Memory system ready!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Test Commands</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">make</span><span style=\"color:#9ECBFF\"> clean</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#B392F0\">make</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> -serial</span><span style=\"color:#9ECBFF\"> stdio</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Memory map displayed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Frame allocator initialized</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Paging enabled (no crash)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Heap allocations work</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - \"Memory system ready!\" appears</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"test-specification\">Test Specification</h2>\n<h3 id=\"test-1-memory-map-parsing\">Test 1: Memory Map Parsing</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># test_memory_map.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> subprocess</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_memory_map</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> subprocess.Popen(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        [</span><span style=\"color:#9ECBFF\">'qemu-system-i386'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'-drive'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'format=raw,file=os.img'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">         '-serial'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'stdio'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'-display'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'none'</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        stdout</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">subprocess.</span><span style=\"color:#79B8FF\">PIPE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    time.sleep(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc.terminate()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    output, _ </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc.communicate(</span><span style=\"color:#FFAB70\">timeout</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    text </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> output.decode()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Check for memory region messages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#9ECBFF\"> 'Memory:'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> text </span><span style=\"color:#F97583\">or</span><span style=\"color:#9ECBFF\"> 'memory'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> text.lower(), </span><span style=\"color:#9ECBFF\">\"No memory map output\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Should have at least one usable region</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    usable_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> text.lower().count(</span><span style=\"color:#9ECBFF\">'usable'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#E1E4E8\"> usable_count </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"No usable memory regions found\"</span></span></code></pre></div>\n\n<h3 id=\"test-2-frame-allocation\">Test 2: Frame Allocation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// kernel/test_frame.c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_frame_allocation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Testing frame allocation...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate frames</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">f1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">f2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">f3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Allocated: \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_put_hex</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)f1); </span><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\", \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_put_hex</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)f2); </span><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\", \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_put_hex</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)f3); </span><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify different addresses</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(f1 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> f2 </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> f2 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> f3, </span><span style=\"color:#9ECBFF\">\"Frames should be different\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Free and reallocate</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free_frame</span><span style=\"color:#E1E4E8\">(f2);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">f4 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  After free+alloc: \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_put_hex</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)f4); </span><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // f4 should be f2 (reused)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(f4 </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> f2, </span><span style=\"color:#9ECBFF\">\"Frame should be reused\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PASS: Frame allocation</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-3-double-free-detection\">Test 3: Double-Free Detection</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// kernel/test_frame.c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_double_free</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Testing double-free detection...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free_frame</span><span style=\"color:#E1E4E8\">(frame);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This should panic</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Attempting double-free (should panic)...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free_frame</span><span style=\"color:#E1E4E8\">(frame);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should not reach here</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"FAIL: Double-free not detected!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-4-page-mapping\">Test 4: Page Mapping</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// kernel/test_paging.c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_page_mapping</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Testing page mapping...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create test page directory</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pd </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(pd, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, PAGE_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Map a page</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> vaddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">400000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> paddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">alloc_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> map_page</span><span style=\"color:#E1E4E8\">(pd, vaddr, paddr, PTE_PRESENT </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PTE_WRITABLE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(result </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"map_page failed\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify translation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> translated </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_physical</span><span style=\"color:#E1E4E8\">(pd, vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Mapped 0x\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#B392F0\">vga_put_hex</span><span style=\"color:#E1E4E8\">(vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\" -> 0x\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#B392F0\">vga_put_hex</span><span style=\"color:#E1E4E8\">(translated); </span><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(translated </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> paddr, </span><span style=\"color:#9ECBFF\">\"Translation mismatch\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test unmapping</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    unmap_page</span><span style=\"color:#E1E4E8\">(pd, vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    translated </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_physical</span><span style=\"color:#E1E4E8\">(pd, vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(translated </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Page still mapped after unmap\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PASS: Page mapping</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-5-paging-enablement\">Test 5: Paging Enablement</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># test_paging_enable.sh</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run QEMU and check for triple fault after paging enable</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">timeout</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#9ECBFF\"> qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    -d</span><span style=\"color:#9ECBFF\"> int,cpu_reset</span><span style=\"color:#79B8FF\"> -serial</span><span style=\"color:#9ECBFF\"> stdio</span><span style=\"color:#79B8FF\"> -display</span><span style=\"color:#9ECBFF\"> none</span><span style=\"color:#F97583\"> 2>&#x26;1</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tee</span><span style=\"color:#9ECBFF\"> paging_log.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check for \"Paging enabled\" message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -q</span><span style=\"color:#9ECBFF\"> \"Paging enabled\"</span><span style=\"color:#9ECBFF\"> paging_log.txt</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"PASS: Paging enabled message found\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"FAIL: Paging enabled message not found\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    exit</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check for triple fault (reset)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -q</span><span style=\"color:#9ECBFF\"> \"cpu_reset\"</span><span style=\"color:#9ECBFF\"> paging_log.txt</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"FAIL: CPU reset detected (possible triple fault)\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    exit</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"PASS: No triple fault after paging enable\"</span></span></code></pre></div>\n\n<h3 id=\"test-6-heap-allocation\">Test 6: Heap Allocation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// kernel/test_heap.c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_heap_allocation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Testing heap allocation...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate various sizes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  kmalloc(16) = 0x\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#B392F0\">vga_put_hex</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)p1);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">  kmalloc(100) = 0x\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#B392F0\">vga_put_hex</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)p2);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">  kmalloc(1000) = 0x\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#B392F0\">vga_put_hex</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)p3);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify addresses are in heap region</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)p1 </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> HEAP_START, </span><span style=\"color:#9ECBFF\">\"p1 below heap\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)p2 </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> HEAP_START, </span><span style=\"color:#9ECBFF\">\"p2 below heap\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)p3 </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> HEAP_START, </span><span style=\"color:#9ECBFF\">\"p3 below heap\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write to memory (shouldn't fault)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(p1, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">AA</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(p2, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">BB</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(p3, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">CC</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Free and reallocate</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kfree</span><span style=\"color:#E1E4E8\">(p2);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p4 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  After free+alloc: 0x\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#B392F0\">vga_put_hex</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)p4);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // p4 should be near p2 (reused space)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">abs</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)p4 </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)p2) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 200</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"p4 should reuse p2 space\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PASS: Heap allocation</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-7-heap-coalescing\">Test 7: Heap Coalescing</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// kernel/test_heap.c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_heap_coalescing</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Testing heap coalescing...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate three contiguous blocks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Free them in order</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kfree</span><span style=\"color:#E1E4E8\">(p1);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kfree</span><span style=\"color:#E1E4E8\">(p2);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kfree</span><span style=\"color:#E1E4E8\">(p3);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Now allocate a large block that should fit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">large </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">300</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Large allocation after coalesce: 0x\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_put_hex</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)large);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should be at or near p1 (coalesced space)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)large </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)p1 </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">           abs</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)large </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)p1) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 400</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">           \"Coalescing failed\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PASS: Heap coalescing</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-8-page-fault-diagnostics\">Test 8: Page Fault Diagnostics</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># test_page_fault.sh</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Trigger page fault and verify diagnostic output</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Modify kernel to intentionally cause page fault:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># uint32_t *bad = (uint32_t*)0xDEADBEEF;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># *bad = 0x12345678;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">timeout</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#9ECBFF\"> qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    -serial</span><span style=\"color:#9ECBFF\"> stdio</span><span style=\"color:#79B8FF\"> -display</span><span style=\"color:#9ECBFF\"> none</span><span style=\"color:#F97583\"> 2>&#x26;1</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tee</span><span style=\"color:#9ECBFF\"> pf_log.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check for page fault message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -q</span><span style=\"color:#9ECBFF\"> \"PAGE FAULT\"</span><span style=\"color:#9ECBFF\"> pf_log.txt</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"PASS: Page fault handler executed\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"FAIL: No page fault message\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    exit</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check for faulting address</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -q</span><span style=\"color:#9ECBFF\"> \"0xDEADBEEF\\|Address:\"</span><span style=\"color:#9ECBFF\"> pf_log.txt</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"PASS: Fault address reported\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"FAIL: Fault address not reported\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    exit</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-targets\">Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Target</th>\n<th>How to Measure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Frame allocation (bitmap scan)</td>\n<td>O(n) worst case, ~10µs for 1GB</td>\n<td>Time alloc_frame() calls, average over 1000 allocations</td>\n</tr>\n<tr>\n<td>Frame free</td>\n<td>O(1), &lt; 1µs</td>\n<td>Time free_frame() calls</td>\n</tr>\n<tr>\n<td>Page mapping (no PT alloc)</td>\n<td>&lt; 500 cycles, ~200ns</td>\n<td>Time map_page() for already-present PT</td>\n</tr>\n<tr>\n<td>Page mapping (with PT alloc)</td>\n<td>&lt; 2000 cycles, ~1µs</td>\n<td>Time map_page() including frame allocation</td>\n</tr>\n<tr>\n<td>TLB invalidate</td>\n<td>~10 cycles</td>\n<td>Single invlpg instruction</td>\n</tr>\n<tr>\n<td>kmalloc (small, &lt; 64 bytes)</td>\n<td>&lt; 1µs</td>\n<td>Time 1000 allocations, average</td>\n</tr>\n<tr>\n<td>kmalloc (large, &gt; 4KB)</td>\n<td>&lt; 10µs</td>\n<td>Time large allocations including page mapping</td>\n</tr>\n<tr>\n<td>kfree</td>\n<td>&lt; 1µs</td>\n<td>Time 1000 frees, average</td>\n</tr>\n<tr>\n<td>Page fault handler</td>\n<td>&lt; 50µs</td>\n<td>Time from fault to diagnostic print</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"hardware-soul\">Hardware Soul</h2>\n<h3 id=\"cache-lines-touched\">Cache Lines Touched</h3>\n<p><strong>Page table access</strong>: Each page table (4KB) occupies exactly 4 cache lines (64 bytes each). During a page walk:</p>\n<ul>\n<li>1 cache line read for PDE (8 bytes, likely shared with other PDEs)</li>\n<li>1 cache line read for PTE (4 bytes, likely shared with other PTEs)</li>\n<li>Total: 2 cache line reads per TLB miss</li>\n</ul>\n<p><strong>Frame allocator bitmap</strong>: For 1GB RAM with 4KB frames:</p>\n<ul>\n<li>32,768 bits = 4KB bitmap = 64 cache lines</li>\n<li>Scanning allocates reads sequentially, good locality</li>\n<li>Free operation touches single cache line</li>\n</ul>\n<p><strong>Heap metadata</strong>: Each block header is 20 bytes. A 64-byte cache line holds ~3 block headers. Allocation scans through headers sequentially until finding fit.</p>\n<h3 id=\"tlb-behavior\">TLB Behavior</h3>\n<p><strong>TLB size</strong>: 64-128 entries on typical x86 CPUs. Each entry maps one 4KB page.</p>\n<p><strong>Coverage</strong>: 64 entries × 4KB = 256KB of direct mapping. Any access outside these 256KB triggers TLB miss and page walk.</p>\n<p><strong>Context switch cost</strong>: CR3 reload invalidates all TLB entries (unless PCID used). Process switch = full TLB flush = worst case 64-128 page walks to repopulate.</p>\n<p><strong>Large page optimization</strong>: Using 4MB pages (PS bit in PDE) means one TLB entry covers 4MB instead of 4KB. 64 entries × 4MB = 256MB coverage. (Not implemented in this spec.)</p>\n<h3 id=\"memory-access-patterns\">Memory Access Patterns</h3>\n<p><strong>Sequential frame allocation</strong>: Good cache behavior—bitmap scan proceeds linearly. If physical memory is contiguous, allocated frames have good locality.</p>\n<p><strong>Random page mapping</strong>: If virtual addresses are scattered across different page tables, each mapping may allocate a new PT, causing allocation overhead and potential cache thrashing.</p>\n<p><strong>Heap fragmentation</strong>: Over time, many small allocations/frees create scattered free blocks. First-fit scanning traverses many cache lines.</p>\n<h3 id=\"physical-reality\">Physical Reality</h3>\n<p><strong>DRAM latency</strong>: ~70ns for DDR4. A TLB miss causing 2 DRAM accesses = 140ns minimum, plus controller overhead.</p>\n<p><strong>Page fault overhead</strong>: Full context switch + disk I/O = milliseconds. Even without swap, just the handler overhead is 10-50µs.</p>\n<p><strong>False sharing</strong>: If two frequently-modified variables share a cache line, they cause cache coherency traffic. Heap head/tail pointers should be on separate cache lines in a multi-threaded system.</p>\n<hr>\n<h2 id=\"concurrency-specification\">Concurrency Specification</h2>\n<h3 id=\"current-model-single-threaded\">Current Model: Single-Threaded</h3>\n<p>All allocation functions are <strong>not thread-safe</strong> by design for this milestone. The kernel runs single-threaded until Milestone 4.</p>\n<h3 id=\"critical-sections-future-proofing\">Critical Sections (Future-Proofing)</h3>\n<p>When interrupts are enabled and scheduling is added:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">kmalloc_safe</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">ptr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> flags;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Disable interrupts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">pushf; pop %0; cli</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(flags));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> kmalloc</span><span style=\"color:#E1E4E8\">(size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Restore interrupts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">push %0; popf</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(flags));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"lock-free-keyboard-buffer-already-implemented\">Lock-Free Keyboard Buffer (Already Implemented)</h3>\n<p>The circular buffer uses careful index ordering:</p>\n<ul>\n<li>Producer (IRQ handler) only writes to <code>head</code>, reads <code>tail</code></li>\n<li>Consumer (main code) only writes to <code>tail</code>, reads <code>head</code></li>\n<li>Full condition: <code>(head + 1) % SIZE == tail</code> (checked by producer)</li>\n<li>Empty condition: <code>head == tail</code> (checked by consumer)</li>\n</ul>\n<p>No locks needed because each side only modifies one index.</p>\n<hr>\n<h2 id=\"visual-diagrams\">Visual Diagrams</h2>\n<h3 id=\"page-table-hierarchy\">Page Table Hierarchy</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>x86 32-bit Two-Level Paging:\n\nVirtual Address (32 bits):\n┌─────────────────┬─────────────────┬─────────────────┐\n│  PD Index       │  PT Index       │  Page Offset    │\n│  (bits 31:22)   │  (bits 21:12)   │  (bits 11:0)    │\n│  10 bits        │  10 bits        │  12 bits        │\n└────────┬────────┴────────┬────────┴────────┬────────┘\n         │                 │                 │\n         ▼                 │                 │\n    ┌─────────┐            │                 │\n    │   CR3   │            │                 │\n    │(PD addr)│            │                 │\n    └────┬────┘            │                 │\n         │                 │                 │\n         ▼                 │                 │\n┌─────────────────┐        │                 │\n│ Page Directory  │        │                 │\n│  (4KB, 1024     │        │                 │\n│   entries)      │        │                 │\n├─────────────────┤        │                 │\n│ Entry[PD Index] │────────┘                 │\n│  → Page Table   │                          │\n│    Address      │                          │\n└────────┬────────┘                          │\n         │                                   │\n         ▼                                   │\n┌─────────────────┐                          │\n│  Page Table     │                          │\n│  (4KB, 1024     │                          │\n│   entries)      │                          │\n├─────────────────┤                          │\n│ Entry[PT Index] │──────────────────────────┘\n│  → Physical     │\n│    Frame Addr   │\n└────────┬────────┘\n         │\n         ▼\n┌─────────────────┐\n│ Physical Memory │\n│  (4KB Frame)    │\n│ at Frame Addr   │\n│ + Page Offset   │\n└─────────────────┘\n\nCoverage:\n- Page Directory: 1024 entries\n- Each PDE covers: 1024 × 4KB = 4MB\n- Total address space: 1024 × 4MB = 4GB</code></pre></div>\n\n<h3 id=\"page-directorytable-entry-bits\">Page Directory/Table Entry Bits</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Page Table Entry (32 bits):\n┌───────┬───────┬───────┬───────┬───────┬───────┬───────┬───────┬─────────────────┐\n│ 31    │ 12    │ 11  9 │ 8     │ 7     │ 6     │ 5     │ 4  3  │ 2   │ 1   │ 0   │\n│ Frame │       │ Avail │ Global│ PS    │ Dirty │ Acc   │ PCD   │ PWT │ U/S │ R/W │ P   │\n│ Addr  │       │ (OS)  │       │       │       │       │ PWT   │     │     │     │     │\n└───────┴───────┴───────┴───────┴───────┴───────┴───────┴───────┴─────┴─────┴─────┘\n          │                │       │       │       │       │       │     │     │     │\n          │                │       │       │       │       │       │     │     │     └─ Present\n          │                │       │       │       │       │       │     │     └─ Read/Write\n          │                │       │       │       │       │       │     └─ User/Supervisor\n          │                │       │       │       │       │       └─ Write-Through\n          │                │       │       │       │       └─ Cache Disable\n          │                │       │       │       └─ Accessed (CPU sets)\n          │                │       │       └─ Dirty (CPU sets, PT only)\n          │                │       └─ Page Size (0=4KB, 1=4MB in PD)\n          │                └─ Global (not flushed on CR3 reload)\n          └─ Available for OS use\n          \nBits 31:12 - Physical Frame Address (frame must be 4KB aligned)\n\nPage Directory Entry (same format, but):\n- Bit 7 (PS): Page Size (0=4KB pages, 1=4MB pages)\n- Bit 6 (D): Reserved (not dirty)\n- Frame Address points to Page Table (not data frame)</code></pre></div>\n\n<h3 id=\"e820-memory-map\">E820 Memory Map</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Typical E820 Memory Map (512MB system):\n\nPhysical Address\n┌─────────────────────────────────────────────────────────────────┐\n│ 0x000000 - 0x000FFF │ IVT, BDA (Reserved)            │  4 KB   │\n├─────────────────────────────────────────────────────────────────┤\n│ 0x001000 - 0x07FFFF │ Low Memory (Usable)            │ 508 KB  │\n├─────────────────────────────────────────────────────────────────┤\n│ 0x080000 - 0x0FFFFF │ EBDA, Video RAM, ROM (Reserved)│ ~500 KB │\n├─────────────────────────────────────────────────────────────────┤\n│ 0x100000 - 0x1FFFFF │ Kernel + data (Usable)         │  1 MB   │\n│                     │ (Marked used by allocator)     │         │\n├─────────────────────────────────────────────────────────────────┤\n│ 0x200000 - 0x1FFFFFF│ Extended Memory (Usable)       │ ~30 MB  │\n│                     │ Available for allocation       │         │\n├─────────────────────────────────────────────────────────────────┤\n│ 0x2000000+          │ More RAM (Usable)              │ ~480 MB │\n└─────────────────────────────────────────────────────────────────┘\n\nMemory Map Entry Format (E820):\n┌─────────────────────────────────────────────────────────────────┐\n│ Offset  Size  Field                                           │\n├─────────────────────────────────────────────────────────────────┤\n│ 0       8     Base Address (uint64_t)                         │\n│ 8       8     Length (uint64_t)                               │\n│ 16      4     Type (uint32_t)                                 │\n│                 1 = Usable                                    │\n│                 2 = Reserved                                  │\n│                 3 = ACPI Reclaimable                          │\n│                 4 = ACPI NVS                                  │\n│                 5 = Bad Memory                                │\n│ 20      4     ACPI Extended Attributes (optional)             │\n└─────────────────────────────────────────────────────────────────┘</code></pre></div>\n\n<h3 id=\"identity-higher-half-mapping\">Identity + Higher-Half Mapping</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Virtual Address Space Layout:\n\n┌─────────────────────────────────────────────────────────────────┐\n│ 0xFFFFFFFF           End of 32-bit address space               │\n│                                                                 │\n│ ... Reserved / Kernel Space ...                                │\n│                                                                 │\n├─────────────────────────────────────────────────────────────────┤\n│ 0xC0400000           Kernel Heap Start                         │\n│                     ┌─────────────────────────────────┐         │\n│                     │   kmalloc/kfree region          │         │\n│                     │   (grows on demand)             │         │\n│                     └─────────────────────────────────┘         │\n├─────────────────────────────────────────────────────────────────┤\n│ 0xC0100000           Kernel Code/Data (Higher-Half)            │\n│                     ┌─────────────────────────────────┐         │\n│                     │   .text, .rodata, .data, .bss   │         │\n│                     │   Maps to physical 0x00100000   │         │\n│                     └─────────────────────────────────┘         │\n├─────────────────────────────────────────────────────────────────┤\n│ 0xC0000000           Higher-Half Base (3 GB)                   │\n│                     Maps to physical 0x00000000                 │\n├─────────────────────────────────────────────────────────────────┤\n│ 0x01000000           End of Identity Map (16 MB)               │\n│                                                                 │\n│ ... Identity-Mapped Region ...                                 │\n│   0x00000000 - 0x00FFFFFF → 0x00000000 - 0x00FFFFFF           │\n│   (VGA at 0xB8000 accessible)                                  │\n│                                                                 │\n├─────────────────────────────────────────────────────────────────┤\n│ 0x00000000           Start of Address Space                    │\n│                     (User Space in future milestones)           │\n└─────────────────────────────────────────────────────────────────┘\n\nPhysical to Virtual Mapping:\n┌─────────────────────────────────────────────────────────────────┐\n│ Physical Address     Virtual Address         Purpose           │\n├─────────────────────────────────────────────────────────────────┤\n│ 0x00000000           0x00000000              Identity map      │\n│         ...                   ...             (first 16 MB)    │\n│ 0x00FFFFFF           0x00FFFFFF                                │\n├─────────────────────────────────────────────────────────────────┤\n│ 0x00000000           0xC0000000              Higher-half kernel│\n│         ...                   ...             (first 16 MB     │\n│ 0x00FFFFFF           0xC0FFFFFF               mapped high)     │\n├─────────────────────────────────────────────────────────────────┤\n│ 0x00100000           0xC0100000              Kernel code      │\n├─────────────────────────────────────────────────────────────────┤\n│ (allocated)          0xC0400000+             Kernel heap      │\n└─────────────────────────────────────────────────────────────────┘</code></pre></div>\n\n<h3 id=\"paging-enable-sequence\">Paging Enable Sequence</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Enabling Paging - Critical Sequence:\n\n┌─────────────────────────────────────────────────────────────────┐\n│ Step 1: Create Page Directory                                   │\n│   pd = alloc_frame()                                            │\n│   memset(pd, 0, 4096)                                          │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│ Step 2: Identity Map First 16 MB                                │\n│   FOR addr = 0 TO 16MB STEP 4K:                                │\n│     map_page(pd, addr, addr, PTE_WRITABLE)                     │\n│                                                                 │\n│   CRITICAL: Must include currently executing code!              │\n│   The instruction AFTER enabling paging must be mapped.        │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│ Step 3: Higher-Half Mapping                                     │\n│   FOR offset = 0 TO 16MB STEP 4K:                              │\n│     vaddr = 0xC0000000 + offset                                │\n│     paddr = offset                                             │\n│     map_page(pd, vaddr, paddr, PTE_WRITABLE)                   │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│ Step 4: Load CR3                                                │\n│   asm volatile(&quot;mov %0, %%cr3&quot; : : &quot;r&quot;(pd_phys))               │\n│                                                                 │\n│   This sets the page directory base address.                   │\n│   TLB is flushed when CR3 changes.                             │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│ Step 5: Enable Paging                                           │\n│   asm volatile(&quot;mov %%cr0, %0&quot; : &quot;=r&quot;(cr0))                    │\n│   cr0 |= (1 &lt;&lt; 31)  // Set PG bit                              │\n│   asm volatile(&quot;mov %0, %%cr0&quot; : : &quot;r&quot;(cr0))                   │\n│                                                                 │\n│   CRITICAL: The very next instruction fetch uses paging!       │\n│   If current EIP not mapped → immediate page fault → crash     │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│ Step 6: Continue in Paged Mode                                  │\n│   All addresses now translated through page tables.            │\n│   Kernel code accessible at 0xC0100000+.                       │\n│   VGA accessible at 0xB8000 (identity mapped).                 │\n└─────────────────────────────────────────────────────────────────┘\n\nCommon Mistakes:\n┌─────────────────────────────────────────────────────────────────┐\n│ ✗ Forgetting identity map → code not accessible after PG set   │\n│ ✗ Not mapping VGA → screen output breaks                       │\n│ ✗ Wrong CR3 value → page directory not found                   │\n│ ✗ Page tables not identity mapped → can't access PT to fill it │\n│ ✗ Forgetting invlpg → stale TLB entries                        │\n└─────────────────────────────────────────────────────────────────┘</code></pre></div>\n\n<h3 id=\"page-fault-handler-flow\">Page Fault Handler Flow</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Page Fault (Exception 14) Processing:\n\n┌─────────────────────────────────────────────────────────────────┐\n│                        CPU                                       │\n│  1. Instruction causes page fault                               │\n│  2. Push EFLAGS, CS, EIP                                        │\n│  3. Push error code                                              │\n│  4. Load CR2 with faulting address                              │\n│  5. Load IDT[14] → CS:EIP                                       │\n│  6. Jump to handler                                              │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│                    Assembly Stub                                 │\n│  1. Push dummy error code (if not provided)                     │\n│  2. Push interrupt number (14)                                  │\n│  3. pusha (save all GP registers)                               │\n│  4. Push segment registers                                      │\n│  5. Call C handler                                               │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│                     C Handler                                    │\n│                                                                 │\n│  void page_fault_handler(registers_t *regs) {                  │\n│      uint32_t fault_addr;                                       │\n│      asm volatile(&quot;mov %%cr2, %0&quot; : &quot;=r&quot;(fault_addr));         │\n│                                                                 │\n│      int present = !(regs-&gt;err_code &amp; 0x1);                    │\n│      int write = regs-&gt;err_code &amp; 0x2;                         │\n│      int user = regs-&gt;err_code &amp; 0x4;                          │\n│                                                                 │\n│      kprintf(&quot;Page Fault!\\n&quot;);                                  │\n│      kprintf(&quot;  Address: 0x%x\\n&quot;, fault_addr);                 │\n│      kprintf(&quot;  %s, %s, %s mode\\n&quot;,                            │\n│              present ? &quot;protection&quot; : &quot;not-present&quot;,           │\n│              write ? &quot;write&quot; : &quot;read&quot;,                          │\n│              user ? &quot;user&quot; : &quot;kernel&quot;);                        │\n│                                                                 │\n│      PANIC(&quot;Unhandled page fault&quot;);                             │\n│  }                                                               │\n└─────────────────────────────────────────────────────────────────┘\n\nError Code Bits:\n┌─────────────────────────────────────────────────────────────────┐\n│ Bit 0 (P): 0 = Page not present                                 │\n│            1 = Protection violation (page exists)              │\n│ Bit 1 (W): 0 = Read access                                      │\n│            1 = Write access                                     │\n│ Bit 2 (U): 0 = Supervisor mode (kernel)                        │\n│            1 = User mode                                        │\n│ Bit 3 (R): 1 = Reserved bit set in paging structures           │\n│ Bit 4 (I): 1 = Instruction fetch (NX violation)                │\n└─────────────────────────────────────────────────────────────────┘</code></pre></div>\n\n<h3 id=\"kmalloc-internals\">kmalloc Internals</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Kernel Heap Structure:\n\n┌─────────────────────────────────────────────────────────────────┐\n│                      Virtual Memory                              │\n│                    0xC0400000+                                   │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  ┌────────────────────────────────────────────────────────────┐│\n│  │                    Heap Block 1 (free)                     ││\n│  ├────────────────────────────────────────────────────────────┤│\n│  │ magic   │ 0xDEADBEEF                                        ││\n│  │ size    │ 1000                                              ││\n│  │ free    │ 1                                                 ││\n│  │ next    │ ─────────────────────────────┐                   ││\n│  │ prev    │ NULL                         │                   ││\n│  ├─────────┴─────────────────────────────┴───────────────────┤│\n│  │                    Data Area (1000 bytes)                  ││\n│  └────────────────────────────────────────────────────────────┘│\n│                           │                                     │\n│                           ▼                                     │\n│  ┌────────────────────────────────────────────────────────────┐│\n│  │                  Heap Block 2 (allocated)                  ││\n│  ├────────────────────────────────────────────────────────────┤│\n│  │ magic   │ 0xDEADBEEF                                        ││\n│  │ size    │ 64                                                ││\n│  │ free    │ 0                                                 ││\n│  │ next    │ ─────────────────────────────┐                   ││\n│  │ prev    │ ◄─────────────────────────────┘                   ││\n│  ├─────────┴─────────────────────────────┴───────────────────┤│\n│  │                    Data Area (64 bytes)                    ││\n│  │               [kmalloc returned pointer here]              ││\n│  └────────────────────────────────────────────────────────────┘│\n│                           │                                     │\n│                           ▼                                     │\n│  ┌────────────────────────────────────────────────────────────┐│\n│  │                    Heap Block 3 (free)                     ││\n│  ├────────────────────────────────────────────────────────────┤│\n│  │ magic   │ 0xDEADBEEF                                        ││\n│  │ size    │ 4080                                              ││\n│  │ free    │ 1                                                 ││\n│  │ next    │ NULL (end of heap)                               ││\n│  │ prev    │ ◄─────────────────────────────                    ││\n│  ├─────────┴─────────────────────────────┴───────────────────┤│\n│  │                    Data Area (4080 bytes)                  ││\n│  └────────────────────────────────────────────────────────────┘│\n│                                                                 │\n├─────────────────────────────────────────────────────────────────┤\n│                    End of Mapped Heap                           │\n│              (expand by mapping more pages)                     │\n└─────────────────────────────────────────────────────────────────┘\n\nkmalloc Algorithm:\n┌─────────────────────────────────────────────────────────────────┐\n│ 1. Align size to 4 bytes                                        │\n│ 2. Scan free list for block &gt;= size                            │\n│ 3. If found:                                                    │\n│    a. If block is much larger, split:                          │\n│       - Create new free block after allocated portion          │\n│       - Adjust sizes                                           │\n│    b. Mark block as allocated                                   │\n│    c. Return pointer to data area                              │\n│ 4. If not found:                                                │\n│    a. Expand heap (map new pages)                              │\n│    b. Create new free block in expanded region                 │\n│    c. Retry allocation                                          │\n└─────────────────────────────────────────────────────────────────┘\n\nkfree Algorithm:\n┌─────────────────────────────────────────────────────────────────┐\n│ 1. Get block header from pointer                               │\n│ 2. Verify magic number                                          │\n│ 3. Check for double-free                                        │\n│ 4. Mark as free                                                 │\n│ 5. Coalesce with next block if free                            │\n│ 6. Coalesce with previous block if free                        │\n└─────────────────────────────────────────────────────────────────┘</code></pre></div>\n\n<hr>\n<!-- TDD_MOD_ID: mod-scheduling -->\n<h1 id=\"technical-design-specification-process-management-and-preemptive-scheduling\">Technical Design Specification: Process Management and Preemptive Scheduling</h1>\n<h2 id=\"module-charter\">Module Charter</h2>\n<p>The process management module implements preemptive multitasking through Process Control Blocks (PCBs) that capture complete CPU state, assembly context switching that saves/restores all registers, TSS configuration for secure ring 3→ring 0 stack transitions during interrupts/syscalls, a round-robin scheduler triggered by timer interrupts, and a system call interface via INT 0x80. It supports both kernel-mode processes (ring 0, shared address space) and user-mode processes (ring 3, isolated page directories).</p>\n<p><strong>What it does NOT do</strong>: This module does not implement demand paging (page faults halt), does not implement priority scheduling or deadline scheduling (round-robin only), does not implement inter-process communication beyond basic syscalls, does not handle process termination cleanup beyond marking zombie state, does not implement copy-on-write fork, and does not implement threading (one thread per process).</p>\n<p><strong>Upstream dependencies</strong>: GDT must include user code/data descriptors (ring 3) at indices 3-4; IDT must have handlers for exceptions 0-31 and IRQs 0-15; timer interrupt must fire at configured frequency; paging must be enabled with identity mapping for low memory and higher-half kernel; frame allocator and heap must be functional.</p>\n<p><strong>Downstream consumers</strong>: User programs execute via syscalls (sys_write, sys_exit); shell/command interpreter will use process creation; future milestones may add IPC, signals, and file descriptors.</p>\n<p><strong>Invariants</strong>: TSS.ESP0 must be updated before every context switch to a user-mode process; context switch must save ALL registers in PCB order; scheduler must disable interrupts during critical sections; user processes must never access kernel memory (page fault if attempted); syscall handler must validate all user pointers before dereferencing.</p>\n<hr>\n<h2 id=\"file-structure\">File Structure</h2>\n<p>Create files in this order:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>1. kernel/process/process.h      # PCB structure, process states, function declarations\n2. kernel/process/process.c      # Process creation, destruction, table management\n3. kernel/process/context.asm    # Context switch assembly implementation\n4. kernel/process/tss.h          # TSS structure and function declarations\n5. kernel/process/tss.c          # TSS initialization and ESP0 update\n6. kernel/process/scheduler.h    # Scheduler interface declarations\n7. kernel/process/scheduler.c    # Round-robin scheduler implementation\n8. kernel/syscall/syscall.h      # Syscall numbers and handler declarations\n9. kernel/syscall/syscall.c      # Syscall dispatch and implementations\n10. kernel/syscall/syscall.asm   # Syscall entry stub (INT 0x80)\n11. kernel/user/user_mode.asm    # enter_user_mode assembly\n12. kernel/user/user_entry.c     # User process entry point wrapper</code></pre></div>\n\n<hr>\n<h2 id=\"complete-data-model\">Complete Data Model</h2>\n<h3 id=\"process-control-block-pcb\">Process Control Block (PCB)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// kernel/process/process.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"memory/paging.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Process states</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROCESS_UNUSED </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">       // Slot in process table is free</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROCESS_READY,</span><span style=\"color:#6A737D\">            // Ready to run, waiting for scheduler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROCESS_RUNNING,</span><span style=\"color:#6A737D\">          // Currently executing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROCESS_BLOCKED,</span><span style=\"color:#6A737D\">          // Waiting for I/O, sleep, etc.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PROCESS_ZOMBIE</span><span style=\"color:#6A737D\">            // Terminated, waiting for cleanup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">process_state_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Process Control Block - matches assembly offsets exactly</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> process {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // === Identification (offset 0) ===</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pid;</span><span style=\"color:#6A737D\">                    // Process ID (1-65535)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">                   // Process name (null-terminated)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_state_t</span><span style=\"color:#E1E4E8\"> state;</span><span style=\"color:#6A737D\">           // Current state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> padding0</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">             // Align to 8 bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // === Register state (offset 32) ===</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // General purpose registers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eax;</span><span style=\"color:#6A737D\">                    // Offset 32</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ebx;</span><span style=\"color:#6A737D\">                    // Offset 36</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ecx;</span><span style=\"color:#6A737D\">                    // Offset 40</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> edx;</span><span style=\"color:#6A737D\">                    // Offset 44</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esi;</span><span style=\"color:#6A737D\">                    // Offset 48</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> edi;</span><span style=\"color:#6A737D\">                    // Offset 52</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ebp;</span><span style=\"color:#6A737D\">                    // Offset 56</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esp;</span><span style=\"color:#6A737D\">                    // Offset 60 - kernel or user stack</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eip;</span><span style=\"color:#6A737D\">                    // Offset 64 - instruction pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eflags;</span><span style=\"color:#6A737D\">                 // Offset 68 - flags register</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Segment registers (16-bit values stored in 32-bit fields)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> cs;</span><span style=\"color:#6A737D\">                     // Offset 72 - code segment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ds;</span><span style=\"color:#6A737D\">                     // Offset 76 - data segment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> es;</span><span style=\"color:#6A737D\">                     // Offset 80</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> fs;</span><span style=\"color:#6A737D\">                     // Offset 84</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> gs;</span><span style=\"color:#6A737D\">                     // Offset 88</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ss;</span><span style=\"color:#6A737D\">                     // Offset 92 - stack segment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // === Memory management (offset 96) ===</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">page_directory;</span><span style=\"color:#6A737D\">    // Offset 96 - virtual address space</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> kernel_stack;</span><span style=\"color:#6A737D\">               // Offset 100 - top of kernel stack (for TSS.ESP0)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> user_stack_top;</span><span style=\"color:#6A737D\">             // Offset 104 - user stack top (if user mode)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // === Scheduling (offset 108) ===</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> process </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">next;</span><span style=\"color:#6A737D\">           // Offset 108 - next in run queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> process </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">prev;</span><span style=\"color:#6A737D\">           // Offset 112 - previous in run queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> wake_time;</span><span style=\"color:#6A737D\">             // Offset 116 - tick to wake (for sleep)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int32_t</span><span style=\"color:#E1E4E8\"> exit_status;</span><span style=\"color:#6A737D\">            // Offset 120 - exit code for parent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> time_slice;</span><span style=\"color:#6A737D\">            // Offset 124 - remaining time slice</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // === Process tree (future expansion) ===</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> process </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">parent;</span><span style=\"color:#6A737D\">         // Offset 128 - parent process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> process </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">first_child;</span><span style=\"color:#6A737D\">    // Offset 132 - first child</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> process </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">next_sibling;</span><span style=\"color:#6A737D\">   // Offset 136 - next sibling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed)) </span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Verify PCB size and alignment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PCB_SIZE</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PCB_REG_OFFSET</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#6A737D\">          // Offset to first register (eax)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Process table</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_PROCESSES</span><span style=\"color:#79B8FF\"> 64</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> KERNEL_STACK_SIZE</span><span style=\"color:#79B8FF\"> 4096</span><span style=\"color:#6A737D\">     // 4KB kernel stack per process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> USER_STACK_SIZE</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\"> // 64KB user stack</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#79B8FF\"> process_t</span><span style=\"color:#FFAB70\"> process_table</span><span style=\"color:#E1E4E8\">[MAX_PROCESSES];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#79B8FF\"> process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">current_process;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#79B8FF\"> process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">ready_queue;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> next_pid;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Assembly context switch offsets MUST match this structure:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Verify with: nasm -f elf32 context.asm &#x26;&#x26; nm context.o</span></span></code></pre></div>\n\n<p><strong>PCB Memory Layout (byte offsets):</strong></p>\n<table>\n<thead>\n<tr>\n<th>Offset</th>\n<th>Size</th>\n<th>Field</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>4</td>\n<td>pid</td>\n<td>Unique process identifier</td>\n</tr>\n<tr>\n<td>4</td>\n<td>16</td>\n<td>name</td>\n<td>Debug-friendly process name</td>\n</tr>\n<tr>\n<td>20</td>\n<td>4</td>\n<td>state</td>\n<td>Ready/Running/Blocked/Zombie</td>\n</tr>\n<tr>\n<td>24</td>\n<td>4</td>\n<td>padding0</td>\n<td>Alignment to 8 bytes</td>\n</tr>\n<tr>\n<td>28</td>\n<td>4</td>\n<td>(reserved)</td>\n<td>Future use</td>\n</tr>\n<tr>\n<td>32</td>\n<td>4</td>\n<td>eax</td>\n<td>General purpose register A</td>\n</tr>\n<tr>\n<td>36</td>\n<td>4</td>\n<td>ebx</td>\n<td>General purpose register B</td>\n</tr>\n<tr>\n<td>40</td>\n<td>4</td>\n<td>ecx</td>\n<td>General purpose register C</td>\n</tr>\n<tr>\n<td>44</td>\n<td>4</td>\n<td>edx</td>\n<td>General purpose register D</td>\n</tr>\n<tr>\n<td>48</td>\n<td>4</td>\n<td>esi</td>\n<td>Source index register</td>\n</tr>\n<tr>\n<td>52</td>\n<td>4</td>\n<td>edi</td>\n<td>Destination index register</td>\n</tr>\n<tr>\n<td>56</td>\n<td>4</td>\n<td>ebp</td>\n<td>Base pointer</td>\n</tr>\n<tr>\n<td>60</td>\n<td>4</td>\n<td>esp</td>\n<td>Stack pointer</td>\n</tr>\n<tr>\n<td>64</td>\n<td>4</td>\n<td>eip</td>\n<td>Instruction pointer</td>\n</tr>\n<tr>\n<td>68</td>\n<td>4</td>\n<td>eflags</td>\n<td>CPU flags</td>\n</tr>\n<tr>\n<td>72</td>\n<td>4</td>\n<td>cs</td>\n<td>Code segment selector</td>\n</tr>\n<tr>\n<td>76</td>\n<td>4</td>\n<td>ds</td>\n<td>Data segment selector</td>\n</tr>\n<tr>\n<td>80</td>\n<td>4</td>\n<td>es</td>\n<td>Extra segment selector</td>\n</tr>\n<tr>\n<td>84</td>\n<td>4</td>\n<td>fs</td>\n<td>Extra segment selector</td>\n</tr>\n<tr>\n<td>88</td>\n<td>4</td>\n<td>gs</td>\n<td>Extra segment selector</td>\n</tr>\n<tr>\n<td>92</td>\n<td>4</td>\n<td>ss</td>\n<td>Stack segment selector</td>\n</tr>\n<tr>\n<td>96</td>\n<td>4</td>\n<td>page_directory</td>\n<td>Pointer to process page tables</td>\n</tr>\n<tr>\n<td>100</td>\n<td>4</td>\n<td>kernel_stack</td>\n<td>Kernel stack top (for TSS.ESP0)</td>\n</tr>\n<tr>\n<td>104</td>\n<td>4</td>\n<td>user_stack_top</td>\n<td>User mode stack top</td>\n</tr>\n<tr>\n<td>108</td>\n<td>4</td>\n<td>next</td>\n<td>Next process in queue</td>\n</tr>\n<tr>\n<td>112</td>\n<td>4</td>\n<td>prev</td>\n<td>Previous process in queue</td>\n</tr>\n<tr>\n<td>116</td>\n<td>4</td>\n<td>wake_time</td>\n<td>Tick count to wake</td>\n</tr>\n<tr>\n<td>120</td>\n<td>4</td>\n<td>exit_status</td>\n<td>Process exit code</td>\n</tr>\n<tr>\n<td>124</td>\n<td>4</td>\n<td>time_slice</td>\n<td>Remaining quantum</td>\n</tr>\n<tr>\n<td>128</td>\n<td>4</td>\n<td>parent</td>\n<td>Parent process pointer</td>\n</tr>\n<tr>\n<td>132</td>\n<td>4</td>\n<td>first_child</td>\n<td>First child pointer</td>\n</tr>\n<tr>\n<td>136</td>\n<td>4</td>\n<td>next_sibling</td>\n<td>Sibling list pointer</td>\n</tr>\n</tbody></table>\n<h3 id=\"task-state-segment-tss\">Task State Segment (TSS)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// kernel/process/tss.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TSS structure for 32-bit x86</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Only SS0:ESP0 are critical for ring transitions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> prev_task;</span><span style=\"color:#6A737D\">       // 0: Previous task link (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved0;</span><span style=\"color:#6A737D\">       // 2: Reserved</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esp0;</span><span style=\"color:#6A737D\">            // 4: Stack pointer for ring 0 (CRITICAL)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ss0;</span><span style=\"color:#6A737D\">             // 8: Stack segment for ring 0 (CRITICAL)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved1;</span><span style=\"color:#6A737D\">       // 10: Reserved</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esp1;</span><span style=\"color:#6A737D\">            // 12: Stack pointer for ring 1 (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ss1;</span><span style=\"color:#6A737D\">             // 16: Stack segment for ring 1 (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved2;</span><span style=\"color:#6A737D\">       // 18: Reserved</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esp2;</span><span style=\"color:#6A737D\">            // 20: Stack pointer for ring 2 (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ss2;</span><span style=\"color:#6A737D\">             // 24: Stack segment for ring 2 (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved3;</span><span style=\"color:#6A737D\">       // 26: Reserved</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> cr3;</span><span style=\"color:#6A737D\">             // 28: Page directory base (unused in software switching)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eip;</span><span style=\"color:#6A737D\">             // 32: Instruction pointer (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eflags;</span><span style=\"color:#6A737D\">          // 36: Flags (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> eax;</span><span style=\"color:#6A737D\">             // 40-68: General registers (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ecx;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> edx;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ebx;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esp;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ebp;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> esi;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> edi;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> es;</span><span style=\"color:#6A737D\">              // 72: Extra segment (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved4;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> cs;</span><span style=\"color:#6A737D\">              // 76: Code segment (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved5;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ss;</span><span style=\"color:#6A737D\">              // 80: Stack segment (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved6;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ds;</span><span style=\"color:#6A737D\">              // 84: Data segment (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved7;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> fs;</span><span style=\"color:#6A737D\">              // 88: Extra segment (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved8;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> gs;</span><span style=\"color:#6A737D\">              // 92: Extra segment (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved9;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> ldt;</span><span style=\"color:#6A737D\">             // 96: LDT selector (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> reserved10;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> trap;</span><span style=\"color:#6A737D\">            // 100: Trap bit (unused)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> iomap_base;</span><span style=\"color:#6A737D\">      // 102: I/O permission bitmap offset</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#B392F0\">__attribute__</span><span style=\"color:#E1E4E8\">((packed)) </span><span style=\"color:#79B8FF\">tss_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TSS instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#79B8FF\"> tss_t</span><span style=\"color:#E1E4E8\"> tss;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TSS selector in GDT (index 5, selector = 0x28)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TSS_SELECTOR</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">28</span></span></code></pre></div>\n\n<h3 id=\"system-call-numbers\">System Call Numbers</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// kernel/syscall/syscall.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// System call numbers (passed in EAX)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SYS_EXIT</span><span style=\"color:#79B8FF\">    0</span><span style=\"color:#6A737D\">    // void sys_exit(int status)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SYS_READ</span><span style=\"color:#79B8FF\">    1</span><span style=\"color:#6A737D\">    // int sys_read(int fd, char *buf, int count)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SYS_WRITE</span><span style=\"color:#79B8FF\">   2</span><span style=\"color:#6A737D\">    // int sys_write(int fd, const char *buf, int count)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SYS_EXEC</span><span style=\"color:#79B8FF\">    3</span><span style=\"color:#6A737D\">    // int sys_exec(const char *path)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SYS_FORK</span><span style=\"color:#79B8FF\">    4</span><span style=\"color:#6A737D\">    // int sys_fork(void)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SYS_GETPID</span><span style=\"color:#79B8FF\">  5</span><span style=\"color:#6A737D\">    // int sys_getpid(void)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SYS_YIELD</span><span style=\"color:#79B8FF\">   6</span><span style=\"color:#6A737D\">    // void sys_yield(void)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Maximum syscall number</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_SYSCALL</span><span style=\"color:#79B8FF\"> 7</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Syscall handler type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> int32_t</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">syscall_handler_t</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> arg0, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> arg1, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> arg2);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Syscall dispatch table</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#79B8FF\"> syscall_handler_t</span><span style=\"color:#FFAB70\"> syscall_table</span><span style=\"color:#E1E4E8\">[MAX_SYSCALL];</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Individual syscall implementations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> sys_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> status</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> sys_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> sys_read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> fd</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> sys_getpid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> sys_yield</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<h3 id=\"scheduler-data-structures\">Scheduler Data Structures</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// kernel/process/scheduler.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"process.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Scheduler configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DEFAULT_TIME_SLICE</span><span style=\"color:#79B8FF\">  10</span><span style=\"color:#6A737D\">    // Default ticks per time slice (100ms at 100Hz)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SCHEDULER_FREQ</span><span style=\"color:#79B8FF\">      100</span><span style=\"color:#6A737D\">   // Timer frequency in Hz</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Scheduler state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#E1E4E8\"> scheduler_ticks;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> scheduler_enabled;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Run queue management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_add_to_queue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">proc</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_remove_from_queue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">proc</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">scheduler_pick_next</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Core scheduler functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_tick</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">           // Called from timer interrupt</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_yield</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">          // Voluntary yield</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">proc</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_unblock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">proc</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"interface-contracts\">Interface Contracts</h2>\n<h3 id=\"process_createconst-char-name-void-entryvoid-int-is_user\">process_create(const char *name, void (*entry)(void), int is_user)</h3>\n<p><strong>Purpose</strong>: Create a new process and add it to the ready queue</p>\n<p><strong>Parameters</strong>:</p>\n<ul>\n<li><code>name</code>: Process name (max 15 characters)</li>\n<li><code>entry</code>: Entry point function</li>\n<li><code>is_user</code>: 0 for kernel-mode process, 1 for user-mode</li>\n</ul>\n<p><strong>Returns</strong>:</p>\n<ul>\n<li>Pointer to new process_t on success</li>\n<li>NULL on failure (process table full, out of memory)</li>\n</ul>\n<p><strong>Side effects</strong>:</p>\n<ul>\n<li>Allocates PCB slot</li>\n<li>Allocates kernel stack (4KB)</li>\n<li>For user processes: allocates user stack and clones page directory</li>\n<li>Adds process to ready queue</li>\n</ul>\n<p><strong>Preconditions</strong>: Memory allocator initialized; paging enabled</p>\n<p><strong>Postconditions</strong>: New process in READY state, runnable by scheduler</p>\n<h3 id=\"process_exitint-status\">process_exit(int status)</h3>\n<p><strong>Purpose</strong>: Terminate the current process</p>\n<p><strong>Parameters</strong>:</p>\n<ul>\n<li><code>status</code>: Exit status code</li>\n</ul>\n<p><strong>Returns</strong>: Does not return</p>\n<p><strong>Side effects</strong>:</p>\n<ul>\n<li>Sets process state to ZOMBIE</li>\n<li>Stores exit status</li>\n<li>Removes from run queue</li>\n<li>Triggers scheduler to run next process</li>\n</ul>\n<h3 id=\"context_switchprocess_t-old-process_t-new\">context_switch(process_t *old, process_t *new)</h3>\n<p><strong>Purpose</strong>: Save current CPU state to old PCB and load state from new PCB</p>\n<p><strong>Parameters</strong>:</p>\n<ul>\n<li><code>old</code>: Pointer to current process PCB (may be NULL for first switch)</li>\n<li><code>new</code>: Pointer to process to switch to</li>\n</ul>\n<p><strong>Returns</strong>: Does not return to caller (returns to new process context)</p>\n<p><strong>Side effects</strong>:</p>\n<ul>\n<li>Saves all registers to old-&gt;*</li>\n<li>Loads CR3 if page directories differ</li>\n<li>Updates TSS.ESP0 for user processes</li>\n<li>Loads all registers from new-&gt;*</li>\n<li>Returns to new-&gt;eip with new-&gt;eflags</li>\n</ul>\n<p><strong>Critical</strong>: Assembly implementation; must match PCB offsets exactly</p>\n<h3 id=\"tss_initvoid\">tss_init(void)</h3>\n<p><strong>Purpose</strong>: Initialize the Task State Segment and load TR</p>\n<p><strong>Parameters</strong>: None</p>\n<p><strong>Returns</strong>: None</p>\n<p><strong>Side effects</strong>:</p>\n<ul>\n<li>Zeros TSS structure</li>\n<li>Sets TSS.SS0 = 0x10 (kernel data selector)</li>\n<li>Adds TSS descriptor to GDT at index 5</li>\n<li>Loads TR with selector 0x28</li>\n</ul>\n<p><strong>Preconditions</strong>: GDT must be loaded</p>\n<h3 id=\"tss_set_esp0uint32_t-esp0\">tss_set_esp0(uint32_t esp0)</h3>\n<p><strong>Purpose</strong>: Update the kernel stack pointer for ring transitions</p>\n<p><strong>Parameters</strong>:</p>\n<ul>\n<li><code>esp0</code>: New value for TSS.ESP0</li>\n</ul>\n<p><strong>Returns</strong>: None</p>\n<p><strong>Critical</strong>: MUST be called before switching to any user-mode process</p>\n<h3 id=\"scheduler_initvoid\">scheduler_init(void)</h3>\n<p><strong>Purpose</strong>: Initialize scheduler and create kernel idle process</p>\n<p><strong>Parameters</strong>: None</p>\n<p><strong>Returns</strong>: None</p>\n<p><strong>Side effects</strong>:</p>\n<ul>\n<li>Creates PCB for current (kernel) process</li>\n<li>Sets current_process to kernel process</li>\n<li>Enables scheduler</li>\n</ul>\n<h3 id=\"scheduler_tickvoid\">scheduler_tick(void)</h3>\n<p><strong>Purpose</strong>: Handle timer interrupt and trigger context switch if needed</p>\n<p><strong>Parameters</strong>: None (called from timer IRQ handler)</p>\n<p><strong>Returns</strong>: None</p>\n<p><strong>Side effects</strong>:</p>\n<ul>\n<li>Increments tick counter</li>\n<li>Decrements current process time slice</li>\n<li>Triggers context switch if slice expired or process yielded</li>\n</ul>\n<p><strong>Preconditions</strong>: Timer interrupt configured; IDT loaded</p>\n<h3 id=\"scheduler_yieldvoid\">scheduler_yield(void)</h3>\n<p><strong>Purpose</strong>: Voluntarily give up CPU to next ready process</p>\n<p><strong>Parameters</strong>: None</p>\n<p><strong>Returns</strong>: Does not return immediately (returns when scheduled again)</p>\n<p><strong>Side effects</strong>:</p>\n<ul>\n<li>Marks current process as READY</li>\n<li>Triggers immediate context switch</li>\n</ul>\n<h3 id=\"enter_user_modeuint32_t-entry-uint32_t-stack\">enter_user_mode(uint32_t entry, uint32_t stack)</h3>\n<p><strong>Purpose</strong>: Transition from kernel mode to user mode</p>\n<p><strong>Parameters</strong>:</p>\n<ul>\n<li><code>entry</code>: Entry point address in user space</li>\n<li><code>stack</code>: Top of user stack</li>\n</ul>\n<p><strong>Returns</strong>: Does not return (begins executing user code at ring 3)</p>\n<p><strong>Side effects</strong>:</p>\n<ul>\n<li>Loads segment registers with user selectors (0x23)</li>\n<li>Sets up iret frame with user CS, SS, EIP, ESP, EFLAGS</li>\n<li>Executes iret to enter ring 3</li>\n</ul>\n<p><strong>Critical</strong>: TSS.ESP0 must be set before calling</p>\n<h3 id=\"syscall_handlerregisters_t-regs\">syscall_handler(registers_t *regs)</h3>\n<p><strong>Purpose</strong>: Dispatch system call to appropriate handler</p>\n<p><strong>Parameters</strong>:</p>\n<ul>\n<li><code>regs</code>: Pointer to saved register frame (int_no = 0x80)</li>\n</ul>\n<p><strong>Returns</strong>: Result in regs-&gt;eax</p>\n<p><strong>Side effects</strong>:</p>\n<ul>\n<li>Validates syscall number</li>\n<li>Validates user pointers</li>\n<li>Calls appropriate handler function</li>\n</ul>\n<hr>\n<h2 id=\"algorithm-specification\">Algorithm Specification</h2>\n<h3 id=\"process-creation\">Process Creation</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>PROCESS_CREATE(name, entry, is_user):\n  1. Find free slot in process_table\n     FOR i = 0 TO MAX_PROCESSES - 1:\n       IF process_table[i].state == PROCESS_UNUSED:\n         proc = &amp;process_table[i]\n         BREAK\n     IF no free slot:\n       RETURN NULL\n  \n  2. Initialize PCB fields\n     memset(proc, 0, sizeof(process_t))\n     proc-&gt;pid = next_pid++\n     strncpy(proc-&gt;name, name, 15)\n     proc-&gt;state = PROCESS_READY\n     proc-&gt;time_slice = DEFAULT_TIME_SLICE\n  \n  3. Allocate kernel stack\n     stack_frame = alloc_frame()\n     IF stack_frame == NULL:\n       RETURN NULL\n     proc-&gt;kernel_stack = (uint32_t)stack_frame + KERNEL_STACK_SIZE\n  \n  4. Set up initial register state\n     proc-&gt;eip = (uint32_t)entry\n     proc-&gt;eflags = 0x202  // IF=1, bit 1 always 1\n     proc-&gt;ebp = proc-&gt;kernel_stack\n     proc-&gt;esp = proc-&gt;kernel_stack  // Will be adjusted for iret frame\n  \n  5. Set up segments based on mode\n     IF is_user:\n       // User mode (ring 3)\n       proc-&gt;cs = 0x1B   // User code selector (GDT index 3, RPL=3)\n       proc-&gt;ds = 0x23   // User data selector (GDT index 4, RPL=3)\n       proc-&gt;es = 0x23\n       proc-&gt;fs = 0x23\n       proc-&gt;gs = 0x23\n       proc-&gt;ss = 0x23\n       \n       // Create user page directory (clone kernel mappings)\n       proc-&gt;page_directory = clone_page_directory(current_page_directory)\n       IF proc-&gt;page_directory == NULL:\n         free_frame(stack_frame)\n         RETURN NULL\n       \n       // Allocate user stack\n       user_stack_virt = USER_STACK_TOP - USER_STACK_SIZE\n       FOR page = user_stack_virt TO USER_STACK_TOP STEP 4096:\n         phys = alloc_frame()\n         IF phys == NULL:\n           // Cleanup and fail\n           RETURN NULL\n         map_page(proc-&gt;page_directory, page, phys, \n                  PTE_PRESENT | PTE_WRITABLE | PTE_USER)\n       \n       proc-&gt;user_stack_top = USER_STACK_TOP\n       proc-&gt;esp = USER_STACK_TOP  // User stack top\n     ELSE:\n       // Kernel mode (ring 0)\n       proc-&gt;cs = 0x08   // Kernel code selector\n       proc-&gt;ds = 0x10   // Kernel data selector\n       proc-&gt;es = 0x10\n       proc-&gt;fs = 0x10\n       proc-&gt;gs = 0x10\n       proc-&gt;ss = 0x10\n       proc-&gt;page_directory = current_page_directory\n       proc-&gt;user_stack_top = 0\n  \n  6. Add to ready queue\n     proc-&gt;next = ready_queue\n     proc-&gt;prev = NULL\n     IF ready_queue != NULL:\n       ready_queue-&gt;prev = proc\n     ready_queue = proc\n  \n  7. RETURN proc</code></pre></div>\n\n<h3 id=\"context-switch-assembly\">Context Switch (Assembly)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; kernel/process/context.asm\n; void context_switch(process_t *old, process_t *new)\n; Arguments: [esp+4] = old, [esp+8] = new\n\nglobal context_switch\nextern current_process\nextern current_page_directory\nextern tss\n\nsection .text\n\n; PCB offsets - MUST match process.h\n%define PCB_PID          0\n%define PCB_EAX          32\n%define PCB_EBX          36\n%define PCB_ECX          40\n%define PCB_EDX          44\n%define PCB_ESI          48\n%define PCB_EDI          52\n%define PCB_EBP          56\n%define PCB_ESP          60\n%define PCB_EIP          64\n%define PCB_EFLAGS       68\n%define PCB_CS           72\n%define PCB_DS           76\n%define PCB_ES           80\n%define PCB_FS           84\n%define PCB_GS           88\n%define PCB_SS           92\n%define PCB_PAGE_DIR     96\n%define PCB_KERNEL_STACK 100\n\ncontext_switch:\n    ; Prologue\n    push ebp\n    mov ebp, esp\n    pushf                      ; Save EFLAGS\n    push ebx                   ; Save callee-saved registers\n    push esi\n    push edi\n    \n    ; Get arguments\n    mov ecx, [ebp + 8]         ; ecx = old process\n    mov edx, [ebp + 12]        ; edx = new process\n    \n    ; === SAVE OLD PROCESS STATE ===\n    test ecx, ecx\n    jz .skip_save              ; Skip if old is NULL (first switch)\n    \n    ; Save return address as new EIP\n    mov eax, [ebp + 4]         ; Return address\n    mov [ecx + PCB_EIP], eax\n    \n    ; Save stack pointer\n    lea eax, [ebp + 20]        ; ESP before we pushed anything\n    mov [ecx + PCB_ESP], eax\n    \n    ; Save callee-saved registers we pushed\n    mov [ecx + PCB_EBX], ebx\n    mov [ecx + PCB_ESI], esi\n    mov [ecx + PCB_EDI], edi\n    mov [ecx + PCB_EBP], ebp\n    \n    ; Save EFLAGS\n    mov eax, [ebp - 4]         ; Pushed EFLAGS\n    mov [ecx + PCB_EFLAGS], eax\n    \n    ; Save segment registers\n    mov eax, ds\n    mov [ecx + PCB_DS], eax\n    mov eax, es\n    mov [ecx + PCB_ES], eax\n    mov eax, fs\n    mov [ecx + PCB_FS], eax\n    mov eax, gs\n    mov [ecx + PCB_GS], eax\n    mov eax, ss\n    mov [ecx + PCB_SS], eax\n    \n    ; Save caller-saved registers (these were in eax/edx/ecx)\n    ; We'll restore them from the PCB later if needed\n    ; For now, we don't save eax/edx/ecx as they're caller-saved\n    \n.skip_save:\n    ; === LOAD NEW PROCESS STATE ===\n    \n    ; Update current_process\n    mov [current_process], edx\n    \n    ; Switch page directory if different\n    mov eax, [current_page_directory]\n    cmp eax, [edx + PCB_PAGE_DIR]\n    je .same_page_dir\n    \n    ; Load new CR3\n    mov eax, [edx + PCB_PAGE_DIR]\n    mov cr3, eax\n    mov [current_page_directory], eax\n    \n.same_page_dir:\n    ; Update TSS.ESP0 for user processes\n    ; Check if CS indicates user mode (0x1B)\n    cmp word [edx + PCB_CS], 0x1B\n    jne .kernel_process\n    \n    ; User process - update TSS.ESP0\n    mov eax, [edx + PCB_KERNEL_STACK]\n    mov [tss + 4], eax         ; tss.esp0 offset is 4\n    \n.kernel_process:\n    ; Restore segment registers\n    mov ds, [edx + PCB_DS]\n    mov es, [edx + PCB_ES]\n    mov fs, [edx + PCB_FS]\n    mov gs, [edx + PCB_GS]\n    \n    ; Restore general registers\n    mov ebx, [edx + PCB_EBX]\n    mov esi, [edx + PCB_ESI]\n    mov edi, [edx + PCB_EDI]\n    mov ebp, [edx + PCB_EBP]\n    \n    ; Restore stack pointer\n    mov esp, [edx + PCB_ESP]\n    \n    ; Restore EFLAGS\n    push dword [edx + PCB_EFLAGS]\n    popf\n    \n    ; Restore ESI last (we used it earlier, but now we restore from PCB)\n    ; Actually, we already restored ESI above\n    \n    ; Return to new process\n    mov eax, [edx + PCB_EIP]\n    jmp eax                    ; Jump to new process's EIP</code></pre></div>\n\n<h3 id=\"tss-initialization\">TSS Initialization</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>TSS_INIT():\n  1. Zero TSS structure\n     memset(&amp;tss, 0, sizeof(tss_t))\n  \n  2. Set critical fields\n     tss.ss0 = 0x10            // Kernel data selector\n     tss.esp0 = 0x90000        // Initial kernel stack (updated on switch)\n     tss.iomap_base = sizeof(tss_t)  // No I/O bitmap\n  \n  3. Add TSS descriptor to GDT\n     base = (uint32_t)&amp;tss\n     limit = sizeof(tss_t) - 1\n     \n     // TSS descriptor (system segment, type=0x9 for 32-bit TSS available)\n     // Byte 5 (access): 0x89 = Present(1) DPL=0(00) S=0(0) Type=01001(9)\n     // Byte 6 (flags): Granularity=0, 32-bit=1, Limit[19:16]=0\n     \n     gdt_set_gate(5, base, limit, 0x89, 0x00)\n  \n  4. Load Task Register\n     asm volatile(&quot;ltr %w0&quot; : : &quot;r&quot;(TSS_SELECTOR))</code></pre></div>\n\n<h3 id=\"round-robin-scheduler\">Round-Robin Scheduler</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>SCHEDULER_TICK():\n  1. Increment tick counter\n     scheduler_ticks++\n  \n  2. Check if scheduler enabled\n     IF !scheduler_enabled:\n       RETURN\n  \n  3. Decrement current process time slice\n     IF current_process != NULL:\n       current_process-&gt;time_slice--\n       \n       IF current_process-&gt;time_slice == 0:\n         // Time slice expired\n         current_process-&gt;time_slice = DEFAULT_TIME_SLICE\n         current_process-&gt;state = PROCESS_READY\n         \n         // Move to end of queue\n         scheduler_remove_from_queue(current_process)\n         scheduler_add_to_queue(current_process)\n         \n         // Trigger context switch\n         SCHEDULE()\n  \n  4. Check for yielded processes\n     IF current_process-&gt;state == PROCESS_READY AND current_process != ready_queue:\n       SCHEDULE()\n\nSCHEDULE():\n  1. Find next runnable process\n     next = ready_queue\n     WHILE next != NULL:\n       IF next-&gt;state == PROCESS_READY:\n         BREAK\n       next = next-&gt;next\n     \n     IF next == NULL:\n       // No runnable process - keep running current\n       RETURN\n  \n  2. Check if same process\n     IF next == current_process:\n       RETURN\n  \n  3. Update process states\n     old = current_process\n     IF old-&gt;state == PROCESS_RUNNING:\n       old-&gt;state = PROCESS_READY\n     \n     next-&gt;state = PROCESS_RUNNING\n  \n  4. Update current_process\n     current_process = next\n  \n  5. Remove from front of queue\n     scheduler_remove_from_queue(next)\n     scheduler_add_to_queue(next)  // Add to end (round-robin)\n  \n  6. Perform context switch\n     context_switch(old, next)\n\nSCHEDULER_ADD_TO_QUEUE(proc):\n  IF ready_queue == NULL:\n    ready_queue = proc\n    proc-&gt;prev = NULL\n    proc-&gt;next = NULL\n  ELSE:\n    // Find end of queue\n    last = ready_queue\n    WHILE last-&gt;next != NULL:\n      last = last-&gt;next\n    \n    last-&gt;next = proc\n    proc-&gt;prev = last\n    proc-&gt;next = NULL\n\nSCHEDULER_REMOVE_FROM_QUEUE(proc):\n  IF proc-&gt;prev != NULL:\n    proc-&gt;prev-&gt;next = proc-&gt;next\n  ELSE:\n    ready_queue = proc-&gt;next\n  \n  IF proc-&gt;next != NULL:\n    proc-&gt;next-&gt;prev = proc-&gt;prev\n  \n  proc-&gt;prev = NULL\n  proc-&gt;next = NULL</code></pre></div>\n\n<h3 id=\"system-call-dispatch\">System Call Dispatch</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>SYSCALL_HANDLER(regs):\n  1. Extract syscall number\n     syscall_num = regs-&gt;eax\n     \n  2. Validate syscall number\n     IF syscall_num &lt; 0 OR syscall_num &gt;= MAX_SYSCALL:\n       regs-&gt;eax = -1  // Return error\n       RETURN\n  \n  3. Get handler\n     handler = syscall_table[syscall_num]\n     IF handler == NULL:\n       regs-&gt;eax = -1\n       RETURN\n  \n  4. Call handler with arguments\n     // Arguments are in EBX, ECX, EDX\n     result = handler(regs-&gt;ebx, regs-&gt;ecx, regs-&gt;edx)\n     \n  5. Store result\n     regs-&gt;eax = result\n\nSYS_WRITE(fd, buf, count):\n  1. Validate file descriptor\n     IF fd &lt; 0 OR fd &gt; 2:  // Only stdout(1) and stderr(2) supported\n       RETURN -1\n  \n  2. Validate buffer pointer\n     IF buf == NULL:\n       RETURN -1\n     \n     // Check buffer is in user space (below kernel base)\n     IF (uint32_t)buf &gt;= KERNEL_VIRTUAL_BASE:\n       RETURN -1  // EFAULT\n     \n     // Verify buffer is mapped (simplified check)\n     phys = get_physical(current_process-&gt;page_directory, (uint32_t)buf)\n     IF phys == 0:\n       RETURN -1  // Invalid pointer\n  \n  3. Write to VGA/serial\n     FOR i = 0 TO count - 1:\n       vga_putchar(buf[i])\n     \n     RETURN count\n\nSYS_EXIT(status):\n  1. Get current process\n     proc = current_process\n  \n  2. Mark as zombie\n     proc-&gt;state = PROCESS_ZOMBIE\n     proc-&gt;exit_status = status\n  \n  3. Free resources (simplified)\n     IF proc-&gt;page_directory != current_page_directory:\n       // User process - free user memory\n       // (Full implementation would walk page tables)\n  \n  4. Remove from run queue\n     scheduler_remove_from_queue(proc)\n  \n  5. Trigger scheduler (never returns)\n     scheduler_yield()\n     // Never reaches here\n\nSYS_GETPID():\n  RETURN current_process-&gt;pid\n\nSYS_YIELD():\n  current_process-&gt;state = PROCESS_READY\n  scheduler_yield()\n  // Returns when scheduled again</code></pre></div>\n\n<h3 id=\"enter-user-mode\">Enter User Mode</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">asm</span><pre class=\"arch-pre shiki-highlighted\"><code>; kernel/user/user_mode.asm\n; void enter_user_mode(uint32_t entry, uint32_t stack)\n\nglobal enter_user_mode\n\nsection .text\n\nenter_user_mode:\n    ; Get arguments\n    mov eax, [esp + 4]    ; entry point\n    mov ebx, [esp + 8]    ; user stack top\n    \n    ; Disable interrupts during transition\n    cli\n    \n    ; Load user data segment selectors\n    mov cx, 0x23          ; User data selector (index 4, RPL=3)\n    mov ds, cx\n    mov es, cx\n    mov fs, cx\n    mov gs, cx\n    \n    ; Set up user stack for iret\n    ; Push in reverse order: SS, ESP, EFLAGS, CS, EIP\n    \n    ; Set up stack frame for iret\n    push 0x23             ; SS (user data selector with RPL=3)\n    push ebx              ; ESP (user stack top)\n    pushf                 ; EFLAGS\n    or dword [esp], 0x200 ; Set IF (enable interrupts)\n    push 0x1B             ; CS (user code selector with RPL=3)\n    push eax              ; EIP (entry point)\n    \n    ; iret pops: EIP, CS, EFLAGS, ESP, SS\n    ; This transitions to ring 3\n    iret</code></pre></div>\n\n<hr>\n<h2 id=\"error-handling-matrix\">Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th>Error</th>\n<th>Detected By</th>\n<th>Recovery</th>\n<th>User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Process table full</td>\n<td><code>process_create</code> scans all slots</td>\n<td>Return NULL</td>\n<td>Depends on caller</td>\n</tr>\n<tr>\n<td>Kernel stack allocation failure</td>\n<td><code>alloc_frame</code> returns NULL</td>\n<td>Clean up, return NULL</td>\n<td>No</td>\n</tr>\n<tr>\n<td>User stack allocation failure</td>\n<td><code>alloc_frame</code> returns NULL in loop</td>\n<td>Free allocated frames, return NULL</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Page directory clone failure</td>\n<td><code>clone_page_directory</code> returns NULL</td>\n<td>Free stacks, return NULL</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Context switch register corruption</td>\n<td>Wrong PCB offsets</td>\n<td>Debug with GDB; check assembly matches C</td>\n<td>Yes (crash)</td>\n</tr>\n<tr>\n<td>TSS.ESP0 not updated</td>\n<td>User process traps to kernel</td>\n<td>Systematic: update before every switch</td>\n<td>Yes (triple fault)</td>\n</tr>\n<tr>\n<td>Invalid syscall number</td>\n<td>Bounds check in handler</td>\n<td>Return -1 (EINVAL)</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Invalid user pointer</td>\n<td>Check address range and mapping</td>\n<td>Return -1 (EFAULT)</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Double-free in scheduler</td>\n<td>Process already removed</td>\n<td>Debug assertion in remove_from_queue</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Zombie process remains</td>\n<td>exit doesn&#39;t clean up</td>\n<td>Parent must reap (future: waitpid)</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Infinite loop in ready queue</td>\n<td>All processes blocked</td>\n<td>Idle process always runnable</td>\n<td>No (hangs)</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"state-machine-process-lifecycle\">State Machine: Process Lifecycle</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Process State Transitions:\n\n                    ┌─────────────────────────────────────┐\n                    │            PROCESS_UNUSED           │\n                    │         (initial state)             │\n                    └──────────────────┬──────────────────┘\n                                       │ process_create()\n                                       ▼\n                    ┌─────────────────────────────────────┐\n        ┌──────────▶│            PROCESS_READY            │◀──────────┐\n        │           │    (runnable, waiting for CPU)      │           │\n        │           └──────────────────┬──────────────────┘           │\n        │                              │ scheduler_pick_next()        │\n        │                              ▼                               │\n        │           ┌─────────────────────────────────────┐           │\n        │           │           PROCESS_RUNNING           │           │\n        │           │       (currently executing)         │           │\n        │           └──────────────────┬──────────────────┘           │\n        │                              │                               │\n        │         ┌────────────────────┼────────────────────┐         │\n        │         │                    │                    │         │\n        │         │ timer/scheduler    │ block()           │ exit()  │\n        │         │ yield()            │ sleep()           │         │\n        │         ▼                    ▼                    ▼         │\n        │  (back to READY)    ┌───────────────┐    ┌──────────────┐  │\n        │                     │PROCESS_BLOCKED│    │PROCESS_ZOMBIE│  │\n        └─────────────────────│ (waiting for  │    │  (terminated)│  │\n                              │   event)      │    └──────────────┘  │\n                              └───────┬───────┘                      │\n                                      │ wake() / event               │\n                                      └──────────────────────────────┘\n                                          (back to READY)\n\nVALID Transitions:\n  UNUSED → READY     : process_create()\n  READY → RUNNING    : scheduler dispatch\n  RUNNING → READY    : time slice expired, yield\n  RUNNING → BLOCKED  : wait for I/O, sleep\n  RUNNING → ZOMBIE   : exit()\n  BLOCKED → READY    : I/O complete, sleep expired\n\nINVALID Transitions:\n  UNUSED → RUNNING   : Must go through READY first\n  READY → ZOMBIE     : Must be RUNNING to exit\n  BLOCKED → RUNNING  : Must go through READY\n  ZOMBIE → *         : Terminal state</code></pre></div>\n\n<hr>\n<h2 id=\"concurrency-specification\">Concurrency Specification</h2>\n<h3 id=\"preemptive-multitasking-model\">Preemptive Multitasking Model</h3>\n<p>Only ONE process executes at any instant. Concurrency is simulated through rapid context switching triggered by:</p>\n<ol>\n<li>Timer interrupt (preemptive)</li>\n<li>Voluntary yield (cooperative)</li>\n<li>Blocking I/O (implicit yield)</li>\n</ol>\n<h3 id=\"critical-sections\">Critical Sections</h3>\n<p>Interrupts must be disabled during:</p>\n<ul>\n<li>Process table modification</li>\n<li>Run queue manipulation  </li>\n<li>Context switch (partial - can re-enable after CR3 load)</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Safe queue manipulation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scheduler_remove_from_queue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">proc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> flags;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Disable interrupts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">pushf; pop %0; cli</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(flags));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... manipulate queue ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Restore interrupts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">push %0; popf</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(flags));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"interrupt-safety-in-handlers\">Interrupt Safety in Handlers</h3>\n<ul>\n<li>ISR handlers run with interrupts disabled (interrupt gate)</li>\n<li>Timer handler calls <code>scheduler_tick()</code> which may switch contexts</li>\n<li>After context switch, interrupts are restored from saved EFLAGS</li>\n<li>Syscall handler runs with interrupts enabled (trap gate)</li>\n</ul>\n<h3 id=\"per-process-data-protection\">Per-Process Data Protection</h3>\n<p>Each process has:</p>\n<ul>\n<li>Independent kernel stack (no shared stack data)</li>\n<li>Independent page directory (no shared user memory)</li>\n<li>Shared kernel memory (read-only from user mode)</li>\n</ul>\n<h3 id=\"lock-free-queue-access\">Lock-Free Queue Access</h3>\n<p>The ready queue is accessed only:</p>\n<ol>\n<li>From timer interrupt (interrupt context)</li>\n<li>From syscall context (process context, but interrupts may be disabled)</li>\n</ol>\n<p>Single-CPU design means no true concurrent access if interrupts are disabled.</p>\n<hr>\n<h2 id=\"implementation-sequence-with-checkpoints\">Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-pcb-structure-definition-2-3-hours\">Phase 1: PCB Structure Definition (2-3 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/process/process.h</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Define process_state_t enumeration</li>\n<li>Define process_t structure with exact byte offsets</li>\n<li>Add comments documenting PCB layout</li>\n<li>Define MAX_PROCESSES, stack sizes, etc.</li>\n<li>Declare global variables (process_table, current_process, etc.)</li>\n</ol>\n<p><strong>Checkpoint</strong>: PCB structure compiles</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Test: verify offsets</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">_Static_assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">offsetof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">, eax) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"EAX offset wrong\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">_Static_assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">offsetof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">, eip) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"EIP offset wrong\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">_Static_assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">offsetof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">, page_directory) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 96</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"PD offset wrong\"</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Test</strong>: Compile and check struct size matches expected</p>\n<h3 id=\"phase-2-process-creation-kernel-mode-3-4-hours\">Phase 2: Process Creation (Kernel Mode) (3-4 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/process/process.c</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Implement <code>process_table</code> array initialization</li>\n<li>Implement <code>process_create()</code> for kernel processes</li>\n<li>Allocate kernel stack from frame allocator</li>\n<li>Set up initial register state for kernel mode</li>\n<li>Add to ready queue</li>\n</ol>\n<p><strong>Checkpoint</strong>: Can create kernel process</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_process</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Test process running!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#F97583\">asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">hlt</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">); }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// In kernel_main:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"test\"</span><span style=\"color:#E1E4E8\">, test_process, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ASSERT</span><span style=\"color:#E1E4E8\">(proc </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Failed to create process\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Process created: \"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#B392F0\">vga_put_dec</span><span style=\"color:#E1E4E8\">(proc</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">pid</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Test</strong>: Create process, verify PCB fields set correctly</p>\n<h3 id=\"phase-3-context-switch-assembly-5-7-hours\">Phase 3: Context Switch Assembly (5-7 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/process/context.asm</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Define PCB offsets to match C structure</li>\n<li>Implement save path (save all registers to old PCB)</li>\n<li>Implement CR3 switch logic</li>\n<li>Implement TSS.ESP0 update logic</li>\n<li>Implement restore path (load all registers from new PCB)</li>\n<li>Handle NULL old process (first switch)</li>\n</ol>\n<p><strong>Checkpoint</strong>: Context switch doesn&#39;t crash</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Test: switch to same process</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#FFAB70\">process_table</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">context_switch</span><span style=\"color:#E1E4E8\">(proc, proc);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Context switch returned!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Should print this</span></span></code></pre></div>\n\n<p><strong>Test</strong>: Create two processes, switch between them manually</p>\n<h3 id=\"phase-4-tss-initialization-3-4-hours\">Phase 4: TSS Initialization (3-4 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/process/tss.h</code>, <code>kernel/process/tss.c</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Define tss_t structure matching hardware format</li>\n<li>Implement <code>tss_init()</code> to zero and configure TSS</li>\n<li>Add TSS descriptor to GDT (modify boot/gdt.asm or create function)</li>\n<li>Load TR with <code>ltr</code> instruction</li>\n<li>Implement <code>tss_set_esp0()</code> helper</li>\n</ol>\n<p><strong>Checkpoint</strong>: TSS loads without fault</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">tss_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"TSS initialized</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"TSS.ESP0 = 0x\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#B392F0\">vga_put_hex</span><span style=\"color:#E1E4E8\">(tss.esp0); </span><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Read TR to verify</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#E1E4E8\"> tr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">str %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(tr));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"TR = 0x\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#B392F0\">vga_put_hex</span><span style=\"color:#E1E4E8\">(tr); </span><span style=\"color:#B392F0\">vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\" (expected 0x28)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Test</strong>: Verify TR = 0x28, TSS.ESP0 set correctly</p>\n<h3 id=\"phase-5-round-robin-scheduler-4-5-hours\">Phase 5: Round-Robin Scheduler (4-5 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/process/scheduler.h</code>, <code>kernel/process/scheduler.c</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Implement <code>scheduler_init()</code> to create idle process</li>\n<li>Implement <code>scheduler_add_to_queue()</code></li>\n<li>Implement <code>scheduler_remove_from_queue()</code></li>\n<li>Implement <code>scheduler_pick_next()</code></li>\n<li>Implement <code>scheduler_yield()</code> that calls context switch</li>\n<li>Implement <code>schedule()</code> internal function</li>\n</ol>\n<p><strong>Checkpoint</strong>: Manual scheduling works</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">scheduler_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create test processes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"proc_a\"</span><span style=\"color:#E1E4E8\">, test_process_a, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"proc_b\"</span><span style=\"color:#E1E4E8\">, test_process_b, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Manually yield</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">scheduler_yield</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Should switch to first process</span></span></code></pre></div>\n\n<p><strong>Test</strong>: Create 3 processes, manually call scheduler_yield(), verify round-robin order</p>\n<h3 id=\"phase-6-timer-interrupt-integration-2-3-hours\">Phase 6: Timer Interrupt Integration (2-3 hours)</h3>\n<p><strong>Files</strong>: Modify <code>kernel/timer.c</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Add call to <code>scheduler_tick()</code> in timer handler</li>\n<li>Enable scheduler after timer configured</li>\n<li>Unmask IRQ0 (timer)</li>\n<li>Ensure interrupts enabled</li>\n</ol>\n<p><strong>Checkpoint</strong>: Preemptive multitasking works</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// After timer_init():</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">timer_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 100Hz</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Enable scheduler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">scheduler_enabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create processes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"proc_a\"</span><span style=\"color:#E1E4E8\">, test_process_a, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"proc_b\"</span><span style=\"color:#E1E4E8\">, test_process_b, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"proc_c\"</span><span style=\"color:#E1E4E8\">, test_process_c, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Enable interrupts and yield</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">sti</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">scheduler_yield</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Scheduler takes over - processes print in round-robin</span></span></code></pre></div>\n\n<p><strong>Test</strong>: Three kernel processes print to different screen locations, counters increment independently</p>\n<h3 id=\"phase-7-multi-process-kernel-demo-2-3-hours\">Phase 7: Multi-Process Kernel Demo (2-3 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/main.c</code> or new demo file</p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Create three kernel processes with different entry functions</li>\n<li>Each process prints to different VGA location</li>\n<li>Each has a counter that increments</li>\n<li>Verify counters update independently</li>\n</ol>\n<p><strong>Checkpoint</strong>: Visual demo of preemptive multitasking</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> process_a</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_set_cursor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[A] Count: \"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#B392F0\">vga_put_dec</span><span style=\"color:#E1E4E8\">(count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 500000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Delay</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Similar for process_b and process_c</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Expected: Three counters incrementing simultaneously on screen</span></span></code></pre></div>\n\n<p><strong>Test</strong>: Run for 10 seconds, verify all three counters increased</p>\n<h3 id=\"phase-8-user-mode-process-creation-4-5-hours\">Phase 8: User-Mode Process Creation (4-5 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/process/process.c</code> (modify), <code>kernel/memory/paging.c</code> (add clone function)</p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Implement <code>clone_page_directory()</code> to copy kernel mappings</li>\n<li>Allocate user stack in user virtual address space</li>\n<li>Map user stack pages with PTE_USER flag</li>\n<li>Set user segment selectors (CS=0x1B, DS=0x23)</li>\n<li>Copy user code to user address space (simplified: just mark pages)</li>\n</ol>\n<p><strong>Checkpoint</strong>: User process PCB created</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> user_test_function</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Simple test function</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">user_proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"user_test\"</span><span style=\"color:#E1E4E8\">, user_test_function, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ASSERT</span><span style=\"color:#E1E4E8\">(user_proc </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Failed to create user process\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ASSERT</span><span style=\"color:#E1E4E8\">(user_proc</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">cs </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">1B</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Wrong CS for user process\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ASSERT</span><span style=\"color:#E1E4E8\">(user_proc</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">page_directory </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> current_page_directory, </span><span style=\"color:#9ECBFF\">\"User should have own PD\"</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Test</strong>: Create user process, verify CS=0x1B, own page directory, user stack allocated</p>\n<h3 id=\"phase-9-enter-user-mode-via-iret-2-3-hours\">Phase 9: Enter User Mode via iret (2-3 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/user/user_mode.asm</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Implement <code>enter_user_mode()</code> assembly function</li>\n<li>Load segment registers with user selectors</li>\n<li>Build iret frame on stack</li>\n<li>Execute iret to transition to ring 3</li>\n<li>Verify CPL=3 after transition</li>\n</ol>\n<p><strong>Checkpoint</strong>: Successfully enter user mode</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// After creating user process:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> enter_user_process</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"user\"</span><span style=\"color:#E1E4E8\">, user_entry, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Enter user mode</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    enter_user_mode</span><span style=\"color:#E1E4E8\">(proc->eip, proc->esp);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Never reaches here</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// In user mode code:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> user_entry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This runs at ring 3!</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Attempt to write to VGA directly - should fault</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // char *vga = (char*)0xB8000;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // *vga = 'X';  // Page fault if VGA not mapped user-accessible</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use syscall instead</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sys_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Hello from user mode!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">23</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sys_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Test</strong>: User process prints message via syscall, then exits cleanly</p>\n<h3 id=\"phase-10-system-call-interface-4-5-hours\">Phase 10: System Call Interface (4-5 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/syscall/syscall.h</code>, <code>kernel/syscall/syscall.c</code>, <code>kernel/syscall/syscall.asm</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Define syscall numbers and handler table</li>\n<li>Create ISR stub for INT 0x80</li>\n<li>Register IDT gate with DPL=3 (user callable)</li>\n<li>Implement syscall dispatcher</li>\n<li>Implement syscall parameter extraction from registers</li>\n</ol>\n<p><strong>Checkpoint</strong>: Syscall from kernel mode works</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Test syscall from kernel (ring 0)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> sys_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Test</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">vga_put_dec</span><span style=\"color:#E1E4E8\">(result);</span><span style=\"color:#6A737D\">  // Should print 5</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Register syscall handler</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">idt_set_gate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">isr128</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">EE</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // DPL=3</span></span></code></pre></div>\n\n<p><strong>Test</strong>: Call INT 0x80 from kernel, verify handler runs and returns</p>\n<h3 id=\"phase-11-sys_write-and-sys_exit-2-3-hours\">Phase 11: sys_write and sys_exit (2-3 hours)</h3>\n<p><strong>Files</strong>: <code>kernel/syscall/syscall.c</code></p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Implement <code>sys_write()</code> with pointer validation</li>\n<li>Implement <code>sys_exit()</code> to terminate process</li>\n<li>Implement <code>sys_getpid()</code> as trivial syscall</li>\n<li>Add user-space wrapper functions (optional)</li>\n</ol>\n<p><strong>Checkpoint</strong>: User process uses syscalls</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// User mode code</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> _start</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">msg </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"Hello from user mode!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"</span><span style=\"color:#9ECBFF\">int $0x80</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">a</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(SYS_WRITE), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">b</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">c</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(msg), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">23</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    );</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"</span><span style=\"color:#9ECBFF\">int $0x80</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">a</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(SYS_EXIT), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">b</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    );</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Expected: \"Hello from user mode!\" printed, process exits</span></span></code></pre></div>\n\n<p><strong>Test</strong>: User process prints message and exits without crashing</p>\n<h3 id=\"final-integration-3-4-hours\">Final Integration (3-4 hours)</h3>\n<p><strong>Goal</strong>: Complete preemptive multitasking with user-mode processes and syscalls</p>\n<p><strong>Steps</strong>:</p>\n<ol>\n<li>Integrate all components in <code>kernel_main()</code></li>\n<li>Initialize in correct order:<ul>\n<li>Memory (paging, heap)</li>\n<li>Interrupts (IDT, PIC, timer)</li>\n<li>TSS</li>\n<li>Scheduler</li>\n<li>Syscalls</li>\n</ul>\n</li>\n<li>Create kernel demo processes</li>\n<li>Create user demo process</li>\n<li>Enable interrupts and start scheduler</li>\n</ol>\n<p><strong>Checkpoint</strong>: Full system runs</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> kernel_main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">multiboot_info_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">mbi</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Core initialization</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    serial_init</span><span style=\"color:#E1E4E8\">(COM1_PORT);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Initializing memory...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memory_init</span><span style=\"color:#E1E4E8\">(mbi);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Initializing interrupts...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    idt_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pic_remap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">40</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    timer_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    keyboard_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Initializing TSS...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    tss_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Initializing scheduler...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scheduler_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Initializing syscalls...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    syscall_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Creating processes...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"kernel_a\"</span><span style=\"color:#E1E4E8\">, kernel_process_a, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"kernel_b\"</span><span style=\"color:#E1E4E8\">, kernel_process_b, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"user_test\"</span><span style=\"color:#E1E4E8\">, user_process_entry, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    kprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Starting scheduler...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    scheduler_enabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pic_unmask_irq</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Timer</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pic_unmask_irq</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Keyboard</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">sti</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scheduler_yield</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Never reaches here</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Test Commands</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">make</span><span style=\"color:#9ECBFF\"> clean</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#B392F0\">make</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> -serial</span><span style=\"color:#9ECBFF\"> stdio</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Boot messages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - \"Starting scheduler...\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Three processes running (two kernel, one user)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - User process prints via syscall</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Counters incrementing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - No crashes, hangs, or triple faults</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"test-specification\">Test Specification</h2>\n<h3 id=\"test-1-pcb-structure-layout\">Test 1: PCB Structure Layout</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test_pcb_layout.c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_pcb_layout</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify offsets match assembly expectations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">offsetof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">, pid) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"PID offset\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">offsetof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">, eax) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"EAX offset\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">offsetof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">, eip) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"EIP offset\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">offsetof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">, eflags) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 68</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"EFLAGS offset\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">offsetof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">, cs) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 72</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"CS offset\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">offsetof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">, page_directory) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 96</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"PD offset\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">offsetof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">, kernel_stack) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"KSTACK offset\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify size</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 140</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"PCB size\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PASS: PCB layout</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-2-process-creation\">Test 2: Process Creation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test_process_create.c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> free_before </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> frame_alloc.free_frames;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"test\"</span><span style=\"color:#E1E4E8\">, test_func, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(proc </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Process creation failed\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(proc->pid </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"PID assignment\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(proc->state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PROCESS_READY, </span><span style=\"color:#9ECBFF\">\"Initial state\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(proc->cs </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">08</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Kernel CS\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(proc->kernel_stack </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Kernel stack allocated\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify frame was allocated</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(frame_alloc.free_frames </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> free_before </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Frame used\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify in ready queue</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(ready_queue </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> proc, </span><span style=\"color:#9ECBFF\">\"Added to queue\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PASS: Process creation</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-3-context-switch\">Test 3: Context Switch</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test_context_switch.c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> proc_a_ran </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> proc_b_ran </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> proc_a</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc_a_ran </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scheduler_yield</span><span style=\"color:#E1E4E8\">();</span><span style=\"color:#6A737D\">  // Switch to proc_b</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc_a_ran </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> proc_b</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc_b_ran </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scheduler_yield</span><span style=\"color:#E1E4E8\">();</span><span style=\"color:#6A737D\">  // Switch back to proc_a</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc_b_ran </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_context_switch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">a </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"a\"</span><span style=\"color:#E1E4E8\">, proc_a, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">b </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"b\"</span><span style=\"color:#E1E4E8\">, proc_b, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Disable timer for controlled test</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    scheduler_enabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Manually switch to process a</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> a;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    a->state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PROCESS_RUNNING;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    context_switch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">process_table</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], a);</span><span style=\"color:#6A737D\">  // From kernel to proc_a</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // After both yield, check values</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(proc_a_ran </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Proc A completed\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(proc_b_ran </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Proc B completed\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PASS: Context switch</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-4-tss-configuration\">Test 4: TSS Configuration</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test_tss.c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_tss</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    tss_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify TSS.ESP0 and SS0</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(tss.ss0 </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"TSS.SS0\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(tss.esp0 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"TSS.ESP0 set\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify TR loaded</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> tr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">str %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(tr));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(tr </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">28</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"TR value\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test ESP0 update</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    tss_set_esp0</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">12345678</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(tss.esp0 </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">12345678</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"ESP0 update\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PASS: TSS configuration</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-5-scheduler-round-robin\">Test 5: Scheduler Round-Robin</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test_scheduler.c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#FFAB70\"> order</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> order_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> sched_a</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#FFAB70\">order</span><span style=\"color:#E1E4E8\">[order_idx</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'A'</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">scheduler_yield</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> sched_b</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#FFAB70\">order</span><span style=\"color:#E1E4E8\">[order_idx</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'B'</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">scheduler_yield</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> sched_c</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#FFAB70\">order</span><span style=\"color:#E1E4E8\">[order_idx</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'C'</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">scheduler_yield</span><span style=\"color:#E1E4E8\">(); }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_scheduler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"a\"</span><span style=\"color:#E1E4E8\">, sched_a, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"b\"</span><span style=\"color:#E1E4E8\">, sched_b, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"c\"</span><span style=\"color:#E1E4E8\">, sched_c, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Run for 9 yields (3 full rounds)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 9</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        scheduler_tick</span><span style=\"color:#E1E4E8\">();</span><span style=\"color:#6A737D\">  // Simulate timer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify round-robin order: A, B, C, A, B, C, A, B, C</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">order</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'A'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Order 0\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">order</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'B'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Order 1\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">order</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'C'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Order 2\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">order</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'A'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Order 3\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">order</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'B'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Order 4\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">order</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'C'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Order 5\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PASS: Scheduler round-robin</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-6-user-mode-entry\">Test 6: User Mode Entry</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test_user_mode.c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> user_mode_entered </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> user_entry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check CPL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> cs;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">mov %%cs, %0</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(cs));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // CS should be 0x1B or 0x1F (user code, RPL=3)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    user_mode_entered </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (cs </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#F97583\"> ?</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> :</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sys_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_user_mode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"user\"</span><span style=\"color:#E1E4E8\">, user_entry, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set up TSS.ESP0</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    tss_set_esp0</span><span style=\"color:#E1E4E8\">(proc->kernel_stack);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Enter user mode</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    enter_user_mode</span><span style=\"color:#E1E4E8\">(proc->eip, proc->esp);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should not return, but if it does:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(user_mode_entered </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"User mode entered\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PASS: User mode entry</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-7-syscall-dispatch\">Test 7: Syscall Dispatch</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test_syscall.c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_syscall</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    syscall_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test sys_write from kernel</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> sys_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"test</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(result </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"sys_write return\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test sys_getpid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> sys_getpid</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(pid </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> current_process->pid, </span><span style=\"color:#9ECBFF\">\"sys_getpid\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test invalid syscall</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">int $0x80</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">=a</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(result) : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">a</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">999</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ASSERT</span><span style=\"color:#E1E4E8\">(result </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Invalid syscall\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PASS: Syscall dispatch</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-8-user-process-isolation\">Test 8: User Process Isolation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test_user_isolation.c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> user_try_kernel_access</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Attempt to read kernel memory - should fault</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    volatile</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">kernel_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">C0100000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> val </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">kernel_addr;</span><span style=\"color:#6A737D\">  // Should page fault</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should never reach here</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sys_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"FAIL: accessed kernel</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">22</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sys_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_user_isolation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"isolation_test\"</span><span style=\"color:#E1E4E8\">, user_try_kernel_access, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Run process - expect page fault</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // (This test requires page fault handler to catch and report)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vga_puts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PASS: User isolation (page fault expected)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-9-multi-process-demo\">Test 9: Multi-Process Demo</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># test_multi_process.sh</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">timeout</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#9ECBFF\"> qemu-system-i386</span><span style=\"color:#79B8FF\"> -drive</span><span style=\"color:#9ECBFF\"> format=raw,file=os.img</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    -serial</span><span style=\"color:#9ECBFF\"> stdio</span><span style=\"color:#79B8FF\"> -display</span><span style=\"color:#9ECBFF\"> none</span><span style=\"color:#F97583\"> 2>&#x26;1</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tee</span><span style=\"color:#9ECBFF\"> demo_log.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check that all three processes ran</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -q</span><span style=\"color:#9ECBFF\"> \"Process A\"</span><span style=\"color:#9ECBFF\"> demo_log.txt</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   grep</span><span style=\"color:#79B8FF\"> -q</span><span style=\"color:#9ECBFF\"> \"Process B\"</span><span style=\"color:#9ECBFF\"> demo_log.txt</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   grep</span><span style=\"color:#79B8FF\"> -q</span><span style=\"color:#9ECBFF\"> \"Process C\"</span><span style=\"color:#9ECBFF\"> demo_log.txt</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"PASS: All processes ran\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"FAIL: Not all processes ran\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    exit</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check that processes ran multiple times (preemption working)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">count_a</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">grep</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"Process A\"</span><span style=\"color:#9ECBFF\"> demo_log.txt</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> echo</span><span style=\"color:#9ECBFF\"> \"0\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> [ </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$count_a</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> -gt</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\"> ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"PASS: Preemption working (</span><span style=\"color:#E1E4E8\">$count_a</span><span style=\"color:#9ECBFF\"> iterations of A)\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"FAIL: Preemption not working\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    exit</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-targets\">Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Target</th>\n<th>How to Measure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Context switch (same PD)</td>\n<td>&lt; 500 cycles</td>\n<td>Time from <code>context_switch</code> call to return in new process</td>\n</tr>\n<tr>\n<td>Context switch (different PD)</td>\n<td>&lt; 5000 cycles</td>\n<td>Includes TLB refill cost</td>\n</tr>\n<tr>\n<td>PCB allocation</td>\n<td>&lt; 100 cycles</td>\n<td>Scan process table for free slot</td>\n</tr>\n<tr>\n<td>Kernel stack allocation</td>\n<td>&lt; 500 cycles</td>\n<td>Single frame allocation</td>\n</tr>\n<tr>\n<td>User process creation</td>\n<td>&lt; 10,000 cycles</td>\n<td>Includes PD clone, stack allocation</td>\n</tr>\n<tr>\n<td>Scheduler tick</td>\n<td>&lt; 200 cycles</td>\n<td>Timer handler overhead</td>\n</tr>\n<tr>\n<td>Syscall dispatch</td>\n<td>&lt; 100 cycles</td>\n<td>From <code>int 0x80</code> to handler entry</td>\n</tr>\n<tr>\n<td>sys_write (1 char)</td>\n<td>&lt; 500 cycles</td>\n<td>Argument validation + VGA output</td>\n</tr>\n<tr>\n<td>User-kernel transition</td>\n<td>&lt; 200 cycles</td>\n<td>int 0x80 + return to user</td>\n</tr>\n<tr>\n<td>Timer interrupt overhead</td>\n<td>&lt; 1% of CPU</td>\n<td>100Hz timer, handler ~200 cycles = 0.002%</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"hardware-soul\">Hardware Soul</h2>\n<h3 id=\"cache-lines-touched\">Cache Lines Touched</h3>\n<p><strong>Context switch</strong>:</p>\n<ul>\n<li>PCB read: 140 bytes = 3 cache lines (all registers + metadata)</li>\n<li>PCB write: Same 3 cache lines</li>\n<li>Page directory access: 1 cache line for CR3 read</li>\n<li>TSS update: 4 bytes (ESP0) - likely in same cache line as other TSS fields</li>\n<li>Total: ~5-7 cache line touches per switch</li>\n</ul>\n<p><strong>Scheduler</strong>:</p>\n<ul>\n<li>Run queue traversal: 2 pointers per process checked</li>\n<li>If 10 processes in queue: ~20 pointer reads, 1-2 cache lines</li>\n</ul>\n<p><strong>Syscall</strong>:</p>\n<ul>\n<li>IDT entry read: 8 bytes, 1 cache line shared with nearby entries</li>\n<li>Syscall table lookup: 1 pointer read</li>\n<li>Handler code: Variable (should stay in cache for common syscalls)</li>\n</ul>\n<h3 id=\"branch-prediction\">Branch Prediction</h3>\n<p><strong>Round-robin scheduler</strong>: Highly predictable - always picks next in queue. Branch predictor learns pattern quickly.</p>\n<p><strong>Syscall dispatch</strong>: Table lookup - no branching. Unpredictable only if syscall numbers random (unlikely).</p>\n<p><strong>Context switch</strong>: No branches in core switch path (just comparisons for CR3, TSS update).</p>\n<h3 id=\"tlb-behavior\">TLB Behavior</h3>\n<p><strong>CR3 reload flushes TLB</strong>:</p>\n<ul>\n<li>64-128 entries lost</li>\n<li>Each miss = 2-4 memory accesses (PD walk + PT walk)</li>\n<li>Kernel code hot path: ~10 TLB entries for common functions</li>\n<li>Recovery time: 100-500 cycles depending on working set</li>\n</ul>\n<p><strong>User-kernel transitions</strong>:</p>\n<ul>\n<li>Kernel pages marked global (PTE_GLOBAL) to survive CR3 reload</li>\n<li>Or kernel mapped in all page directories (this implementation)</li>\n<li>No TLB flush for kernel-only switches if PCID used (not in this impl)</li>\n</ul>\n<h3 id=\"pipeline-impact\">Pipeline Impact</h3>\n<p><strong>iret for user mode entry</strong>:</p>\n<ul>\n<li>Serializing instruction - full pipeline flush</li>\n<li>Cost: 20-50 cycles</li>\n<li>Required for privilege level change</li>\n</ul>\n<p><strong>int 0x80 for syscalls</strong>:</p>\n<ul>\n<li>Interrupt gate entry flushes pipeline</li>\n<li>Similar cost to iret</li>\n<li>Could optimize with sysenter/sysexit (not implemented)</li>\n</ul>\n<h3 id=\"cache-pollution\">Cache Pollution</h3>\n<p><strong>Process working set</strong>:</p>\n<ul>\n<li>Each process has own working set</li>\n<li>Context switch evicts previous process&#39;s cache lines</li>\n<li>L1D typically 32KB: holds ~800 cache lines</li>\n<li>If process accesses more than 800 lines, thrashing occurs</li>\n</ul>\n<hr>\n<h2 id=\"visual-diagrams\">Visual Diagrams</h2>\n<h3 id=\"pcb-structure\">PCB Structure</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Process Control Block (140 bytes):\n\n┌─────────────────────────────────────────────────────────────────────┐\n│ Offset 0: Identification                                            │\n├─────────────────────────────────────────────────────────────────────┤\n│  +0   │ pid (4)        │ Process ID                                 │\n│  +4   │ name[16]       │ Process name (null-terminated)            │\n│  +20  │ state (4)      │ READY/RUNNING/BLOCKED/ZOMBIE              │\n│  +24  │ padding (8)    │ Reserved for alignment                    │\n└─────────────────────────────────────────────────────────────────────┘\n┌─────────────────────────────────────────────────────────────────────┐\n│ Offset 32: Register State (SAVED/RESTORED BY CONTEXT SWITCH)        │\n├─────────────────────────────────────────────────────────────────────┤\n│  +32  │ eax            │ General purpose                           │\n│  +36  │ ebx            │                                           │\n│  +40  │ ecx            │                                           │\n│  +44  │ edx            │                                           │\n│  +48  │ esi            │ Source index                              │\n│  +52  │ edi            │ Destination index                         │\n│  +56  │ ebp            │ Base pointer                              │\n│  +60  │ esp            │ Stack pointer                             │\n│  +64  │ eip            │ Instruction pointer                       │\n│  +68  │ eflags         │ CPU flags                                 │\n│  +72  │ cs             │ Code segment selector                     │\n│  +76  │ ds             │ Data segment selector                     │\n│  +80  │ es             │ Extra segment                             │\n│  +84  │ fs             │ Extra segment                             │\n│  +88  │ gs             │ Extra segment                             │\n│  +92  │ ss             │ Stack segment selector                    │\n└─────────────────────────────────────────────────────────────────────┘\n┌─────────────────────────────────────────────────────────────────────┐\n│ Offset 96: Memory Management                                        │\n├─────────────────────────────────────────────────────────────────────┤\n│  +96  │ page_directory │ Page directory pointer (virtual addr)     │\n│  +100 │ kernel_stack   │ Top of kernel stack (for TSS.ESP0)        │\n│  +104 │ user_stack_top │ User mode stack top                       │\n└─────────────────────────────────────────────────────────────────────┘\n┌─────────────────────────────────────────────────────────────────────┐\n│ Offset 108: Scheduling                                              │\n├─────────────────────────────────────────────────────────────────────┤\n│  +108 │ next           │ Next process in queue                     │\n│  +112 │ prev           │ Previous process in queue                 │\n│  +116 │ wake_time      │ Tick count to wake (for sleep)            │\n│  +120 │ exit_status    │ Exit code                                 │\n│  +124 │ time_slice     │ Remaining quantum                         │\n└─────────────────────────────────────────────────────────────────────┘\n┌─────────────────────────────────────────────────────────────────────┐\n│ Offset 128: Process Tree (Future)                                   │\n├─────────────────────────────────────────────────────────────────────┤\n│  +128 │ parent         │ Parent process                            │\n│  +132 │ first_child    │ First child process                       │\n│  +136 │ next_sibling   │ Next sibling                              │\n└─────────────────────────────────────────────────────────────────────┘\n\nAssembly Offset Verification:\n  %define PCB_EAX     32    ; Must match C offsetof(process_t, eax)\n  %define PCB_EIP     64    ; Must match C offsetof(process_t, eip)\n  %define PCB_CS      72    ; Must match C offsetof(process_t, cs)\n  %define PCB_KSTACK  100   ; Must match C offsetof(process_t, kernel_stack)</code></pre></div>\n\n<h3 id=\"context-switch-flow\">Context Switch Flow</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Context Switch Operation:\n\n┌─────────────────────────────────────────────────────────────────────┐\n│                         BEFORE SWITCH                               │\n│                                                                     │\n│   Process A (running)                                               │\n│   ┌─────────────────┐                                               │\n│   │ EAX = 0x11111111│                                               │\n│   │ EBX = 0x22222222│                                               │\n│   │ EIP = 0x00100234│  ──┐                                          │\n│   │ ESP = 0x00090000│    │                                          │\n│   │ ...             │    │                                          │\n│   └─────────────────┘    │                                          │\n│                          │                                          │\n│   PCB_A (in memory)      │                                          │\n│   ┌─────────────────┐    │                                          │\n│   │ eax = ?         │ ◀──┘  Will be saved here                      │\n│   │ eip = ?         │                                               │\n│   │ ...             │                                               │\n│   └─────────────────┘                                               │\n└─────────────────────────────────────────────────────────────────────┘\n                              │\n                              │ context_switch(PCB_A, PCB_B)\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────────────┐\n│                         DURING SWITCH                               │\n│                                                                     │\n│   1. Save current state to PCB_A                                    │\n│      PCB_A.eax ← EAX (0x11111111)                                  │\n│      PCB_A.ebx ← EBX                                               │\n│      PCB_A.eip ← return_address                                    │\n│      ...                                                            │\n│                                                                     │\n│   2. Update TSS.ESP0 if switching to user process                   │\n│      TSS.ESP0 ← PCB_B.kernel_stack                                 │\n│                                                                     │\n│   3. Switch page directory if different                             │\n│      CR3 ← PCB_B.page_directory                                    │\n│      (TLB flushed automatically)                                    │\n│                                                                     │\n│   4. Update current_process                                         │\n│      current_process ← PCB_B                                       │\n│                                                                     │\n│   5. Load new state from PCB_B                                      │\n│      EAX ← PCB_B.eax                                               │\n│      EBX ← PCB_B.ebx                                               │\n│      EIP ← PCB_B.eip                                               │\n│      ...                                                            │\n└─────────────────────────────────────────────────────────────────────┘\n                              │\n                              │ jmp to PCB_B.eip\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────────────┐\n│                         AFTER SWITCH                                │\n│                                                                     │\n│   Process B (now running)                                           │\n│   ┌─────────────────┐                                               │\n│   │ EAX = 0xAAAAAAAA│  ◀── Loaded from PCB_B                       │\n│   │ EBX = 0xBBBBBBBB│                                               │\n│   │ EIP = 0x00100567│                                               │\n│   │ ESP = 0x000A0000│                                               │\n│   │ ...             │                                               │\n│   └─────────────────┘                                               │\n│                                                                     │\n│   Process A (suspended)                                             │\n│   ┌─────────────────┐                                               │\n│   │ State saved in  │                                               │\n│   │ PCB_A           │  ──▶ Will resume when scheduled again        │\n│   └─────────────────┘                                               │\n└─────────────────────────────────────────────────────────────────────┘\n\nCritical Invariants:\n  • ALL registers saved (EAX-EDX, ESI, EDI, EBP, ESP, EIP, EFLAGS)\n  • ALL segment registers saved (CS, DS, ES, FS, GS, SS)\n  • TSS.ESP0 updated BEFORE switching to user process\n  • CR3 reloaded if page directories differ\n  • Stack valid at all times</code></pre></div>\n\n<h3 id=\"tss-structure\">TSS Structure</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Task State Segment (104 bytes):\n\n┌─────────────────────────────────────────────────────────────────────┐\n│ Offset  Field        Value            Purpose                      │\n├─────────────────────────────────────────────────────────────────────┤\n│  0      prev_task    0x0000           Previous task link (unused)  │\n│  4      esp0         0x90000          ★ RING 0 STACK POINTER ★     │\n│  8      ss0          0x0010           ★ RING 0 STACK SEGMENT ★     │\n│  12     esp1         0                Ring 1 stack (unused)        │\n│  16     ss1          0                Ring 1 segment (unused)      │\n│  20     esp2         0                Ring 2 stack (unused)        │\n│  24     ss2          0                Ring 2 segment (unused)      │\n│  28     cr3          0                Page directory (unused)      │\n│  32-68  eax-edi      0                General regs (unused)        │\n│  72-92  es-gs        0                Segments (unused)            │\n│  96     ldt          0                LDT selector (unused)        │\n│  100    trap         0                Trap flag (unused)           │\n│  102    iomap_base   104              I/O bitmap offset (none)     │\n└─────────────────────────────────────────────────────────────────────┘\n\nCRITICAL USAGE:\n  When interrupt/syscall occurs in user mode (ring 3):\n  1. CPU reads TSS.SS0 and TSS.ESP0\n  2. CPU switches to kernel stack: SS:ESP = SS0:ESP0\n  3. CPU pushes user SS, ESP, EFLAGS, CS, EIP onto kernel stack\n  4. CPU loads CS:EIP from IDT entry\n  5. Handler runs on kernel stack at ring 0\n\nTSS.ESP0 MUST be updated:\n  • Before context switch to ANY user-mode process\n  • Value = top of that process's kernel stack\n  • Each process has its own kernel stack (4KB)</code></pre></div>\n\n<h3 id=\"ring-transition-user-to-kernel\">Ring Transition (User to Kernel)</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Ring 3 → Ring 0 Transition (on interrupt/syscall):\n\nBEFORE (User Mode):\n┌─────────────────────────────────────────────────────────────────────┐\n│  User Process at Ring 3                                             │\n│                                                                     │\n│  CPU State:                                                         │\n│    CS:EIP = 0x1B:0x00100400 (user code)                            │\n│    SS:ESP = 0x23:0xBFFFF000 (user stack)                           │\n│    CPL = 3 (Current Privilege Level)                               │\n│                                                                     │\n│  User Stack:                          Kernel Stack:                 │\n│  ┌──────────────┐                     ┌──────────────┐             │\n│  │ local vars   │                     │    empty     │             │\n│  │ return addr  │                     │              │             │\n│  │ parameters   │                     │              │             │\n│  │ ...          │                     │              │             │\n│  └──────────────┘ ← ESP               └──────────────┘             │\n│   0xBFFFF000                                   ?                    │\n│                                                                     │\n│  TSS.ESP0 = 0x00090000 (kernel stack for this process)             │\n│  TSS.SS0  = 0x0010 (kernel data segment)                           │\n└─────────────────────────────────────────────────────────────────────┘\n                              │\n                              │ User executes: int 0x80\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────────────┐\n│  CPU Hardware Actions:                                              │\n│                                                                     │\n│  1. Read IDT[0x80] → Get handler CS:EIP                            │\n│  2. Check privilege: IDT DPL (3) &gt;= CPL (3) ✓                      │\n│  3. Detect ring transition: IDT CS DPL (0) &lt; CPL (3)               │\n│  4. Read TSS.SS0:ESP0 = 0x0010:0x00090000                          │\n│  5. Switch to kernel stack                                          │\n│  6. Push onto kernel stack:                                         │\n│     ┌──────────────┐                                                │\n│     │ SS (user)    │ 0x23                                          │\n│     │ ESP (user)   │ 0xBFFFF000                                    │\n│     │ EFLAGS       │ 0x00000202                                    │\n│     │ CS (user)    │ 0x1B                                          │\n│     │ EIP (user)   │ 0x00100402 (after int instruction)            │\n│     └──────────────┘ ← ESP (now 0x00090000)                        │\n│  7. Load CS:EIP from IDT                                            │\n│  8. Clear CPL to 0                                                  │\n└─────────────────────────────────────────────────────────────────────┘\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────────────┐\n│ AFTER (Kernel Mode):                                                │\n│                                                                     │\n│  CPU State:                                                         │\n│    CS:EIP = 0x08:syscall_handler (kernel code)                     │\n│    SS:ESP = 0x10:0x0008FFE0 (kernel stack)  ← ESP decremented      │\n│    CPL = 0 (Current Privilege Level)                               │\n│                                                                     │\n│  Kernel Stack:                                                      │\n│  ┌──────────────┐                                                   │\n│  │ SS (user)    │ 0x23    ← Pushed by CPU                          │\n│  │ ESP (user)   │ 0xBFFFF000                                       │\n│  │ EFLAGS       │ 0x00000202                                       │\n│  │ CS (user)    │ 0x1B                                             │\n│  │ EIP (user)   │ 0x00100402                                       │\n│  └──────────────┴──────────────────────────────────┐               │\n│  │ (handler's local vars, saved regs, etc.)        │               │\n│  └─────────────────────────────────────────────────┘ ← ESP         │\n│   0x0008FF00                                                       │\n│                                                                     │\n│  User Stack: (unchanged)                                           │\n│  ┌──────────────┐                                                   │\n│  │ local vars   │                                                   │\n│  │ ...          │                                                   │\n│  └──────────────┘                                                   │\n│   0xBFFFF000                                                       │\n└─────────────────────────────────────────────────────────────────────┘\n                              │\n                              │ Handler executes, then iret\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────────────┐\n│ iret (Return to User Mode):                                         │\n│                                                                     │\n│  1. Pop EIP, CS, EFLAGS, ESP, SS from kernel stack                 │\n│  2. Restore SS:ESP = 0x23:0xBFFFF000                               │\n│  3. Restore CS:EIP = 0x1B:0x00100402                               │\n│  4. Restore EFLAGS                                                  │\n│  5. Set CPL = 3                                                     │\n│  6. Resume user code                                                │\n└─────────────────────────────────────────────────────────────────────┘\n\nWITHOUT TSS.SS0:ESP0 → TRIPLE FAULT!\n  The CPU has nowhere to put the kernel stack.\n  Always update TSS.ESP0 before switching to user process.</code></pre></div>\n\n<h3 id=\"scheduler-queue\">Scheduler Queue</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Round-Robin Run Queue:\n\n┌─────────────────────────────────────────────────────────────────────┐\n│                         RUN QUEUE                                   │\n│                                                                     │\n│   ready_queue ──┐                                                   │\n│                 │                                                   │\n│                 ▼                                                   │\n│   ┌─────────────┐     ┌─────────────┐     ┌─────────────┐          │\n│   │   PCB A     │────▶│   PCB B     │────▶│   PCB C     │──▶ NULL  │\n│   │   READY     │     │   READY     │     │   READY     │          │\n│   │   pid=1     │◀────│   pid=2     │◀────│   pid=3     │          │\n│   └─────────────┘     └─────────────┘     └─────────────┘          │\n│                                                                     │\n│   current_process = PCB A (running)                                │\n│                                                                     │\n└─────────────────────────────────────────────────────────────────────┘\n\nTimer Tick (quantum expired):\n\n┌─────────────────────────────────────────────────────────────────────┐\n│ Step 1: Move current to end                                         │\n│                                                                     │\n│   ┌─────────────┐     ┌─────────────┐     ┌─────────────┐          │\n│   │   PCB B     │────▶│   PCB C     │────▶│   PCB A     │──▶ NULL  │\n│   │   READY     │     │   READY     │     │   READY     │          │\n│   │   pid=2     │◀────│   pid=3     │◀────│   pid=1     │          │\n│   └─────────────┘     └─────────────┘     └─────────────┘          │\n│         ▲                                           │               │\n│         │                                           │               │\n│   ready_queue ◀─────────────────────────────────────┘               │\n│                                                                     │\n│ Step 2: Pick next                                                   │\n│                                                                     │\n│   next = ready_queue = PCB B                                       │\n│   switch from PCB A to PCB B                                       │\n│                                                                     │\n│ Step 3: After switch                                                │\n│                                                                     │\n│   current_process = PCB B                                          │\n│   PCB B state = RUNNING                                            │\n│   PCB A state = READY                                              │\n│                                                                     │\n└─────────────────────────────────────────────────────────────────────┘\n\nBlocking (e.g., waiting for I/O):\n\n┌─────────────────────────────────────────────────────────────────────┐\n│ Process B calls sys_read() which blocks:                            │\n│                                                                     │\n│   PCB B state = BLOCKED                                            │\n│   Remove PCB B from queue                                          │\n│                                                                     │\n│   ready_queue ──▶ PCB C ──▶ PCB A ──▶ NULL                        │\n│                                                                     │\n│   current_process = PCB C (next ready)                             │\n│                                                                     │\n│ Later, when I/O completes:                                          │\n│                                                                     │\n│   PCB B state = READY                                              │\n│   Add PCB B to end of queue                                        │\n│                                                                     │\n│   ready_queue ──▶ PCB C ──▶ PCB A ──▶ PCB B ──▶ NULL              │\n│                                                                     │\n└─────────────────────────────────────────────────────────────────────┘\n\nPriority Queue (NOT IMPLEMENTED - future enhancement):\n┌─────────────────────────────────────────────────────────────────────┐\n│   Multiple queues by priority:                                      │\n│   priority[0] ──▶ [high priority tasks]                            │\n│   priority[1] ──▶ [normal tasks]                                   │\n│   priority[2] ──▶ [low priority tasks]                             │\n│                                                                     │\n│   Always pick from highest non-empty queue                          │\n│   Time slice varies by priority                                     │\n└─────────────────────────────────────────────────────────────────────┘</code></pre></div>\n\n<h3 id=\"multi-process-demo\">Multi-Process Demo</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Three Kernel Processes Demo:\n\n┌─────────────────────────────────────────────────────────────────────┐\n│                         VGA Screen                                  │\n│                                                                     │\n│  Row 0:  ┌──────────────────────────────────────────────────────┐  │\n│          │ [Process A] Count: 42                                 │  │\n│          └──────────────────────────────────────────────────────┘  │\n│                                                                     │\n│  Row 5:  ┌──────────────────────────────────────────────────────┐  │\n│          │ [Process B] Count: 38                                 │  │\n│          └──────────────────────────────────────────────────────┘  │\n│                                                                     │\n│  Row 10: ┌──────────────────────────────────────────────────────┐  │\n│          │ [Process C] Count: 45                                 │  │\n│          └──────────────────────────────────────────────────────┘  │\n│                                                                     │\n│  ... rest of screen ...                                            │\n│                                                                     │\n└─────────────────────────────────────────────────────────────────────┘\n\nExecution Timeline (100Hz timer, 10 tick quantum):\n\nTime    Running Process    Action\n────────────────────────────────────────────────────────────────────\n0ms     A                  Increments counter to 1\n1ms     A                  Increments to 2\n...\n100ms   A (quantum done)   Switch to B\n100ms   B                  Increments counter to 1\n101ms   B                  Increments to 2\n...\n200ms   B (quantum done)   Switch to C\n200ms   C                  Increments counter to 1\n...\n300ms   C (quantum done)   Switch to A\n300ms   A                  Increments counter to 11 (resumed)\n...\n\nEach process sees:\n  - Its counter incrementing\n  - No awareness of other processes\n  - No awareness of being suspended/resumed\n\nKey Observations:\n  • All three counters increment &quot;simultaneously&quot; (from user perspective)\n  • Only ONE process actually executes at any instant\n  • Switch overhead is imperceptible (~500 cycles = ~0.5µs at 1GHz)\n  • Each process has independent EIP, ESP, registers</code></pre></div>\n\n<h3 id=\"user-kernel-memory-layout\">User-Kernel Memory Layout</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Address Space Layout:\n\n┌─────────────────────────────────────────────────────────────────────┐\n│                         KERNEL SPACE (1GB)                          │\n│                    0xC0000000 - 0xFFFFFFFF                         │\n│                                                                     │\n│  0xFFFFFFFF ┌──────────────────────────────────────┐               │\n│             │                                      │               │\n│             │   Reserved / Device MMIO             │               │\n│             │                                      │               │\n│  0xC0800000 ├──────────────────────────────────────┤               │\n│             │   Kernel Heap End                    │               │\n│             │   (expandable)                       │               │\n│  0xC0400000 ├──────────────────────────────────────┤               │\n│             │   Kernel Heap (kmalloc)              │               │\n│             │   PTE_USER = 0 (supervisor only)    │               │\n│  0xC0100000 ├──────────────────────────────────────┤               │\n│             │   Kernel Code + Data                 │               │\n│             │   .text, .rodata, .data, .bss        │               │\n│             │   PTE_USER = 0 (supervisor only)    │               │\n│  0xC0000000 ├──────────────────────────────────────┤               │\n│             │   Kernel mapping of low memory       │               │\n│             │   (VGA at 0xB8000 mapped here)       │               │\n│             └──────────────────────────────────────┘               │\n│                                                                     │\n├─────────────────────────────────────────────────────────────────────┤\n│                         USER SPACE (3GB)                            │\n│                    0x00000000 - 0xBFFFFFFF                         │\n│                                                                     │\n│  0xBFFFFFFF ┌──────────────────────────────────────┐               │\n│             │   User Stack (grows down)            │               │\n│             │   PTE_USER = 1                       │               │\n│  0xBFFFF000 ├──────────────────────────────────────┤               │\n│             │                                      │               │\n│             │   (unmapped - guard page)            │               │\n│             │                                      │               │\n│  0xBFF00000 ├──────────────────────────────────────┤               │\n│             │                                      │               │\n│             │   User Heap (expandable)             │               │\n│             │   (brk/sbrk managed)                 │               │\n│             │                                      │               │\n│  0x00400000 ├──────────────────────────────────────┤               │\n│             │   User Code + Data                   │               │\n│             │   (loaded from executable)           │               │\n│             │   PTE_USER = 1                       │               │\n│  0x00001000 ├──────────────────────────────────────┤               │\n│             │   NULL page (unmapped)               │               │\n│  0x00000000 └──────────────────────────────────────┘               │\n│                                                                     │\n└─────────────────────────────────────────────────────────────────────┘\n\nPage Table Entry User Bit:\n  PTE_USER = 1 → User mode (ring 3) can access\n  PTE_USER = 0 → Supervisor only (ring 0-2)\n\nUser Process Page Directory:\n  - Entries 0-767: User space (unique per process)\n  - Entries 768-1023: Kernel space (identical across all processes)\n  - Kernel entries: PTE_USER = 0, PTE_GLOBAL = 1\n\nUser Mode Access Violation:\n  User code: mov eax, [0xC0100000]  ; Kernel memory\n  CPU checks: PTE_USER = 0, CPL = 3 → PAGE FAULT</code></pre></div>\n\n<h3 id=\"system-call-interface\">System Call Interface</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>INT 0x80 System Call Mechanism:\n\nUser Mode Call:\n┌─────────────────────────────────────────────────────────────────────┐\n│  // User code                                                       │\n│  const char *msg = &quot;Hello\\n&quot;;                                      │\n│  int len = 5;                                                       │\n│                                                                     │\n│  // Inline assembly syscall                                         │\n│  asm volatile(                                                      │\n│      &quot;int $0x80&quot;                   // Trigger syscall              │\n│      : &quot;=a&quot;(retval)                // Return value in EAX          │\n│      : &quot;a&quot;(SYS_WRITE),             // Syscall number in EAX        │\n│        &quot;b&quot;(1),                     // fd in EBX                    │\n│        &quot;c&quot;(msg),                   // buf in ECX                   │\n│        &quot;d&quot;(len)                    // count in EDX                 │\n│  );                                                                 │\n└─────────────────────────────────────────────────────────────────────┘\n                              │\n                              │ int 0x80\n                              │ (CPU transitions ring 3 → ring 0)\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────────────┐\n│  Kernel Syscall Handler                                             │\n│                                                                     │\n│  1. Read syscall number from EAX                                   │\n│     syscall_num = regs-&gt;eax;  // EAX saved on stack               │\n│                                                                     │\n│  2. Bounds check                                                    │\n│     if (syscall_num &gt;= MAX_SYSCALL) return -1;                     │\n│                                                                     │\n│  3. Dispatch to handler                                             │\n│     handler = syscall_table[syscall_num];                          │\n│     result = handler(regs-&gt;ebx, regs-&gt;ecx, regs-&gt;edx);             │\n│                                                                     │\n│  4. Store result                                                    │\n│     regs-&gt;eax = result;  // Return value                           │\n│                                                                     │\n│  5. iret back to user mode                                          │\n└─────────────────────────────────────────────────────────────────────┘\n                              │\n                              │ iret\n                              │ (CPU transitions ring 0 → ring 3)\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────────────┐\n│  // User code continues                                             │\n│  if (retval == len) {                                               │\n│      // Success                                                     │\n│  }                                                                  │\n└─────────────────────────────────────────────────────────────────────┘\n\nSyscall Register Convention:\n┌─────────────────────────────────────────────────────────────────────┐\n│ Register    Input                   Output                         │\n├─────────────────────────────────────────────────────────────────────┤\n│ EAX         Syscall number          Return value                   │\n│ EBX         Argument 0              (preserved or result)          │\n│ ECX         Argument 1              (preserved or result)          │\n│ EDX         Argument 2              (preserved or result)          │\n│ ESI         Argument 3 (optional)   (preserved)                    │\n│ EDI         Argument 4 (optional)   (preserved)                    │\n│ EBP         Argument 5 (optional)   (preserved)                    │\n└─────────────────────────────────────────────────────────────────────┘\n\nSyscall Table:\n┌─────────────────────────────────────────────────────────────────────┐\n│ Number  Name        Handler              Signature                 │\n├─────────────────────────────────────────────────────────────────────┤\n│ 0       SYS_EXIT    sys_exit             (int status) → void       │\n│ 1       SYS_READ    sys_read             (fd, buf, count) → int    │\n│ 2       SYS_WRITE   sys_write            (fd, buf, count) → int    │\n│ 3       SYS_EXEC    sys_exec             (path) → int              │\n│ 4       SYS_FORK    sys_fork             () → int                  │\n│ 5       SYS_GETPID  sys_getpid           () → int                  │\n│ 6       SYS_YIELD   sys_yield            () → void                 │\n│ 7-255   Reserved    (NULL)               -                         │\n└─────────────────────────────────────────────────────────────────────┘\n\nIDT Entry for INT 0x80:\n  offset_low  = handler_address &amp; 0xFFFF\n  selector    = 0x08 (kernel code)\n  zero        = 0\n  type_attr   = 0xEE  // Present, DPL=3 (user callable), Trap gate\n  offset_high = handler_address &gt;&gt; 16\n\nDPL=3 is CRITICAL: Allows user mode to call int 0x80\nDPL=0 would cause General Protection Fault if called from ring 3</code></pre></div>\n\n<hr>\n<p>[[CRITERIA_JSON: {&quot;module_id&quot;: &quot;mod-scheduling&quot;, &quot;criteria&quot;: [&quot;PCB structure defines all required fields at documented byte offsets&quot;, &quot;process_create allocates kernel stack and initializes PCB for kernel mode&quot;, &quot;process_create allocates user stack and clones page directory for user mode&quot;, &quot;context_switch saves all general purpose registers (EAX-EDX, ESI, EDI, EBP, ESP)&quot;, &quot;context_switch saves all segment registers (CS, DS, ES, FS, GS, SS)&quot;, &quot;context_switch saves EIP and EFLAGS&quot;, &quot;context_switch loads CR3 when page directories differ&quot;, &quot;context_switch updates TSS.ESP0 for user mode processes&quot;, &quot;TSS is initialized with SS0=0x10 and loaded into TR&quot;, &quot;TSS.ESP0 is updated before every context switch to user process&quot;, &quot;Round-robin scheduler maintains ready queue with correct prev/next pointers&quot;, &quot;scheduler_tick triggers context switch when time slice expires&quot;, &quot;scheduler_yield marks current process READY and switches to next&quot;, &quot;enter_user_mode uses iret to transition to ring 3&quot;, &quot;enter_user_mode sets up stack frame with SS, ESP, EFLAGS, CS, EIP&quot;, &quot;System call handler registered at IDT vector 0x80 with DPL=3&quot;, &quot;System call handler validates syscall number before dispatch&quot;, &quot;System call handler validates user pointers before dereferencing&quot;, &quot;sys_write validates buffer is in user space (below kernel base)&quot;, &quot;sys_exit marks process as ZOMBIE and triggers scheduler&quot;, &quot;Three kernel processes can run concurrently with independent counters&quot;, &quot;User process executes at ring 3 (CS=0x1B)&quot;, &quot;User process page fault occurs on kernel memory access (isolation verified)&quot;]}]</p>\n<!-- TDD_MOD_ID: mod-drivers -->\n<p>I&#39;ll create a Technical Design Specification for the Kernel Drivers and Utilities module. Let me first examine the existing architecture to ensure consistency.</p>\n<p>I&#39;ll create a bibliography of high-quality external resources for the OS development concepts covered in this project. Let me first examine the existing architecture documentation to understand the scope better.# 📚 Beyond the Atlas: Further Reading</p>\n<h2 id=\"x86-architecture-amp-boot-process\">x86 Architecture &amp; Boot Process</h2>\n<p><strong>Paper</strong>: B. Ford, S. Hibler, J. Lepreau, P. Tullmann. &quot;Microkernels Meet Recursive Virtual Machines.&quot; <em>OSDI &#39;96</em>. The foundational paper on bootstrapping and recursive VM structure—directly relevant to understanding the hardware-to-software transition.</p>\n<p><strong>Code</strong>: Linux Kernel <code>arch/x86/boot/</code> — Specifically <code>boot/header.S</code> and <code>boot/main.c</code>. The production implementation of the boot sequence you&#39;re building, showing how GRUB-compatible multiboot and real-mode transitions work at scale.</p>\n<p><strong>Best Explanation</strong>: osdev.org Wiki, &quot;A20 Line&quot; article. The clearest explanation of why this historical quirk exists and the multiple methods to handle it.</p>\n<p><strong>Why</strong>: These resources cover the actual hardware initialization that your bootloader negotiates, from real-mode legacy to protected mode setup.</p>\n<h2 id=\"segmentation-amp-gdt\">Segmentation &amp; GDT</h2>\n<p><strong>Spec</strong>: Intel 64 and IA-32 Architectures Software Developer&#39;s Manual, Volume 3A, Chapter 3 (&quot;Protected-Mode Memory Management&quot;). Sections 3.4-3.5 document the exact descriptor format and selector mechanics.</p>\n<p><strong>Code</strong>: Linux Kernel <code>arch/x86/kernel/cpu/common.c</code> — <code>cpu_init()</code> function showing how production systems configure GDT entries including per-CPU segments.</p>\n<p><strong>Best Explanation</strong>: &quot;GDT Tutorial&quot; by the OSDev community. Practical walkthrough of flat memory model setup with working code examples.</p>\n<p><strong>Why</strong>: Intel&#39;s manual is authoritative; OSDev bridges specification to implementation.</p>\n<h2 id=\"interrupt-handling-amp-idt\">Interrupt Handling &amp; IDT</h2>\n<p><strong>Spec</strong>: Intel 64 and IA-32 Architectures SDM, Volume 3A, Chapter 6 (&quot;Interrupt and Exception Handling&quot;). Documents exception vectors, error codes, and IDT gate formats.</p>\n<p><strong>Code</strong>: Linux Kernel <code>arch/x86/kernel/idt.c</code> — The modern Linux IDT setup, showing how a production system maps vectors to handlers with proper privilege levels.</p>\n<p><strong>Best Explanation</strong>: &quot;8259 PIC&quot; article on OSDev Wiki. Essential for understanding IRQ remapping—the most common source of early OS bugs.</p>\n<p><strong>Why</strong>: The PIC remapping problem trips up every OS developer; this resource prevents hours of debugging.</p>\n<h2 id=\"physical-memory-management\">Physical Memory Management</h2>\n<p><strong>Paper</strong>: J. Bonwick. &quot;The Slab Allocator: An Object-Caching Kernel Memory Allocator.&quot; <em>USENIX &#39;94</em>. While this is about slab allocators specifically, the introduction explains the frame allocator problem space clearly.</p>\n<p><strong>Code</strong>: Linux Kernel <code>mm/page_alloc.c</code> — The buddy allocator implementation. <code>__alloc_pages_nodemask()</code> shows how production systems handle frame allocation with zones and watermarks.</p>\n<p><strong>Best Explanation</strong>: &quot;Physical Memory Management&quot; chapter in &quot;Operating Systems: Three Easy Pieces&quot; by Arpaci-Dusseau. Free online at ostep.org.</p>\n<p><strong>Why</strong>: OSTEP provides intuition; Linux shows the 30-year evolution of these ideas.</p>\n<h2 id=\"x86-paging-amp-virtual-memory\">x86 Paging &amp; Virtual Memory</h2>\n<p><strong>Spec</strong>: Intel SDM, Volume 3A, Chapter 4 (&quot;Paging&quot;). Tables 4-5 through 4-12 document the exact bit layout of PDEs and PTEs for 32-bit paging.</p>\n<p><strong>Code</strong>: Linux Kernel <code>arch/x86/mm/init_32.c</code> — <code>kernel_physical_mapping_init()</code> shows how Linux builds its page tables, including the identity mapping + higher-half pattern.</p>\n<p><strong>Best Explanation</strong>: &quot;What Every Computer Scientist Should Know About Virtual Memory&quot; by Ulrich Drepper.虽然是about Linux specifics but explains the hardware-software contract.</p>\n<p><strong>Why</strong>: Drepper&#39;s guide connects page table mechanics to performance—essential for understanding TLB behavior.</p>\n<h2 id=\"context-switching-amp-scheduling\">Context Switching &amp; Scheduling</h2>\n<p><strong>Paper</strong>: C. B. Weinstock and W. A. Wulf. &quot;QuickCheck: An Efficient Implementation of Checkpointing.&quot; <em>ICSE &#39;91</em>. While about checkpoints, the register save/restore mechanics are identical to context switching.</p>\n<p><strong>Code</strong>: Linux Kernel <code>arch/x86/kernel/process_32.c</code> — <code>__switch_to_asm()</code>. The actual assembly that saves/restores registers. Compare to your <code>context_switch()</code> implementation.</p>\n<p><strong>Best Explanation</strong>: &quot;Scheduling&quot; chapter in OSTEP. Clear explanation of round-robin and the tradeoffs in scheduling algorithm design.</p>\n<p><strong>Why</strong>: Seeing Linux&#39;s context switch demystifies what &quot;saving all registers&quot; actually means in production.</p>\n<h2 id=\"the-tss-amp-ring-transitions\">The TSS &amp; Ring Transitions</h2>\n<p><strong>Spec</strong>: Intel SDM, Volume 3A, Section 7.2.1 (&quot;Task-State Segment&quot;). Documents why TSS.SS0:ESP0 are mandatory for privilege transitions.</p>\n<p><strong>Code</strong>: Linux Kernel <code>arch/x86/kernel/process.c</code> — <code>arch_setup_new_exec()</code> and related functions showing how TSS.ESP0 is updated per-task.</p>\n<p><strong>Best Explanation</strong>: &quot;Privilege Levels&quot; on OSDev Wiki. Clear diagrams showing stack switching during ring transitions.</p>\n<p><strong>Why</strong>: The TSS is often misunderstood as &quot;Intel&#39;s failed hardware task switching&quot;—understanding its actual purpose (stack switching) prevents subtle bugs.</p>\n<h2 id=\"system-calls\">System Calls</h2>\n<p><strong>Paper</strong>: M. Abadi et al. &quot;Control-Flow Integrity.&quot; <em>CCS &#39;05</em>. While advanced, the introduction explains why syscall validation matters for security.</p>\n<p><strong>Code</strong>: Linux Kernel <code>arch/x86/entry/entry_32.S</code> — <code>ENTRY(entry_INT80_compat)</code>. The INT 0x80 handler showing how modern Linux still supports this legacy interface.</p>\n<p><strong>Best Explanation</strong>: &quot;System Calls&quot; chapter in OSTEP. Clear conceptual explanation with implementation details.</p>\n<p><strong>Why</strong>: OSTEP explains the &quot;why&quot;; Linux shows 30 years of security hardening.</p>\n<h2 id=\"ps2-keyboard-amp-hardware-io\">PS/2 Keyboard &amp; Hardware I/O</h2>\n<p><strong>Spec</strong>: IBM PS/2 Hardware Interface Technical Reference. The original specification for the keyboard controller interface.</p>\n<p><strong>Code</strong>: Linux Kernel <code>drivers/input/keyboard/atkbd.c</code> — Production keyboard driver showing scancode handling complexity.</p>\n<p><strong>Best Explanation</strong>: &quot;PS/2 Keyboard&quot; article on OSDev Wiki. Complete scancode tables and initialization sequences.</p>\n<p><strong>Why</strong>: The OSDev article has tested code for handling the scancode quirks that will otherwise consume debugging time.</p>\n<h2 id=\"vga-text-mode\">VGA Text Mode</h2>\n<p><strong>Spec</strong>: IBM VGA Technical Reference. The original specification for text mode buffer format.</p>\n<p><strong>Code</strong>: Linux Kernel <code>drivers/video/console/vgacon.c</code> — Production VGA console driver.</p>\n<p><strong>Best Explanation</strong>: &quot;VGA Text Mode&quot; on OSDev Wiki. Direct buffer addressing with color attribute byte format.</p>\n<p><strong>Why</strong>: Simple, visual feedback is essential for debugging—this is your first output device.</p>\n<h2 id=\"serial-port-debugging-lifeline\">Serial Port (Debugging Lifeline)</h2>\n<p><strong>Code</strong>: Linux Kernel <code>drivers/tty/serial/8250/8250_core.c</code> — The standard PC serial driver.</p>\n<p><strong>Best Explanation</strong>: &quot;Serial Ports&quot; on OSDev Wiki. Complete initialization sequence and register map.</p>\n<p><strong>Why</strong>: When your kernel triple-faults before VGA works, serial output is your only diagnostic tool.</p>\n<h2 id=\"debugging-with-qemu-amp-gdb\">Debugging with QEMU &amp; GDB</h2>\n<p><strong>Best Explanation</strong>: &quot;Debugging with QEMU&quot; on OSDev Wiki. Complete guide to <code>-s -S</code> flags and GDB integration.</p>\n<p><strong>Why</strong>: Working without a debugger in OS development is practically impossible—this skill is foundational.</p>\n<h2 id=\"linker-scripts-amp-memory-layout\">Linker Scripts &amp; Memory Layout</h2>\n<p><strong>Spec</strong>: GNU LD Manual, Chapter 3 (&quot;Linker Scripts&quot;). The authoritative reference for section placement and symbol definitions.</p>\n<p><strong>Code</strong>: Linux Kernel <code>arch/x86/kernel/vmlinux.lds.S</code> — Production linker script showing complex section ordering and alignment requirements.</p>\n<p><strong>Best Explanation</strong>: &quot;Linker Scripts&quot; chapter in &quot;Linkers and Loaders&quot; by John Levine. Explains the VMA/LMA distinction critical for higher-half kernels.</p>\n<p><strong>Why</strong>: Understanding VMA vs LMA prevents the &quot;why is my code at the wrong address&quot; class of bugs.</p>\n<hr>\n<h2 id=\"reference-hierarchy\">Reference Hierarchy</h2>\n<ol>\n<li><strong>Intel SDM Volumes 1-3A</strong> — The hardware truth; consult for exact bit layouts and behavior</li>\n<li><strong>OSDev Wiki</strong> — Community-tested implementations; first stop for practical guidance</li>\n<li><strong>Linux Kernel Source</strong> — Production implementations; study after understanding the basics</li>\n<li><strong>OSTEP (ostep.org)</strong> — Conceptual clarity; read alongside implementation</li>\n<li><strong>QEMU + GDB</strong> — Your debugging environment; master early</li>\n</ol>\n<p>Total: 20 resources, prioritized by relevance to this project&#39;s milestones.</p>\n","toc":[{"level":1,"text":"Build Your Own OS","id":"build-your-own-os"},{"level":1,"text":"Milestone 1: Bootloader, GDT, and Kernel Entry","id":"milestone-1-bootloader-gdt-and-kernel-entry"},{"level":2,"text":"The Tension: Hardware Doesn&#39;t Want to Run Your Code","id":"the-tension-hardware-doesn39t-want-to-run-your-code"},{"level":2,"text":"System Map: Where We Are","id":"system-map-where-we-are"},{"level":2,"text":"The Boot Process: From Power-On to Your First Instruction","id":"the-boot-process-from-power-on-to-your-first-instruction"},{"level":3,"text":"What the BIOS Does (So You Don&#39;t Have To)","id":"what-the-bios-does-so-you-don39t-have-to"},{"level":3,"text":"Your Bootloader&#39;s Job","id":"your-bootloader39s-job"},{"level":3,"text":"The A20 Line: A Historical Anomaly You Must Handle","id":"the-a20-line-a-historical-anomaly-you-must-handle"},{"level":2,"text":"Segmentation: The GDT and Why x86 Still Has It","id":"segmentation-the-gdt-and-why-x86-still-has-it"},{"level":3,"text":"The Tension: Why Segmentation Exists","id":"the-tension-why-segmentation-exists"},{"level":3,"text":"The Flat Memory Model: Your Goal","id":"the-flat-memory-model-your-goal"},{"level":3,"text":"GDT Entry Structure: 64 Bits of Configuration","id":"gdt-entry-structure-64-bits-of-configuration"},{"level":2,"text":"The Protected Mode Transition: A Precise Sequence","id":"the-protected-mode-transition-a-precise-sequence"},{"level":3,"text":"Step-by-Step Transition","id":"step-by-step-transition"},{"level":3,"text":"Why Each Step Matters","id":"why-each-step-matters"},{"level":2,"text":"Loading the Kernel from Disk","id":"loading-the-kernel-from-disk"},{"level":2,"text":"The Linker Script: Where Code Lives in Memory","id":"the-linker-script-where-code-lives-in-memory"},{"level":2,"text":"The C Entry Point: No Runtime, No Safety Net","id":"the-c-entry-point-no-runtime-no-safety-net"},{"level":2,"text":"VGA Text Mode: Your First Display Driver","id":"vga-text-mode-your-first-display-driver"},{"level":2,"text":"Serial Port Debug Output: Your Lifeline","id":"serial-port-debug-output-your-lifeline"},{"level":2,"text":"Hardware Soul: What&#39;s Actually Happening","id":"hardware-soul-what39s-actually-happening"},{"level":2,"text":"Debugging Your Bootloader: When Nothing Works","id":"debugging-your-bootloader-when-nothing-works"},{"level":3,"text":"QEMU with GDB","id":"qemu-with-gdb"},{"level":3,"text":"Serial Output","id":"serial-output"},{"level":3,"text":"Triple Fault Detection","id":"triple-fault-detection"},{"level":2,"text":"Design Decision: One-Stage vs Two-Stage Bootloader","id":"design-decision-one-stage-vs-two-stage-bootloader"},{"level":2,"text":"Building and Running","id":"building-and-running"},{"level":2,"text":"Knowledge Cascade","id":"knowledge-cascade"},{"level":2,"text":"Summary","id":"summary"},{"level":1,"text":"Milestone 2: Interrupts, Exceptions, and Keyboard","id":"milestone-2-interrupts-exceptions-and-keyboard"},{"level":2,"text":"The Tension: Hardware Can&#39;t Wait For You","id":"the-tension-hardware-can39t-wait-for-you"},{"level":2,"text":"Revelation: It&#39;s Not a Callback","id":"revelation-it39s-not-a-callback"},{"level":2,"text":"System Map: Where We Are","id":"system-map-where-we-are"},{"level":2,"text":"The IDT: 256 Doors to Your Code","id":"the-idt-256-doors-to-your-code"},{"level":3,"text":"Structure of an IDT Entry","id":"structure-of-an-idt-entry"},{"level":3,"text":"Loading the IDT","id":"loading-the-idt"},{"level":3,"text":"CPU Exception Vectors: 0-31","id":"cpu-exception-vectors-0-31"},{"level":2,"text":"Interrupt Stack Frame: What the CPU Pushes","id":"interrupt-stack-frame-what-the-cpu-pushes"},{"level":2,"text":"Writing an Interrupt Handler: The Assembly Shim","id":"writing-an-interrupt-handler-the-assembly-shim"},{"level":3,"text":"The C Handler","id":"the-c-handler"},{"level":2,"text":"The 8259 PIC: Routing Hardware Interrupts","id":"the-8259-pic-routing-hardware-interrupts"},{"level":3,"text":"The Remapping Problem","id":"the-remapping-problem"},{"level":3,"text":"Programming the PIC","id":"programming-the-pic"},{"level":3,"text":"IRQ Handlers","id":"irq-handlers"},{"level":2,"text":"The PIT Timer: Your First Clock","id":"the-pit-timer-your-first-clock"},{"level":2,"text":"PS/2 Keyboard: Scancodes to Characters","id":"ps2-keyboard-scancodes-to-characters"},{"level":3,"text":"Reading from the Keyboard","id":"reading-from-the-keyboard"},{"level":3,"text":"Handling Special Cases","id":"handling-special-cases"},{"level":2,"text":"Double Fault: Your Last Line of Defense","id":"double-fault-your-last-line-of-defense"},{"level":2,"text":"Putting It All Together: Initialization Sequence","id":"putting-it-all-together-initialization-sequence"},{"level":2,"text":"Hardware Soul: What&#39;s Happening on the Metal","id":"hardware-soul-what39s-happening-on-the-metal"},{"level":2,"text":"Debugging Interrupt Issues","id":"debugging-interrupt-issues"},{"level":2,"text":"Design Decision: Interrupt Gates vs Trap Gates","id":"design-decision-interrupt-gates-vs-trap-gates"},{"level":2,"text":"Knowledge Cascade","id":"knowledge-cascade"},{"level":2,"text":"Summary","id":"summary"},{"level":1,"text":"Milestone 3: Physical and Virtual Memory Management","id":"milestone-3-physical-and-virtual-memory-management"},{"level":2,"text":"The Tension: Memory Isn&#39;t What You Think It Is","id":"the-tension-memory-isn39t-what-you-think-it-is"},{"level":2,"text":"Revelation: The Address Translation Happens Every Time","id":"revelation-the-address-translation-happens-every-time"},{"level":2,"text":"System Map: Where We Are","id":"system-map-where-we-are"},{"level":2,"text":"Physical Memory Map: Discovering What Exists","id":"physical-memory-map-discovering-what-exists"},{"level":3,"text":"The E820 BIOS Query","id":"the-e820-bios-query"},{"level":3,"text":"Typical Memory Layout","id":"typical-memory-layout"},{"level":2,"text":"Physical Frame Allocator: Managing 4KB Chunks","id":"physical-frame-allocator-managing-4kb-chunks"},{"level":3,"text":"Bitmap Allocator","id":"bitmap-allocator"},{"level":3,"text":"Initializing the Frame Allocator","id":"initializing-the-frame-allocator"},{"level":3,"text":"Alternative: Linked List Allocator","id":"alternative-linked-list-allocator"},{"level":2,"text":"Page Tables: The Two-Level Hierarchy","id":"page-tables-the-two-level-hierarchy"},{"level":3,"text":"x86 32-bit Paging Structure","id":"x86-32-bit-paging-structure"},{"level":3,"text":"Extracting Address Components","id":"extracting-address-components"},{"level":3,"text":"Mapping Virtual to Physical","id":"mapping-virtual-to-physical"},{"level":2,"text":"Identity Mapping + Higher-Half Kernel","id":"identity-mapping-higher-half-kernel"},{"level":3,"text":"The Address Space Layout Problem","id":"the-address-space-layout-problem"},{"level":3,"text":"Setting Up the Initial Page Tables","id":"setting-up-the-initial-page-tables"},{"level":3,"text":"Enabling Paging: The Critical Sequence","id":"enabling-paging-the-critical-sequence"},{"level":3,"text":"TLB Flushing","id":"tlb-flushing"},{"level":2,"text":"Page Fault Handler: Diagnosis and Recovery","id":"page-fault-handler-diagnosis-and-recovery"},{"level":3,"text":"The Error Code","id":"the-error-code"},{"level":3,"text":"Handler Implementation","id":"handler-implementation"},{"level":2,"text":"Kernel Heap: Dynamic Memory Allocation","id":"kernel-heap-dynamic-memory-allocation"},{"level":3,"text":"The Need for kmalloc","id":"the-need-for-kmalloc"},{"level":3,"text":"Simple Heap Implementation: Linked List of Blocks","id":"simple-heap-implementation-linked-list-of-blocks"},{"level":3,"text":"A Simpler Alternative: Placement Allocator","id":"a-simpler-alternative-placement-allocator"},{"level":2,"text":"Hardware Soul: The Physical Reality of Virtual Memory","id":"hardware-soul-the-physical-reality-of-virtual-memory"},{"level":2,"text":"Debugging Memory Management","id":"debugging-memory-management"},{"level":2,"text":"Design Decision: Bitmap vs Free-List Allocator","id":"design-decision-bitmap-vs-free-list-allocator"},{"level":2,"text":"Knowledge Cascade","id":"knowledge-cascade"},{"level":2,"text":"Summary","id":"summary"},{"level":1,"text":"Milestone 4: Processes and Preemptive Scheduling","id":"milestone-4-processes-and-preemptive-scheduling"},{"level":2,"text":"The Tension: One CPU, Many Tasks—The Illusion of Simultaneity","id":"the-tension-one-cpu-many-tasksthe-illusion-of-simultaneity"},{"level":2,"text":"Revelation: It&#39;s Not Parallelism—It&#39;s Perfect Amnesia","id":"revelation-it39s-not-parallelismit39s-perfect-amnesia"},{"level":2,"text":"System Map: Where We Are","id":"system-map-where-we-are"},{"level":2,"text":"The Process Control Block: Capturing a Process&#39;s Soul","id":"the-process-control-block-capturing-a-process39s-soul"},{"level":3,"text":"What Must Be Saved","id":"what-must-be-saved"},{"level":3,"text":"PCB Storage","id":"pcb-storage"},{"level":3,"text":"Setting Up the First Process","id":"setting-up-the-first-process"},{"level":2,"text":"Context Switch: The Assembly Core","id":"context-switch-the-assembly-core"},{"level":3,"text":"Why Assembly is Mandatory","id":"why-assembly-is-mandatory"},{"level":3,"text":"The Assembly Implementation","id":"the-assembly-implementation"},{"level":3,"text":"A Cleaner Approach: Using iret","id":"a-cleaner-approach-using-iret"},{"level":2,"text":"The TSS: Required for Ring Transitions","id":"the-tss-required-for-ring-transitions"},{"level":3,"text":"What the TSS Does (and Doesn&#39;t Do)","id":"what-the-tss-does-and-doesn39t-do"},{"level":3,"text":"When TSS.ESP0 Must Be Updated","id":"when-tssesp0-must-be-updated"},{"level":2,"text":"Round-Robin Scheduler: The Heart of Multitasking","id":"round-robin-scheduler-the-heart-of-multitasking"},{"level":3,"text":"The Algorithm","id":"the-algorithm"},{"level":3,"text":"Integration with Timer Interrupt","id":"integration-with-timer-interrupt"},{"level":2,"text":"Demonstration: Three Kernel Processes","id":"demonstration-three-kernel-processes"},{"level":2,"text":"User Mode: Crossing the Ring Boundary","id":"user-mode-crossing-the-ring-boundary"},{"level":3,"text":"Creating a User Process","id":"creating-a-user-process"},{"level":3,"text":"Entering User Mode: The iret Trick","id":"entering-user-mode-the-iret-trick"},{"level":3,"text":"Isolation Verification","id":"isolation-verification"},{"level":2,"text":"System Calls: User-to-Kernel Communication","id":"system-calls-user-to-kernel-communication"},{"level":3,"text":"The INT 0x80 Interface","id":"the-int-0x80-interface"},{"level":3,"text":"Setting Up the Syscall Gate","id":"setting-up-the-syscall-gate"},{"level":3,"text":"Implementing sys_write","id":"implementing-sys_write"},{"level":3,"text":"Implementing sys_exit","id":"implementing-sys_exit"},{"level":3,"text":"User-Space Syscall Wrapper","id":"user-space-syscall-wrapper"},{"level":2,"text":"Hardware Soul: The Physical Cost of Multitasking","id":"hardware-soul-the-physical-cost-of-multitasking"},{"level":2,"text":"Debugging Scheduler Issues","id":"debugging-scheduler-issues"},{"level":2,"text":"Design Decision: Cooperative vs Preemptive Scheduling","id":"design-decision-cooperative-vs-preemptive-scheduling"},{"level":2,"text":"Knowledge Cascade","id":"knowledge-cascade"},{"level":2,"text":"Summary","id":"summary"},{"level":1,"text":"TDD","id":"tdd"},{"level":1,"text":"Technical Design Specification: Bootloader and Protected Mode Entry","id":"technical-design-specification-bootloader-and-protected-mode-entry"},{"level":2,"text":"Module Charter","id":"module-charter"},{"level":2,"text":"File Structure","id":"file-structure"},{"level":2,"text":"Complete Data Model","id":"complete-data-model"},{"level":3,"text":"GDT Entry Structure (8 bytes each)","id":"gdt-entry-structure-8-bytes-each"},{"level":3,"text":"GDTR Structure (6 bytes)","id":"gdtr-structure-6-bytes"},{"level":3,"text":"Memory Layout at Boot","id":"memory-layout-at-boot"},{"level":3,"text":"Kernel Stack Layout","id":"kernel-stack-layout"},{"level":2,"text":"Interface Contracts","id":"interface-contracts"},{"level":3,"text":"stage1.asm Entry Point","id":"stage1asm-entry-point"},{"level":3,"text":"a20_enable()","id":"a20_enable"},{"level":3,"text":"gdt_load()","id":"gdt_load"},{"level":3,"text":"protected_mode_enter()","id":"protected_mode_enter"},{"level":3,"text":"disk_read.sectors(drive, cylinder, head, sector, count, es:bx)","id":"disk_readsectorsdrive-cylinder-head-sector-count-esbx"},{"level":3,"text":"kernel_entry (assembly shim)","id":"kernel_entry-assembly-shim"},{"level":2,"text":"Algorithm Specification","id":"algorithm-specification"},{"level":3,"text":"Stage 1 Bootloader Sequence","id":"stage-1-bootloader-sequence"},{"level":3,"text":"A20 Line Enablement (Multiple Methods)","id":"a20-line-enablement-multiple-methods"},{"level":3,"text":"Disk Read with Retry","id":"disk-read-with-retry"},{"level":3,"text":"BSS Zeroing","id":"bss-zeroing"},{"level":2,"text":"Error Handling Matrix","id":"error-handling-matrix"},{"level":2,"text":"Implementation Sequence with Checkpoints","id":"implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Stage 1 Bootloader Assembly (4-6 hours)","id":"phase-1-stage-1-bootloader-assembly-4-6-hours"},{"level":3,"text":"Phase 2: A20 Line Enablement (2-3 hours)","id":"phase-2-a20-line-enablement-2-3-hours"},{"level":3,"text":"Phase 3: GDT Configuration and Loading (3-4 hours)","id":"phase-3-gdt-configuration-and-loading-3-4-hours"},{"level":3,"text":"Phase 4: Protected Mode Transition (2-3 hours)","id":"phase-4-protected-mode-transition-2-3-hours"},{"level":3,"text":"Phase 5: Kernel Loader (3-4 hours)","id":"phase-5-kernel-loader-3-4-hours"},{"level":3,"text":"Phase 6: Kernel Entry Shim (2-3 hours)","id":"phase-6-kernel-entry-shim-2-3-hours"},{"level":3,"text":"Phase 7: Linker Script Design (2-3 hours)","id":"phase-7-linker-script-design-2-3-hours"},{"level":3,"text":"Final Integration (2-3 hours)","id":"final-integration-2-3-hours"},{"level":2,"text":"Test Specification","id":"test-specification"},{"level":3,"text":"Test 1: Boot Signature Valid","id":"test-1-boot-signature-valid"},{"level":3,"text":"Test 2: GDT Structure Valid","id":"test-2-gdt-structure-valid"},{"level":3,"text":"Test 3: Protected Mode Entry","id":"test-3-protected-mode-entry"},{"level":3,"text":"Test 4: Kernel Load Address","id":"test-4-kernel-load-address"},{"level":3,"text":"Test 5: BSS Zeroing","id":"test-5-bss-zeroing"},{"level":3,"text":"Test 6: Serial Output","id":"test-6-serial-output"},{"level":3,"text":"Test 7: VGA Output","id":"test-7-vga-output"},{"level":2,"text":"Performance Targets","id":"performance-targets"},{"level":2,"text":"Visual Diagrams","id":"visual-diagrams"},{"level":3,"text":"Boot Sequence","id":"boot-sequence"},{"level":3,"text":"GDT Structure","id":"gdt-structure"},{"level":3,"text":"Protected Mode Transition","id":"protected-mode-transition"},{"level":3,"text":"Triple Fault Chain","id":"triple-fault-chain"},{"level":2,"text":"Hardware Soul","id":"hardware-soul"},{"level":3,"text":"Cache Lines Touched","id":"cache-lines-touched"},{"level":3,"text":"Pipeline Behavior","id":"pipeline-behavior"},{"level":3,"text":"Memory Access Patterns","id":"memory-access-patterns"},{"level":3,"text":"I/O Port Access","id":"io-port-access"},{"level":2,"text":"Implementation Notes","id":"implementation-notes"},{"level":3,"text":"Stage 1 Size Optimization","id":"stage-1-size-optimization"},{"level":3,"text":"Two-Stage vs Direct Kernel Load","id":"two-stage-vs-direct-kernel-load"},{"level":3,"text":"Debugging with QEMU","id":"debugging-with-qemu"},{"level":1,"text":"Technical Design Specification: Interrupt and Exception Handling","id":"technical-design-specification-interrupt-and-exception-handling"},{"level":2,"text":"Module Charter","id":"module-charter"},{"level":2,"text":"File Structure","id":"file-structure"},{"level":2,"text":"Complete Data Model","id":"complete-data-model"},{"level":3,"text":"IDT Entry Structure (8 bytes)","id":"idt-entry-structure-8-bytes"},{"level":3,"text":"IDTR (6 bytes)","id":"idtr-6-bytes"},{"level":3,"text":"Register Frame Structure","id":"register-frame-structure"},{"level":3,"text":"CPU Exception Vectors","id":"cpu-exception-vectors"},{"level":3,"text":"Error Code Format (for vectors 8, 10-14, 17)","id":"error-code-format-for-vectors-8-10-14-17"},{"level":3,"text":"PIC Configuration","id":"pic-configuration"},{"level":3,"text":"PIT Timer Configuration","id":"pit-timer-configuration"},{"level":3,"text":"Keyboard Buffer and Scancode Table","id":"keyboard-buffer-and-scancode-table"},{"level":2,"text":"Interface Contracts","id":"interface-contracts"},{"level":3,"text":"idt_init()","id":"idt_init"},{"level":3,"text":"idt_set_gate(uint8_t num, uint32_t handler, uint16_t sel, uint8_t flags)","id":"idt_set_gateuint8_t-num-uint32_t-handler-uint16_t-sel-uint8_t-flags"},{"level":3,"text":"isr_handler(registers_t *regs) [C function called from assembly]","id":"isr_handlerregisters_t-regs-c-function-called-from-assembly"},{"level":3,"text":"irq_handler(registers_t *regs) [C function called from assembly]","id":"irq_handlerregisters_t-regs-c-function-called-from-assembly"},{"level":3,"text":"pic_remap(uint8_t offset1, uint8_t offset2)","id":"pic_remapuint8_t-offset1-uint8_t-offset2"},{"level":3,"text":"pic_send_eoi(uint8_t irq)","id":"pic_send_eoiuint8_t-irq"},{"level":3,"text":"pic_mask_irq(uint8_t irq)","id":"pic_mask_irquint8_t-irq"},{"level":3,"text":"pic_unmask_irq(uint8_t irq)","id":"pic_unmask_irquint8_t-irq"},{"level":3,"text":"timer_init(uint32_t frequency)","id":"timer_inituint32_t-frequency"},{"level":3,"text":"timer_handler(void)","id":"timer_handlervoid"},{"level":3,"text":"keyboard_init(void)","id":"keyboard_initvoid"},{"level":3,"text":"keyboard_handler(void)","id":"keyboard_handlervoid"},{"level":3,"text":"kb_getchar(void)","id":"kb_getcharvoid"},{"level":2,"text":"Algorithm Specification","id":"algorithm-specification"},{"level":3,"text":"IDT Initialization","id":"idt-initialization"},{"level":3,"text":"Setting an IDT Gate","id":"setting-an-idt-gate"},{"level":3,"text":"Assembly ISR Stub (exceptions without error code)","id":"assembly-isr-stub-exceptions-without-error-code"},{"level":3,"text":"Assembly ISR Stub (exceptions with error code)","id":"assembly-isr-stub-exceptions-with-error-code"},{"level":3,"text":"Common ISR Stub","id":"common-isr-stub"},{"level":3,"text":"Common IRQ Stub","id":"common-irq-stub"},{"level":3,"text":"PIC Remapping Sequence","id":"pic-remapping-sequence"},{"level":3,"text":"EOI Sending","id":"eoi-sending"},{"level":3,"text":"PIT Timer Initialization","id":"pit-timer-initialization"},{"level":3,"text":"Keyboard Handler","id":"keyboard-handler"},{"level":3,"text":"Double Fault Handler","id":"double-fault-handler"},{"level":2,"text":"Error Handling Matrix","id":"error-handling-matrix"},{"level":2,"text":"State Machine: Keyboard Scancode Parsing","id":"state-machine-keyboard-scancode-parsing"},{"level":2,"text":"Implementation Sequence with Checkpoints","id":"implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: IDT Structure and Loading (2-3 hours)","id":"phase-1-idt-structure-and-loading-2-3-hours"},{"level":3,"text":"Phase 2: Assembly ISR Stubs (3-4 hours)","id":"phase-2-assembly-isr-stubs-3-4-hours"},{"level":3,"text":"Phase 3: Register Frame and C Handler (2-3 hours)","id":"phase-3-register-frame-and-c-handler-2-3-hours"},{"level":3,"text":"Phase 4: PIC Remapping (2-3 hours)","id":"phase-4-pic-remapping-2-3-hours"},{"level":3,"text":"Phase 5: IRQ Handlers with EOI (2-3 hours)","id":"phase-5-irq-handlers-with-eoi-2-3-hours"},{"level":3,"text":"Phase 6: PIT Timer Driver (2-3 hours)","id":"phase-6-pit-timer-driver-2-3-hours"},{"level":3,"text":"Phase 7: PS/2 Keyboard Driver (3-4 hours)","id":"phase-7-ps2-keyboard-driver-3-4-hours"},{"level":3,"text":"Phase 8: Double Fault Handler (1-2 hours)","id":"phase-8-double-fault-handler-1-2-hours"},{"level":3,"text":"Final Integration (2-3 hours)","id":"final-integration-2-3-hours"},{"level":2,"text":"Test Specification","id":"test-specification"},{"level":3,"text":"Test 1: IDT Loads Without Crash","id":"test-1-idt-loads-without-crash"},{"level":3,"text":"Test 2: PIC Remaps Correctly","id":"test-2-pic-remaps-correctly"},{"level":3,"text":"Test 3: Timer Fires at Correct Frequency","id":"test-3-timer-fires-at-correct-frequency"},{"level":3,"text":"Test 4: Keyboard Buffer Works","id":"test-4-keyboard-buffer-works"},{"level":3,"text":"Test 5: Exception Handlers Print Diagnostics","id":"test-5-exception-handlers-print-diagnostics"},{"level":3,"text":"Test 6: EOI is Sent","id":"test-6-eoi-is-sent"},{"level":3,"text":"Test 7: Double Fault Caught","id":"test-7-double-fault-caught"},{"level":2,"text":"Performance Targets","id":"performance-targets"},{"level":2,"text":"Hardware Soul","id":"hardware-soul"},{"level":3,"text":"Cache Lines Touched","id":"cache-lines-touched"},{"level":3,"text":"Branch Prediction","id":"branch-prediction"},{"level":3,"text":"I/O Port Access","id":"io-port-access"},{"level":3,"text":"TLB Considerations","id":"tlb-considerations"},{"level":3,"text":"Interrupt Latency Components","id":"interrupt-latency-components"},{"level":2,"text":"Concurrency Specification","id":"concurrency-specification"},{"level":3,"text":"Interrupt Context","id":"interrupt-context"},{"level":3,"text":"Shared Data","id":"shared-data"},{"level":3,"text":"Critical Sections","id":"critical-sections"},{"level":3,"text":"Re-entrancy","id":"re-entrancy"},{"level":2,"text":"Implementation Notes","id":"implementation-notes"},{"level":3,"text":"Register Save Order","id":"register-save-order"},{"level":3,"text":"Error Code Handling","id":"error-code-handling"},{"level":3,"text":"PIC Mask Management","id":"pic-mask-management"},{"level":3,"text":"Extended Scancodes","id":"extended-scancodes"},{"level":2,"text":"Visual Diagrams","id":"visual-diagrams"},{"level":3,"text":"IDT Entry Structure","id":"idt-entry-structure"},{"level":3,"text":"Interrupt Stack Frame","id":"interrupt-stack-frame"},{"level":3,"text":"PIC Remapping","id":"pic-remapping"},{"level":3,"text":"Exception Vectors and Error Codes","id":"exception-vectors-and-error-codes"},{"level":3,"text":"Keyboard Scancode Flow","id":"keyboard-scancode-flow"},{"level":3,"text":"ISR State Machine","id":"isr-state-machine"},{"level":1,"text":"Technical Design Specification: Physical and Virtual Memory Management","id":"technical-design-specification-physical-and-virtual-memory-management"},{"level":2,"text":"Module Charter","id":"module-charter"},{"level":2,"text":"File Structure","id":"file-structure"},{"level":2,"text":"Complete Data Model","id":"complete-data-model"},{"level":3,"text":"E820 Memory Map Entry (20 bytes)","id":"e820-memory-map-entry-20-bytes"},{"level":3,"text":"Multiboot Memory Map Header","id":"multiboot-memory-map-header"},{"level":3,"text":"Frame Allocator State","id":"frame-allocator-state"},{"level":3,"text":"Page Directory/Table Entry (4 bytes each)","id":"page-directorytable-entry-4-bytes-each"},{"level":3,"text":"Page Directory and Page Table Structures","id":"page-directory-and-page-table-structures"},{"level":3,"text":"Heap Block Header","id":"heap-block-header"},{"level":3,"text":"Memory Layout Constants","id":"memory-layout-constants"},{"level":2,"text":"Interface Contracts","id":"interface-contracts"},{"level":3,"text":"e820_init(multiboot_info_t *mbi)","id":"e820_initmultiboot_info_t-mbi"},{"level":3,"text":"frame_allocator_init(void)","id":"frame_allocator_initvoid"},{"level":3,"text":"alloc_frame(void)","id":"alloc_framevoid"},{"level":3,"text":"free_frame(void *addr)","id":"free_framevoid-addr"},{"level":3,"text":"paging_init(void)","id":"paging_initvoid"},{"level":3,"text":"map_page(page_directory_t *dir, uint32_t vaddr, uint32_t paddr, uint32_t flags)","id":"map_pagepage_directory_t-dir-uint32_t-vaddr-uint32_t-paddr-uint32_t-flags"},{"level":3,"text":"unmap_page(page_directory_t *dir, uint32_t vaddr)","id":"unmap_pagepage_directory_t-dir-uint32_t-vaddr"},{"level":3,"text":"get_physical(page_directory_t *dir, uint32_t vaddr)","id":"get_physicalpage_directory_t-dir-uint32_t-vaddr"},{"level":3,"text":"kmalloc(uint32_t size)","id":"kmallocuint32_t-size"},{"level":3,"text":"kfree(void *ptr)","id":"kfreevoid-ptr"},{"level":2,"text":"Algorithm Specification","id":"algorithm-specification"},{"level":3,"text":"Memory Map Parsing","id":"memory-map-parsing"},{"level":3,"text":"Frame Allocator Initialization","id":"frame-allocator-initialization"},{"level":3,"text":"Frame Allocation (Bitmap Scan)","id":"frame-allocation-bitmap-scan"},{"level":3,"text":"Frame Freeing","id":"frame-freeing"},{"level":3,"text":"Page Mapping","id":"page-mapping"},{"level":3,"text":"Page Unmapping","id":"page-unmapping"},{"level":3,"text":"Identity and Higher-Half Mapping","id":"identity-and-higher-half-mapping"},{"level":3,"text":"Page Fault Handler","id":"page-fault-handler"},{"level":3,"text":"Kernel Heap Allocation","id":"kernel-heap-allocation"},{"level":3,"text":"Kernel Heap Freeing","id":"kernel-heap-freeing"},{"level":2,"text":"Error Handling Matrix","id":"error-handling-matrix"},{"level":2,"text":"Implementation Sequence with Checkpoints","id":"implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Memory Map Parser (3-4 hours)","id":"phase-1-memory-map-parser-3-4-hours"},{"level":3,"text":"Phase 2: Bitmap Frame Allocator (4-5 hours)","id":"phase-2-bitmap-frame-allocator-4-5-hours"},{"level":3,"text":"Phase 3: Page Table Structures (3-4 hours)","id":"phase-3-page-table-structures-3-4-hours"},{"level":3,"text":"Phase 4: map_page/unmap_page (4-5 hours)","id":"phase-4-map_pageunmap_page-4-5-hours"},{"level":3,"text":"Phase 5: Identity Mapping (2-3 hours)","id":"phase-5-identity-mapping-2-3-hours"},{"level":3,"text":"Phase 6: Higher-Half Kernel Mapping (3-4 hours)","id":"phase-6-higher-half-kernel-mapping-3-4-hours"},{"level":3,"text":"Phase 7: Paging Enablement Sequence (2-3 hours)","id":"phase-7-paging-enablement-sequence-2-3-hours"},{"level":3,"text":"Phase 8: Page Fault Handler (2-3 hours)","id":"phase-8-page-fault-handler-2-3-hours"},{"level":3,"text":"Phase 9: Kernel Heap (5-7 hours)","id":"phase-9-kernel-heap-5-7-hours"},{"level":3,"text":"Final Integration (2-3 hours)","id":"final-integration-2-3-hours"},{"level":2,"text":"Test Specification","id":"test-specification"},{"level":3,"text":"Test 1: Memory Map Parsing","id":"test-1-memory-map-parsing"},{"level":3,"text":"Test 2: Frame Allocation","id":"test-2-frame-allocation"},{"level":3,"text":"Test 3: Double-Free Detection","id":"test-3-double-free-detection"},{"level":3,"text":"Test 4: Page Mapping","id":"test-4-page-mapping"},{"level":3,"text":"Test 5: Paging Enablement","id":"test-5-paging-enablement"},{"level":3,"text":"Test 6: Heap Allocation","id":"test-6-heap-allocation"},{"level":3,"text":"Test 7: Heap Coalescing","id":"test-7-heap-coalescing"},{"level":3,"text":"Test 8: Page Fault Diagnostics","id":"test-8-page-fault-diagnostics"},{"level":2,"text":"Performance Targets","id":"performance-targets"},{"level":2,"text":"Hardware Soul","id":"hardware-soul"},{"level":3,"text":"Cache Lines Touched","id":"cache-lines-touched"},{"level":3,"text":"TLB Behavior","id":"tlb-behavior"},{"level":3,"text":"Memory Access Patterns","id":"memory-access-patterns"},{"level":3,"text":"Physical Reality","id":"physical-reality"},{"level":2,"text":"Concurrency Specification","id":"concurrency-specification"},{"level":3,"text":"Current Model: Single-Threaded","id":"current-model-single-threaded"},{"level":3,"text":"Critical Sections (Future-Proofing)","id":"critical-sections-future-proofing"},{"level":3,"text":"Lock-Free Keyboard Buffer (Already Implemented)","id":"lock-free-keyboard-buffer-already-implemented"},{"level":2,"text":"Visual Diagrams","id":"visual-diagrams"},{"level":3,"text":"Page Table Hierarchy","id":"page-table-hierarchy"},{"level":3,"text":"Page Directory/Table Entry Bits","id":"page-directorytable-entry-bits"},{"level":3,"text":"E820 Memory Map","id":"e820-memory-map"},{"level":3,"text":"Identity + Higher-Half Mapping","id":"identity-higher-half-mapping"},{"level":3,"text":"Paging Enable Sequence","id":"paging-enable-sequence"},{"level":3,"text":"Page Fault Handler Flow","id":"page-fault-handler-flow"},{"level":3,"text":"kmalloc Internals","id":"kmalloc-internals"},{"level":1,"text":"Technical Design Specification: Process Management and Preemptive Scheduling","id":"technical-design-specification-process-management-and-preemptive-scheduling"},{"level":2,"text":"Module Charter","id":"module-charter"},{"level":2,"text":"File Structure","id":"file-structure"},{"level":2,"text":"Complete Data Model","id":"complete-data-model"},{"level":3,"text":"Process Control Block (PCB)","id":"process-control-block-pcb"},{"level":3,"text":"Task State Segment (TSS)","id":"task-state-segment-tss"},{"level":3,"text":"System Call Numbers","id":"system-call-numbers"},{"level":3,"text":"Scheduler Data Structures","id":"scheduler-data-structures"},{"level":2,"text":"Interface Contracts","id":"interface-contracts"},{"level":3,"text":"process_create(const char *name, void (*entry)(void), int is_user)","id":"process_createconst-char-name-void-entryvoid-int-is_user"},{"level":3,"text":"process_exit(int status)","id":"process_exitint-status"},{"level":3,"text":"context_switch(process_t *old, process_t *new)","id":"context_switchprocess_t-old-process_t-new"},{"level":3,"text":"tss_init(void)","id":"tss_initvoid"},{"level":3,"text":"tss_set_esp0(uint32_t esp0)","id":"tss_set_esp0uint32_t-esp0"},{"level":3,"text":"scheduler_init(void)","id":"scheduler_initvoid"},{"level":3,"text":"scheduler_tick(void)","id":"scheduler_tickvoid"},{"level":3,"text":"scheduler_yield(void)","id":"scheduler_yieldvoid"},{"level":3,"text":"enter_user_mode(uint32_t entry, uint32_t stack)","id":"enter_user_modeuint32_t-entry-uint32_t-stack"},{"level":3,"text":"syscall_handler(registers_t *regs)","id":"syscall_handlerregisters_t-regs"},{"level":2,"text":"Algorithm Specification","id":"algorithm-specification"},{"level":3,"text":"Process Creation","id":"process-creation"},{"level":3,"text":"Context Switch (Assembly)","id":"context-switch-assembly"},{"level":3,"text":"TSS Initialization","id":"tss-initialization"},{"level":3,"text":"Round-Robin Scheduler","id":"round-robin-scheduler"},{"level":3,"text":"System Call Dispatch","id":"system-call-dispatch"},{"level":3,"text":"Enter User Mode","id":"enter-user-mode"},{"level":2,"text":"Error Handling Matrix","id":"error-handling-matrix"},{"level":2,"text":"State Machine: Process Lifecycle","id":"state-machine-process-lifecycle"},{"level":2,"text":"Concurrency Specification","id":"concurrency-specification"},{"level":3,"text":"Preemptive Multitasking Model","id":"preemptive-multitasking-model"},{"level":3,"text":"Critical Sections","id":"critical-sections"},{"level":3,"text":"Interrupt Safety in Handlers","id":"interrupt-safety-in-handlers"},{"level":3,"text":"Per-Process Data Protection","id":"per-process-data-protection"},{"level":3,"text":"Lock-Free Queue Access","id":"lock-free-queue-access"},{"level":2,"text":"Implementation Sequence with Checkpoints","id":"implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: PCB Structure Definition (2-3 hours)","id":"phase-1-pcb-structure-definition-2-3-hours"},{"level":3,"text":"Phase 2: Process Creation (Kernel Mode) (3-4 hours)","id":"phase-2-process-creation-kernel-mode-3-4-hours"},{"level":3,"text":"Phase 3: Context Switch Assembly (5-7 hours)","id":"phase-3-context-switch-assembly-5-7-hours"},{"level":3,"text":"Phase 4: TSS Initialization (3-4 hours)","id":"phase-4-tss-initialization-3-4-hours"},{"level":3,"text":"Phase 5: Round-Robin Scheduler (4-5 hours)","id":"phase-5-round-robin-scheduler-4-5-hours"},{"level":3,"text":"Phase 6: Timer Interrupt Integration (2-3 hours)","id":"phase-6-timer-interrupt-integration-2-3-hours"},{"level":3,"text":"Phase 7: Multi-Process Kernel Demo (2-3 hours)","id":"phase-7-multi-process-kernel-demo-2-3-hours"},{"level":3,"text":"Phase 8: User-Mode Process Creation (4-5 hours)","id":"phase-8-user-mode-process-creation-4-5-hours"},{"level":3,"text":"Phase 9: Enter User Mode via iret (2-3 hours)","id":"phase-9-enter-user-mode-via-iret-2-3-hours"},{"level":3,"text":"Phase 10: System Call Interface (4-5 hours)","id":"phase-10-system-call-interface-4-5-hours"},{"level":3,"text":"Phase 11: sys_write and sys_exit (2-3 hours)","id":"phase-11-sys_write-and-sys_exit-2-3-hours"},{"level":3,"text":"Final Integration (3-4 hours)","id":"final-integration-3-4-hours"},{"level":2,"text":"Test Specification","id":"test-specification"},{"level":3,"text":"Test 1: PCB Structure Layout","id":"test-1-pcb-structure-layout"},{"level":3,"text":"Test 2: Process Creation","id":"test-2-process-creation"},{"level":3,"text":"Test 3: Context Switch","id":"test-3-context-switch"},{"level":3,"text":"Test 4: TSS Configuration","id":"test-4-tss-configuration"},{"level":3,"text":"Test 5: Scheduler Round-Robin","id":"test-5-scheduler-round-robin"},{"level":3,"text":"Test 6: User Mode Entry","id":"test-6-user-mode-entry"},{"level":3,"text":"Test 7: Syscall Dispatch","id":"test-7-syscall-dispatch"},{"level":3,"text":"Test 8: User Process Isolation","id":"test-8-user-process-isolation"},{"level":3,"text":"Test 9: Multi-Process Demo","id":"test-9-multi-process-demo"},{"level":2,"text":"Performance Targets","id":"performance-targets"},{"level":2,"text":"Hardware Soul","id":"hardware-soul"},{"level":3,"text":"Cache Lines Touched","id":"cache-lines-touched"},{"level":3,"text":"Branch Prediction","id":"branch-prediction"},{"level":3,"text":"TLB Behavior","id":"tlb-behavior"},{"level":3,"text":"Pipeline Impact","id":"pipeline-impact"},{"level":3,"text":"Cache Pollution","id":"cache-pollution"},{"level":2,"text":"Visual Diagrams","id":"visual-diagrams"},{"level":3,"text":"PCB Structure","id":"pcb-structure"},{"level":3,"text":"Context Switch Flow","id":"context-switch-flow"},{"level":3,"text":"TSS Structure","id":"tss-structure"},{"level":3,"text":"Ring Transition (User to Kernel)","id":"ring-transition-user-to-kernel"},{"level":3,"text":"Scheduler Queue","id":"scheduler-queue"},{"level":3,"text":"Multi-Process Demo","id":"multi-process-demo"},{"level":3,"text":"User-Kernel Memory Layout","id":"user-kernel-memory-layout"},{"level":3,"text":"System Call Interface","id":"system-call-interface"},{"level":2,"text":"x86 Architecture &amp; Boot Process","id":"x86-architecture-amp-boot-process"},{"level":2,"text":"Segmentation &amp; GDT","id":"segmentation-amp-gdt"},{"level":2,"text":"Interrupt Handling &amp; IDT","id":"interrupt-handling-amp-idt"},{"level":2,"text":"Physical Memory Management","id":"physical-memory-management"},{"level":2,"text":"x86 Paging &amp; Virtual Memory","id":"x86-paging-amp-virtual-memory"},{"level":2,"text":"Context Switching &amp; Scheduling","id":"context-switching-amp-scheduling"},{"level":2,"text":"The TSS &amp; Ring Transitions","id":"the-tss-amp-ring-transitions"},{"level":2,"text":"System Calls","id":"system-calls"},{"level":2,"text":"PS/2 Keyboard &amp; Hardware I/O","id":"ps2-keyboard-amp-hardware-io"},{"level":2,"text":"VGA Text Mode","id":"vga-text-mode"},{"level":2,"text":"Serial Port (Debugging Lifeline)","id":"serial-port-debugging-lifeline"},{"level":2,"text":"Debugging with QEMU &amp; GDB","id":"debugging-with-qemu-amp-gdb"},{"level":2,"text":"Linker Scripts &amp; Memory Layout","id":"linker-scripts-amp-memory-layout"},{"level":2,"text":"Reference Hierarchy","id":"reference-hierarchy"}],"title":"Build Your Own OS","markdown":"# Build Your Own OS\n\nThis project guides you through building a complete x86 operating system kernel from the first BIOS instruction to a preemptively multitasking system with user-mode processes. You will implement the critical path that every operating system must navigate: bootstrapping from firmware, configuring CPU data structures (GDT, IDT, TSS), managing physical and virtual memory, and implementing preemptive scheduling with privilege-level transitions.\n\nThe x86 architecture presents unique challenges—the transition from 16-bit real mode to 32-bit protected mode requires precise configuration of segmentation, paging, and interrupt handling. Every decision negotiates with hardware constraints: the 4KB page granularity, the 256 interrupt vectors, the privilege ring hierarchy, and the cache line boundaries that affect context switch performance.\n\nBy the end, you will understand not just how an OS works, but why it works that way—the physical and architectural forces that shaped these designs. This knowledge transfers directly to understanding container isolation, virtual machine introspection, real-time scheduling, and low-level security exploits.\n\n\n\n<!-- MS_ID: build-os-m1 -->\n# Milestone 1: Bootloader, GDT, and Kernel Entry\n\n## The Tension: Hardware Doesn't Want to Run Your Code\n\nWhen you press the power button, your 3GHz CPU with billions of transistors wakes up in a shockingly primitive state:\n\n- **16-bit mode** — only 64KB addressable per segment, 1MB total\n- **Real mode segmentation** — addresses computed as `segment * 16 + offset`\n- **No memory protection** — any code can overwrite anything\n- **BIOS in control** — interrupt vectors point to 16-bit BIOS routines\n\nYour kernel is 32-bit code expecting flat memory, protected segments, and C runtime conventions. The gap between these two worlds is not bridged by magic — you must build every plank of that bridge yourself.\n\n\n![x86 Boot Sequence: BIOS to C Entry](./diagrams/diag-boot-sequence.svg)\n\n\nThe numbers make this concrete:\n- BIOS loads exactly **512 bytes** from the disk's first sector — that's your entire stage 1 bootloader\n- The A20 line, disabled for IBM PC/XT compatibility, blocks addresses above 1MB — your kernel at 0x100000 is unreachable until you enable it\n- Entering protected mode without flushing the pipeline leaves the CPU decoding 16-bit instructions as 32-bit — instant crash\n\nThis milestone is about building the bootstrap sequence that transforms a 16-bit relic into a 32-bit modern CPU, then handing control to C code you wrote.\n\n---\n\n## System Map: Where We Are\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                         YOUR OS KERNEL                          │\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐              │\n│  │  Bootloader │→ │     GDT     │→ │  C Kernel   │              │\n│  │  (16-bit)   │  │ (Segments)  │  │  (32-bit)   │              │\n│  └─────────────┘  └─────────────┘  └─────────────┘              │\n│         ↓                ↓                ↓                     │\n│  ┌─────────────────────────────────────────────────────────────┐│\n│  │                    HARDWARE STATE                           ││\n│  │  Real Mode → Protected Mode → Paging (later)               ││\n│  │  CR0.PE=0  → CR0.PE=1      → CR0.PG=1                      ││\n│  └─────────────────────────────────────────────────────────────┘│\n└─────────────────────────────────────────────────────────────────┘\n```\n\nWe're building the left side: bootloader, GDT, and the protected mode transition. Without this, nothing else exists.\n\n---\n\n## The Boot Process: From Power-On to Your First Instruction\n\n### What the BIOS Does (So You Don't Have To)\n\nThe BIOS (Basic Input/Output System) — or its modern successor UEFI — performs essential hardware initialization:\n\n1. **POST** (Power-On Self-Test) — verifies RAM, CPU, and critical hardware\n2. **Hardware enumeration** — discovers disks, keyboards, display adapters\n3. **Boot device selection** — checks configured boot order\n4. **MBR load** — reads sector 0 (first 512 bytes) from the boot disk into memory at **0x7C00**\n5. **Jump to 0x7C00** — transfers control to your bootloader with `CS:IP = 0x0000:0x7C00`\n\nThe magic address 0x7C00 isn't arbitrary — it's in the original IBM PC memory map, placed low enough to be addressable in real mode but high enough to not conflict with BIOS data structures.\n\n### Your Bootloader's Job\n\n512 bytes. That's all you get for stage 1. In that space, you must:\n\n```asm\n; boot.asm - Stage 1 Bootloader (must fit in 512 bytes)\n[BITS 16]\n[ORG 0x7C00]\n\nstart:\n    ; Set up segments for real mode\n    xor ax, ax\n    mov ds, ax\n    mov es, ax\n    mov ss, ax\n    mov sp, 0x7C00          ; Stack grows down from bootloader\n\n    ; Enable A20 line (access memory above 1MB)\n    call enable_a20\n\n    ; Load stage 2 bootloader from disk\n    call load_stage2\n\n    ; Set up GDT\n    lgdt [gdt_descriptor]\n\n    ; Enter protected mode\n    mov eax, cr0\n    or eax, 1               ; Set PE bit (Protection Enable)\n    mov cr0, eax\n\n    ; Far jump to flush pipeline and load new CS\n    jmp 0x08:protected_mode_entry\n\n    ; ... GDT and helper functions follow ...\n\ntimes 510-($-$$) db 0       ; Pad to 510 bytes\ndw 0xAA55                   ; Boot signature (BIOS requires this)\n```\n\nThe boot signature `0xAA55` is the final checksum — the BIOS scans the last two bytes of sector 0 and only executes the code if it finds this signature. Without it, the BIOS moves to the next boot device.\n\n### The A20 Line: A Historical Anomaly You Must Handle\n\nThe A20 line is a quirk of PC history. The original 8086 had 20 address lines (A0-A19), addressing 1MB. Memory wrapped around — address 0x100000 (1MB + 0) accessed the same physical memory as 0x00000.\n\nIBM designed the PC/AT (286) with 24 address lines, but to maintain compatibility with 8086 software that relied on wraparound, they added a gate to disable A20. By default, **A20 is disabled**, meaning you cannot access memory above 1MB.\n\nYour kernel loads at 0x100000 — unreachable until you enable A20:\n\n```asm\nenable_a20:\n    ; Method 1: Fast A20 gate (port 0x92)\n    in al, 0x92\n    or al, 2\n    out 0x92, al\n    ret\n\n    ; Method 2: Keyboard controller (more reliable on old hardware)\n    ; ... involves sending commands to port 0x64/0x60 ...\n```\n\nThe fast A20 gate via port 0x92 works on most modern systems and virtual machines. For maximum compatibility, production bootloaders try multiple methods.\n\n---\n\n## Segmentation: The GDT and Why x86 Still Has It\n\n### The Tension: Why Segmentation Exists\n\nYou might wonder: why configure segments at all? Why not just use flat memory?\n\nThe answer lies in x86 history. The 8086 (1978) was a 16-bit processor needing to address more than 64KB. **Segmentation** was the solution: addresses are computed as `segment * 16 + offset`, giving 20-bit addresses (1MB).\n\nProtected mode (386, 1985) extended this with **segment descriptors** — rich metadata about each segment:\n- Base address (32-bit) — where the segment starts\n- Limit (20-bit) — how large the segment is\n- Access rights — readable? writable? executable?\n- Privilege level — ring 0 (kernel) or ring 3 (user)\n- Granularity — limit in bytes or 4KB pages\n\nThe **Global Descriptor Table (GDT)** is an array of these descriptors. The GDTR register holds the table's base address and limit. Every memory access uses a segment selector (index into GDT) combined with an offset.\n\n{{DIAGRAM:diag-gdt-structure}}\n\n### The Flat Memory Model: Your Goal\n\nFor a modern OS, you want **flat segmentation** — segments with base=0, limit=4GB. This makes segmentation transparent; logical addresses equal linear addresses. Paging (which you'll add in Milestone 3) handles the real memory protection and isolation.\n\nYour GDT needs five entries:\n\n| Index | Type | Base | Limit | Privilege | Purpose |\n|-------|------|------|-------|-----------|---------|\n| 0 | Null | 0 | 0 | — | Required by CPU |\n| 1 | Code | 0 | 4GB | Ring 0 | Kernel code |\n| 2 | Data | 0 | 4GB | Ring 0 | Kernel data |\n| 3 | Code | 0 | 4GB | Ring 3 | User code |\n| 4 | Data | 0 | 4GB | Ring 3 | User data |\n\nThe null descriptor (index 0) is mandatory — the CPU uses selector 0 as a \"null selector\" for error conditions. Loading a segment register with 0 doesn't cause a fault, but using it for memory access will.\n\n### GDT Entry Structure: 64 Bits of Configuration\n\nEach GDT entry is 8 bytes (64 bits), packed with specific fields:\n\n```\nByte 0-1:  Limit [15:0]      (bits 0-15 of limit)\nByte 2-3:  Base [15:0]       (bits 0-15 of base)\nByte 4:    Base [23:16]      (bits 16-23 of base)\nByte 5:    Access Byte       (present, ring, type flags)\nByte 6:    Flags + Limit[19:16]\nByte 7:    Base [31:24]      (bits 24-31 of base)\n```\n\nThe **access byte** (byte 5) controls privilege and type:\n\n```\nBit 7: Present (1 = segment exists)\nBit 6-5: DPL (Descriptor Privilege Level: 00=ring 0, 11=ring 3)\nBit 4: S (System: 1=code/data, 0=system like TSS)\nBit 3: Type bit 3 (Executable: 1=code, 0=data)\nBit 2: Type bit 2 (Direction/Conforming for code, Expand-down for data)\nBit 1: Type bit 1 (Readable for code, Writable for data)\nBit 0: Accessed (CPU sets this when segment is accessed)\n```\n\nThe **flags byte** (high 4 bits of byte 6):\n\n```\nBit 7: Granularity (0=limit in bytes, 1=limit in 4KB pages)\nBit 6: Size (0=16-bit, 1=32-bit)\nBit 5: Long (1=64-bit code segment for x86-64)\nBit 4: Reserved\n```\n\nHere's a concrete GDT setup:\n\n```asm\ngdt_start:\n    ; Null descriptor (required)\n    dq 0x0000000000000000\n\ngdt_code_kernel:             ; Index 1: Kernel code segment\n    ; Base=0, Limit=0xFFFFF, 4KB granularity, 32-bit, ring 0, executable+readable\n    dw 0xFFFF               ; Limit [15:0]\n    dw 0x0000               ; Base [15:0]\n    db 0x00                 ; Base [23:16]\n    db 10011010b            ; Present, ring 0, code, executable, readable\n    db 11001111b            ; 4KB granularity, 32-bit, Limit [19:16]\n    db 0x00                 ; Base [31:24]\n\ngdt_data_kernel:             ; Index 2: Kernel data segment\n    ; Base=0, Limit=0xFFFFF, 4KB granularity, 32-bit, ring 0, writable\n    dw 0xFFFF\n    dw 0x0000\n    db 0x00\n    db 10010010b            ; Present, ring 0, data, writable\n    db 11001111b\n    db 0x00\n\ngdt_code_user:               ; Index 3: User code segment (ring 3)\n    dw 0xFFFF\n    dw 0x0000\n    db 0x00\n    db 11111010b            ; Present, ring 3 (DPL=11), code, executable, readable\n    db 11001111b\n    db 0x00\n\ngdt_data_user:               ; Index 4: User data segment (ring 3)\n    dw 0xFFFF\n    dw 0x0000\n    db 0x00\n    db 11110010b            ; Present, ring 3, data, writable\n    db 11001111b\n    db 0x00\n\ngdt_descriptor:\n    dw gdt_descriptor - gdt_start - 1  ; Size (limit)\n    dd gdt_start                        ; Base address\n```\n\nThe segment selectors (what you load into segment registers) are computed as:\n\n```\nSelector = (Index << 3) | (TI << 2) | RPL\n\nWhere:\n  Index = position in GDT (0, 1, 2, ...)\n  TI = Table Indicator (0=GDT, 1=LDT — you'll use 0)\n  RPL = Requested Privilege Level (0 or 3)\n\nKernel code selector = (1 << 3) | 0 = 0x08\nKernel data selector = (2 << 3) | 0 = 0x10\nUser code selector = (3 << 3) | 3 = 0x1B\nUser data selector = (4 << 3) | 3 = 0x23\n```\n\n---\n\n## The Protected Mode Transition: A Precise Sequence\n\n\n![Protected Mode Transition: Before and After](./diagrams/diag-protected-mode-transition.svg)\n\n\nEntering protected mode isn't a single instruction — it's a sequence where getting any step wrong causes a **triple fault** (CPU exception → handler crashes → double fault → handler crashes → triple fault → CPU reset).\n\n### Step-by-Step Transition\n\n```asm\n; 1. Disable interrupts (CRITICAL — real-mode IVT is now invalid)\ncli\n\n; 2. Load the GDT\nlgdt [gdt_descriptor]\n\n; 3. Enable protected mode\nmov eax, cr0\nor eax, 1                ; Set PE (Protection Enable) bit\nmov cr0, eax\n\n; 4. Far jump to flush the pipeline and load CS with kernel code selector\njmp 0x08:protected_mode_entry\n\n[BITS 32]\nprotected_mode_entry:\n    ; 5. Now in 32-bit protected mode! Reload segment registers.\n    mov ax, 0x10         ; Kernel data selector\n    mov ds, ax\n    mov es, ax\n    mov fs, ax\n    mov gs, ax\n    mov ss, ax\n    mov esp, 0x90000     ; Set up kernel stack (below 1MB for now)\n\n    ; 6. Jump to kernel C entry point\n    jmp 0x08:0x100000    ; Kernel loaded at 1MB physical\n```\n\n### Why Each Step Matters\n\n**Disable interrupts (`cli`)**: The real-mode IVT (Interrupt Vector Table) at 0x0-0x3FF contains BIOS interrupt handlers. Once you enter protected mode, these addresses are interpreted completely differently. An interrupt before you set up the IDT (Milestone 2) will crash.\n\n**Load GDT (`lgdt`)**: The CPU needs to know where segment descriptors live. This must happen *before* setting CR0.PE.\n\n**Set CR0.PE**: This is the actual mode switch. But the pipeline still contains 16-bit instructions decoded as 16-bit.\n\n**Far jump**: `jmp 0x08:protected_mode_entry` does two things:\n1. Loads CS with selector 0x08 (kernel code segment)\n2. Flushes the prefetch queue (pipeline), forcing fresh instruction fetch in 32-bit mode\n\nWithout this jump, the CPU continues executing what it thinks are 16-bit instructions, but they're actually your 32-bit code — garbage execution.\n\n**Reload segment registers**: After the far jump, CS is valid, but DS/ES/FS/GS/SS still contain real-mode values. Loading them with the kernel data selector (0x10) ensures all memory access uses your flat segments.\n\n---\n\n## Loading the Kernel from Disk\n\nThe stage 1 bootloader (512 bytes) usually loads a larger stage 2, which then loads the kernel. BIOS interrupt **INT 13h** provides disk access in real mode:\n\n```asm\nload_kernel:\n    ; Reset disk system\n    xor ah, ah\n    xor dl, dl            ; dl = boot drive number (passed by BIOS)\n    int 0x13\n\n    ; Read sectors using CHS (Cylinder-Head-Sector) addressing\n    ; ah=02h (read), al=number of sectors, ch=cylinder, cl=sector, dh=head, dl=drive\n    mov ah, 0x02\n    mov al, 32            ; Read 32 sectors (16KB — adjust based on kernel size)\n    mov ch, 0             ; Cylinder 0\n    mov cl, 2             ; Start at sector 2 (sector 1 is the MBR)\n    mov dh, 0             ; Head 0\n    mov dl, [boot_drive]\n    mov bx, 0x100000      ; Destination: 1MB (es:bx = destination)\n    mov es, bx\n    xor bx, bx\n    int 0x13\n    jc disk_error         ; Carry flag set on error\n\n    ret\n\nboot_drive: db 0\n```\n\nThe destination 0x100000 (1MB) is traditional — it's the first available memory above the low memory region used by BIOS and real-mode structures.\n\n---\n\n## The Linker Script: Where Code Lives in Memory\n\nYour C kernel doesn't know its own addresses — the linker decides where every function and variable lives. The linker script controls this.\n\n\n![Kernel Memory Map: Linker Script Layout](./diagrams/diag-linker-script.svg)\n\n\n```ld\n/* linker.ld */\nENTRY(kernel_entry)\n\nSECTIONS\n{\n    /* Kernel starts at 1MB physical */\n    . = 0x100000;\n\n    .text : {\n        *(.multiboot)      /* Multiboot header if using GRUB */\n        *(.text)\n    }\n\n    .rodata : {\n        *(.rodata)\n    }\n\n    .data : {\n        *(.data)\n    }\n\n    .bss : {\n        __bss_start = .;\n        *(COMMON)\n        *(.bss)\n        __bss_end = .;\n    }\n\n    /DISCARD/ : {\n        *(.comment)\n        *(.eh_frame)\n    }\n}\n```\n\nThe symbols `__bss_start` and `__bss_end` are crucial — they mark the range of uninitialized global/static variables that must be zeroed at startup. In a hosted C environment, the C runtime (crt0) does this. In your kernel, you do it.\n\n---\n\n## The C Entry Point: No Runtime, No Safety Net\n\nWhen control reaches your C code, you have:\n\n- **No zeroed BSS** — uninitialized globals contain garbage\n- **No initialized globals** — the loader handles .data, but verify this\n- **No stack setup** — you set SS:ESP in assembly\n- **No libc** — no printf, no malloc, no memcpy\n\nHere's a minimal kernel entry:\n\n```c\n/* kernel_entry.asm — called from bootloader */\n[BITS 32]\nextern kernel_main\nglobal kernel_entry\n\nkernel_entry:\n    ; Set up stack (if not already done)\n    mov esp, 0x90000\n\n    ; Zero the BSS section\n    extern __bss_start\n    extern __bss_end\n    mov edi, __bss_start\n    mov ecx, __bss_end\n    sub ecx, edi\n    xor eax, eax\n    rep stosb\n\n    ; Call kernel main\n    call kernel_main\n\n    ; Halt if kernel_main returns\n.halt:\n    cli\n    hlt\n    jmp .halt\n```\n\n```c\n/* kernel_main.c */\nvoid kernel_main(void) {\n    // At this point: GDT is loaded, protected mode is active,\n    // BSS is zeroed, stack is valid\n    \n    // Initialize VGA text mode (0xB8000)\n    vga_init();\n    vga_puts(\"Welcome to MyOS!\\n\");\n    \n    // Initialize serial port for debug output\n    serial_init(COM1_PORT);\n    serial_puts(COM1_PORT, \"Kernel booted successfully.\\n\");\n    \n    // Your OS begins here...\n    while (1) {\n        asm volatile(\"hlt\");\n    }\n}\n```\n\n---\n\n## VGA Text Mode: Your First Display Driver\n\nThe VGA text buffer at **0xB8000** is memory-mapped I/O — writing to this address displays characters on screen. Each character is 2 bytes:\n\n```\nByte 0: ASCII character\nByte 1: Attribute byte:\n  - Bits 0-3: Foreground color (0-15)\n  - Bits 4-6: Background color (0-7)\n  - Bit 7: Blink (or bright background if enabled)\n```\n\n```c\n#define VGA_BUFFER ((volatile uint16_t*)0xB8000)\n#define VGA_WIDTH 80\n#define VGA_HEIGHT 25\n\nstatic int vga_row = 0;\nstatic int vga_col = 0;\n\ntypedef enum {\n    VGA_BLACK = 0,\n    VGA_BLUE = 1,\n    VGA_GREEN = 2,\n    VGA_CYAN = 3,\n    VGA_RED = 4,\n    VGA_MAGENTA = 5,\n    VGA_BROWN = 6,\n    VGA_LIGHT_GREY = 7,\n    // ... more colors\n} vga_color;\n\nstatic inline uint16_t vga_entry(char c, uint8_t fg, uint8_t bg) {\n    return (uint16_t)c | ((uint16_t)(fg | (bg << 4)) << 8);\n}\n\nvoid vga_putchar(char c) {\n    if (c == '\\n') {\n        vga_col = 0;\n        vga_row++;\n        return;\n    }\n    \n    VGA_BUFFER[vga_row * VGA_WIDTH + vga_col] = vga_entry(c, VGA_LIGHT_GREY, VGA_BLACK);\n    vga_col++;\n    \n    if (vga_col >= VGA_WIDTH) {\n        vga_col = 0;\n        vga_row++;\n    }\n    \n    if (vga_row >= VGA_HEIGHT) {\n        // Scroll (copy all rows up by one)\n        for (int i = 0; i < (VGA_HEIGHT - 1) * VGA_WIDTH; i++) {\n            VGA_BUFFER[i] = VGA_BUFFER[i + VGA_WIDTH];\n        }\n        // Clear last row\n        for (int i = (VGA_HEIGHT - 1) * VGA_WIDTH; i < VGA_HEIGHT * VGA_WIDTH; i++) {\n            VGA_BUFFER[i] = vga_entry(' ', VGA_LIGHT_GREY, VGA_BLACK);\n        }\n        vga_row = VGA_HEIGHT - 1;\n    }\n}\n```\n\n---\n\n## Serial Port Debug Output: Your Lifeline\n\nWhen the kernel crashes before VGA works, or when you need to log data that scrolls off screen, serial output is essential. COM1 is at I/O port **0x3F8**.\n\n```c\n#define COM1_PORT 0x3F8\n\nstatic inline void outb(uint16_t port, uint8_t val) {\n    asm volatile(\"outb %0, %1\" : : \"a\"(val), \"Nd\"(port));\n}\n\nstatic inline uint8_t inb(uint16_t port) {\n    uint8_t ret;\n    asm volatile(\"inb %1, %0\" : \"=a\"(ret) : \"Nd\"(port));\n    return ret;\n}\n\nvoid serial_init(uint16_t port) {\n    outb(port + 1, 0x00);    // Disable all interrupts\n    outb(port + 3, 0x80);    // Enable DLAB (set baud rate divisor)\n    outb(port + 0, 0x03);    // Set divisor to 3 (lo byte) 38400 baud\n    outb(port + 1, 0x00);    //                  (hi byte)\n    outb(port + 3, 0x03);    // 8 bits, no parity, one stop bit\n    outb(port + 2, 0xC7);    // Enable FIFO, clear them, with 14-byte threshold\n    outb(port + 4, 0x0B);    // IRQs enabled, RTS/DSR set\n}\n\nint serial_is_transmit_empty(uint16_t port) {\n    return inb(port + 5) & 0x20;\n}\n\nvoid serial_putchar(uint16_t port, char c) {\n    while (serial_is_transmit_empty(port) == 0);\n    outb(port, c);\n}\n\nvoid serial_puts(uint16_t port, const char* str) {\n    while (*str) {\n        serial_putchar(port, *str++);\n    }\n}\n```\n\nWith QEMU, you can redirect serial output to a file or stdio:\n\n```bash\nqemu-system-i386 -kernel myos.bin -serial stdio\n# Or save to file:\nqemu-system-i386 -kernel myos.bin -serial file:debug.log\n```\n\n---\n\n## Hardware Soul: What's Actually Happening\n\nEvery step of this boot sequence has hardware implications:\n\n**Cache behavior**: The GDT, loaded via `lgdt`, is read by the CPU into internal registers. Subsequent segment accesses don't read memory — they use the cached descriptor. Modifying the GDT requires a reload.\n\n**TLB state**: In protected mode without paging, linear addresses = physical addresses. When you enable paging (Milestone 3), the TLB (Translation Lookaside Buffer) caches page table entries. For now, it's unused.\n\n**Pipeline flush**: The far jump after `mov cr0, eax` forces a pipeline flush. On modern CPUs, this costs 10-30 cycles. In the boot sequence, this is negligible, but the same principle applies to every context switch.\n\n**Memory access patterns**: The VGA text buffer at 0xB8000 is **uncacheable** memory-mapped I/O. Writing to it goes directly to the video controller, not through the cache hierarchy. This is why we use `volatile` — the compiler must not optimize away or reorder these writes.\n\n---\n\n## Debugging Your Bootloader: When Nothing Works\n\nBootloader bugs are brutal — you often get no output, just a black screen or reset. Here's your debugging toolkit:\n\n### QEMU with GDB\n\n```bash\n# Terminal 1: Start QEMU with GDB stub\nqemu-system-i386 -kernel myos.bin -s -S\n\n# Terminal 2: Connect GDB\ngdb\n(gdb) target remote :1234\n(gdb) break *0x7C00        # Break at bootloader entry\n(gdb) continue\n```\n\n### Serial Output\n\nBefore VGA works, serial is your only output. Initialize it early:\n\n```asm\n; In stage 1, after setting segments:\nmov dx, 0x3F8 + 1\nxor al, al\nout dx, al          ; Disable serial interrupts\n; ... minimal init ...\n\n; Debug: output 'A' to confirm we got here\nmov dx, 0x3F8\nmov al, 'A'\nout dx, al\n```\n\n### Triple Fault Detection\n\nA triple fault (exception → crash → double fault → crash → triple fault → reset) means your CPU state is corrupted. Common causes:\n\n- GDT misconfiguration (wrong base/limit/access bytes)\n- Far jump with wrong selector\n- Forgetting to reload segment registers after mode switch\n- Stack corruption (SS:ESP invalid)\n\nUse QEMU's `-d int,cpu_reset` to log interrupts and resets.\n\n\n![Fault Cascade: Triple Fault Cause Chain](./diagrams/diag-triple-fault-chain.svg)\n\n\n---\n\n## Design Decision: One-Stage vs Two-Stage Bootloader\n\n| Approach | Pros | Cons | Used By |\n|----------|------|------|---------|\n| **One-Stage (512 bytes)** | Simpler, single file | Must fit everything in 510 bytes, limited kernel size | Educational OSes, tiny kernels |\n| **Two-Stage** | Stage 2 can be large, more features | More complex loading, stage 2 must find kernel | Most real bootloaders (GRUB, Linux) |\n| **Multiboot (GRUB)** | GRUB handles all boot complexity | Requires multiboot header, depends on GRUB | Many hobby OSes, Xen |\n\nFor learning, a simple two-stage approach is practical:\n- Stage 1 (512 bytes): Enable A20, load GDT, load stage 2, enter protected mode\n- Stage 2 (larger): Load kernel from disk (using INT 13h in real mode or your own driver in protected mode), verify, jump to kernel\n\n---\n\n## Building and Running\n\nA typical build process:\n\n```bash\n# Assemble bootloader\nnasm -f bin boot.asm -o boot.bin\n\n# Compile kernel (freestanding, no stdlib)\ngcc -m32 -ffreestanding -fno-pic -fno-pie -nostdlib -c kernel_main.c -o kernel_main.o\ngcc -m32 -ffreestanding -fno-pic -fno-pie -nostdlib -c vga.c -o vga.o\ngcc -m32 -ffreestanding -fno-pic -fno-pie -nostdlib -c serial.c -o serial.o\n\n# Link kernel\nld -m elf_i386 -T linker.ld -o kernel.elf kernel_main.o vga.o serial.o\n\n# Extract raw binary (for direct loading)\nobjcopy -O binary kernel.elf kernel.bin\n\n# Create disk image with bootloader and kernel\ndd if=/dev/zero of=os.img bs=512 count=2880\ndd if=boot.bin of=os.img bs=512 count=1 conv=notrunc\ndd if=kernel.bin of=os.img bs=512 seek=1 conv=notrunc\n\n# Run in QEMU\nqemu-system-i386 -drive format=raw,file=os.img -serial stdio\n```\n\n---\n\n## Knowledge Cascade\n\nYou've now built the foundation of an operating system. Here's where this knowledge connects:\n\n**Virtualization and Hypervisors**: The GDT, IDT, and paging machinery you configure is exactly what hypervisors (VMware, KVM, Hyper-V) virtualize. A \"VM entry\" from hypervisor to guest is analogous to your protected mode transition — the hypervisor loads the guest's IDT, GDT, and CR3 before transferring control. Understanding this boot sequence is the first step to understanding VM introspection and escape exploits.\n\n**Linker Scripts and Memory Layout (Cross-Domain)**: The `.text`, `.data`, `.bss` section concepts and LMA (Load Memory Address) vs VMA (Virtual Memory Address) distinction apply to embedded firmware, UEFI drivers, and even position-independent code in security exploits. ROP chains rely on knowing exact offsets in memory — knowledge that starts with understanding linker scripts.\n\n**BIOS/UEFI Exploitation**: The real-mode IVT at 0x0 is still relevant — BIOS bootkits hook INT 13h to infect boot sectors. UEFI's Secure Boot targets exactly the boot path you implemented, verifying signatures before allowing code execution. Understanding the attack surface of boot requires understanding legitimate boot.\n\n**No-std Rust and Freestanding Environments**: The absence of libc, crt0, and runtime services you experience here is exactly what embedded Rust, Linux kernel modules, and WASM runtimes handle. The `#![no_std]` attribute in Rust means \"I will provide my own panic handler and memory allocator\" — the same contract you're fulfilling in C.\n\n**Forward: What You Can Now Build**: With a booting kernel, you can now:\n- Implement an IDT and handle CPU exceptions (Milestone 2)\n- Build a physical memory allocator and enable paging (Milestone 3)\n- Create preemptive multitasking with context switching (Milestone 4)\n\n---\n\n## Summary\n\nYou've crossed the first great divide in OS development:\n\n1. **Boot process**: BIOS → MBR (your bootloader at 0x7C00) → protected mode → kernel entry\n2. **GDT**: Five descriptors (null, kernel code/data, user code/data) with flat memory model\n3. **Protected mode transition**: `cli` → `lgdt` → set CR0.PE → far jump → reload segments\n4. **C environment**: Zero BSS, set stack, call kernel_main — no runtime provided\n5. **Output drivers**: VGA text mode (0xB8000) and serial port (COM1 at 0x3F8)\n\nThe hardware constraints — 512-byte MBR, A20 line, pipeline flush requirements — shaped every decision. You negotiated with physics, and your kernel boots.\n\n\n![OS Kernel Architecture: Satellite View](./diagrams/diag-satellite-system.svg)\n\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-os-m2 -->\n<!-- MS_ID: build-os-m2 -->\n# Milestone 2: Interrupts, Exceptions, and Keyboard\n\n## The Tension: Hardware Can't Wait For You\n\nYour kernel from Milestone 1 sits in a loop, dutifully executing instructions one after another. But the real world doesn't wait:\n\n- The user presses a key — the keyboard controller has data *now*\n- The timer chip fires — the scheduler needs to run *now*\n- Your code divides by zero — the CPU detects an error *now*\n- A page isn't in memory — the MMU needs resolution *now*\n\n**Polling** (checking \"is there input?\" in a loop) wastes millions of cycles. At 3GHz, checking the keyboard 1000 times per second means 3 million wasted cycles between checks — and you still might miss a keystroke if the user types faster than you poll.\n\nThe solution: let hardware interrupt your code. But here's the constraint — the CPU must save exactly enough state to resume later, transfer control to your handler, and do this in **microseconds**. The mechanism must be:\n\n1. **Deterministic**: Same interrupt → same handler → same stack frame\n2. **Fast**: No searching, no dynamic dispatch — direct table lookup\n3. **Precise**: Every register preserved, every byte accounted for\n\nThe x86 answer is the **Interrupt Descriptor Table (IDT)**: 256 entries, each 8 bytes, containing the address and metadata for one handler. When interrupt N occurs, the CPU loads CS:EIP from entry N and jumps — no function calls, no callbacks, just raw hardware-driven control transfer.\n\nAnd here's what surprises most developers: **CPU exceptions and hardware IRQs use the same mechanism**. Division by zero (exception 0), keyboard input (IRQ1 via vector 33), and your own `int 0x80` syscall — all route through the IDT. The CPU doesn't distinguish \"software problems\" from \"hardware events\" at the dispatch level.\n\n---\n\n## Revelation: It's Not a Callback\n\n**What you might think**: \"I register a handler function, and when the keyboard has data, the hardware calls it like an event handler in JavaScript.\"\n\n**What actually happens**: The 8259 PIC doesn't call anything. It asserts an electrical signal on the CPU's INTR pin. The CPU:\n\n1. Finishes the current instruction\n2. Looks up the IDT entry for the interrupt vector\n3. **Pushes EFLAGS, CS, EIP onto the stack** (and optionally an error code)\n4. Loads CS:EIP from the IDT entry\n5. Jumps to your handler\n\nYour handler is now running. The PIC is waiting. And here's the critical part: **the PIC will not deliver another interrupt until you send EOI (End of Interrupt)**. Forget this, and your system appears to \"freeze\" — the keyboard stops responding, the timer stops ticking, everything halts.\n\nThis isn't magic. It's a protocol. You must:\n\n1. Save all registers (the CPU only saved EFLAGS, CS, EIP)\n2. Handle the interrupt\n3. Send EOI to the PIC\n4. Restore all registers\n5. Execute `iret` (which pops EFLAGS, CS, EIP)\n\nMiss any step, and you corrupt the interrupted code — or lock up the interrupt system entirely.\n\n{{DIAGRAM:diag-idt-entry}}\n\n---\n\n## System Map: Where We Are\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                         YOUR OS KERNEL                          │\n│                                                                 │\n│  ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐         │\n│  │   IDT   │   │   PIC   │   │   PIT   │   │ Keyboard│         │\n│  │  256    │   │  8259   │   │  Timer  │   │  Driver │         │\n│  │ entries │   │ Master/ │   │ 100Hz   │   │ Scancode│         │\n│  │         │   │ Slave   │   │         │   │ →ASCII  │         │\n│  └────┬────┘   └────┬────┘   └────┬────┘   └────┬────┘         │\n│       │             │             │             │               │\n│       └─────────────┴─────────────┴─────────────┘              │\n│                           │                                     │\n│  ┌────────────────────────┴────────────────────────┐           │\n│  │                  HARDWARE                        │           │\n│  │  CPU exceptions (0-31) + IRQs (32-47)           │           │\n│  │  All vector through IDT → Your handlers          │           │\n│  └─────────────────────────────────────────────────┘           │\n└─────────────────────────────────────────────────────────────────┘\n```\n\nWe're building the center column: IDT for dispatch, PIC for hardware routing, PIT for timing, and keyboard for input. These are the nervous system of your kernel.\n\n---\n\n## The IDT: 256 Doors to Your Code\n\n### Structure of an IDT Entry\n\nEach IDT entry is an 8-byte **gate descriptor**. The structure mirrors the GDT entry but with different fields:\n\n```\nBytes 0-1:  Offset [15:0]      (low 16 bits of handler address)\nBytes 2-3:  Segment Selector   (code segment to run handler in)\nByte 4:     Reserved (always 0)\nByte 5:     Access Byte:\n  - Bit 7: Present (1 = valid entry)\n  - Bits 6-5: DPL (who can call via INT instruction)\n  - Bit 4: Always 0 (system segment)\n  - Bits 3-0: Gate type (1110 = interrupt gate, 1111 = trap gate)\nBytes 6-7:  Offset [31:16]     (high 16 bits of handler address)\n```\n\n**Interrupt gate vs Trap gate**: The only difference is whether interrupts are automatically disabled. An interrupt gate clears the IF flag (disables interrupts) on entry; a trap gate doesn't. For hardware IRQs, use interrupt gates to prevent nested interrupts. For CPU exceptions that might need to handle interrupts, trap gates can be appropriate.\n\n```c\nstruct idt_entry {\n    uint16_t offset_low;\n    uint16_t selector;\n    uint8_t  zero;\n    uint8_t  type_attr;\n    uint16_t offset_high;\n} __attribute__((packed));\n\nstruct idt_ptr {\n    uint16_t limit;           // Size of IDT - 1\n    uint32_t base;            // Address of IDT\n} __attribute__((packed));\n```\n\n### Loading the IDT\n\n```c\n#define IDT_ENTRIES 256\n\nstruct idt_entry idt[IDT_ENTRIES];\nstruct idt_ptr idtr;\n\nvoid idt_set_gate(uint8_t num, uint32_t handler, uint16_t sel, uint8_t flags) {\n    idt[num].offset_low = handler & 0xFFFF;\n    idt[num].offset_high = (handler >> 16) & 0xFFFF;\n    idt[num].selector = sel;\n    idt[num].zero = 0;\n    idt[num].type_attr = flags;\n}\n\nvoid idt_load(void) {\n    idtr.limit = sizeof(idt) - 1;\n    idtr.base = (uint32_t)&idt;\n    asm volatile(\"lidt %0\" : : \"m\"(idtr));\n}\n```\n\n### CPU Exception Vectors: 0-31\n\nIntel reserved the first 32 vectors for CPU-detected conditions:\n\n| Vector | Name | Error Code? | Cause |\n|--------|------|-------------|-------|\n| 0 | #DE Divide Error | No | Division by zero or overflow |\n| 1 | #DB Debug | No | Debug trap (single step, breakpoint) |\n| 2 | NMI | No | Non-maskable interrupt |\n| 3 | #BP Breakpoint | No | INT 3 instruction |\n| 6 | #UD Invalid Opcode | No | CPU encountered unknown instruction |\n| 8 | #DF Double Fault | Yes | Exception during handling another exception |\n| 10 | #TS Invalid TSS | Yes | TSS segment invalid |\n| 11 | #NP Segment Not Present | Yes | Segment descriptor P=0 |\n| 12 | #SS Stack-Segment Fault | Yes | Stack operation outside limit |\n| 13 | #GP General Protection | Yes | Privilege violation, invalid segment |\n| 14 | #PF Page Fault | Yes | Page not present or protection violation |\n\n\n![CPU Exception Vectors and Error Codes](./diagrams/diag-exception-vectors.svg)\n\n\nThe **error code** column is critical. Some exceptions push an error code onto the stack; others don't. Your handler must know which, or `iret` will pop the wrong value into EIP and crash.\n\n---\n\n## Interrupt Stack Frame: What the CPU Pushes\n\n{{DIAGRAM:diag-interrupt-stack-frame}}\n\nWhen an interrupt occurs, the CPU pushes this stack frame:\n\n```\nHigh addresses\n┌─────────────────┐\n│    SS (old)     │  ← Only if privilege change (ring 3 → ring 0)\n│    ESP (old)    │  ← Only if privilege change\n├─────────────────┤\n│    EFLAGS       │  ← Always pushed\n├─────────────────┤\n│    CS (old)     │  ← Always pushed\n│    EIP (old)    │  ← Always pushed\n├─────────────────┤\n│  Error Code     │  ← Only for exceptions 8, 10-14\n└─────────────────┘\nLow addresses (stack grows down)\n```\n\n**Your handler receives this stack**. The CPU did NOT save EAX, EBX, ECX, EDX, ESI, EDI, EBP, or DS/ES/FS/GS. If you use any of these registers (and you will), you must save and restore them yourself.\n\n---\n\n## Writing an Interrupt Handler: The Assembly Shim\n\nYou can't write an interrupt handler entirely in C because C has no way to:\n\n1. Control exactly what's pushed/popped\n2. Execute `iret` instead of `ret`\n3. Handle the optional error code\n\nThe standard pattern is an **assembly stub** that calls a C function:\n\n```asm\n; Common interrupt stub macro\n%macro ISR_NOERR 1       ; For exceptions WITHOUT error code\nglobal isr%1\nisr%1:\n    push dword 0         ; Push dummy error code to unify stack frame\n    push dword %1        ; Push interrupt number\n    jmp isr_common_stub\n%endmacro\n\n%macro ISR_ERR 1         ; For exceptions WITH error code\nglobal isr%1\nisr%1:\n    push dword %1        ; Push interrupt number (error code already on stack)\n    jmp isr_common_stub\n%endmacro\n\n; Declare all CPU exception handlers\nISR_NOERR 0              ; Divide Error\nISR_NOERR 1              ; Debug\nISR_NOERR 2              ; NMI\nISR_NOERR 3              ; Breakpoint\nISR_NOERR 4              ; Overflow\nISR_NOERR 5              ; BOUND Range Exceeded\nISR_NOERR 6              ; Invalid Opcode\nISR_NOERR 7              ; Device Not Available\nISR_ERR   8              ; Double Fault (has error code)\nISR_NOERR 9              ; Coprocessor Segment Overrun\nISR_ERR   10             ; Invalid TSS\nISR_ERR   11             ; Segment Not Present\nISR_ERR   12             ; Stack-Segment Fault\nISR_ERR   13             ; General Protection Fault\nISR_ERR   14             ; Page Fault\n; ... continue for 0-31\n\n; Common handler stub\nextern isr_handler       ; C function to handle the interrupt\n\nisr_common_stub:\n    ; Save all general-purpose registers\n    pusha                ; Pushes EAX, ECX, EDX, EBX, ESP (old), EBP, ESI, EDI\n    push ds\n    push es\n    push fs\n    push gs\n\n    ; Save current stack pointer (passes pointer to stack frame to C)\n    mov eax, esp\n    push eax\n\n    ; Load kernel data segment\n    mov ax, 0x10\n    mov ds, ax\n    mov es, ax\n    mov fs, ax\n    mov gs, ax\n\n    ; Call C handler\n    call isr_handler\n\n    ; Restore stack pointer (C may have returned a value in EAX, ignore)\n    add esp, 4\n\n    ; Restore segment registers\n    pop gs\n    pop fs\n    pop es\n    pop ds\n\n    ; Restore general-purpose registers\n    popa\n\n    ; Remove error code and interrupt number\n    add esp, 8\n\n    ; Return from interrupt\n    iret\n```\n\nThe `pusha` instruction (Push All) saves EAX, ECX, EDX, EBX, ESP (the value before pusha), EBP, ESI, EDI in that order. `popa` restores all except ESP (which is restored automatically).\n\n### The C Handler\n\n```c\ntypedef struct {\n    uint32_t gs, fs, es, ds;\n    uint32_t edi, esi, ebp, esp, ebx, edx, ecx, eax;\n    uint32_t int_no, err_code;\n    uint32_t eip, cs, eflags;\n    uint32_t useresp, ss;  // Only valid if privilege change occurred\n} registers_t;\n\nvoid isr_handler(registers_t *regs) {\n    // Check if this is an exception (0-31) or IRQ (32+)\n    if (regs->int_no < 32) {\n        // CPU exception\n        const char *exception_messages[] = {\n            \"Division By Zero\",\n            \"Debug\",\n            \"Non Maskable Interrupt\",\n            \"Breakpoint\",\n            \"Into Detected Overflow\",\n            \"Out of Bounds\",\n            \"Invalid Opcode\",\n            \"No Coprocessor\",\n            \"Double Fault\",\n            \"Coprocessor Segment Overrun\",\n            \"Bad TSS\",\n            \"Segment Not Present\",\n            \"Stack Fault\",\n            \"General Protection Fault\",\n            \"Page Fault\",\n            \"Unknown Interrupt\",\n            // ... more messages\n        };\n        \n        vga_puts(\"EXCEPTION: \");\n        vga_puts(exception_messages[regs->int_no]);\n        vga_puts(\"\\n\");\n        \n        // Special handling for page fault\n        if (regs->int_no == 14) {\n            uint32_t faulting_address;\n            asm volatile(\"mov %%cr2, %0\" : \"=r\"(faulting_address));\n            vga_puts(\"Faulting address: \");\n            vga_put_hex(faulting_address);\n            vga_puts(\"\\n\");\n            \n            vga_puts(\"Error code: \");\n            vga_put_hex(regs->err_code);\n            vga_puts(\" (\");\n            if (!(regs->err_code & 0x1)) vga_puts(\"not-present \");\n            if (regs->err_code & 0x2) vga_puts(\"write \");\n            if (regs->err_code & 0x4) vga_puts(\"user-mode \");\n            vga_puts(\")\\n\");\n        }\n        \n        // For double fault, halt with diagnostic\n        if (regs->int_no == 8) {\n            vga_puts(\"DOUBLE FAULT - System halted.\\n\");\n            asm volatile(\"cli; hlt\");\n        }\n        \n        // For other exceptions, halt for now\n        vga_puts(\"System halted.\\n\");\n        asm volatile(\"cli; hlt\");\n    }\n}\n```\n\n---\n\n## The 8259 PIC: Routing Hardware Interrupts\n\nThe **Programmable Interrupt Controller (PIC)** is a separate chip that collects interrupt signals from devices and presents them to the CPU one at a time. The original 8259 handled 8 IRQs; modern systems cascade two PICs for 15 IRQs (IRQ2 is the cascade connection).\n\n\n![PIC Remapping: IRQ to Vector Mapping](./diagrams/diag-pic-remapping.svg)\n\n\n### The Remapping Problem\n\nBy default, the PIC maps IRQs 0-7 to CPU vectors 8-15 and IRQs 8-15 to vectors 0x70-0x77. But vectors 8-15 are CPU exceptions! When the timer fires (IRQ0), it looks like a double fault (vector 8).\n\nYou must **remap** the PICs to use vectors that don't conflict:\n\n```\nMaster PIC: IRQ0-7 → vectors 32-39 (0x20-0x27)\nSlave PIC:  IRQ8-15 → vectors 40-47 (0x28-0x2F)\n```\n\n### Programming the PIC\n\nThe PIC is programmed via I/O ports:\n- Master: Command at 0x20, Data at 0x21\n- Slave: Command at 0xA0, Data at 0xA1\n\nThe initialization sequence sends **ICW1-ICW4** (Initialization Command Words):\n\n```c\n#define PIC1_CMD  0x20\n#define PIC1_DATA 0x21\n#define PIC2_CMD  0xA0\n#define PIC2_DATA 0xA1\n\nvoid pic_remap(int offset1, int offset2) {\n    // ICW1: Start initialization, expect ICW4\n    outb(PIC1_CMD, 0x11);   // 0x11 = initialize + ICW4 needed\n    outb(PIC2_CMD, 0x11);\n    \n    // ICW2: Vector offsets\n    outb(PIC1_DATA, offset1);  // Master offset (e.g., 32)\n    outb(PIC2_DATA, offset2);  // Slave offset (e.g., 40)\n    \n    // ICW3: Tell Master there's a slave at IRQ2 (00000100)\n    //       Tell Slave its cascade identity (00000010)\n    outb(PIC1_DATA, 0x04);\n    outb(PIC2_DATA, 0x02);\n    \n    // ICW4: 8086 mode, non-automatic EOI\n    outb(PIC1_DATA, 0x01);\n    outb(PIC2_DATA, 0x01);\n    \n    // Clear data registers (mask all IRQs initially)\n    outb(PIC1_DATA, 0x0);\n    outb(PIC2_DATA, 0x0);\n}\n\nvoid pic_send_eoi(uint8_t irq) {\n    // Send End of Interrupt to the PIC(s)\n    outb(PIC1_CMD, 0x20);          // EOI to master\n    \n    if (irq >= 8) {\n        outb(PIC2_CMD, 0x20);      // EOI to slave if IRQ came from it\n    }\n}\n```\n\n### IRQ Handlers\n\nFor hardware IRQs (vectors 32-47), you need separate stubs that send EOI:\n\n```asm\n; IRQ handlers\n%macro IRQ 2\nglobal irq%1\nirq%1:\n    push dword 0           ; Dummy error code\n    push dword %1          ; IRQ number\n    jmp irq_common_stub\n%endmacro\n\nIRQ 0,  32                 ; Timer\nIRQ 1,  33                 ; Keyboard\nIRQ 2,  34                 ; Cascade\nIRQ 3,  35                 ; COM2\nIRQ 4,  36                 ; COM1\n; ... continue for IRQs 0-15\n\nextern irq_handler\n\nirq_common_stub:\n    pusha\n    push ds\n    push es\n    push fs\n    push gs\n    \n    mov eax, esp\n    push eax\n    \n    mov ax, 0x10\n    mov ds, ax\n    mov es, ax\n    mov fs, ax\n    mov gs, ax\n    \n    call irq_handler\n    \n    add esp, 4\n    \n    pop gs\n    pop fs\n    pop es\n    pop ds\n    popa\n    \n    add esp, 8\n    \n    iret\n```\n\n```c\n// C handler for IRQs\nvoid irq_handler(registers_t *regs) {\n    // Send EOI to PIC\n    pic_send_eoi(regs->int_no - 32);\n    \n    // Dispatch to specific handler\n    if (regs->int_no == 32) {\n        timer_handler();\n    } else if (regs->int_no == 33) {\n        keyboard_handler();\n    }\n    // ... other IRQ handlers\n}\n```\n\n---\n\n## The PIT Timer: Your First Clock\n\nThe **Programmable Interval Timer (8253/8254)** generates periodic interrupts at a configurable frequency. Channel 0 is connected to IRQ0.\n\nThe base frequency is 1,193,182 Hz (≈1.193 MHz). You configure the divisor to get your desired frequency:\n\n```\nOutput frequency = 1,193,182 / divisor\nDivisor for 100Hz = 1,193,182 / 100 = 11931 (0x2E9B)\n```\n\n```c\n#define PIT_CHANNEL0 0x40\n#define PIT_CMD      0x43\n\nvolatile uint32_t tick_count = 0;\n\nvoid timer_init(uint32_t frequency) {\n    uint32_t divisor = 1193182 / frequency;\n    \n    // Command byte: channel 0, access mode: lobyte/hibyte, mode 3 (square wave)\n    outb(PIT_CMD, 0x36);\n    \n    // Send divisor\n    outb(PIT_CHANNEL0, divisor & 0xFF);        // Low byte\n    outb(PIT_CHANNEL0, (divisor >> 8) & 0xFF); // High byte\n}\n\nvoid timer_handler(void) {\n    tick_count++;\n    \n    // Every 100 ticks (1 second at 100Hz), print a message\n    if (tick_count % 100 == 0) {\n        vga_puts(\"Tick: \");\n        vga_put_dec(tick_count / 100);\n        vga_puts(\" seconds\\n\");\n    }\n}\n```\n\nThe `volatile` keyword on `tick_count` prevents the compiler from caching it in a register — necessary because it's modified in an interrupt handler that the compiler can't see.\n\n---\n\n## PS/2 Keyboard: Scancodes to Characters\n\nThe keyboard doesn't send ASCII. It sends **scancodes** — raw key identifiers. When you press 'A', the keyboard sends scancode 0x1E. When you release 'A', it sends 0x9E (break code = make code | 0x80).\n\n{{DIAGRAM:diag-keyboard-scancode-flow}}\n\n### Reading from the Keyboard\n\nThe keyboard controller presents data at I/O port 0x60. When a key is pressed:\n\n1. Keyboard controller sends scancode to port 0x60\n2. Keyboard controller asserts IRQ1\n3. CPU vectors through IDT to your IRQ1 handler\n4. Your handler reads port 0x60 to get the scancode\n\n```c\n#define KB_DATA_PORT 0x60\n#define KB_CMD_PORT  0x64\n\n#define KB_BUFFER_SIZE 128\n\nstatic char kb_buffer[KB_BUFFER_SIZE];\nstatic int kb_buffer_head = 0;\nstatic int kb_buffer_tail = 0;\n\n// US QWERTY scancode to ASCII table (lowercase)\nstatic char scancode_to_ascii[] = {\n    0,    0,   '1', '2', '3', '4', '5', '6',   // 0x00-0x07\n    '7', '8', '9', '0', '-', '=', '\\b', '\\t',  // 0x08-0x0F (backspace, tab)\n    'q', 'w', 'e', 'r', 't', 'y', 'u', 'i',   // 0x10-0x17\n    'o', 'p', '[', ']', '\\n', 0,              // 0x18-0x1D (enter, left ctrl)\n    'a', 's', 'd', 'f', 'g', 'h', 'j', 'k',   // 0x1E-0x25\n    'l', ';', '\\'', '`', 0, '\\\\',             // 0x26-0x2B (no key, shift, backslash)\n    'z', 'x', 'c', 'v', 'b', 'n', 'm', ',',   // 0x2C-0x33\n    '.', '/', 0, 0, 0, ' ',                   // 0x34-0x39 (shift, alt, space)\n};\n\n// Extended scancodes (prefixed with 0xE0) need separate handling\nstatic int extended_scancode = 0;\n\nvoid keyboard_handler(void) {\n    uint8_t scancode = inb(KB_DATA_PORT);\n    \n    // Handle extended scancodes (arrow keys, etc.)\n    if (scancode == 0xE0) {\n        extended_scancode = 1;\n        return;\n    }\n    \n    // Check for break code (key release)\n    int released = (scancode & 0x80);\n    scancode &= 0x7F;\n    \n    if (released) {\n        // Handle key release (for shift/ctrl tracking)\n        if (scancode == 0x2A || scancode == 0x36) {\n            // Left or right shift released\n            shift_pressed = 0;\n        }\n        return;\n    }\n    \n    // Handle modifier keys\n    if (scancode == 0x2A || scancode == 0x36) {\n        shift_pressed = 1;\n        return;\n    }\n    \n    // Convert to ASCII\n    if (scancode < sizeof(scancode_to_ascii)) {\n        char c = scancode_to_ascii[scancode];\n        \n        if (shift_pressed && c >= 'a' && c <= 'z') {\n            c -= 32;  // Convert to uppercase\n        }\n        \n        // Add to circular buffer\n        int next_head = (kb_buffer_head + 1) % KB_BUFFER_SIZE;\n        if (next_head != kb_buffer_tail) {\n            kb_buffer[kb_buffer_head] = c;\n            kb_buffer_head = next_head;\n        }\n    }\n}\n\n// Non-blocking read from keyboard buffer\nint kb_getchar(void) {\n    if (kb_buffer_head == kb_buffer_tail) {\n        return -1;  // Buffer empty\n    }\n    \n    char c = kb_buffer[kb_buffer_tail];\n    kb_buffer_tail = (kb_buffer_tail + 1) % KB_BUFFER_SIZE;\n    return c;\n}\n```\n\n### Handling Special Cases\n\nThe PS/2 keyboard has quirks:\n\n1. **Extended scancodes** (0xE0 prefix): Arrow keys, navigation cluster, and right-side modifiers send a two-byte sequence starting with 0xE0\n2. **Pause/Break**: Sends 0xE1 0x1D 0x45 0xE1 0x9D 0xC5 (8 bytes total!)\n3. **Print Screen**: Sends 0xE0 0x2A 0xE0 0x37 on press\n\nProduction keyboard drivers use state machines. For now, handling basic alphanumeric keys is sufficient.\n\n---\n\n## Double Fault: Your Last Line of Defense\n\nA **double fault** (exception 8) occurs when an exception happens while handling another exception. Common causes:\n\n- Page fault while handling a page fault\n- Segment not present while handling an exception\n- Stack overflow during exception handling\n\nWithout a double fault handler, the CPU **triple faults** and resets. With a handler, you can at least print a diagnostic before halting:\n\n```c\nvoid double_fault_handler(registers_t *regs) {\n    vga_set_color(VGA_WHITE, VGA_RED);\n    vga_puts(\"\\n!!! DOUBLE FAULT !!!\\n\");\n    vga_puts(\"System state corrupted. Halting.\\n\");\n    vga_puts(\"EIP: \");\n    vga_put_hex(regs->eip);\n    vga_puts(\"  CS: \");\n    vga_put_hex(regs->cs);\n    vga_puts(\"\\nError code: \");\n    vga_put_hex(regs->err_code);\n    vga_puts(\"\\n\");\n    \n    // No recovery possible from double fault\n    asm volatile(\"cli; hlt\");\n}\n```\n\nThe error code for double fault indicates what went wrong:\n\n```\nBits 0-1: Which table (0=GDT, 1=IDT, 2=LDT, 3=IDT)\nBit 2:    Type of access (0=instruction fetch or segment load)\nBits 3-15: Index of selector\n```\n\n\n![Fault Cascade: Triple Fault Cause Chain](./diagrams/diag-triple-fault-chain.svg)\n\n\n---\n\n## Putting It All Together: Initialization Sequence\n\n```c\nvoid idt_init(void) {\n    // Set up exception handlers (0-31)\n    idt_set_gate(0,  (uint32_t)isr0,  0x08, 0x8E);  // Divide Error\n    idt_set_gate(1,  (uint32_t)isr1,  0x08, 0x8E);  // Debug\n    // ... all 32 exceptions ...\n    idt_set_gate(8,  (uint32_t)isr8,  0x08, 0x8E);  // Double Fault\n    idt_set_gate(14, (uint32_t)isr14, 0x08, 0x8E);  // Page Fault\n    \n    // Remap PIC and set up IRQ handlers (32-47)\n    pic_remap(32, 40);\n    idt_set_gate(32, (uint32_t)irq0, 0x08, 0x8E);   // Timer\n    idt_set_gate(33, (uint32_t)irq1, 0x08, 0x8E);   // Keyboard\n    // ... remaining IRQs ...\n    \n    // Load IDT\n    idt_load();\n}\n\nvoid kernel_main(void) {\n    vga_init();\n    serial_init(COM1_PORT);\n    \n    vga_puts(\"Initializing IDT...\\n\");\n    idt_init();\n    \n    vga_puts(\"Initializing timer (100Hz)...\\n\");\n    timer_init(100);\n    \n    // Unmask IRQ0 (timer) and IRQ1 (keyboard)\n    outb(PIC1_DATA, 0xFC);  // 11111100 - enable IRQ0 and IRQ1\n    \n    vga_puts(\"Enabling interrupts...\\n\");\n    asm volatile(\"sti\");\n    \n    vga_puts(\"System ready. Type something!\\n\");\n    \n    while (1) {\n        int c = kb_getchar();\n        if (c != -1) {\n            vga_putchar(c);\n        }\n        asm volatile(\"hlt\");  // Wait for interrupt\n    }\n}\n```\n\n---\n\n## Hardware Soul: What's Happening on the Metal\n\n**Interrupt latency**: From IRQ assertion to your handler's first instruction, the CPU spends 50-100 cycles on the automatic stack operations. Your pusha/push ds-es adds another 40 cycles. That's 100-150 cycles of pure overhead before any useful work.\n\n**Cache impact**: Interrupt handlers run with whatever's in the cache. A timer interrupt that fires while running a memory-intensive loop will find a cold cache. This is why interrupt handlers should be small.\n\n**PIC priority**: The PIC has a fixed priority scheme — IRQ0 (timer) is highest, IRQ7 lowest. If IRQ0 is pending when IRQ7 arrives, IRQ0 wins. If you're in an IRQ0 handler and IRQ7 fires, it waits (unless you re-enable interrupts with `sti` in the handler).\n\n**The EOI timing window**: Between your handler returning and `iret` executing, interrupts are still disabled. But after `iret`, if EOI was sent, the next pending IRQ fires immediately. There's no \"settle time.\"\n\n**Keyboard controller buffer**: The keyboard controller has a small internal buffer (typically 16 bytes). If you don't read port 0x60 fast enough, the controller discards old keystrokes. Your interrupt handler needs to be responsive.\n\n---\n\n## Debugging Interrupt Issues\n\n**Symptom: System freezes immediately after enabling interrupts**\n\n- Check: Did you remap the PIC? Default vectors 8-15 conflict with CPU exceptions\n- Check: Is the IDT loaded? Add a debug print after `lidt`\n- Check: Are your IDT entry addresses correct? Use GDB to inspect\n\n**Symptom: One interrupt works, then nothing**\n\n- You forgot to send EOI. The PIC is waiting.\n- Check: `pic_send_eoi()` is called at the end of every IRQ handler\n\n**Symptom: Keyboard produces wrong characters**\n\n- Scancode table mismatch. Are you using US QWERTY?\n- Extended scancode handling missing. Arrow keys send 0xE0 prefix\n\n**Symptom: Random crashes, corrupted variables**\n\n- You're not saving/restoring all registers\n- Check: `pusha`/`popa` plus segment registers\n- Check: Error code handling (some exceptions push it, some don't)\n\n**Symptom: Triple fault**\n\n- Check: Double fault handler is installed and correct\n- Check: Stack pointer is valid (your handler needs stack space)\n- Use QEMU: `qemu-system-i386 -d int -serial stdio` to log all interrupts\n\n---\n\n## Design Decision: Interrupt Gates vs Trap Gates\n\n| Aspect | Interrupt Gate | Trap Gate | Recommendation |\n|--------|---------------|-----------|----------------|\n| IF flag | Cleared (interrupts disabled) | Unchanged | IRQs: interrupt gate |\n| Nested interrupts | Prevented automatically | Must handle manually | Exceptions: trap gate OK |\n| Used by Linux | All hardware IRQs | Software interrupts | Follow Linux |\n\nFor this project, use interrupt gates (0x8E in type_attr) for all entries. The simplicity outweighs the minor latency cost of re-enabling interrupts if needed.\n\n---\n\n## Knowledge Cascade\n\nYou've built the interrupt subsystem — the nervous system of your kernel. Here's where this knowledge connects:\n\n**Signal Handling in Unix/Linux**: Every signal mechanism traces back to what you just built. `SIGSEGV` (segmentation fault) is your page fault handler reporting to user space. `SIGALRM` is your timer interrupt delivering a notification. The `sigaction()` system call is essentially letting user programs register their own \"IDT entries\" for software signals. When you understand that signals are just user-space-visible interrupts, the POSIX signal API makes perfect sense.\n\n**Rust Panic and Go Recover (Cross-Domain)**: Language-level exception handling is built on CPU exceptions. When Rust code panics, the runtime either unwinds the stack or aborts — similar to how your exception handlers choose between recovery and halt. Go's `recover()` function catches panics, analogous to a high-level double fault handler. The difference is scope: CPU exceptions are per-instruction, language exceptions are per-call-frame.\n\n**Real-Time Systems and Interrupt Latency**: The EOI timing you learned — send it too late and latency increases, send it too early and risk re-entrancy — is central to real-time systems. The Linux PREEMPT_RT patch converts hard IRQs to threaded interrupts for this reason. Audio buffer underruns (glitches) happen when interrupt handlers take too long. Your timer handler's execution time directly affects the system's worst-case interrupt latency.\n\n**Input Subsystem Architecture**: Your scancode-to-ASCII table is the ancestor of Linux's input subsystem. The modern Linux keyboard driver handles multiple keyboard types, keyboard layouts (via user-space keymaps), and even multiple keyboards simultaneously. But at the core: scancode in from hardware, character out to buffer. You've implemented the essential path.\n\n**Interrupt Storm Debugging**: When a faulty network card asserts IRQ continuously and your handler forgets EOI, the system \"freezes\" — but it's actually spending 100% of CPU time in your handler. Server administrators see this with `/proc/interrupts` showing millions of IRQs per second. You now understand why: the PIC keeps delivering, the CPU keeps vectoring, nothing else runs.\n\n**Forward: What You Can Now Build**: With a working interrupt system, you can:\n- Implement preemptive scheduling (timer interrupt triggers context switch)\n- Add demand paging (page fault handler loads pages from disk)\n- Build a system call interface (INT 0x80 is just another interrupt)\n- Write drivers for any hardware with an IRQ\n\n---\n\n## Summary\n\nYou've built the interrupt subsystem — the mechanism by which hardware events and software exceptions reach your code:\n\n1. **IDT**: 256 entries, each 8 bytes, mapping vector numbers to handler addresses\n2. **Exception handlers**: CPU-detected conditions (0-31), some with error codes\n3. **PIC remapping**: Move IRQs from conflicting vectors (8-15) to 32-47\n4. **EOI protocol**: Tell the PIC when you're done, or interrupts stop forever\n5. **PIT timer**: Configure divisor for desired frequency, increment tick counter\n6. **PS/2 keyboard**: Read scancodes from port 0x60, convert to ASCII, buffer for reading\n7. **Double fault handler**: Catch cascading failures before they cause triple fault\n\nThe revelation: interrupts are not callbacks. The CPU pushes a defined stack frame, jumps to your handler, and expects you to clean up. The PIC asserts a signal but doesn't \"call\" anything. You send EOI as a message, not a return value. This is hardware communication at its most fundamental.\n\n\n![OS Kernel Architecture: Satellite View](./diagrams/diag-satellite-system.svg)\n\n\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-os-m3 -->\n# Milestone 3: Physical and Virtual Memory Management\n\n## The Tension: Memory Isn't What You Think It Is\n\nHere's what most developers believe about memory:\n\n> \"Memory is a big byte array. `malloc(100)` gives me 100 bytes at some address like 0x1000. That address points to physical RAM. Virtual memory is just swap to disk.\"\n\nEvery part of this mental model is wrong.\n\n**Reality #1: Physical memory is a collection of 4KB chunks called frames.** There is no giant contiguous array. The 1GB of RAM in your system is 262,144 separate frames, each individually addressable, each potentially allocated to a different purpose.\n\n**Reality #2: Virtual addresses are translated on every single access.** When you read `*ptr` where `ptr = 0xC0123456`, the CPU doesn't \"look up\" the translation once. It walks the page table hierarchy every time—or relies on the TLB (Translation Lookaside Buffer) cache. That translation happens in hardware, in parallel with the cache lookup, adding ~10-30 cycles to every memory access.\n\n**Reality #3: The TLB is not coherent with your page table writes.** Modify a page table entry, and the TLB still holds the old translation. The CPU will happily use stale data. You must explicitly invalidate entries with `invlpg` or reload CR3.\n\n**Reality #4: Enabling paging without mapping your current code causes immediate crash.** The moment you set CR0.PG, the CPU starts translating *the very next instruction fetch*. If that instruction's virtual address doesn't map to its physical location, you page fault before executing another instruction.\n\n{{DIAGRAM:diag-page-table-hierarchy}}\n\nThe numbers that matter:\n- **4KB frame size** — the atomic unit of physical allocation\n- **4MB per page directory entry** — each PDE covers a 4MB virtual region\n- **1024 entries per page directory** — covers 4GB virtual address space\n- **1024 entries per page table** — covers 4MB per page table\n- **TLB: 64-128 entries** — tiny cache, misses cost hundreds of cycles\n\nThis milestone is about building the memory management layer that makes virtual addresses work: parsing the physical memory map, allocating frames, constructing page tables, enabling paging, and building a kernel heap on top of it all.\n\n---\n\n## Revelation: The Address Translation Happens Every Time\n\n**What you might think**: \"When I call `malloc`, the kernel sets up a mapping. After that, accessing that pointer goes directly to RAM.\"\n\n**What actually happens**:\n\nEvery memory access—every instruction fetch, every data read, every stack push—goes through this sequence:\n\n1. CPU generates a **virtual address** (e.g., 0xC0101234)\n2. Extract page directory index: bits 22-31 → 0x300 (768)\n3. Read Page Directory Entry (PDE) at CR3 + 768*4\n4. Check present bit—if 0, raise page fault\n5. Extract page table index: bits 12-21 → 0x101 (257)\n6. Read Page Table Entry (PTE) at PDE.frame + 257*4\n7. Check present bit—if 0, raise page fault\n8. Extract offset: bits 0-11 → 0x234\n9. Physical address = PTE.frame + 0x234\n10. Access cache/memory at that physical address\n\nSteps 2-9 happen in hardware, in parallel with the L1 cache lookup. But here's the critical part: the TLB caches the *result* of steps 2-9. If you modify the page table entry in step 7, the TLB still holds the old translation.\n\n\n![Page Directory/Table Entry Bits](./diagrams/diag-page-directory-entry.svg)\n\n\nThis has profound implications:\n\n- **Context switches must reload CR3** — each process has its own page directory, and the TLB is full of the old process's translations\n- **Modifying page tables requires invlpg** — or the CPU uses stale translations\n- **Identity mapping is mandatory during transition** — enabling paging while executing code at 0x100000 requires a mapping from virtual 0x100000 to physical 0x100000\n\n---\n\n## System Map: Where We Are\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                         YOUR OS KERNEL                          │\n│                                                                 │\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │\n│  │   Memory    │  │   Physical  │  │   Virtual   │             │\n│  │   Map       │→ │   Frame     │→ │   Memory    │             │\n│  │  (E820)     │  │   Allocator │  │   Manager   │             │\n│  └─────────────┘  └─────────────┘  └─────────────┘             │\n│         │                │                │                     │\n│         │                │                ↓                     │\n│         │                │         ┌─────────────┐              │\n│         │                │         │   Kernel    │              │\n│         │                └────────→│   Heap      │              │\n│         │                          │ (kmalloc)   │              │\n│         │                          └─────────────┘              │\n│         │                                │                      │\n│  ┌──────┴────────────────────────────────┴──────────────┐      │\n│  │                    HARDWARE                          │      │\n│  │  CR3 → Page Directory → Page Tables → Physical RAM  │      │\n│  │  TLB caches translations (NOT coherent with writes) │      │\n│  └─────────────────────────────────────────────────────┘      │\n└─────────────────────────────────────────────────────────────────┘\n```\n\nWe're building the entire memory management stack: physical memory discovery, frame allocation, page table construction, paging enablement, and kernel heap allocation.\n\n---\n\n## Physical Memory Map: Discovering What Exists\n\n### The E820 BIOS Query\n\nBefore you can allocate memory, you need to know what memory exists. The BIOS provides this via the E820 query (INT 15h, AX=E820), which returns a list of memory regions with their types.\n\n{{DIAGRAM:diag-e820-memory-map}}\n\nEach E820 entry is 20+ bytes:\n\n```c\nstruct e820_entry {\n    uint64_t base;      // Base address of region\n    uint64_t length;    // Length of region\n    uint32_t type;      // Type of memory\n    uint32_t acpi;      // ACPI extended attributes (optional)\n} __attribute__((packed));\n\n#define E820_USABLE    1   // Normal RAM, can be used\n#define E820_RESERVED  2   // Reserved, do not use\n#define E820_ACPI_RECL 3   // ACPI reclaimable after reading tables\n#define E820_ACPI_NVS  4   // ACPI non-volatile storage\n#define E820_BAD       5   // Bad memory, contains errors\n```\n\nIf you're using a multiboot bootloader (GRUB), the multiboot info structure already contains the memory map:\n\n```c\nstruct multiboot_mmap_entry {\n    uint32_t size;\n    uint64_t base_addr;\n    uint64_t length;\n    uint32_t type;\n} __attribute__((packed));\n\nvoid parse_memory_map(multiboot_info_t *mbi) {\n    // Check if memory map is present\n    if (!(mbi->flags & (1 << 6))) {\n        panic(\"No memory map from bootloader!\");\n    }\n    \n    uint32_t total_usable = 0;\n    multiboot_mmap_entry_t *entry = (multiboot_mmap_entry_t *)mbi->mmap_addr;\n    \n    while ((uint32_t)entry < mbi->mmap_addr + mbi->mmap_length) {\n        kprintf(\"Memory: 0x%x - 0x%x \", \n                (uint32_t)entry->base_addr,\n                (uint32_t)(entry->base_addr + entry->length - 1));\n        \n        switch (entry->type) {\n            case E820_USABLE:\n                kprintf(\"(usable)\\n\");\n                total_usable += entry->length;\n                break;\n            case E820_RESERVED:\n                kprintf(\"(reserved)\\n\");\n                break;\n            case E820_ACPI_RECL:\n                kprintf(\"(ACPI reclaimable)\\n\");\n                break;\n            case E820_ACPI_NVS:\n                kprintf(\"(ACPI NVS)\\n\");\n                break;\n            default:\n                kprintf(\"(type %d)\\n\", entry->type);\n        }\n        \n        entry = (multiboot_mmap_entry_t *)((uint32_t)entry + entry->size + 4);\n    }\n    \n    kprintf(\"Total usable memory: %d MB\\n\", total_usable / (1024 * 1024));\n}\n```\n\n### Typical Memory Layout\n\nA typical 512MB system might have:\n\n| Start | End | Type | Purpose |\n|-------|-----|------|---------|\n| 0x000000 | 0x000FFF | Reserved | Real-mode IVT, BDA |\n| 0x001000 | 0x07FFFF | Usable | Low memory (conventional) |\n| 0x07FFFF | 0x080000 | Reserved | EBDA (Extended BIOS Data Area) |\n| 0x080000 | 0x0FFFFF | Reserved | ROM area, video memory |\n| 0x100000 | 0x1FFFFFF | Usable | Extended memory (your kernel lives here) |\n| 0x2000000+ | ... | Usable | More RAM |\n\n**Critical insight**: Not all \"usable\" memory is actually available. Your kernel binary, page tables, and bootloader data occupy physical frames. Your allocator must skip these.\n\n---\n\n## Physical Frame Allocator: Managing 4KB Chunks\n\n### Bitmap Allocator\n\nA bitmap allocator uses one bit per frame to track allocation status. For 4GB of memory with 4KB frames, you need 128KB of bitmap (4GB / 4KB / 8 bits = 131,072 bytes).\n\n```c\n#define FRAME_SIZE 4096\n#define FRAMES_PER_BITMAP_ENTRY 32  // 32 bits per uint32_t\n\nstatic uint32_t *frame_bitmap;\nstatic uint32_t total_frames;\nstatic uint32_t first_usable_frame;\n\n// Calculate which frame a physical address belongs to\n#define FRAME_FROM_ADDR(addr) ((addr) / FRAME_SIZE)\n\n// Bitmap operations\nstatic inline void set_frame(uint32_t frame) {\n    frame_bitmap[frame / 32] |= (1 << (frame % 32));\n}\n\nstatic inline void clear_frame(uint32_t frame) {\n    frame_bitmap[frame / 32] &= ~(1 << (frame % 32));\n}\n\nstatic inline int test_frame(uint32_t frame) {\n    return frame_bitmap[frame / 32] & (1 << (frame % 32));\n}\n\n// Find first free frame\nstatic int find_free_frame(void) {\n    for (uint32_t i = first_usable_frame / 32; i < total_frames / 32; i++) {\n        if (frame_bitmap[i] != 0xFFFFFFFF) {\n            // At least one bit is free\n            for (int j = 0; j < 32; j++) {\n                if (!(frame_bitmap[i] & (1 << j))) {\n                    return i * 32 + j;\n                }\n            }\n        }\n    }\n    return -1;  // Out of memory\n}\n\n// Allocate a single frame, returns physical address\nvoid *alloc_frame(void) {\n    int frame = find_free_frame();\n    if (frame == -1) {\n        return NULL;  // Out of memory\n    }\n    \n    set_frame(frame);\n    return (void *)(frame * FRAME_SIZE);\n}\n\n// Free a frame by physical address\nvoid free_frame(void *addr) {\n    uint32_t frame = FRAME_FROM_ADDR((uint32_t)addr);\n    \n    // Safety checks\n    if (frame < first_usable_frame || frame >= total_frames) {\n        panic(\"free_frame: invalid frame number %d\\n\", frame);\n    }\n    \n    // Double-free detection\n    if (!test_frame(frame)) {\n        panic(\"free_frame: double free at frame %d (addr 0x%x)\\n\", frame, addr);\n    }\n    \n    clear_frame(frame);\n}\n```\n\n### Initializing the Frame Allocator\n\n```c\nvoid frame_allocator_init(multiboot_info_t *mbi) {\n    // Calculate total physical memory\n    uint32_t max_addr = 0;\n    multiboot_mmap_entry_t *entry = (multiboot_mmap_entry_t *)mbi->mmap_addr;\n    \n    while ((uint32_t)entry < mbi->mmap_addr + mbi->mmap_length) {\n        uint32_t end = entry->base_addr + entry->length;\n        if (end > max_addr) {\n            max_addr = end;\n        }\n        entry = (multiboot_mmap_entry_t *)((uint32_t)entry + entry->size + 4);\n    }\n    \n    total_frames = max_addr / FRAME_SIZE;\n    \n    // Allocate bitmap (must be in identity-mapped region)\n    uint32_t bitmap_size = (total_frames + 31) / 32 * sizeof(uint32_t);\n    frame_bitmap = (uint32_t *)placement_alloc(bitmap_size);\n    \n    // Mark everything as reserved initially\n    memset(frame_bitmap, 0xFF, bitmap_size);\n    \n    // Mark usable regions as free\n    first_usable_frame = total_frames;  // Start with max\n    entry = (multiboot_mmap_entry_t *)mbi->mmap_addr;\n    \n    while ((uint32_t)entry < mbi->mmap_addr + mbi->mmap_length) {\n        if (entry->type == E820_USABLE) {\n            uint32_t start_frame = FRAME_FROM_ADDR(entry->base_addr);\n            uint32_t end_frame = FRAME_FROM_ADDR(entry->base_addr + entry->length);\n            \n            // Align to frame boundaries\n            if (start_frame * FRAME_SIZE < entry->base_addr) start_frame++;\n            if (end_frame * FRAME_SIZE > entry->base_addr + entry->length) end_frame--;\n            \n            for (uint32_t f = start_frame; f < end_frame; f++) {\n                clear_frame(f);\n                if (f < first_usable_frame) {\n                    first_usable_frame = f;\n                }\n            }\n        }\n        entry = (multiboot_mmap_entry_t *)((uint32_t)entry + entry->size + 4);\n    }\n    \n    // Reserve kernel and already-allocated memory\n    extern uint32_t _kernel_start;\n    extern uint32_t _kernel_end;\n    \n    uint32_t kernel_start_frame = FRAME_FROM_ADDR((uint32_t)&_kernel_start);\n    uint32_t kernel_end_frame = FRAME_FROM_ADDR((uint32_t)&_kernel_end) + 1;\n    \n    for (uint32_t f = kernel_start_frame; f < kernel_end_frame; f++) {\n        set_frame(f);  // Mark as used\n    }\n    \n    kprintf(\"Frame allocator initialized: %d frames, first usable at 0x%x\\n\",\n            total_frames, first_usable_frame * FRAME_SIZE);\n}\n```\n\n### Alternative: Linked List Allocator\n\nA free-list allocator tracks free frames by linking them together:\n\n```c\nstruct free_frame {\n    struct free_frame *next;\n};\n\nstatic struct free_frame *free_list = NULL;\n\nvoid *alloc_frame(void) {\n    if (free_list == NULL) {\n        return NULL;\n    }\n    \n    struct free_frame *frame = free_list;\n    free_list = free_list->next;\n    return (void *)frame;\n}\n\nvoid free_frame(void *addr) {\n    struct free_frame *frame = (struct free_frame *)addr;\n    frame->next = free_list;\n    free_list = frame;\n}\n```\n\n**Trade-off**: The free-list is O(1) for both allocation and freeing, but requires careful handling of the initial population and doesn't handle double-free detection as naturally.\n\n---\n\n## Page Tables: The Two-Level Hierarchy\n\n### x86 32-bit Paging Structure\n\nOn x86 without PAE (Physical Address Extension), paging uses a two-level hierarchy:\n\n{{DIAGRAM:diag-page-table-hierarchy}}\n\n1. **Page Directory (PD)**: 1024 entries, each covering 4MB of virtual space\n2. **Page Table (PT)**: 1024 entries, each covering 4KB of virtual space\n\nThe CR3 register holds the **physical address** of the page directory.\n\n```c\n#define PAGE_SIZE 4096\n#define ENTRIES_PER_TABLE 1024\n\n// Page Directory/Table Entry\ntypedef uint32_t pte_t;\n\n// Entry flags\n#define PTE_PRESENT    (1 << 0)\n#define PTE_WRITABLE   (1 << 1)\n#define PTE_USER       (1 << 2)\n#define PTE_WRITETHRU  (1 << 3)\n#define PTE_CACHE_DIS  (1 << 4)\n#define PTE_ACCESSED   (1 << 5)\n#define PTE_DIRTY      (1 << 6)   // Page tables only\n#define PTE_PAGE_SIZE  (1 << 7)   // 4MB pages in PD\n#define PTE_GLOBAL     (1 << 8)   // Not flushed on CR3 reload\n#define PTE_FRAME_MASK 0xFFFFF000\n\ntypedef struct {\n    pte_t entries[ENTRIES_PER_TABLE];\n} page_table_t;\n\ntypedef struct {\n    pte_t entries[ENTRIES_PER_TABLE];\n} page_directory_t;\n\n// Current page directory\nstatic page_directory_t *current_directory;\n```\n\n### Extracting Address Components\n\n```c\n// Extract indices from a virtual address\n#define PD_INDEX(addr) (((addr) >> 22) & 0x3FF)\n#define PT_INDEX(addr) (((addr) >> 12) & 0x3FF)\n#define PAGE_OFFSET(addr) ((addr) & 0xFFF)\n\n// Get frame address from PTE\n#define PTE_FRAME(pte) ((pte) & PTE_FRAME_MASK)\n```\n\n### Mapping Virtual to Physical\n\n```c\n// Map a virtual page to a physical frame\nvoid map_page(page_directory_t *dir, uint32_t virt, uint32_t phys, uint32_t flags) {\n    // Align addresses to page boundaries\n    virt &= ~0xFFF;\n    phys &= ~0xFFF;\n    \n    uint32_t pd_idx = PD_INDEX(virt);\n    uint32_t pt_idx = PT_INDEX(virt);\n    \n    // Get or create page table\n    pte_t *pde = &dir->entries[pd_idx];\n    page_table_t *pt;\n    \n    if (!(*pde & PTE_PRESENT)) {\n        // Allocate new page table\n        pt = (page_table_t *)alloc_frame();\n        if (!pt) {\n            panic(\"Failed to allocate page table for 0x%x\\n\", virt);\n        }\n        \n        // Clear the page table\n        memset(pt, 0, sizeof(page_table_t));\n        \n        // Set page directory entry\n        *pde = ((uint32_t)pt) | PTE_PRESENT | PTE_WRITABLE | (flags & PTE_USER);\n    } else {\n        pt = (page_table_t *)PTE_FRAME(*pde);\n    }\n    \n    // Set page table entry\n    pte_t *pte = &pt->entries[pt_idx];\n    *pte = phys | flags | PTE_PRESENT;\n    \n    // Invalidate TLB entry\n    asm volatile(\"invlpg (%0)\" : : \"r\"(virt));\n}\n\n// Unmap a virtual page\nvoid unmap_page(page_directory_t *dir, uint32_t virt) {\n    uint32_t pd_idx = PD_INDEX(virt);\n    uint32_t pt_idx = PT_INDEX(virt);\n    \n    if (!(dir->entries[pd_idx] & PTE_PRESENT)) {\n        return;  // Nothing mapped\n    }\n    \n    page_table_t *pt = (page_table_t *)PTE_FRAME(dir->entries[pd_idx]);\n    pt->entries[pt_idx] = 0;  // Clear present bit\n    \n    // Invalidate TLB entry\n    asm volatile(\"invlpg (%0)\" : : \"r\"(virt));\n}\n\n// Get physical address for a virtual address (returns 0 if not mapped)\nuint32_t get_physical(page_directory_t *dir, uint32_t virt) {\n    uint32_t pd_idx = PD_INDEX(virt);\n    uint32_t pt_idx = PT_INDEX(virt);\n    \n    if (!(dir->entries[pd_idx] & PTE_PRESENT)) {\n        return 0;\n    }\n    \n    page_table_t *pt = (page_table_t *)PTE_FRAME(dir->entries[pd_idx]);\n    \n    if (!(pt->entries[pt_idx] & PTE_PRESENT)) {\n        return 0;\n    }\n    \n    return PTE_FRAME(pt->entries[pt_idx]) | PAGE_OFFSET(virt);\n}\n```\n\n---\n\n## Identity Mapping + Higher-Half Kernel\n\n### The Address Space Layout Problem\n\nYour kernel needs to be accessible from every process (for system calls, interrupt handlers). But user processes need isolated address spaces. The solution: **higher-half kernel**.\n\n{{DIAGRAM:diag-identity-higher-half}}\n\n```\nVirtual Address Space:\n┌─────────────────┐ 0xFFFFFFFF\n│   Kernel Space  │ (1GB, reserved)\n│   0xC0000000+   │\n├─────────────────┤ 0xC0000000 (3GB)\n│                 │\n│   User Space    │ (3GB, per-process)\n│   0x00000000+   │\n│                 │\n└─────────────────┘ 0x00000000\n```\n\nThe kernel is linked to run at 0xC0000000+ but loaded at 0x100000 physical. The page tables create both:\n- **Identity mapping**: 0x00000000-0x00FFFFFF → 0x00000000-0x00FFFFFF (for VGA, MMIO)\n- **Higher-half mapping**: 0xC0000000-0xC0FFFFFF → 0x00000000-0x00FFFFFF (for kernel code)\n\n### Setting Up the Initial Page Tables\n\n```c\n#define KERNEL_VIRTUAL_BASE 0xC0000000\n#define KERNEL_PHYSICAL_BASE 0x100000\n\n// Identity-map the first N MB and map the kernel at higher half\nvoid paging_init(void) {\n    // Allocate page directory\n    page_directory_t *dir = (page_directory_t *)alloc_frame();\n    memset(dir, 0, sizeof(page_directory_t));\n    \n    // Identity map first 16MB (kernel + VGA + MMIO)\n    // This allows VGA at 0xB8000 to still work\n    for (uint32_t addr = 0; addr < 16 * 1024 * 1024; addr += PAGE_SIZE) {\n        // Supervisor-only, writable, present\n        map_page(dir, addr, addr, PTE_WRITABLE);\n    }\n    \n    // Higher-half mapping for kernel (0xC0000000+)\n    // Map first 16MB at 0xC0000000 as well\n    for (uint32_t offset = 0; offset < 16 * 1024 * 1024; offset += PAGE_SIZE) {\n        uint32_t virt = KERNEL_VIRTUAL_BASE + offset;\n        uint32_t phys = offset;\n        map_page(dir, virt, phys, PTE_WRITABLE);\n    }\n    \n    current_directory = dir;\n    \n    // Load CR3 and enable paging\n    load_cr3(dir);\n    enable_paging();\n}\n```\n\n### Enabling Paging: The Critical Sequence\n\n{{DIAGRAM:diag-paging-enable}}\n\n```c\nvoid load_cr3(page_directory_t *dir) {\n    uint32_t phys = (uint32_t)dir;\n    asm volatile(\"mov %0, %%cr3\" : : \"r\"(phys));\n}\n\nvoid enable_paging(void) {\n    uint32_t cr0;\n    asm volatile(\"mov %%cr0, %0\" : \"=r\"(cr0));\n    cr0 |= (1 << 31);  // Set PG bit\n    asm volatile(\"mov %0, %%cr0\" : : \"r\"(cr0));\n}\n```\n\n**CRITICAL**: The identity mapping must exist *before* you enable paging. The instruction that sets CR0.PG is at some virtual address V. The very next instruction fetch uses V, which must translate to the correct physical address. Without identity mapping, V doesn't map to anything, and you page fault immediately.\n\n### TLB Flushing\n\n```c\n// Flush a single TLB entry\nstatic inline void invlpg(uint32_t addr) {\n    asm volatile(\"invlpg (%0)\" : : \"r\"(addr) : \"memory\");\n}\n\n// Flush entire TLB (by reloading CR3)\nstatic inline void flush_tlb(void) {\n    uint32_t cr3;\n    asm volatile(\"mov %%cr3, %0\" : \"=r\"(cr3));\n    asm volatile(\"mov %0, %%cr3\" : : \"r\"(cr3));\n}\n```\n\nWhen to flush:\n- After modifying any page table entry: `invlpg(addr)`\n- On context switch: reload CR3 (implicit flush)\n- After changing page directory entries: reload CR3\n\n---\n\n## Page Fault Handler: Diagnosis and Recovery\n\nThe page fault handler (exception 14) is your window into the paging system. When a translation fails, the CPU:\n\n1. Pushes error code onto stack\n2. Loads CR2 with the faulting virtual address\n3. Vectors through IDT to your handler\n\n{{DIAGRAM:diag-page-fault-handler}}\n\n### The Error Code\n\n```\nBit 0 (P): Present\n  0 = page not present\n  1 = protection violation\n\nBit 1 (W): Write\n  0 = read access\n  1 = write access\n\nBit 2 (U): User\n  0 = supervisor mode\n  1 = user mode\n\nBit 3 (R): Reserved bit\n  0 = not caused by reserved bit\n  1 = reserved bit set in page tables\n\nBit 4 (I): Instruction fetch\n  0 = data access\n  1 = instruction fetch (NX bit violation)\n```\n\n### Handler Implementation\n\n```c\nvoid page_fault_handler(registers_t *regs) {\n    uint32_t faulting_addr;\n    asm volatile(\"mov %%cr2, %0\" : \"=r\"(faulting_addr));\n    \n    int present = !(regs->err_code & 0x1);\n    int write = regs->err_code & 0x2;\n    int user = regs->err_code & 0x4;\n    int reserved = regs->err_code & 0x8;\n    int exec = regs->err_code & 0x10;\n    \n    kprintf(\"\\n=== PAGE FAULT ===\\n\");\n    kprintf(\"Faulting address: 0x%x\\n\", faulting_addr);\n    kprintf(\"Error code: 0x%x\\n\", regs->err_code);\n    kprintf(\"  Cause: \");\n    \n    if (present) {\n        kprintf(\"Protection violation (\");\n    } else {\n        kprintf(\"Page not present (\");\n    }\n    \n    if (write) kprintf(\"write \");\n    else kprintf(\"read \");\n    \n    if (user) kprintf(\"user-mode \");\n    else kprintf(\"kernel-mode \");\n    \n    if (reserved) kprintf(\"reserved-bit \");\n    if (exec) kprintf(\"instruction-fetch \");\n    \n    kprintf(\")\\n\");\n    \n    // Print where we were\n    kprintf(\"EIP: 0x%x, CS: 0x%x\\n\", regs->eip, regs->cs);\n    \n    // Check if address is in valid ranges\n    if (faulting_addr < 0x100000) {\n        kprintf(\"Address in low memory (below 1MB)\\n\");\n    } else if (faulting_addr >= KERNEL_VIRTUAL_BASE && \n               faulting_addr < KERNEL_VIRTUAL_BASE + 16*1024*1024) {\n        kprintf(\"Address in kernel space (higher-half)\\n\");\n    } else if (faulting_addr >= 0x100000 && faulting_addr < 16*1024*1024) {\n        kprintf(\"Address in identity-mapped region\\n\");\n    } else {\n        kprintf(\"Address outside mapped regions\\n\");\n    }\n    \n    // For now, halt on any page fault\n    // Later: implement demand paging, copy-on-write, etc.\n    panic(\"Page fault - system halted\\n\");\n}\n```\n\n---\n\n## Kernel Heap: Dynamic Memory Allocation\n\n### The Need for kmalloc\n\nThe frame allocator gives you 4KB chunks. But often you need 100 bytes for a string, or 48 bytes for a process structure. The kernel heap bridges this gap.\n\n\n![Kernel Heap Allocator: kmalloc/kfree](./diagrams/diag-kmalloc-internals.svg)\n\n\n### Simple Heap Implementation: Linked List of Blocks\n\n```c\n#define HEAP_START    0xC0400000  // Virtual address for heap\n#define HEAP_SIZE     (4 * 1024 * 1024)  // 4MB initial heap\n#define BLOCK_MAGIC   0xDEADBEEF\n\ntypedef struct heap_block {\n    uint32_t magic;\n    uint32_t size;          // Size of data area (not including header)\n    int free;               // 1 if free, 0 if allocated\n    struct heap_block *next;\n    struct heap_block *prev;\n} heap_block_t;\n\nstatic heap_block_t *heap_head = NULL;\nstatic uint32_t heap_current = HEAP_START;\n\nvoid heap_init(void) {\n    // Allocate first page for heap\n    void *frame = alloc_frame();\n    map_page(current_directory, heap_current, (uint32_t)frame, PTE_WRITABLE);\n    \n    // Initialize first block\n    heap_head = (heap_block_t *)heap_current;\n    heap_head->magic = BLOCK_MAGIC;\n    heap_head->size = PAGE_SIZE - sizeof(heap_block_t);\n    heap_head->free = 1;\n    heap_head->next = NULL;\n    heap_head->prev = NULL;\n    \n    heap_current += PAGE_SIZE;\n}\n\n// Expand heap by one page\nstatic void heap_expand(void) {\n    void *frame = alloc_frame();\n    if (!frame) {\n        panic(\"kmalloc: out of physical memory\\n\");\n    }\n    \n    map_page(current_directory, heap_current, (uint32_t)frame, PTE_WRITABLE);\n    \n    // Find last block\n    heap_block_t *last = heap_head;\n    while (last->next) {\n        last = last->next;\n    }\n    \n    // If last block is free, expand it\n    if (last->free) {\n        last->size += PAGE_SIZE;\n    } else {\n        // Create new free block\n        heap_block_t *new_block = (heap_block_t *)heap_current;\n        new_block->magic = BLOCK_MAGIC;\n        new_block->size = PAGE_SIZE - sizeof(heap_block_t);\n        new_block->free = 1;\n        new_block->next = NULL;\n        new_block->prev = last;\n        last->next = new_block;\n    }\n    \n    heap_current += PAGE_SIZE;\n}\n\nvoid *kmalloc(uint32_t size) {\n    // Align size to 4 bytes\n    size = (size + 3) & ~3;\n    \n    // Find a free block large enough (first-fit)\n    heap_block_t *block = heap_head;\n    while (block) {\n        if (block->magic != BLOCK_MAGIC) {\n            panic(\"kmalloc: heap corruption detected\\n\");\n        }\n        \n        if (block->free && block->size >= size) {\n            // Found a suitable block\n            \n            // Split block if it's much larger\n            if (block->size > size + sizeof(heap_block_t) + 16) {\n                heap_block_t *new_block = (heap_block_t *)((uint32_t)block + \n                                          sizeof(heap_block_t) + size);\n                new_block->magic = BLOCK_MAGIC;\n                new_block->size = block->size - size - sizeof(heap_block_t);\n                new_block->free = 1;\n                new_block->next = block->next;\n                new_block->prev = block;\n                \n                if (block->next) {\n                    block->next->prev = new_block;\n                }\n                \n                block->size = size;\n                block->next = new_block;\n            }\n            \n            block->free = 0;\n            return (void *)((uint32_t)block + sizeof(heap_block_t));\n        }\n        \n        block = block->next;\n    }\n    \n    // No suitable block found, expand heap\n    heap_expand();\n    \n    // Try again (should succeed now)\n    return kmalloc(size);\n}\n\nvoid kfree(void *ptr) {\n    if (!ptr) return;\n    \n    heap_block_t *block = (heap_block_t *)((uint32_t)ptr - sizeof(heap_block_t));\n    \n    if (block->magic != BLOCK_MAGIC) {\n        panic(\"kfree: invalid pointer or heap corruption\\n\");\n    }\n    \n    block->free = 1;\n    \n    // Coalesce with next block if free\n    if (block->next && block->next->free) {\n        block->size += sizeof(heap_block_t) + block->next->size;\n        block->next = block->next->next;\n        if (block->next) {\n            block->next->prev = block;\n        }\n    }\n    \n    // Coalesce with previous block if free\n    if (block->prev && block->prev->free) {\n        block->prev->size += sizeof(heap_block_t) + block->size;\n        block->prev->next = block->next;\n        if (block->next) {\n            block->next->prev = block->prev;\n        }\n    }\n}\n```\n\n### A Simpler Alternative: Placement Allocator\n\nFor early boot (before heap is ready), a simple bump allocator works:\n\n```c\nstatic uint32_t placement_addr = 0x100000;  // Start after kernel\n\nvoid *placement_alloc(uint32_t size) {\n    // Align to 4 bytes\n    size = (size + 3) & ~3;\n    \n    void *addr = (void *)placement_addr;\n    placement_addr += size;\n    \n    return addr;\n}\n```\n\nThis never frees memory—use only for allocations that persist for the kernel's lifetime (like the frame bitmap).\n\n---\n\n## Hardware Soul: The Physical Reality of Virtual Memory\n\n**TLB miss cost**: A TLB miss triggers a hardware page table walk. On x86, this is 2-4 memory accesses (PD + PT). With DDR4 latency around 70ns, a TLB miss costs 140-280ns. At 3GHz, that's 400-800 cycles. The TLB is tiny (64-128 entries on modern CPUs) because fully-associative lookups are expensive—every TLB entry must be compared against the virtual address in parallel.\n\n**Cache behavior of page tables**: Page tables live in regular memory and are cached in L1/L2/L3 like any other data. A process with good locality has its page tables hot in cache. A random-access workload (database hash join, graph traversal) thrashes not just data cache but page table cache too.\n\n**Context switch TLB flush**: Reloading CR3 flushes the TLB on x86 (unless PCID is used). This is 100-500 cycles of pure overhead per context switch. This is why kernel threads share the same address space—they don't need CR3 reload. Linux uses \"lazy TLB flushing\" for kernel threads.\n\n**Page fault overhead**: A page fault is a full context switch to the kernel, plus CR2 read, plus handler execution, plus potential I/O wait. Even for demand paging from RAM (not disk), this is thousands of cycles. This is why madvise(MADV_WILLNEED) exists—prefault pages before the critical path.\n\n**Memory access pattern matters**: Sequential access through a 4KB page costs 1 TLB miss for 1024 32-bit accesses. Random access across 1000 pages costs 1000 TLB misses. Same data size, 1000x difference in TLB overhead. This is why structure-of-arrays (SoA) beats array-of-structures (AoS) for cache and TLB efficiency.\n\n---\n\n## Debugging Memory Management\n\n**Symptom: Immediate page fault when enabling paging**\n\n- Identity mapping missing or incorrect\n- Check: Is the code you're executing identity-mapped?\n- Debug: Print the virtual address of `enable_paging()` and verify it maps correctly\n\n**Symptom: Page fault with garbage address (0xCCCCCCCC or similar)**\n\n- Uninitialized pointer\n- Check: All pointers initialized before use\n- Debug: Use magic patterns (0xDEADBEEF) to detect uninitialized memory\n\n**Symptom: Page fault in kernel at reasonable address**\n\n- Page not mapped or protection violation\n- Check: Is the page table entry present? Writable?\n- Debug: Print page directory and page table entries for the faulting address\n\n**Symptom: Random corruption, crashes after varying time**\n\n- Double-free in heap allocator\n- Buffer overflow\n- Use-after-free\n- Debug: Add magic numbers to heap blocks, check on alloc/free\n\n**Symptom: System hangs, no interrupts processed**\n\n- Ran out of physical frames\n- Page table allocation failing silently\n- Debug: Track total free frames, warn when low\n\n**Symptom: VGA stops working after enabling paging**\n\n- Identity mapping for 0xB8000 missing\n- Check: First 16MB identity mapped?\n- Debug: Print PTE for address 0xB8000\n\n---\n\n## Design Decision: Bitmap vs Free-List Allocator\n\n| Aspect | Bitmap | Free-List | Recommendation |\n|--------|--------|-----------|----------------|\n| Allocation | O(n) scan for free bit | O(1) pop from list | Free-list for speed |\n| Freeing | O(1) clear bit | O(1) push to list | Equal |\n| Double-free detection | Easy (test before clear) | Hard (corrupts list) | Bitmap wins |\n| Memory overhead | Fixed (1 bit per frame) | Variable (list pointers) | Bitmap predictable |\n| Fragmentation tracking | Hard to see patterns | Easy (list order) | Free-list wins |\n| Used by Linux | Buddy allocator (not bitmap) | Per-zone free lists | Hybrid |\n\nFor a learning OS, start with bitmap for simplicity and double-free detection. A free-list is faster but harder to debug.\n\n---\n\n## Knowledge Cascade\n\nYou've built the memory management system—the foundation that everything else in your kernel stands on. Here's where this knowledge connects:\n\n**Container and VM Memory Isolation**: The user/supervisor bits in page table entries are exactly what Docker, KVM, and every sandboxing technology relies on. When a container process tries to read kernel memory, the CPU checks the user bit—0 means supervisor-only, page fault. A missing supervisor bit is a kernel memory disclosure vulnerability (CVE-2019-18683 was exactly this). Hypervisors use the same mechanism: guest physical → host physical mappings with privilege isolation. Understanding page table bits is understanding the attack surface of isolation.\n\n**Memory-Mapped I/O and Device Drivers (Cross-Domain)**: The identity mapping you keep for VGA (0xB8000) is the same technique used for every memory-mapped device: NIC registers, GPU command buffers, DMA engines. A network driver maps the NIC's BAR (Base Address Register) region and writes descriptor pointers directly. The CPU doesn't know it's writing to a device—it's just a store to a memory address. This is why `volatile` is mandatory for MMIO: the compiler must not optimize away or reorder these accesses.\n\n**Game Engine Asset Streaming**: The higher-half kernel mapping you implemented teaches address space layout that game engines use for streaming. A game might reserve virtual address 0x10000000-0x20000000 for texture streaming, mapping and unmapping physical pages as assets load/unload. The virtual address stays constant; the backing physical memory changes. This is exactly what your `map_page()` function does, just called at runtime instead of boot.\n\n**Garbage Collector Write Barriers**: The dirty and accessed bits in page tables are used by generational garbage collectors to track which pages need scanning. A GC can mark all pages read-only, let the dirty bit track which pages were written to, and only scan those pages in the next collection cycle. This is called \"page-level write barrier\" and reduces GC pause times dramatically for large heaps.\n\n**Page Cache and File-Backed Memory**: The concepts here—virtual to physical mapping, demand allocation, lazy evaluation—are exactly what Linux's page cache does. When you read a file, Linux doesn't copy data into your buffer. It maps the file's page cache pages into your address space. Same physical page, mapped in multiple processes. Copy-on-write (which you can implement by clearing the writable bit) enables fork() efficiency.\n\n**Forward: What You Can Now Build**: With working memory management, you can:\n- Implement per-process address spaces (each process gets its own page directory)\n- Add demand paging (page fault handler loads from disk)\n- Build copy-on-write fork (map pages read-only, copy on write fault)\n- Create shared memory for IPC (map same physical pages in multiple processes)\n- Implement memory-mapped files (map file contents into address space)\n\n---\n\n## Summary\n\nYou've built the memory management layer that transforms physical RAM into virtual address spaces:\n\n1. **Physical memory map**: Parse E820/multiboot to discover usable, reserved, and ACPI regions\n2. **Frame allocator**: Bitmap or free-list tracking of 4KB frames with double-free detection\n3. **Page tables**: Two-level hierarchy (PD + PT) translating 32-bit virtual to physical addresses\n4. **Identity + higher-half mapping**: Low memory identity-mapped for VGA/MMIO; kernel at 0xC0000000+\n5. **Paging enablement**: Load CR3, set CR0.PG, maintain TLB coherence with invlpg\n6. **Page fault handler**: Read CR2 for faulting address, diagnose from error code\n7. **Kernel heap**: kmalloc/kfree providing arbitrary-size allocations backed by frame allocator\n\nThe revelation: memory is not a byte array. It's a two-level translation structure cached in a tiny, non-coherent TLB. Every access walks this hierarchy or hits the cache. Modify a page table entry, and the CPU will happily use stale translations until you explicitly invalidate them.\n\nThe physical constraints—4KB frames, two-level translation, TLB cache behavior, CR3 reload cost—shape every decision. This is systems programming: negotiating with hardware, not abstracting it away.\n\n\n![OS Kernel Architecture: Satellite View](./diagrams/diag-satellite-system.svg)\n\n\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-os-m4 -->\n# Milestone 4: Processes and Preemptive Scheduling\n\n## The Tension: One CPU, Many Tasks—The Illusion of Simultaneity\n\nYou have one CPU core. Your user wants to type in a text editor while music plays in the background and a compiler runs in another window. Three distinct instruction streams, one execution engine.\n\nThe hardware offers no magic \"run multiple things\" instruction. What it does offer is precise enough to build the illusion yourself:\n\n- **Timer interrupt**: Fire IRQ0 every N milliseconds, giving you a foothold back in the kernel\n- **Register save/restore**: Push all registers to memory, pop them back—exactly the mechanism function calls use, applied to an entire process\n- **Privilege levels**: Ring 0 (kernel) and ring 3 (user) with hardware-enforced boundaries\n\nBut here's the brutal constraint: when the timer fires, the currently running process is mid-instruction. Its EIP points somewhere in its code. Its stack has local variables. Its registers hold intermediate computation results. If you don't save *every single byte of state* and restore it perfectly later, that process crashes—or worse, produces silent corruption.\n\nThe numbers that matter:\n- **Context switch overhead**: 100-500 cycles saving/restoring registers, plus TLB flush if address spaces differ\n- **Timer quantum**: 10ms typical (100Hz timer), meaning 10-50ms of useful work between switches\n- **Cache impact**: A process evicts ~100KB of L1 cache per millisecond; after 10ms, the next process finds a cold cache\n- **TLB entries**: 64-128 entries, all flushed on CR3 reload—every virtual address translation starts cold\n\nThis milestone implements preemptive multitasking: the mechanism by which your kernel creates the illusion of parallelism through rapid, precise, hardware-assisted context switching.\n\n---\n\n## Revelation: It's Not Parallelism—It's Perfect Amnesia\n\n**What you might think**: \"The scheduler runs multiple processes at once, switching between them so fast they all appear to run simultaneously.\"\n\n**What actually happens**:\n\nOnly ONE process executes at any instant. The \"concurrent\" illusion requires this exact sequence:\n\n1. Timer interrupt fires (IRQ0 → IDT vector 32)\n2. CPU pushes EFLAGS, CS, EIP onto current stack (and SS:ESP if ring 3 → ring 0)\n3. Your IRQ handler saves *every other register* to the current process's PCB\n4. Scheduler picks the next ready process\n5. Your context switch code loads the new process's saved registers\n6. TSS.ESP0 is updated to the new process's kernel stack\n7. `iret` pops EFLAGS, CS, EIP—and you're now running the new process\n\n{{DIAGRAM:diag-context-switch-flow}}\n\nThe magic: the interrupted process has **zero awareness** it was suspended. When it resumes later, its registers are restored, its stack is intact, its EIP points to the next instruction—and it continues as if nothing happened.\n\nBut here's what surprises most developers: **system calls are not function calls**.\n\nWhen user code executes `int 0x80`, the CPU:\n1. Looks up IDT entry 0x80\n2. Checks privilege transition (DPL of gate vs CPL of caller)\n3. **Switches stacks** using TSS.SS0:ESP0\n4. Pushes user SS, ESP, EFLAGS, CS, EIP\n5. Loads kernel CS:EIP from IDT entry\n6. Begins executing kernel code at ring 0\n\nYou cannot implement this with a function call. The hardware *must* be involved because ring transitions require stack switching for security—the kernel stack is not accessible from user mode, so the CPU can't trust a user-supplied stack pointer.\n\n\n![Ring 3 → Ring 0 Transition: Stack Switch](./diagrams/diag-ring-transition.svg)\n\n\nAnd the TSS (Task State Segment)? Not optional. Without TSS.SS0:ESP0 configured, the CPU has nowhere to put the kernel stack during a ring 3 → ring 0 transition. The result: triple fault, system reset.\n\n---\n\n## System Map: Where We Are\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                         YOUR OS KERNEL                          │\n│                                                                 │\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │\n│  │    PCB      │  │   Context   │  │     TSS     │             │\n│  │   Manager   │  │   Switch    │  │   Config    │             │\n│  │  (create,   │  │  (assembly) │  │  (SS0:ESP0) │             │\n│  │   destroy)  │  │             │  │             │             │\n│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘             │\n│         │                │                │                     │\n│         └────────────────┼────────────────┘                     │\n│                          │                                      │\n│  ┌───────────────────────┴───────────────────────┐             │\n│  │                 SCHEDULER                      │             │\n│  │  Round-robin: timer IRQ → pick next → switch   │             │\n│  └───────────────────────┬───────────────────────┘             │\n│                          │                                      │\n│         ┌────────────────┼────────────────┐                     │\n│         ↓                ↓                ↓                     │\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │\n│  │  Process A  │  │  Process B  │  │  Process C  │             │\n│  │  (running)  │  │   (ready)   │  │   (ready)   │             │\n│  │   ring 0    │  │   ring 0    │  │   ring 3    │             │\n│  └─────────────┘  └─────────────┘  └─────────────┘             │\n│                                                                 │\n│  ┌─────────────────────────────────────────────────────────────┐│\n│  │                    HARDWARE                                 ││\n│  │  Timer IRQ0 → IDT → Scheduler → Context Switch → iret      ││\n│  │  TSS provides SS0:ESP0 for ring 3→0 stack switch          ││\n│  └─────────────────────────────────────────────────────────────┘│\n└─────────────────────────────────────────────────────────────────┘\n```\n\nWe're building the process management layer: PCB structures to hold process state, context switch assembly to swap register sets, TSS configuration for privilege transitions, a round-robin scheduler, and system call infrastructure.\n\n---\n\n## The Process Control Block: Capturing a Process's Soul\n\n### What Must Be Saved\n\nA process is defined entirely by its register state and memory. To suspend and resume it perfectly, you need:\n\n{{DIAGRAM:diag-pcb-structure}}\n\n```c\ntypedef enum {\n    PROCESS_READY,\n    PROCESS_RUNNING,\n    PROCESS_BLOCKED,\n    PROCESS_ZOMBIE\n} process_state_t;\n\ntypedef struct process {\n    // Identification\n    uint32_t pid;\n    char name[16];\n    process_state_t state;\n    \n    // Register state (saved on context switch)\n    uint32_t eax, ebx, ecx, edx;\n    uint32_t esi, edi, ebp;\n    uint32_t esp, eip;\n    uint32_t eflags;\n    uint32_t cs, ds, es, fs, gs, ss;\n    \n    // Memory management\n    page_directory_t *page_directory;  // Virtual address space\n    uint32_t kernel_stack;             // Top of kernel stack (for TSS.ESP0)\n    \n    // Scheduling\n    struct process *next;\n    struct process *prev;\n    uint32_t wake_time;                // For sleep/wakeup\n} process_t;\n```\n\nThe fields fall into categories:\n\n**Register state**: Everything the CPU uses. Miss one, and the resumed process corrupts data or crashes.\n\n**Memory management**: Each process gets its own page directory (address space isolation). The kernel stack pointer is crucial—when a user-mode process traps to the kernel (interrupt or syscall), the CPU switches to this stack.\n\n**Scheduling**: Linked list pointers for the run queue, plus any state for blocking/waking.\n\n### PCB Storage\n\n```c\n#define MAX_PROCESSES 64\n#define KERNEL_STACK_SIZE 4096\n\nstatic process_t process_table[MAX_PROCESSES];\nstatic uint32_t next_pid = 1;\n\nprocess_t *current_process = NULL;\nprocess_t *ready_queue = NULL;\n\nprocess_t *create_process(const char *name, void (*entry_point)(void), int is_user) {\n    // Find free slot\n    process_t *proc = NULL;\n    for (int i = 0; i < MAX_PROCESSES; i++) {\n        if (process_table[i].state == PROCESS_ZOMBIE || \n            process_table[i].pid == 0) {\n            proc = &process_table[i];\n            break;\n        }\n    }\n    \n    if (!proc) {\n        return NULL;  // Process table full\n    }\n    \n    // Initialize PCB\n    memset(proc, 0, sizeof(process_t));\n    proc->pid = next_pid++;\n    strncpy(proc->name, name, 15);\n    proc->state = PROCESS_READY;\n    \n    // Allocate kernel stack\n    void *stack_frame = alloc_frame();\n    proc->kernel_stack = (uint32_t)stack_frame + KERNEL_STACK_SIZE;\n    \n    // Set up initial register state\n    proc->eip = (uint32_t)entry_point;\n    proc->esp = proc->kernel_stack;\n    proc->ebp = proc->kernel_stack;\n    proc->eflags = 0x202;  // IF=1 (interrupts enabled), bit 1 always set\n    \n    // Segment selectors\n    if (is_user) {\n        proc->cs = 0x1B;  // User code selector (ring 3)\n        proc->ds = proc->es = proc->fs = proc->gs = proc->ss = 0x23;  // User data\n        proc->esp = 0xBFFFFFFF;  // User stack at top of user space\n        \n        // Create user page directory (copy kernel mappings)\n        proc->page_directory = clone_page_directory(current_directory);\n    } else {\n        proc->cs = 0x08;  // Kernel code selector (ring 0)\n        proc->ds = proc->es = proc->fs = proc->gs = proc->ss = 0x10;  // Kernel data\n        proc->page_directory = current_directory;  // Share kernel space\n    }\n    \n    // Add to ready queue\n    proc->next = ready_queue;\n    if (ready_queue) {\n        ready_queue->prev = proc;\n    }\n    ready_queue = proc;\n    \n    return proc;\n}\n```\n\n### Setting Up the First Process\n\nThe first process isn't \"created\"—it *is* the kernel's current execution state. You construct its PCB by capturing what's already running:\n\n```c\nvoid scheduler_init(void) {\n    // Create PCB for current (kernel) process\n    process_t *kernel_proc = &process_table[0];\n    memset(kernel_proc, 0, sizeof(process_t));\n    \n    kernel_proc->pid = next_pid++;\n    strcpy(kernel_proc->name, \"kernel\");\n    kernel_proc->state = PROCESS_RUNNING;\n    kernel_proc->page_directory = current_directory;\n    kernel_proc->kernel_stack = 0x90000;  // Current kernel stack\n    \n    current_process = kernel_proc;\n}\n```\n\n---\n\n## Context Switch: The Assembly Core\n\n### Why Assembly is Mandatory\n\nC provides no control over:\n- Which registers are saved and in what order\n- Stack pointer manipulation during the save\n- The exact layout of the register dump\n- Loading CR3 (page directory base)\n\nThe context switch must be written in assembly.\n\n{{DIAGRAM:diag-context-switch-flow}}\n\n### The Assembly Implementation\n\n```asm\n; context_switch.asm\n; void context_switch(process_t *old, process_t *new)\n\nglobal context_switch\nextern current_process\n\nsection .text\n\n; Process struct offsets (must match C struct)\n%define PCB_PID         0\n%define PCB_EAX         8\n%define PCB_EBX         12\n%define PCB_ECX         16\n%define PCB_EDX         20\n%define PCB_ESI         24\n%define PCB_EDI         28\n%define PCB_EBP         32\n%define PCB_ESP         36\n%define PCB_EIP         40\n%define PCB_EFLAGS      44\n%define PCB_CS          48\n%define PCB_DS          52\n%define PCB_ES          56\n%define PCB_FS          60\n%define PCB_GS          64\n%define PCB_SS          68\n%define PCB_PAGE_DIR    72\n%define PCB_KERNEL_STACK 76\n\ncontext_switch:\n    ; Arguments: [esp+4] = old process, [esp+8] = new process\n    push ebp\n    mov ebp, esp\n    \n    pushfd                    ; Save EFLAGS\n    pushad                    ; Save EAX, ECX, EDX, EBX, ESP (old), EBP, ESI, EDI\n    \n    ; Save segment registers\n    push ds\n    push es\n    push fs\n    push gs\n    \n    ; Get pointer to old process\n    mov eax, [ebp + 8]        ; old process pointer\n    test eax, eax\n    jz .load_new              ; If old is NULL, skip saving\n    \n    ; Save registers to old PCB\n    mov [eax + PCB_EAX], eax  ; ... actually need to be careful here\n    ; Better: use edi as temp since we pushed it\n    \n    ; Actually, reload old pointer and save properly\n    mov edi, [ebp + 8]        ; old process\n    \n    ; Get stack position before we pushed stuff\n    mov ecx, [ebp - 4]        ; pushed ebp\n    mov [edi + PCB_EBP], ecx\n    \n    ; We need the ESP value from BEFORE pushad\n    ; pushad pushes: EAX, ECX, EDX, EBX, ESP(original), EBP, ESI, EDI\n    ; The ESP in pushad is at offset 16 from start of pushad area\n    mov ecx, [esp + 16]       ; Original ESP from pushad\n    mov [edi + PCB_ESP], ecx\n    \n    ; Save other registers from pushad\n    mov ecx, [esp + 0]        ; EDI\n    mov [edi + PCB_EDI], ecx\n    mov ecx, [esp + 4]        ; ESI\n    mov [edi + PCB_ESI], ecx\n    mov ecx, [esp + 20]       ; EBX\n    mov [edi + PCB_EBX], ecx\n    mov ecx, [esp + 24]       ; EDX\n    mov [edi + PCB_EDX], ecx\n    mov ecx, [esp + 28]       ; ECX\n    mov [edi + PCB_ECX], ecx\n    mov ecx, [esp + 32]       ; EAX\n    mov [edi + PCB_EAX], ecx\n    \n    ; Save EFLAGS\n    mov ecx, [esp + 36]       ; EFLAGS (after pushad + segs)\n    add ecx, 16               ; Adjust for segment registers\n    mov [edi + PCB_EFLAGS], ecx\n    \n    ; Save instruction pointer (return address from context_switch call)\n    mov ecx, [ebp + 4]\n    mov [edi + PCB_EIP], ecx\n    \n    ; Save segment registers\n    mov [edi + PCB_DS], ds\n    mov [edi + PCB_ES], es\n    mov [edi + PCB_FS], fs\n    mov [edi + PCB_GS], gs\n    mov [edi + PCB_CS], cs\n    mov [edi + PCB_SS], ss\n\n.load_new:\n    ; Load new process\n    mov esi, [ebp + 12]       ; new process\n    \n    ; Update current_process\n    mov [current_process], esi\n    \n    ; Load page directory if different\n    mov eax, [current_directory]\n    mov ebx, [esi + PCB_PAGE_DIR]\n    cmp eax, ebx\n    je .same_page_dir\n    \n    ; Switch to new page directory\n    mov cr3, ebx\n    mov [current_directory], ebx\n    \n.same_page_dir:\n    ; Update TSS.ESP0 for ring 3 processes\n    extern tss_update_esp0\n    push dword [esi + PCB_KERNEL_STACK]\n    call tss_update_esp0\n    add esp, 4\n    \n    ; Restore segment registers\n    mov ds, [esi + PCB_DS]\n    mov es, [esi + PCB_ES]\n    mov fs, [esi + PCB_FS]\n    mov gs, [esi + PCB_GS]\n    \n    ; Restore general registers\n    mov eax, [esi + PCB_EAX]\n    mov ebx, [esi + PCB_EBX]\n    mov ecx, [esi + PCB_ECX]\n    mov edx, [esi + PCB_EDX]\n    mov edi, [esi + PCB_EDI]\n    \n    ; Restore stack pointer and EBP\n    mov esp, [esi + PCB_ESP]\n    mov ebp, [esi + PCB_EBP]\n    \n    ; Restore ESI last (we were using it)\n    mov esi, [esi + PCB_ESI]\n    \n    ; Restore EFLAGS and return\n    pushfd\n    popfd\n    \n    ret\n```\n\n### A Cleaner Approach: Using iret\n\nA more robust approach uses `iret` to restore EIP, CS, EFLAGS, and optionally ESP/SS:\n\n```asm\n; Simpler context switch using iret\nglobal switch_to_process\n\nswitch_to_process:\n    ; [esp+4] = new process PCB pointer\n    mov eax, [esp + 4]\n    \n    ; Update current_process global\n    extern current_process\n    mov [current_process], eax\n    \n    ; Switch page directory\n    mov ebx, [eax + PCB_PAGE_DIR]\n    mov cr3, ebx\n    \n    ; Update TSS.ESP0\n    extern tss\n    mov ecx, [eax + PCB_KERNEL_STACK]\n    mov [tss + 4], ecx        ; tss.esp0 offset\n    \n    ; Set up stack for iret\n    ; Need: EIP, CS, EFLAGS, (ESP, SS if user mode)\n    mov ebx, [eax + PCB_ESP]\n    mov ecx, [eax + PCB_EFLAGS]\n    mov edx, [eax + PCB_EIP]\n    \n    ; Check if user mode (CS = 0x1B)\n    cmp word [eax + PCB_CS], 0x1B\n    je .user_mode\n    \n.kernel_mode:\n    ; Build kernel-mode iret frame\n    push ecx                  ; EFLAGS\n    push dword [eax + PCB_CS] ; CS\n    push edx                  ; EIP\n    push dword [eax + PCB_GS]\n    push dword [eax + PCB_FS]\n    push dword [eax + PCB_ES]\n    push dword [eax + PCB_DS]\n    push dword [eax + PCB_EDI]\n    push dword [eax + PCB_ESI]\n    push dword [eax + PCB_EBP]\n    push ebx                  ; ESP (will be loaded before iret)\n    push dword [eax + PCB_EBX]\n    push dword [eax + PCB_EDX]\n    push dword [eax + PCB_ECX]\n    push dword [eax + PCB_EAX]\n    \n    ; Restore registers\n    pop eax\n    pop ecx\n    pop edx\n    pop ebx\n    add esp, 4                ; Skip ESP (already set)\n    pop ebp\n    pop esi\n    pop edi\n    pop ds\n    pop es\n    pop fs\n    pop gs\n    \n    iret\n    \n.user_mode:\n    ; Build user-mode iret frame (includes SS:ESP)\n    push dword [eax + PCB_SS] ; User SS\n    push ebx                  ; User ESP\n    push ecx                  ; EFLAGS\n    push dword [eax + PCB_CS] ; User CS\n    push edx                  ; EIP\n    ; ... restore other registers ...\n    iret\n```\n\n---\n\n## The TSS: Required for Ring Transitions\n\n### What the TSS Does (and Doesn't Do)\n\nThe **Task State Segment** is a holdover from Intel's original multitasking design. Modern OSes use it for exactly one thing: **stack switching on privilege transitions**.\n\n{{DIAGRAM:diag-tss-structure}}\n\nWhen the CPU transitions from ring 3 to ring 0 (via interrupt, exception, or syscall), it needs a trusted stack. It can't use the user's stack—that would be a security hole. So it loads SS:ESP from TSS.SS0:ESP0.\n\n```c\n// TSS structure (only essential fields shown)\ntypedef struct {\n    uint16_t prev_task;       // 0\n    uint16_t reserved0;\n    uint32_t esp0;            // 4: Stack pointer for ring 0\n    uint16_t ss0;             // 8: Stack segment for ring 0\n    uint16_t reserved1;\n    uint32_t esp1;            // 12: For ring 1 (unused)\n    uint16_t ss1;\n    uint16_t reserved2;\n    uint32_t esp2;            // 20: For ring 2 (unused)\n    uint16_t ss2;\n    uint16_t reserved3;\n    uint32_t cr3;             // 28: Page directory (not used for software switching)\n    uint32_t eip;             // 32\n    uint32_t eflags;          // 36\n    uint32_t eax, ecx, edx, ebx, esp, ebp, esi, edi;  // 40-64\n    uint16_t es;              // 68\n    uint16_t reserved4;\n    uint16_t cs;              // 72\n    uint16_t reserved5;\n    uint16_t ss;              // 76\n    uint16_t reserved6;\n    uint16_t ds;              // 80\n    uint16_t reserved7;\n    uint16_t fs;              // 84\n    uint16_t reserved8;\n    uint16_t gs;              // 88\n    uint16_t reserved9;\n    uint16_t ldt;             // 92\n    uint16_t reserved10;\n    uint16_t trap;            // 96\n    uint16_t iomap_base;      // 102\n} __attribute__((packed)) tss_t;\n\nstatic tss_t tss;\n\nvoid tss_init(void) {\n    memset(&tss, 0, sizeof(tss_t));\n    \n    tss.ss0 = 0x10;           // Kernel data segment\n    tss.esp0 = 0x90000;       // Initial kernel stack (will be updated)\n    tss.iomap_base = sizeof(tss_t);  // No I/O bitmap\n    \n    // Add TSS to GDT (entry 5)\n    // TSS descriptor is a system segment (S=0 in access byte)\n    uint32_t base = (uint32_t)&tss;\n    uint32_t limit = sizeof(tss_t) - 1;\n    \n    gdt_set_gate(5, base, limit, 0xE9, 0x00);  // Present, ring 0, TSS type\n    \n    // Load TR (Task Register)\n    asm volatile(\"ltr %w0\" : : \"r\"(0x28));  // Selector: index 5, TI=0, RPL=0\n}\n\nvoid tss_update_esp0(uint32_t esp0) {\n    tss.esp0 = esp0;\n}\n```\n\n### When TSS.ESP0 Must Be Updated\n\nEvery time you switch to a new process that might run in user mode, you must update TSS.ESP0 to point to that process's kernel stack:\n\n```c\nvoid scheduler_yield(void) {\n    process_t *old = current_process;\n    process_t *new = pick_next_process();\n    \n    if (new && new != old) {\n        old->state = PROCESS_READY;\n        new->state = PROCESS_RUNNING;\n        \n        // Critical: update TSS before context switch\n        tss_update_esp0(new->kernel_stack);\n        \n        context_switch(old, new);\n    }\n}\n```\n\nIf you forget this, a user-mode process traps to the kernel with a stale ESP0, and the kernel stack pointer points to the *previous* process's stack. Corruption ensues.\n\n---\n\n## Round-Robin Scheduler: The Heart of Multitasking\n\n### The Algorithm\n\nRound-robin is the simplest fair scheduling algorithm:\n\n1. Maintain a queue of READY processes\n2. On timer interrupt, move current process to end of queue\n3. Pick the first READY process\n4. Context switch to it\n\n{{DIAGRAM:diag-scheduler-queue}}\n\n```c\nvoid scheduler_tick(void) {\n    // Called from timer interrupt handler\n    \n    if (!current_process) {\n        return;  // Scheduler not initialized\n    }\n    \n    // Current process used its time slice\n    // Move it to the back of the ready queue\n    if (current_process->state == PROCESS_RUNNING) {\n        current_process->state = PROCESS_READY;\n        \n        // Move to end of queue\n        if (ready_queue && ready_queue->next) {\n            process_t *last = ready_queue;\n            while (last->next) {\n                last = last->next;\n            }\n            \n            // Remove current from front\n            ready_queue = current_process->next;\n            if (ready_queue) {\n                ready_queue->prev = NULL;\n            }\n            \n            // Add to back\n            last->next = current_process;\n            current_process->prev = last;\n            current_process->next = NULL;\n        }\n    }\n    \n    // Pick next process\n    process_t *next = ready_queue;\n    while (next) {\n        if (next->state == PROCESS_READY) {\n            break;\n        }\n        next = next->next;\n    }\n    \n    if (next && next != current_process) {\n        schedule_switch(next);\n    }\n}\n\nvoid schedule_switch(process_t *next) {\n    process_t *prev = current_process;\n    \n    next->state = PROCESS_RUNNING;\n    current_process = next;\n    \n    // Remove from ready queue\n    if (next->prev) {\n        next->prev->next = next->next;\n    } else {\n        ready_queue = next->next;\n    }\n    if (next->next) {\n        next->next->prev = next->prev;\n    }\n    next->prev = NULL;\n    next->next = NULL;\n    \n    // Update TSS before switch\n    tss_update_esp0(next->kernel_stack);\n    \n    // Perform context switch\n    context_switch(prev, next);\n}\n```\n\n### Integration with Timer Interrupt\n\n```c\n// In interrupt handler (from Milestone 2)\nvoid irq_handler(registers_t *regs) {\n    uint8_t irq = regs->int_no - 32;\n    \n    switch (irq) {\n        case 0:  // Timer\n            timer_ticks++;\n            scheduler_tick();\n            break;\n        case 1:  // Keyboard\n            keyboard_handler();\n            break;\n        // ... other IRQs ...\n    }\n    \n    pic_send_eoi(irq);\n}\n```\n\n---\n\n## Demonstration: Three Kernel Processes\n\nTo prove preemptive multitasking works, create three processes that each print to a different screen region:\n\n{{DIAGRAM:diag-multi-process-demo}}\n\n```c\nvoid process_a(void) {\n    int count = 0;\n    while (1) {\n        vga_set_cursor(0, 0);\n        vga_puts(\"[Process A] Count: \");\n        vga_put_dec(count++);\n        vga_puts(\"\\n\");\n        \n        // Busy loop to consume time slice\n        for (volatile int i = 0; i < 1000000; i++);\n    }\n}\n\nvoid process_b(void) {\n    int count = 0;\n    while (1) {\n        vga_set_cursor(10, 0);\n        vga_puts(\"[Process B] Count: \");\n        vga_put_dec(count++);\n        vga_puts(\"\\n\");\n        \n        for (volatile int i = 0; i < 1000000; i++);\n    }\n}\n\nvoid process_c(void) {\n    int count = 0;\n    while (1) {\n        vga_set_cursor(20, 0);\n        vga_puts(\"[Process C] Count: \");\n        vga_put_dec(count++);\n        vga_puts(\"\\n\");\n        \n        for (volatile int i = 0; i < 1000000; i++);\n    }\n}\n\nvoid demo_multitasking(void) {\n    kprintf(\"Creating kernel processes...\\n\");\n    \n    create_process(\"proc_a\", process_a, 0);  // 0 = kernel mode\n    create_process(\"proc_b\", process_b, 0);\n    create_process(\"proc_c\", process_c, 0);\n    \n    kprintf(\"Enabling scheduler...\\n\");\n    \n    // Enable timer interrupt\n    uint8_t mask = inb(PIC1_DATA);\n    mask &= ~0x01;  // Enable IRQ0\n    outb(PIC1_DATA, mask);\n    \n    // Enable interrupts\n    asm volatile(\"sti\");\n    \n    // Yield to let scheduler take over\n    scheduler_yield();\n    \n    // We never reach here\n}\n```\n\nThe three counters increment independently, each process unaware it's being interrupted dozens of times per second.\n\n---\n\n## User Mode: Crossing the Ring Boundary\n\n### Creating a User Process\n\nA user process differs from a kernel process in three ways:\n\n1. **Segment selectors**: CS=0x1B, DS/ES/SS=0x23 (ring 3, CPL=3)\n2. **Page directory**: Isolated from kernel, with kernel pages marked supervisor-only\n3. **Stack**: Located in user space, not kernel space\n\n{{DIAGRAM:diag-user-kernel-memory}}\n\n```c\nprocess_t *create_user_process(const char *name, void (*entry)(void)) {\n    process_t *proc = create_process(name, entry, 1);\n    if (!proc) return NULL;\n    \n    // Allocate user stack (at top of user space: 0xBFFFF000)\n    uint32_t user_stack_virt = 0xBFFFF000;\n    void *user_stack_phys = alloc_frame();\n    \n    // Map user stack in process's page directory\n    map_page(proc->page_directory, user_stack_virt, \n             (uint32_t)user_stack_phys, PTE_WRITABLE | PTE_USER);\n    \n    proc->esp = user_stack_virt + PAGE_SIZE;  // Top of stack\n    proc->ss = 0x23;  // User data segment (ring 3)\n    \n    // Copy user code (for now, assume it's somewhere in kernel memory)\n    // In a real OS, you'd load from an executable file\n    \n    return proc;\n}\n```\n\n### Entering User Mode: The iret Trick\n\nTo transition from kernel to user mode, you use `iret` with a specially crafted stack frame:\n\n```asm\n; enter_user_mode(entry_point, user_stack_top)\nglobal enter_user_mode\n\nenter_user_mode:\n    mov eax, [esp + 4]    ; Entry point\n    mov ebx, [esp + 8]    ; User stack top\n    \n    ; Set up segment registers for user mode\n    mov cx, 0x23          ; User data selector\n    mov ds, cx\n    mov es, cx\n    mov fs, cx\n    mov gs, cx\n    \n    ; Push user mode stack frame for iret\n    push 0x23             ; SS (user data)\n    push ebx              ; ESP (user stack)\n    pushf                 ; EFLAGS\n    push 0x1B             ; CS (user code)\n    push eax              ; EIP (entry point)\n    \n    ; Enable interrupts in EFLAGS\n    or dword [esp + 8], 0x200\n    \n    ; Jump to user mode\n    iret\n```\n\nThe `iret` instruction pops SS, ESP, EFLAGS, CS, EIP from the stack. Because CS=0x1B (CPL=3), the CPU transitions to ring 3, loads the user stack from your pushed value, and begins executing user code.\n\n### Isolation Verification\n\nA user process should NOT be able to access kernel memory:\n\n```c\nvoid user_process_test(void) {\n    // This should trigger a page fault\n    uint32_t *kernel_addr = (uint32_t *)0xC0100000;\n    *kernel_addr = 0xDEADBEEF;  // Write to kernel memory\n    \n    // Should never reach here\n    sys_write(\"This should never print\\n\");\n}\n```\n\nWhen this runs in ring 3, the page table entry for 0xC0100000 has the user/supervisor bit clear (supervisor-only). The CPU raises a page fault with error code bit 2 set (user-mode access).\n\n---\n\n## System Calls: User-to-Kernel Communication\n\n### The INT 0x80 Interface\n\nSystem calls use software interrupts to transition from user to kernel mode. The convention:\n\n- **EAX**: System call number\n- **EBX, ECX, EDX**: Arguments (up to 3)\n- **EAX (return)**: Return value\n\n{{DIAGRAM:diag-syscall-interface}}\n\n### Setting Up the Syscall Gate\n\n```c\n#define SYSCALL_WRITE  0\n#define SYSCALL_EXIT   1\n#define SYSCALL_READ   2\n\nvoid syscall_handler(registers_t *regs) {\n    switch (regs->eax) {\n        case SYSCALL_WRITE:\n            // sys_write(fd, buf, len)\n            regs->eax = sys_write(\n                (int)regs->ebx,\n                (const char *)regs->ecx,\n                (size_t)regs->edx\n            );\n            break;\n            \n        case SYSCALL_EXIT:\n            // sys_exit(status)\n            sys_exit((int)regs->ebx);\n            break;\n            \n        case SYSCALL_READ:\n            // sys_read(fd, buf, len)\n            regs->eax = sys_read(\n                (int)regs->ebx,\n                (char *)regs->ecx,\n                (size_t)regs->edx\n            );\n            break;\n            \n        default:\n            kprintf(\"Unknown syscall: %d\\n\", regs->eax);\n            regs->eax = -1;\n    }\n}\n\nvoid syscall_init(void) {\n    // Register syscall handler at IDT entry 0x80\n    // DPL=3 allows user mode to call via INT 0x80\n    idt_set_gate(0x80, (uint32_t)isr128, 0x08, 0xEE);  // 0xEE = DPL 3, present, interrupt gate\n}\n```\n\n### Implementing sys_write\n\n```c\nint sys_write(int fd, const char *buf, size_t len) {\n    // Validate file descriptor\n    if (fd < 0 || fd >= MAX_FDS) {\n        return -1;  // EBADF\n    }\n    \n    // Validate buffer pointer (must be in user space)\n    if ((uint32_t)buf >= KERNEL_VIRTUAL_BASE) {\n        return -1;  // EFAULT\n    }\n    \n    // For now, just write to VGA\n    for (size_t i = 0; i < len; i++) {\n        vga_putchar(buf[i]);\n    }\n    \n    return len;\n}\n```\n\n### Implementing sys_exit\n\n```c\nvoid sys_exit(int status) {\n    kprintf(\"Process %d exiting with status %d\\n\", \n            current_process->pid, status);\n    \n    // Mark process as zombie\n    current_process->state = PROCESS_ZOMBIE;\n    \n    // Free resources\n    if (current_process->page_directory != current_directory) {\n        // Free user page directory and frames\n        // (implementation depends on your memory manager)\n    }\n    \n    // Remove from ready queue\n    if (current_process->prev) {\n        current_process->prev->next = current_process->next;\n    }\n    if (current_process->next) {\n        current_process->next->prev = current_process->prev;\n    }\n    \n    // Schedule next process\n    scheduler_yield();\n    \n    // Never returns\n}\n```\n\n### User-Space Syscall Wrapper\n\n```c\n// In user code (or a libc-like library)\nstatic inline int syscall0(int num) {\n    int ret;\n    asm volatile(\"int $0x80\" : \"=a\"(ret) : \"a\"(num));\n    return ret;\n}\n\nstatic inline int syscall3(int num, int a, int b, int c) {\n    int ret;\n    asm volatile(\"int $0x80\" \n                 : \"=a\"(ret) \n                 : \"a\"(num), \"b\"(a), \"c\"(b), \"d\"(c));\n    return ret;\n}\n\nvoid user_print(const char *msg) {\n    int len = 0;\n    while (msg[len]) len++;\n    syscall3(SYSCALL_WRITE, 1, (int)msg, len);\n}\n\nvoid user_exit(int status) {\n    syscall1(SYSCALL_EXIT, status);\n}\n```\n\n---\n\n## Hardware Soul: The Physical Cost of Multitasking\n\n\n![Context Switch: Cache and TLB Impact](./diagrams/diag-cache-analysis-context-switch.svg)\n\n\n**Context switch overhead breakdown**:\n- Register save/restore: 50-100 cycles (pushad/popad + segments)\n- CR3 reload: 10-20 cycles, plus TLB flush cost\n- TLB refill: 100-500 cycles per miss, ~64 entries = potentially 32,000 cycles worst case\n- Cache cold start: L1 miss is ~4 cycles, L2 miss is ~12 cycles, L3 miss is ~40 cycles, memory is ~150 cycles\n\n**The TLB flush problem**: Reloading CR3 flushes the TLB (unless PCID is used). A process with good locality might have 50 TLB entries populated. After a switch, all 50 are gone. The next instruction might trigger a TLB miss, then another, then another. This is why kernel threads share the same address space—no TLB flush.\n\n**Cache pollution**: Process A runs for 10ms, filling L1 with its data. Context switch to process B. Process B's working set evicts process A's. When process A runs again, it finds a cold cache. This is the working set size problem: if a process's working set exceeds L1 cache, it suffers cache misses every time it's scheduled.\n\n**Interrupt latency vs scheduling latency**: Timer interrupt fires every 10ms. But if you're in an interrupt handler or critical section with interrupts disabled, the scheduler can't run. Worst-case scheduling latency = timer quantum + maximum interrupt handler time + maximum critical section time. This is why real-time systems minimize interrupt handler work and keep critical sections short.\n\n**The scheduling granularity trade-off**:\n- Shorter quantum (1ms): Better responsiveness, more context switch overhead\n- Longer quantum (100ms): Less overhead, worse interactivity\n\nAt 100Hz (10ms quantum) with 5 processes, each gets 2 CPU seconds per wall-clock second. But context switch overhead at 100Hz is 0.1% of CPU time—negligible. At 1000Hz, it's 1%. At 10000Hz, it's 10%. There's a reason 100-1000Hz is typical.\n\n---\n\n## Debugging Scheduler Issues\n\n**Symptom: System freezes after enabling scheduler**\n\n- Timer interrupt not firing: Check PIC mask, IDT entry for IRQ0\n- No ready processes: Check that processes were created\n- Context switch corrupts state: Add serial debug prints before/after switch\n\n**Symptom: Processes run once, then crash**\n\n- EIP not saved correctly: Check PCB offset calculations\n- Stack corruption: Verify ESP is saved/restored correctly\n- Page directory not switched: Check CR3 loading\n\n**Symptom: User-mode process causes triple fault**\n\n- TSS not initialized: Check `ltr` was called\n- TSS.ESP0 not updated: Must update on every context switch\n- User page tables missing kernel mapping: Kernel pages must be mapped but supervisor-only\n\n**Symptom: Syscall returns garbage or crashes**\n\n- Arguments not passed correctly: Check EBX/ECX/EDX handling\n- Return value not in EAX: Check that handler sets regs->eax\n- IDT gate DPL wrong: Must be 3 to allow user-mode `int 0x80`\n\n**Symptom: Page fault in user mode accessing valid address**\n\n- User bit not set on page table entry\n- Page not mapped in user's page directory\n- Stack overflow (user stack too small)\n\n---\n\n## Design Decision: Cooperative vs Preemptive Scheduling\n\n| Aspect | Cooperative | Preemptive | Used By |\n|--------|-------------|------------|---------|\n| Switch trigger | Process yields | Timer interrupt | Preemptive: Linux, Windows |\n| Latency | Unbounded | Bounded | Cooperative: Green threads |\n| Implementation | Simple | Complex (interrupt-safety) | |\n| Fault isolation | Bad (crash hangs system) | Good (can kill stuck process) | |\n| Real-time | Impossible | Possible with priority | |\n\nPreemptive scheduling is mandatory for a general-purpose OS. Cooperative can work for specific workloads (event-driven servers, embedded loops) but can't guarantee responsiveness.\n\n---\n\n## Knowledge Cascade\n\nYou've built preemptive multitasking—the mechanism that makes modern computing possible. Here's where this knowledge connects:\n\n**Thread Pools and Async Runtimes**: The context switch you implemented is exactly what green threads do in software. Go's goroutines save registers to a structure, switch to the next runnable goroutine, and restore—same mechanism, user-space implementation. Tokio tasks in Rust, Erlang processes, and Java virtual threads all use this technique. The difference is they don't need ring transitions or TSS manipulation—they're all in user space. Understanding register save/restore is fundamental to designing coroutine systems.\n\n**Virtualization and VM Exits (Cross-Domain)**: When a VM executes a privileged instruction (like accessing CR3), the CPU performs a \"VM exit\"—analogous to your ring 3→ring 0 transition. The VMCS (Virtual Machine Control Structure) saves guest state (registers, segment selectors, CR3) just like your PCB saves process state. The hypervisor handles the exit, potentially emulates the instruction, then does a \"VM entry\" to resume the guest. VMware, KVM, and Hyper-V all implement this loop. Understanding your TSS and ring transitions is the first step to understanding VM introspection and escape exploits.\n\n**Real-Time Scheduling**: Your round-robin scheduler is the foundation for understanding advanced schedulers. Linux's CFS (Completely Fair Scheduler) uses a red-black tree instead of a queue, tracking \"virtual runtime\" to ensure fairness. SCHED_FIFO and SCHED_RR provide real-time guarantees—the timer interrupt doesn't demote them, only explicit yield or blocking does. Deadline scheduling (EDF—Earliest Deadline First) is used in hard real-time systems. All of these are variations on the context switch you just built.\n\n**Security: Privilege Escalation Attacks**: The ring boundary and TSS mechanism you implemented is exactly what kernel exploits try to bypass. A privilege escalation exploit might: (1) find a kernel bug that writes to user-controlled address, (2) overwrite a function pointer with user-controlled code, (3) trigger kernel execution of that code. The CPU is now executing ring 3 code with ring 0 privileges. Meltdown and Spectre attacks target the same isolation machinery—speculative execution crossing protection boundaries. Understanding ring transitions is understanding the attack surface.\n\n**Coroutine Implementations in Game Engines**: Fiber-based job systems in game engines (Unity's Jobs system, Unreal's task graph) use the same context-switching techniques. A game might have 10,000 \"fibers\" (lightweight threads) that yield when waiting for animation, physics, or I/O. The fiber switch saves registers to a fiber-local context, just like your PCB. The difference is fibers never cross privilege levels—pure user-space switching. This is how modern games achieve massive parallelism without OS thread overhead.\n\n**Forward: What You Can Now Build**: With preemptive multitasking, you can:\n- Implement blocking I/O (process blocks on read, scheduler runs others)\n- Add process priorities (higher priority processes run first)\n- Build signals (interrupt a process asynchronously, like SIGKILL)\n- Create /proc filesystem (expose PCB information to user space)\n- Implement fork/exec (create new processes from user space)\n\n---\n\n## Summary\n\nYou've built preemptive multitasking—the illusion of parallelism through precise, hardware-assisted context switching:\n\n1. **Process Control Block (PCB)**: Stores PID, all registers, page directory, kernel stack pointer\n2. **Context switch**: Assembly routine that saves old process state and loads new process state\n3. **TSS (Task State Segment)**: Provides SS0:ESP0 for ring 3→ring 0 stack switching\n4. **Round-robin scheduler**: Timer interrupt triggers queue rotation and context switch\n5. **User-mode processes**: Ring 3 execution with isolated address spaces\n6. **System calls**: INT 0x80 with DPL=3 enables user→kernel transitions\n\nThe revelation: only ONE process runs at a time. \"Concurrent\" execution is achieved by saving every register, loading the next process's registers, and jumping to its saved EIP. The interrupted process has no awareness it was suspended. System calls are not function calls—they trigger hardware privilege transitions through IDT gates, with stack switching via TSS.\n\nThe physical constraints—TLB flush on CR3 reload, cache pollution between processes, interrupt latency affecting scheduling latency—shape every design decision. This is systems programming at its most fundamental.\n\n\n![OS Kernel Architecture: Satellite View](./diagrams/diag-satellite-system.svg)\n\n\n---\n<!-- END_MS -->\n\n\n\n\n# TDD\n\nA complete x86 operating system kernel implementing the critical path from BIOS bootstrap to preemptive multitasking with user-mode processes. The design negotiates with x86 hardware constraints at every layer: 512-byte MBR limit, A20 line legacy, GDT/IDT configuration, 4KB page granularity, TLB non-coherence, and ring-level transitions. The kernel provides interrupt-driven I/O, virtual memory with higher-half mapping, and preemptive round-robin scheduling with privilege isolation.\n\n\n\n<!-- TDD_MOD_ID: mod-boot -->\n# Technical Design Specification: Bootloader and Protected Mode Entry\n\n## Module Charter\n\nThe bootloader module transforms the CPU from its 16-bit real mode state (as left by BIOS) into 32-bit protected mode with flat segmentation, then loads and transfers control to the C kernel. It handles the A20 line enabling, GDT configuration, protected mode transition, and kernel loading from disk.\n\n**What it does NOT do**: This module does not set up paging (CR0.PG remains 0), does not configure the IDT or enable interrupts, does not perform any memory allocation, and does not handle user-mode (ring 3) transitions.\n\n**Upstream dependencies**: BIOS has loaded the MBR at 0x7C00 and passed the boot drive number in DL.\n\n**Downstream consumers**: The C kernel entry point expects protected mode with flat segments (CS=0x08, DS/ES/SS=0x10), a valid stack, and zeroed BSS section.\n\n**Invariants**: Stage 1 must fit in 510 bytes; GDT must contain at least null + kernel code + kernel data descriptors; protected mode transition must use a far jump to flush the pipeline; kernel must be loaded at a known physical address (0x100000).\n\n---\n\n## File Structure\n\nCreate files in this order:\n\n```\n1. boot/stage1.asm          # Stage 1 bootloader (fits in 512-byte MBR)\n2. boot/stage2.asm          # Stage 2 bootloader (larger, loaded by stage 1)\n3. boot/gdt.asm             # GDT definitions and loader\n4. boot/a20.asm             # A20 line enablement routines\n5. boot/disk.asm            # Disk read routines using INT 13h\n6. boot/kernel_entry.asm    # Kernel entry shim (BSS zeroing, stack setup)\n7. kernel/linker.ld         # Linker script for kernel placement\n8. kernel/main.c            # Kernel C entry point (minimal, for testing)\n9. Makefile                 # Build system\n```\n\n---\n\n## Complete Data Model\n\n### GDT Entry Structure (8 bytes each)\n\nEach GDT entry is 64 bits with specific field packing:\n\n| Offset | Bits | Field | Description |\n|--------|------|-------|-------------|\n| 0-1 | 16 | Limit[15:0] | Low 16 bits of segment limit |\n| 2-3 | 16 | Base[15:0] | Low 16 bits of base address |\n| 4 | 8 | Base[23:16] | Bits 16-23 of base address |\n| 5 | 8 | Access Byte | Present, DPL, Type flags |\n| 6 | 8 | Flags + Limit[19:16] | Granularity, size, high limit bits |\n| 7 | 8 | Base[31:24] | Bits 24-31 of base address |\n\n**Access Byte (byte 5) bit layout:**\n\n| Bit | Name | Value for Kernel Code | Value for Kernel Data |\n|-----|------|----------------------|----------------------|\n| 7 | Present | 1 | 1 |\n| 6-5 | DPL | 00 (ring 0) | 00 (ring 0) |\n| 4 | S (System) | 1 (code/data) | 1 (code/data) |\n| 3 | Executable | 1 | 0 |\n| 2 | DC (Direction/Conforming) | 0 | 0 |\n| 1 | RW (Read/Writable) | 1 (readable) | 1 (writable) |\n| 0 | Accessed | 0 (CPU sets) | 0 |\n\n**Access byte values:**\n- Kernel Code: `0x9A` (10011010b)\n- Kernel Data: `0x92` (10010010b)\n\n**Flags (high 4 bits of byte 6):**\n\n| Bit | Name | Value |\n|-----|------|-------|\n| 7 | Granularity | 1 (4KB pages) |\n| 6 | Size | 1 (32-bit) |\n| 5 | Long | 0 (not 64-bit) |\n| 4 | Reserved | 0 |\n\n**Flags value: `0xC`** (1100b shifted to high nibble = `0xC0` when combined with limit)\n\n**Complete GDT entry bytes:**\n\n```\nNull Descriptor (index 0):\n  Bytes: 00 00 00 00 00 00 00 00\n\nKernel Code (index 1, selector 0x08):\n  Base=0x00000000, Limit=0xFFFFF (4GB with 4KB granularity)\n  Bytes: FF FF 00 00 00 9A CF 00\n\nKernel Data (index 2, selector 0x10):\n  Base=0x00000000, Limit=0xFFFFF (4GB with 4KB granularity)\n  Bytes: FF FF 00 00 00 92 CF 00\n```\n\n### GDTR Structure (6 bytes)\n\n```\nOffset 0-1: Limit (16-bit, size of GDT - 1)\nOffset 2-5: Base (32-bit, linear address of GDT)\n```\n\n### Memory Layout at Boot\n\n```\nPhysical Address    Contents\n─────────────────────────────────────────\n0x000000 - 0x0003FF  Real-mode IVT (DO NOT TOUCH)\n0x000400 - 0x0004FF  BDA (BIOS Data Area)\n0x000500 - 0x0007BF  Free (can use for stage 2)\n0x0007C0 - 0x0007FF  Stage 1 bootloader (MBR)\n0x0007FF - 0x000FFF  Free (stack can grow down from 0x7C00)\n0x001000 - 0x00FFFF  Free (low memory)\n0x010000 - 0x01FFFF  EBDA, video RAM, ROM (AVOID)\n0x020000 - 0x0FFFFF  ROM area, video memory (AVOID)\n0x100000 - N         Kernel loaded here (1MB mark)\n```\n\n### Kernel Stack Layout\n\n```\nThe kernel stack is set up at 0x90000 (below 1MB, in identity-mappable region)\nStack grows downward from 0x90000\n```\n\n---\n\n## Interface Contracts\n\n### stage1.asm Entry Point\n\n**Entry**: BIOS jumps to 0x7C00 with:\n- `CS:IP = 0x0000:0x7C00`\n- `DL = boot drive number` (0x00 = floppy, 0x80 = first HDD)\n- Interrupts enabled\n- Real mode (CR0.PE = 0)\n\n**Exit**: Stage 1 jumps to stage 2 (or directly enters protected mode)\n\n**Constraints**:\n- Must fit in 510 bytes (bytes 510-511 are boot signature 0xAA55)\n- Must not modify memory outside 0x7C00-0x7DFF without care\n- BIOS disk services (INT 13h) are only available in real mode\n\n### a20_enable()\n\n**Purpose**: Enable the A20 line to access memory above 1MB\n\n**Parameters**: None\n\n**Returns**: \n- `AX = 1` on success\n- `AX = 0` on failure\n\n**Side effects**: Modifies keyboard controller state, port 0x92\n\n**Error handling**: Tries multiple methods; if all fail, returns 0 but does not halt (some emulators don't need A20)\n\n### gdt_load()\n\n**Purpose**: Load the GDT register with the descriptor table\n\n**Parameters**: None (GDT address is embedded)\n\n**Returns**: None\n\n**Side effects**: Loads GDTR; does NOT enable protected mode\n\n**Constraints**: Must be called before setting CR0.PE\n\n### protected_mode_enter()\n\n**Purpose**: Transition from real mode to protected mode\n\n**Parameters**: None\n\n**Returns**: Never returns (far jump to 32-bit code)\n\n**Side effects**:\n- Sets CR0.PE = 1\n- Performs far jump to flush pipeline\n- Loads all segment registers with kernel data selector\n\n**Constraints**:\n- GDT must be loaded\n- Interrupts must be disabled (`cli`)\n- A20 should be enabled\n- Identity-mapped code must exist at the jump target\n\n### disk_read.sectors(drive, cylinder, head, sector, count, es:bx)\n\n**Purpose**: Read sectors from disk using BIOS INT 13h\n\n**Parameters**:\n- `DL = drive` (passed from BIOS)\n- `CH = cylinder` (low 8 bits)\n- `CL = sector` (bits 0-5) | cylinder high bits (bits 6-7)\n- `DH = head`\n- `AL = count` (sectors to read)\n- `ES:BX = destination buffer`\n\n**Returns**:\n- `CF = 0` on success\n- `CF = 1` on error, `AH = error code`\n\n**Error codes**:\n- `0x01`: Invalid command\n- `0x02`: Address mark not found\n- `0x03`: Write protect (not applicable)\n- `0x04`: Sector not found\n- `0x05`: Reset failed\n- `0x06`: Disk changed\n- `0x08`: DMA overrun\n- `0x09`: DMA boundary error\n- `0x0C`: Invalid media\n- `0x10`: CRC error\n- `0x20`: Controller failure\n- `0x40`: Seek failed\n- `0x80`: Timeout (no response)\n\n**Recovery**: Reset disk system (INT 13h, AH=0) and retry up to 3 times\n\n### kernel_entry (assembly shim)\n\n**Entry**: Called after protected mode transition with:\n- `CS = 0x08` (kernel code selector)\n- `DS/ES/SS = 0x10` (kernel data selector)\n- `ESP = 0x90000` (kernel stack)\n\n**Exit**: Calls `kernel_main()` in C\n\n**Responsibilities**:\n1. Ensure stack is valid\n2. Zero BSS section from `__bss_start` to `__bss_end`\n3. Call `kernel_main()`\n4. Halt if kernel_main returns\n\n---\n\n## Algorithm Specification\n\n### Stage 1 Bootloader Sequence\n\n```\nSTAGE1_BOOT:\n  1. Set up real-mode segments:\n     DS = ES = SS = 0\n     SP = 0x7C00 (stack grows down from bootloader)\n  \n  2. Save boot drive number:\n     Store DL to [boot_drive]\n  \n  3. Display boot message (optional, INT 10h)\n  \n  4. Reset disk system:\n     AH = 0, INT 13h\n  \n  5. Load stage 2 from sectors 2-N:\n     CALL disk_load_stage2\n     IF error: display error, halt\n  \n  6. Enable A20 line:\n     CALL a20_enable\n     IF error: display warning, continue anyway\n  \n  7. Load GDT:\n     LGDT [gdt_descriptor]\n  \n  8. Disable interrupts:\n     CLI\n  \n  9. Enter protected mode:\n     MOV EAX, CR0\n     OR EAX, 1\n     MOV CR0, EAX\n  \n  10. Far jump to 32-bit code:\n      JMP 0x08:protected_mode_entry\n  \n  ; After this point, we're in 32-bit protected mode\n  \n  11. Reload segment registers:\n      MOV AX, 0x10\n      MOV DS, AX\n      MOV ES, AX\n      MOV FS, AX\n      MOV GS, AX\n      MOV SS, AX\n      MOV ESP, 0x90000\n  \n  12. Jump to kernel entry point:\n      JMP 0x08:0x100000\n```\n\n### A20 Line Enablement (Multiple Methods)\n\n```\nA20_ENABLE:\n  ; Method 1: Fast A20 gate (port 0x92)\n  ; Works on most modern systems and emulators\n  \n  IN AL, 0x92\n  TEST AL, 2        ; Check if A20 already enabled\n  JNZ .a20_done\n  \n  OR AL, 2          ; Set A20 bit\n  AND AL, 0xFE      ; Clear reset bit (safety)\n  OUT 0x92, AL\n  JMP .a20_done\n  \n  ; Method 2: Keyboard controller (more compatible)\n  ; The keyboard controller's output port bit 1 controls A20\n  \n  CALL kbc_wait_input   ; Wait for input buffer empty\n  MOV AL, 0xD0          ; Read output port command\n  OUT 0x64, AL\n  CALL kbc_wait_output  ; Wait for output buffer full\n  IN AL, 0x60           ; Read current output port value\n  PUSH AX\n  \n  CALL kbc_wait_input\n  MOV AL, 0xD1          ; Write output port command\n  OUT 0x64, AL\n  \n  CALL kbc_wait_input\n  POP AX\n  OR AL, 2              ; Set A20 bit\n  OUT 0x60, AL\n  \n  CALL kbc_wait_input\n  \n.a20_done:\n  ; Verify A20 is enabled\n  CALL a20_verify\n  RET\n\nKBC_WAIT_INPUT:\n  ; Wait until keyboard controller input buffer is empty\n  IN AL, 0x64\n  TEST AL, 2\n  JNZ KBC_WAIT_INPUT\n  RET\n\nKBC_WAIT_OUTPUT:\n  ; Wait until keyboard controller output buffer is full\n  IN AL, 0x64\n  TEST AL, 1\n  JZ KBC_WAIT_OUTPUT\n  RET\n\nA20_VERIFY:\n  ; Verify A20 is actually enabled by testing memory wraparound\n  ; Write different values to 0x0000:0x0500 and 0xFFFF:0x0510\n  ; If A20 disabled, they alias to the same physical address\n  \n  MOV AX, 0x0000\n  MOV ES, AX\n  MOV DI, 0x0500\n  MOV BYTE [ES:DI], 0x00\n  \n  MOV AX, 0xFFFF\n  MOV ES, AX\n  MOV DI, 0x0510       ; 0xFFFF0 + 0x0510 = 0x100500 (wraps to 0x0500 if A20 off)\n  MOV BYTE [ES:DI], 0xFF\n  \n  MOV AX, 0x0000\n  MOV ES, AX\n  MOV DI, 0x0500\n  CMP BYTE [ES:DI], 0x00\n  \n  JE .a20_is_on        ; If still 0x00, addresses don't alias\n  MOV AX, 0            ; A20 is off\n  RET\n  \n.a20_is_on:\n  MOV AX, 1\n  RET\n```\n\n### Disk Read with Retry\n\n```\nDISK_READ:\n  ; Input: CH = cylinder, CL = sector, DH = head, DL = drive\n  ;        AL = count, ES:BX = buffer\n  ; Output: CF set on error, AH = error code\n  \n  PUSH AX             ; Save sector count\n  MOV SI, 3           ; Retry count\n  \n.retry:\n  POP AX\n  PUSH AX\n  MOV AH, 0x02        ; BIOS read sectors function\n  PUSH SI\n  INT 0x13\n  POP SI\n  JNC .success\n  \n  ; Error occurred - reset disk and retry\n  PUSH AX             ; Save error code\n  XOR AH, AH          ; Reset disk system\n  INT 0x13\n  POP AX\n  \n  DEC SI\n  JNZ .retry\n  \n  ; All retries exhausted\n  POP AX\n  STC                 ; Set carry flag to indicate error\n  RET\n  \n.success:\n  POP AX\n  CLC                 ; Clear carry flag\n  RET\n```\n\n### BSS Zeroing\n\n```\nKERNEL_ENTRY:\n  ; Set up stack (if not already done)\n  MOV ESP, 0x90000\n  \n  ; Zero BSS section\n  ; __bss_start and __bss_end are defined in linker script\n  MOV EDI, __bss_start\n  MOV ECX, __bss_end\n  SUB ECX, EDI        ; Length = end - start\n  XOR EAX, EAX        ; Zero\n  REP STOSB           ; Fill BSS with zeros\n  \n  ; Call C kernel entry point\n  CALL kernel_main\n  \n  ; If kernel_main returns, halt\n.halt:\n  CLI\n  HLT\n  JMP .halt\n```\n\n---\n\n## Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n|-------|-------------|----------|---------------|\n| Disk read failure | INT 13h returns CF=1 | Reset disk, retry up to 3 times | Yes, error message on screen |\n| A20 line stuck | a20_verify returns 0 | Continue anyway (emulators may not need it) | Warning message |\n| No boot signature | BIOS checks bytes 510-511 | N/A (BIOS moves to next device) | \"No bootable device\" |\n| GDT misconfiguration | Triple fault on mode switch | Debug with QEMU `-d int` | System reset |\n| Kernel not found | Disk read returns error | Halt with error message | Yes |\n| Stage 1 too large | Build-time (nasm error) | Remove debug code, optimize | Build fails |\n\n---\n\n## Implementation Sequence with Checkpoints\n\n### Phase 1: Stage 1 Bootloader Assembly (4-6 hours)\n\n**Goal**: Create a bootable MBR that displays a message and halts\n\n**Files to create**:\n1. `boot/stage1.asm`\n\n**Steps**:\n1. Set up the ORG directive at 0x7C00\n2. Initialize segment registers (DS, ES, SS)\n3. Set up stack pointer at 0x7C00\n4. Save boot drive number\n5. Display \"Booting...\" message using INT 10h\n6. Add padding and boot signature\n\n**Checkpoint**: Build and run in QEMU. Should display message and halt.\n```bash\nnasm -f bin boot/stage1.asm -o boot.bin\nqemu-system-i386 -drive format=raw,file=boot.bin\n# Expected: \"Booting...\" message, then system sits idle\n```\n\n### Phase 2: A20 Line Enablement (2-3 hours)\n\n**Goal**: Implement and verify A20 line enabling\n\n**Files to create**:\n1. `boot/a20.asm`\n\n**Steps**:\n1. Implement fast A20 gate method (port 0x92)\n2. Implement keyboard controller method (ports 0x60/0x64)\n3. Implement A20 verification routine\n4. Add debug output showing A20 status\n\n**Checkpoint**: Display \"A20: enabled\" or \"A20: disabled\" on boot\n```bash\n# Build with a20.asm included\n# Expected: \"A20: enabled\" message\n```\n\n### Phase 3: GDT Configuration and Loading (3-4 hours)\n\n**Goal**: Define and load a valid GDT\n\n**Files to create**:\n1. `boot/gdt.asm`\n\n**Steps**:\n1. Define GDT with null, kernel code, and kernel data descriptors\n2. Define GDTR structure (limit and base)\n3. Implement lgdt wrapper\n4. Add debug output showing GDT address\n\n**Checkpoint**: GDT loads without error (no visible crash before protected mode)\n```bash\n# Add message \"GDT loaded\" after lgdt\n# Expected: Message appears, system continues\n```\n\n### Phase 4: Protected Mode Transition (2-3 hours)\n\n**Goal**: Successfully enter 32-bit protected mode\n\n**Files to modify**:\n1. `boot/stage1.asm`\n\n**Steps**:\n1. Add `cli` before mode switch\n2. Set CR0.PE bit\n3. Add far jump to 32-bit code section\n4. Create 32-bit code section with segment register reloads\n5. Display \"Protected mode!\" message\n\n**Checkpoint**: Successfully enter protected mode and display message\n```bash\n# Expected: \"Protected mode!\" message in 32-bit code\n# QEMU should not reset or triple fault\n```\n\n### Phase 5: Kernel Loader (3-4 hours)\n\n**Goal**: Load kernel binary from disk\n\n**Files to create**:\n1. `boot/disk.asm`\n2. `boot/stage2.asm` (optional, for larger loader)\n\n**Steps**:\n1. Implement disk_read routine with retry logic\n2. Calculate CHS geometry for kernel location\n3. Load kernel to 0x100000\n4. Verify kernel was loaded (check first bytes)\n\n**Checkpoint**: Kernel binary loaded to 0x100000\n```bash\n# Create a simple kernel.bin (just a few bytes for testing)\ndd if=/dev/zero of=disk.img bs=512 count=2880\ndd if=boot.bin of=disk.img bs=512 count=1 conv=notrunc\ndd if=kernel.bin of=disk.img bs=512 seek=1 conv=notrunc\n\n# In protected mode, display value at 0x100000\n# Expected: Matches first bytes of kernel.bin\n```\n\n### Phase 6: Kernel Entry Shim (2-3 hours)\n\n**Goal**: Create assembly entry point that calls C code\n\n**Files to create**:\n1. `boot/kernel_entry.asm`\n\n**Steps**:\n1. Set up kernel stack at 0x90000\n2. Zero BSS section using linker symbols\n3. Call kernel_main\n4. Add halt loop if kernel_main returns\n\n**Checkpoint**: C kernel_main is called and can print a message\n```bash\n# kernel_main just prints \"Hello from C!\"\n# Expected: Message appears on screen\n```\n\n### Phase 7: Linker Script Design (2-3 hours)\n\n**Goal**: Define kernel memory layout\n\n**Files to create**:\n1. `kernel/linker.ld`\n\n**Steps**:\n1. Set entry point to kernel_entry\n2. Place .text at 0x100000\n3. Define .rodata, .data, .bss sections\n4. Export __bss_start and __bss_end symbols\n5. Add /DISCARD/ for unwanted sections\n\n**Checkpoint**: Kernel links successfully, BSS is properly zeroed\n```bash\nld -m elf_i386 -T kernel/linker.ld -o kernel.elf kernel_entry.o main.o\nnm kernel.elf | grep bss\n# Expected: __bss_start and __bss_end defined\n```\n\n### Final Integration (2-3 hours)\n\n**Goal**: Complete bootable system\n\n**Steps**:\n1. Create Makefile with all build rules\n2. Create disk image with bootloader and kernel\n3. Add VGA and serial output to kernel_main\n4. Test in QEMU with serial output\n\n**Checkpoint**: Kernel boots, displays welcome message on VGA and serial\n```bash\nmake\nqemu-system-i386 -drive format=raw,file=os.img -serial stdio\n# Expected: Welcome message on screen and serial console\n# Run tests: make test (all pass)\n```\n\n---\n\n## Test Specification\n\n### Test 1: Boot Signature Valid\n\n```python\n# test_boot_signature.py\ndef test_boot_signature():\n    with open('boot.bin', 'rb') as f:\n        data = f.read()\n    \n    assert len(data) == 512, \"Boot sector must be exactly 512 bytes\"\n    assert data[510] == 0x55, \"Byte 510 must be 0x55\"\n    assert data[511] == 0xAA, \"Byte 511 must be 0xAA\"\n```\n\n### Test 2: GDT Structure Valid\n\n```python\n# test_gdt.py\ndef test_gdt_null_descriptor():\n    # Null descriptor must be all zeros\n    # Locate GDT in binary and verify first 8 bytes are 0\n    pass\n\ndef test_gdt_code_descriptor():\n    # Kernel code descriptor:\n    # - Base = 0\n    # - Limit = 0xFFFFF\n    # - Access = 0x9A (present, ring 0, code, readable)\n    # - Flags = 0xC (4KB granularity, 32-bit)\n    pass\n\ndef test_gdt_data_descriptor():\n    # Kernel data descriptor:\n    # - Base = 0\n    # - Limit = 0xFFFFF\n    # - Access = 0x92 (present, ring 0, data, writable)\n    # - Flags = 0xC\n    pass\n```\n\n### Test 3: Protected Mode Entry\n\n```bash\n# test_protected_mode.sh\n# Run QEMU with GDB to verify protected mode entry\n\nqemu-system-i386 -drive format=raw,file=os.img -s -S &\nQEMU_PID=$!\n\nsleep 1\n\ngdb -batch -ex \"target remote :1234\" \\\n    -ex \"break *0x7C00\" \\\n    -ex \"continue\" \\\n    -ex \"x/i \\$pc\" \\\n    -ex \"stepi 100\" \\\n    -ex \"info registers cr0\" \\\n    -ex \"quit\"\n\nkill $QEMU_PID\n\n# Verify CR0.PE bit is set\n```\n\n### Test 4: Kernel Load Address\n\n```bash\n# test_kernel_load.sh\n# Verify kernel is loaded at correct address\n\n# Create test kernel with known pattern\necho -n \"KERNEL_TEST_PATTERN\" > test_pattern.bin\ndd if=test_pattern.bin of=os.img bs=1 seek=$((0x100000)) conv=notrunc\n\n# Run in QEMU and check memory\n# (This requires QEMU monitor or GDB)\n```\n\n### Test 5: BSS Zeroing\n\n```c\n// kernel/test_bss.c\n#include <stdint.h>\n\n// These should be in BSS (uninitialized)\nstatic uint32_t test_var1;\nstatic uint32_t test_var2;\nstatic char test_buffer[256];\n\nvoid test_bss_zeroed(void) {\n    // After kernel entry, all BSS should be zero\n    if (test_var1 != 0 || test_var2 != 0) {\n        vga_puts(\"FAIL: BSS variables not zeroed\\n\");\n        halt();\n    }\n    \n    for (int i = 0; i < 256; i++) {\n        if (test_buffer[i] != 0) {\n            vga_puts(\"FAIL: BSS buffer not zeroed\\n\");\n            halt();\n        }\n    }\n    \n    vga_puts(\"PASS: BSS zeroed correctly\\n\");\n}\n```\n\n### Test 6: Serial Output\n\n```bash\n# test_serial.sh\n# Verify serial output works\n\nOUTPUT=$(qemu-system-i386 -drive format=raw,file=os.img -serial stdio -display none -nographic 2>&1 | timeout 5 cat)\n\nif echo \"$OUTPUT\" | grep -q \"Welcome\"; then\n    echo \"PASS: Serial output working\"\nelse\n    echo \"FAIL: No welcome message on serial\"\n    exit 1\nfi\n```\n\n### Test 7: VGA Output\n\n```bash\n# test_vga.sh\n# Verify VGA text mode output works\n\n# This requires checking VGA buffer in QEMU or visual inspection\n# For automation, we check that the kernel doesn't crash\n\nqemu-system-i386 -drive format=raw,file=os.img -nographic &\nQEMU_PID=$!\n\nsleep 2\n\nif ps -p $QEMU_PID > /dev/null; then\n    echo \"PASS: Kernel running (VGA likely working)\"\n    kill $QEMU_PID\nelse\n    echo \"FAIL: Kernel crashed\"\n    exit 1\nfi\n```\n\n---\n\n## Performance Targets\n\n| Operation | Target | How to Measure |\n|-----------|--------|----------------|\n| Boot to C entry | < 1 second | Time from QEMU start to first serial output |\n| Stage 1 size | ≤ 510 bytes | `wc -c boot.bin` must show 512 (including signature) |\n| GDT load | < 100 cycles | Single `lgdt` instruction |\n| Protected mode switch | < 50 cycles | CR0 write + far jump |\n| Disk read (16KB) | < 100ms | Measure time for loading kernel |\n\n---\n\n## Visual Diagrams\n\n### Boot Sequence\n\n![x86 Boot Sequence: BIOS to C Entry](./diagrams/diag-boot-sequence.svg)\n\n### GDT Structure\n\n```\nGDT Memory Layout:\n┌────────────────────────────────────────────────────────────────┐\n│ Offset 0x00: Null Descriptor                                   │\n│   00 00 00 00 00 00 00 00                                      │\n├────────────────────────────────────────────────────────────────┤\n│ Offset 0x08: Kernel Code Descriptor                            │\n│   ┌──────────────────────────────────────────────────────────┐ │\n│   │ Limit[15:0]  │ Base[15:0] │ Base[23:16] │ Access │ Flags │ │\n│   │    0xFFFF    │   0x0000   │    0x00     │ 0x9A   │0xC*   │ │\n│   │              │            │             │        │ +Lim  │ │\n│   └──────────────────────────────────────────────────────────┘ │\n│   Base[31:24] = 0x00                                           │\n│   Decoded: Base=0, Limit=0xFFFFF (4KB gran = 4GB), 32-bit code │\n├────────────────────────────────────────────────────────────────┤\n│ Offset 0x10: Kernel Data Descriptor                            │\n│   Same as code but Access = 0x92 (data, writable)              │\n│   Decoded: Base=0, Limit=0xFFFFF (4KB gran = 4GB), 32-bit data │\n└────────────────────────────────────────────────────────────────┘\n\nGDTR Register:\n┌────────────────┬────────────────────────────────────────────────┐\n│ Limit (16-bit) │ Base (32-bit)                                  │\n│    0x0017      │ Address of gdt_start                           │\n│  (24-1=23)     │                                                │\n└────────────────┴────────────────────────────────────────────────┘\n```\n\n### Protected Mode Transition\n\n```\nBEFORE (Real Mode):\n┌─────────────────────────────────────────┐\n│ CR0.PE = 0                              │\n│ CS:IP = 0x0000:0x7C00 (real mode addr)  │\n│ GDTR = undefined                        │\n│ Segment registers = real mode values    │\n│ Paging = disabled                       │\n└─────────────────────────────────────────┘\n              │\n              ▼ cli (disable interrupts)\n              │\n              ▼ lgdt [gdt_descriptor]\n              │\n              ▼ mov eax, cr0 / or eax, 1 / mov cr0, eax\n              │\n┌─────────────────────────────────────────┐\n│ CR0.PE = 1                              │\n│ CS:IP = 0x0000:0x7C00 (still real mode! │\n│         CPU is in inconsistent state)   │\n│ GDTR = valid                            │\n│ Pipeline contains 16-bit decoded inst.  │\n└─────────────────────────────────────────┘\n              │\n              ▼ jmp 0x08:protected_mode_entry\n              │  (far jump flushes pipeline,\n              │   loads CS with selector 0x08)\n              │\n┌─────────────────────────────────────────┐\n│ AFTER (Protected Mode):                 │\n│ CR0.PE = 1                              │\n│ CS = 0x08 (kernel code, GDT index 1)    │\n│ EIP = protected_mode_entry              │\n│ DS/ES/SS = still real mode values!      │\n│ (Must reload immediately)               │\n└─────────────────────────────────────────┘\n              │\n              ▼ mov ax, 0x10 / mov ds, ax / ...\n              │\n┌─────────────────────────────────────────┐\n│ FULLY IN PROTECTED MODE:                │\n│ All segment registers = 0x10            │\n│ ESP = 0x90000 (kernel stack)            │\n│ Ready to execute 32-bit kernel code     │\n└─────────────────────────────────────────┘\n```\n\n### Triple Fault Chain\n\n```\nNormal Fault Flow:\n┌──────────────────┐\n│ CPU Exception    │──▶ IDT Entry ──▶ Handler ──▶ iret ──▶ Resume\n└──────────────────┘\n\nDouble Fault:\n┌──────────────────┐\n│ CPU Exception    │──▶ IDT Entry ──▶ Handler CRASHES\n└──────────────────┘         │\n                              ▼\n                    ┌──────────────────┐\n                    │ Double Fault (8) │──▶ IDT[8] ──▶ Handler\n                    └──────────────────┘\n\nTriple Fault (System Reset):\n┌──────────────────┐\n│ CPU Exception    │──▶ IDT Entry ──▶ Handler CRASHES\n└──────────────────┘         │\n                              ▼\n                    ┌──────────────────┐\n                    │ Double Fault (8) │──▶ IDT[8] ──▶ Handler CRASHES\n                    └──────────────────┘         │\n                                                 ▼\n                                       ┌──────────────────┐\n                                       │ Triple Fault     │──▶ CPU RESET\n                                       │ (No handler!)    │\n                                       └──────────────────┘\n\nCommon Causes in Bootloader:\n1. GDT not loaded before setting CR0.PE\n2. Far jump with invalid selector\n3. Segment register load with invalid selector\n4. Stack pointer invalid after mode switch\n5. Code at jump target is not 32-bit\n```\n\n---\n\n## Hardware Soul\n\n### Cache Lines Touched\n\n- **GDT load**: The GDT itself (24 bytes for 3 entries) is read by the CPU into internal descriptor caches. This does NOT go through the normal cache hierarchy—it's a special register load.\n- **Stage 1 execution**: Runs from BIOS ROM shadow or RAM at 0x7C00. First execution likely has cache misses.\n- **Kernel load**: Sequential disk reads are buffered by BIOS. The destination at 0x100000 is likely cache-cold.\n\n### Pipeline Behavior\n\n- **Real mode code**: 16-bit decoding path\n- **Mode switch**: Setting CR0.PE doesn't flush the pipeline—the far jump does\n- **Far jump cost**: 10-30 cycles to flush and refill pipeline with 32-bit code\n- **After switch**: CPU now uses 32-bit decoding path\n\n### Memory Access Patterns\n\n- **Disk reads**: Sequential sector reads via INT 13h. BIOS may optimize this with multi-sector reads.\n- **GDT access**: Single 24-byte read when `lgdt` executes\n- **BSS zeroing**: Sequential writes from `__bss_start` to `__bss_end`. This is cache-friendly (sequential stores).\n\n### I/O Port Access\n\n| Port | Purpose | Timing |\n|------|---------|--------|\n| 0x92 | Fast A20 gate | ~1 microsecond |\n| 0x64 | KBC command | ~10 microseconds wait |\n| 0x60 | KBC data | ~10 microseconds wait |\n\n---\n\n## Implementation Notes\n\n### Stage 1 Size Optimization\n\nIf stage 1 exceeds 510 bytes:\n\n1. Remove string messages (use single characters)\n2. Use shorter instruction encodings (`xor ax, ax` instead of `mov ax, 0`)\n3. Combine operations (`push cs / pop ds` instead of `mov ax, cs / mov ds, ax`)\n4. Move complex code to stage 2\n\n### Two-Stage vs Direct Kernel Load\n\n**Two-stage approach** (recommended):\n- Stage 1: Minimal—just load stage 2 and enter protected mode\n- Stage 2: Larger—load kernel, set up environment, transfer control\n\n**Direct load**:\n- Stage 1 loads kernel directly before protected mode\n- Simpler but limited to what fits in 510 bytes\n\n### Debugging with QEMU\n\n```bash\n# Log all interrupts and CPU resets\nqemu-system-i386 -drive format=raw,file=os.img -d int,cpu_reset -serial stdio 2>&1 | tee debug.log\n\n# Use GDB\nqemu-system-i386 -drive format=raw,file=os.img -s -S &\ngdb -ex \"target remote :1234\" -ex \"break *0x7c00\"\n\n# Monitor commands (in QEMU)\n(qemu) info registers\n(qemu) x/10i $eip\n(qemu) xp /10x 0x100000  # physical memory view\n```\n\n---\n\n\n<!-- TDD_MOD_ID: mod-interrupts -->\n# Technical Design Specification: Interrupt and Exception Handling\n\n## Module Charter\n\nThe interrupt module implements the IDT (Interrupt Descriptor Table) with 256 entries, CPU exception handlers for vectors 0-31, and hardware IRQ handlers for vectors 32-47. It configures the 8259 PIC to remap IRQs away from CPU exception vectors, implements PIT timer and PS/2 keyboard drivers, and provides the infrastructure for asynchronous hardware event handling.\n\n**What it does NOT do**: This module does not implement scheduling (timer just increments a counter), does not handle system calls (vector 0x80), does not implement APIC (uses legacy 8259 PIC only), and does not handle page fault recovery (just prints diagnostics).\n\n**Upstream dependencies**: GDT must be loaded with kernel code (0x08) and data (0x10) selectors; protected mode must be active.\n\n**Downstream consumers**: Scheduler (Milestone 4) uses timer interrupt for preemption; keyboard buffer consumed by shell/TTY; exception handlers provide crash diagnostics.\n\n**Invariants**: All interrupt handlers must save/restore complete register state; EOI must be sent to PIC for all IRQs; IDT must be loaded before interrupts are enabled; PIC must be remapped before any IRQs are unmasked.\n\n---\n\n## File Structure\n\nCreate files in this order:\n\n```\n1. kernel/idt.h              # IDT structures and function declarations\n2. kernel/idt.c              # IDT initialization and gate management\n3. kernel/isr.asm            # Assembly ISR stubs for exceptions 0-31\n4. kernel/irq.asm            # Assembly IRQ stubs for IRQs 0-15\n5. kernel/interrupt_handler.c # Common C handler dispatcher\n6. kernel/pic.h              # PIC interface declarations\n7. kernel/pic.c              # PIC remapping and EOI functions\n8. kernel/timer.h            # PIT timer interface\n9. kernel/timer.c            # PIT initialization and handler\n10. kernel/keyboard.h        # Keyboard interface declarations\n11. kernel/keyboard.c        # PS/2 keyboard driver with scancode table\n12. kernel/registers.h       # Register frame structure definition\n```\n\n---\n\n## Complete Data Model\n\n### IDT Entry Structure (8 bytes)\n\nEach IDT entry is a gate descriptor with this exact layout:\n\n| Offset | Size | Field | Description |\n|--------|------|-------|-------------|\n| 0 | 16 bits | Offset Low | Bits 15:0 of handler address |\n| 2 | 16 bits | Segment Selector | Code segment for handler (0x08) |\n| 4 | 8 bits | Reserved | Must be 0 |\n| 5 | 8 bits | Type/Attributes | Gate type and flags |\n| 6 | 16 bits | Offset High | Bits 31:16 of handler address |\n\n**Type/Attributes byte (byte 5) bit layout:**\n\n| Bit | Name | Value | Description |\n|-----|------|-------|-------------|\n| 7 | Present | 1 | Gate is valid |\n| 6-5 | DPL | 00 or 11 | Descriptor Privilege Level (0=kernel only, 3=user callable) |\n| 4 | Storage | 0 | Must be 0 for interrupt/trap gates |\n| 3-0 | Type | 1110 or 1111 | 1110=Interrupt gate (IF=0), 1111=Trap gate (IF unchanged) |\n\n**Standard attribute values:**\n- Interrupt gate (kernel only): `0x8E` (10001110b)\n- Trap gate (kernel only): `0x8F` (10001111b)\n- User-callable interrupt gate: `0xEE` (11101110b) — for syscalls\n\n```c\n// kernel/idt.h\n#include <stdint.h>\n\ntypedef struct {\n    uint16_t offset_low;    // Offset bits 15:0\n    uint16_t selector;      // Code segment selector\n    uint8_t  zero;          // Reserved, must be 0\n    uint8_t  type_attr;     // Type and attributes\n    uint16_t offset_high;   // Offset bits 31:16\n} __attribute__((packed)) idt_entry_t;\n\ntypedef struct {\n    uint16_t limit;         // Size of IDT - 1\n    uint32_t base;          // Address of IDT\n} __attribute__((packed)) idt_ptr_t;\n\n#define IDT_ENTRIES 256\n#define IDT_INTERRUPT_GATE 0x8E\n#define IDT_TRAP_GATE 0x8F\n#define IDT_USER_GATE 0xEE\n```\n\n### IDTR (6 bytes)\n\n```c\n// Loaded via lidt instruction\n// limit = sizeof(idt_entry_t) * IDT_ENTRIES - 1 = 2047\n// base = (uint32_t)&idt\n```\n\n### Register Frame Structure\n\nThis structure matches what the assembly stubs push onto the stack:\n\n```c\n// kernel/registers.h\n#include <stdint.h>\n\ntypedef struct {\n    // Pushed by our assembly stub (manual)\n    uint32_t gs, fs, es, ds;\n    \n    // Pushed by pusha (EAX, ECX, EDX, EBX, ESP(original), EBP, ESI, EDI)\n    uint32_t edi, esi, ebp, esp, ebx, edx, ecx, eax;\n    \n    // Pushed by our assembly stub\n    uint32_t int_no;        // Interrupt number\n    uint32_t err_code;      // Error code (0 for exceptions without one)\n    \n    // Pushed by CPU automatically\n    uint32_t eip, cs, eflags;\n    \n    // Only present if privilege change occurred (ring 3 -> ring 0)\n    uint32_t useresp, ss;\n} __attribute__((packed)) registers_t;\n```\n\n**Stack layout at handler entry (grows downward):**\n\n```\nHigh addresses\n┌─────────────────┐\n│    SS (old)     │  ← Only if privilege change\n│    ESP (old)    │  ← Only if privilege change\n├─────────────────┤\n│    EFLAGS       │  ← CPU pushes\n├─────────────────┤\n│    CS (old)     │  ← CPU pushes\n│    EIP (old)    │  ← CPU pushes\n├─────────────────┤\n│  Error Code     │  ← CPU pushes (for some exceptions) or stub pushes 0\n├─────────────────┤\n│  Interrupt #    │  ← Stub pushes\n├─────────────────┤\n│      EAX        │  ← pusha\n│      ECX        │\n│      EDX        │\n│      EBX        │\n│      ESP (old)  │  ← Value before pusha\n│      EBP        │\n│      ESI        │\n│      EDI        │  ← pusha ends\n├─────────────────┤\n│      DS         │  ← Stub pushes\n│      ES         │\n│      FS         │\n│      GS         │  ← Stub pushes\n└─────────────────┘ ← ESP points here\nLow addresses\n```\n\n### CPU Exception Vectors\n\n| Vector | Mnemonic | Error Code? | Type | Description |\n|--------|----------|-------------|------|-------------|\n| 0 | #DE | No | Fault | Divide Error |\n| 1 | #DB | No | Fault/Trap | Debug Exception |\n| 2 | NMI | No | Interrupt | Non-Maskable Interrupt |\n| 3 | #BP | No | Trap | Breakpoint (INT 3) |\n| 4 | #OF | No | Trap | Overflow (INTO) |\n| 5 | #BR | No | Fault | BOUND Range Exceeded |\n| 6 | #UD | No | Fault | Invalid Opcode |\n| 7 | #NM | No | Fault | Device Not Available (no FPU) |\n| 8 | #DF | Yes | Abort | Double Fault |\n| 9 | — | No | Fault | Coprocessor Segment Overrun (legacy) |\n| 10 | #TS | Yes | Fault | Invalid TSS |\n| 11 | #NP | Yes | Fault | Segment Not Present |\n| 12 | #SS | Yes | Fault | Stack-Segment Fault |\n| 13 | #GP | Yes | Fault | General Protection |\n| 14 | #PF | Yes | Fault | Page Fault |\n| 15 | — | No | Fault | Reserved |\n| 16 | #MF | No | Fault | x87 FPU Floating-Point Error |\n| 17 | #AC | Yes | Fault | Alignment Check |\n| 18 | #MC | No | Abort | Machine Check |\n| 19 | #XM | No | Fault | SIMD Floating-Point Exception |\n| 20-31 | — | No | — | Reserved |\n\n### Error Code Format (for vectors 8, 10-14, 17)\n\n```\nFor exceptions 8, 10-14 (segment-related):\n┌────────────────────────────────────────────────────────────────┐\n│ Bits 15-3: Selector Index  │ Bit 2: TI │ Bits 1-0: IDT/GDT/LDT│\n│                            │(0=GDT,    │ 00=GDT, 01=IDT,      │\n│                            │ 1=LDT)    │ 10=LDT, 11=IDT       │\n└────────────────────────────────────────────────────────────────┘\n\nFor page fault (exception 14):\n┌────────────────────────────────────────────────────────────────┐\n│ Bit 0 (P): 0=page not present, 1=protection violation          │\n│ Bit 1 (W): 0=read access, 1=write access                       │\n│ Bit 2 (U): 0=supervisor mode, 1=user mode                      │\n│ Bit 3 (R): 1=reserved bit set in paging structures             │\n│ Bit 4 (I): 1=instruction fetch (NX bit violation)              │\n│ Bits 5-31: Reserved                                            │\n└────────────────────────────────────────────────────────────────┘\n```\n\n### PIC Configuration\n\n```c\n// kernel/pic.h\n#define PIC1_CMD  0x20    // Master PIC command port\n#define PIC1_DATA 0x21    // Master PIC data port\n#define PIC2_CMD  0xA0    // Slave PIC command port\n#define PIC2_DATA 0xA1    // Slave PIC data port\n\n#define PIC_EOI   0x20    // End of Interrupt command\n\n// Vector offsets after remapping\n#define IRQ_BASE  32      // Master IRQs start at vector 32\n#define IRQ_BASE2 40      // Slave IRQs start at vector 40\n```\n\n### PIT Timer Configuration\n\n```c\n// kernel/timer.h\n#define PIT_CHANNEL0 0x40   // Channel 0 data port\n#define PIT_CHANNEL1 0x41   // Channel 1 data port (unused)\n#define PIT_CHANNEL2 0x42   // Channel 2 data port (speaker)\n#define PIT_CMD      0x43   // Mode/Command register\n\n#define PIT_FREQ     1193182  // Base frequency in Hz\n\n// Command byte format:\n// Bits 7-6: Channel (00=0, 01=1, 10=2, 11=read-back)\n// Bits 5-4: Access mode (00=latch, 01=low, 10=high, 11=both)\n// Bits 3-1: Mode (000=int on TC, 001=one-shot, 010=rate gen, 011=square wave, ...)\n// Bit 0: BCD (0=binary, 1=BCD)\n\n#define PIT_CMD_CHANNEL0 0x36  // 00110110b: ch0, lobyte/hibyte, mode 3, binary\n```\n\n### Keyboard Buffer and Scancode Table\n\n```c\n// kernel/keyboard.h\n#define KB_DATA_PORT 0x60   // Keyboard data register\n#define KB_CMD_PORT  0x64   // Keyboard command/status register\n\n#define KB_BUFFER_SIZE 128  // Circular buffer size\n\ntypedef struct {\n    char buffer[KB_BUFFER_SIZE];\n    volatile int head;\n    volatile int tail;\n} kb_buffer_t;\n\n// Scancode Set 1 (US QWERTY) - make codes only\n// Index = scancode, value = ASCII character (0 if not printable)\nstatic const char scancode_to_ascii[128] = {\n    0,    0,   '1', '2', '3', '4', '5', '6',     // 0x00-0x07\n    '7', '8', '9', '0', '-', '=', '\\b', '\\t',    // 0x08-0x0F\n    'q', 'w', 'e', 'r', 't', 'y', 'u', 'i',     // 0x10-0x17\n    'o', 'p', '[', ']', '\\n', 0,   'a', 's',    // 0x18-0x1F (0x1D=ctrl)\n    'd', 'f', 'g', 'h', 'j', 'k', 'l', ';',     // 0x20-0x27\n    '\\'', '`', 0,   '\\\\', 'z', 'x', 'c', 'v',   // 0x28-0x2F (0x2A=shift)\n    'b', 'n', 'm', ',', '.', '/', 0,   '*',     // 0x30-0x37 (0x36=shift, 0x37=* on keypad)\n    0,   ' ',                                    // 0x38-0x39 (0x38=alt, 0x39=space)\n    // 0x3A-0x45: capslock, F1-F10, numlock, scrolllock, etc.\n    // Extended codes (0xE0 prefix) handled separately\n};\n```\n\n---\n\n## Interface Contracts\n\n### idt_init()\n\n**Purpose**: Initialize the IDT with 256 entries\n\n**Parameters**: None\n\n**Returns**: None\n\n**Side effects**:\n- Zeros all 256 IDT entries\n- Loads IDTR via `lidt`\n- Does NOT enable interrupts\n\n**Preconditions**: GDT must be loaded\n\n**Postconditions**: IDT is ready to have handlers registered\n\n### idt_set_gate(uint8_t num, uint32_t handler, uint16_t sel, uint8_t flags)\n\n**Purpose**: Register an interrupt handler in the IDT\n\n**Parameters**:\n- `num`: Vector number (0-255)\n- `handler`: Address of handler function\n- `sel`: Code segment selector (typically 0x08)\n- `flags`: Type/attributes byte (e.g., IDT_INTERRUPT_GATE)\n\n**Returns**: None\n\n**Side effects**: Modifies IDT entry at index `num`\n\n**Constraints**:\n- Handler must be a valid 32-bit address\n- Selector must point to a valid code segment\n\n### isr_handler(registers_t *regs) [C function called from assembly]\n\n**Purpose**: Common dispatcher for CPU exceptions\n\n**Parameters**: `regs` — pointer to saved register frame on stack\n\n**Returns**: None (returns via `iret` in assembly)\n\n**Responsibilities**:\n- Dispatch to specific exception handler based on `regs->int_no`\n- Print diagnostic for unhandled exceptions\n- Halt on fatal exceptions (double fault, GPF, etc.)\n\n### irq_handler(registers_t *regs) [C function called from assembly]\n\n**Purpose**: Common dispatcher for hardware IRQs\n\n**Parameters**: `regs` — pointer to saved register frame on stack\n\n**Returns**: None (returns via `iret` in assembly)\n\n**Responsibilities**:\n- Call device-specific handler (timer, keyboard, etc.)\n- Send EOI to PIC\n- Never return without sending EOI\n\n### pic_remap(uint8_t offset1, uint8_t offset2)\n\n**Purpose**: Remap PIC IRQs to non-conflicting vectors\n\n**Parameters**:\n- `offset1`: Vector offset for master PIC (typically 32)\n- `offset2`: Vector offset for slave PIC (typically 40)\n\n**Returns**: None\n\n**Side effects**:\n- Sends ICW1-ICW4 to both PICs\n- Masks all IRQs initially\n- Changes IRQ-to-vector mapping permanently\n\n**Preconditions**: Must be called before any IRQs are unmasked\n\n**Critical**: Without remapping, IRQ0 fires at vector 8 (double fault!)\n\n### pic_send_eoi(uint8_t irq)\n\n**Purpose**: Signal End of Interrupt to PIC\n\n**Parameters**: `irq` — IRQ number (0-15)\n\n**Returns**: None\n\n**Side effects**: Allows PIC to deliver next interrupt\n\n**Critical**: MUST be called at end of every IRQ handler, or system hangs\n\n### pic_mask_irq(uint8_t irq)\n\n**Purpose**: Mask (disable) a specific IRQ\n\n**Parameters**: `irq` — IRQ number (0-15)\n\n**Returns**: None\n\n### pic_unmask_irq(uint8_t irq)\n\n**Purpose**: Unmask (enable) a specific IRQ\n\n**Parameters**: `irq` — IRQ number (0-15)\n\n**Returns**: None\n\n### timer_init(uint32_t frequency)\n\n**Purpose**: Initialize PIT to fire at specified frequency\n\n**Parameters**: `frequency` — desired frequency in Hz (typically 100)\n\n**Returns**: None\n\n**Side effects**:\n- Programs PIT channel 0\n- Does NOT unmask IRQ0 (caller must do this)\n\n**Constraints**: Frequency should be 18Hz to 1.193MHz (divisor 1-65535)\n\n### timer_handler(void)\n\n**Purpose**: Handle timer interrupt (IRQ0)\n\n**Parameters**: None (called from irq_handler)\n\n**Returns**: None\n\n**Side effects**: Increments global tick counter\n\n### keyboard_init(void)\n\n**Purpose**: Initialize PS/2 keyboard driver\n\n**Parameters**: None\n\n**Returns**: None\n\n**Side effects**: Clears keyboard buffer\n\n### keyboard_handler(void)\n\n**Purpose**: Handle keyboard interrupt (IRQ1)\n\n**Parameters**: None (called from irq_handler)\n\n**Returns**: None\n\n**Side effects**: Reads scancode, converts to ASCII, stores in buffer\n\n### kb_getchar(void)\n\n**Purpose**: Non-blocking read from keyboard buffer\n\n**Parameters**: None\n\n**Returns**: \n- ASCII character if available\n- -1 if buffer empty\n\n**Thread safety**: Buffer is lock-free but safe for single consumer\n\n---\n\n## Algorithm Specification\n\n### IDT Initialization\n\n```\nIDT_INIT:\n  1. Zero all 256 IDT entries\n     FOR i = 0 TO 255:\n       idt[i].offset_low = 0\n       idt[i].selector = 0\n       idt[i].zero = 0\n       idt[i].type_attr = 0\n       idt[i].offset_high = 0\n  \n  2. Set up IDTR\n     idtr.limit = sizeof(idt_entry_t) * 256 - 1  // 2047\n     idtr.base = (uint32_t)&idt\n  \n  3. Load IDT\n     asm volatile(\"lidt %0\" : : \"m\"(idtr))\n```\n\n### Setting an IDT Gate\n\n```\nIDT_SET_GATE(num, handler, sel, flags):\n  1. Extract handler address bytes\n     offset_low = handler & 0xFFFF\n     offset_high = (handler >> 16) & 0xFFFF\n  \n  2. Populate entry\n     idt[num].offset_low = offset_low\n     idt[num].selector = sel\n     idt[num].zero = 0\n     idt[num].type_attr = flags\n     idt[num].offset_high = offset_high\n```\n\n### Assembly ISR Stub (exceptions without error code)\n\n```\n; Macro for exceptions that DON'T push error code\n%macro ISR_NOERRCODE 1\nglobal isr%1\nisr%1:\n    push dword 0            ; Push dummy error code to unify stack frame\n    push dword %1           ; Push interrupt number\n    jmp isr_common_stub\n%endmacro\n```\n\n### Assembly ISR Stub (exceptions with error code)\n\n```\n; Macro for exceptions that DO push error code\n%macro ISR_ERRCODE 1\nglobal isr%1\nisr%1:\n    push dword %1           ; Push interrupt number (error code already on stack)\n    jmp isr_common_stub\n%endmacro\n```\n\n### Common ISR Stub\n\n```\nisr_common_stub:\n    ; Save all general-purpose registers\n    pusha                   ; EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI\n    \n    ; Save segment registers\n    push ds\n    push es\n    push fs\n    push gs\n    \n    ; Load kernel data segment\n    mov ax, 0x10\n    mov ds, ax\n    mov es, ax\n    mov fs, ax\n    mov gs, ax\n    \n    ; Push pointer to stack frame\n    mov eax, esp\n    push eax\n    \n    ; Call C handler\n    extern isr_handler\n    call isr_handler\n    \n    ; Restore stack pointer (ignore return value)\n    add esp, 4\n    \n    ; Restore segment registers\n    pop gs\n    pop fs\n    pop es\n    pop ds\n    \n    ; Restore general-purpose registers\n    popa\n    \n    ; Remove error code and interrupt number\n    add esp, 8\n    \n    ; Return from interrupt\n    iret\n```\n\n### Common IRQ Stub\n\n```\nirq_common_stub:\n    pusha\n    push ds\n    push es\n    push fs\n    push gs\n    \n    mov ax, 0x10\n    mov ds, ax\n    mov es, ax\n    mov fs, ax\n    mov gs, ax\n    \n    mov eax, esp\n    push eax\n    \n    extern irq_handler\n    call irq_handler\n    \n    add esp, 4\n    \n    pop gs\n    pop fs\n    pop es\n    pop ds\n    popa\n    \n    add esp, 8\n    \n    iret\n```\n\n### PIC Remapping Sequence\n\n```\nPIC_REMAP(offset1, offset2):\n  1. Save current masks\n     a = inb(PIC1_DATA)\n     b = inb(PIC2_DATA)\n  \n  2. Start initialization (ICW1)\n     outb(PIC1_CMD, 0x11)   ; ICW4 needed, cascade mode\n     outb(PIC2_CMD, 0x11)\n  \n  3. Set vector offsets (ICW2)\n     outb(PIC1_DATA, offset1)  ; Master: IRQ0 -> vector 32\n     outb(PIC2_DATA, offset2)  ; Slave: IRQ8 -> vector 40\n  \n  4. Tell master about slave (ICW3)\n     outb(PIC1_DATA, 0x04)  ; Slave at IRQ2 (bit 2 set)\n     outb(PIC2_DATA, 0x02)  ; Slave cascade identity\n  \n  5. Set 8086 mode (ICW4)\n     outb(PIC1_DATA, 0x01)  ; 8086 mode, normal EOI\n     outb(PIC2_DATA, 0x01)\n  \n  6. Restore masks\n     outb(PIC1_DATA, a)\n     outb(PIC2_DATA, b)\n```\n\n### EOI Sending\n\n```\nPIC_SEND_EOI(irq):\n  1. Always send EOI to master\n     outb(PIC1_CMD, 0x20)\n  \n  2. If IRQ >= 8, also send to slave\n     IF irq >= 8:\n       outb(PIC2_CMD, 0x20)\n```\n\n### PIT Timer Initialization\n\n```\nTIMER_INIT(frequency):\n  1. Calculate divisor\n     divisor = 1193182 / frequency\n     IF divisor > 65535: divisor = 65535\n     IF divisor < 1: divisor = 1\n  \n  2. Send command byte\n     ; Channel 0, lobyte/hibyte, mode 3 (square wave), binary\n     outb(PIT_CMD, 0x36)\n  \n  3. Send divisor\n     outb(PIT_CHANNEL0, divisor & 0xFF)        ; Low byte\n     outb(PIT_CHANNEL0, (divisor >> 8) & 0xFF) ; High byte\n  \n  4. Initialize tick counter\n     timer_ticks = 0\n```\n\n### Keyboard Handler\n\n```\nKEYBOARD_HANDLER:\n  1. Read scancode\n     scancode = inb(KB_DATA_PORT)\n  \n  2. Check for extended prefix\n     IF scancode == 0xE0:\n       extended_mode = 1\n       RETURN  // Wait for next byte\n  \n  3. Check for break code (key release)\n     released = (scancode & 0x80)\n     scancode &= 0x7F  // Remove break bit\n  \n  4. Handle key release\n     IF released:\n       IF scancode == LSHIFT or RSHIFT:\n         shift_held = 0\n       IF scancode == CTRL:\n         ctrl_held = 0\n       RETURN\n  \n  5. Handle modifier press\n     IF scancode == LSHIFT or RSHIFT:\n       shift_held = 1\n       RETURN\n     IF scancode == CTRL:\n       ctrl_held = 1\n       RETURN\n  \n  6. Convert to ASCII\n     IF scancode >= 128:\n       RETURN  // Unknown scancode\n     c = scancode_to_ascii[scancode]\n     IF c == 0:\n       RETURN  // Non-printable key\n  \n  7. Apply modifiers\n     IF shift_held AND c >= 'a' AND c <= 'z':\n       c -= 32  // Uppercase\n  \n  8. Store in buffer (if space)\n     next_head = (buffer_head + 1) % KB_BUFFER_SIZE\n     IF next_head != buffer_tail:\n       buffer[buffer_head] = c\n       buffer_head = next_head\n```\n\n### Double Fault Handler\n\n```\nDOUBLE_FAULT_HANDLER(regs):\n  1. Print banner\n     vga_set_color(RED, WHITE)\n     vga_puts(\"\\n!!! DOUBLE FAULT !!!\\n\")\n  \n  2. Print diagnostics\n     vga_puts(\"EIP: \"); vga_put_hex(regs->eip)\n     vga_puts(\"  CS: \"); vga_put_hex(regs->cs)\n     vga_puts(\"\\nError code: \"); vga_put_hex(regs->err_code)\n  \n  3. Decode error code\n     index = (regs->err_code >> 3) & 0x1FFF\n     table = regs->err_code & 0x3\n     vga_puts(\"  Table: \")\n     IF table == 0: vga_puts(\"GDT\")\n     IF table == 1: vga_puts(\"IDT\")\n     IF table == 2: vga_puts(\"LDT\")\n     IF table == 3: vga_puts(\"IDT\")\n     vga_puts(\"  Index: \"); vga_put_hex(index)\n  \n  4. Halt\n     vga_puts(\"\\nSystem halted.\\n\")\n     cli\n     hlt\n```\n\n---\n\n## Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n|-------|-------------|----------|---------------|\n| PIC not remapped | IRQ0 fires at vector 8 (double fault) | Remap PIC before enabling interrupts | Yes, double fault message |\n| Missing EOI | System appears frozen | Always call `pic_send_eoi` in IRQ handler | No (just hangs) |\n| Register corruption | Mysterious crashes later | Ensure pusha/popa + segment saves match | Yes, random faults |\n| Stack frame misalignment | `iret` pops wrong values | Error code handling must match exception | Yes, GPF or garbage EIP |\n| Double fault unhandled | Triple fault (CPU reset) | Install handler at IDT[8] | Yes, system resets |\n| Page fault (kernel) | Page fault at valid address | Print CR2 and error code, halt | Yes, PF message |\n| Unknown opcode | #UD exception | Print EIP, halt | Yes, UD message |\n| Keyboard buffer overflow | Buffer full | Drop character, ring buffer protects | No |\n| Invalid IRQ number | Array bounds | Ignore invalid IRQs | No |\n\n---\n\n## State Machine: Keyboard Scancode Parsing\n\n```\n                    ┌─────────────────┐\n                    │     IDLE        │\n                    └────────┬────────┘\n                             │\n                    ┌────────▼────────┐\n              ┌─────│  Read Scancode  │─────┐\n              │     └────────┬────────┘     │\n              │              │              │\n     ┌────────▼───┐   ┌──────▼──────┐   ┌──▼─────────┐\n     │ 0xE0 (ext) │   │ 0x00-0x7F   │   │ 0x80-0xFF │\n     │ Next byte  │   │ (make code) │   │(break code)│\n     │ is ext     │   │             │   │            │\n     └────────┬───┘   └──────┬──────┘   └─────┬──────┘\n              │              │                │\n              │       ┌──────▼──────┐   ┌─────▼──────┐\n              │       │ Modifier?   │   │ Clear held │\n              │       │ (Shift/Ctrl)│   │ flag       │\n              │       └──────┬──────┘   └────────────┘\n              │              │\n              │       ┌──────▼──────┐\n              │       │ ASCII?      │\n              │       │ Lookup table│\n              │       └──────┬──────┘\n              │              │\n              │       ┌──────▼──────┐\n              │       │ Apply mods  │\n              │       │ (shift)     │\n              │       └──────┬──────┘\n              │              │\n              │       ┌──────▼──────┐\n              │       │ Buffer full?│\n              │       └──────┬──────┘\n              │              │\n              │       ┌──────▼──────┐\n              │       │ Store char  │\n              │       │ in buffer   │\n              │       └──────┬──────┘\n              │              │\n              └──────────────►\n                    ┌───────▼───────┐\n                    │ Return (wait  │\n                    │ for next IRQ) │\n                    └───────────────┘\n```\n\n---\n\n## Implementation Sequence with Checkpoints\n\n### Phase 1: IDT Structure and Loading (2-3 hours)\n\n**Files**: `kernel/idt.h`, `kernel/idt.c`\n\n**Steps**:\n1. Define `idt_entry_t` and `idt_ptr_t` structures\n2. Declare global IDT array (256 entries)\n3. Implement `idt_init()` to zero all entries\n4. Implement `idt_set_gate()` to populate entries\n5. Implement `idt_load()` with inline assembly `lidt`\n\n**Checkpoint**: IDT loads without error\n```c\n// Add to kernel_main.c:\nidt_init();\nvga_puts(\"IDT initialized\\n\");\n// Verify: no crash, message appears\n```\n\n**Test**: Run in QEMU, verify no triple fault after `lidt`\n\n### Phase 2: Assembly ISR Stubs (3-4 hours)\n\n**Files**: `kernel/isr.asm`\n\n**Steps**:\n1. Create macros `ISR_NOERRCODE` and `ISR_ERRCODE`\n2. Generate stubs for all 32 CPU exceptions\n3. Implement `isr_common_stub` with full register save\n4. Declare global symbols for each stub\n\n**Checkpoint**: Assembly compiles without error\n```bash\nnasm -f elf32 kernel/isr.asm -o isr.o\n# No errors or warnings\n```\n\n**Test**: Link with kernel, verify symbols exist\n```bash\nnm kernel.elf | grep isr\n# Should show isr0, isr1, ..., isr31\n```\n\n### Phase 3: Register Frame and C Handler (2-3 hours)\n\n**Files**: `kernel/registers.h`, `kernel/interrupt_handler.c`\n\n**Steps**:\n1. Define `registers_t` structure matching assembly push order\n2. Implement `isr_handler()` to dispatch based on `int_no`\n3. Add exception messages array\n4. Implement page fault handler with CR2 read\n\n**Checkpoint**: Exception handler prints diagnostics\n```c\n// Trigger divide by zero:\nint x = 1 / 0;  // After interrupts enabled\n// Expected: \"EXCEPTION: Divide By Zero\" message\n```\n\n**Test**: Force each exception, verify correct message\n\n### Phase 4: PIC Remapping (2-3 hours)\n\n**Files**: `kernel/pic.h`, `kernel/pic.c`\n\n**Steps**:\n1. Implement `outb` and `inb` inline functions\n2. Implement `pic_remap()` with ICW1-ICW4 sequence\n3. Implement `pic_send_eoi()`\n4. Implement `pic_mask_irq()` and `pic_unmask_irq()`\n\n**Checkpoint**: PIC remaps without error\n```c\n// In kernel_main, after idt_init:\npic_remap(32, 40);\nvga_puts(\"PIC remapped\\n\");\n// Enable timer and keyboard:\npic_unmask_irq(0);  // Timer\npic_unmask_irq(1);  // Keyboard\n// Expected: No immediate crash\n```\n\n**Test**: Unmask IRQ0, verify timer fires at vector 32 (not 8)\n\n### Phase 5: IRQ Handlers with EOI (2-3 hours)\n\n**Files**: `kernel/irq.asm`, modify `kernel/interrupt_handler.c`\n\n**Steps**:\n1. Create IRQ stub macros (irq0 through irq15)\n2. Implement `irq_common_stub`\n3. Implement `irq_handler()` in C\n4. Add `pic_send_eoi()` call\n\n**Checkpoint**: IRQ handlers run without hanging\n```c\n// After enabling IRQ0, system should not freeze\n// Timer counter should increment\n```\n\n**Test**: Enable timer IRQ, verify tick counter increases\n\n### Phase 6: PIT Timer Driver (2-3 hours)\n\n**Files**: `kernel/timer.h`, `kernel/timer.c`\n\n**Steps**:\n1. Implement `timer_init()` with divisor calculation\n2. Implement `timer_handler()` to increment counter\n3. Add `timer_get_ticks()` accessor\n4. Register timer handler in `irq_handler()`\n\n**Checkpoint**: Timer fires at configured frequency\n```c\ntimer_init(100);  // 100Hz\npic_unmask_irq(0);\nsti();\n// Print tick count every second:\nwhile (1) {\n    static uint32_t last = 0;\n    if (timer_get_ticks() / 100 != last) {\n        last = timer_get_ticks() / 100;\n        vga_put_dec(last);\n        vga_puts(\" seconds\\n\");\n    }\n    hlt();\n}\n```\n\n**Test**: Verify seconds counter increments at correct rate\n\n### Phase 7: PS/2 Keyboard Driver (3-4 hours)\n\n**Files**: `kernel/keyboard.h`, `kernel/keyboard.c`\n\n**Steps**:\n1. Define scancode-to-ASCII table\n2. Implement circular buffer\n3. Implement `keyboard_handler()` with scancode parsing\n4. Handle shift modifier\n5. Implement `kb_getchar()` for non-blocking read\n6. Register keyboard handler in `irq_handler()`\n\n**Checkpoint**: Keyboard input appears in buffer\n```c\nkeyboard_init();\npic_unmask_irq(1);\nsti();\n\nvga_puts(\"Type something: \");\nwhile (1) {\n    int c = kb_getchar();\n    if (c != -1) {\n        vga_putchar(c);\n    }\n    hlt();\n}\n```\n\n**Test**: Type on keyboard, verify characters appear on screen\n\n### Phase 8: Double Fault Handler (1-2 hours)\n\n**Files**: Modify `kernel/interrupt_handler.c`\n\n**Steps**:\n1. Add special case for `int_no == 8` in `isr_handler()`\n2. Print detailed diagnostics (EIP, CS, error code)\n3. Halt instead of returning\n\n**Checkpoint**: Double fault is caught, not triple fault\n```c\n// Trigger double fault by corrupting IDT:\nidt[8].offset_low = 0xDEAD;  // Invalid handler\nidt[8].offset_high = 0xDEAD;\nasm volatile(\"int $8\");  // Trigger double fault\n// Expected: Double fault message, system halts (not resets)\n```\n\n**Test**: Verify double fault handler prints message and halts\n\n### Final Integration (2-3 hours)\n\n**Goal**: Complete interrupt system with all handlers working\n\n**Steps**:\n1. Integrate all components in `kernel_main()`\n2. Add proper initialization order:\n   - GDT (already done)\n   - IDT init\n   - PIC remap\n   - Timer init\n   - Keyboard init\n   - Unmask IRQs\n   - `sti`\n3. Create interactive test: display typed characters with timestamp\n\n**Checkpoint**: All tests pass\n```c\nvoid kernel_main(void) {\n    vga_init();\n    serial_init(COM1_PORT);\n    \n    vga_puts(\"Initializing IDT...\\n\");\n    idt_init();\n    \n    vga_puts(\"Remapping PIC...\\n\");\n    pic_remap(32, 40);\n    \n    vga_puts(\"Initializing timer (100Hz)...\\n\");\n    timer_init(100);\n    \n    vga_puts(\"Initializing keyboard...\\n\");\n    keyboard_init();\n    \n    // Unmask timer and keyboard IRQs\n    pic_unmask_irq(0);\n    pic_unmask_irq(1);\n    \n    vga_puts(\"Enabling interrupts...\\n\");\n    asm volatile(\"sti\");\n    \n    vga_puts(\"System ready. Type something!\\n\");\n    \n    while (1) {\n        int c = kb_getchar();\n        if (c != -1) {\n            vga_puts(\"[\");\n            vga_put_dec(timer_get_ticks());\n            vga_puts(\"] \");\n            vga_putchar(c);\n            vga_puts(\"\\n\");\n        }\n        asm volatile(\"hlt\");\n    }\n}\n```\n\n**Test Commands**:\n```bash\nmake clean && make\nqemu-system-i386 -drive format=raw,file=os.img -serial stdio\n\n# Expected:\n# - Boot messages appear\n# - \"System ready. Type something!\" appears\n# - Typing shows \"[tickcount] character\"\n# - Timer increments correctly\n# - No crashes, hangs, or triple faults\n```\n\n---\n\n## Test Specification\n\n### Test 1: IDT Loads Without Crash\n\n```python\n# test_idt_load.py\nimport subprocess\nimport time\n\ndef test_idt_load():\n    # Build kernel\n    result = subprocess.run(['make'], capture_output=True)\n    assert result.returncode == 0, f\"Build failed: {result.stderr.decode()}\"\n    \n    # Run QEMU briefly\n    proc = subprocess.Popen(\n        ['qemu-system-i386', '-drive', 'format=raw,file=os.img', \n         '-serial', 'stdio', '-display', 'none', '-nographic'],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE\n    )\n    \n    time.sleep(2)\n    proc.terminate()\n    output, _ = proc.communicate(timeout=5)\n    \n    # Check for IDT init message\n    assert b'IDT' in output, \"IDT initialization message not found\"\n    assert b'triple fault' not in output.lower(), \"Triple fault detected\"\n```\n\n### Test 2: PIC Remaps Correctly\n\n```bash\n# test_pic_remap.sh\n# Verify IRQ0 triggers vector 32, not 8\n\n# Run QEMU with interrupt logging\ntimeout 5 qemu-system-i386 -drive format=raw,file=os.img \\\n    -d int -serial stdio -display none 2>&1 | tee int_log.txt\n\n# Check that interrupt 32 (0x20) appears, not 8 with PIC origin\nif grep -q \"irq 0\" int_log.txt; then\n    echo \"PASS: IRQ0 fires correctly\"\nelse\n    echo \"FAIL: No IRQ0 detected\"\n    exit 1\nfi\n```\n\n### Test 3: Timer Fires at Correct Frequency\n\n```python\n# test_timer_frequency.py\nimport subprocess\nimport time\nimport re\n\ndef test_timer_frequency():\n    proc = subprocess.Popen(\n        ['qemu-system-i386', '-drive', 'format=raw,file=os.img',\n         '-serial', 'stdio', '-display', 'none'],\n        stdout=subprocess.PIPE\n    )\n    \n    time.sleep(3)  # Wait 3 seconds\n    proc.terminate()\n    output, _ = proc.communicate(timeout=5)\n    text = output.decode()\n    \n    # Find tick counts at different times\n    # Assuming we print ticks, look for increasing values\n    tick_pattern = r'\\[(\\d+)\\]'\n    matches = re.findall(tick_pattern, text)\n    \n    if len(matches) < 2:\n        return  # Not enough data\n    \n    ticks = [int(m) for m in matches]\n    elapsed_ticks = ticks[-1] - ticks[0]\n    \n    # At 100Hz, 3 seconds should be ~300 ticks\n    # Allow 20% tolerance\n    assert 200 <= elapsed_ticks <= 400, \\\n        f\"Timer frequency off: {elapsed_ticks} ticks in ~3 seconds\"\n```\n\n### Test 4: Keyboard Buffer Works\n\n```python\n# test_keyboard_buffer.py\nimport subprocess\n\ndef test_keyboard_buffer():\n    # Run QEMU with keyboard input\n    proc = subprocess.Popen(\n        ['qemu-system-i386', '-drive', 'format=raw,file=os.img',\n         '-serial', 'stdio', '-display', 'none'],\n        stdin=subprocess.PIPE,\n        stdout=subprocess.PIPE\n    )\n    \n    # Wait for ready\n    time.sleep(1)\n    \n    # Send some keystrokes via QEMU monitor\n    # (This is tricky; usually done with expect or pexpect)\n    # For now, just verify keyboard init message appears\n    \n    proc.terminate()\n    output, _ = proc.communicate(timeout=5)\n    \n    assert b'keyboard' in output.lower(), \"Keyboard init message missing\"\n```\n\n### Test 5: Exception Handlers Print Diagnostics\n\n```c\n// kernel/test_exceptions.c\nvoid test_divide_by_zero(void) {\n    volatile int x = 1;\n    volatile int y = 0;\n    volatile int z = x / y;  // Should trigger #DE\n    (void)z;\n}\n\nvoid test_invalid_opcode(void) {\n    asm volatile(\".byte 0x06, 0x07\");  // Invalid on modern x86\n}\n\nvoid test_page_fault(void) {\n    volatile int *ptr = (int *)0xDEADBEEF;\n    *ptr = 42;  // Should trigger #PF\n}\n\n// In kernel_main, after IDT init:\n// Uncomment ONE test at a time:\n// test_divide_by_zero();\n// Expected: \"EXCEPTION: Divide By Zero\" then halt\n```\n\n### Test 6: EOI is Sent\n\n```bash\n# test_eoi.sh\n# If EOI is missing, system hangs after first interrupt\n\ntimeout 5 qemu-system-i386 -drive format=raw,file=os.img \\\n    -serial stdio -display none 2>&1 | tee eoi_log.txt\n\n# Check for multiple timer ticks (proves EOI is working)\ntick_count=$(grep -c \"seconds\" eoi_log.txt || echo \"0\")\n\nif [ \"$tick_count\" -gt 1 ]; then\n    echo \"PASS: EOI sent correctly (multiple ticks seen)\"\nelse\n    echo \"FAIL: System may have hung (EOI not sent?)\"\n    exit 1\nfi\n```\n\n### Test 7: Double Fault Caught\n\n```bash\n# test_double_fault.sh\n# Trigger double fault and verify handler runs (not reset)\n\n# Modify kernel to corrupt IDT[0] after setup:\n# idt[0].offset_low = 0xDEAD;\n# asm volatile(\"int $0\");\n# Then trigger int 0 again\n\n# Expected: \"DOUBLE FAULT\" message, not QEMU reset\n```\n\n---\n\n## Performance Targets\n\n| Operation | Target | How to Measure |\n|-----------|--------|----------------|\n| ISR entry (pusha + segs) | < 50 cycles | Count instructions: pusha (17), push ds-es-fs-gs (3×), mov ax/mov ds (2×4) ≈ 35 cycles |\n| C handler call overhead | < 20 cycles | Call/ret pair ≈ 5-10 cycles |\n| Total ISR entry to handler | < 150 cycles | Sum of above plus stack manipulation |\n| EOI send | < 10 cycles | Single `outb` instruction |\n| Keyboard scancode to buffer | < 500 cycles | Inb (1), table lookup (5), buffer store (5) |\n| Timer tick (counter increment) | < 100 cycles | Memory increment with lock prefix if needed |\n| Timer accuracy | Within 1% | Compare tick count to wall clock over 10 seconds |\n| Keyboard latency (IRQ to buffer) | < 1ms | Measure from QEMU input to buffer write |\n\n---\n\n## Hardware Soul\n\n### Cache Lines Touched\n\n**IDT access**: The IDT (2048 bytes) fits in 32 cache lines. The CPU reads the relevant entry during interrupt dispatch, which is cached in L1. Frequently used vectors (timer at 32, keyboard at 33) stay hot in cache.\n\n**Handler code**: Interrupt handlers should be small and stay in cache. A 64-byte cache line holds ~16-20 instructions. Timer handler (~20 instructions) and keyboard handler (~50 instructions) should remain L1-resident.\n\n**Keyboard buffer**: 128-byte circular buffer = 2 cache lines. The head/tail indices share a cache line with the buffer.\n\n### Branch Prediction\n\n**Interrupt dispatch**: Fully predictable — direct table lookup using vector number. No branches in the dispatch path until the C handler's switch statement.\n\n**Scancode parsing**: Branch-heavy due to modifier checks and table lookups. The CPU's branch predictor learns the pattern (most keys are alphanumeric, shift state changes infrequently).\n\n**Timer handler**: Minimal branching — just increment counter. Highly predictable.\n\n### I/O Port Access\n\n| Port | Access Type | Latency | Notes |\n|------|-------------|---------|-------|\n| 0x20/0xA0 (PIC cmd) | Out | ~1 µs | EOI command |\n| 0x21/0xA1 (PIC data) | In/Out | ~1 µs | Mask registers |\n| 0x60 (Keyboard data) | In | ~1 µs | Scancode read |\n| 0x64 (Keyboard status) | In | ~1 µs | Status check |\n| 0x40/0x43 (PIT) | Out | ~1 µs | Timer programming |\n\nAll I/O port accesses bypass the cache hierarchy entirely.\n\n### TLB Considerations\n\nHandlers must be in always-mapped memory. With paging enabled:\n- IDT should be in identity-mapped or kernel region\n- Handler code must be mapped in all address spaces\n- Stack must be valid (kernel stack at known address)\n\n### Interrupt Latency Components\n\n1. **Hardware latency**: IRQ assertion to CPU response (~1-2 µs)\n2. **CPU dispatch**: Vector lookup, privilege check, stack switch (~50-100 cycles)\n3. **Software save**: pusha + segment saves (~40 cycles)\n4. **Handler execution**: Variable (timer: ~20 cycles, keyboard: ~100 cycles)\n5. **Restore + iret**: popa + segment restores + iret (~50 cycles)\n6. **EOI**: outb to PIC (~1 µs)\n\nTotal minimum latency: ~2-5 µs for timer, ~5-10 µs for keyboard\n\n---\n\n## Concurrency Specification\n\n### Interrupt Context\n\nInterrupt handlers run in a special context:\n\n- **Atomic entry**: CPU automatically disables interrupts (for interrupt gates) during dispatch\n- **No preemption**: Handler cannot be preempted by same or lower priority interrupt\n- **No blocking**: Handler must not sleep, wait, or call any blocking function\n- **No per-process state**: Handler may run in context of any process\n\n### Shared Data\n\n| Data | Access Pattern | Protection |\n|------|---------------|------------|\n| Timer tick counter | Write (IRQ), Read (any) | `volatile`, atomic increment |\n| Keyboard buffer | Write (IRQ), Read (any) | Lock-free circular buffer |\n| Keyboard head/tail | Write (IRQ updates head, user updates tail) | Index variables, careful ordering |\n| IDT entries | Write (init only), Read (CPU) | No protection needed (one-time init) |\n| PIC masks | Read/Write (any) | No concurrent access expected |\n\n### Critical Sections\n\nDuring IDT/PIC initialization:\n```c\nvoid interrupt_init(void) {\n    cli();  // Disable interrupts during setup\n    \n    idt_init();\n    pic_remap(32, 40);\n    // Register handlers...\n    \n    sti();  // Re-enable after complete setup\n}\n```\n\n### Re-entrancy\n\nHandlers are NOT re-entrant by default (interrupt gates clear IF). If re-entrancy is needed:\n1. Use trap gate instead of interrupt gate\n2. Manually re-enable interrupts with `sti` in handler\n3. Protect shared data with per-vector locks\n\n---\n\n## Implementation Notes\n\n### Register Save Order\n\nThe order MUST match the `registers_t` structure:\n\n```asm\n; Assembly pushes:\npush gs       ; Offset +0\npush fs       ; Offset +4\npush es       ; Offset +8\npush ds       ; Offset +12\npusha         ; EDI+16, ESI+20, EBP+24, ESP+28, EBX+32, EDX+36, ECX+40, EAX+44\npush int_no   ; Offset +48\npush err_code ; Offset +52\n; CPU already pushed: EIP+56, CS+60, EFLAGS+64\n; If ring change: ESP+68, SS+72\n```\n\n### Error Code Handling\n\nSome exceptions push error code, some don't:\n\n```asm\n; Exceptions WITHOUT error code (use dummy push):\nISR_NOERRCODE 0   ; #DE\nISR_NOERRCODE 1   ; #DB\nISR_NOERRCODE 2   ; NMI\nISR_NOERRCODE 3   ; #BP\nISR_NOERRCODE 4   ; #OF\nISR_NOERRCODE 5   ; #BR\nISR_NOERRCODE 6   ; #UD\nISR_NOERRCODE 7   ; #NM\nISR_ERRCODE   8   ; #DF (HAS error code)\nISR_NOERRCODE 9   ; Coprocessor Segment Overrun\nISR_ERRCODE   10  ; #TS\nISR_ERRCODE   11  ; #NP\nISR_ERRCODE   12  ; #SS\nISR_ERRCODE   13  ; #GP\nISR_ERRCODE   14  ; #PF\n; ... continue pattern\n```\n\n### PIC Mask Management\n\n```c\n// Unmask IRQ:\nvoid pic_unmask_irq(uint8_t irq) {\n    uint16_t port;\n    uint8_t value;\n    \n    if (irq < 8) {\n        port = PIC1_DATA;\n    } else {\n        port = PIC2_DATA;\n        irq -= 8;\n    }\n    \n    value = inb(port) & ~(1 << irq);\n    outb(port, value);\n}\n\n// Mask IRQ:\nvoid pic_mask_irq(uint8_t irq) {\n    uint16_t port;\n    uint8_t value;\n    \n    if (irq < 8) {\n        port = PIC1_DATA;\n    } else {\n        port = PIC2_DATA;\n        irq -= 8;\n    }\n    \n    value = inb(port) | (1 << irq);\n    outb(port, value);\n}\n```\n\n### Extended Scancodes\n\nArrow keys and navigation cluster send 0xE0 prefix:\n\n```c\nstatic int extended_scancode = 0;\n\nvoid keyboard_handler(void) {\n    uint8_t scancode = inb(KB_DATA_PORT);\n    \n    if (scancode == 0xE0) {\n        extended_scancode = 1;\n        return;  // Wait for next byte\n    }\n    \n    if (extended_scancode) {\n        extended_scancode = 0;\n        // Handle extended code: scancode is the second byte\n        // Arrow keys: 0x48=up, 0x50=down, 0x4B=left, 0x4D=right\n        // ...\n        return;\n    }\n    \n    // Normal scancode handling...\n}\n```\n\n---\n\n## Visual Diagrams\n\n### IDT Entry Structure\n\n```\nIDT Gate Descriptor (8 bytes):\n┌─────────────────────────────────────────────────────────────────┐\n│ 63       48│47       32│31   24│23 16│15      0│               │\n│  Offset    │  Offset   │       │ Seg │  Offset │               │\n│  High      │  High     │ Zero  │ Sel │  Low    │               │\n│  [31:16]   │  [31:16]  │       │     │  [15:0] │               │\n└─────────────────────────────────────────────────────────────────┘\n              │           │       │     │         │\n              │           │       │     │         └─ Handler address bits 15:0\n              │           │       │     └─ Code segment selector (0x08)\n              │           │       └─ Reserved (must be 0)\n              │           └─ Type/Attributes:\n              │              ┌──────────────────────────┐\n              │              │ P DPL 0 Type             │\n              │              │ 1 00  0 1110 = 0x8E      │\n              │              │ ↑  ↑   ↑ ↑               │\n              │              │ │  │   │ └─ Gate type    │\n              │              │ │  │   └─ System (0)    │\n              │              │ │  └─ Privilege level   │\n              │              │ └─ Present              │\n              └─ Handler address bits 31:16\n```\n\n### Interrupt Stack Frame\n\n```\n                 High Addresses\n                 ┌─────────────────┐\n                 │    SS (old)     │ ← Only if privilege change (ring 3→0)\n                 │    ESP (old)    │\n                 ├─────────────────┤\n                 │    EFLAGS       │ ← CPU pushes\n                 ├─────────────────┤\n                 │    CS (old)     │ ← CPU pushes\n                 │    EIP (old)    │ ← CPU pushes\n                 ├─────────────────┤\n                 │  Error Code     │ ← CPU (some) or stub (dummy 0)\n                 ├─────────────────┤\n                 │  Interrupt #    │ ← Stub pushes\n                 ├─────────────────┤\n                 │      EAX        │ ← pusha\n                 │      ECX        │\n                 │      EDX        │\n                 │      EBX        │\n                 │   ESP (before   │\n                 │    pusha)       │\n                 │      EBP        │\n                 │      ESI        │\n                 │      EDI        │ ← pusha ends\n                 ├─────────────────┤\n                 │      DS         │ ← Stub pushes\n                 │      ES         │\n                 │      FS         │\n                 │      GS         │ ← Stub pushes\n                 └─────────────────┘ ← ESP points here\n                 Low Addresses\n\nregisters_t structure maps this exactly:\n  gs, fs, es, ds                    (offset 0-15)\n  edi, esi, ebp, esp, ebx, edx, ecx, eax  (offset 16-47)\n  int_no, err_code                  (offset 48-55)\n  eip, cs, eflags                   (offset 56-67)\n  useresp, ss                       (offset 68-75, optional)\n```\n\n### PIC Remapping\n\n```\nBEFORE Remapping (Default):\n┌──────────────────────────────────────────────────────────┐\n│ IRQ 0 1 2 3 4 5 6 7 │ IRQ 8  9  10 11 12 13 14 15      │\n│     ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ │    ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓        │\n│ Vec 8 9 A B C D E F │   70 71 72 73 74 75 76 77        │\n│     ↑ CONFLICT!     │                                   │\n│     #DF is vec 8!   │                                   │\n└──────────────────────────────────────────────────────────┘\n\nAFTER Remapping:\n┌──────────────────────────────────────────────────────────┐\n│ IRQ 0 1 2 3 4 5 6 7 │ IRQ 8  9  10 11 12 13 14 15      │\n│     ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ │    ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓        │\n│ Vec 32 33 34 35 36 37 38 39 │ 40 41 42 43 44 45 46 47  │\n│     ↑ Timer  ↑ Keyb │    ↑ RTC                          │\n│     (no conflict)   │                                   │\n└──────────────────────────────────────────────────────────┘\n\nCPU Exception Vectors (0-31) remain for CPU-detected faults:\n┌──────────────────────────────────────────────────────────┐\n│ 0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 ...    │\n│ #DE #DB NMI #BP #OF #BR #UD #NM #DF -- #TS #NP #SS #GP #PF│\n└──────────────────────────────────────────────────────────┘\n```\n\n### Exception Vectors and Error Codes\n\n```\nCPU Exception Vectors (0-31):\n\n┌────┬───────┬────────┬───────────────────────────────────────┐\n│Vec │ Name  │ Error? │                Cause                  │\n├────┼───────┼────────┼───────────────────────────────────────┤\n│ 0  │ #DE   │ No     │ Division by zero or overflow          │\n│ 1  │ #DB   │ No     │ Debug trap (single step, breakpoint)  │\n│ 2  │ NMI   │ No     │ Hardware NMI (parity error, etc.)     │\n│ 3  │ #BP   │ No     │ INT 3 instruction (debugger)          │\n│ 4  │ #OF   │ No     │ INTO instruction with OF flag set     │\n│ 5  │ #BR   │ No     │ BOUND instruction range exceeded      │\n│ 6  │ #UD   │ No     │ Invalid or privileged instruction     │\n│ 7  │ #NM   │ No     │ FPU instruction with no FPU present   │\n│ 8  │ #DF   │ Yes    │ Exception during exception handling   │\n│ 9  │ --    │ No     │ (Reserved, coprocessor segment overrun)│\n│ 10 │ #TS   │ Yes    │ Invalid TSS during task switch        │\n│ 11 │ #NP   │ Yes    │ Segment or gate not present           │\n│ 12 │ #SS   │ Yes    │ Stack segment limit violation         │\n│ 13 │ #GP   │ Yes    │ General protection violation          │\n│ 14 │ #PF   │ Yes    │ Page not present or protection fault  │\n│ 15 │ --    │ No     │ Reserved                              │\n│ 16 │ #MF   │ No     │ x87 FPU error                         │\n│ 17 │ #AC   │ Yes    │ Alignment check (alignment mode)      │\n│ 18 │ #MC   │ No     │ Machine check (hardware error)        │\n│ 19 │ #XM   │ No     │ SIMD floating-point exception         │\n│20-31│ --   │ No     │ Reserved                              │\n└────┴───────┴────────┴───────────────────────────────────────┘\n\nPage Fault Error Code (vector 14):\n┌────┬─────────────────────────────────────────────────────────┐\n│Bit │                         Meaning                         │\n├────┼─────────────────────────────────────────────────────────┤\n│ 0  │ P: 0=page not present, 1=protection violation           │\n│ 1  │ W: 0=read access, 1=write access                        │\n│ 2  │ U: 0=supervisor mode, 1=user mode                       │\n│ 3  │ R: 1=reserved bit set in paging structures              │\n│ 4  │ I: 1=instruction fetch (NX bit violation)               │\n│5-31│ Reserved                                                │\n└────┴─────────────────────────────────────────────────────────┘\n```\n\n### Keyboard Scancode Flow\n\n```\nKeyboard Scancode Processing:\n\n┌─────────────────────────────────────────────────────────────────┐\n│                     KEYBOARD CONTROLLER                         │\n│                    (sends scancode)                             │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │ IRQ1\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│                     IRQ1 HANDLER                                │\n│  1. Read scancode from port 0x60                                │\n│  2. Check for 0xE0 (extended prefix)                            │\n│  3. Check for break code (bit 7)                                │\n│  4. Update modifier state (shift, ctrl, alt)                    │\n│  5. Lookup ASCII in scancode table                              │\n│  6. Apply modifiers (shift -> uppercase)                        │\n│  7. Store in circular buffer                                    │\n│  8. Send EOI                                                    │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│                   CIRCULAR BUFFER                               │\n│  ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐ │\n│  │ H │ e │ l │ l │ o │   │   │   │   │   │   │   │   │   │   │ │\n│  └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘ │\n│        ↑                                                   ↑   │\n│       tail                                                head │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │ kb_getchar()\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│                     APPLICATION                                │\n│  int c = kb_getchar();                                          │\n│  if (c != -1) { vga_putchar(c); }                              │\n└─────────────────────────────────────────────────────────────────┘\n\nScancode Table (Set 1, partial):\n┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐\n│ 01 │ 02 │ 03 │ 04 │ 05 │ 06 │ 07 │ 08 │ 09 │ 0A │ 0B │ 0C │\n│Esc │ 1  │ 2  │ 3  │ 4  │ 5  │ 6  │ 7  │ 8  │ 9  │ 0  │ -  │\n├────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┤\n│ 0D │ 0E │ 0F │ 10 │ 11 │ 12 │ 13 │ 14 │ 15 │ 16 │ 17 │ 18 │\n│ =  │BkSp│Tab │ q  │ w  │ e  │ r  │ t  │ y  │ u  │ i  │ o  │\n├────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┤\n│ 19 │ 1A │ 1B │ 1C │ 1E │ 1F │ 20 │ 21 │ 22 │ 23 │ 24 │ 25 │\n│ p  │ [  │ ]  │Enter│ a │ s  │ d  │ f  │ g  │ h  │ j  │ k  │\n├────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┤\n│ 26 │ 27 │ 28 │ 29 │ 2B │ 2C │ 2D │ 2E │ 2F │ 30 │ 31 │ 32 │\n│ l  │ ;  │ '  │ `  │ \\  │ z  │ x  │ c  │ v  │ b  │ n  │ m  │\n├────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┤\n│ 33 │ 34 │ 35 │ 39 │                                              \n│ ,  │ .  │ /  │Space│ ...etc...                                   \n└────┴────┴────┴────┴───────────────────────────────────────────┘\n```\n\n### ISR State Machine\n\n```\nISR/IRQ Processing State Machine:\n\n                    ┌──────────────────┐\n                    │   CPU Running    │\n                    │   User/Kernel    │\n                    │     Code         │\n                    └────────┬─────────┘\n                             │\n              Interrupt/IRQ  │\n              ──────────────▶│\n                             ▼\n                    ┌──────────────────┐\n                    │  CPU Pushes:     │\n                    │  EFLAGS, CS, EIP │\n                    │  (SS, ESP if     │\n                    │   ring change)   │\n                    └────────┬─────────┘\n                             │\n                             ▼\n                    ┌──────────────────┐\n                    │  IDT Lookup      │\n                    │  (vector → gate) │\n                    └────────┬─────────┘\n                             │\n                    ┌────────▼─────────┐\n                    │   Our Stub:      │\n                    │   Push err/dummy │\n                    │   Push int_no    │\n                    └────────┬─────────┘\n                             │\n                    ┌────────▼─────────┐\n                    │   pusha          │\n                    │   push segs      │\n                    └────────┬─────────┘\n                             │\n                    ┌────────▼─────────┐\n                    │ Load kernel DS   │\n                    │ Call C handler   │\n                    └────────┬─────────┘\n                             │\n              ┌──────────────┴──────────────┐\n              │                             │\n              ▼                             ▼\n     ┌─────────────────┐          ┌─────────────────┐\n     │   ISR Handler   │          │   IRQ Handler   │\n     │  (Exception)    │          │  (Hardware)     │\n     │                 │          │                 │\n     │ Print message   │          │ Call device     │\n     │ Halt if fatal   │          │ handler         │\n     └────────┬────────┘          │ Send EOI to PIC │\n              │                   └────────┬────────┘\n              │                             │\n              └──────────────┬──────────────┘\n                             │\n                    ┌────────▼─────────┐\n                    │   pop segs       │\n                    │   popa           │\n                    │   add esp, 8     │\n                    │   iret           │\n                    └────────┬─────────┘\n                             │\n                             ▼\n                    ┌──────────────────┐\n                    │   Resume         │\n                    │   Interrupted    │\n                    │   Code           │\n                    └──────────────────┘\n```\n\n---\n\n\n<!-- TDD_MOD_ID: mod-memory -->\n# Technical Design Specification: Physical and Virtual Memory Management\n\n## Module Charter\n\nThe memory management module implements physical frame allocation using a bitmap allocator, two-level x86 page tables (page directory + page tables) for virtual memory, identity mapping for the first 16MB plus higher-half kernel mapping at 0xC0000000, and a kernel heap allocator (kmalloc/kfree). It parses the E820/multiboot memory map to discover usable physical memory regions.\n\n**What it does NOT do**: This module does not implement per-process address spaces (all processes share kernel mapping), does not implement demand paging or swap, does not implement copy-on-write, does not handle memory-mapped files, and does not implement user-space malloc (only kernel kmalloc).\n\n**Upstream dependencies**: GDT must be loaded with flat kernel segments; IDT must have page fault handler registered at vector 14; multiboot bootloader must provide memory map.\n\n**Downstream consumers**: Process manager (Milestone 4) will use page directory cloning for per-process address spaces; all kernel code uses kmalloc/kfree for dynamic allocation; device drivers use identity-mapped MMIO regions.\n\n**Invariants**: Frame allocator must never return a frame containing kernel code/data; page tables must always have kernel region (0xC0000000+) mapped identically across all page directories; TLB must be invalidated after any page table modification; kmalloc must never return memory below 0xC0400000 (kernel heap region).\n\n---\n\n## File Structure\n\nCreate files in this order:\n\n```\n1. kernel/memory/e820.h          # E820/multiboot memory map structures\n2. kernel/memory/e820.c          # Memory map parser and printer\n3. kernel/memory/frame.h         # Frame allocator interface\n4. kernel/memory/frame.c         # Bitmap frame allocator implementation\n5. kernel/memory/paging.h        # Page table structures and interface\n6. kernel/memory/paging.c        # Page directory/table management\n7. kernel/memory/heap.h          # kmalloc/kfree interface\n8. kernel/memory/heap.c          # Kernel heap implementation\n9. kernel/memory/memory.c        # Top-level memory init integrating all components\n10. kernel/linker.ld             # Updated linker script with higher-half symbols\n```\n\n---\n\n## Complete Data Model\n\n### E820 Memory Map Entry (20 bytes)\n\n```c\n// kernel/memory/e820.h\n#include <stdint.h>\n\ntypedef struct {\n    uint64_t base;          // Base address of region\n    uint64_t length;        // Length of region in bytes\n    uint32_t type;          // Type of memory\n    uint32_t acpi;          // ACPI extended attributes (optional)\n} __attribute__((packed)) e820_entry_t;\n\n// Memory region types\n#define E820_USABLE         1   // Normal RAM\n#define E820_RESERVED       2   // Reserved, do not use\n#define E820_ACPI_RECLAIM   3   // ACPI reclaimable (read tables first)\n#define E820_ACPI_NVS       4   // ACPI non-volatile storage\n#define E820_BAD            5   // Bad memory (errors)\n\n// Parsed memory region for internal use\ntypedef struct {\n    uint64_t base;\n    uint64_t length;\n    uint32_t type;\n} memory_region_t;\n\n#define MAX_MEMORY_REGIONS  64\n```\n\n### Multiboot Memory Map Header\n\n```c\n// From multiboot specification\ntypedef struct {\n    uint32_t size;              // Size of this structure (minus size field)\n    uint64_t base_addr;         // Base address\n    uint64_t length;            // Length\n    uint32_t type;              // Type\n} __attribute__((packed)) multiboot_mmap_entry_t;\n\n// Multiboot info structure (partial)\ntypedef struct {\n    uint32_t flags;\n    uint32_t mem_lower;         // KB of low memory (0-640KB)\n    uint32_t mem_upper;         // KB of high memory (1MB+)\n    // ... other fields ...\n    uint32_t mmap_length;       // Memory map length\n    uint32_t mmap_addr;         // Memory map address\n} __attribute__((packed)) multiboot_info_t;\n```\n\n### Frame Allocator State\n\n```c\n// kernel/memory/frame.h\n#include <stdint.h>\n\n#define FRAME_SIZE          4096        // 4KB per frame\n#define FRAME_SHIFT         12          // log2(4096)\n#define BITS_PER_DWORD      32\n\n// Frame allocator state\ntypedef struct {\n    uint32_t *bitmap;                 // Bitmap: 1 = allocated, 0 = free\n    uint32_t bitmap_size;             // Number of uint32_t entries\n    uint32_t total_frames;            // Total frames in system\n    uint32_t free_frames;             // Currently free frames\n    uint32_t first_usable;            // First frame number that's usable\n    uint32_t kernel_end_frame;        // First frame after kernel\n} frame_allocator_t;\n\nextern frame_allocator_t frame_alloc;\n\n// Convert between physical address and frame number\n#define ADDR_TO_FRAME(addr)     ((addr) >> FRAME_SHIFT)\n#define FRAME_TO_ADDR(frame)    ((frame) << FRAME_SHIFT)\n\n// Bitmap operations\nstatic inline void frame_set(uint32_t frame) {\n    frame_alloc.bitmap[frame / BITS_PER_DWORD] |= (1U << (frame % BITS_PER_DWORD));\n}\n\nstatic inline void frame_clear(uint32_t frame) {\n    frame_alloc.bitmap[frame / BITS_PER_DWORD] &= ~(1U << (frame % BITS_PER_DWORD));\n}\n\nstatic inline int frame_test(uint32_t frame) {\n    return frame_alloc.bitmap[frame / BITS_PER_DWORD] & (1U << (frame % BITS_PER_DWORD));\n}\n```\n\n### Page Directory/Table Entry (4 bytes each)\n\n```c\n// kernel/memory/paging.h\n#include <stdint.h>\n\ntypedef uint32_t pte_t;       // Page Table Entry\ntypedef uint32_t pde_t;       // Page Directory Entry\n\n// Page entry flags (bits in pte_t/pde_t)\n#define PTE_PRESENT       (1U << 0)    // Page is present in memory\n#define PTE_WRITABLE      (1U << 1)    // Read/Write (1 = writable)\n#define PTE_USER          (1U << 2)    // User/supervisor (1 = user accessible)\n#define PTE_WRITETHROUGH  (1U << 3)    // Write-through caching\n#define PTE_CACHE_DISABLE (1U << 4)    // Disable cache for this page\n#define PTE_ACCESSED      (1U << 5)    // Page has been accessed (read)\n#define PTE_DIRTY         (1U << 6)    // Page has been written to (PT only)\n#define PTE_PAGE_SIZE     (1U << 7)    // 4MB page (PD only)\n#define PTE_GLOBAL        (1U << 8)    // Global page (not flushed on CR3 reload)\n#define PTE_FRAME_MASK    0xFFFFF000   // Frame address mask (bits 31:12)\n\n// Extract fields from entry\n#define PTE_FRAME(pte)          ((pte) & PTE_FRAME_MASK)\n#define PTE_FLAGS(pte)          ((pte) & ~PTE_FRAME_MASK)\n\n// Common flag combinations\n#define PTE_KERNEL_CODE         (PTE_PRESENT | PTE_WRITABLE)\n#define PTE_KERNEL_DATA         (PTE_PRESENT | PTE_WRITABLE)\n#define PTE_USER_CODE           (PTE_PRESENT | PTE_WRITABLE | PTE_USER)\n#define PTE_USER_DATA           (PTE_PRESENT | PTE_WRITABLE | PTE_USER)\n```\n\n**Page Table Entry bit layout:**\n\n| Bits | Field | Description |\n|------|-------|-------------|\n| 0 | Present | 1 = page in memory |\n| 1 | R/W | 1 = writable |\n| 2 | U/S | 1 = user-mode accessible |\n| 3 | PWT | Write-through caching |\n| 4 | PCD | Cache disable |\n| 5 | A | Accessed (CPU sets on read) |\n| 6 | D | Dirty (CPU sets on write, PT only) |\n| 7 | PS | Page size (0 = 4KB) |\n| 8 | G | Global (ignore on CR3 reload) |\n| 9-11 | Available | OS-defined |\n| 12-31 | Frame Address | Physical frame address (4KB aligned) |\n\n### Page Directory and Page Table Structures\n\n```c\n#define ENTRIES_PER_TABLE    1024\n#define PAGE_SIZE            4096\n\ntypedef struct {\n    pte_t entries[ENTRIES_PER_TABLE];\n} __attribute__((aligned(PAGE_SIZE))) page_table_t;\n\ntypedef struct {\n    pde_t entries[ENTRIES_PER_TABLE];\n} __attribute__((aligned(PAGE_SIZE))) page_directory_t;\n\n// Extract indices from virtual address\n#define PD_INDEX(vaddr)      (((vaddr) >> 22) & 0x3FF)\n#define PT_INDEX(vaddr)      (((vaddr) >> 12) & 0x3FF)\n#define PAGE_OFFSET(vaddr)   ((vaddr) & 0xFFF)\n\n// Current page directory (physical address in CR3)\nextern page_directory_t *current_page_directory;\n```\n\n### Heap Block Header\n\n```c\n// kernel/memory/heap.h\n#include <stdint.h>\n\n#define HEAP_MAGIC           0xDEADBEEF\n#define HEAP_MIN_BLOCK_SIZE  16        // Minimum allocation size\n#define HEAP_START           0xC0400000  // Virtual address for heap\n#define HEAP_INITIAL_SIZE    (4 * 1024 * 1024)  // 4MB initial\n\ntypedef struct heap_block {\n    uint32_t magic;                   // HEAP_MAGIC for integrity check\n    uint32_t size;                    // Size of data area (excluding header)\n    uint8_t  free;                    // 1 = free, 0 = allocated\n    uint8_t  padding[3];              // Align to 4 bytes\n    struct heap_block *next;          // Next block in list\n    struct heap_block *prev;          // Previous block in list\n} __attribute__((packed)) heap_block_t;\n\n#define BLOCK_HEADER_SIZE    sizeof(heap_block_t)\n#define BLOCK_DATA(block)    ((void*)((uint8_t*)(block) + BLOCK_HEADER_SIZE))\n#define DATA_TO_BLOCK(ptr)   ((heap_block_t*)((uint8_t*)(ptr) - BLOCK_HEADER_SIZE))\n```\n\n### Memory Layout Constants\n\n```c\n// kernel/memory/memory.h\n\n// Physical memory layout\n#define KERNEL_PHYSICAL_BASE   0x00100000    // 1 MB - where kernel is loaded\n#define LOW_MEMORY_END         0x00100000    // 1 MB - end of low memory\n#define VGA_PHYSICAL           0x000B8000    // VGA text buffer\n\n// Virtual memory layout\n#define KERNEL_VIRTUAL_BASE    0xC0000000    // 3 GB - higher-half kernel\n#define KERNEL_HEAP_START      0xC0400000    // 3 GB + 4 MB - kernel heap\n#define KERNEL_HEAP_END        0xC0800000    // 3 GB + 8 MB - heap end (expandable)\n#define USER_SPACE_START       0x00000000    // User space base\n#define USER_SPACE_END         0xBFFFFFFF    // User space end (3 GB - 1)\n#define USER_STACK_TOP         0xBFFFF000    // User stack (grows down)\n\n// Identity mapping range\n#define IDENTITY_MAP_END       (16 * 1024 * 1024)  // Identity map first 16 MB\n```\n\n---\n\n## Interface Contracts\n\n### e820_init(multiboot_info_t *mbi)\n\n**Purpose**: Parse multiboot memory map and store usable regions\n\n**Parameters**: \n- `mbi`: Pointer to multiboot info structure from bootloader\n\n**Returns**: 0 on success, -1 on error\n\n**Side effects**: \n- Populates global `memory_regions` array\n- Sets `num_memory_regions`\n\n**Preconditions**: Called early in kernel init before frame allocator\n\n**Postconditions**: Memory map available for frame allocator initialization\n\n### frame_allocator_init(void)\n\n**Purpose**: Initialize bitmap frame allocator from parsed memory map\n\n**Parameters**: None\n\n**Returns**: 0 on success, -1 on error\n\n**Side effects**:\n- Allocates bitmap (using placement allocator during boot)\n- Marks kernel frames as used\n- Marks reserved/acpi regions as used\n\n**Preconditions**: e820_init() must have been called\n\n**Postconditions**: Frame allocator ready to allocate free frames\n\n### alloc_frame(void)\n\n**Purpose**: Allocate a single 4KB physical frame\n\n**Parameters**: None\n\n**Returns**: \n- Physical address of allocated frame on success\n- NULL (0) if out of memory\n\n**Side effects**:\n- Marks frame as allocated in bitmap\n- Decrements `free_frames` counter\n\n**Thread safety**: NOT thread-safe. Caller must disable interrupts if needed.\n\n### free_frame(void *addr)\n\n**Purpose**: Free a previously allocated physical frame\n\n**Parameters**:\n- `addr`: Physical address of frame to free\n\n**Returns**: None\n\n**Side effects**:\n- Clears frame bit in bitmap\n- Increments `free_frames` counter\n\n**Error handling**:\n- Panics on double-free (frame already free)\n- Panics if address not frame-aligned\n- Panics if frame outside valid range\n\n### paging_init(void)\n\n**Purpose**: Set up initial page tables and enable paging\n\n**Parameters**: None\n\n**Returns**: None\n\n**Side effects**:\n- Creates initial page directory\n- Identity maps first 16MB\n- Maps kernel at 0xC0000000+ (higher-half)\n- Loads CR3 and sets CR0.PG\n\n**Preconditions**: Frame allocator initialized\n\n**Postconditions**: Paging enabled, kernel running in higher-half\n\n### map_page(page_directory_t *dir, uint32_t vaddr, uint32_t paddr, uint32_t flags)\n\n**Purpose**: Map a virtual page to a physical frame\n\n**Parameters**:\n- `dir`: Page directory to modify\n- `vaddr`: Virtual address (will be page-aligned)\n- `paddr`: Physical address (will be page-aligned)\n- `flags`: PTE flags (PTE_PRESENT | PTE_WRITABLE | ...)\n\n**Returns**: 0 on success, -1 on failure (out of memory for page table)\n\n**Side effects**:\n- May allocate new page table\n- Invalidates TLB entry for vaddr\n\n**Preconditions**: Paging enabled (or dir is valid)\n\n### unmap_page(page_directory_t *dir, uint32_t vaddr)\n\n**Purpose**: Remove a virtual-to-physical mapping\n\n**Parameters**:\n- `dir`: Page directory to modify\n- `vaddr`: Virtual address to unmap\n\n**Returns**: None\n\n**Side effects**: Invalidates TLB entry for vaddr\n\n### get_physical(page_directory_t *dir, uint32_t vaddr)\n\n**Purpose**: Translate virtual address to physical address\n\n**Parameters**:\n- `dir`: Page directory to query\n- `vaddr`: Virtual address to translate\n\n**Returns**:\n- Physical address on success\n- 0 if not mapped\n\n### kmalloc(uint32_t size)\n\n**Purpose**: Allocate kernel heap memory\n\n**Parameters**:\n- `size`: Number of bytes to allocate\n\n**Returns**:\n- Pointer to allocated memory (in kernel virtual space)\n- NULL if out of memory\n\n**Side effects**: May expand heap by mapping new pages\n\n**Alignment**: Returns 4-byte aligned pointers\n\n**Minimum allocation**: HEAP_MIN_BLOCK_SIZE bytes\n\n### kfree(void *ptr)\n\n**Purpose**: Free previously allocated heap memory\n\n**Parameters**:\n- `ptr`: Pointer returned by kmalloc (or NULL)\n\n**Returns**: None\n\n**Side effects**:\n- Coalesces with adjacent free blocks\n- May reduce heap (optional optimization)\n\n**Error handling**:\n- Panics on invalid pointer (magic mismatch)\n- Panics on double-free\n- Silently ignores NULL\n\n---\n\n## Algorithm Specification\n\n### Memory Map Parsing\n\n```\nE820_INIT(mbi):\n  1. Verify multiboot flags indicate memory map present\n     IF !(mbi->flags & (1 << 6)):\n       RETURN error  // No memory map!\n  \n  2. Initialize region counter\n     num_regions = 0\n  \n  3. Iterate through memory map entries\n     entry = mbi->mmap_addr\n     WHILE entry < mbi->mmap_addr + mbi->mmap_length:\n       // Skip entries above 4GB (we're 32-bit)\n       IF entry->base + entry->length > 0xFFFFFFFF:\n         entry = next_entry\n         CONTINUE\n       \n       // Store region info\n       regions[num_regions].base = entry->base\n       regions[num_regions].length = entry->length\n       regions[num_regions].type = entry->type\n       \n       num_regions++\n       IF num_regions >= MAX_MEMORY_REGIONS:\n         BREAK  // Too many regions\n       \n       entry = next_entry (entry + entry->size + 4)\n  \n  4. Calculate total usable memory\n     total_memory = 0\n     FOR each region:\n       IF region.type == E820_USABLE:\n         total_memory += region.length\n  \n  5. RETURN success\n```\n\n### Frame Allocator Initialization\n\n```\nFRAME_ALLOCATOR_INIT():\n  1. Calculate total frames from highest address\n     max_addr = 0\n     FOR each region:\n       IF region.base + region.length > max_addr:\n         max_addr = region.base + region.length\n     \n     total_frames = max_addr / FRAME_SIZE\n  \n  2. Allocate bitmap using placement allocator\n     bitmap_dwords = (total_frames + 31) / 32\n     bitmap = placement_alloc(bitmap_dwords * 4)\n     \n     // Mark ALL frames as reserved initially\n     FOR i = 0 TO bitmap_dwords - 1:\n       bitmap[i] = 0xFFFFFFFF\n  \n  3. Find first usable frame\n     first_usable = total_frames  // Start with max\n     FOR each region:\n       IF region.type == E820_USABLE:\n         start_frame = ALIGN_UP(region.base, FRAME_SIZE) / FRAME_SIZE\n         IF start_frame < first_usable:\n           first_usable = start_frame\n  \n  4. Mark usable frames as free\n     free_frames = 0\n     FOR each region:\n       IF region.type == E820_USABLE:\n         start_frame = ALIGN_UP(region.base, FRAME_SIZE) / FRAME_SIZE\n         end_frame = ALIGN_DOWN(region.base + region.length, FRAME_SIZE) / FRAME_SIZE\n         \n         FOR frame = start_frame TO end_frame - 1:\n           clear_frame(frame)\n           free_frames++\n  \n  5. Reserve kernel frames\n     kernel_start = ADDR_TO_FRAME(&_kernel_start)\n     kernel_end = ADDR_TO_FRAME(&_kernel_end) + 1  // +1 for partial frame\n     \n     FOR frame = kernel_start TO kernel_end - 1:\n       IF frame_test(frame) == 0:  // Was free\n         set_frame(frame)\n         free_frames--\n     \n     kernel_end_frame = kernel_end\n  \n  6. Reserve already-allocated placement memory\n     placement_start = first_usable  // Rough estimate\n     placement_end = ADDR_TO_FRAME(placement_addr)\n     \n     FOR frame = placement_start TO placement_end:\n       IF frame_test(frame) == 0:\n         set_frame(frame)\n         free_frames--\n  \n  7. RETURN success\n```\n\n### Frame Allocation (Bitmap Scan)\n\n```\nALLOC_FRAME():\n  1. Check if any frames available\n     IF free_frames == 0:\n       RETURN NULL  // Out of memory\n  \n  2. Scan bitmap for free bit\n     FOR i = first_usable / 32 TO total_frames / 32:\n       IF bitmap[i] != 0xFFFFFFFF:  // At least one free bit\n         FOR j = 0 TO 31:\n           frame = i * 32 + j\n           IF frame >= first_usable AND frame_test(frame) == 0:\n             // Found free frame\n             set_frame(frame)\n             free_frames--\n             RETURN FRAME_TO_ADDR(frame)\n  \n  3. No free frame found (shouldn't happen if free_frames > 0)\n     RETURN NULL\n```\n\n### Frame Freeing\n\n```\nFREE_FRAME(addr):\n  1. Validate address\n     IF addr == NULL:\n       RETURN  // Ignore NULL\n     \n     IF addr % FRAME_SIZE != 0:\n       PANIC(\"free_frame: unaligned address 0x%x\\n\", addr)\n  \n  2. Calculate frame number\n     frame = ADDR_TO_FRAME(addr)\n     \n     IF frame >= total_frames:\n       PANIC(\"free_frame: frame %d out of range\\n\", frame)\n  \n  3. Check for double-free\n     IF frame_test(frame) == 0:\n       PANIC(\"free_frame: double free at frame %d (addr 0x%x)\\n\", frame, addr)\n  \n  4. Mark as free\n     clear_frame(frame)\n     free_frames++\n```\n\n### Page Mapping\n\n```\nMAP_PAGE(dir, vaddr, paddr, flags):\n  1. Align addresses to page boundaries\n     vaddr = vaddr & ~0xFFF\n     paddr = paddr & ~0xFFF\n  \n  2. Get page directory index\n     pd_idx = PD_INDEX(vaddr)\n     pde = &dir->entries[pd_idx]\n  \n  3. Get or create page table\n     IF *pde & PTE_PRESENT:\n       // Page table exists\n       pt = (page_table_t*)PTE_FRAME(*pde)\n     ELSE:\n       // Need to create page table\n       pt_phys = alloc_frame()\n       IF pt_phys == NULL:\n         RETURN -1  // Out of memory\n       \n       pt = (page_table_t*)pt_phys  // Identity-mapped during init\n       \n       // Clear page table\n       FOR i = 0 TO 1023:\n         pt->entries[i] = 0\n       \n       // Set page directory entry\n       *pde = (uint32_t)pt_phys | PTE_PRESENT | PTE_WRITABLE | PTE_USER\n  \n  4. Set page table entry\n     pt_idx = PT_INDEX(vaddr)\n     pt->entries[pt_idx] = paddr | flags | PTE_PRESENT\n  \n  5. Invalidate TLB entry\n     asm volatile(\"invlpg (%0)\" : : \"r\"(vaddr) : \"memory\")\n  \n  6. RETURN 0\n```\n\n### Page Unmapping\n\n```\nUNMAP_PAGE(dir, vaddr):\n  1. Get page directory entry\n     pd_idx = PD_INDEX(vaddr)\n     pde = &dir->entries[pd_idx]\n     \n     IF !(*pde & PTE_PRESENT):\n       RETURN  // Nothing mapped\n  \n  2. Get page table\n     pt = (page_table_t*)PTE_FRAME(*pde)\n  \n  3. Clear page table entry\n     pt_idx = PT_INDEX(vaddr)\n     pt->entries[pt_idx] = 0\n  \n  4. Invalidate TLB entry\n     asm volatile(\"invlpg (%0)\" : : \"r\"(vaddr) : \"memory\")\n```\n\n### Identity and Higher-Half Mapping\n\n```\nPAGING_INIT():\n  1. Allocate page directory\n     pd_phys = alloc_frame()\n     pd = (page_directory_t*)pd_phys\n     \n     // Clear all entries (not present)\n     FOR i = 0 TO 1023:\n       pd->entries[i] = 0\n  \n  2. Identity map first 16 MB\n     FOR addr = 0 TO 16*1024*1024 STEP PAGE_SIZE:\n       map_page(pd, addr, addr, PTE_PRESENT | PTE_WRITABLE)\n       // Note: supervisor-only (no PTE_USER)\n  \n  3. Higher-half kernel mapping (0xC0000000+)\n     FOR offset = 0 TO 16*1024*1024 STEP PAGE_SIZE:\n       vaddr = KERNEL_VIRTUAL_BASE + offset\n       paddr = offset\n       map_page(pd, vaddr, paddr, PTE_PRESENT | PTE_WRITABLE)\n  \n  4. Load CR3\n     asm volatile(\"mov %0, %%cr3\" : : \"r\"(pd_phys))\n  \n  5. Enable paging\n     asm volatile(\"mov %%cr0, %0\" : \"=r\"(cr0))\n     cr0 |= (1 << 31)  // Set PG bit\n     asm volatile(\"mov %0, %%cr0\" : : \"r\"(cr0))\n  \n  6. Update global pointer\n     current_page_directory = (page_directory_t*)(KERNEL_VIRTUAL_BASE + (uint32_t)pd_phys)\n     // Now we need to access via higher-half address!\n```\n\n### Page Fault Handler\n\n```\nPAGE_FAULT_HANDLER(regs):\n  1. Read faulting address from CR2\n     asm volatile(\"mov %%cr2, %0\" : \"=r\"(fault_addr))\n  \n  2. Decode error code\n     present = !(regs->err_code & 0x1)   // Bit 0: 0=not present\n     write = regs->err_code & 0x2        // Bit 1: write access\n     user = regs->err_code & 0x4         // Bit 2: user mode\n     reserved = regs->err_code & 0x8     // Bit 3: reserved bit\n     exec = regs->err_code & 0x10        // Bit 4: instruction fetch\n  \n  3. Print diagnostic\n     kprintf(\"=== PAGE FAULT ===\\n\")\n     kprintf(\"Address: 0x%x\\n\", fault_addr)\n     kprintf(\"Error: %s %s %s %s\\n\",\n             present ? \"protection\" : \"not-present\",\n             write ? \"write\" : \"read\",\n             user ? \"user\" : \"kernel\",\n             exec ? \"exec\" : \"\")\n     kprintf(\"EIP: 0x%x\\n\", regs->eip)\n  \n  4. Check if address is in valid ranges\n     IF fault_addr >= KERNEL_VIRTUAL_BASE:\n       kprintf(\"In kernel space\\n\")\n     ELSE IF fault_addr < IDENTITY_MAP_END:\n       kprintf(\"In identity-mapped region\\n\")\n     ELSE:\n       kprintf(\"Outside mapped regions\\n\")\n  \n  5. Halt (no demand paging in this version)\n     PANIC(\"Page fault - system halted\\n\")\n```\n\n### Kernel Heap Allocation\n\n```\nKMALLOC(size):\n  1. Handle edge cases\n     IF size == 0:\n       RETURN NULL\n  \n  2. Align size to 4 bytes\n     size = (size + 3) & ~3\n     \n     IF size < HEAP_MIN_BLOCK_SIZE:\n       size = HEAP_MIN_BLOCK_SIZE\n  \n  3. Find free block (first-fit)\n     block = heap_head\n     WHILE block != NULL:\n       IF block->magic != HEAP_MAGIC:\n         PANIC(\"kmalloc: heap corruption at 0x%x\\n\", block)\n       \n       IF block->free AND block->size >= size:\n         // Found suitable block\n         GOTO found_block\n       \n       block = block->next\n  \n  4. No suitable block - expand heap\n     IF !heap_expand(size + BLOCK_HEADER_SIZE):\n       RETURN NULL  // Out of memory\n     \n     // Try again (should succeed now)\n     RETURN kmalloc(size)\n  \n  found_block:\n  5. Split block if large enough\n     remaining = block->size - size\n     IF remaining > BLOCK_HEADER_SIZE + HEAP_MIN_BLOCK_SIZE:\n       // Create new free block after this one\n       new_block = (heap_block_t*)((uint8_t*)block + BLOCK_HEADER_SIZE + size)\n       new_block->magic = HEAP_MAGIC\n       new_block->size = remaining - BLOCK_HEADER_SIZE\n       new_block->free = 1\n       new_block->next = block->next\n       new_block->prev = block\n       \n       IF block->next:\n         block->next->prev = new_block\n       \n       block->next = new_block\n       block->size = size\n  \n  6. Mark block as allocated\n     block->free = 0\n     \n     RETURN BLOCK_DATA(block)\n```\n\n### Kernel Heap Freeing\n\n```\nKFREE(ptr):\n  1. Handle NULL\n     IF ptr == NULL:\n       RETURN\n  \n  2. Get block header\n     block = DATA_TO_BLOCK(ptr)\n  \n  3. Validate magic\n     IF block->magic != HEAP_MAGIC:\n       PANIC(\"kfree: invalid pointer 0x%x (magic=0x%x)\\n\", ptr, block->magic)\n  \n  4. Check for double-free\n     IF block->free:\n       PANIC(\"kfree: double free at 0x%x\\n\", ptr)\n  \n  5. Mark as free\n     block->free = 1\n  \n  6. Coalesce with next block\n     IF block->next AND block->next->free AND block->next->magic == HEAP_MAGIC:\n       block->size += BLOCK_HEADER_SIZE + block->next->size\n       block->next = block->next->next\n       IF block->next:\n         block->next->prev = block\n  \n  7. Coalesce with previous block\n     IF block->prev AND block->prev->free AND block->prev->magic == HEAP_MAGIC:\n       block->prev->size += BLOCK_HEADER_SIZE + block->size\n       block->prev->next = block->next\n       IF block->next:\n         block->next->prev = block->prev\n```\n\n---\n\n## Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n|-------|-------------|----------|---------------|\n| No memory map from bootloader | `e820_init` checks flags | Panic with message | Yes, \"No memory map\" |\n| Out of physical frames | `alloc_frame` returns NULL | kmalloc returns NULL, caller handles | Depends on caller |\n| Double-free in frame allocator | `free_frame` tests bit | Panic with address | Yes, panic message |\n| Invalid frame address | `free_frame` checks alignment/range | Panic | Yes |\n| Page table allocation failure | `map_page` checks alloc_frame result | Return -1, caller handles | Depends on caller |\n| Page fault (kernel) | Exception 14 handler | Print diagnostics, halt | Yes, fault message |\n| Page fault during paging init | Triple fault | System reset | Yes (reset) |\n| TLB stale entry | Various | Always call invlpg | No (prevention) |\n| Heap corruption (bad magic) | `kmalloc`/`kfree` check magic | Panic | Yes |\n| Heap double-free | `kfree` checks free flag | Panic | Yes |\n| Heap expansion failure | `heap_expand` returns 0 | kmalloc returns NULL | Depends on caller |\n\n---\n\n## Implementation Sequence with Checkpoints\n\n### Phase 1: Memory Map Parser (3-4 hours)\n\n**Files**: `kernel/memory/e820.h`, `kernel/memory/e820.c`\n\n**Steps**:\n1. Define e820_entry_t and memory_region_t structures\n2. Implement `e820_init()` to parse multiboot mmap\n3. Add `e820_print()` for debugging\n4. Store parsed regions in global array\n\n**Checkpoint**: Memory map parsed and displayed\n```c\n// In kernel_main after basic init:\ne820_init(mbi);\ne820_print();\n// Expected: List of memory regions with types\n// \"Memory: 0x000000 - 0x09FFFF (usable)\"\n// \"Memory: 0x100000 - 0x3FFFFFF (usable)\"\n// etc.\n```\n\n**Test**: Verify region count and total memory match QEMU configuration\n\n### Phase 2: Bitmap Frame Allocator (4-5 hours)\n\n**Files**: `kernel/memory/frame.h`, `kernel/memory/frame.c`\n\n**Steps**:\n1. Implement placement allocator for boot-time allocations\n2. Calculate total frames from memory map\n3. Allocate bitmap using placement allocator\n4. Mark usable regions as free\n5. Reserve kernel frames\n6. Implement `alloc_frame()` with bitmap scan\n7. Implement `free_frame()` with double-free check\n\n**Checkpoint**: Frame allocator works\n```c\nvoid *frame1 = alloc_frame();\nvoid *frame2 = alloc_frame();\nkprintf(\"Allocated frames: 0x%x, 0x%x\\n\", frame1, frame2);\nfree_frame(frame1);\nvoid *frame3 = alloc_frame();\nkprintf(\"After free+alloc: 0x%x (should reuse 0x%x)\\n\", frame3, frame1);\n// Expected: frame3 == frame1 (first-fit reuses freed frame)\n```\n\n**Test**: Allocate all frames, verify NULL return; free and reallocate\n\n### Phase 3: Page Table Structures (3-4 hours)\n\n**Files**: `kernel/memory/paging.h`, `kernel/memory/paging.c` (partial)\n\n**Steps**:\n1. Define pte_t, pde_t and flag constants\n2. Define page_table_t, page_directory_t structures\n3. Implement PD_INDEX, PT_INDEX macros\n4. Implement `get_physical()` for address translation\n\n**Checkpoint**: Structures compile, indices calculate correctly\n```c\nkprintf(\"PD_INDEX(0xC0000000) = %d (expected 768)\\n\", PD_INDEX(0xC0000000));\nkprintf(\"PT_INDEX(0xC0001000) = %d (expected 1)\\n\", PT_INDEX(0xC0001000));\n```\n\n### Phase 4: map_page/unmap_page (4-5 hours)\n\n**Files**: Continue `kernel/memory/paging.c`\n\n**Steps**:\n1. Implement `map_page()` with page table allocation\n2. Implement `unmap_page()`\n3. Add invlpg inline assembly\n4. Test with identity-mapped addresses initially\n\n**Checkpoint**: Manual mapping works\n```c\npage_directory_t *test_pd = alloc_frame();\nmemset(test_pd, 0, PAGE_SIZE);\n\nvoid *frame = alloc_frame();\nmap_page(test_pd, 0x400000, (uint32_t)frame, PTE_PRESENT | PTE_WRITABLE);\n\nuint32_t phys = get_physical(test_pd, 0x400000);\nkprintf(\"Mapped 0x400000 -> 0x%x\\n\", phys);\n// Expected: phys == frame address\n```\n\n### Phase 5: Identity Mapping (2-3 hours)\n\n**Files**: Continue `kernel/memory/paging.c`\n\n**Steps**:\n1. Create initial page directory\n2. Identity map first 16MB (0x00000000 - 0x00FFFFFF)\n3. Verify VGA (0xB8000) still accessible\n\n**Checkpoint**: Identity mapping works\n```c\n// Create PD and identity map\npaging_init_identity_only();\n\n// VGA should still work\nvga_puts(\"Identity mapping works!\\n\");\n```\n\n### Phase 6: Higher-Half Kernel Mapping (3-4 hours)\n\n**Files**: `kernel/memory/paging.c`, update `kernel/linker.ld`\n\n**Steps**:\n1. Update linker script with higher-half addresses\n2. Add higher-half mapping (0xC0000000+ -> 0x00000000+)\n3. Handle the transition carefully (code runs at physical until paging enabled)\n4. Test kernel functions via higher-half addresses\n\n**Checkpoint**: Kernel runs in higher half\n```c\n// After paging_init():\nkprintf(\"Kernel running at 0x%x (virtual)\\n\", (uint32_t)&kernel_main);\nkprintf(\"Physical address: 0x%x\\n\", get_physical(current_page_directory, (uint32_t)&kernel_main));\n// Expected: Virtual ~0xC0100000, Physical ~0x00100000\n```\n\n**Critical**: Update linker script:\n```ld\nENTRY(kernel_entry)\n\nSECTIONS\n{\n    . = 0xC0100000;  /* Higher-half + 1MB offset */\n    \n    .text ALIGN(4K) : AT(ADDR(.text) - 0xC0000000)\n    {\n        *(.multiboot)\n        *(.text)\n    }\n    \n    .rodata ALIGN(4K) : AT(ADDR(.rodata) - 0xC0000000)\n    {\n        *(.rodata)\n    }\n    \n    .data ALIGN(4K) : AT(ADDR(.data) - 0xC0000000)\n    {\n        *(.data)\n    }\n    \n    .bss ALIGN(4K) : AT(ADDR(.bss) - 0xC0000000)\n    {\n        __bss_start = .;\n        *(COMMON)\n        *(.bss)\n        __bss_end = .;\n    }\n    \n    _kernel_end = .;\n}\n```\n\n### Phase 7: Paging Enablement Sequence (2-3 hours)\n\n**Files**: `kernel/memory/paging.c`\n\n**Steps**:\n1. Ensure identity mapping exists before enabling\n2. Load CR3 with page directory physical address\n3. Set CR0.PG bit\n4. Handle the instruction fetch after paging enabled\n5. Reload segment registers if needed\n\n**Checkpoint**: Paging enables without triple fault\n```bash\n# Run in QEMU with interrupt logging\nqemu-system-i386 -drive format=raw,file=os.img -d int,cpu_reset -serial stdio 2>&1 | head -100\n# Expected: No triple fault or reset after \"Enabling paging\" message\n```\n\n### Phase 8: Page Fault Handler (2-3 hours)\n\n**Files**: Update `kernel/interrupt_handler.c`\n\n**Steps**:\n1. Add case for vector 14 in `isr_handler()`\n2. Read CR2 for faulting address\n3. Decode error code bits\n4. Print comprehensive diagnostic\n5. Halt (no recovery in this version)\n\n**Checkpoint**: Page faults are diagnosed\n```c\n// Trigger a page fault:\nuint32_t *bad = (uint32_t*)0xDEADBEEF;\n*bad = 0x12345678;\n// Expected: Page fault message with address 0xDEADBEEF\n```\n\n### Phase 9: Kernel Heap (5-7 hours)\n\n**Files**: `kernel/memory/heap.h`, `kernel/memory/heap.c`\n\n**Steps**:\n1. Define heap_block_t structure\n2. Implement `heap_init()` to create initial heap region\n3. Map heap pages using frame allocator\n4. Implement `kmalloc()` with first-fit and block splitting\n5. Implement `kfree()` with coalescing\n6. Implement `heap_expand()` for growth\n\n**Checkpoint**: Heap allocation works\n```c\nheap_init();\n\nvoid *p1 = kmalloc(100);\nvoid *p2 = kmalloc(200);\nvoid *p3 = kmalloc(50);\n\nkprintf(\"Allocated: 0x%x, 0x%x, 0x%x\\n\", p1, p2, p3);\n\nkfree(p2);\nvoid *p4 = kmalloc(150);  // Should fit in p2's space\nkprintf(\"After free+alloc: 0x%x\\n\", p4);\n// Expected: p4 is near p2 (reused space)\n```\n\n**Test**: Stress test with many allocations/frees, verify no corruption\n\n### Final Integration (2-3 hours)\n\n**Goal**: Complete memory management system\n\n**Steps**:\n1. Create `kernel/memory/memory.c` with `memory_init(mbi)`\n2. Call all init functions in correct order:\n   - e820_init\n   - frame_allocator_init\n   - paging_init\n   - heap_init\n3. Update kernel_main to use memory_init\n4. Add memory status command for debugging\n\n**Checkpoint**: All tests pass\n```c\nvoid kernel_main(multiboot_info_t *mbi) {\n    vga_init();\n    serial_init(COM1_PORT);\n    \n    vga_puts(\"Initializing memory...\\n\");\n    memory_init(mbi);\n    \n    vga_puts(\"Memory status:\\n\");\n    vga_puts(\"  Total frames: \"); vga_put_dec(frame_alloc.total_frames);\n    vga_puts(\"\\n  Free frames: \"); vga_put_dec(frame_alloc.free_frames);\n    vga_puts(\"\\n  Kernel heap: 0x\"); vga_put_hex(HEAP_START);\n    vga_puts(\"\\n\\n\");\n    \n    // Test allocations\n    void *p = kmalloc(1024);\n    vga_puts(\"kmalloc(1024) = 0x\"); vga_put_hex((uint32_t)p);\n    vga_puts(\"\\n\");\n    \n    kfree(p);\n    vga_puts(\"kfree done\\n\");\n    \n    vga_puts(\"Memory system ready!\\n\");\n}\n```\n\n**Test Commands**:\n```bash\nmake clean && make\nqemu-system-i386 -drive format=raw,file=os.img -serial stdio\n\n# Expected:\n# - Memory map displayed\n# - Frame allocator initialized\n# - Paging enabled (no crash)\n# - Heap allocations work\n# - \"Memory system ready!\" appears\n```\n\n---\n\n## Test Specification\n\n### Test 1: Memory Map Parsing\n\n```python\n# test_memory_map.py\nimport subprocess\nimport re\n\ndef test_memory_map():\n    proc = subprocess.Popen(\n        ['qemu-system-i386', '-drive', 'format=raw,file=os.img',\n         '-serial', 'stdio', '-display', 'none'],\n        stdout=subprocess.PIPE\n    )\n    \n    import time\n    time.sleep(3)\n    proc.terminate()\n    output, _ = proc.communicate(timeout=5)\n    text = output.decode()\n    \n    # Check for memory region messages\n    assert 'Memory:' in text or 'memory' in text.lower(), \"No memory map output\"\n    \n    # Should have at least one usable region\n    usable_count = text.lower().count('usable')\n    assert usable_count >= 1, \"No usable memory regions found\"\n```\n\n### Test 2: Frame Allocation\n\n```c\n// kernel/test_frame.c\nvoid test_frame_allocation(void) {\n    vga_puts(\"Testing frame allocation...\\n\");\n    \n    // Allocate frames\n    void *f1 = alloc_frame();\n    void *f2 = alloc_frame();\n    void *f3 = alloc_frame();\n    \n    vga_puts(\"  Allocated: \");\n    vga_put_hex((uint32_t)f1); vga_puts(\", \");\n    vga_put_hex((uint32_t)f2); vga_puts(\", \");\n    vga_put_hex((uint32_t)f3); vga_puts(\"\\n\");\n    \n    // Verify different addresses\n    ASSERT(f1 != f2 && f2 != f3, \"Frames should be different\");\n    \n    // Free and reallocate\n    free_frame(f2);\n    void *f4 = alloc_frame();\n    \n    vga_puts(\"  After free+alloc: \");\n    vga_put_hex((uint32_t)f4); vga_puts(\"\\n\");\n    \n    // f4 should be f2 (reused)\n    ASSERT(f4 == f2, \"Frame should be reused\");\n    \n    vga_puts(\"PASS: Frame allocation\\n\");\n}\n```\n\n### Test 3: Double-Free Detection\n\n```c\n// kernel/test_frame.c\nvoid test_double_free(void) {\n    vga_puts(\"Testing double-free detection...\\n\");\n    \n    void *frame = alloc_frame();\n    \n    free_frame(frame);\n    \n    // This should panic\n    vga_puts(\"  Attempting double-free (should panic)...\\n\");\n    free_frame(frame);\n    \n    // Should not reach here\n    vga_puts(\"FAIL: Double-free not detected!\\n\");\n}\n```\n\n### Test 4: Page Mapping\n\n```c\n// kernel/test_paging.c\nvoid test_page_mapping(void) {\n    vga_puts(\"Testing page mapping...\\n\");\n    \n    // Create test page directory\n    page_directory_t *pd = (page_directory_t*)alloc_frame();\n    memset(pd, 0, PAGE_SIZE);\n    \n    // Map a page\n    uint32_t vaddr = 0x400000;\n    uint32_t paddr = (uint32_t)alloc_frame();\n    \n    int result = map_page(pd, vaddr, paddr, PTE_PRESENT | PTE_WRITABLE);\n    ASSERT(result == 0, \"map_page failed\");\n    \n    // Verify translation\n    uint32_t translated = get_physical(pd, vaddr);\n    vga_puts(\"  Mapped 0x\"); vga_put_hex(vaddr);\n    vga_puts(\" -> 0x\"); vga_put_hex(translated); vga_puts(\"\\n\");\n    \n    ASSERT(translated == paddr, \"Translation mismatch\");\n    \n    // Test unmapping\n    unmap_page(pd, vaddr);\n    translated = get_physical(pd, vaddr);\n    ASSERT(translated == 0, \"Page still mapped after unmap\");\n    \n    vga_puts(\"PASS: Page mapping\\n\");\n}\n```\n\n### Test 5: Paging Enablement\n\n```bash\n# test_paging_enable.sh\n# Run QEMU and check for triple fault after paging enable\n\ntimeout 5 qemu-system-i386 -drive format=raw,file=os.img \\\n    -d int,cpu_reset -serial stdio -display none 2>&1 | tee paging_log.txt\n\n# Check for \"Paging enabled\" message\nif grep -q \"Paging enabled\" paging_log.txt; then\n    echo \"PASS: Paging enabled message found\"\nelse\n    echo \"FAIL: Paging enabled message not found\"\n    exit 1\nfi\n\n# Check for triple fault (reset)\nif grep -q \"cpu_reset\" paging_log.txt; then\n    echo \"FAIL: CPU reset detected (possible triple fault)\"\n    exit 1\nfi\n\necho \"PASS: No triple fault after paging enable\"\n```\n\n### Test 6: Heap Allocation\n\n```c\n// kernel/test_heap.c\nvoid test_heap_allocation(void) {\n    vga_puts(\"Testing heap allocation...\\n\");\n    \n    // Allocate various sizes\n    void *p1 = kmalloc(16);\n    void *p2 = kmalloc(100);\n    void *p3 = kmalloc(1000);\n    \n    vga_puts(\"  kmalloc(16) = 0x\"); vga_put_hex((uint32_t)p1);\n    vga_puts(\"\\n  kmalloc(100) = 0x\"); vga_put_hex((uint32_t)p2);\n    vga_puts(\"\\n  kmalloc(1000) = 0x\"); vga_put_hex((uint32_t)p3);\n    vga_puts(\"\\n\");\n    \n    // Verify addresses are in heap region\n    ASSERT((uint32_t)p1 >= HEAP_START, \"p1 below heap\");\n    ASSERT((uint32_t)p2 >= HEAP_START, \"p2 below heap\");\n    ASSERT((uint32_t)p3 >= HEAP_START, \"p3 below heap\");\n    \n    // Write to memory (shouldn't fault)\n    memset(p1, 0xAA, 16);\n    memset(p2, 0xBB, 100);\n    memset(p3, 0xCC, 1000);\n    \n    // Free and reallocate\n    kfree(p2);\n    void *p4 = kmalloc(80);\n    \n    vga_puts(\"  After free+alloc: 0x\"); vga_put_hex((uint32_t)p4);\n    vga_puts(\"\\n\");\n    \n    // p4 should be near p2 (reused space)\n    ASSERT(abs((int)p4 - (int)p2) < 200, \"p4 should reuse p2 space\");\n    \n    vga_puts(\"PASS: Heap allocation\\n\");\n}\n```\n\n### Test 7: Heap Coalescing\n\n```c\n// kernel/test_heap.c\nvoid test_heap_coalescing(void) {\n    vga_puts(\"Testing heap coalescing...\\n\");\n    \n    // Allocate three contiguous blocks\n    void *p1 = kmalloc(100);\n    void *p2 = kmalloc(100);\n    void *p3 = kmalloc(100);\n    \n    // Free them in order\n    kfree(p1);\n    kfree(p2);\n    kfree(p3);\n    \n    // Now allocate a large block that should fit\n    void *large = kmalloc(300);\n    \n    vga_puts(\"  Large allocation after coalesce: 0x\");\n    vga_put_hex((uint32_t)large);\n    vga_puts(\"\\n\");\n    \n    // Should be at or near p1 (coalesced space)\n    ASSERT((uint32_t)large == (uint32_t)p1 || \n           abs((int)large - (int)p1) < 400,\n           \"Coalescing failed\");\n    \n    vga_puts(\"PASS: Heap coalescing\\n\");\n}\n```\n\n### Test 8: Page Fault Diagnostics\n\n```bash\n# test_page_fault.sh\n# Trigger page fault and verify diagnostic output\n\n# Modify kernel to intentionally cause page fault:\n# uint32_t *bad = (uint32_t*)0xDEADBEEF;\n# *bad = 0x12345678;\n\ntimeout 3 qemu-system-i386 -drive format=raw,file=os.img \\\n    -serial stdio -display none 2>&1 | tee pf_log.txt\n\n# Check for page fault message\nif grep -q \"PAGE FAULT\" pf_log.txt; then\n    echo \"PASS: Page fault handler executed\"\nelse\n    echo \"FAIL: No page fault message\"\n    exit 1\nfi\n\n# Check for faulting address\nif grep -q \"0xDEADBEEF\\|Address:\" pf_log.txt; then\n    echo \"PASS: Fault address reported\"\nelse\n    echo \"FAIL: Fault address not reported\"\n    exit 1\nfi\n```\n\n---\n\n## Performance Targets\n\n| Operation | Target | How to Measure |\n|-----------|--------|----------------|\n| Frame allocation (bitmap scan) | O(n) worst case, ~10µs for 1GB | Time alloc_frame() calls, average over 1000 allocations |\n| Frame free | O(1), < 1µs | Time free_frame() calls |\n| Page mapping (no PT alloc) | < 500 cycles, ~200ns | Time map_page() for already-present PT |\n| Page mapping (with PT alloc) | < 2000 cycles, ~1µs | Time map_page() including frame allocation |\n| TLB invalidate | ~10 cycles | Single invlpg instruction |\n| kmalloc (small, < 64 bytes) | < 1µs | Time 1000 allocations, average |\n| kmalloc (large, > 4KB) | < 10µs | Time large allocations including page mapping |\n| kfree | < 1µs | Time 1000 frees, average |\n| Page fault handler | < 50µs | Time from fault to diagnostic print |\n\n---\n\n## Hardware Soul\n\n### Cache Lines Touched\n\n**Page table access**: Each page table (4KB) occupies exactly 4 cache lines (64 bytes each). During a page walk:\n- 1 cache line read for PDE (8 bytes, likely shared with other PDEs)\n- 1 cache line read for PTE (4 bytes, likely shared with other PTEs)\n- Total: 2 cache line reads per TLB miss\n\n**Frame allocator bitmap**: For 1GB RAM with 4KB frames:\n- 32,768 bits = 4KB bitmap = 64 cache lines\n- Scanning allocates reads sequentially, good locality\n- Free operation touches single cache line\n\n**Heap metadata**: Each block header is 20 bytes. A 64-byte cache line holds ~3 block headers. Allocation scans through headers sequentially until finding fit.\n\n### TLB Behavior\n\n**TLB size**: 64-128 entries on typical x86 CPUs. Each entry maps one 4KB page.\n\n**Coverage**: 64 entries × 4KB = 256KB of direct mapping. Any access outside these 256KB triggers TLB miss and page walk.\n\n**Context switch cost**: CR3 reload invalidates all TLB entries (unless PCID used). Process switch = full TLB flush = worst case 64-128 page walks to repopulate.\n\n**Large page optimization**: Using 4MB pages (PS bit in PDE) means one TLB entry covers 4MB instead of 4KB. 64 entries × 4MB = 256MB coverage. (Not implemented in this spec.)\n\n### Memory Access Patterns\n\n**Sequential frame allocation**: Good cache behavior—bitmap scan proceeds linearly. If physical memory is contiguous, allocated frames have good locality.\n\n**Random page mapping**: If virtual addresses are scattered across different page tables, each mapping may allocate a new PT, causing allocation overhead and potential cache thrashing.\n\n**Heap fragmentation**: Over time, many small allocations/frees create scattered free blocks. First-fit scanning traverses many cache lines.\n\n### Physical Reality\n\n**DRAM latency**: ~70ns for DDR4. A TLB miss causing 2 DRAM accesses = 140ns minimum, plus controller overhead.\n\n**Page fault overhead**: Full context switch + disk I/O = milliseconds. Even without swap, just the handler overhead is 10-50µs.\n\n**False sharing**: If two frequently-modified variables share a cache line, they cause cache coherency traffic. Heap head/tail pointers should be on separate cache lines in a multi-threaded system.\n\n---\n\n## Concurrency Specification\n\n### Current Model: Single-Threaded\n\nAll allocation functions are **not thread-safe** by design for this milestone. The kernel runs single-threaded until Milestone 4.\n\n### Critical Sections (Future-Proofing)\n\nWhen interrupts are enabled and scheduling is added:\n\n```c\nvoid *kmalloc_safe(uint32_t size) {\n    void *ptr;\n    uint32_t flags;\n    \n    // Disable interrupts\n    asm volatile(\"pushf; pop %0; cli\" : \"=r\"(flags));\n    \n    ptr = kmalloc(size);\n    \n    // Restore interrupts\n    asm volatile(\"push %0; popf\" : : \"r\"(flags));\n    \n    return ptr;\n}\n```\n\n### Lock-Free Keyboard Buffer (Already Implemented)\n\nThe circular buffer uses careful index ordering:\n\n- Producer (IRQ handler) only writes to `head`, reads `tail`\n- Consumer (main code) only writes to `tail`, reads `head`\n- Full condition: `(head + 1) % SIZE == tail` (checked by producer)\n- Empty condition: `head == tail` (checked by consumer)\n\nNo locks needed because each side only modifies one index.\n\n---\n\n## Visual Diagrams\n\n### Page Table Hierarchy\n\n```\nx86 32-bit Two-Level Paging:\n\nVirtual Address (32 bits):\n┌─────────────────┬─────────────────┬─────────────────┐\n│  PD Index       │  PT Index       │  Page Offset    │\n│  (bits 31:22)   │  (bits 21:12)   │  (bits 11:0)    │\n│  10 bits        │  10 bits        │  12 bits        │\n└────────┬────────┴────────┬────────┴────────┬────────┘\n         │                 │                 │\n         ▼                 │                 │\n    ┌─────────┐            │                 │\n    │   CR3   │            │                 │\n    │(PD addr)│            │                 │\n    └────┬────┘            │                 │\n         │                 │                 │\n         ▼                 │                 │\n┌─────────────────┐        │                 │\n│ Page Directory  │        │                 │\n│  (4KB, 1024     │        │                 │\n│   entries)      │        │                 │\n├─────────────────┤        │                 │\n│ Entry[PD Index] │────────┘                 │\n│  → Page Table   │                          │\n│    Address      │                          │\n└────────┬────────┘                          │\n         │                                   │\n         ▼                                   │\n┌─────────────────┐                          │\n│  Page Table     │                          │\n│  (4KB, 1024     │                          │\n│   entries)      │                          │\n├─────────────────┤                          │\n│ Entry[PT Index] │──────────────────────────┘\n│  → Physical     │\n│    Frame Addr   │\n└────────┬────────┘\n         │\n         ▼\n┌─────────────────┐\n│ Physical Memory │\n│  (4KB Frame)    │\n│ at Frame Addr   │\n│ + Page Offset   │\n└─────────────────┘\n\nCoverage:\n- Page Directory: 1024 entries\n- Each PDE covers: 1024 × 4KB = 4MB\n- Total address space: 1024 × 4MB = 4GB\n```\n\n### Page Directory/Table Entry Bits\n\n```\nPage Table Entry (32 bits):\n┌───────┬───────┬───────┬───────┬───────┬───────┬───────┬───────┬─────────────────┐\n│ 31    │ 12    │ 11  9 │ 8     │ 7     │ 6     │ 5     │ 4  3  │ 2   │ 1   │ 0   │\n│ Frame │       │ Avail │ Global│ PS    │ Dirty │ Acc   │ PCD   │ PWT │ U/S │ R/W │ P   │\n│ Addr  │       │ (OS)  │       │       │       │       │ PWT   │     │     │     │     │\n└───────┴───────┴───────┴───────┴───────┴───────┴───────┴───────┴─────┴─────┴─────┘\n          │                │       │       │       │       │       │     │     │     │\n          │                │       │       │       │       │       │     │     │     └─ Present\n          │                │       │       │       │       │       │     │     └─ Read/Write\n          │                │       │       │       │       │       │     └─ User/Supervisor\n          │                │       │       │       │       │       └─ Write-Through\n          │                │       │       │       │       └─ Cache Disable\n          │                │       │       │       └─ Accessed (CPU sets)\n          │                │       │       └─ Dirty (CPU sets, PT only)\n          │                │       └─ Page Size (0=4KB, 1=4MB in PD)\n          │                └─ Global (not flushed on CR3 reload)\n          └─ Available for OS use\n          \nBits 31:12 - Physical Frame Address (frame must be 4KB aligned)\n\nPage Directory Entry (same format, but):\n- Bit 7 (PS): Page Size (0=4KB pages, 1=4MB pages)\n- Bit 6 (D): Reserved (not dirty)\n- Frame Address points to Page Table (not data frame)\n```\n\n### E820 Memory Map\n\n```\nTypical E820 Memory Map (512MB system):\n\nPhysical Address\n┌─────────────────────────────────────────────────────────────────┐\n│ 0x000000 - 0x000FFF │ IVT, BDA (Reserved)            │  4 KB   │\n├─────────────────────────────────────────────────────────────────┤\n│ 0x001000 - 0x07FFFF │ Low Memory (Usable)            │ 508 KB  │\n├─────────────────────────────────────────────────────────────────┤\n│ 0x080000 - 0x0FFFFF │ EBDA, Video RAM, ROM (Reserved)│ ~500 KB │\n├─────────────────────────────────────────────────────────────────┤\n│ 0x100000 - 0x1FFFFF │ Kernel + data (Usable)         │  1 MB   │\n│                     │ (Marked used by allocator)     │         │\n├─────────────────────────────────────────────────────────────────┤\n│ 0x200000 - 0x1FFFFFF│ Extended Memory (Usable)       │ ~30 MB  │\n│                     │ Available for allocation       │         │\n├─────────────────────────────────────────────────────────────────┤\n│ 0x2000000+          │ More RAM (Usable)              │ ~480 MB │\n└─────────────────────────────────────────────────────────────────┘\n\nMemory Map Entry Format (E820):\n┌─────────────────────────────────────────────────────────────────┐\n│ Offset  Size  Field                                           │\n├─────────────────────────────────────────────────────────────────┤\n│ 0       8     Base Address (uint64_t)                         │\n│ 8       8     Length (uint64_t)                               │\n│ 16      4     Type (uint32_t)                                 │\n│                 1 = Usable                                    │\n│                 2 = Reserved                                  │\n│                 3 = ACPI Reclaimable                          │\n│                 4 = ACPI NVS                                  │\n│                 5 = Bad Memory                                │\n│ 20      4     ACPI Extended Attributes (optional)             │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n### Identity + Higher-Half Mapping\n\n```\nVirtual Address Space Layout:\n\n┌─────────────────────────────────────────────────────────────────┐\n│ 0xFFFFFFFF           End of 32-bit address space               │\n│                                                                 │\n│ ... Reserved / Kernel Space ...                                │\n│                                                                 │\n├─────────────────────────────────────────────────────────────────┤\n│ 0xC0400000           Kernel Heap Start                         │\n│                     ┌─────────────────────────────────┐         │\n│                     │   kmalloc/kfree region          │         │\n│                     │   (grows on demand)             │         │\n│                     └─────────────────────────────────┘         │\n├─────────────────────────────────────────────────────────────────┤\n│ 0xC0100000           Kernel Code/Data (Higher-Half)            │\n│                     ┌─────────────────────────────────┐         │\n│                     │   .text, .rodata, .data, .bss   │         │\n│                     │   Maps to physical 0x00100000   │         │\n│                     └─────────────────────────────────┘         │\n├─────────────────────────────────────────────────────────────────┤\n│ 0xC0000000           Higher-Half Base (3 GB)                   │\n│                     Maps to physical 0x00000000                 │\n├─────────────────────────────────────────────────────────────────┤\n│ 0x01000000           End of Identity Map (16 MB)               │\n│                                                                 │\n│ ... Identity-Mapped Region ...                                 │\n│   0x00000000 - 0x00FFFFFF → 0x00000000 - 0x00FFFFFF           │\n│   (VGA at 0xB8000 accessible)                                  │\n│                                                                 │\n├─────────────────────────────────────────────────────────────────┤\n│ 0x00000000           Start of Address Space                    │\n│                     (User Space in future milestones)           │\n└─────────────────────────────────────────────────────────────────┘\n\nPhysical to Virtual Mapping:\n┌─────────────────────────────────────────────────────────────────┐\n│ Physical Address     Virtual Address         Purpose           │\n├─────────────────────────────────────────────────────────────────┤\n│ 0x00000000           0x00000000              Identity map      │\n│         ...                   ...             (first 16 MB)    │\n│ 0x00FFFFFF           0x00FFFFFF                                │\n├─────────────────────────────────────────────────────────────────┤\n│ 0x00000000           0xC0000000              Higher-half kernel│\n│         ...                   ...             (first 16 MB     │\n│ 0x00FFFFFF           0xC0FFFFFF               mapped high)     │\n├─────────────────────────────────────────────────────────────────┤\n│ 0x00100000           0xC0100000              Kernel code      │\n├─────────────────────────────────────────────────────────────────┤\n│ (allocated)          0xC0400000+             Kernel heap      │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n### Paging Enable Sequence\n\n```\nEnabling Paging - Critical Sequence:\n\n┌─────────────────────────────────────────────────────────────────┐\n│ Step 1: Create Page Directory                                   │\n│   pd = alloc_frame()                                            │\n│   memset(pd, 0, 4096)                                          │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│ Step 2: Identity Map First 16 MB                                │\n│   FOR addr = 0 TO 16MB STEP 4K:                                │\n│     map_page(pd, addr, addr, PTE_WRITABLE)                     │\n│                                                                 │\n│   CRITICAL: Must include currently executing code!              │\n│   The instruction AFTER enabling paging must be mapped.        │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│ Step 3: Higher-Half Mapping                                     │\n│   FOR offset = 0 TO 16MB STEP 4K:                              │\n│     vaddr = 0xC0000000 + offset                                │\n│     paddr = offset                                             │\n│     map_page(pd, vaddr, paddr, PTE_WRITABLE)                   │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│ Step 4: Load CR3                                                │\n│   asm volatile(\"mov %0, %%cr3\" : : \"r\"(pd_phys))               │\n│                                                                 │\n│   This sets the page directory base address.                   │\n│   TLB is flushed when CR3 changes.                             │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│ Step 5: Enable Paging                                           │\n│   asm volatile(\"mov %%cr0, %0\" : \"=r\"(cr0))                    │\n│   cr0 |= (1 << 31)  // Set PG bit                              │\n│   asm volatile(\"mov %0, %%cr0\" : : \"r\"(cr0))                   │\n│                                                                 │\n│   CRITICAL: The very next instruction fetch uses paging!       │\n│   If current EIP not mapped → immediate page fault → crash     │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│ Step 6: Continue in Paged Mode                                  │\n│   All addresses now translated through page tables.            │\n│   Kernel code accessible at 0xC0100000+.                       │\n│   VGA accessible at 0xB8000 (identity mapped).                 │\n└─────────────────────────────────────────────────────────────────┘\n\nCommon Mistakes:\n┌─────────────────────────────────────────────────────────────────┐\n│ ✗ Forgetting identity map → code not accessible after PG set   │\n│ ✗ Not mapping VGA → screen output breaks                       │\n│ ✗ Wrong CR3 value → page directory not found                   │\n│ ✗ Page tables not identity mapped → can't access PT to fill it │\n│ ✗ Forgetting invlpg → stale TLB entries                        │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n### Page Fault Handler Flow\n\n```\nPage Fault (Exception 14) Processing:\n\n┌─────────────────────────────────────────────────────────────────┐\n│                        CPU                                       │\n│  1. Instruction causes page fault                               │\n│  2. Push EFLAGS, CS, EIP                                        │\n│  3. Push error code                                              │\n│  4. Load CR2 with faulting address                              │\n│  5. Load IDT[14] → CS:EIP                                       │\n│  6. Jump to handler                                              │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│                    Assembly Stub                                 │\n│  1. Push dummy error code (if not provided)                     │\n│  2. Push interrupt number (14)                                  │\n│  3. pusha (save all GP registers)                               │\n│  4. Push segment registers                                      │\n│  5. Call C handler                                               │\n└─────────────────────────┬───────────────────────────────────────┘\n                          │\n                          ▼\n┌─────────────────────────────────────────────────────────────────┐\n│                     C Handler                                    │\n│                                                                 │\n│  void page_fault_handler(registers_t *regs) {                  │\n│      uint32_t fault_addr;                                       │\n│      asm volatile(\"mov %%cr2, %0\" : \"=r\"(fault_addr));         │\n│                                                                 │\n│      int present = !(regs->err_code & 0x1);                    │\n│      int write = regs->err_code & 0x2;                         │\n│      int user = regs->err_code & 0x4;                          │\n│                                                                 │\n│      kprintf(\"Page Fault!\\n\");                                  │\n│      kprintf(\"  Address: 0x%x\\n\", fault_addr);                 │\n│      kprintf(\"  %s, %s, %s mode\\n\",                            │\n│              present ? \"protection\" : \"not-present\",           │\n│              write ? \"write\" : \"read\",                          │\n│              user ? \"user\" : \"kernel\");                        │\n│                                                                 │\n│      PANIC(\"Unhandled page fault\");                             │\n│  }                                                               │\n└─────────────────────────────────────────────────────────────────┘\n\nError Code Bits:\n┌─────────────────────────────────────────────────────────────────┐\n│ Bit 0 (P): 0 = Page not present                                 │\n│            1 = Protection violation (page exists)              │\n│ Bit 1 (W): 0 = Read access                                      │\n│            1 = Write access                                     │\n│ Bit 2 (U): 0 = Supervisor mode (kernel)                        │\n│            1 = User mode                                        │\n│ Bit 3 (R): 1 = Reserved bit set in paging structures           │\n│ Bit 4 (I): 1 = Instruction fetch (NX violation)                │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n### kmalloc Internals\n\n```\nKernel Heap Structure:\n\n┌─────────────────────────────────────────────────────────────────┐\n│                      Virtual Memory                              │\n│                    0xC0400000+                                   │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  ┌────────────────────────────────────────────────────────────┐│\n│  │                    Heap Block 1 (free)                     ││\n│  ├────────────────────────────────────────────────────────────┤│\n│  │ magic   │ 0xDEADBEEF                                        ││\n│  │ size    │ 1000                                              ││\n│  │ free    │ 1                                                 ││\n│  │ next    │ ─────────────────────────────┐                   ││\n│  │ prev    │ NULL                         │                   ││\n│  ├─────────┴─────────────────────────────┴───────────────────┤│\n│  │                    Data Area (1000 bytes)                  ││\n│  └────────────────────────────────────────────────────────────┘│\n│                           │                                     │\n│                           ▼                                     │\n│  ┌────────────────────────────────────────────────────────────┐│\n│  │                  Heap Block 2 (allocated)                  ││\n│  ├────────────────────────────────────────────────────────────┤│\n│  │ magic   │ 0xDEADBEEF                                        ││\n│  │ size    │ 64                                                ││\n│  │ free    │ 0                                                 ││\n│  │ next    │ ─────────────────────────────┐                   ││\n│  │ prev    │ ◄─────────────────────────────┘                   ││\n│  ├─────────┴─────────────────────────────┴───────────────────┤│\n│  │                    Data Area (64 bytes)                    ││\n│  │               [kmalloc returned pointer here]              ││\n│  └────────────────────────────────────────────────────────────┘│\n│                           │                                     │\n│                           ▼                                     │\n│  ┌────────────────────────────────────────────────────────────┐│\n│  │                    Heap Block 3 (free)                     ││\n│  ├────────────────────────────────────────────────────────────┤│\n│  │ magic   │ 0xDEADBEEF                                        ││\n│  │ size    │ 4080                                              ││\n│  │ free    │ 1                                                 ││\n│  │ next    │ NULL (end of heap)                               ││\n│  │ prev    │ ◄─────────────────────────────                    ││\n│  ├─────────┴─────────────────────────────┴───────────────────┤│\n│  │                    Data Area (4080 bytes)                  ││\n│  └────────────────────────────────────────────────────────────┘│\n│                                                                 │\n├─────────────────────────────────────────────────────────────────┤\n│                    End of Mapped Heap                           │\n│              (expand by mapping more pages)                     │\n└─────────────────────────────────────────────────────────────────┘\n\nkmalloc Algorithm:\n┌─────────────────────────────────────────────────────────────────┐\n│ 1. Align size to 4 bytes                                        │\n│ 2. Scan free list for block >= size                            │\n│ 3. If found:                                                    │\n│    a. If block is much larger, split:                          │\n│       - Create new free block after allocated portion          │\n│       - Adjust sizes                                           │\n│    b. Mark block as allocated                                   │\n│    c. Return pointer to data area                              │\n│ 4. If not found:                                                │\n│    a. Expand heap (map new pages)                              │\n│    b. Create new free block in expanded region                 │\n│    c. Retry allocation                                          │\n└─────────────────────────────────────────────────────────────────┘\n\nkfree Algorithm:\n┌─────────────────────────────────────────────────────────────────┐\n│ 1. Get block header from pointer                               │\n│ 2. Verify magic number                                          │\n│ 3. Check for double-free                                        │\n│ 4. Mark as free                                                 │\n│ 5. Coalesce with next block if free                            │\n│ 6. Coalesce with previous block if free                        │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n\n<!-- TDD_MOD_ID: mod-scheduling -->\n# Technical Design Specification: Process Management and Preemptive Scheduling\n\n## Module Charter\n\nThe process management module implements preemptive multitasking through Process Control Blocks (PCBs) that capture complete CPU state, assembly context switching that saves/restores all registers, TSS configuration for secure ring 3→ring 0 stack transitions during interrupts/syscalls, a round-robin scheduler triggered by timer interrupts, and a system call interface via INT 0x80. It supports both kernel-mode processes (ring 0, shared address space) and user-mode processes (ring 3, isolated page directories).\n\n**What it does NOT do**: This module does not implement demand paging (page faults halt), does not implement priority scheduling or deadline scheduling (round-robin only), does not implement inter-process communication beyond basic syscalls, does not handle process termination cleanup beyond marking zombie state, does not implement copy-on-write fork, and does not implement threading (one thread per process).\n\n**Upstream dependencies**: GDT must include user code/data descriptors (ring 3) at indices 3-4; IDT must have handlers for exceptions 0-31 and IRQs 0-15; timer interrupt must fire at configured frequency; paging must be enabled with identity mapping for low memory and higher-half kernel; frame allocator and heap must be functional.\n\n**Downstream consumers**: User programs execute via syscalls (sys_write, sys_exit); shell/command interpreter will use process creation; future milestones may add IPC, signals, and file descriptors.\n\n**Invariants**: TSS.ESP0 must be updated before every context switch to a user-mode process; context switch must save ALL registers in PCB order; scheduler must disable interrupts during critical sections; user processes must never access kernel memory (page fault if attempted); syscall handler must validate all user pointers before dereferencing.\n\n---\n\n## File Structure\n\nCreate files in this order:\n\n```\n1. kernel/process/process.h      # PCB structure, process states, function declarations\n2. kernel/process/process.c      # Process creation, destruction, table management\n3. kernel/process/context.asm    # Context switch assembly implementation\n4. kernel/process/tss.h          # TSS structure and function declarations\n5. kernel/process/tss.c          # TSS initialization and ESP0 update\n6. kernel/process/scheduler.h    # Scheduler interface declarations\n7. kernel/process/scheduler.c    # Round-robin scheduler implementation\n8. kernel/syscall/syscall.h      # Syscall numbers and handler declarations\n9. kernel/syscall/syscall.c      # Syscall dispatch and implementations\n10. kernel/syscall/syscall.asm   # Syscall entry stub (INT 0x80)\n11. kernel/user/user_mode.asm    # enter_user_mode assembly\n12. kernel/user/user_entry.c     # User process entry point wrapper\n```\n\n---\n\n## Complete Data Model\n\n### Process Control Block (PCB)\n\n```c\n// kernel/process/process.h\n#include <stdint.h>\n#include \"memory/paging.h\"\n\n// Process states\ntypedef enum {\n    PROCESS_UNUSED = 0,       // Slot in process table is free\n    PROCESS_READY,            // Ready to run, waiting for scheduler\n    PROCESS_RUNNING,          // Currently executing\n    PROCESS_BLOCKED,          // Waiting for I/O, sleep, etc.\n    PROCESS_ZOMBIE            // Terminated, waiting for cleanup\n} process_state_t;\n\n// Process Control Block - matches assembly offsets exactly\ntypedef struct process {\n    // === Identification (offset 0) ===\n    uint32_t pid;                    // Process ID (1-65535)\n    char name[16];                   // Process name (null-terminated)\n    process_state_t state;           // Current state\n    uint8_t padding0[4];             // Align to 8 bytes\n    \n    // === Register state (offset 32) ===\n    // General purpose registers\n    uint32_t eax;                    // Offset 32\n    uint32_t ebx;                    // Offset 36\n    uint32_t ecx;                    // Offset 40\n    uint32_t edx;                    // Offset 44\n    uint32_t esi;                    // Offset 48\n    uint32_t edi;                    // Offset 52\n    uint32_t ebp;                    // Offset 56\n    uint32_t esp;                    // Offset 60 - kernel or user stack\n    uint32_t eip;                    // Offset 64 - instruction pointer\n    uint32_t eflags;                 // Offset 68 - flags register\n    \n    // Segment registers (16-bit values stored in 32-bit fields)\n    uint32_t cs;                     // Offset 72 - code segment\n    uint32_t ds;                     // Offset 76 - data segment\n    uint32_t es;                     // Offset 80\n    uint32_t fs;                     // Offset 84\n    uint32_t gs;                     // Offset 88\n    uint32_t ss;                     // Offset 92 - stack segment\n    \n    // === Memory management (offset 96) ===\n    page_directory_t *page_directory;    // Offset 96 - virtual address space\n    uint32_t kernel_stack;               // Offset 100 - top of kernel stack (for TSS.ESP0)\n    uint32_t user_stack_top;             // Offset 104 - user stack top (if user mode)\n    \n    // === Scheduling (offset 108) ===\n    struct process *next;           // Offset 108 - next in run queue\n    struct process *prev;           // Offset 112 - previous in run queue\n    uint32_t wake_time;             // Offset 116 - tick to wake (for sleep)\n    int32_t exit_status;            // Offset 120 - exit code for parent\n    uint32_t time_slice;            // Offset 124 - remaining time slice\n    \n    // === Process tree (future expansion) ===\n    struct process *parent;         // Offset 128 - parent process\n    struct process *first_child;    // Offset 132 - first child\n    struct process *next_sibling;   // Offset 136 - next sibling\n    \n} __attribute__((packed)) process_t;\n\n// Verify PCB size and alignment\n#define PCB_SIZE sizeof(process_t)\n#define PCB_REG_OFFSET 32          // Offset to first register (eax)\n\n// Process table\n#define MAX_PROCESSES 64\n#define KERNEL_STACK_SIZE 4096     // 4KB kernel stack per process\n#define USER_STACK_SIZE (64 * 1024) // 64KB user stack\n\nextern process_t process_table[MAX_PROCESSES];\nextern process_t *current_process;\nextern process_t *ready_queue;\nextern uint32_t next_pid;\n\n// Assembly context switch offsets MUST match this structure:\n// Verify with: nasm -f elf32 context.asm && nm context.o\n```\n\n**PCB Memory Layout (byte offsets):**\n\n| Offset | Size | Field | Purpose |\n|--------|------|-------|---------|\n| 0 | 4 | pid | Unique process identifier |\n| 4 | 16 | name | Debug-friendly process name |\n| 20 | 4 | state | Ready/Running/Blocked/Zombie |\n| 24 | 4 | padding0 | Alignment to 8 bytes |\n| 28 | 4 | (reserved) | Future use |\n| 32 | 4 | eax | General purpose register A |\n| 36 | 4 | ebx | General purpose register B |\n| 40 | 4 | ecx | General purpose register C |\n| 44 | 4 | edx | General purpose register D |\n| 48 | 4 | esi | Source index register |\n| 52 | 4 | edi | Destination index register |\n| 56 | 4 | ebp | Base pointer |\n| 60 | 4 | esp | Stack pointer |\n| 64 | 4 | eip | Instruction pointer |\n| 68 | 4 | eflags | CPU flags |\n| 72 | 4 | cs | Code segment selector |\n| 76 | 4 | ds | Data segment selector |\n| 80 | 4 | es | Extra segment selector |\n| 84 | 4 | fs | Extra segment selector |\n| 88 | 4 | gs | Extra segment selector |\n| 92 | 4 | ss | Stack segment selector |\n| 96 | 4 | page_directory | Pointer to process page tables |\n| 100 | 4 | kernel_stack | Kernel stack top (for TSS.ESP0) |\n| 104 | 4 | user_stack_top | User mode stack top |\n| 108 | 4 | next | Next process in queue |\n| 112 | 4 | prev | Previous process in queue |\n| 116 | 4 | wake_time | Tick count to wake |\n| 120 | 4 | exit_status | Process exit code |\n| 124 | 4 | time_slice | Remaining quantum |\n| 128 | 4 | parent | Parent process pointer |\n| 132 | 4 | first_child | First child pointer |\n| 136 | 4 | next_sibling | Sibling list pointer |\n\n### Task State Segment (TSS)\n\n```c\n// kernel/process/tss.h\n#include <stdint.h>\n\n// TSS structure for 32-bit x86\n// Only SS0:ESP0 are critical for ring transitions\ntypedef struct {\n    uint16_t prev_task;       // 0: Previous task link (unused)\n    uint16_t reserved0;       // 2: Reserved\n    uint32_t esp0;            // 4: Stack pointer for ring 0 (CRITICAL)\n    uint16_t ss0;             // 8: Stack segment for ring 0 (CRITICAL)\n    uint16_t reserved1;       // 10: Reserved\n    uint32_t esp1;            // 12: Stack pointer for ring 1 (unused)\n    uint16_t ss1;             // 16: Stack segment for ring 1 (unused)\n    uint16_t reserved2;       // 18: Reserved\n    uint32_t esp2;            // 20: Stack pointer for ring 2 (unused)\n    uint16_t ss2;             // 24: Stack segment for ring 2 (unused)\n    uint16_t reserved3;       // 26: Reserved\n    uint32_t cr3;             // 28: Page directory base (unused in software switching)\n    uint32_t eip;             // 32: Instruction pointer (unused)\n    uint32_t eflags;          // 36: Flags (unused)\n    uint32_t eax;             // 40-68: General registers (unused)\n    uint32_t ecx;\n    uint32_t edx;\n    uint32_t ebx;\n    uint32_t esp;\n    uint32_t ebp;\n    uint32_t esi;\n    uint32_t edi;\n    uint16_t es;              // 72: Extra segment (unused)\n    uint16_t reserved4;\n    uint16_t cs;              // 76: Code segment (unused)\n    uint16_t reserved5;\n    uint16_t ss;              // 80: Stack segment (unused)\n    uint16_t reserved6;\n    uint16_t ds;              // 84: Data segment (unused)\n    uint16_t reserved7;\n    uint16_t fs;              // 88: Extra segment (unused)\n    uint16_t reserved8;\n    uint16_t gs;              // 92: Extra segment (unused)\n    uint16_t reserved9;\n    uint16_t ldt;             // 96: LDT selector (unused)\n    uint16_t reserved10;\n    uint16_t trap;            // 100: Trap bit (unused)\n    uint16_t iomap_base;      // 102: I/O permission bitmap offset\n} __attribute__((packed)) tss_t;\n\n// TSS instance\nextern tss_t tss;\n\n// TSS selector in GDT (index 5, selector = 0x28)\n#define TSS_SELECTOR 0x28\n```\n\n### System Call Numbers\n\n```c\n// kernel/syscall/syscall.h\n#include <stdint.h>\n\n// System call numbers (passed in EAX)\n#define SYS_EXIT    0    // void sys_exit(int status)\n#define SYS_READ    1    // int sys_read(int fd, char *buf, int count)\n#define SYS_WRITE   2    // int sys_write(int fd, const char *buf, int count)\n#define SYS_EXEC    3    // int sys_exec(const char *path)\n#define SYS_FORK    4    // int sys_fork(void)\n#define SYS_GETPID  5    // int sys_getpid(void)\n#define SYS_YIELD   6    // void sys_yield(void)\n\n// Maximum syscall number\n#define MAX_SYSCALL 7\n\n// Syscall handler type\ntypedef int32_t (*syscall_handler_t)(uint32_t arg0, uint32_t arg1, uint32_t arg2);\n\n// Syscall dispatch table\nextern syscall_handler_t syscall_table[MAX_SYSCALL];\n\n// Individual syscall implementations\nvoid sys_exit(int status);\nint sys_write(int fd, const char *buf, int count);\nint sys_read(int fd, char *buf, int count);\nint sys_getpid(void);\nvoid sys_yield(void);\n```\n\n### Scheduler Data Structures\n\n```c\n// kernel/process/scheduler.h\n#include \"process.h\"\n\n// Scheduler configuration\n#define DEFAULT_TIME_SLICE  10    // Default ticks per time slice (100ms at 100Hz)\n#define SCHEDULER_FREQ      100   // Timer frequency in Hz\n\n// Scheduler state\nextern uint32_t scheduler_ticks;\nextern volatile int scheduler_enabled;\n\n// Run queue management\nvoid scheduler_add_to_queue(process_t *proc);\nvoid scheduler_remove_from_queue(process_t *proc);\nprocess_t *scheduler_pick_next(void);\n\n// Core scheduler functions\nvoid scheduler_init(void);\nvoid scheduler_tick(void);           // Called from timer interrupt\nvoid scheduler_yield(void);          // Voluntary yield\nvoid scheduler_block(process_t *proc);\nvoid scheduler_unblock(process_t *proc);\n```\n\n---\n\n## Interface Contracts\n\n### process_create(const char *name, void (*entry)(void), int is_user)\n\n**Purpose**: Create a new process and add it to the ready queue\n\n**Parameters**:\n- `name`: Process name (max 15 characters)\n- `entry`: Entry point function\n- `is_user`: 0 for kernel-mode process, 1 for user-mode\n\n**Returns**:\n- Pointer to new process_t on success\n- NULL on failure (process table full, out of memory)\n\n**Side effects**:\n- Allocates PCB slot\n- Allocates kernel stack (4KB)\n- For user processes: allocates user stack and clones page directory\n- Adds process to ready queue\n\n**Preconditions**: Memory allocator initialized; paging enabled\n\n**Postconditions**: New process in READY state, runnable by scheduler\n\n### process_exit(int status)\n\n**Purpose**: Terminate the current process\n\n**Parameters**:\n- `status`: Exit status code\n\n**Returns**: Does not return\n\n**Side effects**:\n- Sets process state to ZOMBIE\n- Stores exit status\n- Removes from run queue\n- Triggers scheduler to run next process\n\n### context_switch(process_t *old, process_t *new)\n\n**Purpose**: Save current CPU state to old PCB and load state from new PCB\n\n**Parameters**:\n- `old`: Pointer to current process PCB (may be NULL for first switch)\n- `new`: Pointer to process to switch to\n\n**Returns**: Does not return to caller (returns to new process context)\n\n**Side effects**:\n- Saves all registers to old->*\n- Loads CR3 if page directories differ\n- Updates TSS.ESP0 for user processes\n- Loads all registers from new->*\n- Returns to new->eip with new->eflags\n\n**Critical**: Assembly implementation; must match PCB offsets exactly\n\n### tss_init(void)\n\n**Purpose**: Initialize the Task State Segment and load TR\n\n**Parameters**: None\n\n**Returns**: None\n\n**Side effects**:\n- Zeros TSS structure\n- Sets TSS.SS0 = 0x10 (kernel data selector)\n- Adds TSS descriptor to GDT at index 5\n- Loads TR with selector 0x28\n\n**Preconditions**: GDT must be loaded\n\n### tss_set_esp0(uint32_t esp0)\n\n**Purpose**: Update the kernel stack pointer for ring transitions\n\n**Parameters**:\n- `esp0`: New value for TSS.ESP0\n\n**Returns**: None\n\n**Critical**: MUST be called before switching to any user-mode process\n\n### scheduler_init(void)\n\n**Purpose**: Initialize scheduler and create kernel idle process\n\n**Parameters**: None\n\n**Returns**: None\n\n**Side effects**:\n- Creates PCB for current (kernel) process\n- Sets current_process to kernel process\n- Enables scheduler\n\n### scheduler_tick(void)\n\n**Purpose**: Handle timer interrupt and trigger context switch if needed\n\n**Parameters**: None (called from timer IRQ handler)\n\n**Returns**: None\n\n**Side effects**:\n- Increments tick counter\n- Decrements current process time slice\n- Triggers context switch if slice expired or process yielded\n\n**Preconditions**: Timer interrupt configured; IDT loaded\n\n### scheduler_yield(void)\n\n**Purpose**: Voluntarily give up CPU to next ready process\n\n**Parameters**: None\n\n**Returns**: Does not return immediately (returns when scheduled again)\n\n**Side effects**:\n- Marks current process as READY\n- Triggers immediate context switch\n\n### enter_user_mode(uint32_t entry, uint32_t stack)\n\n**Purpose**: Transition from kernel mode to user mode\n\n**Parameters**:\n- `entry`: Entry point address in user space\n- `stack`: Top of user stack\n\n**Returns**: Does not return (begins executing user code at ring 3)\n\n**Side effects**:\n- Loads segment registers with user selectors (0x23)\n- Sets up iret frame with user CS, SS, EIP, ESP, EFLAGS\n- Executes iret to enter ring 3\n\n**Critical**: TSS.ESP0 must be set before calling\n\n### syscall_handler(registers_t *regs)\n\n**Purpose**: Dispatch system call to appropriate handler\n\n**Parameters**:\n- `regs`: Pointer to saved register frame (int_no = 0x80)\n\n**Returns**: Result in regs->eax\n\n**Side effects**:\n- Validates syscall number\n- Validates user pointers\n- Calls appropriate handler function\n\n---\n\n## Algorithm Specification\n\n### Process Creation\n\n```\nPROCESS_CREATE(name, entry, is_user):\n  1. Find free slot in process_table\n     FOR i = 0 TO MAX_PROCESSES - 1:\n       IF process_table[i].state == PROCESS_UNUSED:\n         proc = &process_table[i]\n         BREAK\n     IF no free slot:\n       RETURN NULL\n  \n  2. Initialize PCB fields\n     memset(proc, 0, sizeof(process_t))\n     proc->pid = next_pid++\n     strncpy(proc->name, name, 15)\n     proc->state = PROCESS_READY\n     proc->time_slice = DEFAULT_TIME_SLICE\n  \n  3. Allocate kernel stack\n     stack_frame = alloc_frame()\n     IF stack_frame == NULL:\n       RETURN NULL\n     proc->kernel_stack = (uint32_t)stack_frame + KERNEL_STACK_SIZE\n  \n  4. Set up initial register state\n     proc->eip = (uint32_t)entry\n     proc->eflags = 0x202  // IF=1, bit 1 always 1\n     proc->ebp = proc->kernel_stack\n     proc->esp = proc->kernel_stack  // Will be adjusted for iret frame\n  \n  5. Set up segments based on mode\n     IF is_user:\n       // User mode (ring 3)\n       proc->cs = 0x1B   // User code selector (GDT index 3, RPL=3)\n       proc->ds = 0x23   // User data selector (GDT index 4, RPL=3)\n       proc->es = 0x23\n       proc->fs = 0x23\n       proc->gs = 0x23\n       proc->ss = 0x23\n       \n       // Create user page directory (clone kernel mappings)\n       proc->page_directory = clone_page_directory(current_page_directory)\n       IF proc->page_directory == NULL:\n         free_frame(stack_frame)\n         RETURN NULL\n       \n       // Allocate user stack\n       user_stack_virt = USER_STACK_TOP - USER_STACK_SIZE\n       FOR page = user_stack_virt TO USER_STACK_TOP STEP 4096:\n         phys = alloc_frame()\n         IF phys == NULL:\n           // Cleanup and fail\n           RETURN NULL\n         map_page(proc->page_directory, page, phys, \n                  PTE_PRESENT | PTE_WRITABLE | PTE_USER)\n       \n       proc->user_stack_top = USER_STACK_TOP\n       proc->esp = USER_STACK_TOP  // User stack top\n     ELSE:\n       // Kernel mode (ring 0)\n       proc->cs = 0x08   // Kernel code selector\n       proc->ds = 0x10   // Kernel data selector\n       proc->es = 0x10\n       proc->fs = 0x10\n       proc->gs = 0x10\n       proc->ss = 0x10\n       proc->page_directory = current_page_directory\n       proc->user_stack_top = 0\n  \n  6. Add to ready queue\n     proc->next = ready_queue\n     proc->prev = NULL\n     IF ready_queue != NULL:\n       ready_queue->prev = proc\n     ready_queue = proc\n  \n  7. RETURN proc\n```\n\n### Context Switch (Assembly)\n\n```asm\n; kernel/process/context.asm\n; void context_switch(process_t *old, process_t *new)\n; Arguments: [esp+4] = old, [esp+8] = new\n\nglobal context_switch\nextern current_process\nextern current_page_directory\nextern tss\n\nsection .text\n\n; PCB offsets - MUST match process.h\n%define PCB_PID          0\n%define PCB_EAX          32\n%define PCB_EBX          36\n%define PCB_ECX          40\n%define PCB_EDX          44\n%define PCB_ESI          48\n%define PCB_EDI          52\n%define PCB_EBP          56\n%define PCB_ESP          60\n%define PCB_EIP          64\n%define PCB_EFLAGS       68\n%define PCB_CS           72\n%define PCB_DS           76\n%define PCB_ES           80\n%define PCB_FS           84\n%define PCB_GS           88\n%define PCB_SS           92\n%define PCB_PAGE_DIR     96\n%define PCB_KERNEL_STACK 100\n\ncontext_switch:\n    ; Prologue\n    push ebp\n    mov ebp, esp\n    pushf                      ; Save EFLAGS\n    push ebx                   ; Save callee-saved registers\n    push esi\n    push edi\n    \n    ; Get arguments\n    mov ecx, [ebp + 8]         ; ecx = old process\n    mov edx, [ebp + 12]        ; edx = new process\n    \n    ; === SAVE OLD PROCESS STATE ===\n    test ecx, ecx\n    jz .skip_save              ; Skip if old is NULL (first switch)\n    \n    ; Save return address as new EIP\n    mov eax, [ebp + 4]         ; Return address\n    mov [ecx + PCB_EIP], eax\n    \n    ; Save stack pointer\n    lea eax, [ebp + 20]        ; ESP before we pushed anything\n    mov [ecx + PCB_ESP], eax\n    \n    ; Save callee-saved registers we pushed\n    mov [ecx + PCB_EBX], ebx\n    mov [ecx + PCB_ESI], esi\n    mov [ecx + PCB_EDI], edi\n    mov [ecx + PCB_EBP], ebp\n    \n    ; Save EFLAGS\n    mov eax, [ebp - 4]         ; Pushed EFLAGS\n    mov [ecx + PCB_EFLAGS], eax\n    \n    ; Save segment registers\n    mov eax, ds\n    mov [ecx + PCB_DS], eax\n    mov eax, es\n    mov [ecx + PCB_ES], eax\n    mov eax, fs\n    mov [ecx + PCB_FS], eax\n    mov eax, gs\n    mov [ecx + PCB_GS], eax\n    mov eax, ss\n    mov [ecx + PCB_SS], eax\n    \n    ; Save caller-saved registers (these were in eax/edx/ecx)\n    ; We'll restore them from the PCB later if needed\n    ; For now, we don't save eax/edx/ecx as they're caller-saved\n    \n.skip_save:\n    ; === LOAD NEW PROCESS STATE ===\n    \n    ; Update current_process\n    mov [current_process], edx\n    \n    ; Switch page directory if different\n    mov eax, [current_page_directory]\n    cmp eax, [edx + PCB_PAGE_DIR]\n    je .same_page_dir\n    \n    ; Load new CR3\n    mov eax, [edx + PCB_PAGE_DIR]\n    mov cr3, eax\n    mov [current_page_directory], eax\n    \n.same_page_dir:\n    ; Update TSS.ESP0 for user processes\n    ; Check if CS indicates user mode (0x1B)\n    cmp word [edx + PCB_CS], 0x1B\n    jne .kernel_process\n    \n    ; User process - update TSS.ESP0\n    mov eax, [edx + PCB_KERNEL_STACK]\n    mov [tss + 4], eax         ; tss.esp0 offset is 4\n    \n.kernel_process:\n    ; Restore segment registers\n    mov ds, [edx + PCB_DS]\n    mov es, [edx + PCB_ES]\n    mov fs, [edx + PCB_FS]\n    mov gs, [edx + PCB_GS]\n    \n    ; Restore general registers\n    mov ebx, [edx + PCB_EBX]\n    mov esi, [edx + PCB_ESI]\n    mov edi, [edx + PCB_EDI]\n    mov ebp, [edx + PCB_EBP]\n    \n    ; Restore stack pointer\n    mov esp, [edx + PCB_ESP]\n    \n    ; Restore EFLAGS\n    push dword [edx + PCB_EFLAGS]\n    popf\n    \n    ; Restore ESI last (we used it earlier, but now we restore from PCB)\n    ; Actually, we already restored ESI above\n    \n    ; Return to new process\n    mov eax, [edx + PCB_EIP]\n    jmp eax                    ; Jump to new process's EIP\n```\n\n### TSS Initialization\n\n```\nTSS_INIT():\n  1. Zero TSS structure\n     memset(&tss, 0, sizeof(tss_t))\n  \n  2. Set critical fields\n     tss.ss0 = 0x10            // Kernel data selector\n     tss.esp0 = 0x90000        // Initial kernel stack (updated on switch)\n     tss.iomap_base = sizeof(tss_t)  // No I/O bitmap\n  \n  3. Add TSS descriptor to GDT\n     base = (uint32_t)&tss\n     limit = sizeof(tss_t) - 1\n     \n     // TSS descriptor (system segment, type=0x9 for 32-bit TSS available)\n     // Byte 5 (access): 0x89 = Present(1) DPL=0(00) S=0(0) Type=01001(9)\n     // Byte 6 (flags): Granularity=0, 32-bit=1, Limit[19:16]=0\n     \n     gdt_set_gate(5, base, limit, 0x89, 0x00)\n  \n  4. Load Task Register\n     asm volatile(\"ltr %w0\" : : \"r\"(TSS_SELECTOR))\n```\n\n### Round-Robin Scheduler\n\n```\nSCHEDULER_TICK():\n  1. Increment tick counter\n     scheduler_ticks++\n  \n  2. Check if scheduler enabled\n     IF !scheduler_enabled:\n       RETURN\n  \n  3. Decrement current process time slice\n     IF current_process != NULL:\n       current_process->time_slice--\n       \n       IF current_process->time_slice == 0:\n         // Time slice expired\n         current_process->time_slice = DEFAULT_TIME_SLICE\n         current_process->state = PROCESS_READY\n         \n         // Move to end of queue\n         scheduler_remove_from_queue(current_process)\n         scheduler_add_to_queue(current_process)\n         \n         // Trigger context switch\n         SCHEDULE()\n  \n  4. Check for yielded processes\n     IF current_process->state == PROCESS_READY AND current_process != ready_queue:\n       SCHEDULE()\n\nSCHEDULE():\n  1. Find next runnable process\n     next = ready_queue\n     WHILE next != NULL:\n       IF next->state == PROCESS_READY:\n         BREAK\n       next = next->next\n     \n     IF next == NULL:\n       // No runnable process - keep running current\n       RETURN\n  \n  2. Check if same process\n     IF next == current_process:\n       RETURN\n  \n  3. Update process states\n     old = current_process\n     IF old->state == PROCESS_RUNNING:\n       old->state = PROCESS_READY\n     \n     next->state = PROCESS_RUNNING\n  \n  4. Update current_process\n     current_process = next\n  \n  5. Remove from front of queue\n     scheduler_remove_from_queue(next)\n     scheduler_add_to_queue(next)  // Add to end (round-robin)\n  \n  6. Perform context switch\n     context_switch(old, next)\n\nSCHEDULER_ADD_TO_QUEUE(proc):\n  IF ready_queue == NULL:\n    ready_queue = proc\n    proc->prev = NULL\n    proc->next = NULL\n  ELSE:\n    // Find end of queue\n    last = ready_queue\n    WHILE last->next != NULL:\n      last = last->next\n    \n    last->next = proc\n    proc->prev = last\n    proc->next = NULL\n\nSCHEDULER_REMOVE_FROM_QUEUE(proc):\n  IF proc->prev != NULL:\n    proc->prev->next = proc->next\n  ELSE:\n    ready_queue = proc->next\n  \n  IF proc->next != NULL:\n    proc->next->prev = proc->prev\n  \n  proc->prev = NULL\n  proc->next = NULL\n```\n\n### System Call Dispatch\n\n```\nSYSCALL_HANDLER(regs):\n  1. Extract syscall number\n     syscall_num = regs->eax\n     \n  2. Validate syscall number\n     IF syscall_num < 0 OR syscall_num >= MAX_SYSCALL:\n       regs->eax = -1  // Return error\n       RETURN\n  \n  3. Get handler\n     handler = syscall_table[syscall_num]\n     IF handler == NULL:\n       regs->eax = -1\n       RETURN\n  \n  4. Call handler with arguments\n     // Arguments are in EBX, ECX, EDX\n     result = handler(regs->ebx, regs->ecx, regs->edx)\n     \n  5. Store result\n     regs->eax = result\n\nSYS_WRITE(fd, buf, count):\n  1. Validate file descriptor\n     IF fd < 0 OR fd > 2:  // Only stdout(1) and stderr(2) supported\n       RETURN -1\n  \n  2. Validate buffer pointer\n     IF buf == NULL:\n       RETURN -1\n     \n     // Check buffer is in user space (below kernel base)\n     IF (uint32_t)buf >= KERNEL_VIRTUAL_BASE:\n       RETURN -1  // EFAULT\n     \n     // Verify buffer is mapped (simplified check)\n     phys = get_physical(current_process->page_directory, (uint32_t)buf)\n     IF phys == 0:\n       RETURN -1  // Invalid pointer\n  \n  3. Write to VGA/serial\n     FOR i = 0 TO count - 1:\n       vga_putchar(buf[i])\n     \n     RETURN count\n\nSYS_EXIT(status):\n  1. Get current process\n     proc = current_process\n  \n  2. Mark as zombie\n     proc->state = PROCESS_ZOMBIE\n     proc->exit_status = status\n  \n  3. Free resources (simplified)\n     IF proc->page_directory != current_page_directory:\n       // User process - free user memory\n       // (Full implementation would walk page tables)\n  \n  4. Remove from run queue\n     scheduler_remove_from_queue(proc)\n  \n  5. Trigger scheduler (never returns)\n     scheduler_yield()\n     // Never reaches here\n\nSYS_GETPID():\n  RETURN current_process->pid\n\nSYS_YIELD():\n  current_process->state = PROCESS_READY\n  scheduler_yield()\n  // Returns when scheduled again\n```\n\n### Enter User Mode\n\n```asm\n; kernel/user/user_mode.asm\n; void enter_user_mode(uint32_t entry, uint32_t stack)\n\nglobal enter_user_mode\n\nsection .text\n\nenter_user_mode:\n    ; Get arguments\n    mov eax, [esp + 4]    ; entry point\n    mov ebx, [esp + 8]    ; user stack top\n    \n    ; Disable interrupts during transition\n    cli\n    \n    ; Load user data segment selectors\n    mov cx, 0x23          ; User data selector (index 4, RPL=3)\n    mov ds, cx\n    mov es, cx\n    mov fs, cx\n    mov gs, cx\n    \n    ; Set up user stack for iret\n    ; Push in reverse order: SS, ESP, EFLAGS, CS, EIP\n    \n    ; Set up stack frame for iret\n    push 0x23             ; SS (user data selector with RPL=3)\n    push ebx              ; ESP (user stack top)\n    pushf                 ; EFLAGS\n    or dword [esp], 0x200 ; Set IF (enable interrupts)\n    push 0x1B             ; CS (user code selector with RPL=3)\n    push eax              ; EIP (entry point)\n    \n    ; iret pops: EIP, CS, EFLAGS, ESP, SS\n    ; This transitions to ring 3\n    iret\n```\n\n---\n\n## Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n|-------|-------------|----------|---------------|\n| Process table full | `process_create` scans all slots | Return NULL | Depends on caller |\n| Kernel stack allocation failure | `alloc_frame` returns NULL | Clean up, return NULL | No |\n| User stack allocation failure | `alloc_frame` returns NULL in loop | Free allocated frames, return NULL | No |\n| Page directory clone failure | `clone_page_directory` returns NULL | Free stacks, return NULL | No |\n| Context switch register corruption | Wrong PCB offsets | Debug with GDB; check assembly matches C | Yes (crash) |\n| TSS.ESP0 not updated | User process traps to kernel | Systematic: update before every switch | Yes (triple fault) |\n| Invalid syscall number | Bounds check in handler | Return -1 (EINVAL) | No |\n| Invalid user pointer | Check address range and mapping | Return -1 (EFAULT) | No |\n| Double-free in scheduler | Process already removed | Debug assertion in remove_from_queue | No |\n| Zombie process remains | exit doesn't clean up | Parent must reap (future: waitpid) | No |\n| Infinite loop in ready queue | All processes blocked | Idle process always runnable | No (hangs) |\n\n---\n\n## State Machine: Process Lifecycle\n\n```\nProcess State Transitions:\n\n                    ┌─────────────────────────────────────┐\n                    │            PROCESS_UNUSED           │\n                    │         (initial state)             │\n                    └──────────────────┬──────────────────┘\n                                       │ process_create()\n                                       ▼\n                    ┌─────────────────────────────────────┐\n        ┌──────────▶│            PROCESS_READY            │◀──────────┐\n        │           │    (runnable, waiting for CPU)      │           │\n        │           └──────────────────┬──────────────────┘           │\n        │                              │ scheduler_pick_next()        │\n        │                              ▼                               │\n        │           ┌─────────────────────────────────────┐           │\n        │           │           PROCESS_RUNNING           │           │\n        │           │       (currently executing)         │           │\n        │           └──────────────────┬──────────────────┘           │\n        │                              │                               │\n        │         ┌────────────────────┼────────────────────┐         │\n        │         │                    │                    │         │\n        │         │ timer/scheduler    │ block()           │ exit()  │\n        │         │ yield()            │ sleep()           │         │\n        │         ▼                    ▼                    ▼         │\n        │  (back to READY)    ┌───────────────┐    ┌──────────────┐  │\n        │                     │PROCESS_BLOCKED│    │PROCESS_ZOMBIE│  │\n        └─────────────────────│ (waiting for  │    │  (terminated)│  │\n                              │   event)      │    └──────────────┘  │\n                              └───────┬───────┘                      │\n                                      │ wake() / event               │\n                                      └──────────────────────────────┘\n                                          (back to READY)\n\nVALID Transitions:\n  UNUSED → READY     : process_create()\n  READY → RUNNING    : scheduler dispatch\n  RUNNING → READY    : time slice expired, yield\n  RUNNING → BLOCKED  : wait for I/O, sleep\n  RUNNING → ZOMBIE   : exit()\n  BLOCKED → READY    : I/O complete, sleep expired\n\nINVALID Transitions:\n  UNUSED → RUNNING   : Must go through READY first\n  READY → ZOMBIE     : Must be RUNNING to exit\n  BLOCKED → RUNNING  : Must go through READY\n  ZOMBIE → *         : Terminal state\n```\n\n---\n\n## Concurrency Specification\n\n### Preemptive Multitasking Model\n\nOnly ONE process executes at any instant. Concurrency is simulated through rapid context switching triggered by:\n1. Timer interrupt (preemptive)\n2. Voluntary yield (cooperative)\n3. Blocking I/O (implicit yield)\n\n### Critical Sections\n\nInterrupts must be disabled during:\n- Process table modification\n- Run queue manipulation  \n- Context switch (partial - can re-enable after CR3 load)\n\n```c\n// Safe queue manipulation\nvoid scheduler_remove_from_queue(process_t *proc) {\n    uint32_t flags;\n    \n    // Disable interrupts\n    asm volatile(\"pushf; pop %0; cli\" : \"=r\"(flags));\n    \n    // ... manipulate queue ...\n    \n    // Restore interrupts\n    asm volatile(\"push %0; popf\" : : \"r\"(flags));\n}\n```\n\n### Interrupt Safety in Handlers\n\n- ISR handlers run with interrupts disabled (interrupt gate)\n- Timer handler calls `scheduler_tick()` which may switch contexts\n- After context switch, interrupts are restored from saved EFLAGS\n- Syscall handler runs with interrupts enabled (trap gate)\n\n### Per-Process Data Protection\n\nEach process has:\n- Independent kernel stack (no shared stack data)\n- Independent page directory (no shared user memory)\n- Shared kernel memory (read-only from user mode)\n\n### Lock-Free Queue Access\n\nThe ready queue is accessed only:\n1. From timer interrupt (interrupt context)\n2. From syscall context (process context, but interrupts may be disabled)\n\nSingle-CPU design means no true concurrent access if interrupts are disabled.\n\n---\n\n## Implementation Sequence with Checkpoints\n\n### Phase 1: PCB Structure Definition (2-3 hours)\n\n**Files**: `kernel/process/process.h`\n\n**Steps**:\n1. Define process_state_t enumeration\n2. Define process_t structure with exact byte offsets\n3. Add comments documenting PCB layout\n4. Define MAX_PROCESSES, stack sizes, etc.\n5. Declare global variables (process_table, current_process, etc.)\n\n**Checkpoint**: PCB structure compiles\n```c\n// Test: verify offsets\n_Static_assert(offsetof(process_t, eax) == 32, \"EAX offset wrong\");\n_Static_assert(offsetof(process_t, eip) == 64, \"EIP offset wrong\");\n_Static_assert(offsetof(process_t, page_directory) == 96, \"PD offset wrong\");\n```\n\n**Test**: Compile and check struct size matches expected\n\n### Phase 2: Process Creation (Kernel Mode) (3-4 hours)\n\n**Files**: `kernel/process/process.c`\n\n**Steps**:\n1. Implement `process_table` array initialization\n2. Implement `process_create()` for kernel processes\n3. Allocate kernel stack from frame allocator\n4. Set up initial register state for kernel mode\n5. Add to ready queue\n\n**Checkpoint**: Can create kernel process\n```c\nvoid test_process(void) {\n    vga_puts(\"Test process running!\\n\");\n    while(1) { asm volatile(\"hlt\"); }\n}\n\n// In kernel_main:\nprocess_t *proc = process_create(\"test\", test_process, 0);\nASSERT(proc != NULL, \"Failed to create process\");\nvga_puts(\"Process created: \"); vga_put_dec(proc->pid); vga_puts(\"\\n\");\n```\n\n**Test**: Create process, verify PCB fields set correctly\n\n### Phase 3: Context Switch Assembly (5-7 hours)\n\n**Files**: `kernel/process/context.asm`\n\n**Steps**:\n1. Define PCB offsets to match C structure\n2. Implement save path (save all registers to old PCB)\n3. Implement CR3 switch logic\n4. Implement TSS.ESP0 update logic\n5. Implement restore path (load all registers from new PCB)\n6. Handle NULL old process (first switch)\n\n**Checkpoint**: Context switch doesn't crash\n```c\n// Test: switch to same process\nprocess_t *proc = &process_table[0];\ncontext_switch(proc, proc);\nvga_puts(\"Context switch returned!\\n\");  // Should print this\n```\n\n**Test**: Create two processes, switch between them manually\n\n### Phase 4: TSS Initialization (3-4 hours)\n\n**Files**: `kernel/process/tss.h`, `kernel/process/tss.c`\n\n**Steps**:\n1. Define tss_t structure matching hardware format\n2. Implement `tss_init()` to zero and configure TSS\n3. Add TSS descriptor to GDT (modify boot/gdt.asm or create function)\n4. Load TR with `ltr` instruction\n5. Implement `tss_set_esp0()` helper\n\n**Checkpoint**: TSS loads without fault\n```c\ntss_init();\nvga_puts(\"TSS initialized\\n\");\nvga_puts(\"TSS.ESP0 = 0x\"); vga_put_hex(tss.esp0); vga_puts(\"\\n\");\n// Read TR to verify\nuint16_t tr;\nasm volatile(\"str %0\" : \"=r\"(tr));\nvga_puts(\"TR = 0x\"); vga_put_hex(tr); vga_puts(\" (expected 0x28)\\n\");\n```\n\n**Test**: Verify TR = 0x28, TSS.ESP0 set correctly\n\n### Phase 5: Round-Robin Scheduler (4-5 hours)\n\n**Files**: `kernel/process/scheduler.h`, `kernel/process/scheduler.c`\n\n**Steps**:\n1. Implement `scheduler_init()` to create idle process\n2. Implement `scheduler_add_to_queue()`\n3. Implement `scheduler_remove_from_queue()`\n4. Implement `scheduler_pick_next()`\n5. Implement `scheduler_yield()` that calls context switch\n6. Implement `schedule()` internal function\n\n**Checkpoint**: Manual scheduling works\n```c\nscheduler_init();\n\n// Create test processes\nprocess_create(\"proc_a\", test_process_a, 0);\nprocess_create(\"proc_b\", test_process_b, 0);\n\n// Manually yield\nscheduler_yield();\n// Should switch to first process\n```\n\n**Test**: Create 3 processes, manually call scheduler_yield(), verify round-robin order\n\n### Phase 6: Timer Interrupt Integration (2-3 hours)\n\n**Files**: Modify `kernel/timer.c`\n\n**Steps**:\n1. Add call to `scheduler_tick()` in timer handler\n2. Enable scheduler after timer configured\n3. Unmask IRQ0 (timer)\n4. Ensure interrupts enabled\n\n**Checkpoint**: Preemptive multitasking works\n```c\n// After timer_init():\ntimer_init(100);  // 100Hz\n\n// Enable scheduler\nscheduler_enabled = 1;\n\n// Create processes\nprocess_create(\"proc_a\", test_process_a, 0);\nprocess_create(\"proc_b\", test_process_b, 0);\nprocess_create(\"proc_c\", test_process_c, 0);\n\n// Enable interrupts and yield\nasm volatile(\"sti\");\nscheduler_yield();\n\n// Scheduler takes over - processes print in round-robin\n```\n\n**Test**: Three kernel processes print to different screen locations, counters increment independently\n\n### Phase 7: Multi-Process Kernel Demo (2-3 hours)\n\n**Files**: `kernel/main.c` or new demo file\n\n**Steps**:\n1. Create three kernel processes with different entry functions\n2. Each process prints to different VGA location\n3. Each has a counter that increments\n4. Verify counters update independently\n\n**Checkpoint**: Visual demo of preemptive multitasking\n```c\nvoid process_a(void) {\n    int count = 0;\n    while (1) {\n        vga_set_cursor(0, 0);\n        vga_puts(\"[A] Count: \"); vga_put_dec(count++);\n        for (volatile int i = 0; i < 500000; i++);  // Delay\n    }\n}\n\n// Similar for process_b and process_c\n\n// Expected: Three counters incrementing simultaneously on screen\n```\n\n**Test**: Run for 10 seconds, verify all three counters increased\n\n### Phase 8: User-Mode Process Creation (4-5 hours)\n\n**Files**: `kernel/process/process.c` (modify), `kernel/memory/paging.c` (add clone function)\n\n**Steps**:\n1. Implement `clone_page_directory()` to copy kernel mappings\n2. Allocate user stack in user virtual address space\n3. Map user stack pages with PTE_USER flag\n4. Set user segment selectors (CS=0x1B, DS=0x23)\n5. Copy user code to user address space (simplified: just mark pages)\n\n**Checkpoint**: User process PCB created\n```c\nextern void user_test_function(void);  // Simple test function\n\nprocess_t *user_proc = process_create(\"user_test\", user_test_function, 1);\nASSERT(user_proc != NULL, \"Failed to create user process\");\nASSERT(user_proc->cs == 0x1B, \"Wrong CS for user process\");\nASSERT(user_proc->page_directory != current_page_directory, \"User should have own PD\");\n```\n\n**Test**: Create user process, verify CS=0x1B, own page directory, user stack allocated\n\n### Phase 9: Enter User Mode via iret (2-3 hours)\n\n**Files**: `kernel/user/user_mode.asm`\n\n**Steps**:\n1. Implement `enter_user_mode()` assembly function\n2. Load segment registers with user selectors\n3. Build iret frame on stack\n4. Execute iret to transition to ring 3\n5. Verify CPL=3 after transition\n\n**Checkpoint**: Successfully enter user mode\n```c\n// After creating user process:\nvoid enter_user_process(void) {\n    process_t *proc = process_create(\"user\", user_entry, 1);\n    \n    // Enter user mode\n    enter_user_mode(proc->eip, proc->esp);\n    \n    // Never reaches here\n}\n\n// In user mode code:\nvoid user_entry(void) {\n    // This runs at ring 3!\n    // Attempt to write to VGA directly - should fault\n    // char *vga = (char*)0xB8000;\n    // *vga = 'X';  // Page fault if VGA not mapped user-accessible\n    \n    // Use syscall instead\n    sys_write(1, \"Hello from user mode!\\n\", 23);\n    sys_exit(0);\n}\n```\n\n**Test**: User process prints message via syscall, then exits cleanly\n\n### Phase 10: System Call Interface (4-5 hours)\n\n**Files**: `kernel/syscall/syscall.h`, `kernel/syscall/syscall.c`, `kernel/syscall/syscall.asm`\n\n**Steps**:\n1. Define syscall numbers and handler table\n2. Create ISR stub for INT 0x80\n3. Register IDT gate with DPL=3 (user callable)\n4. Implement syscall dispatcher\n5. Implement syscall parameter extraction from registers\n\n**Checkpoint**: Syscall from kernel mode works\n```c\n// Test syscall from kernel (ring 0)\nint result = sys_write(1, \"Test\\n\", 5);\nvga_put_dec(result);  // Should print 5\n\n// Register syscall handler\nidt_set_gate(0x80, (uint32_t)isr128, 0x08, 0xEE);  // DPL=3\n```\n\n**Test**: Call INT 0x80 from kernel, verify handler runs and returns\n\n### Phase 11: sys_write and sys_exit (2-3 hours)\n\n**Files**: `kernel/syscall/syscall.c`\n\n**Steps**:\n1. Implement `sys_write()` with pointer validation\n2. Implement `sys_exit()` to terminate process\n3. Implement `sys_getpid()` as trivial syscall\n4. Add user-space wrapper functions (optional)\n\n**Checkpoint**: User process uses syscalls\n```c\n// User mode code\nvoid _start(void) {\n    const char *msg = \"Hello from user mode!\\n\";\n    asm volatile(\n        \"int $0x80\"\n        : \n        : \"a\"(SYS_WRITE), \"b\"(1), \"c\"(msg), \"d\"(23)\n    );\n    \n    asm volatile(\n        \"int $0x80\"\n        : \n        : \"a\"(SYS_EXIT), \"b\"(0)\n    );\n}\n\n// Expected: \"Hello from user mode!\" printed, process exits\n```\n\n**Test**: User process prints message and exits without crashing\n\n### Final Integration (3-4 hours)\n\n**Goal**: Complete preemptive multitasking with user-mode processes and syscalls\n\n**Steps**:\n1. Integrate all components in `kernel_main()`\n2. Initialize in correct order:\n   - Memory (paging, heap)\n   - Interrupts (IDT, PIC, timer)\n   - TSS\n   - Scheduler\n   - Syscalls\n3. Create kernel demo processes\n4. Create user demo process\n5. Enable interrupts and start scheduler\n\n**Checkpoint**: Full system runs\n```c\nvoid kernel_main(multiboot_info_t *mbi) {\n    // Core initialization\n    vga_init();\n    serial_init(COM1_PORT);\n    \n    kprintf(\"Initializing memory...\\n\");\n    memory_init(mbi);\n    \n    kprintf(\"Initializing interrupts...\\n\");\n    idt_init();\n    pic_remap(32, 40);\n    timer_init(100);\n    keyboard_init();\n    \n    kprintf(\"Initializing TSS...\\n\");\n    tss_init();\n    \n    kprintf(\"Initializing scheduler...\\n\");\n    scheduler_init();\n    \n    kprintf(\"Initializing syscalls...\\n\");\n    syscall_init();\n    \n    kprintf(\"Creating processes...\\n\");\n    process_create(\"kernel_a\", kernel_process_a, 0);\n    process_create(\"kernel_b\", kernel_process_b, 0);\n    process_create(\"user_test\", user_process_entry, 1);\n    \n    kprintf(\"Starting scheduler...\\n\");\n    scheduler_enabled = 1;\n    pic_unmask_irq(0);  // Timer\n    pic_unmask_irq(1);  // Keyboard\n    asm volatile(\"sti\");\n    \n    scheduler_yield();\n    \n    // Never reaches here\n}\n```\n\n**Test Commands**:\n```bash\nmake clean && make\nqemu-system-i386 -drive format=raw,file=os.img -serial stdio\n\n# Expected:\n# - Boot messages\n# - \"Starting scheduler...\"\n# - Three processes running (two kernel, one user)\n# - User process prints via syscall\n# - Counters incrementing\n# - No crashes, hangs, or triple faults\n```\n\n---\n\n## Test Specification\n\n### Test 1: PCB Structure Layout\n\n```c\n// test_pcb_layout.c\nvoid test_pcb_layout(void) {\n    // Verify offsets match assembly expectations\n    ASSERT(offsetof(process_t, pid) == 0, \"PID offset\");\n    ASSERT(offsetof(process_t, eax) == 32, \"EAX offset\");\n    ASSERT(offsetof(process_t, eip) == 64, \"EIP offset\");\n    ASSERT(offsetof(process_t, eflags) == 68, \"EFLAGS offset\");\n    ASSERT(offsetof(process_t, cs) == 72, \"CS offset\");\n    ASSERT(offsetof(process_t, page_directory) == 96, \"PD offset\");\n    ASSERT(offsetof(process_t, kernel_stack) == 100, \"KSTACK offset\");\n    \n    // Verify size\n    ASSERT(sizeof(process_t) == 140, \"PCB size\");\n    \n    vga_puts(\"PASS: PCB layout\\n\");\n}\n```\n\n### Test 2: Process Creation\n\n```c\n// test_process_create.c\nvoid test_process_create(void) {\n    uint32_t free_before = frame_alloc.free_frames;\n    \n    process_t *proc = process_create(\"test\", test_func, 0);\n    \n    ASSERT(proc != NULL, \"Process creation failed\");\n    ASSERT(proc->pid == 1, \"PID assignment\");\n    ASSERT(proc->state == PROCESS_READY, \"Initial state\");\n    ASSERT(proc->cs == 0x08, \"Kernel CS\");\n    ASSERT(proc->kernel_stack != 0, \"Kernel stack allocated\");\n    \n    // Verify frame was allocated\n    ASSERT(frame_alloc.free_frames == free_before - 1, \"Frame used\");\n    \n    // Verify in ready queue\n    ASSERT(ready_queue == proc, \"Added to queue\");\n    \n    vga_puts(\"PASS: Process creation\\n\");\n}\n```\n\n### Test 3: Context Switch\n\n```c\n// test_context_switch.c\nvolatile int proc_a_ran = 0;\nvolatile int proc_b_ran = 0;\n\nvoid proc_a(void) {\n    proc_a_ran = 1;\n    scheduler_yield();  // Switch to proc_b\n    proc_a_ran = 2;\n}\n\nvoid proc_b(void) {\n    proc_b_ran = 1;\n    scheduler_yield();  // Switch back to proc_a\n    proc_b_ran = 2;\n}\n\nvoid test_context_switch(void) {\n    process_t *a = process_create(\"a\", proc_a, 0);\n    process_t *b = process_create(\"b\", proc_b, 0);\n    \n    // Disable timer for controlled test\n    scheduler_enabled = 0;\n    \n    // Manually switch to process a\n    current_process = a;\n    a->state = PROCESS_RUNNING;\n    context_switch(&process_table[0], a);  // From kernel to proc_a\n    \n    // After both yield, check values\n    ASSERT(proc_a_ran == 2, \"Proc A completed\");\n    ASSERT(proc_b_ran == 2, \"Proc B completed\");\n    \n    vga_puts(\"PASS: Context switch\\n\");\n}\n```\n\n### Test 4: TSS Configuration\n\n```c\n// test_tss.c\nvoid test_tss(void) {\n    tss_init();\n    \n    // Verify TSS.ESP0 and SS0\n    ASSERT(tss.ss0 == 0x10, \"TSS.SS0\");\n    ASSERT(tss.esp0 != 0, \"TSS.ESP0 set\");\n    \n    // Verify TR loaded\n    uint16_t tr;\n    asm volatile(\"str %0\" : \"=r\"(tr));\n    ASSERT(tr == 0x28, \"TR value\");\n    \n    // Test ESP0 update\n    tss_set_esp0(0x12345678);\n    ASSERT(tss.esp0 == 0x12345678, \"ESP0 update\");\n    \n    vga_puts(\"PASS: TSS configuration\\n\");\n}\n```\n\n### Test 5: Scheduler Round-Robin\n\n```c\n// test_scheduler.c\nvolatile int order[10];\nvolatile int order_idx = 0;\n\nvoid sched_a(void) { order[order_idx++] = 'A'; while(1) scheduler_yield(); }\nvoid sched_b(void) { order[order_idx++] = 'B'; while(1) scheduler_yield(); }\nvoid sched_c(void) { order[order_idx++] = 'C'; while(1) scheduler_yield(); }\n\nvoid test_scheduler(void) {\n    process_create(\"a\", sched_a, 0);\n    process_create(\"b\", sched_b, 0);\n    process_create(\"c\", sched_c, 0);\n    \n    // Run for 9 yields (3 full rounds)\n    for (int i = 0; i < 9; i++) {\n        scheduler_tick();  // Simulate timer\n    }\n    \n    // Verify round-robin order: A, B, C, A, B, C, A, B, C\n    ASSERT(order[0] == 'A', \"Order 0\");\n    ASSERT(order[1] == 'B', \"Order 1\");\n    ASSERT(order[2] == 'C', \"Order 2\");\n    ASSERT(order[3] == 'A', \"Order 3\");\n    ASSERT(order[4] == 'B', \"Order 4\");\n    ASSERT(order[5] == 'C', \"Order 5\");\n    \n    vga_puts(\"PASS: Scheduler round-robin\\n\");\n}\n```\n\n### Test 6: User Mode Entry\n\n```c\n// test_user_mode.c\nvolatile int user_mode_entered = 0;\n\nvoid user_entry(void) {\n    // Check CPL\n    uint16_t cs;\n    asm volatile(\"mov %%cs, %0\" : \"=r\"(cs));\n    \n    // CS should be 0x1B or 0x1F (user code, RPL=3)\n    user_mode_entered = (cs & 3) == 3 ? 1 : -1;\n    \n    sys_exit(0);\n}\n\nvoid test_user_mode(void) {\n    process_t *proc = process_create(\"user\", user_entry, 1);\n    \n    // Set up TSS.ESP0\n    tss_set_esp0(proc->kernel_stack);\n    \n    // Enter user mode\n    enter_user_mode(proc->eip, proc->esp);\n    \n    // Should not return, but if it does:\n    ASSERT(user_mode_entered == 1, \"User mode entered\");\n    \n    vga_puts(\"PASS: User mode entry\\n\");\n}\n```\n\n### Test 7: Syscall Dispatch\n\n```c\n// test_syscall.c\nvoid test_syscall(void) {\n    syscall_init();\n    \n    // Test sys_write from kernel\n    int result = sys_write(1, \"test\\n\", 5);\n    ASSERT(result == 5, \"sys_write return\");\n    \n    // Test sys_getpid\n    int pid = sys_getpid();\n    ASSERT(pid == current_process->pid, \"sys_getpid\");\n    \n    // Test invalid syscall\n    result = -1;\n    asm volatile(\"int $0x80\" : \"=a\"(result) : \"a\"(999));\n    ASSERT(result == -1, \"Invalid syscall\");\n    \n    vga_puts(\"PASS: Syscall dispatch\\n\");\n}\n```\n\n### Test 8: User Process Isolation\n\n```c\n// test_user_isolation.c\nvoid user_try_kernel_access(void) {\n    // Attempt to read kernel memory - should fault\n    volatile uint32_t *kernel_addr = (uint32_t*)0xC0100000;\n    uint32_t val = *kernel_addr;  // Should page fault\n    \n    // Should never reach here\n    sys_write(1, \"FAIL: accessed kernel\\n\", 22);\n    sys_exit(1);\n}\n\nvoid test_user_isolation(void) {\n    process_t *proc = process_create(\"isolation_test\", user_try_kernel_access, 1);\n    \n    // Run process - expect page fault\n    // (This test requires page fault handler to catch and report)\n    \n    vga_puts(\"PASS: User isolation (page fault expected)\\n\");\n}\n```\n\n### Test 9: Multi-Process Demo\n\n```bash\n# test_multi_process.sh\ntimeout 10 qemu-system-i386 -drive format=raw,file=os.img \\\n    -serial stdio -display none 2>&1 | tee demo_log.txt\n\n# Check that all three processes ran\nif grep -q \"Process A\" demo_log.txt && \\\n   grep -q \"Process B\" demo_log.txt && \\\n   grep -q \"Process C\" demo_log.txt; then\n    echo \"PASS: All processes ran\"\nelse\n    echo \"FAIL: Not all processes ran\"\n    exit 1\nfi\n\n# Check that processes ran multiple times (preemption working)\ncount_a=$(grep -c \"Process A\" demo_log.txt || echo \"0\")\nif [ \"$count_a\" -gt 5 ]; then\n    echo \"PASS: Preemption working ($count_a iterations of A)\"\nelse\n    echo \"FAIL: Preemption not working\"\n    exit 1\nfi\n```\n\n---\n\n## Performance Targets\n\n| Operation | Target | How to Measure |\n|-----------|--------|----------------|\n| Context switch (same PD) | < 500 cycles | Time from `context_switch` call to return in new process |\n| Context switch (different PD) | < 5000 cycles | Includes TLB refill cost |\n| PCB allocation | < 100 cycles | Scan process table for free slot |\n| Kernel stack allocation | < 500 cycles | Single frame allocation |\n| User process creation | < 10,000 cycles | Includes PD clone, stack allocation |\n| Scheduler tick | < 200 cycles | Timer handler overhead |\n| Syscall dispatch | < 100 cycles | From `int 0x80` to handler entry |\n| sys_write (1 char) | < 500 cycles | Argument validation + VGA output |\n| User-kernel transition | < 200 cycles | int 0x80 + return to user |\n| Timer interrupt overhead | < 1% of CPU | 100Hz timer, handler ~200 cycles = 0.002% |\n\n---\n\n## Hardware Soul\n\n### Cache Lines Touched\n\n**Context switch**:\n- PCB read: 140 bytes = 3 cache lines (all registers + metadata)\n- PCB write: Same 3 cache lines\n- Page directory access: 1 cache line for CR3 read\n- TSS update: 4 bytes (ESP0) - likely in same cache line as other TSS fields\n- Total: ~5-7 cache line touches per switch\n\n**Scheduler**:\n- Run queue traversal: 2 pointers per process checked\n- If 10 processes in queue: ~20 pointer reads, 1-2 cache lines\n\n**Syscall**:\n- IDT entry read: 8 bytes, 1 cache line shared with nearby entries\n- Syscall table lookup: 1 pointer read\n- Handler code: Variable (should stay in cache for common syscalls)\n\n### Branch Prediction\n\n**Round-robin scheduler**: Highly predictable - always picks next in queue. Branch predictor learns pattern quickly.\n\n**Syscall dispatch**: Table lookup - no branching. Unpredictable only if syscall numbers random (unlikely).\n\n**Context switch**: No branches in core switch path (just comparisons for CR3, TSS update).\n\n### TLB Behavior\n\n**CR3 reload flushes TLB**:\n- 64-128 entries lost\n- Each miss = 2-4 memory accesses (PD walk + PT walk)\n- Kernel code hot path: ~10 TLB entries for common functions\n- Recovery time: 100-500 cycles depending on working set\n\n**User-kernel transitions**:\n- Kernel pages marked global (PTE_GLOBAL) to survive CR3 reload\n- Or kernel mapped in all page directories (this implementation)\n- No TLB flush for kernel-only switches if PCID used (not in this impl)\n\n### Pipeline Impact\n\n**iret for user mode entry**:\n- Serializing instruction - full pipeline flush\n- Cost: 20-50 cycles\n- Required for privilege level change\n\n**int 0x80 for syscalls**:\n- Interrupt gate entry flushes pipeline\n- Similar cost to iret\n- Could optimize with sysenter/sysexit (not implemented)\n\n### Cache Pollution\n\n**Process working set**:\n- Each process has own working set\n- Context switch evicts previous process's cache lines\n- L1D typically 32KB: holds ~800 cache lines\n- If process accesses more than 800 lines, thrashing occurs\n\n---\n\n## Visual Diagrams\n\n### PCB Structure\n\n```\nProcess Control Block (140 bytes):\n\n┌─────────────────────────────────────────────────────────────────────┐\n│ Offset 0: Identification                                            │\n├─────────────────────────────────────────────────────────────────────┤\n│  +0   │ pid (4)        │ Process ID                                 │\n│  +4   │ name[16]       │ Process name (null-terminated)            │\n│  +20  │ state (4)      │ READY/RUNNING/BLOCKED/ZOMBIE              │\n│  +24  │ padding (8)    │ Reserved for alignment                    │\n└─────────────────────────────────────────────────────────────────────┘\n┌─────────────────────────────────────────────────────────────────────┐\n│ Offset 32: Register State (SAVED/RESTORED BY CONTEXT SWITCH)        │\n├─────────────────────────────────────────────────────────────────────┤\n│  +32  │ eax            │ General purpose                           │\n│  +36  │ ebx            │                                           │\n│  +40  │ ecx            │                                           │\n│  +44  │ edx            │                                           │\n│  +48  │ esi            │ Source index                              │\n│  +52  │ edi            │ Destination index                         │\n│  +56  │ ebp            │ Base pointer                              │\n│  +60  │ esp            │ Stack pointer                             │\n│  +64  │ eip            │ Instruction pointer                       │\n│  +68  │ eflags         │ CPU flags                                 │\n│  +72  │ cs             │ Code segment selector                     │\n│  +76  │ ds             │ Data segment selector                     │\n│  +80  │ es             │ Extra segment                             │\n│  +84  │ fs             │ Extra segment                             │\n│  +88  │ gs             │ Extra segment                             │\n│  +92  │ ss             │ Stack segment selector                    │\n└─────────────────────────────────────────────────────────────────────┘\n┌─────────────────────────────────────────────────────────────────────┐\n│ Offset 96: Memory Management                                        │\n├─────────────────────────────────────────────────────────────────────┤\n│  +96  │ page_directory │ Page directory pointer (virtual addr)     │\n│  +100 │ kernel_stack   │ Top of kernel stack (for TSS.ESP0)        │\n│  +104 │ user_stack_top │ User mode stack top                       │\n└─────────────────────────────────────────────────────────────────────┘\n┌─────────────────────────────────────────────────────────────────────┐\n│ Offset 108: Scheduling                                              │\n├─────────────────────────────────────────────────────────────────────┤\n│  +108 │ next           │ Next process in queue                     │\n│  +112 │ prev           │ Previous process in queue                 │\n│  +116 │ wake_time      │ Tick count to wake (for sleep)            │\n│  +120 │ exit_status    │ Exit code                                 │\n│  +124 │ time_slice     │ Remaining quantum                         │\n└─────────────────────────────────────────────────────────────────────┘\n┌─────────────────────────────────────────────────────────────────────┐\n│ Offset 128: Process Tree (Future)                                   │\n├─────────────────────────────────────────────────────────────────────┤\n│  +128 │ parent         │ Parent process                            │\n│  +132 │ first_child    │ First child process                       │\n│  +136 │ next_sibling   │ Next sibling                              │\n└─────────────────────────────────────────────────────────────────────┘\n\nAssembly Offset Verification:\n  %define PCB_EAX     32    ; Must match C offsetof(process_t, eax)\n  %define PCB_EIP     64    ; Must match C offsetof(process_t, eip)\n  %define PCB_CS      72    ; Must match C offsetof(process_t, cs)\n  %define PCB_KSTACK  100   ; Must match C offsetof(process_t, kernel_stack)\n```\n\n### Context Switch Flow\n\n```\nContext Switch Operation:\n\n┌─────────────────────────────────────────────────────────────────────┐\n│                         BEFORE SWITCH                               │\n│                                                                     │\n│   Process A (running)                                               │\n│   ┌─────────────────┐                                               │\n│   │ EAX = 0x11111111│                                               │\n│   │ EBX = 0x22222222│                                               │\n│   │ EIP = 0x00100234│  ──┐                                          │\n│   │ ESP = 0x00090000│    │                                          │\n│   │ ...             │    │                                          │\n│   └─────────────────┘    │                                          │\n│                          │                                          │\n│   PCB_A (in memory)      │                                          │\n│   ┌─────────────────┐    │                                          │\n│   │ eax = ?         │ ◀──┘  Will be saved here                      │\n│   │ eip = ?         │                                               │\n│   │ ...             │                                               │\n│   └─────────────────┘                                               │\n└─────────────────────────────────────────────────────────────────────┘\n                              │\n                              │ context_switch(PCB_A, PCB_B)\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────────────┐\n│                         DURING SWITCH                               │\n│                                                                     │\n│   1. Save current state to PCB_A                                    │\n│      PCB_A.eax ← EAX (0x11111111)                                  │\n│      PCB_A.ebx ← EBX                                               │\n│      PCB_A.eip ← return_address                                    │\n│      ...                                                            │\n│                                                                     │\n│   2. Update TSS.ESP0 if switching to user process                   │\n│      TSS.ESP0 ← PCB_B.kernel_stack                                 │\n│                                                                     │\n│   3. Switch page directory if different                             │\n│      CR3 ← PCB_B.page_directory                                    │\n│      (TLB flushed automatically)                                    │\n│                                                                     │\n│   4. Update current_process                                         │\n│      current_process ← PCB_B                                       │\n│                                                                     │\n│   5. Load new state from PCB_B                                      │\n│      EAX ← PCB_B.eax                                               │\n│      EBX ← PCB_B.ebx                                               │\n│      EIP ← PCB_B.eip                                               │\n│      ...                                                            │\n└─────────────────────────────────────────────────────────────────────┘\n                              │\n                              │ jmp to PCB_B.eip\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────────────┐\n│                         AFTER SWITCH                                │\n│                                                                     │\n│   Process B (now running)                                           │\n│   ┌─────────────────┐                                               │\n│   │ EAX = 0xAAAAAAAA│  ◀── Loaded from PCB_B                       │\n│   │ EBX = 0xBBBBBBBB│                                               │\n│   │ EIP = 0x00100567│                                               │\n│   │ ESP = 0x000A0000│                                               │\n│   │ ...             │                                               │\n│   └─────────────────┘                                               │\n│                                                                     │\n│   Process A (suspended)                                             │\n│   ┌─────────────────┐                                               │\n│   │ State saved in  │                                               │\n│   │ PCB_A           │  ──▶ Will resume when scheduled again        │\n│   └─────────────────┘                                               │\n└─────────────────────────────────────────────────────────────────────┘\n\nCritical Invariants:\n  • ALL registers saved (EAX-EDX, ESI, EDI, EBP, ESP, EIP, EFLAGS)\n  • ALL segment registers saved (CS, DS, ES, FS, GS, SS)\n  • TSS.ESP0 updated BEFORE switching to user process\n  • CR3 reloaded if page directories differ\n  • Stack valid at all times\n```\n\n### TSS Structure\n\n```\nTask State Segment (104 bytes):\n\n┌─────────────────────────────────────────────────────────────────────┐\n│ Offset  Field        Value            Purpose                      │\n├─────────────────────────────────────────────────────────────────────┤\n│  0      prev_task    0x0000           Previous task link (unused)  │\n│  4      esp0         0x90000          ★ RING 0 STACK POINTER ★     │\n│  8      ss0          0x0010           ★ RING 0 STACK SEGMENT ★     │\n│  12     esp1         0                Ring 1 stack (unused)        │\n│  16     ss1          0                Ring 1 segment (unused)      │\n│  20     esp2         0                Ring 2 stack (unused)        │\n│  24     ss2          0                Ring 2 segment (unused)      │\n│  28     cr3          0                Page directory (unused)      │\n│  32-68  eax-edi      0                General regs (unused)        │\n│  72-92  es-gs        0                Segments (unused)            │\n│  96     ldt          0                LDT selector (unused)        │\n│  100    trap         0                Trap flag (unused)           │\n│  102    iomap_base   104              I/O bitmap offset (none)     │\n└─────────────────────────────────────────────────────────────────────┘\n\nCRITICAL USAGE:\n  When interrupt/syscall occurs in user mode (ring 3):\n  1. CPU reads TSS.SS0 and TSS.ESP0\n  2. CPU switches to kernel stack: SS:ESP = SS0:ESP0\n  3. CPU pushes user SS, ESP, EFLAGS, CS, EIP onto kernel stack\n  4. CPU loads CS:EIP from IDT entry\n  5. Handler runs on kernel stack at ring 0\n\nTSS.ESP0 MUST be updated:\n  • Before context switch to ANY user-mode process\n  • Value = top of that process's kernel stack\n  • Each process has its own kernel stack (4KB)\n```\n\n### Ring Transition (User to Kernel)\n\n```\nRing 3 → Ring 0 Transition (on interrupt/syscall):\n\nBEFORE (User Mode):\n┌─────────────────────────────────────────────────────────────────────┐\n│  User Process at Ring 3                                             │\n│                                                                     │\n│  CPU State:                                                         │\n│    CS:EIP = 0x1B:0x00100400 (user code)                            │\n│    SS:ESP = 0x23:0xBFFFF000 (user stack)                           │\n│    CPL = 3 (Current Privilege Level)                               │\n│                                                                     │\n│  User Stack:                          Kernel Stack:                 │\n│  ┌──────────────┐                     ┌──────────────┐             │\n│  │ local vars   │                     │    empty     │             │\n│  │ return addr  │                     │              │             │\n│  │ parameters   │                     │              │             │\n│  │ ...          │                     │              │             │\n│  └──────────────┘ ← ESP               └──────────────┘             │\n│   0xBFFFF000                                   ?                    │\n│                                                                     │\n│  TSS.ESP0 = 0x00090000 (kernel stack for this process)             │\n│  TSS.SS0  = 0x0010 (kernel data segment)                           │\n└─────────────────────────────────────────────────────────────────────┘\n                              │\n                              │ User executes: int 0x80\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────────────┐\n│  CPU Hardware Actions:                                              │\n│                                                                     │\n│  1. Read IDT[0x80] → Get handler CS:EIP                            │\n│  2. Check privilege: IDT DPL (3) >= CPL (3) ✓                      │\n│  3. Detect ring transition: IDT CS DPL (0) < CPL (3)               │\n│  4. Read TSS.SS0:ESP0 = 0x0010:0x00090000                          │\n│  5. Switch to kernel stack                                          │\n│  6. Push onto kernel stack:                                         │\n│     ┌──────────────┐                                                │\n│     │ SS (user)    │ 0x23                                          │\n│     │ ESP (user)   │ 0xBFFFF000                                    │\n│     │ EFLAGS       │ 0x00000202                                    │\n│     │ CS (user)    │ 0x1B                                          │\n│     │ EIP (user)   │ 0x00100402 (after int instruction)            │\n│     └──────────────┘ ← ESP (now 0x00090000)                        │\n│  7. Load CS:EIP from IDT                                            │\n│  8. Clear CPL to 0                                                  │\n└─────────────────────────────────────────────────────────────────────┘\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────────────┐\n│ AFTER (Kernel Mode):                                                │\n│                                                                     │\n│  CPU State:                                                         │\n│    CS:EIP = 0x08:syscall_handler (kernel code)                     │\n│    SS:ESP = 0x10:0x0008FFE0 (kernel stack)  ← ESP decremented      │\n│    CPL = 0 (Current Privilege Level)                               │\n│                                                                     │\n│  Kernel Stack:                                                      │\n│  ┌──────────────┐                                                   │\n│  │ SS (user)    │ 0x23    ← Pushed by CPU                          │\n│  │ ESP (user)   │ 0xBFFFF000                                       │\n│  │ EFLAGS       │ 0x00000202                                       │\n│  │ CS (user)    │ 0x1B                                             │\n│  │ EIP (user)   │ 0x00100402                                       │\n│  └──────────────┴──────────────────────────────────┐               │\n│  │ (handler's local vars, saved regs, etc.)        │               │\n│  └─────────────────────────────────────────────────┘ ← ESP         │\n│   0x0008FF00                                                       │\n│                                                                     │\n│  User Stack: (unchanged)                                           │\n│  ┌──────────────┐                                                   │\n│  │ local vars   │                                                   │\n│  │ ...          │                                                   │\n│  └──────────────┘                                                   │\n│   0xBFFFF000                                                       │\n└─────────────────────────────────────────────────────────────────────┘\n                              │\n                              │ Handler executes, then iret\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────────────┐\n│ iret (Return to User Mode):                                         │\n│                                                                     │\n│  1. Pop EIP, CS, EFLAGS, ESP, SS from kernel stack                 │\n│  2. Restore SS:ESP = 0x23:0xBFFFF000                               │\n│  3. Restore CS:EIP = 0x1B:0x00100402                               │\n│  4. Restore EFLAGS                                                  │\n│  5. Set CPL = 3                                                     │\n│  6. Resume user code                                                │\n└─────────────────────────────────────────────────────────────────────┘\n\nWITHOUT TSS.SS0:ESP0 → TRIPLE FAULT!\n  The CPU has nowhere to put the kernel stack.\n  Always update TSS.ESP0 before switching to user process.\n```\n\n### Scheduler Queue\n\n```\nRound-Robin Run Queue:\n\n┌─────────────────────────────────────────────────────────────────────┐\n│                         RUN QUEUE                                   │\n│                                                                     │\n│   ready_queue ──┐                                                   │\n│                 │                                                   │\n│                 ▼                                                   │\n│   ┌─────────────┐     ┌─────────────┐     ┌─────────────┐          │\n│   │   PCB A     │────▶│   PCB B     │────▶│   PCB C     │──▶ NULL  │\n│   │   READY     │     │   READY     │     │   READY     │          │\n│   │   pid=1     │◀────│   pid=2     │◀────│   pid=3     │          │\n│   └─────────────┘     └─────────────┘     └─────────────┘          │\n│                                                                     │\n│   current_process = PCB A (running)                                │\n│                                                                     │\n└─────────────────────────────────────────────────────────────────────┘\n\nTimer Tick (quantum expired):\n\n┌─────────────────────────────────────────────────────────────────────┐\n│ Step 1: Move current to end                                         │\n│                                                                     │\n│   ┌─────────────┐     ┌─────────────┐     ┌─────────────┐          │\n│   │   PCB B     │────▶│   PCB C     │────▶│   PCB A     │──▶ NULL  │\n│   │   READY     │     │   READY     │     │   READY     │          │\n│   │   pid=2     │◀────│   pid=3     │◀────│   pid=1     │          │\n│   └─────────────┘     └─────────────┘     └─────────────┘          │\n│         ▲                                           │               │\n│         │                                           │               │\n│   ready_queue ◀─────────────────────────────────────┘               │\n│                                                                     │\n│ Step 2: Pick next                                                   │\n│                                                                     │\n│   next = ready_queue = PCB B                                       │\n│   switch from PCB A to PCB B                                       │\n│                                                                     │\n│ Step 3: After switch                                                │\n│                                                                     │\n│   current_process = PCB B                                          │\n│   PCB B state = RUNNING                                            │\n│   PCB A state = READY                                              │\n│                                                                     │\n└─────────────────────────────────────────────────────────────────────┘\n\nBlocking (e.g., waiting for I/O):\n\n┌─────────────────────────────────────────────────────────────────────┐\n│ Process B calls sys_read() which blocks:                            │\n│                                                                     │\n│   PCB B state = BLOCKED                                            │\n│   Remove PCB B from queue                                          │\n│                                                                     │\n│   ready_queue ──▶ PCB C ──▶ PCB A ──▶ NULL                        │\n│                                                                     │\n│   current_process = PCB C (next ready)                             │\n│                                                                     │\n│ Later, when I/O completes:                                          │\n│                                                                     │\n│   PCB B state = READY                                              │\n│   Add PCB B to end of queue                                        │\n│                                                                     │\n│   ready_queue ──▶ PCB C ──▶ PCB A ──▶ PCB B ──▶ NULL              │\n│                                                                     │\n└─────────────────────────────────────────────────────────────────────┘\n\nPriority Queue (NOT IMPLEMENTED - future enhancement):\n┌─────────────────────────────────────────────────────────────────────┐\n│   Multiple queues by priority:                                      │\n│   priority[0] ──▶ [high priority tasks]                            │\n│   priority[1] ──▶ [normal tasks]                                   │\n│   priority[2] ──▶ [low priority tasks]                             │\n│                                                                     │\n│   Always pick from highest non-empty queue                          │\n│   Time slice varies by priority                                     │\n└─────────────────────────────────────────────────────────────────────┘\n```\n\n### Multi-Process Demo\n\n```\nThree Kernel Processes Demo:\n\n┌─────────────────────────────────────────────────────────────────────┐\n│                         VGA Screen                                  │\n│                                                                     │\n│  Row 0:  ┌──────────────────────────────────────────────────────┐  │\n│          │ [Process A] Count: 42                                 │  │\n│          └──────────────────────────────────────────────────────┘  │\n│                                                                     │\n│  Row 5:  ┌──────────────────────────────────────────────────────┐  │\n│          │ [Process B] Count: 38                                 │  │\n│          └──────────────────────────────────────────────────────┘  │\n│                                                                     │\n│  Row 10: ┌──────────────────────────────────────────────────────┐  │\n│          │ [Process C] Count: 45                                 │  │\n│          └──────────────────────────────────────────────────────┘  │\n│                                                                     │\n│  ... rest of screen ...                                            │\n│                                                                     │\n└─────────────────────────────────────────────────────────────────────┘\n\nExecution Timeline (100Hz timer, 10 tick quantum):\n\nTime    Running Process    Action\n────────────────────────────────────────────────────────────────────\n0ms     A                  Increments counter to 1\n1ms     A                  Increments to 2\n...\n100ms   A (quantum done)   Switch to B\n100ms   B                  Increments counter to 1\n101ms   B                  Increments to 2\n...\n200ms   B (quantum done)   Switch to C\n200ms   C                  Increments counter to 1\n...\n300ms   C (quantum done)   Switch to A\n300ms   A                  Increments counter to 11 (resumed)\n...\n\nEach process sees:\n  - Its counter incrementing\n  - No awareness of other processes\n  - No awareness of being suspended/resumed\n\nKey Observations:\n  • All three counters increment \"simultaneously\" (from user perspective)\n  • Only ONE process actually executes at any instant\n  • Switch overhead is imperceptible (~500 cycles = ~0.5µs at 1GHz)\n  • Each process has independent EIP, ESP, registers\n```\n\n### User-Kernel Memory Layout\n\n```\nAddress Space Layout:\n\n┌─────────────────────────────────────────────────────────────────────┐\n│                         KERNEL SPACE (1GB)                          │\n│                    0xC0000000 - 0xFFFFFFFF                         │\n│                                                                     │\n│  0xFFFFFFFF ┌──────────────────────────────────────┐               │\n│             │                                      │               │\n│             │   Reserved / Device MMIO             │               │\n│             │                                      │               │\n│  0xC0800000 ├──────────────────────────────────────┤               │\n│             │   Kernel Heap End                    │               │\n│             │   (expandable)                       │               │\n│  0xC0400000 ├──────────────────────────────────────┤               │\n│             │   Kernel Heap (kmalloc)              │               │\n│             │   PTE_USER = 0 (supervisor only)    │               │\n│  0xC0100000 ├──────────────────────────────────────┤               │\n│             │   Kernel Code + Data                 │               │\n│             │   .text, .rodata, .data, .bss        │               │\n│             │   PTE_USER = 0 (supervisor only)    │               │\n│  0xC0000000 ├──────────────────────────────────────┤               │\n│             │   Kernel mapping of low memory       │               │\n│             │   (VGA at 0xB8000 mapped here)       │               │\n│             └──────────────────────────────────────┘               │\n│                                                                     │\n├─────────────────────────────────────────────────────────────────────┤\n│                         USER SPACE (3GB)                            │\n│                    0x00000000 - 0xBFFFFFFF                         │\n│                                                                     │\n│  0xBFFFFFFF ┌──────────────────────────────────────┐               │\n│             │   User Stack (grows down)            │               │\n│             │   PTE_USER = 1                       │               │\n│  0xBFFFF000 ├──────────────────────────────────────┤               │\n│             │                                      │               │\n│             │   (unmapped - guard page)            │               │\n│             │                                      │               │\n│  0xBFF00000 ├──────────────────────────────────────┤               │\n│             │                                      │               │\n│             │   User Heap (expandable)             │               │\n│             │   (brk/sbrk managed)                 │               │\n│             │                                      │               │\n│  0x00400000 ├──────────────────────────────────────┤               │\n│             │   User Code + Data                   │               │\n│             │   (loaded from executable)           │               │\n│             │   PTE_USER = 1                       │               │\n│  0x00001000 ├──────────────────────────────────────┤               │\n│             │   NULL page (unmapped)               │               │\n│  0x00000000 └──────────────────────────────────────┘               │\n│                                                                     │\n└─────────────────────────────────────────────────────────────────────┘\n\nPage Table Entry User Bit:\n  PTE_USER = 1 → User mode (ring 3) can access\n  PTE_USER = 0 → Supervisor only (ring 0-2)\n\nUser Process Page Directory:\n  - Entries 0-767: User space (unique per process)\n  - Entries 768-1023: Kernel space (identical across all processes)\n  - Kernel entries: PTE_USER = 0, PTE_GLOBAL = 1\n\nUser Mode Access Violation:\n  User code: mov eax, [0xC0100000]  ; Kernel memory\n  CPU checks: PTE_USER = 0, CPL = 3 → PAGE FAULT\n```\n\n### System Call Interface\n\n```\nINT 0x80 System Call Mechanism:\n\nUser Mode Call:\n┌─────────────────────────────────────────────────────────────────────┐\n│  // User code                                                       │\n│  const char *msg = \"Hello\\n\";                                      │\n│  int len = 5;                                                       │\n│                                                                     │\n│  // Inline assembly syscall                                         │\n│  asm volatile(                                                      │\n│      \"int $0x80\"                   // Trigger syscall              │\n│      : \"=a\"(retval)                // Return value in EAX          │\n│      : \"a\"(SYS_WRITE),             // Syscall number in EAX        │\n│        \"b\"(1),                     // fd in EBX                    │\n│        \"c\"(msg),                   // buf in ECX                   │\n│        \"d\"(len)                    // count in EDX                 │\n│  );                                                                 │\n└─────────────────────────────────────────────────────────────────────┘\n                              │\n                              │ int 0x80\n                              │ (CPU transitions ring 3 → ring 0)\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────────────┐\n│  Kernel Syscall Handler                                             │\n│                                                                     │\n│  1. Read syscall number from EAX                                   │\n│     syscall_num = regs->eax;  // EAX saved on stack               │\n│                                                                     │\n│  2. Bounds check                                                    │\n│     if (syscall_num >= MAX_SYSCALL) return -1;                     │\n│                                                                     │\n│  3. Dispatch to handler                                             │\n│     handler = syscall_table[syscall_num];                          │\n│     result = handler(regs->ebx, regs->ecx, regs->edx);             │\n│                                                                     │\n│  4. Store result                                                    │\n│     regs->eax = result;  // Return value                           │\n│                                                                     │\n│  5. iret back to user mode                                          │\n└─────────────────────────────────────────────────────────────────────┘\n                              │\n                              │ iret\n                              │ (CPU transitions ring 0 → ring 3)\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────────────┐\n│  // User code continues                                             │\n│  if (retval == len) {                                               │\n│      // Success                                                     │\n│  }                                                                  │\n└─────────────────────────────────────────────────────────────────────┘\n\nSyscall Register Convention:\n┌─────────────────────────────────────────────────────────────────────┐\n│ Register    Input                   Output                         │\n├─────────────────────────────────────────────────────────────────────┤\n│ EAX         Syscall number          Return value                   │\n│ EBX         Argument 0              (preserved or result)          │\n│ ECX         Argument 1              (preserved or result)          │\n│ EDX         Argument 2              (preserved or result)          │\n│ ESI         Argument 3 (optional)   (preserved)                    │\n│ EDI         Argument 4 (optional)   (preserved)                    │\n│ EBP         Argument 5 (optional)   (preserved)                    │\n└─────────────────────────────────────────────────────────────────────┘\n\nSyscall Table:\n┌─────────────────────────────────────────────────────────────────────┐\n│ Number  Name        Handler              Signature                 │\n├─────────────────────────────────────────────────────────────────────┤\n│ 0       SYS_EXIT    sys_exit             (int status) → void       │\n│ 1       SYS_READ    sys_read             (fd, buf, count) → int    │\n│ 2       SYS_WRITE   sys_write            (fd, buf, count) → int    │\n│ 3       SYS_EXEC    sys_exec             (path) → int              │\n│ 4       SYS_FORK    sys_fork             () → int                  │\n│ 5       SYS_GETPID  sys_getpid           () → int                  │\n│ 6       SYS_YIELD   sys_yield            () → void                 │\n│ 7-255   Reserved    (NULL)               -                         │\n└─────────────────────────────────────────────────────────────────────┘\n\nIDT Entry for INT 0x80:\n  offset_low  = handler_address & 0xFFFF\n  selector    = 0x08 (kernel code)\n  zero        = 0\n  type_attr   = 0xEE  // Present, DPL=3 (user callable), Trap gate\n  offset_high = handler_address >> 16\n\nDPL=3 is CRITICAL: Allows user mode to call int 0x80\nDPL=0 would cause General Protection Fault if called from ring 3\n```\n\n---\n\n[[CRITERIA_JSON: {\"module_id\": \"mod-scheduling\", \"criteria\": [\"PCB structure defines all required fields at documented byte offsets\", \"process_create allocates kernel stack and initializes PCB for kernel mode\", \"process_create allocates user stack and clones page directory for user mode\", \"context_switch saves all general purpose registers (EAX-EDX, ESI, EDI, EBP, ESP)\", \"context_switch saves all segment registers (CS, DS, ES, FS, GS, SS)\", \"context_switch saves EIP and EFLAGS\", \"context_switch loads CR3 when page directories differ\", \"context_switch updates TSS.ESP0 for user mode processes\", \"TSS is initialized with SS0=0x10 and loaded into TR\", \"TSS.ESP0 is updated before every context switch to user process\", \"Round-robin scheduler maintains ready queue with correct prev/next pointers\", \"scheduler_tick triggers context switch when time slice expires\", \"scheduler_yield marks current process READY and switches to next\", \"enter_user_mode uses iret to transition to ring 3\", \"enter_user_mode sets up stack frame with SS, ESP, EFLAGS, CS, EIP\", \"System call handler registered at IDT vector 0x80 with DPL=3\", \"System call handler validates syscall number before dispatch\", \"System call handler validates user pointers before dereferencing\", \"sys_write validates buffer is in user space (below kernel base)\", \"sys_exit marks process as ZOMBIE and triggers scheduler\", \"Three kernel processes can run concurrently with independent counters\", \"User process executes at ring 3 (CS=0x1B)\", \"User process page fault occurs on kernel memory access (isolation verified)\"]}]\n\n\n<!-- TDD_MOD_ID: mod-drivers -->\nI'll create a Technical Design Specification for the Kernel Drivers and Utilities module. Let me first examine the existing architecture to ensure consistency.\n\n\nI'll create a bibliography of high-quality external resources for the OS development concepts covered in this project. Let me first examine the existing architecture documentation to understand the scope better.# 📚 Beyond the Atlas: Further Reading\n\n## x86 Architecture & Boot Process\n\n**Paper**: B. Ford, S. Hibler, J. Lepreau, P. Tullmann. \"Microkernels Meet Recursive Virtual Machines.\" *OSDI '96*. The foundational paper on bootstrapping and recursive VM structure—directly relevant to understanding the hardware-to-software transition.\n\n**Code**: Linux Kernel `arch/x86/boot/` — Specifically `boot/header.S` and `boot/main.c`. The production implementation of the boot sequence you're building, showing how GRUB-compatible multiboot and real-mode transitions work at scale.\n\n**Best Explanation**: osdev.org Wiki, \"A20 Line\" article. The clearest explanation of why this historical quirk exists and the multiple methods to handle it.\n\n**Why**: These resources cover the actual hardware initialization that your bootloader negotiates, from real-mode legacy to protected mode setup.\n\n## Segmentation & GDT\n\n**Spec**: Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3A, Chapter 3 (\"Protected-Mode Memory Management\"). Sections 3.4-3.5 document the exact descriptor format and selector mechanics.\n\n**Code**: Linux Kernel `arch/x86/kernel/cpu/common.c` — `cpu_init()` function showing how production systems configure GDT entries including per-CPU segments.\n\n**Best Explanation**: \"GDT Tutorial\" by the OSDev community. Practical walkthrough of flat memory model setup with working code examples.\n\n**Why**: Intel's manual is authoritative; OSDev bridges specification to implementation.\n\n## Interrupt Handling & IDT\n\n**Spec**: Intel 64 and IA-32 Architectures SDM, Volume 3A, Chapter 6 (\"Interrupt and Exception Handling\"). Documents exception vectors, error codes, and IDT gate formats.\n\n**Code**: Linux Kernel `arch/x86/kernel/idt.c` — The modern Linux IDT setup, showing how a production system maps vectors to handlers with proper privilege levels.\n\n**Best Explanation**: \"8259 PIC\" article on OSDev Wiki. Essential for understanding IRQ remapping—the most common source of early OS bugs.\n\n**Why**: The PIC remapping problem trips up every OS developer; this resource prevents hours of debugging.\n\n## Physical Memory Management\n\n**Paper**: J. Bonwick. \"The Slab Allocator: An Object-Caching Kernel Memory Allocator.\" *USENIX '94*. While this is about slab allocators specifically, the introduction explains the frame allocator problem space clearly.\n\n**Code**: Linux Kernel `mm/page_alloc.c` — The buddy allocator implementation. `__alloc_pages_nodemask()` shows how production systems handle frame allocation with zones and watermarks.\n\n**Best Explanation**: \"Physical Memory Management\" chapter in \"Operating Systems: Three Easy Pieces\" by Arpaci-Dusseau. Free online at ostep.org.\n\n**Why**: OSTEP provides intuition; Linux shows the 30-year evolution of these ideas.\n\n## x86 Paging & Virtual Memory\n\n**Spec**: Intel SDM, Volume 3A, Chapter 4 (\"Paging\"). Tables 4-5 through 4-12 document the exact bit layout of PDEs and PTEs for 32-bit paging.\n\n**Code**: Linux Kernel `arch/x86/mm/init_32.c` — `kernel_physical_mapping_init()` shows how Linux builds its page tables, including the identity mapping + higher-half pattern.\n\n**Best Explanation**: \"What Every Computer Scientist Should Know About Virtual Memory\" by Ulrich Drepper.虽然是about Linux specifics but explains the hardware-software contract.\n\n**Why**: Drepper's guide connects page table mechanics to performance—essential for understanding TLB behavior.\n\n## Context Switching & Scheduling\n\n**Paper**: C. B. Weinstock and W. A. Wulf. \"QuickCheck: An Efficient Implementation of Checkpointing.\" *ICSE '91*. While about checkpoints, the register save/restore mechanics are identical to context switching.\n\n**Code**: Linux Kernel `arch/x86/kernel/process_32.c` — `__switch_to_asm()`. The actual assembly that saves/restores registers. Compare to your `context_switch()` implementation.\n\n**Best Explanation**: \"Scheduling\" chapter in OSTEP. Clear explanation of round-robin and the tradeoffs in scheduling algorithm design.\n\n**Why**: Seeing Linux's context switch demystifies what \"saving all registers\" actually means in production.\n\n## The TSS & Ring Transitions\n\n**Spec**: Intel SDM, Volume 3A, Section 7.2.1 (\"Task-State Segment\"). Documents why TSS.SS0:ESP0 are mandatory for privilege transitions.\n\n**Code**: Linux Kernel `arch/x86/kernel/process.c` — `arch_setup_new_exec()` and related functions showing how TSS.ESP0 is updated per-task.\n\n**Best Explanation**: \"Privilege Levels\" on OSDev Wiki. Clear diagrams showing stack switching during ring transitions.\n\n**Why**: The TSS is often misunderstood as \"Intel's failed hardware task switching\"—understanding its actual purpose (stack switching) prevents subtle bugs.\n\n## System Calls\n\n**Paper**: M. Abadi et al. \"Control-Flow Integrity.\" *CCS '05*. While advanced, the introduction explains why syscall validation matters for security.\n\n**Code**: Linux Kernel `arch/x86/entry/entry_32.S` — `ENTRY(entry_INT80_compat)`. The INT 0x80 handler showing how modern Linux still supports this legacy interface.\n\n**Best Explanation**: \"System Calls\" chapter in OSTEP. Clear conceptual explanation with implementation details.\n\n**Why**: OSTEP explains the \"why\"; Linux shows 30 years of security hardening.\n\n## PS/2 Keyboard & Hardware I/O\n\n**Spec**: IBM PS/2 Hardware Interface Technical Reference. The original specification for the keyboard controller interface.\n\n**Code**: Linux Kernel `drivers/input/keyboard/atkbd.c` — Production keyboard driver showing scancode handling complexity.\n\n**Best Explanation**: \"PS/2 Keyboard\" article on OSDev Wiki. Complete scancode tables and initialization sequences.\n\n**Why**: The OSDev article has tested code for handling the scancode quirks that will otherwise consume debugging time.\n\n## VGA Text Mode\n\n**Spec**: IBM VGA Technical Reference. The original specification for text mode buffer format.\n\n**Code**: Linux Kernel `drivers/video/console/vgacon.c` — Production VGA console driver.\n\n**Best Explanation**: \"VGA Text Mode\" on OSDev Wiki. Direct buffer addressing with color attribute byte format.\n\n**Why**: Simple, visual feedback is essential for debugging—this is your first output device.\n\n## Serial Port (Debugging Lifeline)\n\n**Code**: Linux Kernel `drivers/tty/serial/8250/8250_core.c` — The standard PC serial driver.\n\n**Best Explanation**: \"Serial Ports\" on OSDev Wiki. Complete initialization sequence and register map.\n\n**Why**: When your kernel triple-faults before VGA works, serial output is your only diagnostic tool.\n\n## Debugging with QEMU & GDB\n\n**Best Explanation**: \"Debugging with QEMU\" on OSDev Wiki. Complete guide to `-s -S` flags and GDB integration.\n\n**Why**: Working without a debugger in OS development is practically impossible—this skill is foundational.\n\n## Linker Scripts & Memory Layout\n\n**Spec**: GNU LD Manual, Chapter 3 (\"Linker Scripts\"). The authoritative reference for section placement and symbol definitions.\n\n**Code**: Linux Kernel `arch/x86/kernel/vmlinux.lds.S` — Production linker script showing complex section ordering and alignment requirements.\n\n**Best Explanation**: \"Linker Scripts\" chapter in \"Linkers and Loaders\" by John Levine. Explains the VMA/LMA distinction critical for higher-half kernels.\n\n**Why**: Understanding VMA vs LMA prevents the \"why is my code at the wrong address\" class of bugs.\n\n---\n\n## Reference Hierarchy\n\n1. **Intel SDM Volumes 1-3A** — The hardware truth; consult for exact bit layouts and behavior\n2. **OSDev Wiki** — Community-tested implementations; first stop for practical guidance\n3. **Linux Kernel Source** — Production implementations; study after understanding the basics\n4. **OSTEP (ostep.org)** — Conceptual clarity; read alongside implementation\n5. **QEMU + GDB** — Your debugging environment; master early\n\nTotal: 20 resources, prioritized by relevance to this project's milestones."}