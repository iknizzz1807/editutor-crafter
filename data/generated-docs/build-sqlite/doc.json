{"html":"<h1 id=\"build-your-own-sqlite\">Build Your Own SQLite</h1>\n<p>This project constructs a fully functional embedded SQL database from scratch, implementing the complete SQLite architecture: a tokenizer and recursive-descent parser producing ASTs, a bytecode compiler targeting a virtual database engine (VDBE), and a page-based storage engine with B-trees for clustered tables and B+trees for secondary indexes. The system includes a buffer pool with LRU eviction, a cost-based query planner with statistics-driven optimization, and ACID transactions via both rollback journal and write-ahead logging modes.</p>\n<p>Building SQLite reveals why databases are designed the way they are. Every layer—the virtual machine, the page format, the WAL—exists to solve a specific tension between speed and durability. You&#39;ll discover that SQL execution is essentially running bytecode on a register machine, that B-tree splits are where theory meets messy reality, and that crash recovery is an intricate dance of write ordering and checksums.</p>\n<!-- MS_ID: build-sqlite-m1 -->\n<h1 id=\"milestone-1-sql-tokenizer\">Milestone 1: SQL Tokenizer</h1>\n<h2 id=\"where-we-are-in-the-system\">Where We Are in the System</h2>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-satellite-overview.svg\" alt=\"SQLite Architecture: The Complete System Map\"></p>\n<p>You&#39;re building the <strong>front door</strong> of the database. Before any SQL can be parsed, optimized, or executed, it must be broken into tokens—the atomic units of meaning. This tokenizer sits at the very beginning of the query pipeline, converting raw character input into a structured stream that the parser can consume.</p>\n<p>Every query your database will ever process passes through this code. A bug here corrupts everything downstream.</p>\n<hr>\n<h2 id=\"the-tension-context-changes-meaning\">The Tension: Context Changes Meaning</h2>\n<p>Consider this SQL fragment:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#9ECBFF\"> 'SELECT'</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#9ECBFF\"> \"FROM\"</span></span></code></pre></div>\n\n<p>There are <strong>four</strong> occurrences of the word &quot;SELECT&quot; and &quot;FROM&quot; in that line. But only <strong>two</strong> are keywords. The others are data—literally the strings &#39;SELECT&#39; and &quot;FROM&quot; (the latter being a quoted table name).</p>\n<p>Now consider:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">a</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#6A737D\">    -- subtraction: identifier MINUS number</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#6A737D\">     -- negative number</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">'a-7'</span><span style=\"color:#6A737D\">  -- string literal containing dash</span></span></code></pre></div>\n\n<p>The dash character means three different things depending on context.</p>\n<p><strong>This is the fundamental tension of tokenization: the same character sequence can have completely different meanings based on parser state.</strong> A simple <code>split()</code> on whitespace cannot distinguish between a keyword inside quotes and a keyword outside them. Regex patterns that don&#39;t track state will misclassify tokens.</p>\n<p>The solution is a <strong>finite state machine</strong>—code that explicitly tracks whether you&#39;re currently inside a string literal, a quoted identifier, a numeric literal, or normal &quot;code&quot; space, and transitions between these states based on input characters.</p>\n<hr>\n<h2 id=\"the-tokenizer-state-machine\">The Tokenizer State Machine</h2>\n<p>{{DIAGRAM:diag-tokenizer-state-machine}}</p>\n<p>Your tokenizer will operate as a character-by-character state machine with these primary states:</p>\n<table>\n<thead>\n<tr>\n<th>State</th>\n<th>Meaning</th>\n<th>What Transitions Out</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>DEFAULT</strong></td>\n<td>Normal code space</td>\n<td>Letter → keyword/identifier, Digit → number, <code>&#39;</code> → string, <code>&quot;</code> → quoted identifier, Operator char → operator</td>\n</tr>\n<tr>\n<td><strong>IN_STRING</strong></td>\n<td>Inside <code>&#39;...&#39;</code> literal</td>\n<td><code>&#39;</code> → check for escape (<code>&#39;&#39;</code>), otherwise end string</td>\n</tr>\n<tr>\n<td><strong>IN_QUOTED_ID</strong></td>\n<td>Inside <code>&quot;...&quot;</code> identifier</td>\n<td><code>&quot;</code> → end identifier</td>\n</tr>\n<tr>\n<td><strong>IN_NUMBER</strong></td>\n<td>Parsing numeric literal</td>\n<td>Digit/<code>.</code> → continue, other → emit token, return to DEFAULT</td>\n</tr>\n<tr>\n<td><strong>IN_IDENTIFIER</strong></td>\n<td>Parsing unquoted identifier/keyword</td>\n<td>Letter/digit/<code>_</code> → continue, other → emit token, return to DEFAULT</td>\n</tr>\n</tbody></table>\n<p>The key insight: <strong>you cannot determine token boundaries without tracking state.</strong> When you see a <code>&#39;</code> character, you don&#39;t know if it starts a string, ends a string, or is an escaped quote until you know the current state and look at the next character.</p>\n<hr>\n<h2 id=\"building-the-tokenizer-step-by-step\">Building the Tokenizer: Step by Step</h2>\n<h3 id=\"the-token-structure\">The Token Structure</h3>\n<p>Every token your tokenizer emits needs four pieces of information:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type   </span><span style=\"color:#B392F0\">TokenType</span><span style=\"color:#6A737D\">  // Classification: KEYWORD, IDENTIFIER, STRING, NUMBER, OPERATOR, etc.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Value  </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">     // The actual text: \"SELECT\", \"users\", \"hello world\", \"42\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Line   </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">        // 1-indexed line number for error reporting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Column </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">        // 1-indexed column number for error reporting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The line and column fields are <strong>not optional</strong>. When a user writes malformed SQL like <code>SELECT * FORM users</code> (misspelled FROM), the parser needs to report exactly where the error occurred. The tokenizer is the only component that sees the raw input—it must count newlines and track position.</p>\n<h3 id=\"keyword-recognition-case-insensitive-matching\">Keyword Recognition: Case-Insensitive Matching</h3>\n<p>SQL keywords are case-insensitive. These are all valid:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">select</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> from</span><span style=\"color:#E1E4E8\"> users  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">Select</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> From</span><span style=\"color:#E1E4E8\"> Users</span></span></code></pre></div>\n\n<p>Your tokenizer should:</p>\n<ol>\n<li>Collect the identifier text character by character</li>\n<li>Convert to uppercase (or lowercase) for comparison</li>\n<li>Check against a keyword set/map</li>\n<li>Emit either a KEYWORD token or an IDENTIFIER token</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> keywords </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"SELECT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"FROM\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"WHERE\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"INSERT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"INTO\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"VALUES\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"UPDATE\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"DELETE\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"CREATE\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"TABLE\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"INDEX\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"DROP\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"AND\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"OR\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"NOT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"NULL\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"PRIMARY\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"KEY\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"UNIQUE\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"FOREIGN\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"JOIN\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"INNER\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"LEFT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"RIGHT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"ON\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"ORDER\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"BY\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"ASC\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"DESC\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"GROUP\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"HAVING\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"LIMIT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"OFFSET\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"INTEGER\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"TEXT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"REAL\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"BLOB\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"BEGIN\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"COMMIT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"ROLLBACK\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Tokenizer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">classifyIdentifier</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">text</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TokenType</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    upper </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">ToUpper</span><span style=\"color:#E1E4E8\">(text)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> keywords[upper] {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> KEYWORD</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> IDENTIFIER</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Important</strong>: The original case is preserved in the <code>Value</code> field. Only the classification uses case-insensitive matching. This matters for identifiers—<code>&quot;Users&quot;</code> and <code>users</code> may be different tables depending on quoting rules.</p>\n<h3 id=\"string-literals-the-escape-sequence-problem\">String Literals: The Escape Sequence Problem</h3>\n<p>SQL string literals use single quotes, and a single quote <em>inside</em> the string is escaped by doubling it:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">'It''s a beautiful day'</span><span style=\"color:#6A737D\">   -- String value: It's a beautiful day</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">'O''Brien'</span><span style=\"color:#6A737D\">                -- String value: O'Brien</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">''''</span><span style=\"color:#6A737D\">                      -- String value: ' (single quote)</span></span></code></pre></div>\n\n<p>This is where naive approaches fail. A tokenizer that just looks for the next <code>&#39;</code> character will incorrectly terminate at the first escape.</p>\n<p>The correct logic in the <code>IN_STRING</code> state:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>When current char is ':\n    Peek at next char\n    If next char is also ':\n        This is an escape - append ' to value, advance past both quotes\n    Else:\n        This is the closing quote - emit STRING token, return to DEFAULT</code></pre></div>\n\n<h3 id=\"numeric-literals-integers-vs-floats\">Numeric Literals: Integers vs Floats</h3>\n<p>Numbers require distinguishing between integers and floating-point values:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#79B8FF\">42</span><span style=\"color:#6A737D\">        -- INTEGER</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">14</span><span style=\"color:#6A737D\">      -- FLOAT (has decimal point)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#6A737D\">        -- INTEGER (negative, but handled carefully - see pitfalls)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">1e10      </span><span style=\"color:#6A737D\">-- FLOAT (scientific notation - optional enhancement)</span></span></code></pre></div>\n\n<p>The state machine for numbers:</p>\n<ol>\n<li>If first char is a digit, enter <code>IN_NUMBER</code> state</li>\n<li>Continue collecting digits</li>\n<li>If <code>.</code> encountered, mark as FLOAT and continue</li>\n<li>On non-numeric char, emit NUMBER token with appropriate subtype</li>\n</ol>\n<p><strong>Note on negative numbers</strong>: The <code>-</code> in <code>-7</code> is actually the unary minus <em>operator</em> applied to the literal <code>7</code>. Some tokenizers treat <code>-7</code> as a single negative number token; others emit <code>OPERATOR(-)</code> followed by <code>NUMBER(7)</code>. The latter approach is cleaner because it handles <code>-  7</code> (with spaces) correctly. However, for SQL, it&#39;s common to lex <code>-7</code> as a single negative number token for convenience. Either approach works if your parser handles it consistently.</p>\n<h3 id=\"operators-single-and-double-character\">Operators: Single and Double Character</h3>\n<p>SQL has operators that are one character (<code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>) and operators that are two characters (<code>&lt;=</code>, <code>&gt;=</code>, <code>!=</code>, <code>&lt;&gt;</code>).</p>\n<p>The tokenizer needs to <strong>peek ahead</strong> when it encounters a character that could start a multi-character operator:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Tokenizer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">readOperator</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.pos</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ch </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">current</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check for two-character operators</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> ch {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">&#x3C;</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">peek</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">=</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            t.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">makeToken</span><span style=\"color:#E1E4E8\">(OPERATOR, </span><span style=\"color:#9ECBFF\">\"&#x3C;=\"</span><span style=\"color:#E1E4E8\">, start)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">peek</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">></span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\"> {  </span><span style=\"color:#6A737D\">// &#x3C;> is also not-equals</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            t.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">makeToken</span><span style=\"color:#E1E4E8\">(OPERATOR, </span><span style=\"color:#9ECBFF\">\"&#x3C;>\"</span><span style=\"color:#E1E4E8\">, start)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">></span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">peek</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">=</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            t.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">makeToken</span><span style=\"color:#E1E4E8\">(OPERATOR, </span><span style=\"color:#9ECBFF\">\">=\"</span><span style=\"color:#E1E4E8\">, start)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">!</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">peek</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">=</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            t.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">makeToken</span><span style=\"color:#E1E4E8\">(OPERATOR, </span><span style=\"color:#9ECBFF\">\"!=\"</span><span style=\"color:#E1E4E8\">, start)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">=</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Could be == in some dialects, but SQL uses = for equality</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Single character operator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">makeToken</span><span style=\"color:#E1E4E8\">(OPERATOR, </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">(ch), start)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"quoted-identifiers-double-quotes\">Quoted Identifiers: Double Quotes</h3>\n<p>SQL allows identifiers containing spaces or special characters when wrapped in double quotes:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#9ECBFF\"> \"Order Details\"</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"Item Name\"</span><span style=\"color:#F97583\"> TEXT</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"Price ($)\"</span><span style=\"color:#F97583\"> REAL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p>The <code>IN_QUOTED_ID</code> state is similar to <code>IN_STRING</code>, but SQL quoted identifiers typically don&#39;t use escape doubling—<code>&quot;a&quot;&quot;b&quot;</code> would end the identifier at the second quote, producing <code>a</code> followed by a syntax error or another identifier <code>b</code>. Check your target SQL dialect&#39;s rules.</p>\n<h3 id=\"whitespace-and-comments\">Whitespace and Comments</h3>\n<p>Whitespace (spaces, tabs, newlines) separates tokens but is not emitted as tokens itself. The tokenizer simply skips over it in the DEFAULT state.</p>\n<p>Comments should also be skipped:</p>\n<ul>\n<li><code>-- This is a line comment</code> (continues to end of line)</li>\n<li><code>/* This is a block comment */</code> (can span multiple lines)</li>\n</ul>\n<p>Skipping comments happens in the DEFAULT state before attempting to read a token.</p>\n<hr>\n<h2 id=\"error-reporting-line-and-column-tracking\">Error Reporting: Line and Column Tracking</h2>\n<p>When the tokenizer encounters an unexpected character (like <code>@</code> or a stray <code>&quot;</code> that&#39;s never closed), it must report the location precisely.</p>\n<p>This requires maintaining position state:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Tokenizer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    input   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos     </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">  // Current byte position in input</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line    </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">  // Current line number (1-indexed)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    column  </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">  // Current column number (1-indexed)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Tokenizer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">n</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> n; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> t.input[t.pos] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            t.line</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            t.column </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            t.column</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.pos</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Every token captures the line and column at its <strong>start</strong> position. An unclosed string literal error reports where the string <em>began</em>, not where the input ended.</p>\n<hr>\n<h2 id=\"the-token-stream-output\">The Token Stream Output</h2>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-token-stream-example.svg\" alt=\"Token Stream: SELECT Statement Before and After\"></p>\n<p>For input:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> name</span><span style=\"color:#E1E4E8\">, age </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> age </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 18</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p>The tokenizer produces:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[0] KEYWORD(&quot;SELECT&quot;)      line:1, col:1\n[1] IDENTIFIER(&quot;name&quot;)     line:1, col:8\n[2] PUNCTUATION(&quot;,&quot;)       line:1, col:12\n[3] IDENTIFIER(&quot;age&quot;)      line:1, col:14\n[4] KEYWORD(&quot;FROM&quot;)        line:1, col:18\n[5] IDENTIFIER(&quot;users&quot;)    line:1, col:23\n[6] KEYWORD(&quot;WHERE&quot;)       line:1, col:29\n[7] IDENTIFIER(&quot;age&quot;)      line:1, col:35\n[8] OPERATOR(&quot;&gt;&quot;)          line:1, col:39\n[9] NUMBER(&quot;18&quot;)           line:1, col:41\n[10] PUNCTUATION(&quot;;&quot;)      line:1, col:43</code></pre></div>\n\n<p>This array of tokens is what the parser (next milestone) will consume to build an AST.</p>\n<hr>\n<h2 id=\"a-complete-tokenization-example\">A Complete Tokenization Example</h2>\n<p>Let&#39;s trace through a complex statement:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#9ECBFF\"> \"User Data\"</span><span style=\"color:#E1E4E8\"> (id, </span><span style=\"color:#F97583\">name</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Alice''s Restaurant'</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>Char</th>\n<th>State → State</th>\n<th>Token Emitted</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>I</td>\n<td>DEFAULT → IN_IDENTIFIER</td>\n<td>—</td>\n</tr>\n<tr>\n<td>2-6</td>\n<td>NSERT</td>\n<td>IN_IDENTIFIER</td>\n<td>—</td>\n</tr>\n<tr>\n<td>7</td>\n<td>(space)</td>\n<td>IN_IDENTIFIER → DEFAULT</td>\n<td>KEYWORD(&quot;INSERT&quot;)</td>\n</tr>\n<tr>\n<td>8-11</td>\n<td>INTO</td>\n<td>DEFAULT → IN_IDENTIFIER → DEFAULT</td>\n<td>KEYWORD(&quot;INTO&quot;)</td>\n</tr>\n<tr>\n<td>12</td>\n<td>&quot;</td>\n<td>DEFAULT → IN_QUOTED_ID</td>\n<td>—</td>\n</tr>\n<tr>\n<td>13-21</td>\n<td>User Data</td>\n<td>IN_QUOTED_ID</td>\n<td>—</td>\n</tr>\n<tr>\n<td>22</td>\n<td>&quot;</td>\n<td>IN_QUOTED_ID → DEFAULT</td>\n<td>IDENTIFIER(&quot;User Data&quot;)</td>\n</tr>\n<tr>\n<td>23</td>\n<td>(</td>\n<td>DEFAULT</td>\n<td>PUNCTUATION(&quot;(&quot;)</td>\n</tr>\n<tr>\n<td>24-25</td>\n<td>id</td>\n<td>IN_IDENTIFIER</td>\n<td>IDENTIFIER(&quot;id&quot;)</td>\n</tr>\n<tr>\n<td>26</td>\n<td>,</td>\n<td>DEFAULT</td>\n<td>PUNCTUATION(&quot;,&quot;)</td>\n</tr>\n<tr>\n<td>27-30</td>\n<td>name</td>\n<td>IN_IDENTIFIER</td>\n<td>IDENTIFIER(&quot;name&quot;)</td>\n</tr>\n<tr>\n<td>31</td>\n<td>)</td>\n<td>DEFAULT</td>\n<td>PUNCTUATION(&quot;)&quot;)</td>\n</tr>\n<tr>\n<td>32-36</td>\n<td>VALUES</td>\n<td>IN_IDENTIFIER</td>\n<td>KEYWORD(&quot;VALUES&quot;)</td>\n</tr>\n<tr>\n<td>37</td>\n<td>(</td>\n<td>DEFAULT</td>\n<td>PUNCTUATION(&quot;(&quot;)</td>\n</tr>\n<tr>\n<td>38</td>\n<td>1</td>\n<td>IN_NUMBER</td>\n<td>NUMBER(&quot;1&quot;, INTEGER)</td>\n</tr>\n<tr>\n<td>39</td>\n<td>,</td>\n<td>DEFAULT</td>\n<td>PUNCTUATION(&quot;,&quot;)</td>\n</tr>\n<tr>\n<td>40</td>\n<td>&#39;</td>\n<td>DEFAULT → IN_STRING</td>\n<td>—</td>\n</tr>\n<tr>\n<td>41-45</td>\n<td>Alice</td>\n<td>IN_STRING</td>\n<td>—</td>\n</tr>\n<tr>\n<td>46</td>\n<td>&#39;</td>\n<td>IN_STRING (check next)</td>\n<td>— (next is also &#39;)</td>\n</tr>\n<tr>\n<td>47</td>\n<td>&#39;</td>\n<td>IN_STRING (escaped)</td>\n<td>— (append &#39; to value)</td>\n</tr>\n<tr>\n<td>48-58</td>\n<td>s Restaurant</td>\n<td>IN_STRING</td>\n<td>—</td>\n</tr>\n<tr>\n<td>59</td>\n<td>&#39;</td>\n<td>IN_STRING → DEFAULT</td>\n<td>STRING(&quot;Alice&#39;s Restaurant&quot;)</td>\n</tr>\n<tr>\n<td>60</td>\n<td>)</td>\n<td>DEFAULT</td>\n<td>PUNCTUATION(&quot;)&quot;)</td>\n</tr>\n<tr>\n<td>61</td>\n<td>;</td>\n<td>DEFAULT</td>\n<td>PUNCTUATION(&quot;;&quot;)</td>\n</tr>\n</tbody></table>\n<p>Notice step 46-47: the doubled quote inside the string is recognized as an escape, and only a single quote is added to the token value.</p>\n<hr>\n<h2 id=\"common-pitfalls\">Common Pitfalls</h2>\n<h3 id=\"1-not-handling-escaped-quotes\">1. Not Handling Escaped Quotes</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">'It''s broken'</span><span style=\"color:#6A737D\">   -- Without escape handling, produces: \"It\" followed by error</span></span></code></pre></div>\n\n<p>The tokenizer would emit STRING(&quot;It&quot;), then see <code>s broken&#39;</code> and fail because <code>s</code> isn&#39;t a valid token start in that context.</p>\n<p><strong>Fix</strong>: In the <code>IN_STRING</code> state, always peek ahead when you see <code>&#39;</code> to check for the escape sequence.</p>\n<h3 id=\"2-case-sensitivity-confusion\">2. Case Sensitivity Confusion</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> Users   </span><span style=\"color:#6A737D\">-- \"Users\" should be IDENTIFIER, not keyword</span></span></code></pre></div>\n\n<p>Keywords are case-insensitive, but the <em>text</em> of the token should preserve original case. Don&#39;t lowercase the <code>Value</code> field—only use lowercase/uppercase for the keyword <em>lookup</em>.</p>\n<h3 id=\"3-negative-numbers-vs-subtraction\">3. Negative Numbers vs Subtraction</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#E1E4E8\"> a</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> t   </span><span style=\"color:#6A737D\">-- Is this \"a minus 7\" or \"a negative-7\"?</span></span></code></pre></div>\n\n<p>With whitespace: <code>a - 7</code> is clearly subtraction. Without: <code>a-7</code> is ambiguous.</p>\n<p>The safest approach: <strong>emit the <code>-</code> as an operator always</strong>, let the parser decide if it&#39;s unary minus (negation) or binary minus (subtraction). This handles both <code>a-7</code> and <code>a - 7</code> and <code>-7</code> uniformly.</p>\n<p>If you <em>do</em> want to lex <code>-7</code> as a single negative number, only do so when <code>-</code> is immediately followed by a digit AND the preceding token (if any) suggests an expression context (after an operator, after <code>(</code>, at start of statement, etc.). This is complex and error-prone.</p>\n<h3 id=\"4-unicode-and-multi-byte-characters\">4. Unicode and Multi-byte Characters</h3>\n<p>If your SQL supports Unicode identifiers like <code>名前</code>, you cannot use simple byte indexing. UTF-8 encodes characters as 1-4 bytes, and your line/column tracking must count <em>characters</em>, not bytes.</p>\n<p><strong>For this project</strong>: Start with ASCII-only identifiers. Document the limitation. Unicode support can be added later with a proper UTF-8 decoder.</p>\n<h3 id=\"5-forgetting-to-track-position\">5. Forgetting to Track Position</h3>\n<p>If you don&#39;t increment line/column during tokenization, you can&#39;t provide useful error messages. The parser will be left saying &quot;unexpected token&quot; without being able to show <em>where</em>.</p>\n<hr>\n<h2 id=\"test-suite-what-to-verify\">Test Suite: What to Verify</h2>\n<p>Your tokenizer test suite should cover:</p>\n<p><strong>Basic tokens:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#6A737D\">        -- KEYWORD</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">my_table      </span><span style=\"color:#6A737D\">-- IDENTIFIER  </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">42</span><span style=\"color:#6A737D\">            -- NUMBER (integer)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">14</span><span style=\"color:#6A737D\">          -- NUMBER (float)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">=</span><span style=\"color:#6A737D\">             -- OPERATOR</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">(             </span><span style=\"color:#6A737D\">-- PUNCTUATION</span></span></code></pre></div>\n\n<p><strong>Case insensitivity:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">select</span><span style=\"color:#F97583\"> SELECT</span><span style=\"color:#F97583\"> Select</span><span style=\"color:#F97583\"> sElEcT</span><span style=\"color:#6A737D\">   -- All KEYWORD</span></span></code></pre></div>\n\n<p><strong>String escapes:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">'hello'</span><span style=\"color:#6A737D\">         -- STRING(\"hello\")</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">'It''s'</span><span style=\"color:#6A737D\">         -- STRING(\"It's\")</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">''''</span><span style=\"color:#6A737D\">            -- STRING(\"'\")</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">''</span><span style=\"color:#6A737D\">              -- STRING(\"\") (empty string)</span></span></code></pre></div>\n\n<p><strong>Quoted identifiers:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"column name\"</span><span style=\"color:#6A737D\">   -- IDENTIFIER(\"column name\")</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"SELECT\"</span><span style=\"color:#6A737D\">        -- IDENTIFIER(\"SELECT\") -- NOT a keyword!</span></span></code></pre></div>\n\n<p><strong>Operators:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#F97583\"> ></span><span style=\"color:#F97583\"> &#x3C;=</span><span style=\"color:#F97583\"> >=</span><span style=\"color:#F97583\"> !=</span><span style=\"color:#F97583\"> &#x3C;></span><span style=\"color:#6A737D\">   -- All distinct OPERATOR tokens</span></span></code></pre></div>\n\n<p><strong>Complex statements:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#E1E4E8\"> id, </span><span style=\"color:#F97583\">name</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> age </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 21</span><span style=\"color:#F97583\"> AND</span><span style=\"color:#F97583\"> status</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'active'</span><span style=\"color:#F97583\"> ORDER BY</span><span style=\"color:#F97583\"> name</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> logs (</span><span style=\"color:#F97583\">message</span><span style=\"color:#E1E4E8\">, ts) </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">'User logged in'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'2024-01-15'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#9ECBFF\"> \"Order Items\"</span><span style=\"color:#E1E4E8\"> (id </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#F97583\"> PRIMARY KEY</span><span style=\"color:#E1E4E8\">, qty </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p><strong>Error cases:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">'It never ends    -- Unclosed string: error at line 1, column 1</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"also unclosed    -- Unclosed identifier: error at line 1, column 1</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">@bad_char         -- Unrecognized character: error at line 1, column 1</span></span></code></pre></div>\n\n<p>Aim for <strong>20+ diverse SQL statements</strong> in your test suite, including edge cases.</p>\n<hr>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<p>You&#39;ve just built a <strong>lexer</strong>—the foundation of all language processing. Here&#39;s where this knowledge connects:</p>\n<p><strong>Immediate connections:</strong></p>\n<ul>\n<li><strong>Parser (next milestone)</strong>: Your token stream feeds directly into the recursive-descent parser. The token types you defined become the grammar terminals.</li>\n<li><strong>Error messages</strong>: The line/column tracking you implemented will be used by every error message the database produces.</li>\n</ul>\n<p><strong>Same domain:</strong></p>\n<ul>\n<li><strong>Regular expressions</strong>: The state machine you built is what regex engines compile patterns into. A regex like <code>&#39;[&#39;]*&#39;</code> compiles to nearly the same state transitions as your string literal handler.</li>\n<li><strong>Lexer generators (flex, lex, ANTLR)</strong>: Tools that generate tokenizers from declarative specifications. Your hand-written version gives you complete control and better error messages.</li>\n</ul>\n<p><strong>Cross-domain:</strong></p>\n<ul>\n<li><strong>IDE syntax highlighting</strong>: The colored SQL you see in editors comes from a tokenizer nearly identical to this one, running on every keystroke to recolor the text.</li>\n<li><strong>UTF-8/Unicode handling</strong>: Multi-byte character processing is a state machine problem too—you&#39;re doing character-by-character processing, which is the right mental model for handling variable-width encodings.</li>\n<li><strong>SQL injection detection</strong>: Understanding token boundaries reveals why sanitization is hard. An attacker who knows your tokenizer&#39;s rules can craft inputs like <code>&#39; OR &#39;1&#39;=&#39;1</code> that break out of string contexts. Tokenization is the first line of defense—you must handle all escape sequences correctly or leave vulnerabilities.</li>\n</ul>\n<p><strong>Forward:</strong></p>\n<ul>\n<li><strong>With this knowledge, you could now build</strong>: A syntax highlighter for SQL, a SQL formatter/prettifier, a basic SQL linter that detects syntax issues before parsing, or a query logger that redacts string literals for privacy.</li>\n</ul>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-sqlite-m2 -->\n<h1 id=\"milestone-2-sql-parser-ast\">Milestone 2: SQL Parser (AST)</h1>\n<h2 id=\"where-we-are-in-the-system\">Where We Are in the System</h2>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-satellite-overview.svg\" alt=\"SQLite Architecture: The Complete System Map\"></p>\n<p>Your tokenizer hands you a clean stream of tokens—<code>KEYWORD(&quot;SELECT&quot;)</code>, <code>IDENTIFIER(&quot;users&quot;)</code>, <code>OPERATOR(&quot;&gt;&quot;)</code>, <code>NUMBER(&quot;18&quot;)</code>. Now you must answer: <strong>what does this sequence mean?</strong></p>\n<p>The parser&#39;s job is to impose structure on this flat stream. It recognizes that <code>SELECT</code> starts a query, that <code>FROM</code> introduces a table reference, that <code>WHERE</code> begins a filter condition, and that <code>age &gt; 18</code> is an expression with an operator and two operands. The output is an <strong>Abstract Syntax Tree</strong> (AST)—a hierarchical representation that captures the <em>meaning</em> of the SQL statement.</p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-ast-structure.svg\" alt=\"AST Structure: SELECT Statement Tree\"></p>\n<p>This AST is what the bytecode compiler (next milestone) will traverse to generate executable instructions. A malformed AST produces incorrect bytecode, which produces wrong query results.</p>\n<hr>\n<h2 id=\"the-tension-ambiguity-and-infinite-loops\">The Tension: Ambiguity and Infinite Loops</h2>\n<p>Consider parsing this SQL expression:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> active </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> OR</span><span style=\"color:#F97583\"> role</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'admin'</span><span style=\"color:#F97583\"> AND</span><span style=\"color:#F97583\"> level</span><span style=\"color:#F97583\"> ></span><span style=\"color:#79B8FF\"> 5</span></span></code></pre></div>\n\n<p>Does this mean:</p>\n<ul>\n<li><code>(active = 1 OR role = &#39;admin&#39;) AND level &gt; 5</code> — users who are either active or admins, AND have level &gt; 5?</li>\n<li><code>active = 1 OR (role = &#39;admin&#39; AND level &gt; 5)</code> — users who are active, OR admins with level &gt; 5?</li>\n</ul>\n<p>These return <strong>different results</strong>. The parser must resolve this ambiguity using operator precedence rules.</p>\n<p>Now consider this grammar rule for expressions:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>expression → expression AND expression\n           | expression OR expression\n           | comparison</code></pre></div>\n\n<p>Looks reasonable. But try parsing <code>a OR b</code>:</p>\n<ol>\n<li>Try to match <code>expression AND expression</code></li>\n<li>To match the left <code>expression</code>, try <code>expression AND expression</code> again</li>\n<li>To match <em>that</em> left <code>expression</code>, try <code>expression AND expression</code> again</li>\n<li><strong>Infinite recursion</strong>—the parser never makes progress</li>\n</ol>\n<p>This is <strong>left recursion</strong>, and it&#39;s fatal for recursive descent parsers. The grammar is mathematically valid, but the implementation strategy (recursive functions calling themselves with the same input position) cannot handle it.</p>\n<p><strong>Two problems emerge:</strong></p>\n<ol>\n<li><strong>Ambiguity</strong>: The same token sequence can be interpreted multiple ways—precedence rules must pick one</li>\n<li><strong>Left recursion</strong>: Naive grammar encoding causes infinite loops—structure must be rewritten or a different algorithm used</li>\n</ol>\n<hr>\n<h2 id=\"the-revelation-precedence-is-not-natural\">The Revelation: Precedence Is Not Natural</h2>\n<p>You might expect operator precedence to &quot;just work&quot; if you structure your grammar correctly. It doesn&#39;t.</p>\n<p>SQL&#39;s precedence hierarchy (highest to lowest):</p>\n<ol>\n<li><code>NOT</code> — unary negation</li>\n<li>Comparison operators: <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>!=</code>, <code>&lt;&gt;</code></li>\n<li><code>AND</code> — conjunction</li>\n<li><code>OR</code> — disjunction (lowest precedence)</li>\n</ol>\n<p>This means:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">NOT</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">AND</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> d </span><span style=\"color:#F97583\">OR</span><span style=\"color:#E1E4E8\"> e </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> f</span></span></code></pre></div>\n\n<p>Is parsed as:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>OR\n├── AND\n│   ├── NOT\n│   │   └── = (a, b)\n│   └── &gt; (c, d)\n└── &lt; (e, f)</code></pre></div>\n\n<p>A naive grammar that treats all binary operators equally produces a flat or wrong tree. A grammar that encodes precedence explicitly becomes verbose and hard to maintain:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>or_expr     → and_expr (OR and_expr)*\nand_expr    → not_expr (AND not_expr)*\nnot_expr    → NOT not_expr | comparison\ncomparison  → primary (('=' | '&lt;' | '&gt;') primary)?</code></pre></div>\n\n<p>This works but requires four separate functions for expressions alone. Add more operators and the complexity grows.</p>\n<p>The elegant solution is <strong>precedence climbing</strong> or <strong>Pratt parsing</strong>—a single algorithm that handles all operators using precedence values and associativity rules. You write one function, configure a table of operators, and the algorithm produces correct trees automatically.</p>\n<hr>\n<h2 id=\"three-level-view-from-token-stream-to-ast\">Three-Level View: From Token Stream to AST</h2>\n<p>{{DIAGRAM:diag-query-execution-pipeline}}</p>\n<table>\n<thead>\n<tr>\n<th>Level</th>\n<th>What It Does</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Statement</strong></td>\n<td>Top-level structure: SELECT, INSERT, CREATE, etc.</td>\n<td><code>SELECT ... FROM ... WHERE ...</code></td>\n</tr>\n<tr>\n<td><strong>Clause</strong></td>\n<td>Components within a statement</td>\n<td><code>WHERE active = 1</code></td>\n</tr>\n<tr>\n<td><strong>Expression</strong></td>\n<td>Computable values with operators</td>\n<td><code>a OR b AND NOT c</code></td>\n</tr>\n</tbody></table>\n<p>Your parser descends through these levels:</p>\n<ol>\n<li><strong>Statement level</strong>: Look at first token to choose SELECT parser, INSERT parser, etc.</li>\n<li><strong>Clause level</strong>: Parse column list, FROM clause, WHERE clause, etc.</li>\n<li><strong>Expression level</strong>: Handle operators with correct precedence</li>\n</ol>\n<hr>\n<h2 id=\"building-the-parser-step-by-step\">Building the Parser: Step by Step</h2>\n<h3 id=\"the-parser-structure\">The Parser Structure</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Parser</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tokens    []</span><span style=\"color:#B392F0\">Token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos       </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">       // Current position in token array</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current   </span><span style=\"color:#B392F0\">Token</span><span style=\"color:#6A737D\">     // Lookahead token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    errors    []</span><span style=\"color:#B392F0\">ParseError</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ParseError</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Message </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Line    </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Column  </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The parser maintains a <strong>lookahead</strong>—the current token being examined. One token of lookahead is sufficient for SQL (it&#39;s an LL(1) grammar with some exceptions handled by context).</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.pos</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.pos </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(p.tokens) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> p.tokens[p.pos]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.current </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#E1E4E8\">{Type: EOF}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tokenType</span><span style=\"color:#B392F0\"> TokenType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> tokenType </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> value {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"expected </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, got </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, value, p.current.Value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"statement-parsing-dispatch-on-first-token\">Statement Parsing: Dispatch on First Token</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ParseStatement</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">Statement</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> KEYWORD </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"SELECT\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseSelect</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> KEYWORD </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"INSERT\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseInsert</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> KEYWORD </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"CREATE\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseCreate</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... other statement types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, p.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unexpected token: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, p.current.Value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Each statement type has its own parsing function that knows the expected structure.</p>\n<h3 id=\"select-statement-parsing\">SELECT Statement Parsing</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SelectStatement</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Columns    []</span><span style=\"color:#B392F0\">ColumnSelection</span><span style=\"color:#6A737D\">  // * or explicit column list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FromTable  </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">             // Table name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Where      </span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#6A737D\">         // Optional filter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OrderBy    []</span><span style=\"color:#B392F0\">OrderByColumn</span><span style=\"color:#6A737D\">    // Optional ordering</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Limit      </span><span style=\"color:#F97583\">*int</span><span style=\"color:#6A737D\">               // Optional row limit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ColumnSelection</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expression </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Alias      </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // Optional: \"AS alias\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">parseSelect</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SelectStatement</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stmt </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">SelectStatement</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // SELECT</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(KEYWORD, </span><span style=\"color:#9ECBFF\">\"SELECT\"</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Column list (or *)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    columns, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseColumnList</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stmt.Columns </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> columns</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // FROM clause (required)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> KEYWORD </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"FROM\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> IDENTIFIER {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, p.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"expected table name after FROM\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stmt.FromTable </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> p.current.Value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // WHERE clause (optional)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> KEYWORD </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"WHERE\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expr, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseExpression</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stmt.Where </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expr</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ORDER BY (optional)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> KEYWORD </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"ORDER\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(KEYWORD, </span><span style=\"color:#9ECBFF\">\"BY\"</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stmt.OrderBy, _ </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseOrderByList</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // LIMIT (optional)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> KEYWORD </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"LIMIT\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> NUMBER {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, p.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"expected number after LIMIT\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        limit </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> parseInt</span><span style=\"color:#E1E4E8\">(p.current.Value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stmt.Limit </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">limit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> stmt, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Key insight: <strong>keywords structure the parse</strong>. After <code>SELECT</code>, you expect columns. After <code>FROM</code>, you expect a table. After <code>WHERE</code>, you expect an expression. The parser follows this roadmap.</p>\n<h3 id=\"insert-statement-parsing\">INSERT Statement Parsing</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> InsertStatement</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Table    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Columns  []</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">      // Optional column names</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Values   [][]</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#6A737D\">  // VALUES clause(s)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">parseInsert</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">InsertStatement</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stmt </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">InsertStatement</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // INSERT INTO</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(KEYWORD, </span><span style=\"color:#9ECBFF\">\"INSERT\"</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(KEYWORD, </span><span style=\"color:#9ECBFF\">\"INTO\"</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Table name</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> IDENTIFIER {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, p.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"expected table name\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stmt.Table </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> p.current.Value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Optional column list: (col1, col2, ...)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PUNCTUATION </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"(\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stmt.Columns </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseIdentifierList</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(PUNCTUATION, </span><span style=\"color:#9ECBFF\">\")\"</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // VALUES clause</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(KEYWORD, </span><span style=\"color:#9ECBFF\">\"VALUES\"</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // One or more value tuples: (1, 'a'), (2, 'b')</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> PUNCTUATION </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"(\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, p.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"expected '(' to start VALUES tuple\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        values, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseExpressionList</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stmt.Values </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(stmt.Values, values)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(PUNCTUATION, </span><span style=\"color:#9ECBFF\">\")\"</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check for more tuples</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> PUNCTUATION </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \",\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> stmt, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"create-table-parsing\">CREATE TABLE Parsing</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CreateTableStatement</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Table       </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Columns     []</span><span style=\"color:#B392F0\">ColumnDefinition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Constraints []</span><span style=\"color:#B392F0\">TableConstraint</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ColumnDefinition</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name        </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type        </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">       // INTEGER, TEXT, REAL, BLOB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Constraints []</span><span style=\"color:#B392F0\">ColumnConstraint</span><span style=\"color:#6A737D\">  // PRIMARY KEY, NOT NULL, UNIQUE, etc.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">parseCreate</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CreateTableStatement</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stmt </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">CreateTableStatement</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // CREATE TABLE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(KEYWORD, </span><span style=\"color:#9ECBFF\">\"CREATE\"</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(KEYWORD, </span><span style=\"color:#9ECBFF\">\"TABLE\"</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Table name (may be quoted)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> IDENTIFIER {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, p.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"expected table name\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stmt.Table </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> p.current.Value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Column definitions in parentheses</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(PUNCTUATION, </span><span style=\"color:#9ECBFF\">\"(\"</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        col, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseColumnDefinition</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stmt.Columns </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(stmt.Columns, col)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // More columns?</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PUNCTUATION </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \",\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(PUNCTUATION, </span><span style=\"color:#9ECBFF\">\")\"</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> stmt, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">parseColumnDefinition</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">ColumnDefinition</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    col </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ColumnDefinition</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Column name</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> IDENTIFIER {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> col, p.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"expected column name\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    col.Name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> p.current.Value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Data type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> KEYWORD {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> col, p.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"expected data type\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    col.Type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> p.current.Value  </span><span style=\"color:#6A737D\">// INTEGER, TEXT, REAL, BLOB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Optional constraints</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> KEYWORD {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        switch</span><span style=\"color:#E1E4E8\"> p.current.Value {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> \"PRIMARY\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(KEYWORD, </span><span style=\"color:#9ECBFF\">\"KEY\"</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> col, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            col.Constraints </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(col.Constraints, </span><span style=\"color:#B392F0\">PrimaryKeyConstraint</span><span style=\"color:#E1E4E8\">{})</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> \"NOT\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(KEYWORD, </span><span style=\"color:#9ECBFF\">\"NULL\"</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> col, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            col.Constraints </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(col.Constraints, </span><span style=\"color:#B392F0\">NotNullConstraint</span><span style=\"color:#E1E4E8\">{})</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> \"UNIQUE\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            col.Constraints </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(col.Constraints, </span><span style=\"color:#B392F0\">UniqueConstraint</span><span style=\"color:#E1E4E8\">{})</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Not a constraint keyword - stop parsing constraints</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> col, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> col, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"expression-parsing-the-heart-of-the-parser\">Expression Parsing: The Heart of the Parser</h2>\n<p>This is where precedence matters. You have two approaches:</p>\n<h3 id=\"approach-1-explicit-precedence-levels-grammar-rewriting\">Approach 1: Explicit Precedence Levels (Grammar Rewriting)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// OR has lowest precedence - start here</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">parseExpression</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseOrExpression</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">parseOrExpression</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    left, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseAndExpression</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> KEYWORD </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"OR\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        right, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseAndExpression</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        left </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">BinaryExpression</span><span style=\"color:#E1E4E8\">{Operator: </span><span style=\"color:#9ECBFF\">\"OR\"</span><span style=\"color:#E1E4E8\">, Left: left, Right: right}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> left, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">parseAndExpression</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    left, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseNotExpression</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> KEYWORD </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"AND\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        right, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseNotExpression</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        left </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">BinaryExpression</span><span style=\"color:#E1E4E8\">{Operator: </span><span style=\"color:#9ECBFF\">\"AND\"</span><span style=\"color:#E1E4E8\">, Left: left, Right: right}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> left, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">parseNotExpression</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> KEYWORD </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"NOT\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        operand, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseNotExpression</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">UnaryExpression</span><span style=\"color:#E1E4E8\">{Operator: </span><span style=\"color:#9ECBFF\">\"NOT\"</span><span style=\"color:#E1E4E8\">, Operand: operand}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseComparisonExpression</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">parseComparisonExpression</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    left, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parsePrimaryExpression</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check for comparison operators</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> OPERATOR {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        op </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.current.Value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> op </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"=\"</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> op </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"&#x3C;\"</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> op </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \">\"</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> op </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"&#x3C;=\"</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> op </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \">=\"</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> op </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"!=\"</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> op </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"&#x3C;>\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            right, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parsePrimaryExpression</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">BinaryExpression</span><span style=\"color:#E1E4E8\">{Operator: op, Left: left, Right: right}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> left, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">parsePrimaryExpression</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Parenthesized expression - highest precedence</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PUNCTUATION </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"(\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expr, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseExpression</span><span style=\"color:#E1E4E8\">()  </span><span style=\"color:#6A737D\">// Start over at top</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(PUNCTUATION, </span><span style=\"color:#9ECBFF\">\")\"</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> expr, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Literals</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> NUMBER {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        val </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> parseIntOrFloat</span><span style=\"color:#E1E4E8\">(p.current.Value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">LiteralExpression</span><span style=\"color:#E1E4E8\">{Value: val}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> STRING {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        val </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.current.Value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">LiteralExpression</span><span style=\"color:#E1E4E8\">{Value: val}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> KEYWORD </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"NULL\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">LiteralExpression</span><span style=\"color:#E1E4E8\">{Value: </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Identifier (column reference)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> IDENTIFIER {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        name </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.current.Value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">IdentifierExpression</span><span style=\"color:#E1E4E8\">{Name: name}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, p.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"expected expression\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-precedence-climbing.svg\" alt=\"Expression Precedence: How AND/OR Are Parsed\"></p>\n<p>This works correctly. <code>a OR b AND c</code> is parsed as <code>a OR (b AND c)</code> because <code>parseOrExpression</code> calls <code>parseAndExpression</code> first, which binds the <code>AND</code> tighter.</p>\n<h3 id=\"approach-2-precedence-climbing-compact\">Approach 2: Precedence Climbing (Compact)</h3>\n<p>If you want a single function for all binary operators:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> precedence </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"OR\"</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"AND\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"=\"</span><span style=\"color:#E1E4E8\">:   </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"&#x3C;\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\">\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"&#x3C;=\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\">=\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"!=\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"&#x3C;>\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"NOT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Unary, handled separately</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">parseExpressionWithPrecedence</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">minPrec</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Parse left operand (handles NOT, atoms, parenthesized expressions)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    left, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseUnaryOrAtom</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // While current token is a binary operator with sufficient precedence</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        op </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.current.Value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        prec, isBinary </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> precedence[op]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">isBinary </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> prec </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> minPrec {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Parse right operand with higher precedence</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        right, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseExpressionWithPrecedence</span><span style=\"color:#E1E4E8\">(prec </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        left </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">BinaryExpression</span><span style=\"color:#E1E4E8\">{Operator: op, Left: left, Right: right}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> left, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">parseExpression</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseExpressionWithPrecedence</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\">// Start with lowest precedence</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The algorithm:</p>\n<ol>\n<li>Parse a &quot;primary&quot; expression (literal, identifier, or parenthesized)</li>\n<li>Look at the current operator—if its precedence is &gt;= <code>minPrec</code>, consume it and parse the right side</li>\n<li>For the right side, require <em>higher</em> precedence (<code>prec + 1</code>) to ensure left-associativity</li>\n<li>Loop until you hit an operator with lower precedence than <code>minPrec</code></li>\n</ol>\n<p>This single 20-line function replaces the four separate functions from Approach 1.</p>\n<hr>\n<h2 id=\"parentheses-override-precedence\">Parentheses Override Precedence</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> (active </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> OR</span><span style=\"color:#F97583\"> role</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'admin'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">AND</span><span style=\"color:#F97583\"> level</span><span style=\"color:#F97583\"> ></span><span style=\"color:#79B8FF\"> 5</span></span></code></pre></div>\n\n<p>The parentheses force the <code>OR</code> to be evaluated first, then the result is ANDed with <code>level &gt; 5</code>.</p>\n<p>In both approaches, <code>parsePrimaryExpression</code> handles parentheses by recursively calling <code>parseExpression()</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PUNCTUATION </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"(\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expr, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">parseExpression</span><span style=\"color:#E1E4E8\">()  </span><span style=\"color:#6A737D\">// Full expression inside parens</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(PUNCTUATION, </span><span style=\"color:#9ECBFF\">\")\"</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, p.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unclosed parenthesis\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> expr, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The recursive call starts precedence over from the top—anything inside parentheses is parsed as a fresh expression.</p>\n<hr>\n<h2 id=\"null-the-special-keyword\">NULL: The Special Keyword</h2>\n<p><code>NULL</code> is not an identifier. It&#39;s a keyword representing the absence of a value.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> middle_name </span><span style=\"color:#F97583\">IS</span><span style=\"color:#F97583\"> NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> deleted_at </span><span style=\"color:#F97583\">IS NOT NULL</span></span></code></pre></div>\n\n<p>Your expression parser must recognize <code>NULL</code> as a literal:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> KEYWORD </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"NULL\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">LiteralExpression</span><span style=\"color:#E1E4E8\">{Value: </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, Type: </span><span style=\"color:#9ECBFF\">\"NULL\"</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Note: <code>NULL = NULL</code> does not evaluate to TRUE in SQL—it evaluates to NULL. This three-valued logic will matter when you execute queries, but for parsing, just recognize <code>NULL</code> as a valid expression.</p>\n<hr>\n<h2 id=\"error-reporting-position-tracking\">Error Reporting: Position Tracking</h2>\n<p>When parsing fails, report <em>where</em>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> FORM users</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">--          ^^^^</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Error at line 1, column 10: unexpected token \"FORM\", expected \"FROM\"</span></span></code></pre></div>\n\n<p>Your tokenizer already attached line/column to each token. Propagate this into error messages:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">format</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#F97583\"> ...interface</span><span style=\"color:#E1E4E8\">{}) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> ParseError</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Message: fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(format, args</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Line:    p.current.Line,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Column:  p.current.Column,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>For multi-token constructs, report the <strong>start</strong> position:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">parseSelect</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SelectStatement</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    startLine </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.current.Line</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    startCol </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.current.Column</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... parsing ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">ParseError</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Message: err.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Line:    startLine,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Column:  startCol,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"ast-structure-reference\">AST Structure Reference</h2>\n<p>Your AST types should capture all the information needed for the bytecode compiler:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Statements</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Statement</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#B392F0\">isStatement</span><span style=\"color:#E1E4E8\">() }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SelectStatement</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Columns    []</span><span style=\"color:#B392F0\">ColumnSelection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FromTable  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Alias      </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">              // Optional table alias</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Where      </span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#6A737D\">          // Optional</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GroupBy    []</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#6A737D\">        // Optional</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Having     </span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#6A737D\">          // Optional</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OrderBy    []</span><span style=\"color:#B392F0\">OrderByColumn</span><span style=\"color:#6A737D\">     // Optional</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Limit      </span><span style=\"color:#F97583\">*int</span><span style=\"color:#6A737D\">                // Optional</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Offset     </span><span style=\"color:#F97583\">*int</span><span style=\"color:#6A737D\">                // Optional</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> InsertStatement</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Table    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Columns  []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Values   [][]</span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CreateTableStatement</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Table       </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IfNotExists </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Columns     []</span><span style=\"color:#B392F0\">ColumnDefinition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Expressions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Expression</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#B392F0\">isExpression</span><span style=\"color:#E1E4E8\">() }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BinaryExpression</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Operator </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">        // AND, OR, =, &#x3C;, >, etc.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Left     </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Right    </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> UnaryExpression</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Operator </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">        // NOT, - (negation)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Operand  </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LiteralExpression</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Value </span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}      </span><span style=\"color:#6A737D\">// string, int, float, nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IdentifierExpression</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">            // Column or table name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Column definitions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ColumnDefinition</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name        </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type        </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Constraints []</span><span style=\"color:#B392F0\">ColumnConstraint</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ColumnConstraint</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#B392F0\">isConstraint</span><span style=\"color:#E1E4E8\">() }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PrimaryKeyConstraint</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NotNullConstraint</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> UniqueConstraint</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"common-pitfalls\">Common Pitfalls</h2>\n<h3 id=\"1-left-recursion-in-grammar\">1. Left Recursion in Grammar</h3>\n<p><strong>Wrong:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>expression → expression AND expression | atom</code></pre></div>\n\n<p>This causes infinite recursion. The parser calls <code>parseExpression()</code>, which tries to match <code>expression AND expression</code>, which calls <code>parseExpression()</code> again with the same position.</p>\n<p><strong>Right:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>expression → atom (AND atom)*</code></pre></div>\n\n<p>Or use precedence climbing, which avoids left recursion entirely by iterating instead of recursing on the left side.</p>\n<h3 id=\"2-and-binds-tighter-than-or\">2. AND Binds Tighter Than OR</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">a </span><span style=\"color:#F97583\">OR</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">AND</span><span style=\"color:#E1E4E8\"> c</span></span></code></pre></div>\n\n<p><strong>Wrong parse:</strong> <code>(a OR b) AND c</code></p>\n<p><strong>Correct parse:</strong> <code>a OR (b AND c)</code></p>\n<p>SQL follows mathematical convention where AND is like multiplication (binds tight) and OR is like addition (binds loose). Your precedence table must reflect this.</p>\n<h3 id=\"3-null-is-not-an-identifier\">3. NULL Is Not an Identifier</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> NULL</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users</span></span></code></pre></div>\n\n<p><code>NULL</code> is a keyword, not a column name. If you try to parse it as an identifier, you&#39;ll produce a column reference instead of a null literal.</p>\n<p><strong>Fix</strong>: Check for <code>NULL</code> explicitly in your primary expression parser before checking for identifiers.</p>\n<h3 id=\"4-parentheses-require-recursive-parsing\">4. Parentheses Require Recursive Parsing</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#E1E4E8\"> ((a </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> b) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> c) </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> t</span></span></code></pre></div>\n\n<p>Each opening parenthesis starts a <strong>new</strong> expression parse at the top level. Don&#39;t try to handle nesting with explicit levels—recursion handles arbitrary depth naturally.</p>\n<hr>\n<h2 id=\"test-suite-what-to-verify\">Test Suite: What to Verify</h2>\n<p><strong>SELECT statements:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#E1E4E8\"> id, </span><span style=\"color:#F97583\">name</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> active </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> age </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 18</span><span style=\"color:#F97583\"> AND</span><span style=\"color:#F97583\"> status</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'active'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> (a </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> OR</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">AND</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">ORDER BY</span><span style=\"color:#F97583\"> name</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">LIMIT</span><span style=\"color:#79B8FF\"> 10</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> active </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> ORDER BY</span><span style=\"color:#E1E4E8\"> created_at </span><span style=\"color:#F97583\">DESC</span><span style=\"color:#F97583\"> LIMIT</span><span style=\"color:#79B8FF\"> 5</span></span></code></pre></div>\n\n<p><strong>INSERT statements:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Alice'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users (id, </span><span style=\"color:#F97583\">name</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Alice'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> logs (</span><span style=\"color:#F97583\">message</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">level</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">'Error'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'high'</span><span style=\"color:#E1E4E8\">), (</span><span style=\"color:#9ECBFF\">'Warning'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'medium'</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>CREATE TABLE statements:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> users</span><span style=\"color:#E1E4E8\"> (id </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">name</span><span style=\"color:#F97583\"> TEXT</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> users</span><span style=\"color:#E1E4E8\"> (id </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#F97583\"> PRIMARY KEY</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">name</span><span style=\"color:#F97583\"> TEXT</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> users</span><span style=\"color:#E1E4E8\"> (id </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#E1E4E8\">, email </span><span style=\"color:#F97583\">TEXT</span><span style=\"color:#F97583\"> UNIQUE</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#9ECBFF\"> \"Order Items\"</span><span style=\"color:#E1E4E8\"> (id </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#E1E4E8\">, qty </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>Expression precedence:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">-- These should parse differently</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">a </span><span style=\"color:#F97583\">OR</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">AND</span><span style=\"color:#E1E4E8\"> c            </span><span style=\"color:#6A737D\">-- a OR (b AND c)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">NOT</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b               </span><span style=\"color:#6A737D\">-- NOT (a = b), not (NOT a) = b</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">a </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">OR</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> d </span><span style=\"color:#F97583\">AND</span><span style=\"color:#E1E4E8\"> e </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> f  </span><span style=\"color:#6A737D\">-- (a = b) OR ((c = d) AND (e = f))</span></span></code></pre></div>\n\n<p><strong>Parentheses:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">(a </span><span style=\"color:#F97583\">OR</span><span style=\"color:#E1E4E8\"> b) </span><span style=\"color:#F97583\">AND</span><span style=\"color:#E1E4E8\"> c          </span><span style=\"color:#6A737D\">-- Force OR first</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">NOT</span><span style=\"color:#E1E4E8\"> (a </span><span style=\"color:#F97583\">AND</span><span style=\"color:#E1E4E8\"> b)           </span><span style=\"color:#6A737D\">-- Negate the whole AND</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">((a))                   </span><span style=\"color:#6A737D\">-- Nested parens</span></span></code></pre></div>\n\n<p><strong>Error cases:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#6A737D\">                  -- Missing column list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#6A737D\">           -- Missing table name</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> FORM users     </span><span style=\"color:#6A737D\">-- Misspelled keyword (token-level error, but parser should report position)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users (     </span><span style=\"color:#6A737D\">-- Unclosed column list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> users</span><span style=\"color:#E1E4E8\"> (id  </span><span style=\"color:#6A737D\">-- Unclosed column definition</span></span></code></pre></div>\n\n<p>Aim for <strong>15+ valid statements</strong> and <strong>10+ invalid statements</strong> that produce meaningful error messages.</p>\n<hr>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<p>You&#39;ve just built a <strong>parser</strong>—the gateway to language understanding. Here&#39;s where this connects:</p>\n<p><strong>Immediate connections:</strong></p>\n<ul>\n<li><strong>Bytecode compiler (next milestone)</strong>: Your AST is the direct input. The compiler traverses the tree depth-first, emitting opcodes for each node.</li>\n<li><strong>Error messages</strong>: The position tracking you implemented now appears in every syntax error the database reports.</li>\n</ul>\n<p><strong>Same domain:</strong></p>\n<ul>\n<li><strong>Query optimizers</strong>: Every database optimizer works on ASTs. Transformations like &quot;push WHERE predicates down&quot; or &quot;reorder JOINs&quot; are tree rewrites on the structure you just learned to build.</li>\n<li><strong>SQL dialects</strong>: MySQL, PostgreSQL, SQLite, and SQL Server all parse into similar ASTs but with dialect-specific nodes. Understanding AST structure lets you write cross-database tools.</li>\n</ul>\n<p><strong>Cross-domain:</strong></p>\n<ul>\n<li><strong>Spreadsheet formulas</strong>: <code>=A1+B2*C3</code> has the same precedence challenges. Excel&#39;s formula parser uses the same precedence climbing algorithm.</li>\n<li><strong>Linter and static analysis tools</strong>: ESLint, pylint, and SQL linters all parse code into ASTs, then walk the tree looking for patterns. You could now build a SQL linter that detects <code>SELECT *</code> on production tables.</li>\n<li><strong>Prepared statements</strong>: When you run <code>db.prepare(&quot;SELECT ...&quot;)</code>, the database parses once and caches the AST. Subsequent executions skip parsing. Your AST structure is what gets cached.</li>\n<li><strong>SQL translation</strong>: Converting MySQL&#39;s `` backtick quotes to PostgreSQL&#39;s &quot;double quotes&quot; or SQLite&#39;s [brackets] requires parsing, transforming the AST, and re-serializing. The AST is the common representation.</li>\n</ul>\n<p><strong>Forward:</strong></p>\n<ul>\n<li><strong>With this knowledge, you could now build</strong>: A SQL formatter/prettifier (walk the AST, pretty-print), a SQL linter that enforces style rules, a schema migration tool that parses <code>CREATE TABLE</code> and compares schemas, or a query builder that constructs ASTs programmatically instead of string concatenation.</li>\n</ul>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-sqlite-m3 -->\n<h1 id=\"milestone-3-bytecode-compiler-vdbe\">Milestone 3: Bytecode Compiler (VDBE)</h1>\n<h2 id=\"where-we-are-in-the-system\">Where We Are in the System</h2>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-satellite-overview.svg\" alt=\"SQLite Architecture: The Complete System Map\"></p>\n<p>Your parser hands you a beautiful AST—a tree structure that captures the <em>meaning</em> of a SQL statement. Now comes a critical architectural decision: <strong>how do you execute this tree?</strong></p>\n<p>The naive approach is a <strong>tree-walking interpreter</strong>: recursively evaluate each AST node. For <code>SELECT * FROM users WHERE age &gt; 18</code>, you&#39;d walk the SELECT node, which walks the WHERE node, which walks the comparison node, which walks the identifier and literal nodes. Simple, clean, obvious.</p>\n<p>SQLite does something different. It <strong>compiles the AST into bytecode</strong> and executes that bytecode on a <strong>virtual machine</strong>—the Virtual Database Engine (VDBE). This extra compilation step is not premature optimization. It&#39;s architectural necessity.</p>\n<hr>\n<h2 id=\"the-revelation-why-bytecode-not-tree-walking\">The Revelation: Why Bytecode, Not Tree Walking?</h2>\n<p>Here&#39;s what most developers assume: &quot;Databases interpret SQL directly. Bytecode is overkill for a simple database—just recursively evaluate AST nodes.&quot;</p>\n<p>This assumption is wrong for three reasons.</p>\n<h3 id=\"reason-1-caching-amortizes-compilation-cost\">Reason 1: Caching Amortizes Compilation Cost</h3>\n<p>Consider a web application that runs the same parameterized query 10,000 times per minute:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ?</span></span></code></pre></div>\n\n<p>A tree-walking interpreter parses and validates the AST on <em>every</em> execution. That&#39;s 10,000 parses per minute of the identical structure.</p>\n<p>With bytecode compilation:</p>\n<ol>\n<li>Parse once → AST</li>\n<li>Compile once → bytecode program</li>\n<li>Execute 10,000 times with different parameters</li>\n</ol>\n<p>The bytecode program is a flat array of instructions. Caching it is trivial—store it keyed by the SQL text. SQLite&#39;s prepared statements are exactly this: cached bytecode programs waiting for parameters.</p>\n<h3 id=\"reason-2-the-vm-provides-a-clean-abstraction-boundary\">Reason 2: The VM Provides a Clean Abstraction Boundary</h3>\n<p>Your database has multiple moving parts:</p>\n<ul>\n<li><strong>Frontend</strong>: Tokenizer, parser, compiler</li>\n<li><strong>Execution</strong>: Virtual machine</li>\n<li><strong>Storage</strong>: B-trees, buffer pool, WAL</li>\n</ul>\n<p>With bytecode, the compiler knows nothing about B-tree internals. It emits high-level opcodes like <code>OpenTable</code>, <code>Column</code>, <code>Next</code>. The VM translates these into storage engine calls. Want to swap the storage engine? The compiler doesn&#39;t change. Want to add a new SQL feature? The storage engine doesn&#39;t change.</p>\n<p>This decoupling is why SQLite can support multiple storage formats (rollback journal vs WAL) without rewriting the compiler.</p>\n<h3 id=\"reason-3-optimization-opportunities\">Reason 3: Optimization Opportunities</h3>\n<p>Tree-walking interpreters evaluate nodes as they encounter them. Bytecode compilation enables optimizations <em>before</em> execution:</p>\n<ul>\n<li><strong>Instruction combining</strong>: <code>Column</code> followed by <code>Column</code> on the same row can be optimized</li>\n<li><strong>Dead code elimination</strong>: <code>WHERE 1=1</code> compiles to no conditional jump at all</li>\n<li><strong>Register allocation</strong>: Intermediate values are placed in numbered registers, enabling efficient memory access patterns</li>\n</ul>\n<p>{{DIAGRAM:diag-query-execution-pipeline}}</p>\n<hr>\n<h2 id=\"the-tension-compilation-time-vs-execution-speed\">The Tension: Compilation Time vs Execution Speed</h2>\n<p>Every design decision is a tradeoff. Bytecode compilation introduces overhead: you must traverse the AST, generate instructions, and allocate registers <em>before</em> any rows are processed.</p>\n<p>For a query that returns one row, this overhead might be 50% of total execution time. For a query that scans a million rows, the overhead is negligible.</p>\n<p><strong>The constraint</strong>: Compilation must be fast enough that one-time queries aren&#39;t noticeably slow, while the generated bytecode must be efficient enough to handle large datasets.</p>\n<p>SQLite&#39;s solution: a <strong>simple compiler</strong> with linear-time algorithms. No complex optimizations, just straightforward code generation. The bytecode is &quot;good enough&quot;—not optimal, but fast to produce and fast to execute.</p>\n<hr>\n<h2 id=\"the-instruction-set-your-vm39s-vocabulary\">The Instruction Set: Your VM&#39;s Vocabulary</h2>\n<p>{{DIAGRAM:diag-bytecode-instruction-set}}</p>\n<p>The VDBE instruction set is deliberately small—about 180 opcodes in real SQLite, but you&#39;ll implement around 20-30 for this project. Each instruction has:</p>\n<ul>\n<li><strong>Opcode</strong>: What operation to perform</li>\n<li><strong>P1, P2, P3</strong>: Operands (register numbers, page numbers, column indexes)</li>\n<li><strong>P4</strong>: Optional string or pointer operand</li>\n<li><strong>Comment</strong>: Human-readable description (for EXPLAIN)</li>\n</ul>\n<p>Here are the core opcodes you&#39;ll implement:</p>\n<table>\n<thead>\n<tr>\n<th>Opcode</th>\n<th>P1</th>\n<th>P2</th>\n<th>P3</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>OpenTable</strong></td>\n<td>cursor#</td>\n<td>root page</td>\n<td>0</td>\n<td>Open a B-tree cursor on table</td>\n</tr>\n<tr>\n<td><strong>Close</strong></td>\n<td>cursor#</td>\n<td></td>\n<td></td>\n<td>Close a cursor</td>\n</tr>\n<tr>\n<td><strong>Rewind</strong></td>\n<td>cursor#</td>\n<td>jump target</td>\n<td></td>\n<td>Position cursor before first row; jump if empty</td>\n</tr>\n<tr>\n<td><strong>Column</strong></td>\n<td>cursor#</td>\n<td>column#</td>\n<td>dest reg</td>\n<td>Read column value into register</td>\n</tr>\n<tr>\n<td><strong>ResultRow</strong></td>\n<td>start reg</td>\n<td>count</td>\n<td></td>\n<td>Output current result row</td>\n</tr>\n<tr>\n<td><strong>Next</strong></td>\n<td>cursor#</td>\n<td>jump target</td>\n<td></td>\n<td>Advance cursor; jump if more rows</td>\n</tr>\n<tr>\n<td><strong>Halt</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td>End program execution</td>\n</tr>\n<tr>\n<td><strong>MakeRecord</strong></td>\n<td>start reg</td>\n<td>count</td>\n<td>dest reg</td>\n<td>Serialize registers into a record</td>\n</tr>\n<tr>\n<td><strong>Insert</strong></td>\n<td>cursor#</td>\n<td>record reg</td>\n<td></td>\n<td>Insert record at cursor position</td>\n</tr>\n<tr>\n<td><strong>Delete</strong></td>\n<td>cursor#</td>\n<td></td>\n<td></td>\n<td>Delete row at cursor position</td>\n</tr>\n<tr>\n<td><strong>Integer</strong></td>\n<td>value</td>\n<td>dest reg</td>\n<td></td>\n<td>Load integer constant</td>\n</tr>\n<tr>\n<td><strong>String8</strong></td>\n<td></td>\n<td>dest reg</td>\n<td>string</td>\n<td>Load string constant</td>\n</tr>\n<tr>\n<td><strong>Null</strong></td>\n<td>dest reg</td>\n<td></td>\n<td></td>\n<td>Load NULL into register</td>\n</tr>\n<tr>\n<td><strong>Eq/Ne/Lt/Le/Gt/Ge</strong></td>\n<td>reg1</td>\n<td>jump target</td>\n<td>reg2</td>\n<td>Compare registers; jump if condition true</td>\n</tr>\n<tr>\n<td><strong>Goto</strong></td>\n<td>target</td>\n<td></td>\n<td></td>\n<td>Unconditional jump</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"three-level-view-from-ast-to-bytecode-to-execution\">Three-Level View: From AST to Bytecode to Execution</h2>\n<table>\n<thead>\n<tr>\n<th>Level</th>\n<th>What Happens</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Compiler</strong></td>\n<td>Traverses AST, emits instructions</td>\n<td>SELECT → OpenTable, Rewind, Column loop, Halt</td>\n</tr>\n<tr>\n<td><strong>Bytecode</strong></td>\n<td>Flat array of instructions</td>\n<td><code>[0] OpenTable 0 2 0</code>, <code>[1] Rewind 0 5</code>, ...</td>\n</tr>\n<tr>\n<td><strong>VM</strong></td>\n<td>Fetch-decode-execute cycle</td>\n<td>Read instruction, dispatch to handler, update PC</td>\n</tr>\n</tbody></table>\n<p>The compiler is a <strong>depth-first AST walker</strong> that emits instructions as it goes. The VM is a <strong>simple loop</strong> that reads and executes instructions one at a time.</p>\n<hr>\n<h2 id=\"building-the-compiler-select-statements\">Building the Compiler: SELECT Statements</h2>\n<p>Consider this SQL:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#E1E4E8\"> id, </span><span style=\"color:#F97583\">name</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> age </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 18</span></span></code></pre></div>\n\n<p>The compiler must produce bytecode that:</p>\n<ol>\n<li>Opens a cursor on the <code>users</code> table</li>\n<li>Positions the cursor before the first row</li>\n<li>For each row: reads columns, evaluates WHERE, outputs if matched</li>\n<li>Closes the cursor and halts</li>\n</ol>\n<h3 id=\"step-by-step-compilation\">Step-by-Step Compilation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Compiler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">compileSelect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">SelectStatement</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> program []</span><span style=\"color:#B392F0\">Instruction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Open cursor on the table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // P1=0 (cursor number), P2=2 (root page of 'users' table)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    program </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(program, </span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Opcode: </span><span style=\"color:#9ECBFF\">\"OpenTable\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        P1:     </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Cursor 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        P2:     c.</span><span style=\"color:#B392F0\">getTableRootPage</span><span style=\"color:#E1E4E8\">(stmt.FromTable),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        P3:     </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Comment: fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"table=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, stmt.FromTable),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Rewind cursor (position before first row)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // P2 is the instruction to jump to if table is empty</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rewindPC </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(program)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    program </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(program, </span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Opcode: </span><span style=\"color:#9ECBFF\">\"Rewind\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        P1:     </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Cursor 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        P2:     </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Will patch this later (jump to Halt if empty)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Comment: </span><span style=\"color:#9ECBFF\">\"jump to Halt if empty\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Compile WHERE clause (if exists)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This emits comparison and conditional jump instructions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If WHERE evaluates to false, jump to Next instruction</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> whereJumpTarget </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> stmt.Where </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        whereStartPC </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(program)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.</span><span style=\"color:#B392F0\">compileExpression</span><span style=\"color:#E1E4E8\">(program, stmt.Where, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\">// Result in register 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Conditional jump: if condition is false/NULL, skip to Next</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        program </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(program, </span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Opcode: </span><span style=\"color:#9ECBFF\">\"IfNot\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Jump if register 0 is false or NULL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            P1:     </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,        </span><span style=\"color:#6A737D\">// Register with condition result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            P2:     </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,        </span><span style=\"color:#6A737D\">// Will patch: jump to Next</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Comment: </span><span style=\"color:#9ECBFF\">\"skip row if WHERE false\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        whereJumpTarget </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(program) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Read columns and output row</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For \"SELECT id, name\", read columns into registers 1, 2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, col </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> stmt.Columns {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        colIndex </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">getColumnIndex</span><span style=\"color:#E1E4E8\">(stmt.FromTable, col.Name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        program </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(program, </span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Opcode: </span><span style=\"color:#9ECBFF\">\"Column\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            P1:     </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,     </span><span style=\"color:#6A737D\">// Cursor 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            P2:     colIndex,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            P3:     i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// Destination register</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Comment: fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"col=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -> r</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, col.Name, i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Output the result row</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    program </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(program, </span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Opcode: </span><span style=\"color:#9ECBFF\">\"ResultRow\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        P1:     </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Start register</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        P2:     </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(stmt.Columns),  </span><span style=\"color:#6A737D\">// Number of registers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Comment: fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"output </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> columns\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(stmt.Columns)),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 6. Next: advance cursor and loop back</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nextPC </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(program)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    program </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(program, </span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Opcode: </span><span style=\"color:#9ECBFF\">\"Next\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        P1:     </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Cursor 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        P2:     rewindPC </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Jump back to start of loop (after Rewind)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Comment: </span><span style=\"color:#9ECBFF\">\"loop back to process next row\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 7. Halt</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    haltPC </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(program)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    program </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(program, </span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Opcode: </span><span style=\"color:#9ECBFF\">\"Halt\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Comment: </span><span style=\"color:#9ECBFF\">\"end of query\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 8. Patch jump targets</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    program[rewindPC].P2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> haltPC  </span><span style=\"color:#6A737D\">// Rewind jumps to Halt if empty</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> stmt.Where </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        program[whereJumpTarget].P2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> nextPC  </span><span style=\"color:#6A737D\">// WHERE false jumps to Next</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> program, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"the-compiled-bytecode\">The Compiled Bytecode</h3>\n<p>For <code>SELECT id, name FROM users WHERE age &gt; 18</code>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>addr  opcode      p1  p2  p3  comment\n----  ----------  --  --  --  -------\n0     OpenTable   0   2   0   table=users\n1     Rewind      0   9   0   jump to 9 if empty\n2     Column      0   2   0   col=age -&gt; r0\n3     Integer     18  1   0   r1 = 18\n4     Gt          0   6   1   if r0&gt;r1 goto 6\n5     Goto        0   8   0   skip to Next (row doesn't match)\n6     Column      0   0   1   col=id -&gt; r1\n7     Column      0   1   2   col=name -&gt; r2\n8     ResultRow   1   2   0   output 2 columns\n9     Next        0   2   0   loop back to instruction 2\n10    Halt        0   0   0   end</code></pre></div>\n\n\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-bytecode-compiled-example.svg\" alt=\"Trace Example: SELECT * WHERE id > 5\"></p>\n<p>Trace through this with a 3-row table where ages are [25, 15, 30]:</p>\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>PC</th>\n<th>Instruction</th>\n<th>Action</th>\n<th>Result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>0</td>\n<td>OpenTable</td>\n<td>Open cursor 0 on users</td>\n<td>Cursor ready</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1</td>\n<td>Rewind</td>\n<td>Position before row 1</td>\n<td>Not empty, continue</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2</td>\n<td>Column</td>\n<td>Read age (25) into r0</td>\n<td>r0=25</td>\n</tr>\n<tr>\n<td>4</td>\n<td>3</td>\n<td>Integer</td>\n<td>Load 18 into r1</td>\n<td>r1=18</td>\n</tr>\n<tr>\n<td>5</td>\n<td>4</td>\n<td>Gt</td>\n<td>25 &gt; 18? Yes</td>\n<td>Don&#39;t jump</td>\n</tr>\n<tr>\n<td>6</td>\n<td>6</td>\n<td>Column</td>\n<td>Read id into r1</td>\n<td>r1=1</td>\n</tr>\n<tr>\n<td>7</td>\n<td>7</td>\n<td>Column</td>\n<td>Read name into r2</td>\n<td>r2=&quot;Alice&quot;</td>\n</tr>\n<tr>\n<td>8</td>\n<td>8</td>\n<td>ResultRow</td>\n<td>Output r1, r2</td>\n<td>Emit row (1, &quot;Alice&quot;)</td>\n</tr>\n<tr>\n<td>9</td>\n<td>9</td>\n<td>Next</td>\n<td>Advance to row 2</td>\n<td>More rows, jump to 2</td>\n</tr>\n<tr>\n<td>10</td>\n<td>2</td>\n<td>Column</td>\n<td>Read age (15) into r0</td>\n<td>r0=15</td>\n</tr>\n<tr>\n<td>11</td>\n<td>3</td>\n<td>Integer</td>\n<td>Load 18 into r1</td>\n<td>r1=18</td>\n</tr>\n<tr>\n<td>12</td>\n<td>4</td>\n<td>Gt</td>\n<td>15 &gt; 18? No</td>\n<td>Jump to 6</td>\n</tr>\n<tr>\n<td>13</td>\n<td>6</td>\n<td>Goto</td>\n<td>Unconditional jump</td>\n<td>Go to 8</td>\n</tr>\n<tr>\n<td>14</td>\n<td>8</td>\n<td>Next</td>\n<td>Advance to row 3</td>\n<td>More rows, jump to 2</td>\n</tr>\n<tr>\n<td>15</td>\n<td>2-8</td>\n<td>...</td>\n<td>Process row 3 (age=30)</td>\n<td>Emit row (3, &quot;Charlie&quot;)</td>\n</tr>\n<tr>\n<td>16</td>\n<td>9</td>\n<td>Next</td>\n<td>No more rows</td>\n<td>Don&#39;t jump, continue</td>\n</tr>\n<tr>\n<td>17</td>\n<td>10</td>\n<td>Halt</td>\n<td>End execution</td>\n<td>Done</td>\n</tr>\n</tbody></table>\n<p>Two rows emitted: (1, &quot;Alice&quot;) and (3, &quot;Charlie&quot;).</p>\n<hr>\n<h2 id=\"building-the-compiler-insert-statements\">Building the Compiler: INSERT Statements</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users (id, </span><span style=\"color:#F97583\">name</span><span style=\"color:#E1E4E8\">, age) </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Diana'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">28</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p>The compilation strategy:</p>\n<ol>\n<li>Load the VALUES into registers</li>\n<li>Create a record (serialized row) from those registers</li>\n<li>Insert the record into the table&#39;s B-tree</li>\n<li>Halt</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Compiler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">compileInsert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">InsertStatement</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> program []</span><span style=\"color:#B392F0\">Instruction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Open cursor on the table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    program </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(program, </span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Opcode: </span><span style=\"color:#9ECBFF\">\"OpenTable\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        P1:     </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Cursor 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        P2:     c.</span><span style=\"color:#B392F0\">getTableRootPage</span><span style=\"color:#E1E4E8\">(stmt.Table),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        P3:     </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Comment: fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"table=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, stmt.Table),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Load VALUES into registers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For simplicity, assume single-row INSERT</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    values </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> stmt.Values[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, val </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> values {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.</span><span style=\"color:#B392F0\">compileLiteral</span><span style=\"color:#E1E4E8\">(program, val, i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\">// Registers 1, 2, 3, ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. MakeRecord: serialize registers into a record</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    program </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(program, </span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Opcode: </span><span style=\"color:#9ECBFF\">\"MakeRecord\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        P1:     </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Start register</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        P2:     </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(values),  </span><span style=\"color:#6A737D\">// Number of registers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        P3:     </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Destination register (record in r0)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Comment: fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"create record from </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> values\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(values)),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Insert the record</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    program </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(program, </span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Opcode: </span><span style=\"color:#9ECBFF\">\"Insert\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        P1:     </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Cursor 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        P2:     </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Register with record</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        P3:     </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Comment: </span><span style=\"color:#9ECBFF\">\"insert record into table\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Close and Halt</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    program </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(program, </span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Opcode: </span><span style=\"color:#9ECBFF\">\"Close\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        P1:     </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    program </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(program, </span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Opcode: </span><span style=\"color:#9ECBFF\">\"Halt\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> program, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Compiled bytecode for <code>INSERT INTO users (id, name, age) VALUES (4, &#39;Diana&#39;, 28)</code>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>addr  opcode      p1  p2  p3  p4        comment\n----  ----------  --  --  --  --------  -------\n0     OpenTable   0   2   0             table=users\n1     Integer     4   1   0             r1 = 4\n2     String8     0   2   0   Diana     r2 = &quot;Diana&quot;\n3     Integer     28  3   0             r3 = 28\n4     MakeRecord  1   3   0             record from r1-r3 -&gt; r0\n5     Insert      0   0   0             insert r0 into cursor 0\n6     Close       0   0   0             \n7     Halt        0   0   0</code></pre></div>\n\n<hr>\n<h2 id=\"building-the-virtual-machine\">Building the Virtual Machine</h2>\n<p>The VM is beautifully simple: a fetch-decode-execute loop.</p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-vm-fetch-decode-execute.svg\" alt=\"VDBE Execution Cycle\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> VM</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Program    []</span><span style=\"color:#B392F0\">Instruction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PC         </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">           // Program counter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Registers  []</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#6A737D\">       // Register file (typed values)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Cursors    []</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Cursor</span><span style=\"color:#6A737D\">     // Open cursors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Halted     </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Output     </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#6A737D\">// Callback for ResultRow</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type  </span><span style=\"color:#B392F0\">ValueType</span><span style=\"color:#6A737D\">  // INTEGER, TEXT, REAL, BLOB, NULL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Int   </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Float </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Str   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Bytes []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">vm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VM</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Run</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">vm.Halted </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> vm.PC </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(vm.Program) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        instr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.Program[vm.PC]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">execute</span><span style=\"color:#E1E4E8\">(instr); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">vm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VM</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">instr</span><span style=\"color:#B392F0\"> Instruction</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> instr.Opcode {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"Halt\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vm.Halted </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"Goto\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vm.PC </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> instr.P2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#6A737D\">  // Don't increment PC</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"Integer\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vm.Registers[instr.P2] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: INTEGER, Int: </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(instr.P1)}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"String8\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vm.Registers[instr.P2] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: TEXT, Str: instr.P4.(</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">)}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"Null\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vm.Registers[instr.P1] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: NULL}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"OpenTable\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.storage.</span><span style=\"color:#B392F0\">OpenTable</span><span style=\"color:#E1E4E8\">(instr.P2)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vm.Cursors[instr.P1] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cursor</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"Close\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vm.Cursors[instr.P1] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"Rewind\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.Cursors[instr.P1]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">cursor.</span><span style=\"color:#B392F0\">Rewind</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Table is empty, jump to P2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            vm.PC </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> instr.P2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"Next\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.Cursors[instr.P1]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> cursor.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            vm.PC </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> instr.P2  </span><span style=\"color:#6A737D\">// Jump back to loop start</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // No more rows, continue to next instruction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"Column\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.Cursors[instr.P1]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        value </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cursor.</span><span style=\"color:#B392F0\">GetColumn</span><span style=\"color:#E1E4E8\">(instr.P2)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vm.Registers[instr.P3] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"ResultRow\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        row </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">, instr.P2)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> instr.P2; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            row[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> vm.Registers[instr.P1 </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> i]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vm.</span><span style=\"color:#B392F0\">Output</span><span style=\"color:#E1E4E8\">(row)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"MakeRecord\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Serialize registers [P1, P1+P2-1] into a record</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">serializeRecord</span><span style=\"color:#E1E4E8\">(vm.Registers[instr.P1 : instr.P1</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">instr.P2])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vm.Registers[instr.P3] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: BLOB, Bytes: record}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"Insert\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.Cursors[instr.P1]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.Registers[instr.P2].Bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor.</span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"Eq\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Ne\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Lt\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Le\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Gt\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Ge\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        left </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.Registers[instr.P1]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        right </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.Registers[instr.P3]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">compare</span><span style=\"color:#E1E4E8\">(instr.Opcode, left, right) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            vm.PC </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> instr.P2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unknown opcode: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, instr.Opcode)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm.PC</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"the-register-file\">The Register File</h3>\n<p>The VM uses a <strong>register-based</strong> architecture (not stack-based). This means:</p>\n<ul>\n<li>Instructions specify exactly which registers to read/write</li>\n<li>Intermediate values persist across instructions</li>\n<li>Register allocation happens at compile time</li>\n</ul>\n<p>For <code>SELECT id, name FROM users WHERE age &gt; 18</code>:</p>\n<ul>\n<li>Register 0: Temporary (WHERE condition result, then age value)</li>\n<li>Register 1: id column value</li>\n<li>Register 2: name column value</li>\n<li>Register 3: Literal 18 for comparison</li>\n</ul>\n<p>The compiler decides which register holds what. The VM just executes.</p>\n<hr>\n<h2 id=\"where-clause-compilation-conditional-jumps\">WHERE Clause Compilation: Conditional Jumps</h2>\n<p>The WHERE clause is where control flow gets interesting. Consider:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> age </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 18</span><span style=\"color:#F97583\"> AND</span><span style=\"color:#F97583\"> status</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'active'</span></span></code></pre></div>\n\n<p>The compiler must emit:</p>\n<ol>\n<li>Code to evaluate <code>age &gt; 18</code> (true/false/NULL in a register)</li>\n<li>Conditional jump to skip the row if false</li>\n<li>Code to evaluate <code>status = &#39;active&#39;</code></li>\n<li>Conditional jump to skip the row if false</li>\n<li>If we reach here, both conditions passed → output the row</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Compiler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">compileWhereClause</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">program</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">[]</span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">where</span><span style=\"color:#B392F0\"> Expression</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">skipTarget</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> expr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> where.(</span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">BinaryExpression</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> expr.Operator </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"AND\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Compile left side; if false, jump to skip</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            c.</span><span style=\"color:#B392F0\">compileWhereClause</span><span style=\"color:#E1E4E8\">(program, expr.Left, skipTarget)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Compile right side; if false, jump to skip</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            c.</span><span style=\"color:#B392F0\">compileWhereClause</span><span style=\"color:#E1E4E8\">(program, expr.Right, skipTarget)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> expr.Operator </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"OR\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // More complex: need a label for \"success\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // If left is true, jump to success</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // If left is false, check right</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // If right is true, jump to success</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Otherwise, skip</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // (simplified here)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Comparison operator: =, &#x3C;, >, etc.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            c.</span><span style=\"color:#B392F0\">compileExpression</span><span style=\"color:#E1E4E8\">(program, expr.Left, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)   </span><span style=\"color:#6A737D\">// Result in r0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            c.</span><span style=\"color:#B392F0\">compileExpression</span><span style=\"color:#E1E4E8\">(program, expr.Right, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\">// Result in r1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Emit comparison with negated jump</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // If NOT (r0 op r1), skip this row</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            *</span><span style=\"color:#E1E4E8\">program </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">program, </span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Opcode: c.</span><span style=\"color:#B392F0\">negateOperator</span><span style=\"color:#E1E4E8\">(expr.Operator),  </span><span style=\"color:#6A737D\">// Gt -> Le, Eq -> Ne, etc.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                P1:     </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                P2:     skipTarget,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                P3:     </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Comment: fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"skip if NOT </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, expr.Operator),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The key insight: <strong>WHERE compilation emits early-exit jumps</strong>. Each condition that fails jumps immediately to the <code>Next</code> instruction. Only rows that pass all conditions reach <code>ResultRow</code>.</p>\n<hr>\n<h2 id=\"explain-making-bytecode-visible\">EXPLAIN: Making Bytecode Visible</h2>\n<p>The <code>EXPLAIN</code> command is your debugging superpower. It shows exactly what bytecode the compiler generated:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">EXPLAIN </span><span style=\"color:#F97583\">SELECT</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> age </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 18</span></span></code></pre></div>\n\n<p>Output:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>addr  opcode      p1  p2  p3  p4\n----  ----------  --  --  --  -------\n0     OpenTable   0   2   0   \n1     Rewind      0   7   0   \n2     Column      0   2   0   \n3     Integer     18  1   0   \n4     Le          0   6   1   skip if age &lt;= 18\n5     Column      0   0   1   \n6     ResultRow   1   1   0   \n7     Next        0   2   0   \n8     Halt        0   0   0</code></pre></div>\n\n<p>Implementation is trivial—just print the program:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Compiler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Explain</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">program</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> buf </span><span style=\"color:#B392F0\">strings</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Builder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"addr  opcode      p1  p2  p3  p4</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"----  ----------  --  --  --  -------</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, instr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> program {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%-4d</span><span style=\"color:#79B8FF\">  %-10s</span><span style=\"color:#79B8FF\">  %-2d</span><span style=\"color:#79B8FF\">  %-2d</span><span style=\"color:#79B8FF\">  %-2d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            i, instr.Opcode, instr.P1, instr.P2, instr.P3))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> instr.P4 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, instr.P4))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> instr.Comment </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  ; </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, instr.Comment))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> buf.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>When a query doesn&#39;t do what you expect, <code>EXPLAIN</code> reveals the exact execution plan. This is how database engineers debug query performance.</p>\n<hr>\n<h2 id=\"performance-target-10000-rows-in-100ms\">Performance Target: 10,000 Rows in 100ms</h2>\n<p>The acceptance criteria state: &quot;Bytecode execution of <code>SELECT * FROM t</code> on a 10,000-row table completes in under 100ms.&quot;</p>\n<p>This translates to <strong>100,000 rows per second</strong> or <strong>10 microseconds per row</strong>. On modern hardware, this is achievable with straightforward bytecode execution—the VM loop is tight, and row operations are simple.</p>\n<p>What <em>will</em> kill performance:</p>\n<ul>\n<li><strong>Excessive memory allocation</strong>: Allocating a new object per row</li>\n<li><strong>String copies</strong>: Copying column values unnecessarily</li>\n<li><strong>Branch misprediction</strong>: Irregular jump patterns</li>\n</ul>\n<p>What&#39;s fine:</p>\n<ul>\n<li><strong>The fetch-decode-execute loop itself</strong>: A few nanoseconds per instruction</li>\n<li><strong>Cursor operations</strong>: B-tree traversal is O(log n) for seeks, O(1) for Next</li>\n<li><strong>Register access</strong>: Array indexing is essentially free</li>\n</ul>\n<p>The benchmark:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> BenchmarkTableScan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">b</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">B</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create table with 10,000 rows</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDatabase</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10000</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    count </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM t\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">row</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        count</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    elapsed </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Since</span><span style=\"color:#E1E4E8\">(start)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fmt.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Scanned </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> rows in </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">%.0f</span><span style=\"color:#9ECBFF\"> rows/sec)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        count, elapsed, </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">(count)</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">elapsed.</span><span style=\"color:#B392F0\">Seconds</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>If you&#39;re not hitting 100,000 rows/sec, profile to find the bottleneck. It&#39;s usually in the storage layer (B-tree page fetches), not the VM loop.</p>\n<hr>\n<h2 id=\"common-pitfalls\">Common Pitfalls</h2>\n<h3 id=\"1-missing-the-halt-opcode\">1. Missing the Halt Opcode</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">program </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(program, </span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">{Opcode: </span><span style=\"color:#9ECBFF\">\"Halt\"</span><span style=\"color:#E1E4E8\">})</span></span></code></pre></div>\n\n<p>Forget this, and the VM will run past the end of your program into garbage memory. The <code>PC &lt; len(Program)</code> check catches this, but a proper <code>Halt</code> is cleaner.</p>\n<h3 id=\"2-forgetting-to-patch-jump-targets\">2. Forgetting to Patch Jump Targets</h3>\n<p>Jump targets often aren&#39;t known when you emit the instruction:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">rewindPC </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(program)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">program </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(program, </span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">{Opcode: </span><span style=\"color:#9ECBFF\">\"Rewind\"</span><span style=\"color:#E1E4E8\">, P2: ???})</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ... more code ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">haltPC </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(program)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">program </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(program, </span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">{Opcode: </span><span style=\"color:#9ECBFF\">\"Halt\"</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NOW patch the Rewind</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">program[rewindPC].P2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> haltPC</span></span></code></pre></div>\n\n<p>Forgetting to patch means the Rewind jumps to address 0 (or garbage), causing infinite loops or crashes.</p>\n<h3 id=\"3-register-clobbering\">3. Register Clobbering</h3>\n<p>If you use register 0 for the WHERE condition, then use register 0 for something else before the conditional jump, you&#39;ve clobbered your condition.</p>\n<p><strong>Fix</strong>: Use a consistent register allocation strategy. Simple approach: reserve low registers for temporaries, use higher registers for column values.</p>\n<h3 id=\"4-three-valued-logic-in-comparisons\">4. Three-Valued Logic in Comparisons</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> age </span><span style=\"color:#F97583\">></span><span style=\"color:#F97583\"> NULL</span></span></code></pre></div>\n\n<p>This evaluates to NULL, not FALSE. The <code>Gt</code> opcode must handle NULL correctly: if either operand is NULL, the comparison result is NULL, and <code>IfNot</code> (jump if false/NULL) should skip the row.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">vm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VM</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">compare</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">op</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">left</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">right</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> left.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> NULL </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> right.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> NULL {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // NULL compared to anything is NULL (not true, not false)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // The IfNot opcode treats NULL as \"not true\", so it will jump</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... actual comparison ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"test-suite-what-to-verify\">Test Suite: What to Verify</h2>\n<p><strong>SELECT compilation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users                    </span><span style=\"color:#6A737D\">-- Full table scan</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#E1E4E8\"> id, </span><span style=\"color:#F97583\">name</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users             </span><span style=\"color:#6A737D\">-- Projection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#6A737D\">       -- Equality filter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> age </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 18</span><span style=\"color:#6A737D\">     -- Range filter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> AND</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#6A737D\">  -- AND condition</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">ORDER BY</span><span style=\"color:#F97583\"> name</span><span style=\"color:#6A737D\">      -- (Later milestone)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">LIMIT</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#6A737D\">           -- (Later milestone)</span></span></code></pre></div>\n\n<p><strong>INSERT compilation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Alice'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">25</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users (id, </span><span style=\"color:#F97583\">name</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Alice'</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>EXPLAIN output:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">EXPLAIN </span><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Should show OpenTable, Rewind, Column, ResultRow, Next, Halt</span></span></code></pre></div>\n\n<p><strong>Execution correctness:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Insert 10 rows</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (1, 'A')\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ... 9 more ...</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Query and verify</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> results []</span><span style=\"color:#B392F0\">Row</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM users\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">row</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    results </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(results, row)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(results))</span></span></code></pre></div>\n\n<p><strong>Performance:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// 10,000 row table scan in &#x3C; 100ms</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDatabase</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10000</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">start </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">count </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM t\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">row</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) { count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Less</span><span style=\"color:#E1E4E8\">(t, time.</span><span style=\"color:#B392F0\">Since</span><span style=\"color:#E1E4E8\">(start).</span><span style=\"color:#B392F0\">Milliseconds</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">))</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<p>You&#39;ve just built a <strong>bytecode compiler and virtual machine</strong>—the execution engine at the heart of many language runtimes. Here&#39;s where this connects:</p>\n<p><strong>Immediate connections:</strong></p>\n<ul>\n<li><strong>Query planner (Milestone 8)</strong>: The planner chooses between different bytecode programs (table scan vs index scan). The VM executes whatever it&#39;s given.</li>\n<li><strong>Storage engine (Milestones 4-5)</strong>: The VM&#39;s <code>OpenTable</code>, <code>Column</code>, <code>Next</code> opcodes call into the B-tree layer. The compiler doesn&#39;t know how B-trees work.</li>\n</ul>\n<p><strong>Same domain:</strong></p>\n<ul>\n<li><strong>Query plan caching</strong>: Your bytecode programs can be cached. Real SQLite stores prepared statements as bytecode, reusing them for repeated queries with different parameters.</li>\n<li><strong>EXPLAIN in all databases</strong>: Every database&#39;s <code>EXPLAIN</code> shows its internal execution plan. PostgreSQL shows a tree of plan nodes; SQLite shows bytecode. Both reveal <em>how</em> the query will execute.</li>\n</ul>\n<p><strong>Cross-domain:</strong></p>\n<ul>\n<li><strong>Java JVM and .NET CLR</strong>: The same bytecode-VM architecture powers enterprise applications. Java compiles to JVM bytecode; C# compiles to IL. Both are stack-based (SQLite is register-based), but the principle is identical: compile once, execute many times.</li>\n<li><strong>JIT compilation in modern databases</strong>: Bytecode is the intermediate representation that JIT compilers optimize. LuaJIT traces bytecode to generate machine code. V8 starts with bytecode, then hot-spots get JIT-compiled. Your bytecode is a step toward this.</li>\n<li><strong>WebAssembly</strong>: Compiling to a portable bytecode VM is a pattern repeated across computing. WASM is a stack-based bytecode designed for the web, but the architecture is the same: language → compiler → bytecode → VM.</li>\n</ul>\n<p><strong>Forward:</strong></p>\n<ul>\n<li><strong>With this knowledge, you could now build</strong>: A simple scripting language with bytecode compilation, a regular expression engine (regex compiles to bytecode for a NFA/DFA VM), or a rules engine that compiles business rules to bytecode for fast evaluation.</li>\n</ul>\n<p>The bytecode VM pattern appears everywhere because it works: compilation amortizes analysis cost, bytecode is cacheable, and the VM provides a clean abstraction boundary. You&#39;ve just implemented one of the most powerful patterns in systems programming.</p>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-sqlite-m4 -->\n<h1 id=\"milestone-4-buffer-pool-manager\">Milestone 4: Buffer Pool Manager</h1>\n<h2 id=\"where-we-are-in-the-system\">Where We Are in the System</h2>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-satellite-overview.svg\" alt=\"SQLite Architecture: The Complete System Map\"></p>\n<p>Your bytecode VM now emits opcodes like <code>OpenTable</code>, <code>Column</code>, and <code>Next</code>. These opcodes need to read and write pages—but where do those pages live?</p>\n<p>Disk access is slow. A random read from an SSD takes 25-100 microseconds. From an HDD, 5-10 milliseconds. If every <code>Column</code> opcode triggered a disk read, your 10,000-row table scan would take seconds, not milliseconds.</p>\n<p>The buffer pool is the critical layer between in-memory operations and disk persistence. It caches fixed-size pages in memory, manages memory pressure through eviction, and ensures that pages currently in use aren&#39;t evicted mid-operation. This is where database performance is made or lost.</p>\n<hr>\n<h2 id=\"the-revelation-the-os-page-cache-is-not-enough\">The Revelation: The OS Page Cache Is Not Enough</h2>\n<p>Here&#39;s what most developers assume: &quot;The operating system&#39;s page cache handles this automatically. I can just <code>read()</code> and <code>write()</code> pages as needed. The OS knows how to cache file data efficiently.&quot;</p>\n<p>This assumption is wrong for databases. Here&#39;s why.</p>\n<h3 id=\"reason-1-pinning-prevents-use-after-free\">Reason 1: Pinning Prevents Use-After-Free</h3>\n<p>Consider a B-tree insertion that modifies a page:</p>\n<ol>\n<li>Read page 42 into memory</li>\n<li>Start modifying the page header</li>\n<li><strong>OS decides page 42 hasn&#39;t been accessed recently and evicts it</strong></li>\n<li>Your next write corrupts memory or crashes</li>\n</ol>\n<p>The OS page cache doesn&#39;t know you&#39;re in the middle of a B-tree operation. It just sees &quot;page not recently accessed&quot; and evicts it. Database operations need <strong>atomicity at the page level</strong>—a page must stay resident from the start of an operation to its end.</p>\n<p>The buffer pool solves this with <strong>pinning</strong>: a page can be marked &quot;in use&quot; with a pin count. Pinned pages are invisible to the eviction algorithm.</p>\n<h3 id=\"reason-2-dirty-page-tracking-enables-transactions\">Reason 2: Dirty Page Tracking Enables Transactions</h3>\n<p>When you execute <code>INSERT INTO users VALUES (1, &#39;Alice&#39;)</code>:</p>\n<ol>\n<li>Modify page 5 (the table&#39;s B-tree root)</li>\n<li>Modify page 12 (a leaf page)</li>\n<li>Modify page 3 (an index page)</li>\n</ol>\n<p>All three pages are now <strong>dirty</strong>—modified in memory but not yet written to disk. The OS page cache will eventually flush them, but it doesn&#39;t guarantee <em>when</em> or in <em>what order</em>.</p>\n<p>For ACID transactions, you need precise control:</p>\n<ul>\n<li><strong>Rollback journal mode</strong>: All dirty pages must be flushed together before the journal is deleted</li>\n<li><strong>WAL mode</strong>: Dirty pages must be flushed to the WAL, not the main database file</li>\n</ul>\n<p>The buffer pool tracks exactly which pages are dirty and provides <code>FlushAll()</code> for transaction boundaries.</p>\n<h3 id=\"reason-3-database-specific-eviction-policies\">Reason 3: Database-Specific Eviction Policies</h3>\n<p>OS page cache uses LRU (Least Recently Used) or variants like CLOCK. These work well for general workloads but ignore database semantics:</p>\n<ul>\n<li>A B-tree root page is accessed on <em>every</em> query—it should never be evicted</li>\n<li>A leaf page being scanned sequentially will be accessed once and never again—it should be evicted first</li>\n<li>A page that&#39;s been modified (dirty) costs more to evict (requires a disk write)</li>\n</ul>\n<p>The buffer pool can implement policies that understand these patterns: LRU with hot-page protection, or CLOCK with dirty-page penalty.</p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-buffer-pool-structure.svg\" alt=\"Buffer Pool Architecture\"></p>\n<hr>\n<h2 id=\"the-tension-memory-is-finite\">The Tension: Memory Is Finite</h2>\n<p>A 1TB database contains 244 million 4KB pages. A server might have 64GB of RAM—enough for 16 million pages, or about 6.5% of the database.</p>\n<p><strong>The constraint</strong>: Most of your data lives on disk. You must choose carefully which pages occupy the precious memory slots. A poor choice means unnecessary disk I/O. A good choice means the working set stays hot in memory.</p>\n<p>The tension manifests as:</p>\n<ul>\n<li><strong>Hit rate</strong>: What fraction of page requests are satisfied from memory vs disk?</li>\n<li><strong>Eviction overhead</strong>: How much CPU time is spent deciding which page to evict?</li>\n<li><strong>Write amplification</strong>: How many dirty pages are written to disk unnecessarily?</li>\n</ul>\n<p>The buffer pool must balance these competing concerns.</p>\n<hr>\n<h2 id=\"three-level-view-from-vm-opcodes-to-disk-blocks\">Three-Level View: From VM Opcodes to Disk Blocks</h2>\n<table>\n<thead>\n<tr>\n<th>Level</th>\n<th>What Happens</th>\n<th>Latency</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>VM</strong></td>\n<td><code>Column</code> opcode requests page 42</td>\n<td>Expects &lt; 1 microsecond</td>\n</tr>\n<tr>\n<td><strong>Buffer Pool</strong></td>\n<td>Check if page 42 is cached; if not, evict something and load</td>\n<td>0.1-1 microsecond (hit), 25-100 microseconds (miss)</td>\n</tr>\n<tr>\n<td><strong>Disk I/O</strong></td>\n<td>Read 4KB block from SSD/HDD into a frame</td>\n<td>25 microseconds (SSD), 5-10 milliseconds (HDD)</td>\n</tr>\n</tbody></table>\n<p>The buffer pool&#39;s job is to make level 3 invisible as often as possible. When the hit rate is 99%, the average page access is dominated by level 2, not level 3.</p>\n<hr>\n<h2 id=\"building-the-buffer-pool-data-structures\">Building the Buffer Pool: Data Structures</h2>\n<p>The buffer pool manages three things:</p>\n<ol>\n<li><strong>Frames</strong>: Fixed-size memory slots that hold page data</li>\n<li><strong>Page Table</strong>: Maps page IDs to frames (for fast lookup)</li>\n<li><strong>Metadata</strong>: For each frame, tracks pin count, dirty flag, and access time</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BufferPool</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pageSize   </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">           // Fixed size per page (default 4096)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frameCount </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">           // Number of frames (default 1000)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frames     [][]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\">      // The actual page data [frameCount][pageSize]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pageTable  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">  // page_id -> frame_index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metadata   []</span><span style=\"color:#B392F0\">FrameMetadata</span><span style=\"color:#6A737D\"> // Metadata for each frame</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diskMgr    </span><span style=\"color:#B392F0\">DiskManager</span><span style=\"color:#6A737D\">    // Interface for reading/writing pages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hits       </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">          // Performance metrics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    misses     </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FileID   </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">  // Which database file (for multi-file support)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PageNum  </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">  // Page number within the file</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> FrameMetadata</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PageID    </span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#6A737D\">   // Which page is in this frame (invalid if empty)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PinCount  </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">      // Number of active users of this page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Dirty     </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">     // Has this page been modified?</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastAccess </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#6A737D\"> // For LRU eviction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"initialization\">Initialization</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewBufferPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frameCount</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">pageSize</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">diskMgr</span><span style=\"color:#B392F0\"> DiskManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bp </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pageSize:   pageSize,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        frameCount: frameCount,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        frames:     </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([][]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, frameCount),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pageTable:  </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        metadata:   </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">FrameMetadata</span><span style=\"color:#E1E4E8\">, frameCount),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        diskMgr:    diskMgr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate all frames up front</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> frameCount; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bp.frames[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, pageSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bp.metadata[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> FrameMetadata</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            PageID: </span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{FileID: </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, PageNum: </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#6A737D\">// Invalid = empty frame</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> bp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The buffer pool allocates all memory at startup. This prevents runtime allocation overhead and makes memory usage predictable.</p>\n<hr>\n<h2 id=\"fetchpage-the-core-operation\">FetchPage: The Core Operation</h2>\n<p>When the VM (or B-tree layer) needs a page, it calls <code>FetchPage</code>:</p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-buffer-pool-hit-miss.svg\" alt=\"Buffer Pool: Hit vs Miss Paths\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageID</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Check if page is already in memory (hit)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> frameIdx, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.pageTable[pageID]; exists {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bp.hits</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bp.metadata[frameIdx].PinCount</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bp.metadata[frameIdx].LastAccess </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Data:     bp.frames[frameIdx],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            PageID:   pageID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            frameIdx: frameIdx,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            bp:       bp,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Page not in memory (miss) - need to load it</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bp.misses</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Find a frame to put the page in</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frameIdx, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">findVictimFrame</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err </span><span style=\"color:#6A737D\">// All frames are pinned</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. If the frame has a dirty page, write it back first</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> bp.metadata[frameIdx].Dirty {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        oldPageID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.metadata[frameIdx].PageID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.diskMgr.</span><span style=\"color:#B392F0\">WritePage</span><span style=\"color:#E1E4E8\">(oldPageID, bp.frames[frameIdx]); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Remove old page from page table</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    delete</span><span style=\"color:#E1E4E8\">(bp.pageTable, bp.metadata[frameIdx].PageID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 6. Read the new page from disk</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.diskMgr.</span><span style=\"color:#B392F0\">ReadPage</span><span style=\"color:#E1E4E8\">(pageID, bp.frames[frameIdx]); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 7. Update metadata and page table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bp.metadata[frameIdx] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> FrameMetadata</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        PageID:     pageID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        PinCount:   </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Dirty:      </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        LastAccess: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bp.pageTable[pageID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> frameIdx</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Data:     bp.frames[frameIdx],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        PageID:   pageID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        frameIdx: frameIdx,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bp:       bp,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The critical path is step 1: the cache hit case is just a map lookup and a few field updates. This should take less than 100 nanoseconds.</p>\n<hr>\n<h2 id=\"lru-eviction-finding-a-victim-frame\">LRU Eviction: Finding a Victim Frame</h2>\n<p>When all frames are occupied and a new page is requested, one must be evicted. LRU (Least Recently Used) selects the page that was accessed longest ago.</p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-lru-eviction-flow.svg\" alt=\"LRU Eviction: Data Walk Through\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">findVictimFrame</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> victimIdx </span><span style=\"color:#F97583\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> oldestAccess </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Scan all frames for the best victim</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> bp.frameCount; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        meta </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">bp.metadata[i]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Skip pinned pages - they're in use</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> meta.PinCount </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Skip empty frames - we can use them directly</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> meta.PageID.FileID </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> i, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#6A737D\"> // Found an empty frame, use it immediately</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Among unpinned pages, find the least recently used</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> meta.LastAccess.</span><span style=\"color:#B392F0\">Before</span><span style=\"color:#E1E4E8\">(oldestAccess) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            oldestAccess </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> meta.LastAccess</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            victimIdx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> victimIdx </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"all frames are pinned\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> victimIdx, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"why-not-real-lru\">Why Not Real LRU?</h3>\n<p>True LRU requires updating a data structure (like a linked list) on <em>every</em> access. This adds overhead to every <code>FetchPage</code> call.</p>\n<p>Many databases use <strong>approximate LRU</strong> instead:</p>\n<ul>\n<li><p><strong>CLOCK algorithm</strong>: A &quot;clock hand&quot; scans frames circularly. Each frame has a &quot;reference bit&quot; set on access. The clock hand clears bits as it passes. The first frame with a cleared bit is evicted. This approximates LRU with O(1) overhead per access.</p>\n</li>\n<li><p><strong>LRU-K</strong>: Track the last K access times. Evict based on the K-th most recent access. This prevents a single recent access from making a page &quot;hot.&quot;</p>\n</li>\n</ul>\n<p>For this project, true LRU is acceptable. The overhead of <code>time.Now()</code> and comparison is negligible compared to disk I/O.</p>\n<hr>\n<h2 id=\"pin-and-unpin-protecting-active-pages\">Pin and Unpin: Protecting Active Pages</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PinPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageID</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frameIdx, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.pageTable[pageID]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"page not in buffer pool\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bp.metadata[frameIdx].PinCount</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UnpinPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageID</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">isDirty</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frameIdx, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.pageTable[pageID]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"page not in buffer pool\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    meta </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">bp.metadata[frameIdx]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> meta.PinCount </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unpin called on page with zero pin count\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    meta.PinCount</span><span style=\"color:#F97583\">--</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> isDirty {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        meta.Dirty </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The pin count works like a reference count:</p>\n<ul>\n<li><code>FetchPage</code> returns a page with pin count = 1</li>\n<li>The caller calls <code>UnpinPage</code> when done (often with <code>isDirty=true</code> if modified)</li>\n<li>Only pages with pin count = 0 are eligible for eviction</li>\n</ul>\n<p><strong>Critical rule</strong>: Never hold a page reference without incrementing its pin count. If you do, the page might be evicted and your reference becomes invalid—use-after-free.</p>\n<hr>\n<h2 id=\"dirty-page-tracking-and-flushall\">Dirty Page Tracking and FlushAll</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">MarkDirty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageID</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frameIdx, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.pageTable[pageID]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> exists {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bp.metadata[frameIdx].Dirty </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FlushAll</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> pageID, frameIdx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> bp.pageTable {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> bp.metadata[frameIdx].Dirty {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.diskMgr.</span><span style=\"color:#B392F0\">WritePage</span><span style=\"color:#E1E4E8\">(pageID, bp.frames[frameIdx]); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            bp.metadata[frameIdx].Dirty </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FlushPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageID</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frameIdx, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.pageTable[pageID]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#6A737D\"> // Page not in memory, nothing to flush</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> bp.metadata[frameIdx].Dirty {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.diskMgr.</span><span style=\"color:#B392F0\">WritePage</span><span style=\"color:#E1E4E8\">(pageID, bp.frames[frameIdx]); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bp.metadata[frameIdx].Dirty </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><code>FlushAll</code> is called at transaction boundaries:</p>\n<ul>\n<li>Before deleting a rollback journal (commit)</li>\n<li>Before a WAL checkpoint</li>\n<li>At database shutdown</li>\n</ul>\n<p>Dirty pages are only written to disk when:</p>\n<ol>\n<li>They&#39;re evicted (to make room for another page)</li>\n<li><code>FlushAll</code> or <code>FlushPage</code> is explicitly called</li>\n</ol>\n<p>This minimizes disk writes while ensuring durability.</p>\n<hr>\n<h2 id=\"the-page-handle-safe-access-to-page-data\">The Page Handle: Safe Access to Page Data</h2>\n<p>The <code>Page</code> struct is the handle that upper layers use:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Page</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Data     []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\">   // The actual page data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PageID   </span><span style=\"color:#B392F0\">PageID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frameIdx </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bp       </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">MarkDirty</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.bp.</span><span style=\"color:#B392F0\">MarkDirty</span><span style=\"color:#E1E4E8\">(p.PageID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">isDirty</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.bp.</span><span style=\"color:#B392F0\">UnpinPage</span><span style=\"color:#E1E4E8\">(p.PageID, isDirty)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetData returns a slice into the page data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CAUTION: This slice becomes invalid if the page is evicted!</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Always keep the page pinned while using this data.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetData</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> p.Data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The pattern for B-tree operations:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">btree </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BTree</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Fetch the target page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> btree.bufferPool.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(btree.rootPageID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Page is now pinned (pin count = 1)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Modify the page</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... perform insertion, may require node splits ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page.</span><span style=\"color:#B392F0\">MarkDirty</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Unpin when done</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#6A737D\">// true = page is dirty</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>If the insertion requires reading multiple pages (for a split that propagates up the tree), each page is pinned before use and unpinned after.</p>\n<hr>\n<h2 id=\"hit-rate-the-performance-metric\">Hit Rate: The Performance Metric</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HitRate</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    total </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.hits </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> bp.misses</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> total </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(bp.hits) </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(total)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Stats</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Buffer Pool Stats: hits=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, misses=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, hit_rate=</span><span style=\"color:#79B8FF\">%.2f%%</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bp.hits, bp.misses, bp.</span><span style=\"color:#B392F0\">HitRate</span><span style=\"color:#E1E4E8\">()</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>A well-tuned buffer pool achieves 95%+ hit rate on typical workloads. If your hit rate is below 90%, consider:</p>\n<ul>\n<li>Increasing the frame count (more memory)</li>\n<li>Checking for sequential scans that flush the cache</li>\n<li>Identifying hot pages that should never be evicted</li>\n</ul>\n<hr>\n<h2 id=\"performance-analysis-where-time-goes\">Performance Analysis: Where Time Goes</h2>\n<p>For a buffer pool with 1000 frames and 4KB pages:</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Time</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cache hit (map lookup + pin)</td>\n<td>50-100 ns</td>\n<td>Just memory operations</td>\n</tr>\n<tr>\n<td>Cache miss (eviction + disk read)</td>\n<td>25-100 μs (SSD), 5-10 ms (HDD)</td>\n<td>250-100,000x slower than hit</td>\n</tr>\n<tr>\n<td>LRU scan for victim</td>\n<td>1-10 μs</td>\n<td>Proportional to frame count</td>\n</tr>\n<tr>\n<td>Dirty page writeback</td>\n<td>25-100 μs (SSD)</td>\n<td>Only on eviction or FlushAll</td>\n</tr>\n</tbody></table>\n<p><strong>The golden rule</strong>: Every cache miss costs as much as 1000+ cache hits. Optimizing the hit path (cache hit) is less important than optimizing the miss rate (cache misses).</p>\n<p>A 99% hit rate means 1 in 100 page requests goes to disk. A 90% hit rate means 1 in 10. The difference is 10x more disk I/O—potentially 10x slower query execution.</p>\n<hr>\n<h2 id=\"common-pitfalls\">Common Pitfalls</h2>\n<h3 id=\"1-evicting-a-pinned-page\">1. Evicting a Pinned Page</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Checking PinCount after selecting victim</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">victimIdx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">findVictimFrame</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> bp.metadata[victimIdx].PinCount </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Too late! You already decided to evict this page.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Fix</strong>: The <code>findVictimFrame</code> function must skip pinned pages during its scan. Never evict a page with <code>PinCount &gt; 0</code>.</p>\n<h3 id=\"2-forgetting-to-unpin\">2. Forgetting to Unpin</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">page, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(pageID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ... use the page ...</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BUG: Forgot to call page.Unpin()</span></span></code></pre></div>\n\n<p>If you forget to unpin, that page stays in memory forever (or until restart). With enough forgotten unpins, all frames become pinned and the buffer pool can&#39;t load any new pages.</p>\n<p><strong>Fix</strong>: Use defer immediately after fetching:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">page, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(pageID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">defer</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#6A737D\">// Will unpin even if panic occurs</span></span></code></pre></div>\n\n<h3 id=\"3-not-flushing-before-eviction\">3. Not Flushing Before Eviction</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Overwriting frame without checking dirty flag</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">bp.diskMgr.</span><span style=\"color:#B392F0\">ReadPage</span><span style=\"color:#E1E4E8\">(newPageID, bp.frames[victimIdx])</span></span></code></pre></div>\n\n<p>If the victim page was dirty, you just lost those modifications.</p>\n<p><strong>Fix</strong>: Always check and write back dirty pages before reusing a frame:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> bp.metadata[victimIdx].Dirty {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bp.diskMgr.</span><span style=\"color:#B392F0\">WritePage</span><span style=\"color:#E1E4E8\">(oldPageID, bp.frames[victimIdx])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"4-buffer-pool-deadlock\">4. Buffer Pool Deadlock</h3>\n<p>If a B-tree operation pins 5 pages simultaneously, and your buffer pool has 5 frames, you&#39;ve just deadlocked yourself. No frame can be evicted, but you need another frame.</p>\n<p><strong>Fix</strong>: </p>\n<ul>\n<li>Set a maximum pin limit per operation</li>\n<li>Use a buffer pool large enough for your working set</li>\n<li>Design B-tree operations to minimize simultaneous pins (unpin early)</li>\n</ul>\n<hr>\n<h2 id=\"test-suite-what-to-verify\">Test Suite: What to Verify</h2>\n<p><strong>Basic operations:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Initialize</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">bp </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewBufferPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, diskMgr)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Fetch a page (miss)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">page, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{FileID: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">NotNil</span><span style=\"color:#E1E4E8\">(t, page)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Fetch the same page again (hit)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">page2, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{FileID: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, page.frameIdx, page2.frameIdx) </span><span style=\"color:#6A737D\">// Same frame</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Check hit rate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">0.5</span><span style=\"color:#E1E4E8\">, bp.</span><span style=\"color:#B392F0\">HitRate</span><span style=\"color:#E1E4E8\">()) </span><span style=\"color:#6A737D\">// 1 hit, 1 miss</span></span></code></pre></div>\n\n<p><strong>LRU eviction:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">bp </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewBufferPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, diskMgr) </span><span style=\"color:#6A737D\">// Only 3 frames</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Load 3 pages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Unpin all</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> _, meta </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> bp.metadata {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    meta.PinCount </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Access page 1 to make it recently used</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Load page 4 - should evict page 2 (LRU)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Page 1 should still be in memory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">_, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.pageTable[</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">True</span><span style=\"color:#E1E4E8\">(t, exists)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Page 2 should have been evicted</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">_, exists </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> bp.pageTable[</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">}]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">False</span><span style=\"color:#E1E4E8\">(t, exists)</span></span></code></pre></div>\n\n<p><strong>Pin prevents eviction:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">bp </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewBufferPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, diskMgr)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Load and pin page 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">page1, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Load page 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">bp.</span><span style=\"color:#B392F0\">UnpinPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Try to load page 3 - should fail (page 1 is pinned)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">_, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(t, err) </span><span style=\"color:#6A737D\">// \"all frames are pinned\"</span></span></code></pre></div>\n\n<p><strong>Dirty page writeback:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Mark page as dirty</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">page, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">page.Data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">42</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">page.</span><span style=\"color:#B392F0\">MarkDirty</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">page.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Flush to disk</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">bp.</span><span style=\"color:#B392F0\">FlushAll</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Verify disk has the change</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">diskData, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> diskMgr.</span><span style=\"color:#B392F0\">ReadPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">42</span><span style=\"color:#E1E4E8\">), diskData[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">])</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<p>You&#39;ve just built a <strong>buffer pool</strong>—a pattern that appears wherever memory is scarce and data is large. Here&#39;s where this connects:</p>\n<p><strong>Immediate connections:</strong></p>\n<ul>\n<li><strong>B-tree layer (next milestone)</strong>: Every B-tree operation starts with <code>FetchPage</code>. The B-tree relies on the buffer pool to keep hot pages resident.</li>\n<li><strong>Transactions (Milestone 9)</strong>: The rollback journal and WAL both depend on dirty page tracking. You can&#39;t implement ACID without knowing which pages need to be flushed.</li>\n</ul>\n<p><strong>Same domain:</strong></p>\n<ul>\n<li><strong>Operating system virtual memory</strong>: The OS uses the same LRU/CLOCK algorithms for swapping pages to disk. But databases have additional constraints: pinning prevents use-after-free, and write ordering must respect transaction boundaries.</li>\n<li><strong>Redis eviction policies</strong>: When Redis runs out of memory, it evicts keys using LRU, LFU, or TTL. The same principle applies: a bounded cache must choose what to discard.</li>\n<li><strong>Database checkpoint strategies</strong>: Dirty page tracking enables efficient checkpointing. Instead of flushing the entire buffer pool, you flush only dirty pages—often a small fraction of the total.</li>\n</ul>\n<p><strong>Cross-domain:</strong></p>\n<ul>\n<li><strong>Browser caching</strong>: Images, scripts, and stylesheets are cached with eviction policies. A browser&#39;s image cache is a buffer pool for network resources instead of disk blocks.</li>\n<li><strong>CDN edge caching</strong>: Content delivery networks cache popular content at edge locations. When the cache is full, something must be evicted—the same LRU logic applies.</li>\n<li><strong>SSD wear leveling</strong>: Understanding page lifecycle helps reason about write amplification. Every dirty page eviction is a disk write; minimizing evictions minimizes SSD wear.</li>\n</ul>\n<p><strong>Forward:</strong></p>\n<ul>\n<li><strong>With this knowledge, you could now build</strong>: An in-memory cache with TTL and eviction (like memcached), a browser cache with size limits, or a CDN edge server that caches popular content.</li>\n</ul>\n<p>The buffer pool is where database performance meets systems programming. Every decision—frame count, page size, eviction policy—affects throughput and latency. You&#39;ve built the foundation for all storage operations.</p>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-sqlite-m5 -->\n<h1 id=\"milestone-5-b-tree-page-format-amp-table-storage\">Milestone 5: B-tree Page Format &amp; Table Storage</h1>\n<h2 id=\"where-we-are-in-the-system\">Where We Are in the System</h2>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-satellite-overview.svg\" alt=\"SQLite Architecture: The Complete System Map\"></p>\n<p>Your bytecode VM executes opcodes like <code>OpenTable</code>, <code>Column</code>, and <code>Next</code>. Your buffer pool caches pages in memory with pin/unpin lifecycle management. Now you confront the central design challenge of any database: <strong>how do you organize data on disk?</strong></p>\n<p>The page format is the most consequential design decision in your database. It determines:</p>\n<ul>\n<li>How many rows fit per page (affecting scan performance)</li>\n<li>How fast inserts happen (affecting write throughput)</li>\n<li>How efficiently space is used (affecting storage costs)</li>\n<li>How complex the code becomes (affecting maintainability)</li>\n</ul>\n<p>Every other component—the VM, the buffer pool, the query planner—exists to work with pages. Get this wrong, and nothing else can compensate.</p>\n<hr>\n<h2 id=\"the-tension-variable-records-in-fixed-pages\">The Tension: Variable Records in Fixed Pages</h2>\n<p>A SQL table contains rows of varying sizes:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> users</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    id </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#E1E4E8\">,        </span><span style=\"color:#6A737D\">-- 4 bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    name</span><span style=\"color:#F97583\"> TEXT</span><span style=\"color:#E1E4E8\">,         </span><span style=\"color:#6A737D\">-- 3 bytes (\"Bob\") or 300 bytes (a very long name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bio </span><span style=\"color:#F97583\">TEXT</span><span style=\"color:#6A737D\">           -- 0 bytes (NULL) or 10,000 bytes (a memoir)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p>Your pages are fixed at 4096 bytes. You must fit these variable-length rows into that fixed space, and you must find them again when queried.</p>\n<p>The constraints are brutal:</p>\n<ol>\n<li><p><strong>Insertion order is not sorted order</strong>: Rows arrive in arbitrary order. Row 1 might have rowid 1, row 2 might have rowid 100, row 3 might have rowid 5.</p>\n</li>\n<li><p><strong>Rows change size</strong>: An <code>UPDATE</code> that changes &quot;Bob&quot; to &quot;Bartholomew&quot; grows the row. Where does the extra space come from?</p>\n</li>\n<li><p><strong>Deletions leave gaps</strong>: Deleting row 5 leaves a hole. How do you track and reuse that space?</p>\n</li>\n<li><p><strong>Page boundaries are hard</strong>: A 4096-byte page with 3900 bytes used cannot accept a 500-byte row. But it could accept a 100-byte row.</p>\n</li>\n<li><p><strong>Sorted access must be fast</strong>: Even though rows are inserted in arbitrary order, <code>SELECT * FROM users ORDER BY id</code> must be efficient.</p>\n</li>\n</ol>\n<p>The naive approach—storing rows in sorted order within the page—requires shifting all subsequent rows on every insert. That&#39;s O(n) per insert, which becomes O(n²) for loading a table.</p>\n<p>The solution is the <strong>slotted page format</strong>, which separates storage order from access order.</p>\n<hr>\n<h2 id=\"the-revelation-records-are-not-stored-sorted\">The Revelation: Records Are Not Stored Sorted</h2>\n<p>Here&#39;s what most developers assume: &quot;B-tree nodes store records in sorted order. When I insert rowid 50 between rowid 40 and rowid 60, the page shifts records to make room. Node splitting just moves half the sorted records to a new node.&quot;</p>\n<p>This assumption is wrong, and understanding why reveals the elegance of real database design.</p>\n<h3 id=\"the-slotted-page-format\">The Slotted Page Format</h3>\n<p>A B-tree page has two regions that grow toward each other:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>┌─────────────────────────────────────────────────────────────────┐\n│ Header   │ Cell Pointers        │ Free Space │ Cell Content    │\n│ (8 bytes)│ (grow →)             │            │ (grow ←)        │\n└─────────────────────────────────────────────────────────────────┘</code></pre></div>\n\n\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-page-format-layout.svg\" alt=\"B-tree Page Format: Slotted Page Layout\"></p>\n<ul>\n<li><strong>Header</strong>: Fixed metadata (page type, cell count, free space offset)</li>\n<li><strong>Cell Pointer Array</strong>: 2-byte offsets pointing to each cell, stored in <strong>sorted order by key</strong></li>\n<li><strong>Free Space</strong>: The gap between the pointer array and cell content</li>\n<li><strong>Cell Content Area</strong>: The actual row data, stored in <strong>insertion order</strong></li>\n</ul>\n<p>When you insert a row with rowid 50:</p>\n<ol>\n<li><strong>Append the cell</strong> to the end of the cell content area (no shifting!)</li>\n<li><strong>Insert a pointer</strong> in the pointer array at the correct sorted position (2 bytes, minimal shift)</li>\n<li><strong>Update the header</strong> to reflect new cell count and free space</li>\n</ol>\n<p>The pointer array provides sorted access. The cell content area provides append-only storage. Both goals achieved without O(n) shifting of large records.</p>\n<h3 id=\"why-this-matters-for-node-splits\">Why This Matters for Node Splits</h3>\n<p>When a page overflows, you split it:</p>\n<ol>\n<li><strong>Find the median key</strong> (using the sorted pointer array)</li>\n<li><strong>Create a new page</strong></li>\n<li><strong>Move half the cells</strong> to the new page (copying the cell content, not shifting)</li>\n<li><strong>Promote the separator key</strong> to the parent</li>\n</ol>\n<p>But here&#39;s the complication the naive model misses: <strong>the parent might also overflow</strong>.</p>\n<p>Consider a B-tree of height 3. You insert a row that causes a leaf split. The separator key is promoted to the parent. The parent is also full, so it splits too. The new separator is promoted to the root. The root splits, creating a new root.</p>\n<p><strong>Cascading splits can propagate from leaf to root</strong>, increasing tree height by 1. A single insert can touch O(height) pages and allocate O(height) new pages.</p>\n<p>This is why B-tree operations are O(log n) even though finding the right leaf is O(log n)—the split cascade adds another log factor.</p>\n<hr>\n<h2 id=\"three-level-view-from-sql-row-to-disk-bytes\">Three-Level View: From SQL Row to Disk Bytes</h2>\n<table>\n<thead>\n<tr>\n<th>Level</th>\n<th>What Happens</th>\n<th>Size Concern</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Row</strong></td>\n<td>SQL values (INTEGER, TEXT, NULL)</td>\n<td>Variable per column</td>\n</tr>\n<tr>\n<td><strong>Record</strong></td>\n<td>Serialized bytes with type headers</td>\n<td>Variable per row</td>\n</tr>\n<tr>\n<td><strong>Page</strong></td>\n<td>Fixed 4096 bytes containing multiple records</td>\n<td>Fixed, forces tradeoffs</td>\n</tr>\n</tbody></table>\n<p>The serialization layer (row → record) must handle variable-length encoding. The page layer (records → page) must handle variable-length records in fixed space.</p>\n<hr>\n<h2 id=\"page-types-four-flavors\">Page Types: Four Flavors</h2>\n<p>Your database uses four page types, distinguished by a byte in the header:</p>\n<p>{{DIAGRAM:diag-btree-vs-bptree}}</p>\n<table>\n<thead>\n<tr>\n<th>Page Type</th>\n<th>Byte Value</th>\n<th>Contains</th>\n<th>Used For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Table Leaf</strong></td>\n<td>0x0D</td>\n<td>Full records keyed by rowid</td>\n<td>Table data</td>\n</tr>\n<tr>\n<td><strong>Table Internal</strong></td>\n<td>0x05</td>\n<td>Rowid keys + child page numbers</td>\n<td>Table index structure</td>\n</tr>\n<tr>\n<td><strong>Index Leaf</strong></td>\n<td>0x0A</td>\n<td>(indexed value, rowid) pairs</td>\n<td>Secondary indexes</td>\n</tr>\n<tr>\n<td><strong>Index Internal</strong></td>\n<td>0x02</td>\n<td>Separator keys + child page numbers</td>\n<td>Index structure</td>\n</tr>\n</tbody></table>\n<h3 id=\"table-b-tree-vs-index-btree\">Table B-tree vs Index B+tree</h3>\n<p><strong>Table B-tree</strong>: Stores the actual row data in leaf nodes. The key is the rowid (an auto-incrementing integer). Internal nodes store only separator keys and child pointers.</p>\n<p><strong>Index B+tree</strong>: Stores only (indexed column value, rowid) pairs in leaf nodes. The row data stays in the table B-tree. Internal nodes store separator keys. Leaf nodes are linked for efficient range scans.</p>\n<p>The distinction matters:</p>\n<ul>\n<li>A table B-tree leaf page contains full rows (potentially large)</li>\n<li>An index B+tree leaf page contains only keys + rowids (typically smaller)</li>\n<li>Index leaves link together; table leaves do not (in SQLite&#39;s design)</li>\n</ul>\n<hr>\n<h2 id=\"page-header-format\">Page Header Format</h2>\n<p>Every page begins with a header:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PageHeader</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PageType       </span><span style=\"color:#F97583\">uint8</span><span style=\"color:#6A737D\">   // 0x02, 0x05, 0x0A, or 0x0D</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FirstFreeblock </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\">  // Offset to first freeblock (0 if none)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CellCount      </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\">  // Number of cells on this page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CellContentStart </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\"> // Offset to start of cell content area</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FragmentedBytes </span><span style=\"color:#F97583\">uint8</span><span style=\"color:#6A737D\">  // Number of fragmented free bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RightMostPointer </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\"> // Rightmost child (internal pages only)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Size</strong>: 8 bytes for leaf pages, 12 bytes for internal pages (the rightmost pointer).</p>\n<p><strong>Offsets</strong>: All offsets are from the start of the page (byte 0).</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">PageHeader</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> PageHeader</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        PageType:        p.data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        FirstFreeblock:  binary.BigEndian.</span><span style=\"color:#B392F0\">Uint16</span><span style=\"color:#E1E4E8\">(p.data[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">]),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CellCount:       binary.BigEndian.</span><span style=\"color:#B392F0\">Uint16</span><span style=\"color:#E1E4E8\">(p.data[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">]),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CellContentStart: binary.BigEndian.</span><span style=\"color:#B392F0\">Uint16</span><span style=\"color:#E1E4E8\">(p.data[</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">]),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        FragmentedBytes: p.data[</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        RightMostPointer: binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(p.data[</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">]), </span><span style=\"color:#6A737D\">// Internal only</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetHeader</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">h</span><span style=\"color:#B392F0\"> PageHeader</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> h.PageType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint16</span><span style=\"color:#E1E4E8\">(p.data[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">], h.FirstFreeblock)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint16</span><span style=\"color:#E1E4E8\">(p.data[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">], h.CellCount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint16</span><span style=\"color:#E1E4E8\">(p.data[</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">], h.CellContentStart)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.data[</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> h.FragmentedBytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> h.PageType </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">02</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> h.PageType </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">05</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#6A737D\">// Internal pages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(p.data[</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">], h.RightMostPointer)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"cell-pointer-array\">Cell Pointer Array</h2>\n<p>Immediately after the header, the cell pointer array stores 2-byte offsets to each cell:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CellPointer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">index</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">headerSize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> index</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> binary.BigEndian.</span><span style=\"color:#B392F0\">Uint16</span><span style=\"color:#E1E4E8\">(p.data[offset : offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetCellPointer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">index</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#F97583\"> uint16</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">headerSize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> index</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint16</span><span style=\"color:#E1E4E8\">(p.data[offset:offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">], ptr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">headerSize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">02</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> p.data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">05</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#6A737D\"> // Internal page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#6A737D\"> // Leaf page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The pointer array is <strong>sorted by key</strong>. To find the cell with rowid 50:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FindCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">targetRowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cellCount </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Binary search through the pointer array</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    low, high </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, cellCount</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> low </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> high {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mid </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> (low </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> high) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cellOffset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">CellPointer</span><span style=\"color:#E1E4E8\">(mid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rowid </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">readRowidFromCell</span><span style=\"color:#E1E4E8\">(cellOffset)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> rowid </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> targetRowid {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> mid, </span><span style=\"color:#79B8FF\">true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> rowid </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> targetRowid {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            low </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mid </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            high </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mid </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> low, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#6A737D\"> // Insertion point, not found</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Binary search on the pointer array is O(log n) where n is the number of cells per page (typically 50-500). The actual cell data is never shifted—only 2-byte pointers move.</p>\n<hr>\n<h2 id=\"cell-content-area\">Cell Content Area</h2>\n<p>Cells grow from the end of the page toward the beginning:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FreeSpace</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    headerEnd </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">headerSize</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pointerArrayEnd </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> headerEnd </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(p.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">())</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cellContentStart </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(p.</span><span style=\"color:#B392F0\">CellContentStart</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> cellContentStart </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Page is empty, cell content starts at end of page</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> PageSize </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> pointerArrayEnd</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> cellContentStart </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> pointerArrayEnd</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AllocateCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">size</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">FreeSpace</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> size</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#6A737D\">// +2 for new pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"insufficient space\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Cell content area grows backward from end of page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newContentStart </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(p.</span><span style=\"color:#B392F0\">CellContentStart</span><span style=\"color:#E1E4E8\">()) </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">CellContentStart</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        newContentStart </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PageSize </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.</span><span style=\"color:#B392F0\">SetCellContentStart</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\">(newContentStart))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> newContentStart, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>When a cell is deleted, its space becomes a &quot;freeblock&quot; linked into a free list. The <code>FirstFreeblock</code> header field points to the first freeblock, and each freeblock contains a pointer to the next.</p>\n<hr>\n<h2 id=\"record-serialization-variable-length-encoding\">Record Serialization: Variable-Length Encoding</h2>\n<p>A row must be serialized into bytes before storage. The format uses <strong>variable-length integers (varints)</strong> to minimize space.</p>\n<p>{{DIAGRAM:diag-varint-encoding}}</p>\n<h3 id=\"varint-format\">Varint Format</h3>\n<p>SQLite&#39;s varint encoding uses 1-9 bytes for 64-bit integers:</p>\n<table>\n<thead>\n<tr>\n<th>Value Range</th>\n<th>Bytes</th>\n<th>Format</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0 - 127</td>\n<td>1</td>\n<td><code>0xxxxxxx</code></td>\n</tr>\n<tr>\n<td>128 - 16383</td>\n<td>2</td>\n<td><code>10xxxxxx xxxxxxxx</code></td>\n</tr>\n<tr>\n<td>16384 - 2097151</td>\n<td>3</td>\n<td><code>110xxxxx ...</code></td>\n</tr>\n<tr>\n<td>...</td>\n<td>...</td>\n<td>...</td>\n</tr>\n<tr>\n<td>Large values</td>\n<td>9</td>\n<td><code>11111111</code> + 8 bytes</td>\n</tr>\n</tbody></table>\n<p>The high bits indicate how many continuation bytes follow.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">bytesRead</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> data[offset]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(b), </span><span style=\"color:#79B8FF\">1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Count leading 1 bits to determine length</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> length </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">C0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(b </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">3F</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">E0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(b </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">1F</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">F0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(b </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">0F</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">F8</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(b </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">07</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 5</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FC</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(b </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">03</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 6</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FE</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(b </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">01</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 7</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FE</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 8</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 9</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read continuation bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> length; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (result </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(data[offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">i])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result, length</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> WriteVarint</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Handle negative: 9-byte encoding</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">9</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FF</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint64</span><span style=\"color:#E1E4E8\">(result[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">9</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#E1E4E8\">(value))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(value)}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... handle 2-8 byte encodings ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"record-format\">Record Format</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-record-serialization.svg\" alt=\"Row Record Format: Variable-Length Columns\"></p>\n<p>A record has two parts:</p>\n<ol>\n<li><strong>Header</strong>: Varint header size, followed by serial types for each column</li>\n<li><strong>Body</strong>: The actual column values</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>┌─────────────────────────────────────────────────────────────┐\n│ Header Size  │ Serial Type 1 │ Serial Type 2 │ ... │ Body │\n│ (varint)     │ (varint)      │ (varint)      │     │      │\n└─────────────────────────────────────────────────────────────┘</code></pre></div>\n\n<p>The <strong>serial type</strong> encodes both the type and size:</p>\n<table>\n<thead>\n<tr>\n<th>Serial Type</th>\n<th>Meaning</th>\n<th>Size</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>NULL</td>\n<td>0 bytes</td>\n</tr>\n<tr>\n<td>1</td>\n<td>8-bit signed integer</td>\n<td>1 byte</td>\n</tr>\n<tr>\n<td>2</td>\n<td>16-bit signed integer (big-endian)</td>\n<td>2 bytes</td>\n</tr>\n<tr>\n<td>3</td>\n<td>24-bit signed integer (big-endian)</td>\n<td>3 bytes</td>\n</tr>\n<tr>\n<td>4</td>\n<td>32-bit signed integer (big-endian)</td>\n<td>4 bytes</td>\n</tr>\n<tr>\n<td>5</td>\n<td>48-bit signed integer (big-endian)</td>\n<td>6 bytes</td>\n</tr>\n<tr>\n<td>6</td>\n<td>64-bit signed integer (big-endian)</td>\n<td>8 bytes</td>\n</tr>\n<tr>\n<td>7</td>\n<td>IEEE 754 float (big-endian)</td>\n<td>8 bytes</td>\n</tr>\n<tr>\n<td>8</td>\n<td>Integer 0</td>\n<td>0 bytes</td>\n</tr>\n<tr>\n<td>9</td>\n<td>Integer 1</td>\n<td>0 bytes</td>\n</tr>\n<tr>\n<td>10, 11</td>\n<td>Reserved</td>\n<td>-</td>\n</tr>\n<tr>\n<td>N ≥ 12, even</td>\n<td>BLOB of (N-12)/2 bytes</td>\n<td>(N-12)/2 bytes</td>\n</tr>\n<tr>\n<td>N ≥ 13, odd</td>\n<td>TEXT of (N-13)/2 bytes</td>\n<td>(N-13)/2 bytes</td>\n</tr>\n</tbody></table>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SerialType</span><span style=\"color:#F97583\"> int64</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> EncodeValue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}) (</span><span style=\"color:#B392F0\">SerialType</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> value.(</span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> encodeInt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(v))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> encodeInt</span><span style=\"color:#E1E4E8\">(v)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 7</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">encodeFloat</span><span style=\"color:#E1E4E8\">(v)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(v)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        serialType </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SerialType</span><span style=\"color:#E1E4E8\">(length</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> +</span><span style=\"color:#79B8FF\"> 13</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> serialType, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(v)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(v)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        serialType </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SerialType</span><span style=\"color:#E1E4E8\">(length</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> +</span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> serialType, v</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        panic</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unsupported type: </span><span style=\"color:#79B8FF\">%T</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, v))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> encodeInt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">v</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">SerialType</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 9</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Choose smallest representation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">128</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 127</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(v)}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32768</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 32767</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint16</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int16</span><span style=\"color:#E1E4E8\">(v)))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">, buf</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... more cases ...</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint64</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#E1E4E8\">(v))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">, buf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"full-record-serialization\">Full Record Serialization</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> SerializeRow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">values</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // First pass: calculate sizes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> headerSize </span><span style=\"color:#F97583\">int64</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#6A737D\"> // Header size varint itself</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> bodySize </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    serialTypes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">SerialType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(values))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bodies </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([][]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(values))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, val </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> values {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        st, body </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> EncodeValue</span><span style=\"color:#E1E4E8\">(val)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        serialTypes[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> st</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bodies[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bodySize </span><span style=\"color:#F97583\">+=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(body)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Calculate varint size for serial type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        headerSize </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">varintSize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(st)))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Recalculate header size including the size varint itself</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    totalHeaderSize </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> headerSize </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">varintSize</span><span style=\"color:#E1E4E8\">(headerSize))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate buffer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    totalSize </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(totalHeaderSize) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> bodySize</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, totalSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> writeVarint</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, totalHeaderSize)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, st </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> serialTypes {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> writeVarint</span><span style=\"color:#E1E4E8\">(buf, offset, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(st))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write body</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, body </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> bodies {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        copy</span><span style=\"color:#E1E4E8\">(buf[offset:], body)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(body)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> buf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> DeserializeRow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read header size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    headerSize, offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read serial types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> serialTypes []</span><span style=\"color:#B392F0\">SerialType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    headerEnd </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(offset)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> headerEnd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(headerSize) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        st, bytesRead </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(data, headerEnd)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        serialTypes </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(serialTypes, </span><span style=\"color:#B392F0\">SerialType</span><span style=\"color:#E1E4E8\">(st))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        headerEnd </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> bytesRead</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bodyOffset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> headerEnd</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    values </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(serialTypes))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, st </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> serialTypes {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        value, size </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> decodeValue</span><span style=\"color:#E1E4E8\">(data, bodyOffset, st)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        values[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bodyOffset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"table-b-tree-leaf-page-cells\">Table B-tree Leaf Page Cells</h2>\n<p>A cell in a table leaf page contains:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>┌─────────────┬────────────────┬───────────────────┐\n│ Payload Size│ Rowid          │ Payload (record)  │\n│ (varint)    │ (varint)       │ (bytes)           │\n└─────────────┴────────────────┴───────────────────┘</code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReadTableCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">record</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> offset</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read payload size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payloadSize, bytesRead </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(p.data, pos)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> bytesRead</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read rowid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowid, bytesRead </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(p.data, pos)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> bytesRead</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read payload</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    record </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, payloadSize)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(record, p.data[pos:pos</span><span style=\"color:#F97583\">+int</span><span style=\"color:#E1E4E8\">(payloadSize)])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> rowid, record</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">WriteTableCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">record</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cellSize </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> varintSize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(record))) </span><span style=\"color:#F97583\">+</span><span style=\"color:#B392F0\"> varintSize</span><span style=\"color:#E1E4E8\">(rowid) </span><span style=\"color:#F97583\">+</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate space</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">AllocateCell</span><span style=\"color:#E1E4E8\">(cellSize)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write cell</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> offset</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> writeVarint</span><span style=\"color:#E1E4E8\">(p.data, pos, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(record)))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> writeVarint</span><span style=\"color:#E1E4E8\">(p.data, pos, rowid)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(p.data[pos:], record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> offset, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"table-b-tree-internal-page-cells\">Table B-tree Internal Page Cells</h2>\n<p>Internal pages store separator keys and child pointers:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>┌─────────────┬────────────────┬───────────────────┐\n│ Left Child  │ Rowid          │ (no payload)      │\n│ (4 bytes)   │ (varint)       │                   │\n└─────────────┴────────────────┴───────────────────┘</code></pre></div>\n\n<p>Plus the rightmost pointer in the header.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReadInternalCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#FFAB70\">leftChild</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leftChild </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(p.data[offset : offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowid, _ </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(p.data, offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> leftChild, rowid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FindChildPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cellCount </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Binary search for the right child</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> cellCount; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        _, separatorRowid </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">ReadInternalCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(p.</span><span style=\"color:#B392F0\">CellPointer</span><span style=\"color:#E1E4E8\">(i)))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> rowid </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> separatorRowid {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            leftChild, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">ReadInternalCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(p.</span><span style=\"color:#B392F0\">CellPointer</span><span style=\"color:#E1E4E8\">(i)))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> leftChild</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If greater than all separators, use rightmost pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">RightMostPointer</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"index-btree-page-cells\">Index B+tree Page Cells</h2>\n<p>Index pages store (key, rowid) pairs:</p>\n<p><strong>Leaf cell</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>┌─────────────┬────────────────┬───────────────────┐\n│ Payload Size│ Payload        │ Rowid             │\n│ (varint)    │ (indexed vals) │ (varint)          │\n└─────────────┴────────────────┴───────────────────┘</code></pre></div>\n\n<p><strong>Internal cell</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>┌─────────────┬────────────────┬───────────────────┐\n│ Left Child  │ Payload        │ (no rowid)        │\n│ (4 bytes)   │ (separator)    │                   │\n└─────────────┴────────────────┴───────────────────┘</code></pre></div>\n\n<p>The payload for an index is the serialized indexed column values, without the row data from the table.</p>\n<hr>\n<h2 id=\"node-splitting-the-complex-case\">Node Splitting: The Complex Case</h2>\n<p>When a page runs out of space, it must split:</p>\n<p>{{DIAGRAM:diag-node-split-operation}}</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BTree</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SplitPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageID</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.bufferPool.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(pageID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Find median key</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cellCount </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    medianIndex </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cellCount </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Create new page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newPageID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">allocatePage</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newPage </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.bufferPool.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(newPageID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> newPage.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize new page with same type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newPage.</span><span style=\"color:#B392F0\">SetPageType</span><span style=\"color:#E1E4E8\">(page.</span><span style=\"color:#B392F0\">PageType</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Move cells after median to new page</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> medianIndex </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> cellCount; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cellOffset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">CellPointer</span><span style=\"color:#E1E4E8\">(i)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cellData </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">ReadCell</span><span style=\"color:#E1E4E8\">(cellOffset)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        newPage.</span><span style=\"color:#B392F0\">InsertCell</span><span style=\"color:#E1E4E8\">(cellData)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Remove moved cells from old page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page.</span><span style=\"color:#B392F0\">SetCellCount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\">(medianIndex))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Get the median key to promote</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    medianOffset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">CellPointer</span><span style=\"color:#E1E4E8\">(medianIndex)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    medianKey </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">ReadKey</span><span style=\"color:#E1E4E8\">(medianOffset)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 6. Insert separator into parent (or create new root)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> pageID </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> t.rootPageID {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Splitting the root - create new root</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">createRootWithChildren</span><span style=\"color:#E1E4E8\">(pageID, newPageID, medianKey)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        parentID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">findParent</span><span style=\"color:#E1E4E8\">(pageID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">insertSeparator</span><span style=\"color:#E1E4E8\">(parentID, medianKey, newPageID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"cascading-splits\">Cascading Splits</h3>\n<p>If the parent is also full, <code>insertSeparator</code> triggers another split:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BTree</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">insertSeparator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">parentID</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">key</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rightChild</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parent </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.bufferPool.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(parentID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if parent has space</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> parent.</span><span style=\"color:#B392F0\">FreeSpace</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> requiredSpace {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        parent.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Recursively split parent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">SplitPage</span><span style=\"color:#E1E4E8\">(parentID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Retry insertion after split</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">insertSeparator</span><span style=\"color:#E1E4E8\">(parentID, key, rightChild)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find insertion point and insert</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The recursion can propagate to the root, at which point a new root is created and the tree height increases by 1.</p>\n<hr>\n<h2 id=\"system-catalog-sqlite_master\">System Catalog: sqlite_master</h2>\n<p>The database needs to remember which tables exist and where their root pages are. SQLite uses a special table called <code>sqlite_master</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> sqlite_master</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    type</span><span style=\"color:#F97583\"> TEXT</span><span style=\"color:#E1E4E8\">,        </span><span style=\"color:#6A737D\">-- 'table', 'index', 'trigger', 'view'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    name</span><span style=\"color:#F97583\"> TEXT</span><span style=\"color:#E1E4E8\">,        </span><span style=\"color:#6A737D\">-- Object name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tbl_name </span><span style=\"color:#F97583\">TEXT</span><span style=\"color:#E1E4E8\">,    </span><span style=\"color:#6A737D\">-- Table name (for indexes)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rootpage </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">-- Root page number</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    sql</span><span style=\"color:#F97583\"> TEXT</span><span style=\"color:#6A737D\">          -- CREATE statement</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-system-catalog.svg\" alt=\"System Catalog: sqlite_master Table\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateTable</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">CreateTableStatement</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Allocate a root page for the table's B-tree</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rootPageID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">allocatePage</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Initialize the page as an empty table leaf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rootPage </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.bufferPool.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(rootPageID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rootPage.</span><span style=\"color:#B392F0\">SetPageType</span><span style=\"color:#E1E4E8\">(PageTypeTableLeaf)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rootPage.</span><span style=\"color:#B392F0\">SetCellCount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rootPage.</span><span style=\"color:#B392F0\">SetCellContentStart</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rootPage.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Insert into sqlite_master</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sql </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> serializeCreateStatement</span><span style=\"color:#E1E4E8\">(stmt)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"INSERT INTO sqlite_master (type, name, tbl_name, rootpage, sql) VALUES ('table', '</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">', '</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">', </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, '</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">')\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stmt.Table, stmt.Table, rootPageID, sql,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetTableRootPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">uint32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> rootPage </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">QueryRow</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT rootpage FROM sqlite_master WHERE type='table' AND name=?\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tableName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ).</span><span style=\"color:#B392F0\">Scan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">rootPage)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> rootPage </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"table </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> does not exist\"</span><span style=\"color:#E1E4E8\">, tableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">(rootPage), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The <code>sqlite_master</code> table itself has a well-known root page (page 1 in SQLite).</p>\n<hr>\n<h2 id=\"full-table-scan-traversing-the-leaves\">Full Table Scan: Traversing the Leaves</h2>\n<p>A full table scan iterates through all rows in rowid order:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BTree</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FullTableScan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">callback</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">record</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Start at the root</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pageID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.rootPageID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Navigate to the leftmost leaf</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.bufferPool.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(pageID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">PageType</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PageTypeTableLeaf {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Found a leaf - start scanning</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            page.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Internal page - go to leftmost child</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        leftChild, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">ReadInternalCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(page.</span><span style=\"color:#B392F0\">CellPointer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pageID </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> leftChild</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Scan leaf pages from left to right</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.bufferPool.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(pageID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Process all cells in this leaf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cellCount </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(cellCount); i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cellOffset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">CellPointer</span><span style=\"color:#E1E4E8\">(i)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            rowid, record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">ReadTableCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(cellOffset))</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            callback</span><span style=\"color:#E1E4E8\">(rowid, record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check for next leaf (via rightmost pointer in SQLite's design)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // In a pure B-tree without leaf linking, we'd need to track the path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // and navigate to the next leaf via the parent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nextLeaf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">RightMostPointer</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> nextLeaf </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#6A737D\"> // No more leaves</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pageID </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> nextLeaf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Note: SQLite&#39;s table B-trees don&#39;t link leaf pages together (unlike index B+trees). A full table scan must navigate via the parent nodes. For simplicity, some implementations add leaf linking.</p>\n<hr>\n<h2 id=\"endianness-big-endian-for-portability\">Endianness: Big-Endian for Portability</h2>\n<p>All multi-byte integers in the page format are stored <strong>big-endian</strong> (most significant byte first). This ensures the database file is portable across architectures—a database created on x86 (little-endian) can be read on ARM (could be either).</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Always use big-endian for page format</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint16</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">], value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">], value)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Reading</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">value </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> binary.BigEndian.</span><span style=\"color:#B392F0\">Uint16</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">])</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"common-pitfalls\">Common Pitfalls</h2>\n<h3 id=\"1-confusing-b-tree-and-btree\">1. Confusing B-tree and B+tree</h3>\n<p><strong>Wrong</strong>: &quot;I&#39;ll store row data in internal nodes too, for faster lookups.&quot;</p>\n<p><strong>Right</strong>: Table B-trees store data only in leaves. Index B+trees store (key, rowid) only in leaves. Internal nodes store only separators and pointers.</p>\n<p>Storing data in internal nodes seems efficient—why traverse to a leaf if you find the key in an internal node? But it breaks the invariant that internal node entries are separators, not data. It also reduces fan-out (fewer keys per page) and increases tree height.</p>\n<h3 id=\"2-forgetting-overflow-pages\">2. Forgetting Overflow Pages</h3>\n<p><strong>Wrong</strong>: &quot;A row will always fit in a page.&quot;</p>\n<p><strong>Right</strong>: A row can exceed page size. You need overflow pages.</p>\n<p>If a serialized row exceeds the usable page size (4096 - header), the cell stores a prefix and a pointer to an overflow page chain:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> MaxLocalPayload</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 4096</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\"> 35</span><span style=\"color:#6A737D\"> // Usable space minus header and cell overhead</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">InsertCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">record</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(record) </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> MaxLocalPayload {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Store prefix locally, rest in overflow pages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        prefix </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> record[:MaxLocalPayload]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        overflowPageID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">writeOverflowChain</span><span style=\"color:#E1E4E8\">(record[MaxLocalPayload:])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Cell format changes to include overflow pointer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Normal insertion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"3-page-fragmentation-after-deletes\">3. Page Fragmentation After Deletes</h3>\n<p><strong>Wrong</strong>: &quot;Deleting a cell frees space immediately.&quot;</p>\n<p><strong>Right</strong>: Deleted cells leave gaps. The freeblock list tracks them, but pages can become fragmented.</p>\n<p>A page with 10 cells, then 9 deletions, might have 90% free space but it&#39;s fragmented into 9 small chunks. A large row won&#39;t fit even though &quot;free space&quot; suggests it should.</p>\n<p><strong>Solutions</strong>:</p>\n<ul>\n<li>Periodic compaction (VACUUM)</li>\n<li>In-page defragmentation during inserts</li>\n<li>Merge underfull pages (B-tree deletion)</li>\n</ul>\n<h3 id=\"4-varint-edge-cases\">4. Varint Edge Cases</h3>\n<p><strong>Wrong</strong>: &quot;Varints handle 64-bit integers, so I&#39;ll use them for everything.&quot;</p>\n<p><strong>Right</strong>: Varints are space-efficient but slower to read/write than fixed-width integers.</p>\n<p>For hot paths (like rowids that are accessed frequently), consider whether the space savings justify the CPU cost. SQLite uses varints throughout, but some databases use fixed-width for certain fields.</p>\n<h3 id=\"5-off-by-one-in-page-calculations\">5. Off-by-One in Page Calculations</h3>\n<p>The page is 4096 bytes, indexed 0-4095. The cell content area starts at some offset and grows downward. A common bug:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Off by one</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">newStart </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> pageSize </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> cellSize </span><span style=\"color:#6A737D\">// If cellSize=100, newStart=3996</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RIGHT: The last valid index is pageSize-1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">newStart </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> pageSize </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> cellSize </span><span style=\"color:#6A737D\">// Correct, last byte is at 4095</span></span></code></pre></div>\n\n<p>Actually, this is correct—but the off-by-one errors creep in when calculating free space or checking if a cell fits.</p>\n<hr>\n<h2 id=\"test-suite-what-to-verify\">Test Suite: What to Verify</h2>\n<p><strong>Page header parsing:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">page </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">page.</span><span style=\"color:#B392F0\">SetPageType</span><span style=\"color:#E1E4E8\">(PageTypeTableLeaf)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">page.</span><span style=\"color:#B392F0\">SetCellCount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">page.</span><span style=\"color:#B392F0\">SetCellContentStart</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3500</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">h </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">uint8</span><span style=\"color:#E1E4E8\">(PageTypeTableLeaf), h.PageType)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">), h.CellCount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3500</span><span style=\"color:#E1E4E8\">), h.CellContentStart)</span></span></code></pre></div>\n\n<p><strong>Varint encoding/decoding:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">testCases </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">127</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">16383</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">16384</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2097151</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> _, tc </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> testCases {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    encoded </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> WriteVarint</span><span style=\"color:#E1E4E8\">(tc)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    decoded, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(encoded, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, tc, decoded)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Record serialization:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">values </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">42</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"hello\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3.14</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SerializeRow</span><span style=\"color:#E1E4E8\">(values)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">decoded </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> DeserializeRow</span><span style=\"color:#E1E4E8\">(record)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">42</span><span style=\"color:#E1E4E8\">), decoded[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#9ECBFF\">\"hello\"</span><span style=\"color:#E1E4E8\">, decoded[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Nil</span><span style=\"color:#E1E4E8\">(t, decoded[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">3.14</span><span style=\"color:#E1E4E8\">, decoded[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">])</span></span></code></pre></div>\n\n<p><strong>Cell insertion and retrieval:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">page </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">page.</span><span style=\"color:#B392F0\">Initialize</span><span style=\"color:#E1E4E8\">(PageTypeTableLeaf)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SerializeRow</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"Alice\"</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">offset, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">WriteTableCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">page.</span><span style=\"color:#B392F0\">InsertPointer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, offset)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">rowid, retrieved </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">ReadTableCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(offset))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, record, retrieved)</span></span></code></pre></div>\n\n<p><strong>B-tree insertion with split:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">tree </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewBTree</span><span style=\"color:#E1E4E8\">(bufferPool, pageSize)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Insert until split is forced</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tree.</span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(i), </span><span style=\"color:#B392F0\">SerializeRow</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{i, fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"user</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, i)}))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Verify all rows are retrievable</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">count </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">tree.</span><span style=\"color:#B392F0\">Scan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">record</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    count</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, count)</span></span></code></pre></div>\n\n<p><strong>Full table scan:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">tree </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createPopulatedTree</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#6A737D\">// 100 rows</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> rowids []</span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">tree.</span><span style=\"color:#B392F0\">FullTableScan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">record</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowids </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(rowids, rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Rowids should be in sorted order</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(rowids); i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Less</span><span style=\"color:#E1E4E8\">(t, rowids[i</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], rowids[i])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<p>You&#39;ve just built a <strong>page-based storage engine</strong>—the foundation of all modern databases. Here&#39;s where this connects:</p>\n<p><strong>Immediate connections:</strong></p>\n<ul>\n<li><strong>SELECT execution (Milestone 6)</strong>: The VM&#39;s <code>Column</code> opcode deserializes values from the record format you just defined.</li>\n<li><strong>Secondary indexes (Milestone 7)</strong>: Index B+trees use the same page format with different cell contents.</li>\n</ul>\n<p><strong>Same domain:</strong></p>\n<ul>\n<li><strong>LSM-trees in RocksDB/Cassandra</strong>: The alternative to B-trees. LSM-trees buffer writes in memory, then flush to sorted files (SSTables). Reads check multiple levels. The tradeoff: B-trees optimize reads, LSM-trees optimize writes.</li>\n<li><strong>Index-organized tables in MySQL/Oracle</strong>: MySQL&#39;s InnoDB stores table data in the primary key B-tree, just like SQLite. This is &quot;clustered&quot; storage—the table IS the B-tree.</li>\n<li><strong>Database page fragmentation</strong>: Understanding free space management explains why <code>VACUUM</code> is needed. As pages fragment from inserts/deletes, space is wasted. VACUUM rewrites pages to reclaim fragmented space.</li>\n</ul>\n<p><strong>Cross-domain:</strong></p>\n<ul>\n<li><strong>File systems (ext4, NTFS)</strong>: Directories and extent maps use B-trees with similar page management. The free space bitmap is analogous to the freeblock list. Filesystems face the same fragmentation challenges.</li>\n<li><strong>Variable-length encoding in protocols</strong>: Protocol Buffers use varints identical to SQLite&#39;s. The same space/speed tradeoff appears in network protocols—varints save bandwidth but cost CPU.</li>\n<li><strong>Browser localStorage</strong>: Some browsers use SQLite under the hood. Your web app&#39;s localStorage might be stored in the same B-tree format you just implemented.</li>\n</ul>\n<p><strong>Forward:</strong></p>\n<ul>\n<li><strong>With this knowledge, you could now build</strong>: A key-value store with B-tree persistence, a document database that stores JSON records in B-tree leaves, or a time-series database that organizes timestamped records in B-tree pages.</li>\n</ul>\n<p>The slotted page format, varint encoding, and split cascade are patterns repeated across database implementations. You&#39;ve just learned the vocabulary that database engineers use to discuss storage—terms like &quot;fan-out,&quot; &quot;page utilization,&quot; and &quot;cascading split&quot; will now make sense when you encounter them in documentation and research papers.</p>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-sqlite-m6 -->\n<h1 id=\"milestone-6-select-execution-amp-dml\">Milestone 6: SELECT Execution &amp; DML</h1>\n<h2 id=\"where-we-are-in-the-system\">Where We Are in the System</h2>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-satellite-overview.svg\" alt=\"SQLite Architecture: The Complete System Map\"></p>\n<p>Your bytecode VM executes opcodes. Your buffer pool caches pages. Your B-tree stores serialized records in a slotted page format. Now you must make these components work together to execute actual SQL statements.</p>\n<p>This is where the rubber meets the road. A user types <code>SELECT name FROM users WHERE age &gt; 21</code> and expects to see results. Behind that simple query lies:</p>\n<ul>\n<li><strong>Deserialization</strong>: Converting binary records back into typed values</li>\n<li><strong>Projection</strong>: Extracting only the requested columns</li>\n<li><strong>Predicate evaluation</strong>: Filtering rows based on WHERE conditions</li>\n<li><strong>Three-valued logic</strong>: Handling NULL correctly in every comparison</li>\n</ul>\n<p>And that&#39;s just SELECT. INSERT, UPDATE, and DELETE add their own complexities: constraint checking, B-tree modifications, and maintaining structural integrity.</p>\n<hr>\n<h2 id=\"the-revelation-null-breaks-everything-you-know\">The Revelation: NULL Breaks Everything You Know</h2>\n<p>Here&#39;s what most developers assume: &quot;NULL is like null in programming languages—it&#39;s a special value that equals itself. <code>NULL = NULL</code> is TRUE. WHERE clauses are boolean expressions that evaluate to TRUE or FALSE. Column projection is just selecting array indices.&quot;</p>\n<p>All three assumptions are wrong, and understanding why is essential to building a correct database.</p>\n<h3 id=\"null-does-not-equal-null\">NULL Does Not Equal NULL</h3>\n<p>In SQL, <code>NULL = NULL</code> evaluates to <strong>NULL</strong>, not TRUE.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> middle_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> middle_name</span></span></code></pre></div>\n\n<p>You might expect this to return all users. It doesn&#39;t. For a user with <code>middle_name = NULL</code>, the comparison <code>NULL = NULL</code> evaluates to NULL. The WHERE clause only keeps rows where the predicate is TRUE. NULL is not TRUE, so that row is excluded.</p>\n<p>This isn&#39;t arbitrary—it&#39;s fundamental to SQL&#39;s design. NULL represents &quot;unknown value.&quot; If you don&#39;t know my middle name, and you don&#39;t know your middle name, can you say whether they&#39;re equal? No—you don&#39;t know. The answer is unknown. Hence: NULL.</p>\n<p>To check for NULL, you must use <code>IS NULL</code> or <code>IS NOT NULL</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> middle_name </span><span style=\"color:#F97583\">IS</span><span style=\"color:#F97583\"> NULL</span><span style=\"color:#6A737D\">      -- Correct</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> middle_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> NULL</span><span style=\"color:#6A737D\">       -- WRONG: always returns empty</span></span></code></pre></div>\n\n<h3 id=\"three-valued-logic-true-false-and-null\">Three-Valued Logic: TRUE, FALSE, and NULL</h3>\n<p>{{DIAGRAM:diag-three-valued-logic}}</p>\n<p>WHERE clauses don&#39;t evaluate to TRUE or FALSE. They evaluate to TRUE, FALSE, or NULL. Only TRUE passes the filter.</p>\n<p>The truth tables are counterintuitive:</p>\n<table>\n<thead>\n<tr>\n<th>A</th>\n<th>B</th>\n<th>A AND B</th>\n<th>A OR B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TRUE</td>\n<td>TRUE</td>\n<td>TRUE</td>\n<td>TRUE</td>\n</tr>\n<tr>\n<td>TRUE</td>\n<td>FALSE</td>\n<td>FALSE</td>\n<td>TRUE</td>\n</tr>\n<tr>\n<td>TRUE</td>\n<td>NULL</td>\n<td>NULL</td>\n<td>TRUE</td>\n</tr>\n<tr>\n<td>FALSE</td>\n<td>TRUE</td>\n<td>FALSE</td>\n<td>TRUE</td>\n</tr>\n<tr>\n<td>FALSE</td>\n<td>FALSE</td>\n<td>FALSE</td>\n<td>FALSE</td>\n</tr>\n<tr>\n<td>FALSE</td>\n<td>NULL</td>\n<td>FALSE</td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>NULL</td>\n<td>TRUE</td>\n<td>NULL</td>\n<td>TRUE</td>\n</tr>\n<tr>\n<td>NULL</td>\n<td>FALSE</td>\n<td>FALSE</td>\n<td>NULL</td>\n</tr>\n<tr>\n<td>NULL</td>\n<td>NULL</td>\n<td>NULL</td>\n<td>NULL</td>\n</tr>\n</tbody></table>\n<p>The surprising rules:</p>\n<ul>\n<li><strong>NULL AND TRUE = NULL</strong>: &quot;Unknown AND true&quot; is still unknown</li>\n<li><strong>NULL AND FALSE = FALSE</strong>: &quot;Unknown AND false&quot; is definitely false (one false kills the AND)</li>\n<li><strong>NULL OR TRUE = TRUE</strong>: &quot;Unknown OR true&quot; is definitely true (one true satisfies the OR)</li>\n<li><strong>NULL OR FALSE = NULL</strong>: &quot;Unknown OR false&quot; is still unknown</li>\n</ul>\n<p>Every arithmetic operation involving NULL produces NULL:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">NULL</span><span style=\"color:#F97583\"> +</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">NULL</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">NULL</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#9ECBFF\"> 'text'</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> NULL</span><span style=\"color:#6A737D\">  -- Concatenation</span></span></code></pre></div>\n\n<p>This propagation means a single NULL column can cascade through an entire expression.</p>\n<h3 id=\"column-projection-is-not-array-indexing\">Column Projection Is Not Array Indexing</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-projection-deserialization.svg\" alt=\"Column Projection: Finding the Right Field\"></p>\n<p>In a programming language, accessing <code>row[2]</code> is O(1)—just pointer arithmetic. In your database, records are serialized with variable-length encoding. Column 2&#39;s offset cannot be calculated without first deserializing columns 0 and 1.</p>\n<p>Consider this record:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Header: [size=12] [type1=6] [type2=13+6] [type3=0]\nBody:   [8-byte int] [6-byte string] [0 bytes]</code></pre></div>\n\n<p>To read column 2:</p>\n<ol>\n<li>Read header size varint</li>\n<li>Read serial type for column 0 (determines column 0&#39;s body size)</li>\n<li>Skip column 0&#39;s body</li>\n<li>Read serial type for column 1 (determines column 1&#39;s body size)</li>\n<li>Skip column 1&#39;s body</li>\n<li>Read serial type for column 2 (NULL, 0 bytes)</li>\n<li>Return NULL</li>\n</ol>\n<p>This is O(n) in the number of columns before the target. For <code>SELECT col50 FROM table</code>, you must deserialize 49 columns you don&#39;t need.</p>\n<p><strong>Optimization</strong>: Store column offsets in a separate array when deserializing, then use that for projection. The first access is O(n), subsequent column accesses are O(1).</p>\n<hr>\n<h2 id=\"the-tension-correctness-vs-performance\">The Tension: Correctness vs Performance</h2>\n<p>Every row processed by SELECT must:</p>\n<ol>\n<li>Deserialize the record (O(n) in column count for naive approach)</li>\n<li>Evaluate the WHERE clause (may involve multiple column reads)</li>\n<li>Project the requested columns (may require re-reading)</li>\n</ol>\n<p>For a 10,000-row table with 50 columns, a naive implementation deserializes 500,000 column values even if the query only touches 3 columns.</p>\n<p>The tension is between:</p>\n<ul>\n<li><strong>Correctness</strong>: Three-valued logic must be implemented exactly right</li>\n<li><strong>Performance</strong>: Minimize deserialization work for columns not needed</li>\n</ul>\n<p>SQLite&#39;s approach: deserialize lazily. The <code>Column</code> opcode reads only the requested column, traversing the record to find it. This means reading column 5 is slower than reading column 0, but reading <em>only</em> column 5 is faster than deserializing all 50 columns.</p>\n<hr>\n<h2 id=\"three-level-view-from-bytecode-to-deserialized-values\">Three-Level View: From Bytecode to Deserialized Values</h2>\n<table>\n<thead>\n<tr>\n<th>Level</th>\n<th>What Happens</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>VM</strong></td>\n<td>Executes opcodes, manages cursors and registers</td>\n<td><code>Column 0 2 r1</code></td>\n</tr>\n<tr>\n<td><strong>Cursor</strong></td>\n<td>Navigates B-tree, provides row access</td>\n<td><code>cursor.GetColumn(2)</code></td>\n</tr>\n<tr>\n<td><strong>Record</strong></td>\n<td>Deserializes variable-length fields</td>\n<td>Parse header, skip to offset, decode value</td>\n</tr>\n</tbody></table>\n<p>The VM doesn&#39;t know about record formats. It calls <code>cursor.GetColumn(index)</code> and receives a typed <code>Value</code>. The cursor handles all the parsing complexity.</p>\n<hr>\n<h2 id=\"building-select-execution\">Building SELECT Execution</h2>\n<h3 id=\"the-cursor-abstraction\">The Cursor Abstraction</h3>\n<p>A cursor abstracts B-tree traversal:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Cursor</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tree        </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BTree</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentPage </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentPageID </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cellIndex   </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    atEnd       </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Cursor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">First</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Navigate to leftmost leaf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.currentPageID </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> c.tree.rootPageID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.tree.bufferPool.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(c.currentPageID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">PageType</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PageTypeTableLeaf {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            c.currentPage </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            c.cellIndex </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            c.atEnd </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Internal page: go to leftmost child</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        leftChild, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">ReadInternalCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.currentPageID </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> leftChild</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Cursor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.cellIndex</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> c.cellIndex </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(c.currentPage.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Need to move to next leaf page</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // In SQLite's design, this requires navigating via parent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // For simplicity, we'll use a right-sibling pointer approach</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nextLeaf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.currentPage.</span><span style=\"color:#B392F0\">RightMostPointer</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> nextLeaf </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            c.atEnd </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.currentPage.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.currentPage </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> c.tree.bufferPool.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(nextLeaf)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.cellIndex </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Cursor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetColumn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">colIndex</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read the record for current row</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.currentPage.</span><span style=\"color:#B392F0\">ReadTableCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(c.currentPage.</span><span style=\"color:#B392F0\">CellPointer</span><span style=\"color:#E1E4E8\">(c.cellIndex)))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Deserialize the requested column</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> DeserializeColumn</span><span style=\"color:#E1E4E8\">(record, colIndex)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"column-deserialization\">Column Deserialization</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> DeserializeColumn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">record</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">colIndex</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Parse header to find serial types</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    headerSize, offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(record, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    serialTypes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">SerialType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    headerEnd </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(offset)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> headerEnd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(headerSize) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        st, bytesRead </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(record, headerEnd)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        serialTypes </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(serialTypes, </span><span style=\"color:#B392F0\">SerialType</span><span style=\"color:#E1E4E8\">(st))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        headerEnd </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> bytesRead</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> colIndex </span><span style=\"color:#F97583\">>=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(serialTypes) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: NULL}, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"column index </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> out of range\"</span><span style=\"color:#E1E4E8\">, colIndex)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Skip to the target column</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bodyOffset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> headerEnd</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> colIndex; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bodyOffset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#B392F0\"> serialTypeSize</span><span style=\"color:#E1E4E8\">(serialTypes[i])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Decode the target column</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> decodeValue</span><span style=\"color:#E1E4E8\">(record, bodyOffset, serialTypes[colIndex])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> serialTypeSize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">st</span><span style=\"color:#B392F0\"> SerialType</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> st {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#6A737D\">  // NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#6A737D\">  // 8-bit int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#6A737D\">  // 16-bit int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#6A737D\">  // 24-bit int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#6A737D\">  // 32-bit int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#6A737D\">  // 48-bit int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#6A737D\">  // 64-bit int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> 7</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#6A737D\">  // float</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#6A737D\">  // integer 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> 9</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#6A737D\">  // integer 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> st </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> st</span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">((st </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#6A737D\">// BLOB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> st </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 13</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> st</span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">((st </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 13</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#6A737D\">// TEXT</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> decodeValue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">record</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">st</span><span style=\"color:#B392F0\"> SerialType</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> st {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: NULL}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: INTEGER, Int: </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int8</span><span style=\"color:#E1E4E8\">(record[offset]))}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        val </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int16</span><span style=\"color:#E1E4E8\">(binary.BigEndian.</span><span style=\"color:#B392F0\">Uint16</span><span style=\"color:#E1E4E8\">(record[offset : offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">])))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: INTEGER, Int: val}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        val </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(record[offset : offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">]))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: INTEGER, Int: val}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        val </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(binary.BigEndian.</span><span style=\"color:#B392F0\">Uint64</span><span style=\"color:#E1E4E8\">(record[offset : offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">]))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: INTEGER, Int: val}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> 7</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        val </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> math.</span><span style=\"color:#B392F0\">Float64frombits</span><span style=\"color:#E1E4E8\">(binary.BigEndian.</span><span style=\"color:#B392F0\">Uint64</span><span style=\"color:#E1E4E8\">(record[offset : offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">]))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: REAL, Float: val}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: INTEGER, Int: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> 9</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: INTEGER, Int: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> st </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> st</span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // BLOB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            size </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">((st </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: BLOB, Bytes: record[offset : offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">size]}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> st </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 13</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> st</span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TEXT</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            size </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">((st </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 13</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: TEXT, Str: </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">(record[offset : offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">size])}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: NULL}, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unknown serial type: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, st)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"expression-evaluation-with-three-valued-logic\">Expression Evaluation with Three-Valued Logic</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type  </span><span style=\"color:#B392F0\">ValueType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Int   </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Float </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Str   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Bytes []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ValueType</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    NULL</span><span style=\"color:#B392F0\"> ValueType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INTEGER</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    REAL</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TEXT</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BLOB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">v </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsNull</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> v.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> NULL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">v </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsTruthy</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For WHERE clause filtering</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Only TRUE is truthy; FALSE and NULL are not</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> v.Type {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> NULL:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> INTEGER:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> v.Int </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> REAL:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> v.Float </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> EvaluateComparison</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">op</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">left</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">right</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Three-valued logic: NULL compared to anything is NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> left.</span><span style=\"color:#B392F0\">IsNull</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> right.</span><span style=\"color:#B392F0\">IsNull</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: NULL}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Promote types for comparison</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> left.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> REAL </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> right.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> REAL {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        leftFloat </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> toFloat</span><span style=\"color:#E1E4E8\">(left)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rightFloat </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> toFloat</span><span style=\"color:#E1E4E8\">(right)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        switch</span><span style=\"color:#E1E4E8\"> op {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> \"=\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> boolToValue</span><span style=\"color:#E1E4E8\">(leftFloat </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> rightFloat)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> \"&#x3C;>\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> boolToValue</span><span style=\"color:#E1E4E8\">(leftFloat </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> rightFloat)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> \"&#x3C;\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> boolToValue</span><span style=\"color:#E1E4E8\">(leftFloat </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> rightFloat)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> \"&#x3C;=\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> boolToValue</span><span style=\"color:#E1E4E8\">(leftFloat </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> rightFloat)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> \">\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> boolToValue</span><span style=\"color:#E1E4E8\">(leftFloat </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> rightFloat)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> \">=\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> boolToValue</span><span style=\"color:#E1E4E8\">(leftFloat </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> rightFloat)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Integer comparison</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> op {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"=\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> boolToValue</span><span style=\"color:#E1E4E8\">(left.Int </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> right.Int)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"&#x3C;>\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> boolToValue</span><span style=\"color:#E1E4E8\">(left.Int </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> right.Int)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"&#x3C;\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> boolToValue</span><span style=\"color:#E1E4E8\">(left.Int </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> right.Int)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"&#x3C;=\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> boolToValue</span><span style=\"color:#E1E4E8\">(left.Int </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> right.Int)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \">\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> boolToValue</span><span style=\"color:#E1E4E8\">(left.Int </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> right.Int)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \">=\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> boolToValue</span><span style=\"color:#E1E4E8\">(left.Int </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> right.Int)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: NULL}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> EvaluateAnd</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">left</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">right</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // NULL AND FALSE = FALSE (one false kills it)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> isDefinitelyFalse</span><span style=\"color:#E1E4E8\">(left) </span><span style=\"color:#F97583\">||</span><span style=\"color:#B392F0\"> isDefinitelyFalse</span><span style=\"color:#E1E4E8\">(right) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: INTEGER, Int: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // NULL AND TRUE = NULL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // NULL AND NULL = NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> left.</span><span style=\"color:#B392F0\">IsNull</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> right.</span><span style=\"color:#B392F0\">IsNull</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: NULL}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TRUE AND TRUE = TRUE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: INTEGER, Int: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> EvaluateOr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">left</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">right</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // NULL OR TRUE = TRUE (one true satisfies it)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> isDefinitelyTrue</span><span style=\"color:#E1E4E8\">(left) </span><span style=\"color:#F97583\">||</span><span style=\"color:#B392F0\"> isDefinitelyTrue</span><span style=\"color:#E1E4E8\">(right) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: INTEGER, Int: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // NULL OR FALSE = NULL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // NULL OR NULL = NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> left.</span><span style=\"color:#B392F0\">IsNull</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> right.</span><span style=\"color:#B392F0\">IsNull</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: NULL}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // FALSE OR FALSE = FALSE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: INTEGER, Int: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> EvaluateNot</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">operand</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> operand.</span><span style=\"color:#B392F0\">IsNull</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: NULL}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> boolToValue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">operand.</span><span style=\"color:#B392F0\">IsTruthy</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> isDefinitelyFalse</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">v</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (v.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> INTEGER </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> v.Int </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> (v.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> REAL </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> v.Float </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> isDefinitelyTrue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">v</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (v.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> INTEGER </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> v.Int </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> (v.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> REAL </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> v.Float </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> boolToValue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">b</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> b {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: INTEGER, Int: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: INTEGER, Int: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"where-clause-evaluation-in-the-vm\">WHERE Clause Evaluation in the VM</h3>\n<p>The VM&#39;s comparison opcodes (<code>Eq</code>, <code>Ne</code>, <code>Lt</code>, <code>Le</code>, <code>Gt</code>, <code>Ge</code>) must handle three-valued logic:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">vm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VM</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">executeComparison</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">instr</span><span style=\"color:#B392F0\"> Instruction</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    left </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.Registers[instr.P1]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    right </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.Registers[instr.P3]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> EvaluateComparison</span><span style=\"color:#E1E4E8\">(instr.Opcode, left, right)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Jump only if result is TRUE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If result is NULL or FALSE, continue to next instruction</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> result.</span><span style=\"color:#B392F0\">IsTruthy</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vm.PC </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> instr.P2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm.PC</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>For conditional jumps based on general expressions (not just comparisons):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">case</span><span style=\"color:#9ECBFF\"> \"IfTrue\"</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#6A737D\">// Jump if register is TRUE (not FALSE, not NULL)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> vm.Registers[instr.P1].</span><span style=\"color:#B392F0\">IsTruthy</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vm.PC </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> instr.P2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm.PC</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">case</span><span style=\"color:#9ECBFF\"> \"IfNot\"</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#6A737D\">// Jump if register is FALSE or NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">vm.Registers[instr.P1].</span><span style=\"color:#B392F0\">IsTruthy</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vm.PC </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> instr.P2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm.PC</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">case</span><span style=\"color:#9ECBFF\"> \"IfNull\"</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#6A737D\">// Jump if register is NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> vm.Registers[instr.P1].</span><span style=\"color:#B392F0\">IsNull</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vm.PC </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> instr.P2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm.PC</span><span style=\"color:#F97583\">++</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"building-insert-execution\">Building INSERT Execution</h2>\n<p>INSERT is conceptually simpler than SELECT: serialize the values into a record, insert into the B-tree.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">vm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VM</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">executeInsert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">instr</span><span style=\"color:#B392F0\"> Instruction</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.Cursors[instr.P1]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    recordReg </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> instr.P2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.Registers[recordReg].Bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Insert into B-tree</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> cursor.tree.</span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"constraint-checking-not-null\">Constraint Checking: NOT NULL</h3>\n<p>Before inserting, check constraints:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">InsertRow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">table</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">values</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get table schema</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    schema </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">GetTableSchema</span><span style=\"color:#E1E4E8\">(table)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check NOT NULL constraints</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, col </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> schema.Columns {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> col.NotNull </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> values[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"NOT NULL constraint failed: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, table, col.Name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Serialize and insert</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SerializeRow</span><span style=\"color:#E1E4E8\">(values)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tree </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">GetTableTree</span><span style=\"color:#E1E4E8\">(table)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> tree.</span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The constraint check happens in the compiler or execution layer, not the B-tree. The B-tree just stores bytes—it doesn&#39;t know about constraints.</p>\n<hr>\n<h2 id=\"building-update-execution\">Building UPDATE Execution</h2>\n<p>UPDATE is a delete followed by an insert at the same rowid:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UpdateRows</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">table</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">updates</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#FFAB70\">where</span><span style=\"color:#B392F0\"> Expression</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tree </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">GetTableTree</span><span style=\"color:#E1E4E8\">(table)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    schema </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">GetTableSchema</span><span style=\"color:#E1E4E8\">(table)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> updatedCount </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Scan all rows</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tree.</span><span style=\"color:#B392F0\">NewCursor</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor.</span><span style=\"color:#B392F0\">First</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">cursor.</span><span style=\"color:#B392F0\">AtEnd</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rowid, record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cursor.</span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        values </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> DeserializeRow</span><span style=\"color:#E1E4E8\">(record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Evaluate WHERE clause</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rowMap </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> valuesToMap</span><span style=\"color:#E1E4E8\">(schema, values)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cond </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> EvaluateExpression</span><span style=\"color:#E1E4E8\">(where, rowMap)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> cond.</span><span style=\"color:#B392F0\">IsTruthy</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Apply updates</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            newValues </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(values))</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            copy</span><span style=\"color:#E1E4E8\">(newValues, values)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> colName, newVal </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> updates {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                colIndex </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> schema.</span><span style=\"color:#B392F0\">ColumnIndex</span><span style=\"color:#E1E4E8\">(colName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Check NOT NULL constraint</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> schema.Columns[colIndex].NotNull </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> newVal </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"NOT NULL constraint failed: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, table, colName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                newValues[colIndex] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> newVal</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Delete old row and insert new (same rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cursor.</span><span style=\"color:#B392F0\">Delete</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            newRecord </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SerializeRow</span><span style=\"color:#E1E4E8\">(newValues)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tree.</span><span style=\"color:#B392F0\">InsertAtRowid</span><span style=\"color:#E1E4E8\">(rowid, newRecord)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            updatedCount</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> updatedCount, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Important</strong>: UPDATE cannot change the rowid (primary key). Changing the rowid would require a delete at the old position and insert at the new position—essentially a different operation.</p>\n<hr>\n<h2 id=\"building-delete-execution\">Building DELETE Execution</h2>\n<p>DELETE removes rows matching the WHERE clause:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DeleteRows</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">table</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">where</span><span style=\"color:#B392F0\"> Expression</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tree </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">GetTableTree</span><span style=\"color:#E1E4E8\">(table)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    schema </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">GetTableSchema</span><span style=\"color:#E1E4E8\">(table)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> deletedCount </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> toDelete []</span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">  // Collect rowids to delete</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // First pass: collect matching rowids</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tree.</span><span style=\"color:#B392F0\">NewCursor</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor.</span><span style=\"color:#B392F0\">First</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">cursor.</span><span style=\"color:#B392F0\">AtEnd</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rowid, record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cursor.</span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        values </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> DeserializeRow</span><span style=\"color:#E1E4E8\">(record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rowMap </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> valuesToMap</span><span style=\"color:#E1E4E8\">(schema, values)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cond </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> EvaluateExpression</span><span style=\"color:#E1E4E8\">(where, rowMap)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> cond.</span><span style=\"color:#B392F0\">IsTruthy</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            toDelete </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(toDelete, rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Second pass: delete collected rows</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // (Can't delete while iterating without corrupting cursor state)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, rowid </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> toDelete {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tree.</span><span style=\"color:#B392F0\">Delete</span><span style=\"color:#E1E4E8\">(rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        deletedCount</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> deletedCount, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Two-pass approach</strong>: You cannot delete while iterating—the cursor state becomes invalid. Collect rowids first, then delete.</p>\n<h3 id=\"b-tree-deletion-and-rebalancing\">B-tree Deletion and Rebalancing</h3>\n<p>Deleting a row from a B-tree leaf can leave the page underfull. SQLite&#39;s approach: mark the cell as deleted but don&#39;t immediately rebalance. Rebalancing (merging underfull pages) happens during <code>VACUUM</code> or opportunistically.</p>\n<p>For simplicity, your initial implementation can skip rebalancing. Just remove the cell and update the page. This leaves pages underfull but doesn&#39;t corrupt the tree.</p>\n<hr>\n<h2 id=\"table-existence-checking\">Table Existence Checking</h2>\n<p>Before any operation, verify the table exists:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetTableTree</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BTree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rootPage, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.catalog.</span><span style=\"color:#B392F0\">GetTableRootPage</span><span style=\"color:#E1E4E8\">(tableName)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"no such table: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, tableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> db.btrees[tableName], </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The error message must include the table name:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> nonexistent;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Error: no such table: nonexistent</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"common-pitfalls\">Common Pitfalls</h2>\n<h3 id=\"1-null-null-is-true-wrong\">1. NULL = NULL Is TRUE (Wrong!)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> left.Value </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> right.Value {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> TRUE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RIGHT</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> left.</span><span style=\"color:#B392F0\">IsNull</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> right.</span><span style=\"color:#B392F0\">IsNull</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> NULL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> left.Value </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> right.Value {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> TRUE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Every comparison must check for NULL first.</p>\n<h3 id=\"2-where-null-is-falsy-misleading\">2. WHERE NULL Is Falsy (Misleading!)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#F97583\"> NULL</span></span></code></pre></div>\n\n<p>This returns zero rows—not because NULL is &quot;false,&quot; but because NULL is &quot;not true.&quot; The distinction matters for understanding:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#F97583\"> NOT</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">NULL</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><code>NOT (NULL)</code> is NULL. This also returns zero rows. There is no way to make a NULL predicate return rows.</p>\n<h3 id=\"3-modifying-a-cursor-during-iteration\">3. Modifying a Cursor During Iteration</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Delete during iteration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">cursor.</span><span style=\"color:#B392F0\">AtEnd</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> matches</span><span style=\"color:#E1E4E8\">(cursor) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tree.</span><span style=\"color:#B392F0\">Delete</span><span style=\"color:#E1E4E8\">(cursor.rowid)  </span><span style=\"color:#6A737D\">// Cursor state corrupted!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RIGHT: Collect then delete</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> toDelete []</span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">cursor.</span><span style=\"color:#B392F0\">AtEnd</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> matches</span><span style=\"color:#E1E4E8\">(cursor) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        toDelete </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(toDelete, cursor.rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> _, rowid </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> toDelete {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tree.</span><span style=\"color:#B392F0\">Delete</span><span style=\"color:#E1E4E8\">(rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"4-column-index-off-by-one\">4. Column Index Off-by-One</h3>\n<p>Column indices in your schema might be 0-based, but SQL is 1-based in some contexts. Ensure consistency:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Schema column index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">colIndex </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> schema.</span><span style=\"color:#B392F0\">ColumnIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"name\"</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\">// Returns 0 for first column</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This matches the record format (also 0-based)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">value </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> DeserializeColumn</span><span style=\"color:#E1E4E8\">(record, colIndex)</span></span></code></pre></div>\n\n<h3 id=\"5-update-changing-rowid\">5. UPDATE Changing Rowid</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">UPDATE</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">SET</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 999</span><span style=\"color:#F97583\"> WHERE</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span></span></code></pre></div>\n\n<p>If <code>id</code> is the rowid (INTEGER PRIMARY KEY), this is not a simple UPDATE. The row must be deleted from position 1 and inserted at position 999. Your B-tree must support this, or you must reject such updates.</p>\n<hr>\n<h2 id=\"test-suite-what-to-verify\">Test Suite: What to Verify</h2>\n<p><strong>SELECT with projection:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> users</span><span style=\"color:#E1E4E8\"> (id </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">name</span><span style=\"color:#F97583\"> TEXT</span><span style=\"color:#E1E4E8\">, age </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Alice'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">30</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Bob'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">25</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: (1, 'Alice', 30), (2, 'Bob', 25)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> name</span><span style=\"color:#E1E4E8\">, age </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> users;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: ('Alice', 30), ('Bob', 25)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> age </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 26</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: (1,)</span></span></code></pre></div>\n\n<p><strong>Three-valued logic:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> test</span><span style=\"color:#E1E4E8\"> (a </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#E1E4E8\">, b </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> test </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> test </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> test </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> test </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> test </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: Only (1, 2) - NULL = NULL is not TRUE</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> test </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">IS</span><span style=\"color:#F97583\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: (NULL, 1), (NULL, NULL)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> test </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> OR</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: (1, NULL), (NULL, 1), (1, 2)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- NULL OR TRUE = TRUE, TRUE OR NULL = TRUE</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> test </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> AND</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: (empty)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- TRUE AND NULL = NULL, NULL AND TRUE = NULL</span></span></code></pre></div>\n\n<p><strong>INSERT and verification:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> users</span><span style=\"color:#E1E4E8\"> (id </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#F97583\"> PRIMARY KEY</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">name</span><span style=\"color:#F97583\"> TEXT</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Alice'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: (1, 'Alice')</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Bob'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- If id is INTEGER PRIMARY KEY, NULL means auto-increment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: (2, 'Bob')</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: Error - NOT NULL constraint failed: users.name</span></span></code></pre></div>\n\n<p><strong>UPDATE:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">UPDATE</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">SET</span><span style=\"color:#F97583\"> name</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'Alicia'</span><span style=\"color:#F97583\"> WHERE</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> name</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: 'Alicia'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">UPDATE</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">SET</span><span style=\"color:#F97583\"> name</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> NULL</span><span style=\"color:#F97583\"> WHERE</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: Error - NOT NULL constraint failed: users.name</span></span></code></pre></div>\n\n<p><strong>DELETE:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">DELETE</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: (empty)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">DELETE</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: (empty)</span></span></code></pre></div>\n\n<p><strong>Table existence:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> nonexistent;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: Error - no such table: nonexistent</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> nonexistent </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: Error - no such table: nonexistent</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<p>You&#39;ve just implemented <strong>data manipulation through a virtual machine</strong>—the execution layer that makes SQL useful. Here&#39;s where this connects:</p>\n<p><strong>Immediate connections:</strong></p>\n<ul>\n<li><strong>Secondary indexes (next milestone)</strong>: The same cursor abstraction and deserialization logic applies to index scans. The difference is what the record contains.</li>\n<li><strong>Query planner (Milestone 8)</strong>: The planner chooses between table scans and index scans based on estimated cost. You now have both execution paths.</li>\n</ul>\n<p><strong>Same domain:</strong></p>\n<ul>\n<li><strong>Prepared statements in production databases</strong>: Your bytecode VM can cache compiled programs. A prepared statement is just a bytecode program waiting for parameters. This is why prepared statements are faster for repeated queries.</li>\n<li><strong>ORM query execution</strong>: When you call <code>User.where(age: 18..65)</code> in Rails or <code>User.filter(age &gt;= 18)</code> in SQLAlchemy, the ORM generates SQL that your execution engine processes. Understanding execution helps debug ORM performance issues.</li>\n<li><strong>Trigger execution</strong>: Triggers are SQL statements that execute on INSERT/UPDATE/DELETE. Your execution engine is what runs them.</li>\n</ul>\n<p><strong>Cross-domain:</strong></p>\n<ul>\n<li><strong>Optional types in programming languages</strong>: Rust&#39;s <code>Option&lt;T&gt;</code>, Haskell&#39;s <code>Maybe a</code>, and Java&#39;s <code>Optional&lt;T&gt;</code> all encode the same concept as SQL NULL—a value that may or may not exist. The difference is that SQL NULL propagates through operations (NULL + 5 = NULL), while <code>Option</code> requires explicit handling.</li>\n<li><strong>Data pipeline filtering in ETL systems</strong>: Apache Spark, dbt, and other data tools face the same NULL propagation challenges. A filter like <code>WHERE amount &gt; 100</code> in Spark SQL behaves identically to your implementation.</li>\n<li><strong>CSV/JSON parsing</strong>: Variable-length record handling isn&#39;t unique to databases. A CSV parser that reads &quot;id,name,bio\\n1,Alice,&quot; must handle the empty bio field correctly. The same serial type / body offset pattern applies.</li>\n<li><strong>Constraint checking in ORMs</strong>: Rails validations like <code>validates :name, presence: true</code> implement the same logic as your NOT NULL constraint. The difference is enforcement location: database vs application layer.</li>\n</ul>\n<p><strong>Forward:</strong></p>\n<ul>\n<li><strong>With this knowledge, you could now build</strong>: A query result cache that stores (SQL text, parameters) → (result rows), invalidating on DML to referenced tables; a read replica that executes SELECT queries against a copy of the database; or a change data capture (CDC) system that logs every INSERT/UPDATE/DELETE for downstream consumers.</li>\n</ul>\n<p>The combination of bytecode execution, cursor-based iteration, and three-valued logic is the foundation of SQL query processing. Every database—from SQLite to PostgreSQL to distributed systems like CockroachDB—implements these same patterns.</p>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-sqlite-m7 -->\n<h1 id=\"milestone-7-secondary-indexes\">Milestone 7: Secondary Indexes</h1>\n<h2 id=\"where-we-are-in-the-system\">Where We Are in the System</h2>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-satellite-overview.svg\" alt=\"SQLite Architecture: The Complete System Map\"></p>\n<p>Your database can now execute SELECT, INSERT, UPDATE, and DELETE through the bytecode VM. The B-tree storage engine organizes rows by rowid, enabling efficient full table scans and point lookups. But there&#39;s a glaring performance gap.</p>\n<p>Consider this query:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> email </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'alice@example.com'</span></span></code></pre></div>\n\n<p>Your current implementation performs a <strong>full table scan</strong>: read every row, deserialize the email column, compare to the target. For a table with 1 million users, this reads potentially thousands of pages. Yet the query returns exactly one row.</p>\n<p>The email column is unique—there&#39;s only one matching row. A full scan wastes 999,999 comparisons. What you need is a structure that maps email values directly to their rowids, enabling O(log n) lookup instead of O(n) scan.</p>\n<p>This is the purpose of a <strong>secondary index</strong>: a separate B+tree that stores (column value → rowid) pairs, pointing into the main table B-tree. Create an index on email, and the query becomes: find &#39;<a href=\"mailto:alice@example.com\">alice@example.com</a>&#39; in the index (O(log n)), get the rowid, fetch that single row from the table (O(log n)). Two log-n operations instead of a linear scan.</p>\n<p>But indexes are not free. This milestone reveals why.</p>\n<hr>\n<h2 id=\"the-revelation-indexes-are-not-automatic-magic\">The Revelation: Indexes Are Not Automatic Magic</h2>\n<p>Here&#39;s what most developers assume: &quot;Indexes are just sorted copies of table data. Once I create an index, queries automatically use it. Adding indexes always improves performance.&quot;</p>\n<p>All three assumptions are wrong.</p>\n<h3 id=\"indexes-store-pointers-not-data\">Indexes Store Pointers, Not Data</h3>\n<p>A secondary index does <strong>not</strong> store a copy of the row. It stores a (column value, rowid) pair. The actual row data lives only in the table B-tree.</p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-index-double-lookup.svg\" alt=\"Index Lookup: The Double Lookup Pattern\"></p>\n<p>Consider:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> INDEX</span><span style=\"color:#B392F0\"> idx_email</span><span style=\"color:#F97583\"> ON</span><span style=\"color:#E1E4E8\"> users(email);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> name</span><span style=\"color:#E1E4E8\">, age </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> email </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'alice@example.com'</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p>Execution requires a <strong>double lookup</strong>:</p>\n<ol>\n<li><strong>Index lookup</strong>: Search the email index for &#39;<a href=\"mailto:alice@example.com\">alice@example.com</a>&#39; → find rowid 42</li>\n<li><strong>Table lookup</strong>: Search the table B-tree for rowid 42 → fetch the full row</li>\n<li><strong>Projection</strong>: Extract name and age from the row</li>\n</ol>\n<p>The index gives you the rowid. You must still fetch the row. This is why indexes on columns you never query (like a secret_hash column used only for authentication) are less useful—they require the double lookup, while querying the secret_hash column directly would be a single lookup.</p>\n<h3 id=\"query-planner-decides-not-the-index\">Query Planner Decides, Not the Index</h3>\n<p>Creating an index does not guarantee its use. The query planner must <strong>decide</strong> whether the index helps or hurts.</p>\n<p>For <code>SELECT * FROM users WHERE age &gt; 18</code> on a table where 95% of users are adults:</p>\n<ul>\n<li><strong>Table scan</strong>: Read 1000 pages, filter in memory</li>\n<li><strong>Index scan</strong>: Read index pages to get 950,000 rowids, then perform 950,000 table lookups (one per matching row)</li>\n</ul>\n<p>The index scan is <strong>slower</strong>. Each rowid lookup is a separate B-tree traversal. The planner must estimate: how many rows match the predicate? If it&#39;s a large fraction, a table scan is faster. If it&#39;s a small fraction, the index wins.</p>\n<p>This is <strong>selectivity</strong>: the fraction of rows a predicate matches. Low selectivity (0.1% match) → index helps. High selectivity (90% match) → index hurts.</p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-selectivity-visualization.svg\" alt=\"Selectivity: When Indexes Help vs Hurt\"></p>\n<h3 id=\"every-write-maintains-every-index\">Every Write Maintains Every Index</h3>\n<p>When you execute:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users (id, </span><span style=\"color:#F97583\">name</span><span style=\"color:#E1E4E8\">, email, age) </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Charlie'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'charlie@example.com'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">35</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p>The database must:</p>\n<ol>\n<li>Insert the row into the table B-tree</li>\n<li>Insert (email=&#39;<a href=\"mailto:charlie@example.com\">charlie@example.com</a>&#39;, rowid=100) into the email index</li>\n<li>Insert (age=35, rowid=100) into the age index (if it exists)</li>\n<li>Insert (name=&#39;Charlie&#39;, rowid=100) into the name index (if it exists)</li>\n</ol>\n<p><strong>Every index adds overhead to every write.</strong> A table with 10 indexes has 10x the write cost of a table with no indexes. This is why production databases carefully limit the number of indexes—each one is a tax on INSERT, UPDATE, and DELETE.</p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-index-maintenance.svg\" alt=\"Index Maintenance on INSERT\"></p>\n<hr>\n<h2 id=\"the-tension-read-performance-vs-write-cost\">The Tension: Read Performance vs Write Cost</h2>\n<p>The fundamental tension of indexing is the tradeoff between query speed and write overhead:</p>\n<table>\n<thead>\n<tr>\n<th>Metric</th>\n<th>No Indexes</th>\n<th>Many Indexes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SELECT speed</td>\n<td>Slow (full scans)</td>\n<td>Fast (direct lookups)</td>\n</tr>\n<tr>\n<td>INSERT speed</td>\n<td>Fast (one B-tree update)</td>\n<td>Slow (many B-tree updates)</td>\n</tr>\n<tr>\n<td>UPDATE speed</td>\n<td>Fast (one B-tree update)</td>\n<td>Slow (update indexed columns)</td>\n</tr>\n<tr>\n<td>DELETE speed</td>\n<td>Fast (one B-tree update)</td>\n<td>Slow (remove from all indexes)</td>\n</tr>\n<tr>\n<td>Storage</td>\n<td>Minimal</td>\n<td>Indexes can exceed table size</td>\n</tr>\n</tbody></table>\n<p><strong>The constraint</strong>: You cannot optimize for both reads and writes simultaneously. Every index is a bet that the read performance gain outweighs the write cost over the workload&#39;s lifetime.</p>\n<p>This tension manifests in real systems:</p>\n<ul>\n<li><strong>OLTP (Online Transaction Processing)</strong>: Many writes, few reads per row → fewer indexes</li>\n<li><strong>OLAP (Online Analytical Processing)</strong>: Few writes, many reads → many indexes</li>\n</ul>\n<hr>\n<h2 id=\"three-level-view-from-index-creation-to-query-execution\">Three-Level View: From Index Creation to Query Execution</h2>\n<table>\n<thead>\n<tr>\n<th>Level</th>\n<th>What Happens</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>DDL</strong></td>\n<td>CREATE INDEX builds a new B+tree from existing table data</td>\n<td>Scan table, insert (col, rowid) into new index</td>\n</tr>\n<tr>\n<td><strong>DML</strong></td>\n<td>Every INSERT/UPDATE/DELETE updates all affected indexes</td>\n<td>Insert row, then insert into each index</td>\n</tr>\n<tr>\n<td><strong>Query</strong></td>\n<td>Planner chooses index scan vs table scan, VM executes</td>\n<td>Seek index, get rowids, fetch from table</td>\n</tr>\n</tbody></table>\n<p>The index is a separate data structure with its own B-tree, managed independently from the table B-tree but synchronized on every write.</p>\n<hr>\n<h2 id=\"building-create-index\">Building CREATE INDEX</h2>\n<h3 id=\"index-structure-btree-with-value-rowid-keys\">Index Structure: B+tree with (Value, Rowid) Keys</h3>\n<p>An index B+tree stores entries in leaf pages with this format:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>┌─────────────────┬────────────────┬───────────────────┐\n│ Payload Size    │ Indexed Value  │ Rowid             │\n│ (varint)        │ (serialized)   │ (varint)          │\n└─────────────────┴────────────────┴───────────────────┘</code></pre></div>\n\n<p>The key for ordering is the <strong>composite</strong> of (indexed value, rowid). This ensures:</p>\n<ul>\n<li>Entries are sorted by the indexed value first</li>\n<li>Duplicate values are sorted by rowid (important for non-unique indexes)</li>\n<li>The rowid makes every entry unique even if the indexed value isn&#39;t</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Index</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name       </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tableName  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    columnName </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rootPageID </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    isUnique   </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bufferPool </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SerializeEntry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Serialize the indexed value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    serialType, valueBytes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> EncodeValue</span><span style=\"color:#E1E4E8\">(value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate total size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    valueSize </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(valueBytes)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowidSize </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> varintSize</span><span style=\"color:#E1E4E8\">(rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    totalSize </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> valueSize </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> rowidSize</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Build the entry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">varintSize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(totalSize)) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> totalSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> writeVarint</span><span style=\"color:#E1E4E8\">(buf, offset, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(totalSize))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#B392F0\"> copy</span><span style=\"color:#E1E4E8\">(buf[offset:], valueBytes)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    writeVarint</span><span style=\"color:#E1E4E8\">(buf, offset, rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> buf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DeserializeEntry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">bytesRead</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read payload size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payloadSize, n </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(data, offset)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // The payload contains: serialized value + rowid varint</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // We need to deserialize the value first to know its size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    startOffset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> offset</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read the serial type (first varint in the value encoding)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    serialType, n </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(data, offset)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Decode the value based on serial type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    value, valueSize </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> decodeValue</span><span style=\"color:#E1E4E8\">(data, offset, </span><span style=\"color:#B392F0\">SerialType</span><span style=\"color:#E1E4E8\">(serialType))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> valueSize</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read the rowid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowid, n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(data, offset)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> value, rowid, (offset </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> startOffset) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(n)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"building-the-index-from-existing-data\">Building the Index from Existing Data</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">CreateIndexStatement</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Verify the table exists</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tableRootPage, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.catalog.</span><span style=\"color:#B392F0\">GetTableRootPage</span><span style=\"color:#E1E4E8\">(stmt.TableName)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"no such table: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, stmt.TableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Allocate a root page for the index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexRootPage </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">allocatePage</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Initialize the index B+tree</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexPage </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.bufferPool.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(indexRootPage)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexPage.</span><span style=\"color:#B392F0\">SetPageType</span><span style=\"color:#E1E4E8\">(PageTypeIndexLeaf)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexPage.</span><span style=\"color:#B392F0\">SetCellCount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexPage.</span><span style=\"color:#B392F0\">SetCellContentStart</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexPage.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Scan the table and populate the index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tableTree </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">GetTableTree</span><span style=\"color:#E1E4E8\">(stmt.TableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    index </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        name:       stmt.IndexName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tableName:  stmt.TableName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        columnName: stmt.ColumnName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rootPageID: indexRootPage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        isUnique:   stmt.Unique,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bufferPool: db.bufferPool,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tableTree.</span><span style=\"color:#B392F0\">NewCursor</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor.</span><span style=\"color:#B392F0\">First</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">cursor.</span><span style=\"color:#B392F0\">AtEnd</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rowid, record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cursor.</span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Get the indexed column value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        colIndex </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.schema.</span><span style=\"color:#B392F0\">GetColumnIndex</span><span style=\"color:#E1E4E8\">(stmt.TableName, stmt.ColumnName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        value, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> DeserializeColumn</span><span style=\"color:#E1E4E8\">(record, colIndex)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check UNIQUE constraint if applicable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> stmt.Unique {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            exists, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> index.</span><span style=\"color:#B392F0\">Find</span><span style=\"color:#E1E4E8\">(value)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"UNIQUE constraint failed: duplicate value in index </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, stmt.IndexName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Insert into the index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entry </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> index.</span><span style=\"color:#B392F0\">SerializeEntry</span><span style=\"color:#E1E4E8\">(value, rowid)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> index.</span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(entry); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Record the index in sqlite_master</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"INSERT INTO sqlite_master (type, name, tbl_name, rootpage, sql) VALUES ('index', '</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">', '</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">', </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, '</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">')\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stmt.IndexName, stmt.TableName, indexRootPage, </span><span style=\"color:#B392F0\">serializeCreateIndex</span><span style=\"color:#E1E4E8\">(stmt),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The CREATE INDEX operation is O(n) in the number of rows—it must read every row to build the index. For large tables, this can take significant time, which is why production databases often support <code>CREATE INDEX CONCURRENTLY</code> that builds the index without blocking writes.</p>\n<hr>\n<h2 id=\"index-lookup-equality-search\">Index Lookup: Equality Search</h2>\n<p>For a query like <code>SELECT * FROM users WHERE email = &#39;alice@example.com&#39;</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FindEqual</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">targetValue</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}) ([]</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> rowids []</span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Navigate to the first matching entry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">NewCursor</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    found </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cursor.</span><span style=\"color:#B392F0\">Seek</span><span style=\"color:#E1E4E8\">(targetValue)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">found {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#6A737D\"> // No match</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Collect all matching rowids (for non-unique indexes)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">cursor.</span><span style=\"color:#B392F0\">AtEnd</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        value, rowid </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cursor.</span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Compare the value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cmp </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> compareValues</span><span style=\"color:#E1E4E8\">(value, targetValue)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> cmp </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#6A737D\"> // Past the matching range</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rowids </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(rowids, rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> rowids, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"the-seek-operation\">The Seek Operation</h3>\n<p>The Seek operation finds the first entry &gt;= the target value:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexCursor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Seek</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">targetValue</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start at root</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.pageID </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> c.index.rootPageID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.index.bufferPool.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(c.pageID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">PageType</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PageTypeIndexLeaf {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Binary search within leaf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            c.cellIndex </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">binarySearchLeaf</span><span style=\"color:#E1E4E8\">(page, targetValue)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            c.currentPage </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Check if we found an exact match</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> c.cellIndex </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(page.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                value, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#B392F0\"> compareValues</span><span style=\"color:#E1E4E8\">(value, targetValue) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Internal page: find the right child</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.pageID </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">findChildPage</span><span style=\"color:#E1E4E8\">(page, targetValue)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexCursor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">binarySearchLeaf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">page</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">target</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}) </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cellCount </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(page.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    low, high </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, cellCount</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> low </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> high {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mid </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> (low </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> high) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cellOffset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">CellPointer</span><span style=\"color:#E1E4E8\">(mid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        value, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.index.</span><span style=\"color:#B392F0\">DeserializeEntry</span><span style=\"color:#E1E4E8\">(page.Data, </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(cellOffset))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cmp </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> compareValues</span><span style=\"color:#E1E4E8\">(value, target)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> cmp </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            low </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mid </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> cmp </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            high </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mid </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> mid </span><span style=\"color:#6A737D\">// Exact match</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> low </span><span style=\"color:#6A737D\">// Insertion point</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"range-scan-traversing-leaf-pages\">Range Scan: Traversing Leaf Pages</h2>\n<p>For <code>SELECT * FROM users WHERE age BETWEEN 25 AND 35</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RangeScan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">lowValue</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">highValue</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}) ([]</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> rowids []</span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">NewCursor</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor.</span><span style=\"color:#B392F0\">Seek</span><span style=\"color:#E1E4E8\">(lowValue)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">cursor.</span><span style=\"color:#B392F0\">AtEnd</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        value, rowid </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cursor.</span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check if we've passed the high end of the range</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#B392F0\"> compareValues</span><span style=\"color:#E1E4E8\">(value, highValue) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // This value is in range</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rowids </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(rowids, rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> rowids, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"leaf-page-linking-in-btrees\">Leaf Page Linking in B+trees</h3>\n<p>Index B+trees link leaf pages together for efficient range scans. Each leaf page has a pointer to the next leaf:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IndexLeafPage</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#B392F0\">Page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NextLeaf </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">  // Right-sibling pointer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexLeafPage</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReadHeader</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.Page.</span><span style=\"color:#B392F0\">ReadHeader</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Next leaf pointer stored after the standard header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.NextLeaf </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(p.Data[</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexCursor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.cellIndex</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> c.cellIndex </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(c.currentPage.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Move to next leaf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nextLeaf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.currentPage.NextLeaf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> nextLeaf </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            c.atEnd </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.currentPage.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.currentPage </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> c.index.bufferPool.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(nextLeaf)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.pageID </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> nextLeaf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.cellIndex </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Without leaf linking, a range scan would require navigating through internal pages to find each successive leaf—O(log n) per leaf instead of O(1).</p>\n<hr>\n<h2 id=\"index-maintenance-on-dml\">Index Maintenance on DML</h2>\n<h3 id=\"insert-add-to-all-indexes\">INSERT: Add to All Indexes</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">InsertRow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">table</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">values</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Get table schema and tree</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    schema </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">GetTableSchema</span><span style=\"color:#E1E4E8\">(table)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tree </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">GetTableTree</span><span style=\"color:#E1E4E8\">(table)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Check NOT NULL constraints</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, col </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> schema.Columns {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> col.NotNull </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> values[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"NOT NULL constraint failed: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, table, col.Name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Generate rowid (or use provided)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowid </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">generateRowid</span><span style=\"color:#E1E4E8\">(table)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Serialize and insert into table B-tree</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SerializeRow</span><span style=\"color:#E1E4E8\">(values)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tree.</span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(rowid, record); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Update all indexes on this table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">GetTableIndexes</span><span style=\"color:#E1E4E8\">(table)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, idx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> indexes {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        colIndex </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> schema.</span><span style=\"color:#B392F0\">ColumnIndex</span><span style=\"color:#E1E4E8\">(idx.columnName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        value </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> values[colIndex]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check UNIQUE constraint</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> idx.isUnique {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            exists, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">Find</span><span style=\"color:#E1E4E8\">(value)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> exists {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Rollback the table insert</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                tree.</span><span style=\"color:#B392F0\">Delete</span><span style=\"color:#E1E4E8\">(rowid)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"UNIQUE constraint failed: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, table, idx.columnName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Insert into index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entry </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">SerializeEntry</span><span style=\"color:#E1E4E8\">(value, rowid)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(entry); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Rollback everything on failure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tree.</span><span style=\"color:#B392F0\">Delete</span><span style=\"color:#E1E4E8\">(rowid)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"update-modify-affected-indexes\">UPDATE: Modify Affected Indexes</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UpdateRow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">table</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">updates</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    schema </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">GetTableSchema</span><span style=\"color:#E1E4E8\">(table)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tree </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">GetTableTree</span><span style=\"color:#E1E4E8\">(table)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">GetTableIndexes</span><span style=\"color:#E1E4E8\">(table)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Fetch the current row</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    record, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tree.</span><span style=\"color:#B392F0\">Fetch</span><span style=\"color:#E1E4E8\">(rowid)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    oldValues </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> DeserializeRow</span><span style=\"color:#E1E4E8\">(record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Build new values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newValues </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(oldValues))</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(newValues, oldValues)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> colName, newVal </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> updates {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        colIndex </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> schema.</span><span style=\"color:#B392F0\">ColumnIndex</span><span style=\"color:#E1E4E8\">(colName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check NOT NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> schema.Columns[colIndex].NotNull </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> newVal </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"NOT NULL constraint failed: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, table, colName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        newValues[colIndex] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> newVal</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Update indexes for changed columns</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, idx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> indexes {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        colIndex </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> schema.</span><span style=\"color:#B392F0\">ColumnIndex</span><span style=\"color:#E1E4E8\">(idx.columnName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        oldValue </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> oldValues[colIndex]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        newValue </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> newValues[colIndex]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Skip if the indexed column didn't change</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#B392F0\"> compareValues</span><span style=\"color:#E1E4E8\">(oldValue, newValue) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check UNIQUE constraint on new value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> idx.isUnique {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            existingRowid, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">FindExact</span><span style=\"color:#E1E4E8\">(newValue)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> existingRowid </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> rowid {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"UNIQUE constraint failed: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, table, idx.columnName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Delete old entry from index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        idx.</span><span style=\"color:#B392F0\">Delete</span><span style=\"color:#E1E4E8\">(oldValue, rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Insert new entry into index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entry </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">SerializeEntry</span><span style=\"color:#E1E4E8\">(newValue, rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        idx.</span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(entry)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Update the table B-tree</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newRecord </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SerializeRow</span><span style=\"color:#E1E4E8\">(newValues)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> tree.</span><span style=\"color:#B392F0\">Update</span><span style=\"color:#E1E4E8\">(rowid, newRecord)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"delete-remove-from-all-indexes\">DELETE: Remove from All Indexes</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DeleteRow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">table</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tree </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">GetTableTree</span><span style=\"color:#E1E4E8\">(table)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">GetTableIndexes</span><span style=\"color:#E1E4E8\">(table)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    schema </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">GetTableSchema</span><span style=\"color:#E1E4E8\">(table)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Fetch the row to get values for index deletion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    record, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tree.</span><span style=\"color:#B392F0\">Fetch</span><span style=\"color:#E1E4E8\">(rowid)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    values </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> DeserializeRow</span><span style=\"color:#E1E4E8\">(record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Delete from all indexes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, idx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> indexes {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        colIndex </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> schema.</span><span style=\"color:#B392F0\">ColumnIndex</span><span style=\"color:#E1E4E8\">(idx.columnName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        value </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> values[colIndex]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">Delete</span><span style=\"color:#E1E4E8\">(value, rowid); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Delete from table B-tree</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> tree.</span><span style=\"color:#B392F0\">Delete</span><span style=\"color:#E1E4E8\">(rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"double-lookup-in-the-bytecode-vm\">Double Lookup in the Bytecode VM</h2>\n<p>The VM must coordinate between an index cursor and a table cursor:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Bytecode for: SELECT * FROM users WHERE email = 'alice@example.com'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// (assuming index on email)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 0: OpenIndex cursor=0 rootpage=5    ; Open the email index</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 1: OpenTable cursor=1 rootpage=2    ; Open the users table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 2: String8 'alice@example.com' r0   ; Load the search value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 3: SeekGe cursor=0 r0               ; Position index cursor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 4: Column cursor=0 1 r1             ; Read rowid from index (column 1 is rowid)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 5: SeekRowid cursor=1 r1            ; Position table cursor at rowid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 6: Column cursor=1 0 r2             ; Read id from table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 7: Column cursor=1 1 r3             ; Read name from table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 8: Column cursor=1 2 r4             ; Read email from table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 9: ResultRow r2 3                   ; Output 3 columns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 10: Next cursor=0 4                 ; Loop back for more matches</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 11: Halt</span></span></code></pre></div>\n\n<h3 id=\"vm-implementation-of-seekrowid\">VM Implementation of SeekRowid</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">case</span><span style=\"color:#9ECBFF\"> \"SeekRowid\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.Cursors[instr.P1]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowidReg </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> instr.P2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowid </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.Registers[rowidReg].Int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Seek the table cursor to the rowid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">cursor.</span><span style=\"color:#B392F0\">SeekRowid</span><span style=\"color:#E1E4E8\">(rowid) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Row not found, skip to the next iteration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vm.PC </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> instr.P3 </span><span style=\"color:#6A737D\">// Jump target</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span></code></pre></div>\n\n<h3 id=\"coordinating-two-cursors\">Coordinating Two Cursors</h3>\n<p>The pattern for index-driven queries:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">vm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VM</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">executeIndexScan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">indexCursor</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">tableCursor</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">predicate</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">callback</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    idxCur </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.Cursors[indexCursor]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tblCur </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.Cursors[tableCursor]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">idxCur.</span><span style=\"color:#B392F0\">AtEnd</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Get rowid from index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        _, rowid </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idxCur.</span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Fetch row from table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tblCur.</span><span style=\"color:#B392F0\">SeekRowid</span><span style=\"color:#E1E4E8\">(rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check predicate (if any)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#B392F0\"> predicate</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            callback</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        idxCur.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"unique-index-constraint\">UNIQUE Index Constraint</h2>\n<p>A UNIQUE index rejects duplicate values:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Extract the value and rowid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    value, rowid </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">DeserializeEntry</span><span style=\"color:#E1E4E8\">(entry)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For UNIQUE index, check for existing value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> idx.isUnique {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        existingRowids, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">Find</span><span style=\"color:#E1E4E8\">(value)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(existingRowids) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"UNIQUE constraint failed: duplicate value\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Insert into the B+tree</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> idx.btree.</span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(entry)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The UNIQUE check happens during INSERT and UPDATE, not at index creation time. When creating a UNIQUE index on a table that already has duplicates, the CREATE INDEX fails:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">-- If users table already has duplicate emails:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> UNIQUE INDEX</span><span style=\"color:#B392F0\"> idx_email</span><span style=\"color:#F97583\"> ON</span><span style=\"color:#E1E4E8\"> users(email);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Error: UNIQUE constraint failed: duplicate value</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"covering-indexes-skipping-the-table-lookup\">Covering Indexes: Skipping the Table Lookup</h2>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-covering-index.svg\" alt=\"Covering Index: Skipping the Table Lookup\"></p>\n<p>If all columns needed by a query are in the index, the table lookup can be skipped entirely:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> INDEX</span><span style=\"color:#B392F0\"> idx_email_name</span><span style=\"color:#F97583\"> ON</span><span style=\"color:#E1E4E8\"> users(email, </span><span style=\"color:#F97583\">name</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> name</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> email </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'alice@example.com'</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p>This query only needs <code>email</code> (for the WHERE clause) and <code>name</code> (for the result). Both are in the index. No table lookup required.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Planner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isCoveringIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">query</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">SelectStatement</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">index</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if all referenced columns are in the index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexedColumns </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> index.</span><span style=\"color:#B392F0\">GetColumns</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, col </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> query.</span><span style=\"color:#B392F0\">ReferencedColumns</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#B392F0\">contains</span><span style=\"color:#E1E4E8\">(indexedColumns, col) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Covering indexes are a powerful optimization. A query like <code>SELECT COUNT(*) FROM users WHERE status = &#39;active&#39;</code> with an index on <code>(status)</code> doesn&#39;t need to touch the table at all—the index has all the information.</p>\n<hr>\n<h2 id=\"common-pitfalls\">Common Pitfalls</h2>\n<h3 id=\"1-forgetting-to-update-indexes-on-write\">1. Forgetting to Update Indexes on Write</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Only update the table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">tree.</span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(rowid, record)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BUG: Indexes now have stale data!</span></span></code></pre></div>\n\n<p>Every INSERT, UPDATE, and DELETE must update all affected indexes. Forgetting this causes incorrect query results—index lookups return rowids that don&#39;t exist, or miss rows that do exist.</p>\n<h3 id=\"2-unique-index-allowing-duplicates\">2. UNIQUE Index Allowing Duplicates</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Only check at index creation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> idx.btree.</span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(entry)  </span><span style=\"color:#6A737D\">// No uniqueness check!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>UNIQUE must be enforced on every INSERT and UPDATE, not just at index creation.</p>\n<h3 id=\"3-not-handling-null-in-indexes\">3. Not Handling NULL in Indexes</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> UNIQUE INDEX</span><span style=\"color:#B392F0\"> idx_email</span><span style=\"color:#F97583\"> ON</span><span style=\"color:#E1E4E8\"> users(email);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users (id, email) </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users (id, email) </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Should this succeed or fail?</span></span></code></pre></div>\n\n<p>SQLite allows multiple NULLs in a UNIQUE index (NULL != NULL). Some databases reject this. Document your behavior clearly.</p>\n<h3 id=\"4-index-fragmentation-from-many-deletes\">4. Index Fragmentation from Many Deletes</h3>\n<p>After deleting 90% of rows from a table, the index still has 100% of its pages—most entries are deleted but the pages remain. Index fragmentation wastes space and reduces cache efficiency.</p>\n<p><strong>Solution</strong>: Periodic <code>REINDEX</code> or <code>VACUUM</code> to rebuild fragmented indexes.</p>\n<h3 id=\"5-composite-index-column-order\">5. Composite Index Column Order</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> INDEX</span><span style=\"color:#B392F0\"> idx_name_email</span><span style=\"color:#F97583\"> ON</span><span style=\"color:#E1E4E8\"> users(</span><span style=\"color:#F97583\">name</span><span style=\"color:#E1E4E8\">, email);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> email </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'alice@example.com'</span><span style=\"color:#E1E4E8\">;  </span><span style=\"color:#6A737D\">-- Can't use index efficiently!</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#F97583\"> name</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'Alice'</span><span style=\"color:#E1E4E8\">;               </span><span style=\"color:#6A737D\">-- Can use index</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#F97583\"> name</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'Alice'</span><span style=\"color:#F97583\"> AND</span><span style=\"color:#E1E4E8\"> email </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'alice@example.com'</span><span style=\"color:#E1E4E8\">;  </span><span style=\"color:#6A737D\">-- Can use index</span></span></code></pre></div>\n\n<p>A composite index on (A, B, C) can efficiently serve queries on A, (A, B), or (A, B, C), but not B alone or C alone. The leftmost columns must be specified.</p>\n<hr>\n<h2 id=\"test-suite-what-to-verify\">Test Suite: What to Verify</h2>\n<p><strong>CREATE INDEX:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> users</span><span style=\"color:#E1E4E8\"> (id </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">name</span><span style=\"color:#F97583\"> TEXT</span><span style=\"color:#E1E4E8\">, email </span><span style=\"color:#F97583\">TEXT</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Alice'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'alice@example.com'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Bob'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'bob@example.com'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> INDEX</span><span style=\"color:#B392F0\"> idx_email</span><span style=\"color:#F97583\"> ON</span><span style=\"color:#E1E4E8\"> users(email);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Verify index exists</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> sqlite_master </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#F97583\"> type=</span><span style=\"color:#9ECBFF\">'index'</span><span style=\"color:#F97583\"> AND</span><span style=\"color:#F97583\"> name=</span><span style=\"color:#9ECBFF\">'idx_email'</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p><strong>Index lookup (equality):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> email </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'alice@example.com'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Should use index, read ~2 pages instead of all table pages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Verify by counting buffer pool misses before/after</span></span></code></pre></div>\n\n<p><strong>Index range scan:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> INDEX</span><span style=\"color:#B392F0\"> idx_id</span><span style=\"color:#F97583\"> ON</span><span style=\"color:#E1E4E8\"> users(id);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">BETWEEN</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> AND</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Should traverse index leaves efficiently</span></span></code></pre></div>\n\n<p><strong>UNIQUE constraint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> UNIQUE INDEX</span><span style=\"color:#B392F0\"> idx_unique_email</span><span style=\"color:#F97583\"> ON</span><span style=\"color:#E1E4E8\"> users(email);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Charlie'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'alice@example.com'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: Error - UNIQUE constraint failed</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Charlie'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'charlie@example.com'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: Success</span></span></code></pre></div>\n\n<p><strong>Index maintenance on INSERT:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> INDEX</span><span style=\"color:#B392F0\"> idx_name</span><span style=\"color:#F97583\"> ON</span><span style=\"color:#E1E4E8\"> users(</span><span style=\"color:#F97583\">name</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Diana'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'diana@example.com'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#F97583\"> name</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'Diana'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: Returns (4, 'Diana', 'diana@example.com')</span></span></code></pre></div>\n\n<p><strong>Index maintenance on UPDATE:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">UPDATE</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">SET</span><span style=\"color:#F97583\"> name</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'David'</span><span style=\"color:#F97583\"> WHERE</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#F97583\"> name</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'Diana'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: Empty result</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#F97583\"> name</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'David'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: Returns (4, 'David', 'diana@example.com')</span></span></code></pre></div>\n\n<p><strong>Index maintenance on DELETE:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">DELETE</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#F97583\"> name</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'David'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: Empty result (index entry was deleted)</span></span></code></pre></div>\n\n<p><strong>Double lookup verification:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Verify index lookup followed by table fetch</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">bp </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewBufferPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, diskMgr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewDatabase</span><span style=\"color:#E1E4E8\">(bp)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create table with 1000 rows</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, 'user</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">', 'user</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">@example.com')\"</span><span style=\"color:#E1E4E8\">, i, i, i))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE INDEX idx_email ON users(email)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Reset stats</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">bp.</span><span style=\"color:#B392F0\">ResetStats</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Query with index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM users WHERE email = 'user500@example.com'\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Should read ~2-3 pages (index seek + table fetch), not 100+ pages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Less</span><span style=\"color:#E1E4E8\">(t, bp.Misses, </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<p>You&#39;ve just implemented <strong>secondary indexes</strong>—one of the most impactful database features for query performance. Here&#39;s where this connects:</p>\n<p><strong>Immediate connections:</strong></p>\n<ul>\n<li><strong>Query planner (next milestone)</strong>: The planner needs statistics to decide when an index is beneficial. You now have the execution capability; the planner provides the intelligence.</li>\n<li><strong>Cost model</strong>: The double lookup cost (index seek + table fetch) must be weighed against table scan cost. This is the foundation of cost-based optimization.</li>\n</ul>\n<p><strong>Same domain:</strong></p>\n<ul>\n<li><strong>Covering indexes</strong>: When all queried columns are in the index, the table lookup is skipped entirely. This is why multi-column indexes are powerful—they can &quot;cover&quot; more queries.</li>\n<li><strong>Index-only scans in PostgreSQL/MySQL</strong>: Modern databases track &quot;visibility&quot; in indexes to enable index-only scans even with concurrent updates. Your implementation assumes the table lookup is always needed, but production databases optimize this.</li>\n<li><strong>Write amplification in LSM-trees</strong>: RocksDB and Cassandra use LSM-trees where writes are buffered and periodically merged. Index maintenance in B-trees is synchronous; in LSM-trees, it&#39;s batched. Different tradeoffs, same fundamental concern: indexes add write cost.</li>\n</ul>\n<p><strong>Cross-domain:</strong></p>\n<ul>\n<li><strong>Search engine inverted indexes</strong>: Elasticsearch and Lucene build inverted indexes mapping (term → document IDs). This is the same pattern as your (column value → rowid) mapping. The difference is scale—search engines handle billions of documents and optimize for recall/precision tradeoffs.</li>\n<li><strong>Database replication lag</strong>: In a primary-replica setup, the primary applies writes to all indexes before acknowledging. Replicas replay the write log. If the primary has many indexes, write latency increases, and replication lag grows. This is why read replicas often have fewer indexes than the primary.</li>\n<li><strong>Git object storage</strong>: Git&#39;s pack files index objects by SHA-1 hash. An idx file maps hash prefixes to pack file offsets—essentially an index structure for fast object lookup.</li>\n<li><strong>Elasticsearch/Lucene segment merging</strong>: Multiple index segments must be merged periodically. This is analogous to B-tree rebalancing—maintaining index structure efficiency over time requires maintenance operations.</li>\n</ul>\n<p><strong>Forward:</strong></p>\n<ul>\n<li><strong>With this knowledge, you could now build</strong>: A query cost estimator that predicts whether an index helps or hurts for a given query; a schema advisor that recommends indexes based on query patterns; or a change data capture (CDC) system that tracks which rows were modified by indexing the transaction log.</li>\n</ul>\n<p>Secondary indexes are where database performance tuning lives. Understanding the double lookup pattern, the write overhead, and the selectivity threshold empowers you to design schemas that balance read and write performance—a skill that separates database administrators from developers who &quot;just add indexes until it&#39;s fast.&quot;</p>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-sqlite-m8 -->\n<h1 id=\"milestone-8-query-planner-amp-statistics\">Milestone 8: Query Planner &amp; Statistics</h1>\n<h2 id=\"where-we-are-in-the-system\">Where We Are in the System</h2>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-satellite-overview.svg\" alt=\"SQLite Architecture: The Complete System Map\"></p>\n<p>Your database can now execute queries through bytecode, store data in B-trees, and accelerate lookups with secondary indexes. But there&#39;s a critical missing piece: intelligence.</p>\n<p>When a user runs <code>SELECT * FROM users WHERE age &gt; 21</code>, your database faces a choice:</p>\n<ul>\n<li><strong>Table scan</strong>: Read every page sequentially, filter rows in memory</li>\n<li><strong>Index scan</strong>: Seek the index for matching entries, fetch each row by rowid</li>\n</ul>\n<p>Which is faster? The answer depends on data you don&#39;t have: how many rows match the predicate? What fraction of the table is &quot;age &gt; 21&quot;? Is the index clustered or scattered?</p>\n<p>The query planner is the brain that makes this decision. It estimates the cost of each execution path and chooses the cheapest. Without a planner, your database is like a car without a GPS—it can move, but it doesn&#39;t know the best route.</p>\n<hr>\n<h2 id=\"the-revelation-an-index-can-make-queries-slower\">The Revelation: An Index Can Make Queries Slower</h2>\n<p>Here&#39;s what most developers assume: &quot;Indexes always speed up queries. If I create an index on a column, the database will use it. The optimizer is smart enough to always pick the fastest plan.&quot;</p>\n<p>All three assumptions are catastrophically wrong.</p>\n<h3 id=\"when-indexes-hurt-the-selectivity-trap\">When Indexes Hurt: The Selectivity Trap</h3>\n<p>Consider a <code>users</code> table with 1 million rows and an index on the <code>status</code> column:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> INDEX</span><span style=\"color:#B392F0\"> idx_status</span><span style=\"color:#F97583\"> ON</span><span style=\"color:#E1E4E8\"> users(</span><span style=\"color:#F97583\">status</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#F97583\"> status</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'active'</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p>If 90% of users are active (900,000 rows match), which is faster?</p>\n<p><strong>Table scan</strong>:</p>\n<ul>\n<li>Read ~10,000 pages sequentially</li>\n<li>Filter in memory: 900,000 rows pass</li>\n<li><strong>Total I/O: ~10,000 page reads</strong></li>\n</ul>\n<p><strong>Index scan</strong>:</p>\n<ul>\n<li>Read index pages to find 900,000 matching rowids</li>\n<li>For each rowid, fetch the row from the table</li>\n<li><strong>Total I/O: ~900,000 page reads</strong> (one per matching row, assuming random distribution)</li>\n</ul>\n<p>The index scan is <strong>90x slower</strong>. Each rowid lookup is a random I/O to a different page. Sequential reads (table scan) are vastly faster than random reads (index scan) when the result set is large.</p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-selectivity-visualization.svg\" alt=\"Selectivity: When Indexes Help vs Hurt\"></p>\n<h3 id=\"the-threshold-selectivity-determines-everything\">The Threshold: Selectivity Determines Everything</h3>\n<p><strong>Selectivity</strong> = matching rows / total rows</p>\n<table>\n<thead>\n<tr>\n<th>Selectivity</th>\n<th>Recommended Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&lt; 5%</td>\n<td>Index scan (few rows, random I/O acceptable)</td>\n</tr>\n<tr>\n<td>5-20%</td>\n<td>Either could win, depends on data distribution</td>\n</tr>\n<tr>\n<td>&gt; 20%</td>\n<td>Table scan (many rows, sequential I/O wins)</td>\n</tr>\n<tr>\n<td>&gt; 50%</td>\n<td>Table scan is dramatically faster</td>\n</tr>\n</tbody></table>\n<p>The planner must know the selectivity to choose correctly. Without statistics, it&#39;s flying blind.</p>\n<h3 id=\"flying-blind-the-default-assumption-problem\">Flying Blind: The Default Assumption Problem</h3>\n<p>Before <code>ANALYZE</code> is run, the planner has no statistics. It must assume defaults:</p>\n<ul>\n<li><strong>Default row count</strong>: Assume 1,000,000 rows (or 1000, or 10,000—databases pick different values)</li>\n<li><strong>Default selectivity</strong>: Assume 10% of rows match any equality predicate</li>\n<li><strong>Default distinct values</strong>: Assume 10 distinct values per column</li>\n</ul>\n<p>These defaults are often wrong by orders of magnitude:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">-- Table has 10 rows, planner assumes 1,000,000</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> tiny_table </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Planner chooses table scan (correct for 10 rows)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- But if table had 1M rows, index scan would be right</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Table has 100M rows, planner assumes 1,000</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> huge_table </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#F97583\"> status</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'rare_value'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Planner might choose index scan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- But if 50M rows match, table scan is 1000x faster</span></span></code></pre></div>\n\n<h3 id=\"cardinality-estimation-errors-compound-exponentially\">Cardinality Estimation Errors Compound Exponentially</h3>\n<p>For single-table queries, a 10x cardinality error means a 10x cost error. For joins, errors compound:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> orders o </span><span style=\"color:#F97583\">JOIN</span><span style=\"color:#E1E4E8\"> customers c </span><span style=\"color:#F97583\">ON</span><span style=\"color:#79B8FF\"> o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">customer_id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">WHERE</span><span style=\"color:#79B8FF\"> o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">status</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'pending'</span><span style=\"color:#F97583\"> AND</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">country</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'US'</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p>If the planner underestimates <code>o.status = &#39;pending&#39;</code> by 10x and <code>c.country = &#39;US&#39;</code> by 10x:</p>\n<ul>\n<li>Estimated join result: 1,000 rows</li>\n<li>Actual join result: 100,000 rows</li>\n</ul>\n<p>The join output is off by 100x. If this feeds into another join, the error compounds again. A three-table join with 10x errors at each step produces a 1000x cardinality error.</p>\n<p>This is why production DBAs religiously run <code>ANALYZE</code> after major data changes. Stale statistics cause the planner to choose catastrophically wrong plans.</p>\n<hr>\n<h2 id=\"the-tension-accuracy-vs-estimation-cost\">The Tension: Accuracy vs Estimation Cost</h2>\n<p>The planner faces a fundamental tradeoff:</p>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Accuracy</th>\n<th>Cost</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Exact statistics</strong></td>\n<td>100% accurate</td>\n<td>O(n) per table scan</td>\n</tr>\n<tr>\n<td><strong>Sampled statistics</strong></td>\n<td>~95% accurate</td>\n<td>O(sample size)</td>\n</tr>\n<tr>\n<td><strong>Histograms</strong></td>\n<td>Good for skewed data</td>\n<td>O(buckets) storage</td>\n</tr>\n<tr>\n<td><strong>No statistics</strong></td>\n<td>Default guesses</td>\n<td>Zero cost</td>\n</tr>\n</tbody></table>\n<p>The constraint: you cannot afford to scan the entire table on every query to get exact statistics. The statistics themselves must be collected once (via <code>ANALYZE</code>) and used for many queries.</p>\n<p><strong>The planner&#39;s job</strong>: Make the best decision with imperfect information. Perfect information costs more than the query itself; no information leads to wrong plans. Statistics are the compromise.</p>\n<hr>\n<h2 id=\"three-level-view-from-statistics-to-plan-to-bytecode\">Three-Level View: From Statistics to Plan to Bytecode</h2>\n<p>{{DIAGRAM:diag-query-execution-pipeline}}</p>\n<table>\n<thead>\n<tr>\n<th>Level</th>\n<th>What Happens</th>\n<th>Output</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Statistics</strong></td>\n<td>ANALYZE collects row counts, distinct values</td>\n<td>Metadata stored in system tables</td>\n</tr>\n<tr>\n<td><strong>Planning</strong></td>\n<td>Cost model estimates I/O for each access path</td>\n<td>Chosen plan with estimated cost</td>\n</tr>\n<tr>\n<td><strong>Compilation</strong></td>\n<td>Plan is converted to bytecode</td>\n<td>VDBE program ready for execution</td>\n</tr>\n</tbody></table>\n<p>The planner sits between the parsed AST and the bytecode compiler. It transforms a logical plan (what to do) into a physical plan (how to do it).</p>\n<hr>\n<h2 id=\"building-analyze-collecting-statistics\">Building ANALYZE: Collecting Statistics</h2>\n<h3 id=\"statistics-storage\">Statistics Storage</h3>\n<p>Statistics are stored in a system table, often called <code>sqlite_stat1</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> sqlite_stat1</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tbl </span><span style=\"color:#F97583\">TEXT</span><span style=\"color:#E1E4E8\">,    </span><span style=\"color:#6A737D\">-- Table name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    idx </span><span style=\"color:#F97583\">TEXT</span><span style=\"color:#E1E4E8\">,    </span><span style=\"color:#6A737D\">-- Index name (NULL for table)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stat </span><span style=\"color:#F97583\">TEXT</span><span style=\"color:#6A737D\">    -- Space-separated statistics: \"rows distinct1 distinct2 ...\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p>Example data:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>tbl     | idx         | stat\n--------|-------------|------------------\nusers   | NULL        | 1000000\nusers   | idx_email   | 1000000 1000000\nusers   | idx_status  | 1000000 3\norders  | NULL        | 50000000\norders  | idx_cust_id | 50000000 200000</code></pre></div>\n\n<p>Interpretation:</p>\n<ul>\n<li><code>users</code> table has 1,000,000 rows</li>\n<li><code>idx_email</code> has 1,000,000 distinct values (unique)</li>\n<li><code>idx_status</code> has 3 distinct values (active/inactive/pending)</li>\n<li><code>orders</code> table has 50,000,000 rows</li>\n<li><code>idx_cust_id</code> has 200,000 distinct customer IDs</li>\n</ul>\n<h3 id=\"analyze-implementation\">ANALYZE Implementation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Statistics</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RowCount      </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DistinctCount </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">  // column name -> distinct values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Analyze</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    schema </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">GetTableSchema</span><span style=\"color:#E1E4E8\">(tableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tree </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">GetTableTree</span><span style=\"color:#E1E4E8\">(tableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Count total rows</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> rowCount </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tree.</span><span style=\"color:#B392F0\">NewCursor</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor.</span><span style=\"color:#B392F0\">First</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">cursor.</span><span style=\"color:#B392F0\">AtEnd</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rowCount</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Count distinct values for each indexed column</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    distinctCounts </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">GetTableIndexes</span><span style=\"color:#E1E4E8\">(tableName)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, idx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> indexes {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        distinctCount </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">countDistinctValues</span><span style=\"color:#E1E4E8\">(idx)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        distinctCounts[idx.columnName] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> distinctCount</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Store index statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        statStr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#79B8FF\"> %d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, rowCount, distinctCount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db.</span><span style=\"color:#B392F0\">UpsertStat</span><span style=\"color:#E1E4E8\">(tableName, idx.name, statStr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Store table statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    statStr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, rowCount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">UpsertStat</span><span style=\"color:#E1E4E8\">(tableName, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, statStr)  </span><span style=\"color:#6A737D\">// Empty index name = table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">countDistinctValues</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">idx</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> lastValue </span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">NewCursor</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor.</span><span style=\"color:#B392F0\">First</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">cursor.</span><span style=\"color:#B392F0\">AtEnd</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        value, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cursor.</span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#B392F0\"> compareValues</span><span style=\"color:#E1E4E8\">(value, lastValue) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            count</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            lastValue </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"histogram-storage-advanced\">Histogram Storage (Advanced)</h3>\n<p>For columns with skewed distribution, a single &quot;distinct count&quot; isn&#39;t enough:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">-- Status distribution: 95% active, 4% inactive, 1% pending</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- A query for 'pending' should use the index</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- A query for 'active' should not</span></span></code></pre></div>\n\n<p>Histograms capture this:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Histogram</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ColumnName </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Buckets    []</span><span style=\"color:#B392F0\">HistogramBucket</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> HistogramBucket</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LowerBound </span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    UpperBound </span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Count      </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Distinct   </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">BuildHistogram</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tableName</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">columnName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">numBuckets</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Histogram</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Sample the column values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    values </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">sampleColumnValues</span><span style=\"color:#E1E4E8\">(tableName, columnName, </span><span style=\"color:#79B8FF\">10000</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sort.</span><span style=\"color:#B392F0\">Slice</span><span style=\"color:#E1E4E8\">(values, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">i</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">j</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> compareValues</span><span style=\"color:#E1E4E8\">(values[i], values[j]) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create equal-width buckets</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bucketSize </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(values) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> numBuckets</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buckets </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">HistogramBucket</span><span style=\"color:#E1E4E8\">, numBuckets)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> numBuckets; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> bucketSize</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        end </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> bucketSize</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> numBuckets</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            end </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(values)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buckets[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> HistogramBucket</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LowerBound: values[start],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            UpperBound: values[end</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Count:      </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(end </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Distinct:   </span><span style=\"color:#B392F0\">countDistinct</span><span style=\"color:#E1E4E8\">(values[start:end]),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Histogram</span><span style=\"color:#E1E4E8\">{ColumnName: columnName, Buckets: buckets}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>For this project, distinct counts are sufficient. Histograms are an advanced optimization.</p>\n<hr>\n<h2 id=\"building-the-cost-model\">Building the Cost Model</h2>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-cost-model-comparison.svg\" alt=\"Cost Model: Table Scan vs Index Scan\"></p>\n<h3 id=\"cost-model-table-scan\">Cost Model: Table Scan</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Planner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">costTableScan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">table</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TableInfo</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Table scan reads all pages sequentially</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Cost = number of pages * sequential I/O cost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pages </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">estimatePageCount</span><span style=\"color:#E1E4E8\">(table)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    seqIOCost </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#6A737D\">  // Baseline cost per page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(pages) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> seqIOCost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Planner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">estimatePageCount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">table</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TableInfo</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">getStats</span><span style=\"color:#E1E4E8\">(table.Name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> stats </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // No statistics: assume 1000 pages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1000</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Estimate: rows / rows_per_page</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Average row size varies, but ~20 rows per 4KB page is reasonable</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowsPerPage </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 20</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pages </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> (stats.RowCount </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> rowsPerPage </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> rowsPerPage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Minimum 1 page</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> pages </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pages </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> pages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"cost-model-index-scan\">Cost Model: Index Scan</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Planner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">costIndexScan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">table</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TableInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">index</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">IndexInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">selectivity</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Index scan has two components:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Index traversal: log_f(n) page reads to find start position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Row fetches: selectivity * rows * random I/O per row</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">getStats</span><span style=\"color:#E1E4E8\">(table.Name)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> stats </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // No statistics: assume index is not helpful</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\">30</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\">// Very high cost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    matchingRows </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(stats.RowCount) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> selectivity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Index traversal cost: ~3-4 page reads for B-tree of any size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexTraversalCost </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 4.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Row fetch cost: random I/O per matching row</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Random I/O is ~10x more expensive than sequential I/O</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    randomIOCost </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 10.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // But: if rows are clustered, multiple rows per page</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Assume 20 rows per page, so rows/20 pages actually read</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowsPerPage </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 20.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pagesRead </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> matchingRows </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> rowsPerPage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowFetchCost </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> pagesRead </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> randomIOCost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Total cost</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> indexTraversalCost </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> rowFetchCost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"selectivity-estimation\">Selectivity Estimation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Planner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">estimateSelectivity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">table</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TableInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">predicate</span><span style=\"color:#B392F0\"> Expression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">getStats</span><span style=\"color:#E1E4E8\">(table.Name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> stats </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // No statistics: assume 10% selectivity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0.1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> pred </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> predicate.(</span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">BinaryExpression</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        switch</span><span style=\"color:#E1E4E8\"> pred.Operator {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> \"=\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Equality: 1 / distinct_values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            colName </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> getColumnName</span><span style=\"color:#E1E4E8\">(pred.Left)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            distinct </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> stats.DistinctCount[colName]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> distinct </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                distinct </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#6A737D\">  // Default assumption</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#F97583\"> /</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(distinct)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> \"&#x3C;\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"&#x3C;=\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\">=\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Range: assume 33% selectivity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // (Better: use histogram if available)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 0.33</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> \"!=\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Not equal: 1 - (1/distinct)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            colName </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> getColumnName</span><span style=\"color:#E1E4E8\">(pred.Left)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            distinct </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> stats.DistinctCount[colName]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> distinct </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                distinct </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#F97583\">/float64</span><span style=\"color:#E1E4E8\">(distinct)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">BinaryExpression</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> pred.Operator </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"AND\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // AND: selectivities multiply</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            leftSel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">estimateSelectivity</span><span style=\"color:#E1E4E8\">(table, pred.Left)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            rightSel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">estimateSelectivity</span><span style=\"color:#E1E4E8\">(table, pred.Right)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> leftSel </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> rightSel</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> pred.Operator </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"OR\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // OR: selectivities combine (approximate)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            leftSel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">estimateSelectivity</span><span style=\"color:#E1E4E8\">(table, pred.Left)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            rightSel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">estimateSelectivity</span><span style=\"color:#E1E4E8\">(table, pred.Right)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> leftSel </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> rightSel </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> leftSel</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">rightSel</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Default: 10% selectivity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0.1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"building-the-planner\">Building the Planner</h2>\n<h3 id=\"plan-representation\">Plan Representation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> QueryPlan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AccessPath   </span><span style=\"color:#B392F0\">AccessPath</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EstimatedCost </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EstimatedRows </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AccessPath</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    PlanType</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TableScanPath</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TableName </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TableScanPath</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PlanType</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"TABLE SCAN\"</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IndexScanPath</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TableName  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IndexName  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Predicate  </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Selectivity </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexScanPath</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PlanType</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"INDEX SCAN\"</span><span style=\"color:#E1E4E8\"> }</span></span></code></pre></div>\n\n<h3 id=\"planner-implementation\">Planner Implementation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Planner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PlanSelect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">SelectStatement</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">QueryPlan</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    table </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">getTableInfo</span><span style=\"color:#E1E4E8\">(stmt.FromTable)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> table </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"no such table: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, stmt.FromTable)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Calculate selectivity of WHERE clause</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> selectivity </span><span style=\"color:#F97583\">float64</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1.0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> stmt.Where </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        selectivity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">estimateSelectivity</span><span style=\"color:#E1E4E8\">(table, stmt.Where)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Calculate cost of table scan</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tableScanCost </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">costTableScan</span><span style=\"color:#E1E4E8\">(table)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Find usable indexes and calculate their costs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> bestIndex </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexInfo</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> bestIndexCost </span><span style=\"color:#F97583\">float64</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> math.MaxFloat64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, idx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">getTableIndexes</span><span style=\"color:#E1E4E8\">(table.Name) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check if index is usable for this query</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">p.</span><span style=\"color:#B392F0\">isIndexUsable</span><span style=\"color:#E1E4E8\">(idx, stmt.Where) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        indexCost </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">costIndexScan</span><span style=\"color:#E1E4E8\">(table, idx, selectivity)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> indexCost </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> bestIndexCost {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            bestIndexCost </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> indexCost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            bestIndex </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> idx</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Choose the cheaper option</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">getStats</span><span style=\"color:#E1E4E8\">(table.Name)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> estimatedRows </span><span style=\"color:#F97583\">int64</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1000</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> stats </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        estimatedRows </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">(stats.RowCount) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> selectivity)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> bestIndex </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> bestIndexCost </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> tableScanCost {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">QueryPlan</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            AccessPath: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">IndexScanPath</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                TableName:   table.Name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                IndexName:   bestIndex.Name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Predicate:   stmt.Where,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Selectivity: selectivity,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            EstimatedCost: bestIndexCost,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            EstimatedRows: estimatedRows,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">QueryPlan</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        AccessPath: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">TableScanPath</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            TableName: table.Name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        EstimatedCost: tableScanCost,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        EstimatedRows: estimatedRows,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Planner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isIndexUsable</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">idx</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">IndexInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">where</span><span style=\"color:#B392F0\"> Expression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if the WHERE clause references the indexed column</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> where </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    referencedCols </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> extractReferencedColumns</span><span style=\"color:#E1E4E8\">(where)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, col </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> referencedCols {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> col </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> idx.ColumnName {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"the-selectivity-threshold\">The Selectivity Threshold</h3>\n<p>The planner chooses an index scan only when selectivity is below a threshold:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> IndexSelectivityThreshold</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.2</span><span style=\"color:#6A737D\">  // 20%</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Planner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">shouldUseIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">table</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TableInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">idx</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">IndexInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">selectivity</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> selectivity </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> IndexSelectivityThreshold {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Too many rows match; table scan is faster</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Index scan is likely faster</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>This threshold is a heuristic. Real databases use more sophisticated models that consider:</p>\n<ul>\n<li>Cache behavior (are the pages already in memory?)</li>\n<li>Index clustering (are rows physically ordered by the index?)</li>\n<li>CPU cost (comparing keys vs deserializing rows)</li>\n</ul>\n<hr>\n<h2 id=\"explain-revealing-the-plan\">EXPLAIN: Revealing the Plan</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Planner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Explain</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">plan</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">QueryPlan</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> buf </span><span style=\"color:#B392F0\">strings</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Builder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> ap </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> plan.AccessPath.(</span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TableScanPath</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"TABLE SCAN </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ap.TableName))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">IndexScanPath</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INDEX SCAN </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> VIA </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ap.TableName, ap.IndexName))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\" (selectivity=</span><span style=\"color:#79B8FF\">%.2f%%</span><span style=\"color:#9ECBFF\">)\"</span><span style=\"color:#E1E4E8\">, ap.Selectivity</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">  Estimated rows: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, plan.EstimatedRows))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">  Estimated cost: </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, plan.EstimatedCost))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> buf.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Example output:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">EXPLAIN </span><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> email </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'alice@example.com'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- INDEX SCAN users VIA idx_email (selectivity=0.00%)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">--   Estimated rows: 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">--   Estimated cost: 14.00</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">EXPLAIN </span><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#F97583\"> status</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'active'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Output (assuming 90% active):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- TABLE SCAN users</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">--   Estimated rows: 900000</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">--   Estimated cost: 10000.00</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"join-planning-order-matters\">Join Planning: Order Matters</h2>\n<p>For multi-table queries, the planner must choose a join order:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> orders o </span><span style=\"color:#F97583\">JOIN</span><span style=\"color:#E1E4E8\"> customers c </span><span style=\"color:#F97583\">ON</span><span style=\"color:#79B8FF\"> o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">customer_id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">WHERE</span><span style=\"color:#79B8FF\"> o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">status</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'pending'</span><span style=\"color:#F97583\"> AND</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">country</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'US'</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p>Two possible orders:</p>\n<ol>\n<li><strong>orders → customers</strong>: Find pending orders (assume 1000), then look up customers</li>\n<li><strong>customers → orders</strong>: Find US customers (assume 100000), then look up orders</li>\n</ol>\n<p>Order 1 produces 1000 lookups. Order 2 produces 100,000 lookups. <strong>Order matters</strong>.</p>\n<h3 id=\"join-cardinality-estimation\">Join Cardinality Estimation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Planner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">estimateJoinCardinality</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">left</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">right</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TableInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">joinCondition</span><span style=\"color:#B392F0\"> Expression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leftStats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">getStats</span><span style=\"color:#E1E4E8\">(left.Name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rightStats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">getStats</span><span style=\"color:#E1E4E8\">(right.Name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> leftStats </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> rightStats </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Default: assume cartesian product / 100</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 10000</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Extract join columns</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leftCol, rightCol </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> extractJoinColumns</span><span style=\"color:#E1E4E8\">(joinCondition)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Estimate: smaller table * (1 / distinct values in larger table)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leftDistinct </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> leftStats.DistinctCount[leftCol]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rightDistinct </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> rightStats.DistinctCount[rightCol]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> leftDistinct </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        leftDistinct </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> rightDistinct </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rightDistinct </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Each row in smaller table matches rows / distinct in larger table</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> leftStats.RowCount </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> rightStats.RowCount {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> leftStats.RowCount </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> (rightStats.RowCount </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> rightDistinct)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> rightStats.RowCount </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> (leftStats.RowCount </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> leftDistinct)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"join-order-selection\">Join Order Selection</h3>\n<p>For small numbers of tables (≤10), use dynamic programming:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Planner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">planJoin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tables</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TableInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">conditions</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">QueryPlan</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    n </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(tables)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // dp[mask] = best plan for joining tables in mask</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dp </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">uint32</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">QueryPlan</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Base case: single tables</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, t </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> tables {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mask </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> i</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dp[mask] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">planTableAccess</span><span style=\"color:#E1E4E8\">(t, conditions)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Build up larger joins</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> size </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">; size </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> n; size</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> mask </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">); mask </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> n); mask</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#B392F0\"> bitCount</span><span style=\"color:#E1E4E8\">(mask) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> size {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Try all ways to split mask into left ⊕ right</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> sub </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">); sub </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> mask; sub</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> sub </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> ^</span><span style=\"color:#E1E4E8\">mask </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    continue</span><span style=\"color:#6A737D\">  // sub has bits not in mask</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                left </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sub</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                right </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> mask </span><span style=\"color:#F97583\">^</span><span style=\"color:#E1E4E8\"> sub</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> dp[left] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> dp[right] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Calculate cost of joining left and right</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                joinCost </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> dp[left].EstimatedCost </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> dp[right].EstimatedCost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                joinCard </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">estimateJoinCardinalityFromPlans</span><span style=\"color:#E1E4E8\">(dp[left], dp[right], conditions)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                joinCost </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(joinCard) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 10.0</span><span style=\"color:#6A737D\">  // Per-row join cost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> dp[mask] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> joinCost </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> dp[mask].EstimatedCost {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    dp[mask] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">QueryPlan</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        AccessPath: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">NestedLoopJoinPath</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                            Left:  dp[left],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                            Right: dp[right],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        EstimatedCost: joinCost,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        EstimatedRows: joinCard,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> dp[(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#E1E4E8\">n)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#6A737D\">// Best plan for all tables</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>For this project, a simple greedy approach is sufficient:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Planner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">planJoinGreedy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tables</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TableInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">conditions</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">QueryPlan</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start with the smallest table (after filtering)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    remaining </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TableInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(tables))</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(remaining, tables)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> currentPlan </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">QueryPlan</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(remaining) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Find the table with lowest estimated join cost</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        var</span><span style=\"color:#E1E4E8\"> bestIdx </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        var</span><span style=\"color:#E1E4E8\"> bestCost </span><span style=\"color:#F97583\">float64</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> math.MaxFloat64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i, t </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> remaining {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cost </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">estimateJoinCost</span><span style=\"color:#E1E4E8\">(currentPlan, t, conditions)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> cost </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> bestCost {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                bestCost </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                bestIdx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Add the best table to the plan</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> currentPlan </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            currentPlan </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">planTableAccess</span><span style=\"color:#E1E4E8\">(remaining[bestIdx], conditions)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            currentPlan </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">joinPlans</span><span style=\"color:#E1E4E8\">(currentPlan, p.</span><span style=\"color:#B392F0\">planTableAccess</span><span style=\"color:#E1E4E8\">(remaining[bestIdx], conditions), conditions)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Remove from remaining</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        remaining </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(remaining[:bestIdx], remaining[bestIdx</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:]</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> currentPlan</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"common-pitfalls\">Common Pitfalls</h2>\n<h3 id=\"1-using-an-index-for-low-selectivity-queries\">1. Using an Index for Low-Selectivity Queries</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Always use index if available</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> index </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> indexScanPlan</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RIGHT: Check selectivity threshold</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> index </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> selectivity </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0.2</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> indexScanPlan</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"2-stale-statistics-after-bulk-changes\">2. Stale Statistics After Bulk Changes</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">-- Load 10 million rows</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> logs </span><span style=\"color:#F97583\">SELECT</span><span style=\"color:#E1E4E8\"> ... </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#79B8FF\"> generate_series</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">10000000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Query without ANALYZE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> logs </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#F97583\"> level</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'ERROR'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Planner thinks table has 0 rows, chooses wrong plan</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Solution: Run ANALYZE after bulk changes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ANALYZE logs;</span></span></code></pre></div>\n\n<h3 id=\"3-correlated-predicates-treated-as-independent\">3. Correlated Predicates Treated as Independent</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> products </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> category </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'Electronics'</span><span style=\"color:#F97583\"> AND</span><span style=\"color:#E1E4E8\"> subcategory </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'Laptops'</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p>The planner might estimate selectivity as:</p>\n<ul>\n<li><code>category = &#39;Electronics&#39;</code>: 10%</li>\n<li><code>subcategory = &#39;Laptops&#39;</code>: 5%</li>\n<li>Combined: 10% × 5% = 0.5%</li>\n</ul>\n<p>But in reality, &#39;Laptops&#39; only exists within &#39;Electronics&#39;. The actual selectivity is 5%, not 0.5%.</p>\n<p><strong>Solution</strong>: Correlated column statistics or multi-column histograms. For this project, document the limitation.</p>\n<h3 id=\"4-forcing-plans-without-escape-hatch\">4. Forcing Plans Without Escape Hatch</h3>\n<p>Production databases need <code>FORCE INDEX</code> hints when the planner gets it wrong:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">-- MySQL style</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">FORCE</span><span style=\"color:#F97583\"> INDEX</span><span style=\"color:#E1E4E8\"> (idx_email) </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> email </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'alice@example.com'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- PostgreSQL style</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WITH</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">INDEX</span><span style=\"color:#E1E4E8\">(idx_email)) </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> email </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'alice@example.com'</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p>Your planner should support hints, or at least document how to override bad decisions.</p>\n<hr>\n<h2 id=\"test-suite-what-to-verify\">Test Suite: What to Verify</h2>\n<p><strong>ANALYZE command:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> users</span><span style=\"color:#E1E4E8\"> (id </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">name</span><span style=\"color:#F97583\"> TEXT</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">status</span><span style=\"color:#F97583\"> TEXT</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">SELECT</span><span style=\"color:#E1E4E8\"> ... </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#79B8FF\"> generate_series</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ANALYZE users;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Verify statistics were collected</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> sqlite_stat1 </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> tbl </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'users'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: row count = 1000</span></span></code></pre></div>\n\n<p><strong>Index selection based on selectivity:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Create table with 1000 rows, 10% matching</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDB</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, matchFraction</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0.1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE INDEX idx_status ON users(status)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Query</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">plan </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">PlanQuery</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM users WHERE status = 'rare'\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Should choose index scan (10% &#x3C; 20% threshold)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">IsType</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">IndexScanPath</span><span style=\"color:#E1E4E8\">{}, plan.AccessPath)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Now with 50% matching</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> createTestDB</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, matchFraction</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0.5</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">plan </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">PlanQuery</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM users WHERE status = 'common'\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Should choose table scan (50% > 20% threshold)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">IsType</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">TableScanPath</span><span style=\"color:#E1E4E8\">{}, plan.AccessPath)</span></span></code></pre></div>\n\n<p><strong>EXPLAIN output:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">EXPLAIN </span><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 500</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: Shows scan type, index name (if used), estimated rows</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">EXPLAIN </span><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#F97583\"> status</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'active'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: Shows TABLE SCAN if status is common</span></span></code></pre></div>\n\n<p><strong>Join order optimization:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> orders</span><span style=\"color:#E1E4E8\"> (id </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#E1E4E8\">, customer_id </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">status</span><span style=\"color:#F97583\"> TEXT</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> customers</span><span style=\"color:#E1E4E8\"> (id </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#E1E4E8\">, country </span><span style=\"color:#F97583\">TEXT</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- 1 million orders, 1000 customers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> orders ...</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> customers ...</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ANALYZE;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">EXPLAIN </span><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> orders o </span><span style=\"color:#F97583\">JOIN</span><span style=\"color:#E1E4E8\"> customers c </span><span style=\"color:#F97583\">ON</span><span style=\"color:#79B8FF\"> o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">customer_id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#F97583\"> WHERE</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">country</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'US'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: Start with customers (smaller after filter), then join orders</span></span></code></pre></div>\n\n<p><strong>Fallback without statistics:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">-- New table, no ANALYZE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> new_table</span><span style=\"color:#E1E4E8\"> (id </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">value</span><span style=\"color:#F97583\"> TEXT</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> new_table </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'a'</span><span style=\"color:#E1E4E8\">), (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'b'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">EXPLAIN </span><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> new_table </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: Uses default assumptions, still produces a valid plan</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<p>You&#39;ve just implemented <strong>cost-based query optimization</strong>—the intelligence layer that makes databases fast. Here&#39;s where this connects:</p>\n<p><strong>Immediate connections:</strong></p>\n<ul>\n<li><strong>Previous milestones</strong>: The planner chooses between the table scan (Milestone 6) and index scan (Milestone 7) paths you built. Without the planner, indexes are useless—the database wouldn&#39;t know when to use them.</li>\n<li><strong>EXPLAIN in production</strong>: Every production database query you debug will involve reading an EXPLAIN output. You now understand what &quot;rows=1000&quot; and &quot;cost=14.00&quot; mean.</li>\n</ul>\n<p><strong>Same domain:</strong></p>\n<ul>\n<li><strong>Adaptive query execution in Spark/Presto</strong>: Modern query engines can re-optimize mid-query. If actual cardinalities differ from estimates, they switch strategies on the fly. Your planner is static; theirs is dynamic—but the cost model is the same.</li>\n<li><strong>Database hints and forced plans</strong>: When the planner gets it wrong, production systems need escape hatches. MySQL&#39;s <code>FORCE INDEX</code>, PostgreSQL&#39;s <code>SET enable_seqscan = off</code>, and Oracle&#39;s hints all exist because cost models aren&#39;t perfect.</li>\n<li><strong>Materialized view selection</strong>: Choosing which views to materialize is a planning problem. The same cost-benefit analysis (storage cost vs query speed) applies.</li>\n</ul>\n<p><strong>Cross-domain:</strong></p>\n<ul>\n<li><strong>Compiler optimization passes</strong>: LLVM and GCC run multiple optimization passes, each with a cost model. Dead code elimination, loop unrolling, and function inlining all follow cost-benefit analysis. A loop that runs 3 times shouldn&#39;t be unrolled; a loop that runs 1000000 times should. The same selectivity logic applies.</li>\n<li><strong>Network routing protocols</strong>: OSPF and BGP use cost-based path selection. Each router estimates the &quot;cost&quot; of paths through neighbors and chooses the cheapest. The analogy is exact: network topology ≈ join graph, link cost ≈ I/O cost, path selection ≈ join ordering.</li>\n<li><strong>Machine learning cost models</strong>: Neo4J and other modern databases use ML models trained on query logs to predict execution time. Your cost model is hand-crafted; theirs is learned. But both estimate cost from statistics.</li>\n<li><strong>Caching decisions in CDNs</strong>: A CDN must decide whether to cache content at edge locations. The decision depends on request frequency (selectivity), content size (I/O cost), and storage cost. Same tradeoffs, different domain.</li>\n</ul>\n<p><strong>Forward:</strong></p>\n<ul>\n<li><strong>With this knowledge, you could now build</strong>: A query advisor that analyzes slow query logs and recommends indexes; a database tuner that suggests when to run ANALYZE; or a query visualizer that shows why the planner chose a particular plan.</li>\n</ul>\n<p>The query planner is where database theory meets engineering reality. Statistics are imperfect, cost models are approximations, and yet—most of the time—the planner gets it right. Understanding why it sometimes gets it wrong (and how to fix it) is a skill that separates database experts from application developers.</p>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-sqlite-m9 -->\n<h1 id=\"milestone-9-transactions-rollback-journal\">Milestone 9: Transactions (Rollback Journal)</h1>\n<h2 id=\"where-we-are-in-the-system\">Where We Are in the System</h2>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-satellite-overview.svg\" alt=\"SQLite Architecture: The Complete System Map\"></p>\n<p>Your database can parse SQL, compile it to bytecode, execute queries against B-trees, and use indexes to accelerate lookups. But there&#39;s a catastrophic vulnerability hiding in plain sight.</p>\n<p>Pull the power cord at the wrong moment, and your database file becomes corrupt. Not &quot;some data lost&quot; corrupt—arbitrarily, unrecoverably corrupt. A half-written page here, a missing index entry there, and the entire file is garbage.</p>\n<p>Transactions are the armor against this existential threat. They guarantee <strong>atomicity</strong>: either all changes commit, or none do. A crash at any instant leaves the database in a consistent state. This is not optional—it&#39;s the defining characteristic of a database versus a file format.</p>\n<hr>\n<h2 id=\"the-revelation-durability-requires-write-ordering-not-immediate-writes\">The Revelation: Durability Requires Write Ordering, Not Immediate Writes</h2>\n<p>Here&#39;s what most developers assume: &quot;To ensure durability, I should write data to disk immediately. If the OS buffers writes, I&#39;ll lose data on crash, so I&#39;ll disable all caching and use O_SYNC on every write.&quot;</p>\n<p>This assumption is catastrophically wrong. Immediate writes don&#39;t solve the problem—they make it worse.</p>\n<h3 id=\"the-torn-page-problem\">The Torn Page Problem</h3>\n<p>Consider a B-tree page being updated. The page is 4096 bytes. You modify a cell, adjust the header, update the free space pointer. Then you write the page to disk.</p>\n<p>A crash mid-write might leave only the first 2048 bytes on disk. This is a <strong>torn page</strong>—half old data, half new data, completely invalid.</p>\n<p>If you were updating the B-tree root page, the entire tree is now corrupt. Every query will crash or return garbage.</p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-crash-recovery-scenarios.svg\" alt=\"Crash Recovery: All Failure Modes\"></p>\n<h3 id=\"the-write-ordering-solution\">The Write Ordering Solution</h3>\n<p>You cannot prevent crashes. You cannot prevent torn pages. What you <em>can</em> do is ensure that <strong>after any crash, you can recover to a consistent state</strong>.</p>\n<p>The rollback journal is the key:</p>\n<ol>\n<li><strong>Before</strong> modifying any page in the database file, write the original page to the journal</li>\n<li><strong>fsync</strong> the journal to ensure it&#39;s on stable storage</li>\n<li><strong>Then</strong> modify the database file</li>\n<li>On commit, delete the journal</li>\n</ol>\n<p>If a crash occurs:</p>\n<ul>\n<li><strong>Before journal fsync</strong>: The journal is incomplete or missing. The database is unchanged. Consistent.</li>\n<li><strong>After journal fsync, before database write completes</strong>: The journal has original pages. On restart, detect the &quot;hot journal&quot; and restore from it. Consistent.</li>\n<li><strong>After commit (journal deleted)</strong>: All changes are in the database. Consistent.</li>\n</ul>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-rollback-journal-flow.svg\" alt=\"Rollback Journal: Write Ordering\"></p>\n<p>The critical insight: <strong>the journal must be durable before the database is modified</strong>. This is write ordering. Not &quot;write immediately&quot;—write in a specific sequence that guarantees recoverability.</p>\n<h3 id=\"what-the-journal-contains\">What the Journal Contains</h3>\n<p>The journal stores <strong>complete original page images</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>┌─────────────────────────────────────────────────────────────┐\n│ Journal Header                                              │\n│ - Magic number (identifies this as a journal)               │\n│ - Database page count                                       │\n│ - Checksum algorithm ID                                     │\n│ - Salt values for checksum                                  │\n└─────────────────────────────────────────────────────────────┘\n┌─────────────────────────────────────────────────────────────┐\n│ Page Record 1                                               │\n│ - Page number (4 bytes)                                     │\n│ - Page data (4096 bytes, the ORIGINAL content)              │\n│ - Checksum                                                  │\n└─────────────────────────────────────────────────────────────┘\n┌─────────────────────────────────────────────────────────────┐\n│ Page Record 2                                               │\n│ - Page number                                               │\n│ - Page data (another original page)                         │\n│ - Checksum                                                  │\n└─────────────────────────────────────────────────────────────┘\n│ ... additional page records ...                             |\n└─────────────────────────────────────────────────────────────┘</code></pre></div>\n\n<p>Each page record is a complete 4096-byte snapshot of the page <em>before</em> it was modified. On recovery, you copy these pages back into the database file, overwriting any partial or torn writes.</p>\n<hr>\n<h2 id=\"the-tension-durability-vs-performance\">The Tension: Durability vs Performance</h2>\n<p>Every transaction involves:</p>\n<ol>\n<li>Write original pages to journal</li>\n<li>fsync journal</li>\n<li>Write modified pages to database</li>\n<li>fsync database (optional, depends on pragma)</li>\n<li>Delete journal</li>\n<li>fsync directory (to ensure journal deletion is durable)</li>\n</ol>\n<p>Each <code>fsync</code> is a disk round-trip: 25-100 microseconds on SSD, 5-10 milliseconds on HDD. A transaction touching 10 pages might require 3+ fsyncs—that&#39;s potentially 30+ milliseconds of pure waiting.</p>\n<p><strong>The constraint</strong>: Durability requires fsync. Performance hates fsync. You cannot have both fast commits and guaranteed durability.</p>\n<p>The tension manifests in production as:</p>\n<ul>\n<li><strong>Users disable fsync</strong> (<code>PRAGMA synchronous=OFF</code>) for speed, accepting data loss on crash</li>\n<li><strong>Group commits</strong> batch multiple transactions into one fsync</li>\n<li><strong>WAL mode</strong> (next milestone) reduces fsync frequency by logging changes instead of pages</li>\n</ul>\n<p>For rollback journal mode, accept the cost: durable transactions are slow. That&#39;s the tradeoff.</p>\n<hr>\n<h2 id=\"three-level-view-from-sql-transaction-to-disk-operations\">Three-Level View: From SQL Transaction to Disk Operations</h2>\n<table>\n<thead>\n<tr>\n<th>Level</th>\n<th>What Happens</th>\n<th>Durability Guarantee</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>SQL</strong></td>\n<td>BEGIN, execute statements, COMMIT/ROLLBACK</td>\n<td>User&#39;s mental model of &quot;all or nothing&quot;</td>\n</tr>\n<tr>\n<td><strong>Buffer Pool</strong></td>\n<td>Pages are marked dirty, journal records original content</td>\n<td>In-memory state tracks what needs recovery</td>\n</tr>\n<tr>\n<td><strong>Disk</strong></td>\n<td>Journal write → fsync → database write → journal delete</td>\n<td>Physical write ordering ensures crash recovery</td>\n</tr>\n</tbody></table>\n<p>The transaction manager coordinates these levels, translating SQL semantics into disk operations with correct ordering.</p>\n<hr>\n<h2 id=\"acid-the-four-pillars\">ACID: The Four Pillars</h2>\n<p>Before diving into implementation, understand what you&#39;re guaranteeing:</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Meaning</th>\n<th>How Rollback Journal Implements It</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Atomicity</strong></td>\n<td>All changes commit, or none do</td>\n<td>Journal enables rollback on crash</td>\n</tr>\n<tr>\n<td><strong>Consistency</strong></td>\n<td>Database transitions from one valid state to another</td>\n<td>Constraint checking (NOT NULL, UNIQUE) before commit</td>\n</tr>\n<tr>\n<td><strong>Isolation</strong></td>\n<td>Concurrent transactions don&#39;t see each other&#39;s partial work</td>\n<td>Locking (simplified: one writer at a time)</td>\n</tr>\n<tr>\n<td><strong>Durability</strong></td>\n<td>Committed changes survive crashes</td>\n<td>fsync journal before database modification</td>\n</tr>\n</tbody></table>\n<p>This milestone focuses on <strong>Atomicity</strong> and <strong>Durability</strong> via the rollback journal. <strong>Consistency</strong> is implemented by constraint checking in earlier milestones. <strong>Isolation</strong> requires locking, which we&#39;ll cover at a basic level.</p>\n<hr>\n<h2 id=\"building-the-transaction-manager\">Building the Transaction Manager</h2>\n<h3 id=\"transaction-state\">Transaction State</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TransactionState</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TxNone</span><span style=\"color:#B392F0\"> TransactionState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span><span style=\"color:#6A737D\">  // No active transaction</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TxActive</span><span style=\"color:#6A737D\">                         // BEGIN executed, waiting for COMMIT/ROLLBACK</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TxCommitted</span><span style=\"color:#6A737D\">                      // COMMIT executed</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TxRolledBack</span><span style=\"color:#6A737D\">                     // ROLLBACK executed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TransactionManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state       </span><span style=\"color:#B392F0\">TransactionState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bufferPool  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    journal     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RollbackJournal</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    modifiedPages </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\">  // Original content of modified pages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dbFile      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">os</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">File</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dbPath      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TransactionManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Begin</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> tm.state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> TxActive {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"transaction already active\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tm.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> TxActive</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tm.modifiedPages </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"the-rollback-journal-structure\">The Rollback Journal Structure</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RollbackJournal</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    path       </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // dbPath + \"-journal\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    file       </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">os</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">File</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    header     </span><span style=\"color:#B392F0\">JournalHeader</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pageRecords []</span><span style=\"color:#B392F0\">PageRecord</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    isOpen     </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> JournalHeader</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Magic        </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">  // 0xd9d505f9 (SQLite's magic number)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FormatVersion </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">  // 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PageCount    </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">  // Number of pages in database</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ChecksumAlg  </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">  // Checksum algorithm</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Salt1, Salt2 </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">  // Random values for checksum</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Checksum1, Checksum2 </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">  // Header checksum</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PageRecord</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PageNum  </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Data     []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\">  // 4096 bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Checksum1, Checksum2 </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> JournalMagic</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">d9d505f9</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> JournalHeaderSize</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 28</span></span></code></pre></div>\n\n<h3 id=\"creating-the-journal\">Creating the Journal</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TransactionManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">createJournal</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    journalPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tm.dbPath </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"-journal\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create the journal file</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    file, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Create</span><span style=\"color:#E1E4E8\">(journalPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to create journal: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tm.journal </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">RollbackJournal</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        path:     journalPath,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        file:     file,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pageRecords: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">PageRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        isOpen:   </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write journal header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    header </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> JournalHeader</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Magic:         JournalMagic,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        FormatVersion: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        PageCount:     tm.</span><span style=\"color:#B392F0\">getPageCount</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ChecksumAlg:   </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Simple checksum</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Salt1:         rand.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Salt2:         rand.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tm.journal.header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tm.</span><span style=\"color:#B392F0\">writeJournalHeader</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">j </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RollbackJournal</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">writeJournalHeader</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, JournalHeaderSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">], j.header.Magic)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">], j.header.FormatVersion)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">], j.header.PageCount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">], j.header.ChecksumAlg)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">], j.header.Salt1)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">24</span><span style=\"color:#E1E4E8\">], j.header.Salt2)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate header checksum</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cs1, cs2 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> calculateChecksum</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">24</span><span style=\"color:#E1E4E8\">], j.header.Salt1, j.header.Salt2)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">24</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">28</span><span style=\"color:#E1E4E8\">], cs1)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> j.file.</span><span style=\"color:#B392F0\">WriteAt</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"recording-page-modifications\">Recording Page Modifications</h3>\n<p>The key moment: <strong>before any page is modified, record its original content</strong>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TransactionManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">BeforePageModified</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageID</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">pageData</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> tm.state </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> TxActive {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#6A737D\">  // Not in a transaction, nothing to journal</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if we've already recorded this page</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> _, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tm.modifiedPages[pageID]; exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#6A737D\">  // Already saved the original</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Save the original page content</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    original </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(pageData))</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(original, pageData)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tm.modifiedPages[pageID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> original</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write to journal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> tm.journal.</span><span style=\"color:#B392F0\">WritePageRecord</span><span style=\"color:#E1E4E8\">(pageID.PageNum, original)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">j </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RollbackJournal</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">WritePageRecord</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageNum</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> PageRecord</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        PageNum: pageNum,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Data:    data,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate checksum</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    record.Checksum1, record.Checksum2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> calculateChecksum</span><span style=\"color:#E1E4E8\">(data, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        j.header.Salt1, j.header.Salt2)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    j.pageRecords </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(j.pageRecords, record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write to file: page number + data + checksum</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#F97583\"> +</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(data) </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">], pageNum)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#F97583\">+</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(data)], data)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#F97583\">+</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(data):], record.Checksum1)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(JournalHeaderSize </span><span style=\"color:#F97583\">+</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(j.pageRecords) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#F97583\"> +</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(data) </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> j.file.</span><span style=\"color:#B392F0\">WriteAt</span><span style=\"color:#E1E4E8\">(buf, offset)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"integration-with-buffer-pool\">Integration with Buffer Pool</h3>\n<p>The buffer pool must call <code>BeforePageModified</code> when a page is first modified:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">MarkDirty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageID</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frameIdx, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.pageTable[pageID]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"page not in buffer pool\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    meta </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">bp.metadata[frameIdx]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // First modification in transaction?</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">meta.Dirty </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> bp.txManager </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> bp.txManager.state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> TxActive {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Record original content before marking dirty</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.txManager.</span><span style=\"color:#B392F0\">BeforePageModified</span><span style=\"color:#E1E4E8\">(pageID, bp.frames[frameIdx])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    meta.Dirty </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"commit-making-changes-permanent\">COMMIT: Making Changes Permanent</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TransactionManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Commit</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> tm.state </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> TxActive {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"no active transaction\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Sync the journal to disk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This ensures all original pages are durable BEFORE we modify the database</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tm.journal.file.</span><span style=\"color:#B392F0\">Sync</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to sync journal: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Write all dirty pages to the database file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tm.bufferPool.</span><span style=\"color:#B392F0\">FlushAll</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to flush dirty pages: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Sync the database file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This ensures modified pages are on disk</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tm.dbFile.</span><span style=\"color:#B392F0\">Sync</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to sync database: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Delete the journal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Once the journal is deleted, the transaction is committed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tm.</span><span style=\"color:#B392F0\">deleteJournal</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to delete journal: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Sync the directory to ensure journal deletion is durable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tm.</span><span style=\"color:#B392F0\">syncDirectory</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to sync directory: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tm.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> TxCommitted</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tm.modifiedPages </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TransactionManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">deleteJournal</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> tm.journal </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tm.journal.file.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Remove</span><span style=\"color:#E1E4E8\">(tm.journal.path)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tm.journal </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TransactionManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">syncDirectory</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dirPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Dir</span><span style=\"color:#E1E4E8\">(tm.dbPath)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dirFile, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Open</span><span style=\"color:#E1E4E8\">(dirPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> dirFile.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> dirFile.</span><span style=\"color:#B392F0\">Sync</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"the-critical-write-ordering\">The Critical Write Ordering</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>┌──────────────────────────────────────────────────────────────────────┐\n│                        COMMIT WRITE ORDERING                         │\n├──────────────────────────────────────────────────────────────────────┤\n│                                                                      │\n│   1. Write journal (original pages)                                  │\n│      │                                                               │\n│      ▼                                                               │\n│   2. fsync journal  ◄─── CRITICAL POINT                              │\n│      │                   Journal is now durable                      │\n│      ▼                   Recovery is possible                        │\n│   3. Write database (modified pages)                                 │\n│      │                                                               │\n│      ▼                                                               │\n│   4. fsync database                                                  │\n│      │                                                               │\n│      ▼                                                               │\n│   5. Delete journal                                                  │\n│      │                                                               │\n│      ▼                                                               │\n│   6. fsync directory                                                 │\n│      │                                                               │\n│      ▼                                                               │\n│   COMMIT COMPLETE                                                    │\n│                                                                      │\n└──────────────────────────────────────────────────────────────────────┘</code></pre></div>\n\n<p>If you crash at any point:</p>\n<ul>\n<li><strong>Before step 2</strong>: Journal may be incomplete. Database unchanged. On restart, no hot journal detected. No recovery needed.</li>\n<li><strong>After step 2, before step 5</strong>: Journal is durable. Database may be partially written. On restart, hot journal detected. Restore from journal.</li>\n<li><strong>After step 5</strong>: Journal is deleted. All changes are in the database. Transaction committed.</li>\n</ul>\n<hr>\n<h2 id=\"rollback-undoing-changes\">ROLLBACK: Undoing Changes</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TransactionManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Rollback</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> tm.state </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> TxActive {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"no active transaction\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Restore all pages from the journal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> pageID, originalData </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> tm.modifiedPages {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tm.</span><span style=\"color:#B392F0\">restorePage</span><span style=\"color:#E1E4E8\">(pageID, originalData); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Invalidate modified pages in buffer pool</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> pageID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> tm.modifiedPages {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tm.bufferPool.</span><span style=\"color:#B392F0\">InvalidatePage</span><span style=\"color:#E1E4E8\">(pageID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Delete the journal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tm.</span><span style=\"color:#B392F0\">deleteJournal</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tm.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> TxRolledBack</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tm.modifiedPages </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TransactionManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">restorePage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageID</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write the original page back to the database file</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(pageID.PageNum) </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(tm.bufferPool.pageSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tm.dbFile.</span><span style=\"color:#B392F0\">WriteAt</span><span style=\"color:#E1E4E8\">(data, offset)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"buffer-pool-invalidation\">Buffer Pool Invalidation</h3>\n<p>After rollback, any cached copies of modified pages in the buffer pool are stale. They must be invalidated:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">InvalidatePage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageID</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frameIdx, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.pageTable[pageID]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mark the frame as empty</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    delete</span><span style=\"color:#E1E4E8\">(bp.pageTable, pageID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bp.metadata[frameIdx] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> FrameMetadata</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        PageID: </span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{FileID: </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, PageNum: </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"crash-recovery-detecting-and-applying-the-hot-journal\">Crash Recovery: Detecting and Applying the Hot Journal</h2>\n<p>On database startup, check for a hot journal:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">recoverFromCrash</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    journalPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.path </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"-journal\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if journal exists</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Stat</span><span style=\"color:#E1E4E8\">(journalPath); os.</span><span style=\"color:#B392F0\">IsNotExist</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // No journal, database is clean</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fmt.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Hot journal detected at </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, initiating recovery...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, journalPath)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Open and validate the journal</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    journal, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> openJournal</span><span style=\"color:#E1E4E8\">(journalPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to open journal: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> journal.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read all page records and restore them</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        record, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> journal.</span><span style=\"color:#B392F0\">ReadNextPageRecord</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> io.EOF {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to read journal record: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Verify checksum</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cs1, cs2 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> calculateChecksum</span><span style=\"color:#E1E4E8\">(record.Data, journal.header.Salt1, journal.header.Salt2)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> cs1 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> record.Checksum1 </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> cs2 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> record.Checksum2 {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"journal checksum mismatch for page </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, record.PageNum)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Restore the page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(record.PageNum) </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(db.pageSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        _, err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> db.file.</span><span style=\"color:#B392F0\">WriteAt</span><span style=\"color:#E1E4E8\">(record.Data, offset)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to restore page </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, record.PageNum, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        fmt.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Restored page </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, record.PageNum)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Sync the database</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.file.</span><span style=\"color:#B392F0\">Sync</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Delete the journal</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    os.</span><span style=\"color:#B392F0\">Remove</span><span style=\"color:#E1E4E8\">(journalPath)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fmt.</span><span style=\"color:#B392F0\">Println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Recovery complete.\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> openJournal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RollbackJournal</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    file, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Open</span><span style=\"color:#E1E4E8\">(path)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    headerBuf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, JournalHeaderSize)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> file.</span><span style=\"color:#B392F0\">ReadAt</span><span style=\"color:#E1E4E8\">(headerBuf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        file.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    header </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> JournalHeader</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Magic:         binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(headerBuf[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">]),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        FormatVersion: binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(headerBuf[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">]),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        PageCount:     binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(headerBuf[</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">]),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ChecksumAlg:   binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(headerBuf[</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">]),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Salt1:         binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(headerBuf[</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Salt2:         binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(headerBuf[</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">24</span><span style=\"color:#E1E4E8\">]),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Checksum1:     binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(headerBuf[</span><span style=\"color:#79B8FF\">24</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">28</span><span style=\"color:#E1E4E8\">]),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify magic number</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> header.Magic </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> JournalMagic {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        file.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid journal magic number\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">RollbackJournal</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        path:   path,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        file:   file,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        header: header,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        isOpen: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">j </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RollbackJournal</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReadNextPageRecord</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PageRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    recordSize </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#F97583\"> +</span><span style=\"color:#79B8FF\"> 4096</span><span style=\"color:#F97583\"> +</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#6A737D\">  // page num + data + checksum</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, recordSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(JournalHeaderSize </span><span style=\"color:#F97583\">+</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(j.pageRecords) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> recordSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> j.file.</span><span style=\"color:#B392F0\">ReadAt</span><span style=\"color:#E1E4E8\">(buf, offset)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">PageRecord</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        PageNum:  binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">]),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Data:     buf[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Checksum1: binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">:]),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    j.pageRecords </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(j.pageRecords, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> record, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"isolation-basic-locking\">Isolation: Basic Locking</h2>\n<p>For this milestone, implement a simple locking scheme: <strong>one writer at a time</strong>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LockManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    writeLock </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    readers   </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex     </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Mutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">lm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LockManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AcquireWriteLock</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lm.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> lm.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> lm.writeLock {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"database is locked (write in progress)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> lm.readers </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"database is locked (readers active)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lm.writeLock </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">lm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LockManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReleaseWriteLock</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lm.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> lm.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lm.writeLock </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">lm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LockManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AcquireReadLock</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lm.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> lm.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> lm.writeLock {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"database is locked (write in progress)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lm.readers</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">lm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LockManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReleaseReadLock</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lm.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> lm.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lm.readers</span><span style=\"color:#F97583\">--</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"transaction-visibility\">Transaction Visibility</h3>\n<p>Changes made during a transaction are <strong>not visible to other connections</strong> until COMMIT:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ExecuteWrite</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sql</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Acquire write lock</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.lockManager.</span><span style=\"color:#B392F0\">AcquireWriteLock</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> db.lockManager.</span><span style=\"color:#B392F0\">ReleaseWriteLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start transaction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.txManager.</span><span style=\"color:#B392F0\">Begin</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Execute the statement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... (this will modify pages and journal them)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Commit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> db.txManager.</span><span style=\"color:#B392F0\">Commit</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Other connections attempting to write will block until the transaction completes. Readers see the database state as of the last committed transaction.</p>\n<hr>\n<h2 id=\"sql-interface-begin-commit-rollback\">SQL Interface: BEGIN, COMMIT, ROLLBACK</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">parseTransactionStatement</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">Statement</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> KEYWORD </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"BEGIN\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">BeginStatement</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> KEYWORD </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"COMMIT\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">CommitStatement</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.current.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> KEYWORD </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> p.current.Value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"ROLLBACK\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">RollbackStatement</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, p.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"expected BEGIN, COMMIT, or ROLLBACK\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ExecuteTransactionStatement</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#B392F0\"> Statement</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> s </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> stmt.(</span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">BeginStatement</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> db.txManager.</span><span style=\"color:#B392F0\">Begin</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">CommitStatement</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> db.txManager.</span><span style=\"color:#B392F0\">Commit</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">RollbackStatement</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> db.txManager.</span><span style=\"color:#B392F0\">Rollback</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"auto-commit-mode\">Auto-Commit Mode</h3>\n<p>By default, each statement is its own transaction (auto-commit):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sql</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If not in explicit transaction, auto-commit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    autoCommit </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.txManager.state </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> TxActive</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> autoCommit {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db.txManager.</span><span style=\"color:#B392F0\">Begin</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Parse and execute</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stmt, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.parser.</span><span style=\"color:#B392F0\">Parse</span><span style=\"color:#E1E4E8\">(sql)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> autoCommit {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            db.txManager.</span><span style=\"color:#B392F0\">Rollback</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">executeStatement</span><span style=\"color:#E1E4E8\">(stmt)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> autoCommit {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            db.txManager.</span><span style=\"color:#B392F0\">Rollback</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> db.txManager.</span><span style=\"color:#B392F0\">Commit</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"common-pitfalls\">Common Pitfalls</h2>\n<h3 id=\"1-writing-database-before-journal\">1. Writing Database Before Journal</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Modify database, then journal</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">bp.</span><span style=\"color:#B392F0\">MarkDirty</span><span style=\"color:#E1E4E8\">(pageID)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">modifyPage</span><span style=\"color:#E1E4E8\">(page)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">tm.journal.</span><span style=\"color:#B392F0\">WritePageRecord</span><span style=\"color:#E1E4E8\">(pageID, originalData)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RIGHT: Journal first, then modify</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">tm.journal.</span><span style=\"color:#B392F0\">WritePageRecord</span><span style=\"color:#E1E4E8\">(pageID, originalData)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">bp.</span><span style=\"color:#B392F0\">MarkDirty</span><span style=\"color:#E1E4E8\">(pageID)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">modifyPage</span><span style=\"color:#E1E4E8\">(page)</span></span></code></pre></div>\n\n<p>If you crash after modifying the database but before writing the journal, you have no way to undo the change. The database is corrupt.</p>\n<h3 id=\"2-forgetting-to-fsync-the-journal\">2. Forgetting to fsync the Journal</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: No fsync</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">tm.journal.file.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">(journalData)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">tm.bufferPool.</span><span style=\"color:#B392F0\">FlushAll</span><span style=\"color:#E1E4E8\">()  </span><span style=\"color:#6A737D\">// Write database immediately</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RIGHT: fsync journal first</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">tm.journal.file.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">(journalData)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">tm.journal.file.</span><span style=\"color:#B392F0\">Sync</span><span style=\"color:#E1E4E8\">()    </span><span style=\"color:#6A737D\">// Ensure journal is durable</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">tm.bufferPool.</span><span style=\"color:#B392F0\">FlushAll</span><span style=\"color:#E1E4E8\">()  </span><span style=\"color:#6A737D\">// Now write database</span></span></code></pre></div>\n\n<p>Without the fsync, the journal write might be in the OS cache. A crash loses the journal, and you can&#39;t recover.</p>\n<h3 id=\"3-partial-page-writes-torn-pages\">3. Partial Page Writes (Torn Pages)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Assume writes are atomic</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">tm.dbFile.</span><span style=\"color:#B392F0\">WriteAt</span><span style=\"color:#E1E4E8\">(pageData, offset)  </span><span style=\"color:#6A737D\">// Might write only partial data!</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RIGHT: Journal contains complete pages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Journal has the full 4096-byte original</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Recovery restores the complete page, overwriting any torn write</span></span></code></pre></div>\n\n<p>The journal must contain <strong>complete</strong> page images. If a page is partially written during a crash, recovery overwrites it with the complete original from the journal.</p>\n<h3 id=\"4-not-detecting-hot-journals-on-startup\">4. Not Detecting Hot Journals on Startup</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Open database without checking for journal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.file, _ </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">OpenFile</span><span style=\"color:#E1E4E8\">(path, os.O_RDWR, </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RIGHT: Check for hot journal first</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.file, _ </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">OpenFile</span><span style=\"color:#E1E4E8\">(path, os.O_RDWR, </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check for hot journal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">recoverFromCrash</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db.file.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>If you don&#39;t check for hot journals, an interrupted transaction leaves the database in an inconsistent state forever.</p>\n<h3 id=\"5-lock-deadlocks\">5. Lock Deadlocks</h3>\n<p>With multiple connections and fine-grained locking, deadlocks are possible:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Connection A: Lock table users\nConnection B: Lock table orders\nConnection A: Wait for orders (blocked)\nConnection B: Wait for users (blocked)</code></pre></div>\n\n<p><strong>Simple solution</strong>: Single write lock (what we implemented). One writer at a time eliminates deadlocks at the cost of concurrency.</p>\n<hr>\n<h2 id=\"test-suite-what-to-verify\">Test Suite: What to Verify</h2>\n<p><strong>BEGIN/COMMIT/ROLLBACK commands:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">BEGIN</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Alice'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">COMMIT</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: (1, 'Alice')</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">BEGIN</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Bob'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">ROLLBACK</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: Only (1, 'Alice'), Bob was rolled back</span></span></code></pre></div>\n\n<p><strong>Journal file creation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"BEGIN\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (1, 'Alice')\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Journal file should exist</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">_, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Stat</span><span style=\"color:#E1E4E8\">(db.path </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"-journal\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"COMMIT\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Journal file should be deleted</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">_, err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Stat</span><span style=\"color:#E1E4E8\">(db.path </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"-journal\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">True</span><span style=\"color:#E1E4E8\">(t, os.</span><span style=\"color:#B392F0\">IsNotExist</span><span style=\"color:#E1E4E8\">(err))</span></span></code></pre></div>\n\n<p><strong>Write ordering verification:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Track fsync order</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> fsyncOrder []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">mockDisk </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">MockDiskManager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OnFsync: </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        fsyncOrder </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(fsyncOrder, path)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"BEGIN\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (1, 'Alice')\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"COMMIT\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Journal should be fsync'd before database</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"journal\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"database\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"directory\"</span><span style=\"color:#E1E4E8\">}, fsyncOrder)</span></span></code></pre></div>\n\n<p><strong>Crash recovery:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Simulate a crash</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"BEGIN\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (1, 'Alice')\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// COMMIT not called - simulate crash</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Reopen database</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db2 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> OpenDatabase</span><span style=\"color:#E1E4E8\">(db.path)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Should have detected hot journal and rolled back</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db2.</span><span style=\"color:#B392F0\">QueryRow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT COUNT(*) FROM users\"</span><span style=\"color:#E1E4E8\">).</span><span style=\"color:#B392F0\">Scan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">count)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, count)  </span><span style=\"color:#6A737D\">// Transaction was rolled back</span></span></code></pre></div>\n\n<p><strong>Isolation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">db1 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> OpenDatabase</span><span style=\"color:#E1E4E8\">(path)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db2 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> OpenDatabase</span><span style=\"color:#E1E4E8\">(path)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db1.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"BEGIN\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db1.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (1, 'Alice')\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// db2 should not see uncommitted changes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db2.</span><span style=\"color:#B392F0\">QueryRow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT COUNT(*) FROM users\"</span><span style=\"color:#E1E4E8\">).</span><span style=\"color:#B392F0\">Scan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">count)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, count)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db1.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"COMMIT\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Now db2 can see the changes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db2.</span><span style=\"color:#B392F0\">QueryRow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT COUNT(*) FROM users\"</span><span style=\"color:#E1E4E8\">).</span><span style=\"color:#B392F0\">Scan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">count)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, count)</span></span></code></pre></div>\n\n<p><strong>Torn page simulation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Write partial page, then crash</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"BEGIN\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (1, 'Alice')\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Partially write database file, leave journal intact</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">writePartialPage</span><span style=\"color:#E1E4E8\">(db.path, pageID, partialData)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Reopen - should recover</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db2 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> OpenDatabase</span><span style=\"color:#E1E4E8\">(db.path)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Database should be in pre-transaction state</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<p>You&#39;ve just implemented <strong>ACID transactions with crash recovery</strong>—the foundation of reliable data storage. Here&#39;s where this connects:</p>\n<p><strong>Immediate connections:</strong></p>\n<ul>\n<li><strong>WAL mode (next milestone)</strong>: The rollback journal enables recovery but blocks readers during writes. WAL is an alternative that enables concurrent readers and writers using the same journaling principle.</li>\n<li><strong>All previous milestones</strong>: Every B-tree modification, every index update, every INSERT/UPDATE/DELETE now participates in a transaction. The database is no longer fragile—it survives crashes.</li>\n</ul>\n<p><strong>Same domain:</strong></p>\n<ul>\n<li><strong>Database replication</strong>: Transaction logs shipped to replicas are essentially journals. The replica replays the log to catch up. Same write-ahead principle, different context.</li>\n<li><strong>Point-in-time recovery</strong>: If you keep journals (archive them instead of deleting), you can restore a database to any point in time. This is how production databases recover from user errors.</li>\n<li><strong>Distributed transactions (2PC)</strong>: Two-phase commit extends the rollback journal concept across multiple databases. Each participant logs its intention before committing, enabling atomic cross-database transactions.</li>\n</ul>\n<p><strong>Cross-domain:</strong></p>\n<ul>\n<li><strong>Git object model</strong>: Git&#39;s append-only object store is a form of journaling. Commits are atomic snapshots—if the write is interrupted, the commit doesn&#39;t exist. The ref update is the &quot;commit&quot; point, analogous to journal deletion.</li>\n<li><strong>File system journaling (ext4, HFS+, NTFS)</strong>: Modern file systems use the same technique. Metadata changes are logged before being applied. A crash mid-operation is recovered by replaying or rolling back the journal.</li>\n<li><strong>Crash-only software design</strong>: Systems designed to recover from crashes are more robust than those trying to prevent crashes. Your database now embodies this principle: pull the power cord, restart, and it just works.</li>\n<li><strong>Distributed consensus (Raft, Paxos)</strong>: Write-ahead logging is the foundation of distributed atomic commitment. A Raft leader logs commands before applying them; followers acknowledge before committing. The journal is the persistent log that enables recovery and consensus.</li>\n</ul>\n<p><strong>Forward:</strong></p>\n<ul>\n<li><strong>With this knowledge, you could now build</strong>: A database backup system that copies the database file while transactions are in progress (copy + journal + recover); a change data capture (CDC) system that monitors the journal for changes; or a distributed database that replicates journals across nodes.</li>\n</ul>\n<p>The rollback journal is where databases transition from &quot;interesting exercise&quot; to &quot;production-ready system.&quot; You can now store critical data—financial transactions, user accounts, medical records—with confidence that a power failure won&#39;t corrupt it. This is the trust that makes databases valuable.</p>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-sqlite-m10 -->\n<h1 id=\"milestone-10-wal-mode\">Milestone 10: WAL Mode</h1>\n<h2 id=\"where-we-are-in-the-system\">Where We Are in the System</h2>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-satellite-overview.svg\" alt=\"SQLite Architecture: The Complete System Map\"></p>\n<p>Your rollback journal provides ACID transactions with crash recovery. But it has a fundamental limitation: <strong>writers block readers</strong>.</p>\n<p>When a transaction modifies the database:</p>\n<ol>\n<li>The rollback journal is created</li>\n<li>Pages are modified in the database file</li>\n<li>Until COMMIT, no other connection can safely read the database</li>\n</ol>\n<p>This is because the database file itself is being modified. A reader that opens mid-transaction might see half-written pages, inconsistent indexes, or partial updates. The only safe approach is to block all readers during writes.</p>\n<p>For read-heavy workloads (web applications, analytics), this is tolerable. For mixed workloads with concurrent reads and writes, it&#39;s a bottleneck. A long-running write transaction blocks all reads for its entire duration.</p>\n<p>Write-Ahead Logging (WAL) solves this by <strong>never modifying the database file during a transaction</strong>. Instead, changes are appended to a separate WAL file. Readers see a consistent snapshot of the database while writers append new versions. This enables true concurrent reads and writes—at the cost of additional complexity.</p>\n<hr>\n<h2 id=\"the-revelation-wal-enables-true-concurrency\">The Revelation: WAL Enables True Concurrency</h2>\n<p>Here&#39;s what most developers assume: &quot;WAL and rollback journal are equivalent approaches to durability. WAL just appends instead of overwriting, but the performance is the same.&quot;</p>\n<p>This assumption is wrong. WAL doesn&#39;t just change <em>where</em> writes go—it fundamentally transforms the concurrency model.</p>\n<h3 id=\"the-reader-writer-conflict-in-rollback-journal-mode\">The Reader-Writer Conflict in Rollback Journal Mode</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-rollback-vs-wal.svg\" alt=\"Rollback Journal vs WAL: Architecture Comparison\"></p>\n<p>In rollback journal mode:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Timeline:\n─────────────────────────────────────────────────────────────\nWriter:  BEGIN ──► Modify pages ──► COMMIT\n                      │\n                      ▼\nReaders: BLOCKED ═════════════════► UNBLOCKED</code></pre></div>\n\n<p>The database file is the source of truth. When a writer modifies it, readers can&#39;t safely access it. The lock must be held for the entire transaction duration.</p>\n<h3 id=\"wal-mode-readers-and-writers-coexist\">WAL Mode: Readers and Writers Coexist</h3>\n<p>In WAL mode:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Timeline:\n─────────────────────────────────────────────────────────────\nWriter:  BEGIN ──► Append to WAL ──► COMMIT\n                      │\n                      ▼\nWAL:     [Page v1] ──► [Page v2] ──► [Page v3]\n                      │\nReaders: ════════════════════════════════════════\n         Read snapshot from DB + WAL up to point X</code></pre></div>\n\n<p>The database file is <strong>never modified during a transaction</strong>. All changes go to the WAL. Readers:</p>\n<ol>\n<li>Note the current WAL position when they start</li>\n<li>Read pages from the database file OR the WAL (whichever is newer)</li>\n<li>See a consistent snapshot as of their start time</li>\n</ol>\n<p>A writer appending to the WAL doesn&#39;t affect a reader that started earlier—the reader simply doesn&#39;t see those newer WAL entries.</p>\n<p>{{DIAGRAM:diag-wal-architecture}}</p>\n<h3 id=\"the-cost-complexity-and-checkpointing\">The Cost: Complexity and Checkpointing</h3>\n<p>This concurrency isn&#39;t free:</p>\n<ol>\n<li><p><strong>Checkpointing</strong>: The WAL grows with every write. Periodically, its contents must be merged back into the database file. This is a checkpoint—a batch operation that blocks briefly.</p>\n</li>\n<li><p><strong>Page version lookup</strong>: Readers must check the WAL for newer versions of pages before falling back to the database. This requires a <strong>WAL-index</strong>—a shared memory structure mapping (page number → latest WAL position).</p>\n</li>\n<li><p><strong>Snapshot management</strong>: Each reader pins a &quot;snapshot&quot; of the WAL. The WAL can&#39;t be checkpointed past the oldest active snapshot, or that reader would lose access to pages it might still need.</p>\n</li>\n<li><p><strong>Recovery complexity</strong>: On crash, the WAL must be replayed to restore uncommitted changes. The replay logic is more complex than rollback journal recovery.</p>\n</li>\n</ol>\n<p>The WAL is a bet that the concurrency gain outweighs the complexity cost. For most workloads, it&#39;s the right bet—which is why WAL is the default in PostgreSQL, MySQL&#39;s InnoDB, and modern SQLite deployments.</p>\n<hr>\n<h2 id=\"the-tension-wal-growth-vs-checkpoint-frequency\">The Tension: WAL Growth vs Checkpoint Frequency</h2>\n<p>Every write appends to the WAL. Without checkpointing, the WAL grows unbounded:</p>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>WAL Size</th>\n<th>Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1 million inserts, no checkpoint</td>\n<td>~4 GB</td>\n<td>Disk space exhausted</td>\n</tr>\n<tr>\n<td>Checkpoint every 1000 pages</td>\n<td>~4 MB</td>\n<td>Bounded, but frequent pauses</td>\n</tr>\n<tr>\n<td>Long-running reader + no checkpoint</td>\n<td>Unbounded</td>\n<td>Reader pins old WAL frames</td>\n</tr>\n</tbody></table>\n<p><strong>The constraint</strong>: You must checkpoint frequently enough to bound WAL size, but not so frequently that checkpoint overhead dominates. And checkpointing is blocked by long-running readers.</p>\n<p>This tension manifests as:</p>\n<ul>\n<li><strong>Auto-checkpoint thresholds</strong>: Trigger checkpoint after N pages (SQLite defaults to 1000)</li>\n<li><strong>Passive vs aggressive checkpointing</strong>: Passive checkpointing only copies pages not currently in use; aggressive checkpointing blocks writers to make progress</li>\n<li><strong>WAL file size monitoring</strong>: Production systems alert when WAL exceeds a threshold, indicating checkpoint issues</li>\n</ul>\n<hr>\n<h2 id=\"three-level-view-from-sql-write-to-wal-to-database\">Three-Level View: From SQL Write to WAL to Database</h2>\n<table>\n<thead>\n<tr>\n<th>Level</th>\n<th>What Happens</th>\n<th>File Touched</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Transaction</strong></td>\n<td>INSERT/UPDATE/DELETE modifies pages</td>\n<td>Pages modified in buffer pool</td>\n</tr>\n<tr>\n<td><strong>WAL Append</strong></td>\n<td>Modified pages written to WAL with checksum</td>\n<td><code>.db-wal</code> file</td>\n</tr>\n<tr>\n<td><strong>Checkpoint</strong></td>\n<td>WAL pages copied to database file</td>\n<td><code>.db</code> file</td>\n</tr>\n</tbody></table>\n<p>The database file is only modified during checkpoints, not during regular transactions. This is the key to concurrent access.</p>\n<hr>\n<h2 id=\"wal-file-format\">WAL File Format</h2>\n<p>The WAL file is a sequence of <strong>frames</strong>, each containing a page image and metadata:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>┌─────────────────────────────────────────────────────────────┐\n│ WAL Header (32 bytes)                                        │\n│ - Magic number (0x377f0682 or 0x377f0683)                   │\n│ - File format version                                        │\n│ - Page size                                                  │\n│ - Checkpoint sequence number                                 │\n│ - Salt-1, Salt-2 (random values for checksum)               │\n│ - Checksum-1, Checksum-2 (header checksum)                  │\n└─────────────────────────────────────────────────────────────┘\n┌─────────────────────────────────────────────────────────────┐\n│ Frame 1                                                      │\n│ - Frame header (24 bytes)                                    │\n│   - Page number (4 bytes)                                    │\n│   - Commit marker (4 bytes, non-zero for COMMIT frames)      │\n│   - Salt-1, Salt-2 (must match header)                      │\n│   - Checksum-1, Checksum-2 (cumulative checksum)            │\n│ - Page data (page_size bytes)                               │\n└─────────────────────────────────────────────────────────────┘\n┌─────────────────────────────────────────────────────────────┐\n│ Frame 2                                                      │\n│ - ... same structure ...                                     │\n└─────────────────────────────────────────────────────────────┘\n│ ... additional frames ...                                    │\n└─────────────────────────────────────────────────────────────┘</code></pre></div>\n\n<h3 id=\"wal-header\">WAL Header</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WALHeader</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Magic         </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">  // 0x377f0682 (little-endian) or 0x377f0683 (big-endian)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FormatVersion </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">  // 3007000</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PageSize      </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CheckpointSeq </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Salt1         </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Salt2         </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Checksum1     </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Checksum2     </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> WALHeaderSize</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 32</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> FrameHeaderSize</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 24</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WAL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">WriteHeader</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, WALHeaderSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">], w.header.Magic)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">], w.header.FormatVersion)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">], w.header.PageSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">], w.header.CheckpointSeq)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">], w.header.Salt1)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">24</span><span style=\"color:#E1E4E8\">], w.header.Salt2)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate header checksum</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cs1, cs2 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> walChecksum</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">24</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, w.header.Magic)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">24</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">28</span><span style=\"color:#E1E4E8\">], cs1)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">28</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">], cs2)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.header.Checksum1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cs1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.header.Checksum2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cs2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> w.file.</span><span style=\"color:#B392F0\">WriteAt</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"frame-structure\">Frame Structure</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> FrameHeader</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PageNumber  </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CommitSize  </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">  // Database size in pages after commit, 0 if not a commit frame</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Salt1       </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Salt2       </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Checksum1   </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Checksum2   </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WAL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">WriteFrame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageNum</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">pageData</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">isCommit</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">dbSize</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frame </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> FrameHeader</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        PageNumber: pageNum,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CommitSize: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Salt1:      w.header.Salt1,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Salt2:      w.header.Salt2,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> isCommit {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        frame.CommitSize </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> dbSize</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate cumulative checksum</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frame.Checksum1, frame.Checksum2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> walChecksum</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pageData,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.lastChecksum1,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.lastChecksum2,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.header.Magic,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write frame header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    headerBuf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, FrameHeaderSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(headerBuf[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">], frame.PageNumber)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(headerBuf[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">], frame.CommitSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(headerBuf[</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">], frame.Salt1)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(headerBuf[</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">], frame.Salt2)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(headerBuf[</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">], frame.Checksum1)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(headerBuf[</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">24</span><span style=\"color:#E1E4E8\">], frame.Checksum2)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(WALHeaderSize </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> w.frameCount </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> (FrameHeaderSize </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> w.pageSize))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write header</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> w.file.</span><span style=\"color:#B392F0\">WriteAt</span><span style=\"color:#E1E4E8\">(headerBuf, offset); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write page data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> w.file.</span><span style=\"color:#B392F0\">WriteAt</span><span style=\"color:#E1E4E8\">(pageData, offset </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> FrameHeaderSize); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.frameCount</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.lastChecksum1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> frame.Checksum1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.lastChecksum2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> frame.Checksum2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"checksum-algorithm\">Checksum Algorithm</h3>\n<p>The WAL uses a cumulative checksum to detect corruption anywhere in the file:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> walChecksum</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">s1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">s2</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">magic</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">uint32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // SQLite uses a modified Fletcher-32 checksum</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // The algorithm depends on the magic number's endianness</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> magic </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">377f0683</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Big-endian checksum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(data); i </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#F97583\"> &#x3C;=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(data) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                v1 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(data[i : i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                v2 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(data[i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\"> : i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                s1 </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> v1 </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> s2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                s2 </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> v2 </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> s1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Little-endian checksum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(data); i </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#F97583\"> &#x3C;=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(data) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                v1 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> binary.LittleEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(data[i : i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                v2 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> binary.LittleEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(data[i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\"> : i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                s1 </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> v1 </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> s2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                s2 </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> v2 </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> s1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> s1, s2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"wal-page-lookup-the-wal-index\">WAL Page Lookup: The WAL-Index</h2>\n<p>Readers need to find the most recent version of each page. Scanning the entire WAL for every page read is O(n)—unacceptable.</p>\n<p>The solution is the <strong>WAL-index</strong>: a shared memory structure that maps (page number → latest frame position).</p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-wal-page-lookup.svg\" alt=\"WAL Page Lookup: Finding the Latest Version\"></p>\n<h3 id=\"wal-index-structure\">WAL-Index Structure</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WALIndex</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Shared memory mapping</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    shmPath   </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // .db-shm file</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    shmFile   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">os</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">File</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    shmData   []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\">  // Memory-mapped</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hash table: page number → frame index</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Multiple hash tables for different snapshots</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hashTables []</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WALIndexHash</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WALIndexHash</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Entries [</span><span style=\"color:#B392F0\">WALIndexHashSize</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">WALIndexEntry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WALIndexEntry</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PageNumber </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FrameIndex </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">  // 0 means not in WAL, 1+ is frame number</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> WALIndexHashSize</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 256</span><span style=\"color:#6A737D\">  // Per hash table</span></span></code></pre></div>\n\n<h3 id=\"building-the-wal-index\">Building the WAL-Index</h3>\n<p>When a writer commits, it updates the WAL-index:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WAL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UpdateIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frameStart</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">frameEnd</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read frames and add to hash table</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> frameStart; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> frameEnd; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        frame </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> w.</span><span style=\"color:#B392F0\">ReadFrame</span><span style=\"color:#E1E4E8\">(i)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hash the page number</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        hash </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> frame.PageNumber </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> WALIndexHashSize</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Update or add entry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.index.hashTables[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].Entries[hash] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> WALIndexEntry</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            PageNumber: frame.PageNumber,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            FrameIndex: </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#E1E4E8\">(i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">),  </span><span style=\"color:#6A737D\">// 1-indexed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Sync the index to shared memory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> w.index.</span><span style=\"color:#B392F0\">Sync</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"page-lookup-with-wal\">Page Lookup with WAL</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FetchPageWithWAL</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageID</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">snapshot</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Snapshot</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Check WAL-index for this page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frameIdx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.walIndex.</span><span style=\"color:#B392F0\">Lookup</span><span style=\"color:#E1E4E8\">(pageID.PageNum, snapshot.maxFrame)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> frameIdx </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> frameIdx </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> snapshot.maxFrame {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Page is in WAL and within our snapshot</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        frame </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.wal.</span><span style=\"color:#B392F0\">ReadFrame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(frameIdx </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Copy to a buffer pool frame</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        frameData </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">allocateFrame</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        copy</span><span style=\"color:#E1E4E8\">(frameData, frame.PageData)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">{Data: frameData, PageID: pageID}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Fall back to database file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(pageID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WALIndex</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Lookup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageNum</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">maxFrame</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check each hash table</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, ht </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> idx.hashTables {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        hash </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> pageNum </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> WALIndexHashSize</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entry </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ht.Entries[hash]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> entry.PageNumber </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> pageNum </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> entry.FrameIndex </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> maxFrame {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> entry.FrameIndex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#6A737D\">  // Not found in WAL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"concurrent-readers-snapshot-isolation\">Concurrent Readers: Snapshot Isolation</h2>\n<p>Each reader sees a consistent snapshot of the database as of its start time:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Snapshot</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxFrame    </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">  // Highest WAL frame visible to this reader</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    startTime   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">BeginRead</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Snapshot</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Capture the current WAL position</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Snapshot</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        maxFrame:  db.wal.</span><span style=\"color:#B392F0\">LastCommittedFrame</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        startTime: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ExecuteQuery</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sql</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">snapshot</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Snapshot</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">Row</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // All page reads use this snapshot</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // The reader sees WAL frames 0..maxFrame, but not newer frames</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... execute query using snapshot-aware page fetches ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"snapshot-lifecycle\">Snapshot Lifecycle</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WAL</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    readers     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Snapshot</span><span style=\"color:#6A737D\">  // Active readers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nextReaderID </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    minSnapshot </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">  // Oldest snapshot still in use</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex       </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WAL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RegisterReader</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">snapshot</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Snapshot</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> w.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    id </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> w.nextReaderID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.nextReaderID</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.readers[id] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> snapshot</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update minimum snapshot</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">updateMinSnapshot</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> id</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WAL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UnregisterReader</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> w.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    delete</span><span style=\"color:#E1E4E8\">(w.readers, id)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">updateMinSnapshot</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WAL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">updateMinSnapshot</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.minSnapshot </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, snap </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> w.readers {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> w.minSnapshot </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> snap.maxFrame </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> w.minSnapshot {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            w.minSnapshot </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> snap.maxFrame</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WAL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">MinActiveSnapshot</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.mutex.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> w.mutex.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> w.minSnapshot</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The minimum snapshot determines how much of the WAL can be checkpointed. Frames newer than the minimum snapshot are still needed by at least one reader.</p>\n<hr>\n<h2 id=\"checkpoint-merging-wal-to-database\">Checkpoint: Merging WAL to Database</h2>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-wal-checkpoint-process.svg\" alt=\"Checkpoint: Merging WAL to Database\"></p>\n<p>Checkpointing copies WAL frames back into the database file:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CheckpointMode</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CheckpointPassive</span><span style=\"color:#B392F0\">  CheckpointMode</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span><span style=\"color:#6A737D\">  // Don't block writers</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CheckpointFull</span><span style=\"color:#6A737D\">                             // Block writers briefly</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CheckpointRestart</span><span style=\"color:#6A737D\">                          // Block writers, restart WAL</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CheckpointTruncate</span><span style=\"color:#6A737D\">                         // Block writers, truncate WAL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WAL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Checkpoint</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">mode</span><span style=\"color:#B392F0\"> CheckpointMode</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Determine checkpoint boundary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Can only checkpoint frames not needed by active readers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    minSnapshot </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> w.</span><span style=\"color:#B392F0\">MinActiveSnapshot</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> minSnapshot </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        minSnapshot </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> w.</span><span style=\"color:#B392F0\">LastCommittedFrame</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Read frames and write to database</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    framesCopied </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(minSnapshot); i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        frame </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> w.</span><span style=\"color:#B392F0\">ReadFrame</span><span style=\"color:#E1E4E8\">(i)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Write page to database file</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(frame.PageNumber) </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(w.pageSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> w.dbFile.</span><span style=\"color:#B392F0\">WriteAt</span><span style=\"color:#E1E4E8\">(frame.PageData, offset)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> framesCopied, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        framesCopied</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Sync database file</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.dbFile.</span><span style=\"color:#B392F0\">Sync</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Update WAL (remove checkpointed frames)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> mode </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> CheckpointTruncate {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Truncate WAL file</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.file.</span><span style=\"color:#B392F0\">Truncate</span><span style=\"color:#E1E4E8\">(WALHeaderSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.frameCount </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.checkpointSeq</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.</span><span style=\"color:#B392F0\">WriteHeader</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Move read pointer forward</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.checkpointedFrames </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> framesCopied</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> framesCopied, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"auto-checkpoint\">Auto-Checkpoint</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> DefaultAutoCheckpointPages</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1000</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WAL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AfterCommit</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if we should auto-checkpoint</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> w.frameCount </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> w.autoCheckpointThreshold {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        go</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Run checkpoint in background</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            w.</span><span style=\"color:#B392F0\">Checkpoint</span><span style=\"color:#E1E4E8\">(CheckpointPassive)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetAutoCheckpoint</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pages</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.wal.autoCheckpointThreshold </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"pragma-wal_checkpoint\">PRAGMA wal_checkpoint</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">PRAGMA wal_checkpoint;           </span><span style=\"color:#6A737D\">-- Passive checkpoint</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">PRAGMA wal_checkpoint(FULL);     </span><span style=\"color:#6A737D\">-- Full checkpoint (blocks writers)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">PRAGMA wal_checkpoint(</span><span style=\"color:#F97583\">RESTART</span><span style=\"color:#E1E4E8\">);  </span><span style=\"color:#6A737D\">-- Restart checkpoint</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">PRAGMA wal_checkpoint(</span><span style=\"color:#F97583\">TRUNCATE</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#6A737D\">-- Truncate checkpoint (empties WAL)</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handlePragmaWalCheckpoint</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">mode</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> cpMode </span><span style=\"color:#B392F0\">CheckpointMode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">ToUpper</span><span style=\"color:#E1E4E8\">(mode) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"PASSIVE\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cpMode </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CheckpointPassive</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"FULL\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cpMode </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CheckpointFull</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"RESTART\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cpMode </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CheckpointRestart</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"TRUNCATE\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cpMode </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CheckpointTruncate</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"error: invalid checkpoint mode\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    framesCopied, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.wal.</span><span style=\"color:#B392F0\">Checkpoint</span><span style=\"color:#E1E4E8\">(cpMode)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"error: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> frames copied\"</span><span style=\"color:#E1E4E8\">, framesCopied)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"switching-between-modes\">Switching Between Modes</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">PRAGMA journal_mode</span><span style=\"color:#F97583\">=DELETE</span><span style=\"color:#E1E4E8\">;  </span><span style=\"color:#6A737D\">-- Rollback journal (default)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">PRAGMA journal_mode</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">WAL;     </span><span style=\"color:#6A737D\">-- Write-ahead logging</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetJournalMode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">mode</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">ToUpper</span><span style=\"color:#E1E4E8\">(mode) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"DELETE\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">switchToRollbackJournal</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"WAL\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">switchToWAL</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unsupported journal mode: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, mode)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">switchToWAL</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Check if already in WAL mode</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> db.journalMode </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"WAL\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"wal\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Ensure no active transactions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> db.txManager.state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> TxActive {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"cannot switch journal mode during transaction\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Create WAL file</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    walPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.path </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"-wal\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    walFile, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Create</span><span style=\"color:#E1E4E8\">(walPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Initialize WAL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.wal </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">WAL</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        file:       walFile,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        path:       walPath,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pageSize:   db.pageSize,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dbFile:     db.file,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        autoCheckpointThreshold: DefaultAutoCheckpointPages,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        readers:    </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Snapshot</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.wal.header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> WALHeader</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Magic:         </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">377f0683</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Big-endian</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        FormatVersion: </span><span style=\"color:#79B8FF\">3007000</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        PageSize:      </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#E1E4E8\">(db.pageSize),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CheckpointSeq: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Salt1:         rand.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Salt2:         rand.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.wal.</span><span style=\"color:#B392F0\">WriteHeader</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Create WAL-index shared memory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    shmPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.path </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"-shm\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    shmFile, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Create</span><span style=\"color:#E1E4E8\">(shmPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        walFile.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">Remove</span><span style=\"color:#E1E4E8\">(walPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.wal.shmPath </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> shmPath</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.wal.shmFile </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> shmFile</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 6. Clean up rollback journal if it exists</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> db.rollbackJournal </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db.rollbackJournal.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">Remove</span><span style=\"color:#E1E4E8\">(db.path </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"-journal\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.journalMode </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"WAL\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> \"wal\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">switchToRollbackJournal</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Check if already in rollback journal mode</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> db.journalMode </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"DELETE\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"delete\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Checkpoint all WAL content to database</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.wal.</span><span style=\"color:#B392F0\">Checkpoint</span><span style=\"color:#E1E4E8\">(CheckpointTruncate)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Close and delete WAL files</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.wal.file.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.wal.shmFile.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    os.</span><span style=\"color:#B392F0\">Remove</span><span style=\"color:#E1E4E8\">(db.wal.shmPath)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    os.</span><span style=\"color:#B392F0\">Remove</span><span style=\"color:#E1E4E8\">(db.wal.path)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.wal </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.journalMode </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"DELETE\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> \"delete\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"wal-recovery\">WAL Recovery</h2>\n<p>On startup, the WAL must be replayed to restore any uncommitted changes:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">recoverFromWAL</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    walPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.path </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"-wal\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if WAL exists</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Stat</span><span style=\"color:#E1E4E8\">(walPath); os.</span><span style=\"color:#B392F0\">IsNotExist</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#6A737D\">  // No WAL, nothing to recover</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fmt.</span><span style=\"color:#B392F0\">Println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"WAL file detected, initiating recovery...\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Open and validate WAL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    wal, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> OpenWAL</span><span style=\"color:#E1E4E8\">(walPath, db.file, db.pageSize)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to open WAL: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> wal.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read and validate all frames</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> lastCommitFrame </span><span style=\"color:#F97583\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; ; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        frame, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> wal.</span><span style=\"color:#B392F0\">ReadFrame</span><span style=\"color:#E1E4E8\">(i)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> io.EOF {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to read WAL frame </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, i, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Verify checksum</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expectedCs1, expectedCs2 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> walChecksum</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            frame.PageData,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            wal.lastChecksum1,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            wal.lastChecksum2,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            wal.header.Magic,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> frame.Checksum1 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> expectedCs1 </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> frame.Checksum2 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> expectedCs2 {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Checksum mismatch - WAL is corrupted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Only replay up to the last valid commit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            fmt.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"WAL frame </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> has checksum mismatch, stopping recovery</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, i)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        wal.lastChecksum1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> frame.Checksum1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        wal.lastChecksum2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> frame.Checksum2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Track commit frames</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> frame.CommitSize </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            lastCommitFrame </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        fmt.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Validated frame </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: page </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, i, frame.PageNumber)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Replay up to the last commit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> lastCommitFrame </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        fmt.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Replaying </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> frames to database...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, lastCommitFrame</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> lastCommitFrame; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            frame, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> wal.</span><span style=\"color:#B392F0\">ReadFrame</span><span style=\"color:#E1E4E8\">(i)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(frame.PageNumber) </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(db.pageSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.file.</span><span style=\"color:#B392F0\">WriteAt</span><span style=\"color:#E1E4E8\">(frame.PageData, offset)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to write page </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, frame.PageNumber, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db.file.</span><span style=\"color:#B392F0\">Sync</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        fmt.</span><span style=\"color:#B392F0\">Println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"WAL recovery complete.\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        fmt.</span><span style=\"color:#B392F0\">Println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"No committed frames in WAL, nothing to replay.\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"concurrent-execution-flow\">Concurrent Execution Flow</h2>\n<p>{{DIAGRAM:diag-wal-architecture}}</p>\n<h3 id=\"writer-flow\">Writer Flow</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">executeWriteWithWAL</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#B392F0\"> Statement</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Begin transaction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.txManager.</span><span style=\"color:#B392F0\">Begin</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Execute statement (modifies pages in buffer pool)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">executeStatement</span><span style=\"color:#E1E4E8\">(stmt)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db.txManager.</span><span style=\"color:#B392F0\">Rollback</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. On commit, write dirty pages to WAL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dirtyPages </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.bufferPool.</span><span style=\"color:#B392F0\">GetDirtyPages</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, page </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> dirtyPages {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db.wal.</span><span style=\"color:#B392F0\">WriteFrame</span><span style=\"color:#E1E4E8\">(page.PageID.PageNum, page.Data, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Write commit frame</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dbSize </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">getPageCount</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    commitFrame </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, db.pageSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.wal.</span><span style=\"color:#B392F0\">WriteFrame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, commitFrame, </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, dbSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Sync WAL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.wal.file.</span><span style=\"color:#B392F0\">Sync</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 6. Update WAL-index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.wal.</span><span style=\"color:#B392F0\">UpdateIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, db.wal.frameCount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 7. Mark transaction committed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.txManager.</span><span style=\"color:#B392F0\">Commit</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 8. Check for auto-checkpoint</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.wal.</span><span style=\"color:#B392F0\">AfterCommit</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"reader-flow\">Reader Flow</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">executeReadWithWAL</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sql</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">Row</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Register as reader, get snapshot</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    snapshot </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.wal.</span><span style=\"color:#B392F0\">BeginSnapshot</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    readerID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.wal.</span><span style=\"color:#B392F0\">RegisterReader</span><span style=\"color:#E1E4E8\">(snapshot)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> db.wal.</span><span style=\"color:#B392F0\">UnregisterReader</span><span style=\"color:#E1E4E8\">(readerID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Execute query with snapshot-aware page fetches</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rows, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">executeQuery</span><span style=\"color:#E1E4E8\">(sql, snapshot)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> rows, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">fetchPageSnapshot</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageNum</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">snapshot</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Snapshot</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check WAL-index first</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frameIdx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.wal.index.</span><span style=\"color:#B392F0\">Lookup</span><span style=\"color:#E1E4E8\">(pageNum, snapshot.maxFrame)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> frameIdx </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Read from WAL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        frame </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.wal.</span><span style=\"color:#B392F0\">ReadFrame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(frameIdx </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> frame.PageData, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Fall back to database file</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(pageNum) </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(db.pageSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, db.pageSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.file.</span><span style=\"color:#B392F0\">ReadAt</span><span style=\"color:#E1E4E8\">(data, offset)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> data, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"common-pitfalls\">Common Pitfalls</h2>\n<h3 id=\"1-wal-grows-unbounded-without-checkpointing\">1. WAL Grows Unbounded Without Checkpointing</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Never checkpoint</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.wal.</span><span style=\"color:#B392F0\">WriteFrame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // No checkpoint!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RIGHT: Auto-checkpoint after threshold</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.wal.</span><span style=\"color:#B392F0\">WriteFrame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> db.wal.frameCount </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> db.autoCheckpointThreshold {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db.wal.</span><span style=\"color:#B392F0\">Checkpoint</span><span style=\"color:#E1E4E8\">(CheckpointPassive)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"2-long-running-readers-block-checkpointing\">2. Long-Running Readers Block Checkpointing</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Scenario: Reader holds old snapshot</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">reader1 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">BeginRead</span><span style=\"color:#E1E4E8\">()  </span><span style=\"color:#6A737D\">// snapshot at frame 100</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Writer commits 10000 frames</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Checkpoint can only copy frames 0-99</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Frames 100-10099 are pinned by reader1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.wal.</span><span style=\"color:#B392F0\">Checkpoint</span><span style=\"color:#E1E4E8\">(CheckpointPassive)  </span><span style=\"color:#6A737D\">// Only copies 100 frames</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WAL file is now huge</span></span></code></pre></div>\n\n<p><strong>Solution</strong>: Monitor long-running readers, kill queries that hold snapshots too long, or increase checkpoint threshold.</p>\n<h3 id=\"3-corrupted-wal-not-detected\">3. Corrupted WAL Not Detected</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Trust WAL data without checksum</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">frame </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> wal.</span><span style=\"color:#B392F0\">ReadFrame</span><span style=\"color:#E1E4E8\">(i)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.file.</span><span style=\"color:#B392F0\">WriteAt</span><span style=\"color:#E1E4E8\">(frame.PageData, offset)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RIGHT: Verify checksum before using</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">expectedCs1, expectedCs2 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> walChecksum</span><span style=\"color:#E1E4E8\">(frame.PageData, </span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> frame.Checksum1 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> expectedCs1 {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"WAL corruption detected\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"4-switching-modes-during-active-transaction\">4. Switching Modes During Active Transaction</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Switch mode mid-transaction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"BEGIN\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT ...\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PRAGMA journal_mode=WAL\"</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\">// Undefined behavior!</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RIGHT: Only switch when idle</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"COMMIT\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PRAGMA journal_mode=WAL\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h3 id=\"5-forgetting-to-sync-wal\">5. Forgetting to Sync WAL</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Commit without sync</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.wal.</span><span style=\"color:#B392F0\">WriteFrame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">, isCommit</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// No sync! WAL might not be on disk</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RIGHT: Sync after commit frame</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.wal.</span><span style=\"color:#B392F0\">WriteFrame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">, isCommit</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.wal.file.</span><span style=\"color:#B392F0\">Sync</span><span style=\"color:#E1E4E8\">()  </span><span style=\"color:#6A737D\">// Ensure durability</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"test-suite-what-to-verify\">Test Suite: What to Verify</h2>\n<p><strong>WAL mode activation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">PRAGMA journal_mode</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">WAL;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: \"wal\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Files should exist</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- test.db-wal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- test.db-shm</span></span></code></pre></div>\n\n<p><strong>Concurrent reads during writes:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> OpenDatabase</span><span style=\"color:#E1E4E8\">(path)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PRAGMA journal_mode=WAL\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Start a long write transaction</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">go</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"BEGIN\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (?, ?)\"</span><span style=\"color:#E1E4E8\">, i, fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"user</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, i))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"COMMIT\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Readers should not block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">time.</span><span style=\"color:#B392F0\">Sleep</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Millisecond)  </span><span style=\"color:#6A737D\">// Let writer start</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">rows, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Query</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT COUNT(*) FROM users\"</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\">// Should return immediately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Reader sees snapshot from before the write transaction</span></span></code></pre></div>\n\n<p><strong>WAL file growth and checkpoint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PRAGMA journal_mode=WAL\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PRAGMA wal_autocheckpoint=100\"</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\">// Checkpoint every 100 pages</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (?, ?)\"</span><span style=\"color:#E1E4E8\">, i, </span><span style=\"color:#9ECBFF\">\"test\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WAL should not exceed ~100 pages worth of data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">walSize, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Stat</span><span style=\"color:#E1E4E8\">(db.path </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"-wal\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Less</span><span style=\"color:#E1E4E8\">(t, walSize.</span><span style=\"color:#B392F0\">Size</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">24</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\">// Header + 100 frames max</span></span></code></pre></div>\n\n<p><strong>Checkpoint PRAGMA:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">PRAGMA wal_checkpoint;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: Shows frames copied</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">PRAGMA wal_checkpoint(</span><span style=\"color:#F97583\">TRUNCATE</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: WAL file is truncated to header only</span></span></code></pre></div>\n\n<p><strong>Snapshot isolation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (1, 'Alice')\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Start reader</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">rows1, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Query</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM users\"</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\">// Sees Alice</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (2, 'Bob')\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// New reader sees both</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">rows2, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Query</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM users\"</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\">// Sees Alice and Bob</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Old reader still sees only Alice</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(rows1))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(rows2))</span></span></code></pre></div>\n\n<p><strong>WAL recovery:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PRAGMA journal_mode=WAL\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (1, 'Alice')\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Don't commit - simulate crash</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db2 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> OpenDatabase</span><span style=\"color:#E1E4E8\">(path)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Should recover from WAL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">rows, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db2.</span><span style=\"color:#B392F0\">Query</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM users\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(rows))  </span><span style=\"color:#6A737D\">// Transaction was recovered</span></span></code></pre></div>\n\n<p><strong>Checksum detection:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PRAGMA journal_mode=WAL\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (1, 'Alice')\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Corrupt the WAL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">walFile, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">OpenFile</span><span style=\"color:#E1E4E8\">(db.path </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"-wal\"</span><span style=\"color:#E1E4E8\">, os.O_RDWR, </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">walFile.</span><span style=\"color:#B392F0\">WriteAt</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">FF</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">FF</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">FF</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">FF</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\">// Corrupt a checksum</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">walFile.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db2 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> OpenDatabase</span><span style=\"color:#E1E4E8\">(path)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Should detect corruption and recover only valid frames</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<p>You&#39;ve just implemented <strong>Write-Ahead Logging</strong>—the pattern that enables high-concurrency database systems. Here&#39;s where this connects:</p>\n<p><strong>Immediate connections:</strong></p>\n<ul>\n<li><strong>Previous milestone (Rollback Journal)</strong>: WAL is the alternative to rollback journaling. Both provide durability, but WAL enables concurrent readers. The choice depends on workload: write-heavy with occasional reads → rollback journal; mixed read/write → WAL.</li>\n<li><strong>All storage operations</strong>: Every B-tree modification now goes through the WAL. The buffer pool, B-tree layer, and VM all participate in the WAL protocol.</li>\n</ul>\n<p><strong>Same domain:</strong></p>\n<ul>\n<li><strong>PostgreSQL WAL</strong>: PostgreSQL&#39;s WAL (called &quot;xlog&quot;) is more sophisticated—it logs logical changes (tuple inserts/updates) rather than page images. This enables point-in-time recovery and logical replication. Your WAL logs physical pages; theirs logs logical operations.</li>\n<li><strong>MySQL InnoDB Redo Log</strong>: InnoDB uses a circular WAL with fixed size. Old log records are overwritten after checkpointing. This bounds disk usage but requires careful management. Your WAL grows unbounded until checkpoint.</li>\n<li><strong>Database logical replication</strong>: WAL records can be parsed and shipped to replicas. PostgreSQL&#39;s logical decoding extracts change events from WAL. Your WAL format is simpler but could be extended to support replication.</li>\n</ul>\n<p><strong>Cross-domain:</strong></p>\n<ul>\n<li><strong>Event sourcing</strong>: The append-only event log in event-sourced architectures is a WAL pattern applied at the application level. Events are facts that happened; the current state is derived by replaying events. Same principle: never overwrite, always append.</li>\n<li><strong>Kafka log compaction</strong>: Kafka&#39;s retention policies mirror WAL checkpointing. A compacted topic keeps only the latest value for each key—like checkpointing old page versions out of the WAL. The &quot;log&quot; abstraction unifies databases and message systems.</li>\n<li><strong>Copy-on-write file systems (ZFS, Btrfs)</strong>: ZFS never overwrites blocks in place. New data is written to free space, then metadata is updated atomically. This is like a WAL at the file system level—every write creates a new version.</li>\n<li><strong>Time-travel queries</strong>: Snowflake and BigQuery expose historical data for point-in-time queries. This is snapshot isolation at scale—readers query a snapshot, and the system keeps old versions until they&#39;re no longer needed. Your WAL provides the same capability, just not exposed to users.</li>\n<li><strong>Git reflog</strong>: Git&#39;s reflog is a WAL for branch references. Every update is logged, and you can recover from mistakes by replaying or resetting to an earlier point. The same durability principle applies to version control.</li>\n</ul>\n<p><strong>Forward:</strong></p>\n<ul>\n<li><strong>With this knowledge, you could now build</strong>: A database replication system that ships WAL frames to replicas; a point-in-time recovery system that archives WAL files for later replay; or a change data capture (CDC) system that extracts logical changes from the WAL for downstream consumers.</li>\n</ul>\n<p>WAL is where database engineering meets distributed systems thinking. The append-only log, the snapshot, the checkpoint—these patterns appear everywhere data must be both durable and concurrent. You&#39;ve implemented the core technique that powers every major database system.</p>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-sqlite-m11 -->\n<h1 id=\"milestone-11-aggregate-functions-amp-join\">Milestone 11: Aggregate Functions &amp; JOIN</h1>\n<h2 id=\"where-we-are-in-the-system\">Where We Are in the System</h2>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-satellite-overview.svg\" alt=\"SQLite Architecture: The Complete System Map\"></p>\n<p>Your database can execute single-table queries with WHERE clauses, projections, and indexes. But real analytical work requires more. Consider these queries:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> COUNT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> orders </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#F97583\"> status</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'completed'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#E1E4E8\"> customer_id, </span><span style=\"color:#79B8FF\">SUM</span><span style=\"color:#E1E4E8\">(amount) </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> orders </span><span style=\"color:#F97583\">GROUP BY</span><span style=\"color:#E1E4E8\"> customer_id</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">total</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> customers c </span><span style=\"color:#F97583\">JOIN</span><span style=\"color:#E1E4E8\"> orders o </span><span style=\"color:#F97583\">ON</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">customer_id</span></span></code></pre></div>\n\n<p>Each requires capabilities you don&#39;t yet have: accumulating values across rows, partitioning rows into groups, and combining data from multiple tables. These are <strong>aggregates</strong>, <strong>GROUP BY</strong>, and <strong>JOINs</strong>—the features that transform a key-value store into a relational query engine.</p>\n<p>This milestone adds the final execution capabilities your database needs for real-world queries.</p>\n<hr>\n<h2 id=\"the-revelation-aggregates-have-subtle-null-behavior\">The Revelation: Aggregates Have Subtle NULL Behavior</h2>\n<p>Here&#39;s what most developers assume: &quot;Aggregate functions are simple. SUM adds values, COUNT counts them, AVG computes the average. GROUP BY just groups rows by a column. JOINs combine matching rows.&quot;</p>\n<p>All three assumptions hide critical complexity that causes wrong results.</p>\n<h3 id=\"count-vs-countcolumn-nulls-are-counted-differently\">COUNT(*) vs COUNT(column): NULLs Are Counted Differently</h3>\n<p>Consider a table with a nullable column:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> users</span><span style=\"color:#E1E4E8\"> (id </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">name</span><span style=\"color:#F97583\"> TEXT</span><span style=\"color:#E1E4E8\">, middle_name </span><span style=\"color:#F97583\">TEXT</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Alice'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Marie'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Bob'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> users </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Charlie'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Lee'</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<p>What does <code>COUNT(middle_name)</code> return?</p>\n<table>\n<thead>\n<tr>\n<th>Query</th>\n<th>Result</th>\n<th>Why</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>COUNT(*)</code></td>\n<td>3</td>\n<td>Counts all rows, regardless of NULLs</td>\n</tr>\n<tr>\n<td><code>COUNT(middle_name)</code></td>\n<td>2</td>\n<td>Counts only non-NULL values</td>\n</tr>\n<tr>\n<td><code>COUNT(id)</code></td>\n<td>3</td>\n<td>id has no NULLs</td>\n</tr>\n</tbody></table>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-aggregate-null-handling.svg\" alt=\"Aggregate NULL Handling: COUNT(*) vs COUNT(col)\"></p>\n<p>This isn&#39;t arbitrary—<code>COUNT(*)</code> answers &quot;how many rows?&quot; while <code>COUNT(col)</code> answers &quot;how many rows have a value for this column?&quot; The distinction matters for data quality analysis.</p>\n<h3 id=\"avg-must-return-a-float-even-for-integer-columns\">AVG Must Return a Float, Even for Integer Columns</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> scores</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">value</span><span style=\"color:#F97583\"> INTEGER</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> scores </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">), (</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">), (</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> AVG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> scores;</span></span></code></pre></div>\n\n<p>If you compute <code>AVG</code> as integer division: (1+2+3+4)/4 = 10/4 = 2 (truncated)</p>\n<p>The correct answer is 2.5. <strong>AVG always returns REAL/float</strong>, even when the input column is INTEGER. This requires type promotion during aggregation.</p>\n<h3 id=\"sum-and-avg-ignore-nulls\">SUM and AVG Ignore NULLs</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> scores </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> SUM</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> scores;  </span><span style=\"color:#6A737D\">-- 10, not NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> AVG</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> scores;  </span><span style=\"color:#6A737D\">-- 2.5, not 2.0</span></span></code></pre></div>\n\n<p><code>SUM</code> and <code>AVG</code> treat NULL as &quot;no value&quot; and skip it entirely. The sum is computed over 4 values, not 5. The average divides by 4, not 5.</p>\n<p>This is different from arithmetic: <code>NULL + 5 = NULL</code>. Aggregates are special—they filter out NULLs before accumulating.</p>\n<h3 id=\"group-by-without-order-by-has-no-guaranteed-order\">GROUP BY Without ORDER BY Has No Guaranteed Order</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> status</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">COUNT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> orders </span><span style=\"color:#F97583\">GROUP BY</span><span style=\"color:#F97583\"> status</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p>The result might return groups in any order: (&#39;pending&#39;, 5), (&#39;completed&#39;, 100), (&#39;cancelled&#39;, 3)—or any permutation. GROUP BY partitions rows; it does not sort them. If you need sorted output, add <code>ORDER BY</code>.</p>\n<h3 id=\"nested-loop-joins-are-onm\">Nested Loop Joins Are O(n*m)</h3>\n<p>The simplest JOIN algorithm is a nested loop:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> orders o </span><span style=\"color:#F97583\">JOIN</span><span style=\"color:#E1E4E8\"> customers c </span><span style=\"color:#F97583\">ON</span><span style=\"color:#79B8FF\"> o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">customer_id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> each order o:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> each customer c:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> o.customer_id </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> c.id:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            emit (o, c)</span></span></code></pre></div>\n\n<p>If <code>orders</code> has 10,000 rows and <code>customers</code> has 1,000 rows, this performs <strong>10 million comparisons</strong>. For a 1M-row orders table and 100K customers, it&#39;s 100 billion comparisons.</p>\n<p>This is why query planners matter. A hash join or merge join can reduce this to O(n+m), but your baseline implementation uses nested loops. Understanding this cost reveals why indexes on join columns are critical.</p>\n<hr>\n<h2 id=\"the-tension-correctness-vs-memory-vs-performance\">The Tension: Correctness vs Memory vs Performance</h2>\n<p>Aggregates and JOINs introduce new resource constraints:</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Memory Concern</th>\n<th>Performance Concern</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GROUP BY</td>\n<td>Must hold aggregate state per group</td>\n<td>Hashing vs sorting for partitioning</td>\n</tr>\n<tr>\n<td>Aggregates</td>\n<td>Minimal (single accumulator)</td>\n<td>NULL handling overhead</td>\n</tr>\n<tr>\n<td>Nested loop JOIN</td>\n<td>Minimal (no state needed)</td>\n<td>O(n*m) comparisons</td>\n</tr>\n<tr>\n<td>Hash JOIN</td>\n<td>O(smaller table) for hash table</td>\n<td>O(n+m) but memory-bound</td>\n</tr>\n<tr>\n<td>Sort-merge JOIN</td>\n<td>O(both tables) if external sort</td>\n<td>O(n log n + m log m)</td>\n</tr>\n</tbody></table>\n<p><strong>The constraint</strong>: GROUP BY requires holding aggregate state for every distinct group. A GROUP BY on a column with 1 million distinct values needs 1 million accumulator slots. This can exhaust memory.</p>\n<p>For this milestone, we use in-memory hash aggregation. Production databases spill to disk (external hashing) when memory is exceeded, but that&#39;s an advanced optimization.</p>\n<hr>\n<h2 id=\"three-level-view-from-sql-to-aggregate-state-to-results\">Three-Level View: From SQL to Aggregate State to Results</h2>\n<table>\n<thead>\n<tr>\n<th>Level</th>\n<th>What Happens</th>\n<th>State Required</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>SQL</strong></td>\n<td>GROUP BY clause defines partitioning keys</td>\n<td>Parser extracts column references</td>\n</tr>\n<tr>\n<td><strong>Execution</strong></td>\n<td>Hash table maps group keys → aggregate state</td>\n<td>O(distinct groups) memory</td>\n</tr>\n<tr>\n<td><strong>Output</strong></td>\n<td>Each group produces one result row</td>\n<td>HAVING filters groups</td>\n</tr>\n</tbody></table>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-group-by-execution.svg\" alt=\"GROUP BY: Partitioning and Aggregation\"></p>\n<hr>\n<h2 id=\"building-aggregate-functions\">Building Aggregate Functions</h2>\n<h3 id=\"aggregate-state-structure\">Aggregate State Structure</h3>\n<p>Each aggregate function maintains state across rows:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AggregateState</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Finalize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CountStarState</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    count </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CountStarState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.count</span><span style=\"color:#F97583\">++</span><span style=\"color:#6A737D\">  // Count every row, regardless of value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CountStarState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Finalize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: INTEGER, Int: s.count}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CountColumnState</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    count </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CountColumnState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value.Type </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> NULL {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        s.count</span><span style=\"color:#F97583\">++</span><span style=\"color:#6A737D\">  // Only count non-NULL values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CountColumnState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Finalize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: INTEGER, Int: s.count}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SumState</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sum   </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    valid </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SumState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> NULL {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#6A737D\">  // Skip NULLs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.valid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.sum </span><span style=\"color:#F97583\">+=</span><span style=\"color:#B392F0\"> toFloat</span><span style=\"color:#E1E4E8\">(value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SumState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Finalize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">s.valid {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: NULL}  </span><span style=\"color:#6A737D\">// SUM of no values is NULL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: REAL, Float: s.sum}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AvgState</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sum   </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    count </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AvgState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> NULL {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.sum </span><span style=\"color:#F97583\">+=</span><span style=\"color:#B392F0\"> toFloat</span><span style=\"color:#E1E4E8\">(value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.count</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AvgState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Finalize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> s.count </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: NULL}  </span><span style=\"color:#6A737D\">// AVG of no values is NULL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: REAL, Float: s.sum </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(s.count)}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MinState</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    min   </span><span style=\"color:#B392F0\">Value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    valid </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MinState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> NULL {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">s.valid </span><span style=\"color:#F97583\">||</span><span style=\"color:#B392F0\"> compareValues</span><span style=\"color:#E1E4E8\">(value, s.min) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        s.min </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        s.valid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MinState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Finalize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">s.valid {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: NULL}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> s.min</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MaxState</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max   </span><span style=\"color:#B392F0\">Value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    valid </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MaxState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> NULL {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">s.valid </span><span style=\"color:#F97583\">||</span><span style=\"color:#B392F0\"> compareValues</span><span style=\"color:#E1E4E8\">(value, s.max) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        s.max </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        s.valid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MaxState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Finalize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">s.valid {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: NULL}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> s.max</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"aggregate-function-factory\">Aggregate Function Factory</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AggregateType</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AggregateCountStar</span><span style=\"color:#B392F0\"> AggregateType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AggregateCountColumn</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AggregateSum</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AggregateAvg</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AggregateMin</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AggregateMax</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewAggregateState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">aggType</span><span style=\"color:#B392F0\"> AggregateType</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AggregateState</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> aggType {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> AggregateCountStar:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">CountStarState</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> AggregateCountColumn:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">CountColumnState</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> AggregateSum:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">SumState</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> AggregateAvg:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">AvgState</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> AggregateMin:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">MinState</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> AggregateMax:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">MaxState</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        panic</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unknown aggregate type: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, aggType))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> toFloat</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">v</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> v.Type {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> INTEGER:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(v.Int)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> REAL:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> v.Float</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> NULL:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        panic</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"cannot convert </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\"> to float\"</span><span style=\"color:#E1E4E8\">, v.Type))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"group-by-execution\">GROUP BY Execution</h2>\n<h3 id=\"hash-based-aggregation\">Hash-Based Aggregation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> GroupByExecutor</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    groupColumns []</span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">           // Column indices for GROUP BY</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    aggregates   []</span><span style=\"color:#B392F0\">AggregateSpec</span><span style=\"color:#6A737D\"> // Aggregate functions to compute</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    groups       </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#B392F0\">AggregateState</span><span style=\"color:#6A737D\">  // group key → aggregate states</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AggregateSpec</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type      </span><span style=\"color:#B392F0\">AggregateType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Column    </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">  // Column index for column-based aggregates (-1 for COUNT(*))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GroupByExecutor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ProcessRow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">row</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Extract group key</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    key </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> e.</span><span style=\"color:#B392F0\">makeGroupKey</span><span style=\"color:#E1E4E8\">(row)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Get or create aggregate states for this group</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    states, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> e.groups[key]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        states </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">AggregateState</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(e.aggregates))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i, agg </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> e.aggregates {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            states[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> NewAggregateState</span><span style=\"color:#E1E4E8\">(agg.Type)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        e.groups[key] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> states</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Update each aggregate with the appropriate value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, agg </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> e.aggregates {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        var</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#B392F0\">Value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> agg.Column </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> row[agg.Column]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            value </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: INTEGER, Int: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}  </span><span style=\"color:#6A737D\">// Dummy value for COUNT(*)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        states[i].</span><span style=\"color:#B392F0\">Update</span><span style=\"color:#E1E4E8\">(value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GroupByExecutor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">makeGroupKey</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">row</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> buf </span><span style=\"color:#B392F0\">bytes</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Buffer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, colIdx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> e.groupColumns {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            buf.</span><span style=\"color:#B392F0\">WriteByte</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\">// Separator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">formatValueForKey</span><span style=\"color:#E1E4E8\">(row[colIdx]))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> buf.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> formatValueForKey</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">v</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> v.Type {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> NULL:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\x00</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> INTEGER:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"I</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, v.Int)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> REAL:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"R</span><span style=\"color:#79B8FF\">%f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, v.Float)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> TEXT:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"T</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, v.Str)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> BLOB:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"B</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, v.Bytes)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GroupByExecutor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Finalize</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#B392F0\">GroupResult</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    results </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">GroupResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(e.groups))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> key, states </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> e.groups {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Reconstruct group key values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        keyValues </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> e.</span><span style=\"color:#B392F0\">parseGroupKey</span><span style=\"color:#E1E4E8\">(key)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Finalize aggregates</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        aggValues </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(states))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i, state </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> states {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            aggValues[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> state.</span><span style=\"color:#B392F0\">Finalize</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        results </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(results, </span><span style=\"color:#B392F0\">GroupResult</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Key:    keyValues,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Values: aggValues,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> GroupResult</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Key    []</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#6A737D\">  // GROUP BY column values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Values []</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#6A737D\">  // Aggregate results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"ungrouped-aggregation\">Ungrouped Aggregation</h3>\n<p>Queries without GROUP BY produce a single result row:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> COUNT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#79B8FF\">AVG</span><span style=\"color:#E1E4E8\">(price) </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> products;</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GroupByExecutor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ProcessRowUngrouped</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">row</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Ungrouped queries have a single \"group\" with empty key</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    key </span><span style=\"color:#F97583\">:=</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    states, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> e.groups[key]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        states </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">AggregateState</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(e.aggregates))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i, agg </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> e.aggregates {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            states[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> NewAggregateState</span><span style=\"color:#E1E4E8\">(agg.Type)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        e.groups[key] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> states</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, agg </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> e.aggregates {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        var</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#B392F0\">Value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> agg.Column </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> row[agg.Column]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            value </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: INTEGER, Int: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        states[i].</span><span style=\"color:#B392F0\">Update</span><span style=\"color:#E1E4E8\">(value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"empty-table-handling\">Empty Table Handling</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> COUNT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#79B8FF\">AVG</span><span style=\"color:#E1E4E8\">(price) </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> products </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">;  </span><span style=\"color:#6A737D\">-- Empty result set</span></span></code></pre></div>\n\n<p>Result: <code>(0, NULL)</code></p>\n<ul>\n<li><code>COUNT(*)</code> returns 0 (no rows)</li>\n<li><code>AVG(price)</code> returns NULL (no values to average)</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GroupByExecutor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Finalize</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#B392F0\">GroupResult</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(e.groups) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(e.aggregates) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Empty table with aggregates: return single row with initial states</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        states </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">AggregateState</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(e.aggregates))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i, agg </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> e.aggregates {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            states[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> NewAggregateState</span><span style=\"color:#E1E4E8\">(agg.Type)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        aggValues </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(states))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i, state </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> states {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            aggValues[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> state.</span><span style=\"color:#B392F0\">Finalize</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">GroupResult</span><span style=\"color:#E1E4E8\">{{Key: </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, Values: aggValues}}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... normal finalization ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"having-filtering-groups\">HAVING: Filtering Groups</h2>\n<p>HAVING filters groups <em>after</em> aggregation, unlike WHERE which filters rows <em>before</em> aggregation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#E1E4E8\"> customer_id, </span><span style=\"color:#79B8FF\">SUM</span><span style=\"color:#E1E4E8\">(amount) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> total</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> orders</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">GROUP BY</span><span style=\"color:#E1E4E8\"> customer_id</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">HAVING</span><span style=\"color:#79B8FF\"> SUM</span><span style=\"color:#E1E4E8\">(amount) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GroupByExecutor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FinalizeWithHaving</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">havingPredicate</span><span style=\"color:#B392F0\"> Expression</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#B392F0\">GroupResult</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    allResults </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> e.</span><span style=\"color:#B392F0\">Finalize</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filtered </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">GroupResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, result </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> allResults {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Evaluate HAVING predicate with aggregate values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rowMap </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Add group key columns</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i, col </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> e.groupColumns {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            colName </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> e.schema.Columns[col].Name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            rowMap[colName] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> result.Key[i]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Add aggregate results</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i, agg </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> e.aggregates {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            aggName </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> e.aggregateNames[i]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            rowMap[aggName] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> result.Values[i]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Evaluate predicate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cond </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> EvaluateExpression</span><span style=\"color:#E1E4E8\">(havingPredicate, rowMap)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> cond.</span><span style=\"color:#B392F0\">IsTruthy</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            filtered </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(filtered, result)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> filtered</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"having-vs-where\">HAVING vs WHERE</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">-- WHERE filters rows before grouping</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> status</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">COUNT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> orders</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> amount </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 100</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">GROUP BY</span><span style=\"color:#F97583\"> status</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- HAVING filters groups after aggregation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> status</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">COUNT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> orders</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">GROUP BY</span><span style=\"color:#F97583\"> status</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">HAVING</span><span style=\"color:#79B8FF\"> COUNT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p>The execution order:</p>\n<ol>\n<li>FROM: Load orders table</li>\n<li>WHERE: Filter rows with amount &gt; 100</li>\n<li>GROUP BY: Partition remaining rows by status</li>\n<li>Aggregation: Compute COUNT(*) per group</li>\n<li>HAVING: Filter groups with count &gt; 10</li>\n<li>SELECT: Output results</li>\n</ol>\n<hr>\n<h2 id=\"inner-join-nested-loop-implementation\">INNER JOIN: Nested Loop Implementation</h2>\n<h3 id=\"the-cross-product-with-filter\">The Cross Product with Filter</h3>\n<p>{{DIAGRAM:diag-nested-loop-join}}</p>\n<p>A JOIN is a cross product followed by a filter:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> orders o </span><span style=\"color:#F97583\">JOIN</span><span style=\"color:#E1E4E8\"> customers c </span><span style=\"color:#F97583\">ON</span><span style=\"color:#79B8FF\"> o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">customer_id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p>Conceptually:</p>\n<ol>\n<li>For each row in <code>orders</code></li>\n<li>For each row in <code>customers</code></li>\n<li>If <code>orders.customer_id == customers.id</code>, emit the combined row</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NestedLoopJoinExecutor</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leftTable    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rightTable   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leftColumns  []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rightColumns []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    joinCondition </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db           </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NestedLoopJoinExecutor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">callback</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">joinedRow</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Open cursors on both tables</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leftCursor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> e.db.</span><span style=\"color:#B392F0\">TableScan</span><span style=\"color:#E1E4E8\">(e.leftTable)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rightCursor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> e.db.</span><span style=\"color:#B392F0\">TableScan</span><span style=\"color:#E1E4E8\">(e.rightTable)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get schemas for column mapping</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leftSchema </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> e.db.</span><span style=\"color:#B392F0\">GetSchema</span><span style=\"color:#E1E4E8\">(e.leftTable)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rightSchema </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> e.db.</span><span style=\"color:#B392F0\">GetSchema</span><span style=\"color:#E1E4E8\">(e.rightTable)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Outer loop: iterate left table</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> leftCursor.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        leftRow </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> leftCursor.</span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Inner loop: iterate right table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rightCursor.</span><span style=\"color:#B392F0\">Rewind</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> rightCursor.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            rightRow </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> rightCursor.</span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Build combined row for condition evaluation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            combinedRow </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> i, col </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> leftSchema.Columns {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                combinedRow[e.leftTable</span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\">\".\"</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">col.Name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> leftRow[i]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                combinedRow[col.Name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> leftRow[i]  </span><span style=\"color:#6A737D\">// Also available without table prefix</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> i, col </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> rightSchema.Columns {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                combinedRow[e.rightTable</span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\">\".\"</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">col.Name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> rightRow[i]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Only add without prefix if not ambiguous</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">leftSchema.</span><span style=\"color:#B392F0\">HasColumn</span><span style=\"color:#E1E4E8\">(col.Name) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    combinedRow[col.Name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> rightRow[i]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Evaluate join condition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cond </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> EvaluateExpression</span><span style=\"color:#E1E4E8\">(e.joinCondition, combinedRow)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> cond.</span><span style=\"color:#B392F0\">IsTruthy</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Emit joined row</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                joinedRow </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(leftRow, rightRow</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                callback</span><span style=\"color:#E1E4E8\">(joinedRow)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-join-execution-trace.svg\" alt=\"JOIN Execution: Row-by-Row Trace\"></p>\n<h3 id=\"table-alias-support\">Table Alias Support</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">name</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> orders o</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">JOIN</span><span style=\"color:#E1E4E8\"> customers c </span><span style=\"color:#F97583\">ON</span><span style=\"color:#79B8FF\"> o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">customer_id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> JoinTableRef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TableName </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Alias     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Columns   []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NestedLoopJoinExecutor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ExecuteWithAliases</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    left</span><span style=\"color:#B392F0\"> JoinTableRef</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    right</span><span style=\"color:#B392F0\"> JoinTableRef</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    callback</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">joinedRow</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... similar to above, but use aliases in combinedRow map ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    combinedRow[left.Alias</span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\">\".\"</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">col.Name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"join-with-where-clause\">JOIN with WHERE Clause</h2>\n<p>WHERE clauses can filter before, during, or after the join depending on what they reference:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">total</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> customers c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">JOIN</span><span style=\"color:#E1E4E8\"> orders o </span><span style=\"color:#F97583\">ON</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">customer_id</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">WHERE</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">country</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'US'</span><span style=\"color:#F97583\"> AND</span><span style=\"color:#79B8FF\"> o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">status</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'completed'</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p>Optimal execution:</p>\n<ol>\n<li>Filter <code>customers</code> on <code>country = &#39;US&#39;</code> (reduces left side)</li>\n<li>Filter <code>orders</code> on <code>status = &#39;completed&#39;</code> (reduces right side)</li>\n<li>Join the filtered results</li>\n</ol>\n<p>Simple execution (what we implement):</p>\n<ol>\n<li>Join all customers with all orders</li>\n<li>Filter the joined results</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NestedLoopJoinExecutor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ExecuteWithWhere</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    whereClause</span><span style=\"color:#B392F0\"> Expression</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    callback</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">joinedRow</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> e.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">joinedRow</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Build row map for WHERE evaluation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rowMap </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> e.</span><span style=\"color:#B392F0\">buildRowMap</span><span style=\"color:#E1E4E8\">(joinedRow)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Evaluate WHERE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cond </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> EvaluateExpression</span><span style=\"color:#E1E4E8\">(whereClause, rowMap)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> cond.</span><span style=\"color:#B392F0\">IsTruthy</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            callback</span><span style=\"color:#E1E4E8\">(joinedRow)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The query planner (Milestone 8) is responsible for pushing predicates down to reduce the join input size.</p>\n<hr>\n<h2 id=\"multiple-joins\">Multiple JOINs</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">p</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">product_name</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> customers c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">JOIN</span><span style=\"color:#E1E4E8\"> orders o </span><span style=\"color:#F97583\">ON</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">customer_id</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">JOIN</span><span style=\"color:#E1E4E8\"> products p </span><span style=\"color:#F97583\">ON</span><span style=\"color:#79B8FF\"> o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">product_id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> p</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p>This is a sequence of nested loops:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">QueryExecutor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">executeMultiJoin</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    tables</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">JoinTableRef</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    conditions</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    callback</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">joinedRow</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start with first table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor0 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> e.db.</span><span style=\"color:#B392F0\">TableScan</span><span style=\"color:#E1E4E8\">(tables[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].TableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> cursor0.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        row0 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cursor0.</span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Join with second table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor1 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> e.db.</span><span style=\"color:#B392F0\">TableScan</span><span style=\"color:#E1E4E8\">(tables[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">].TableName)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> cursor1.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            row1 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cursor1.</span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Check first join condition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            combined01 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(row0, row1</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">e.</span><span style=\"color:#B392F0\">evaluateJoinCondition</span><span style=\"color:#E1E4E8\">(conditions[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], combined01, tables[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">]) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Join with third table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cursor2 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> e.db.</span><span style=\"color:#B392F0\">TableScan</span><span style=\"color:#E1E4E8\">(tables[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">].TableName)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> cursor2.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                row2 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cursor2.</span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Check second join condition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                combined012 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(combined01, row2</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">e.</span><span style=\"color:#B392F0\">evaluateJoinCondition</span><span style=\"color:#E1E4E8\">(conditions[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], combined012, tables[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">]) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // All conditions passed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                callback</span><span style=\"color:#E1E4E8\">(combined012)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Each additional JOIN adds another nested loop, making the complexity O(n1 × n2 × n3 × ...).</p>\n<hr>\n<h2 id=\"bytecode-compilation-for-aggregates\">Bytecode Compilation for Aggregates</h2>\n<p>The VM needs new opcodes for aggregation:</p>\n<table>\n<thead>\n<tr>\n<th>Opcode</th>\n<th>P1</th>\n<th>P2</th>\n<th>P3</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>AggStep</strong></td>\n<td>agg#</td>\n<td>column</td>\n<td>0</td>\n<td>Update aggregate with column value</td>\n</tr>\n<tr>\n<td><strong>AggFinal</strong></td>\n<td>agg#</td>\n<td>dest</td>\n<td>0</td>\n<td>Finalize aggregate into register</td>\n</tr>\n<tr>\n<td><strong>SorterOpen</strong></td>\n<td>sorter#</td>\n<td>0</td>\n<td>0</td>\n<td>Open a sorter for GROUP BY</td>\n</tr>\n<tr>\n<td><strong>SorterInsert</strong></td>\n<td>sorter#</td>\n<td>record</td>\n<td>0</td>\n<td>Insert row into sorter</td>\n</tr>\n<tr>\n<td><strong>SorterSort</strong></td>\n<td>sorter#</td>\n<td>0</td>\n<td>0</td>\n<td>Sort the sorter contents</td>\n</tr>\n<tr>\n<td><strong>SorterData</strong></td>\n<td>sorter#</td>\n<td>dest</td>\n<td>0</td>\n<td>Read current sorter row</td>\n</tr>\n<tr>\n<td><strong>SorterNext</strong></td>\n<td>sorter#</td>\n<td>jump</td>\n<td>0</td>\n<td>Advance sorter; jump if more</td>\n</tr>\n</tbody></table>\n<h3 id=\"group-by-bytecode\">GROUP BY Bytecode</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> status</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">COUNT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> orders </span><span style=\"color:#F97583\">GROUP BY</span><span style=\"color:#F97583\"> status</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>addr  opcode        p1  p2  p3  comment\n----  ----------    --  --  --  -------\n0     OpenTable     0   2   0   table=orders\n1     SorterOpen    1   0   0   for GROUP BY\n2     Rewind        0   8   0   scan orders\n3     Column        0   3   0   status -&gt; r0\n4     MakeRecord    0   1   1   make group key\n5     SorterInsert  1   1   0   insert into sorter\n6     Next          0   3   0   loop\n7     SorterSort    1   0   0   sort by group key\n8     SorterData    1   0   0   read group key\n9     AggStep       0   -1  0   COUNT(*) step\n10    SorterNext    1   8   0   loop groups\n11    AggFinal      0   1   0   finalize count\n12    ResultRow     0   2   0   output status, count\n13    Halt          0   0   0</code></pre></div>\n\n<h3 id=\"aggregation-in-the-vm\">Aggregation in the VM</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">case</span><span style=\"color:#9ECBFF\"> \"AggStep\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    aggIdx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> instr.P1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    colReg </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> instr.P2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get the aggregate state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    agg </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.Aggregates[aggIdx]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get the value to aggregate</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#B392F0\">Value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> colReg </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // COUNT(*) - use dummy value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        value </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: INTEGER, Int: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> vm.Registers[colReg]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    agg.</span><span style=\"color:#B392F0\">Update</span><span style=\"color:#E1E4E8\">(value)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">case</span><span style=\"color:#9ECBFF\"> \"AggFinal\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    aggIdx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> instr.P1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    destReg </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> instr.P2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    agg </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.Aggregates[aggIdx]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm.Registers[destReg] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> agg.</span><span style=\"color:#B392F0\">Finalize</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Reset for next group</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm.Aggregates[aggIdx] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> NewAggregateState</span><span style=\"color:#E1E4E8\">(agg.</span><span style=\"color:#B392F0\">Type</span><span style=\"color:#E1E4E8\">())</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"common-pitfalls\">Common Pitfalls</h2>\n<h3 id=\"1-countcolumn-including-nulls\">1. COUNT(column) Including NULLs</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Count all values</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CountColumnState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.count</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RIGHT: Only count non-NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CountColumnState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Update</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value.Type </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> NULL {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        s.count</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"2-avg-returning-integer\">2. AVG Returning Integer</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Integer division</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AvgState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Finalize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: INTEGER, Int: s.sum </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> s.count}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RIGHT: Float division</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AvgState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Finalize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: REAL, Float: s.sum </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(s.count)}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"3-sum-of-empty-set-returning-0-instead-of-null\">3. SUM of Empty Set Returning 0 Instead of NULL</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> SUM</span><span style=\"color:#E1E4E8\">(amount) </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> orders </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p>Result should be NULL, not 0. SUM of no values is &quot;unknown,&quot; not &quot;zero.&quot;</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SumState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Finalize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: REAL, Float: s.sum}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RIGHT</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SumState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Finalize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">s.valid {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: NULL}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: REAL, Float: s.sum}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"4-nested-loop-join-on-large-tables\">4. Nested Loop JOIN on Large Tables</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> large_table_a </span><span style=\"color:#F97583\">JOIN</span><span style=\"color:#E1E4E8\"> large_table_b </span><span style=\"color:#F97583\">ON</span><span style=\"color:#79B8FF\"> a</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> b</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">a_id</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p>If both tables have 100,000 rows, this performs 10 billion comparisons. Always ensure join columns are indexed, or the query planner chooses a different algorithm.</p>\n<h3 id=\"5-group-by-without-aggregate\">5. GROUP BY Without Aggregate</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#E1E4E8\"> customer_id </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> orders </span><span style=\"color:#F97583\">GROUP BY</span><span style=\"color:#E1E4E8\"> customer_id;</span></span></code></pre></div>\n\n<p>This is valid SQL—it returns distinct customer_ids. But it&#39;s confusing. Better to use <code>SELECT DISTINCT customer_id FROM orders</code> for clarity.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Handle GROUP BY without aggregates</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GroupByExecutor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Finalize</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#B392F0\">GroupResult</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(e.aggregates) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // No aggregates - just return distinct group keys</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        results </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">GroupResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(e.groups))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> key </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> e.groups {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            results </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(results, </span><span style=\"color:#B392F0\">GroupResult</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Key:    e.</span><span style=\"color:#B392F0\">parseGroupKey</span><span style=\"color:#E1E4E8\">(key),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Values: </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... normal finalization ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"6-having-using-non-aggregate-columns\">6. HAVING Using Non-Aggregate Columns</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">-- WRONG: HAVING references non-aggregate, non-group column</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#E1E4E8\"> customer_id, </span><span style=\"color:#79B8FF\">SUM</span><span style=\"color:#E1E4E8\">(amount)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> orders</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">GROUP BY</span><span style=\"color:#E1E4E8\"> customer_id</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">HAVING</span><span style=\"color:#F97583\"> status</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'completed'</span><span style=\"color:#E1E4E8\">;  </span><span style=\"color:#6A737D\">-- status is not in GROUP BY!</span></span></code></pre></div>\n\n<p>This is invalid SQL. HAVING can only reference:</p>\n<ul>\n<li>Columns in GROUP BY</li>\n<li>Aggregate functions</li>\n</ul>\n<p>Some databases allow it (returning arbitrary row&#39;s value), but it&#39;s non-standard.</p>\n<hr>\n<h2 id=\"test-suite-what-to-verify\">Test Suite: What to Verify</h2>\n<p><strong>Aggregate functions:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> numbers</span><span style=\"color:#E1E4E8\"> (val </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> numbers </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">), (</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">), (</span><span style=\"color:#F97583\">NULL</span><span style=\"color:#E1E4E8\">), (</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> COUNT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> numbers;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: 5</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> COUNT</span><span style=\"color:#E1E4E8\">(val) </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> numbers;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: 4 (NULL excluded)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> SUM</span><span style=\"color:#E1E4E8\">(val) </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> numbers;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: 11</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> AVG</span><span style=\"color:#E1E4E8\">(val) </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> numbers;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: 2.75 (11/4, not 11/5)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> MIN</span><span style=\"color:#E1E4E8\">(val), </span><span style=\"color:#79B8FF\">MAX</span><span style=\"color:#E1E4E8\">(val) </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> numbers;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: 1, 5</span></span></code></pre></div>\n\n<p><strong>Empty table handling:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> COUNT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#79B8FF\">SUM</span><span style=\"color:#E1E4E8\">(val), </span><span style=\"color:#79B8FF\">AVG</span><span style=\"color:#E1E4E8\">(val) </span><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> numbers </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: 0, NULL, NULL</span></span></code></pre></div>\n\n<p><strong>GROUP BY:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> orders</span><span style=\"color:#E1E4E8\"> (customer_id </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#E1E4E8\">, amount </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> orders </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">), (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">), (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">50</span><span style=\"color:#E1E4E8\">), (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">75</span><span style=\"color:#E1E4E8\">), (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">25</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#E1E4E8\"> customer_id, </span><span style=\"color:#79B8FF\">COUNT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#79B8FF\">SUM</span><span style=\"color:#E1E4E8\">(amount)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> orders</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">GROUP BY</span><span style=\"color:#E1E4E8\"> customer_id;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: (1, 2, 300), (2, 3, 150)</span></span></code></pre></div>\n\n<p><strong>HAVING:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#E1E4E8\"> customer_id, </span><span style=\"color:#79B8FF\">SUM</span><span style=\"color:#E1E4E8\">(amount)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> orders</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">GROUP BY</span><span style=\"color:#E1E4E8\"> customer_id</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">HAVING</span><span style=\"color:#79B8FF\"> SUM</span><span style=\"color:#E1E4E8\">(amount) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 200</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: (1, 300)</span></span></code></pre></div>\n\n<p><strong>INNER JOIN:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> customers</span><span style=\"color:#E1E4E8\"> (id </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">name</span><span style=\"color:#F97583\"> TEXT</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">INSERT INTO</span><span style=\"color:#E1E4E8\"> customers </span><span style=\"color:#F97583\">VALUES</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Alice'</span><span style=\"color:#E1E4E8\">), (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Bob'</span><span style=\"color:#E1E4E8\">), (</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Charlie'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">amount</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> customers c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">JOIN</span><span style=\"color:#E1E4E8\"> orders o </span><span style=\"color:#F97583\">ON</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">customer_id</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: (Alice, 100), (Alice, 200), (Bob, 50), (Bob, 75), (Bob, 25)</span></span></code></pre></div>\n\n<p><strong>JOIN with WHERE:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">amount</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> customers c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">JOIN</span><span style=\"color:#E1E4E8\"> orders o </span><span style=\"color:#F97583\">ON</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">customer_id</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">WHERE</span><span style=\"color:#79B8FF\"> o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">amount</span><span style=\"color:#F97583\"> ></span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: (Alice, 100), (Alice, 200)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Wait, 100 is not > 100, so just (Alice, 200)</span></span></code></pre></div>\n\n<p><strong>Multiple aggregates:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    COUNT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> total,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    COUNT</span><span style=\"color:#E1E4E8\">(val) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> non_null,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SUM</span><span style=\"color:#E1E4E8\">(val) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> sum_val,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AVG</span><span style=\"color:#E1E4E8\">(val) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> avg_val,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MIN</span><span style=\"color:#E1E4E8\">(val) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> min_val,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MAX</span><span style=\"color:#E1E4E8\">(val) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> max_val</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> numbers;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: 5, 4, 11, 2.75, 1, 5</span></span></code></pre></div>\n\n<p><strong>JOIN with no matches:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">amount</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> customers c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">JOIN</span><span style=\"color:#E1E4E8\"> orders o </span><span style=\"color:#F97583\">ON</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> o</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">customer_id</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">WHERE</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">;  </span><span style=\"color:#6A737D\">-- Charlie has no orders</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Expected: (empty result set)</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<p>You&#39;ve just implemented <strong>aggregation and joins</strong>—the features that make SQL a powerful analytical language. Here&#39;s where this connects:</p>\n<p><strong>Immediate connections:</strong></p>\n<ul>\n<li><strong>Query planner (Milestone 8)</strong>: The planner now has more decisions to make. Should a join use nested loop, hash join, or merge join? Should GROUP BY use hashing or sorting? Cost estimation becomes more complex.</li>\n<li><strong>All previous execution</strong>: Aggregates and joins build on the cursor, expression evaluation, and projection infrastructure you already built.</li>\n</ul>\n<p><strong>Same domain:</strong></p>\n<ul>\n<li><strong>Hash aggregation in analytical databases</strong>: DuckDB and ClickHouse use vectorized hash aggregation, processing batches of rows at once for SIMD efficiency. Your row-by-row approach is correct but slower.</li>\n<li><strong>Window functions</strong>: <code>ROW_NUMBER()</code>, <code>RANK()</code>, <code>LEAD()</code>, <code>LAG()</code> extend aggregation to operate over sliding windows. They use similar partitioning logic to GROUP BY.</li>\n<li><strong>Star schema queries in data warehouses</strong>: The canonical analytical query joins a fact table (orders) with dimension tables (customers, products, time). Your JOIN implementation is the foundation.</li>\n</ul>\n<p><strong>Cross-domain:</strong></p>\n<ul>\n<li><strong>MapReduce and data pipelines</strong>: GROUP BY is essentially a map phase (grouping by key) followed by reduce (aggregation). Hadoop&#39;s MapReduce, Spark&#39;s <code>groupBy().agg()</code>, and your SQL GROUP BY all implement the same pattern.</li>\n<li><strong>Stream processing windowing</strong>: Aggregates over time windows in Kafka Streams, Flink, and ksqlDB follow the same accumulation pattern. The difference is that window aggregates must handle late-arriving data and eviction.</li>\n<li><strong>Query engine vectorization</strong>: Modern databases (ClickHouse, DuckDB, Velox) batch aggregate operations for SIMD acceleration. Instead of <code>Update(value)</code> per row, they do <code>UpdateBatch(values[])</code> with CPU vector instructions.</li>\n<li><strong>ORM N+1 query problem</strong>: Understanding JOINs reveals why ORMs sometimes emit hundreds of queries. An ORM loading <code>Post</code> objects with <code>comments</code> might N+1: one query for posts, then N queries for each post&#39;s comments. A proper JOIN would fetch everything in one query. Understanding JOIN execution helps diagnose and fix these performance issues.</li>\n<li><strong>Pandas groupby operations</strong>: Python&#39;s <code>df.groupby(&#39;column&#39;).agg({&#39;value&#39;: &#39;sum&#39;})</code> is semantically identical to SQL&#39;s <code>GROUP BY column</code> with <code>SUM(value)</code>. The implementation differs (vectorized operations vs row-by-row), but the abstraction is the same.</li>\n</ul>\n<p><strong>Forward:</strong></p>\n<ul>\n<li><strong>With this knowledge, you could now build</strong>: A data pipeline that extracts groups from a database and processes them in parallel; a query analyzer that detects N+1 patterns in ORM queries; or a stream processor that computes windowed aggregates over event data.</li>\n</ul>\n<p>Aggregation and joins are where SQL becomes a <em>query language</em> rather than just a data access layer. You can now answer analytical questions: &quot;What&#39;s the average order value by customer segment?&quot; &quot;Which products are frequently bought together?&quot; &quot;How has revenue changed over time?&quot; These are the questions that drive business decisions—and your database can now answer them.</p>\n<hr>\n<!-- END_MS -->\n\n\n\n\n<h1 id=\"tdd\">TDD</h1>\n<p>A complete embedded SQL database engine implementing the SQLite architecture: tokenizer, recursive-descent parser, bytecode compiler (VDBE), register-based virtual machine, page-based B-tree/B+tree storage with slotted page format, LRU buffer pool manager, cost-based query planner with statistics, and ACID transactions via both rollback journal and write-ahead logging. The system processes SQL through a multi-stage pipeline where text becomes tokens, tokens become AST, AST becomes bytecode, and bytecode executes against a durable storage engine.</p>\n<!-- TDD_MOD_ID: build-sqlite-m1 -->\n<h1 id=\"technical-design-specification-sql-tokenizer\">Technical Design Specification: SQL Tokenizer</h1>\n<h2 id=\"module-charter\">Module Charter</h2>\n<p>The SQL Tokenizer converts raw SQL text strings into a stream of typed Token objects through character-by-character finite state machine processing. It handles SQL keywords (case-insensitive), string literals with escaped single quotes, numeric literals (integers and floats), single/multi-character operators, punctuation, quoted identifiers, and line comments. The tokenizer does NOT parse SQL syntax, validate query structure, or interpret token semantics—it produces only the token stream for downstream parser consumption. Upstream dependencies: none (accepts raw string). Downstream dependencies: SQL Parser consumes token stream. Invariants: every character in input is consumed exactly once; token line/column positions are monotonically increasing; the tokenizer never emits partial tokens on error (always ERROR token at failure point).</p>\n<hr>\n<h2 id=\"file-structure\">File Structure</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>tokenizer/\n├── token.go           # (1) Token types and Token struct\n├── tokenizer.go       # (2) Tokenizer struct and state machine\n├── keywords.go        # (3) SQL keyword map\n├── lexer.go           # (4) Core tokenization methods\n├── string_lit.go      # (5) String literal handling with escapes\n├── number.go          # (6) Numeric literal parsing\n├── operator.go        # (7) Operator and punctuation recognition\n├── tokenizer_test.go  # (8) Test suite (20+ SQL statements)\n└── errors.go          # (9) Error types with position info</code></pre></div>\n\n<hr>\n<h2 id=\"complete-data-model\">Complete Data Model</h2>\n<h3 id=\"token-type-enumeration\">Token Type Enumeration</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TokenType</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Sentinel</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EOF</span><span style=\"color:#B392F0\"> TokenType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ERROR</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Literals</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    KEYWORD</span><span style=\"color:#6A737D\">      // SQL reserved word (SELECT, FROM, WHERE, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    IDENTIFIER</span><span style=\"color:#6A737D\">   // Unquoted identifier (table_name, column_name)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    QUOTED_ID</span><span style=\"color:#6A737D\">    // Double-quoted identifier (\"column name\")</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    STRING</span><span style=\"color:#6A737D\">       // Single-quoted string literal ('hello')</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    NUMBER</span><span style=\"color:#6A737D\">       // Numeric literal (42, 3.14, -7)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Operators</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OPERATOR</span><span style=\"color:#6A737D\">     // =, &#x3C;, >, &#x3C;=, >=, !=, &#x3C;>, +, -, *, /</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Punctuation</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PUNCTUATION</span><span style=\"color:#6A737D\">  // (, ), ,, ;, .</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#B392F0\">TokenType</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> t {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> EOF: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"EOF\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ERROR: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"ERROR\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> KEYWORD: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"KEYWORD\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> IDENTIFIER: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"IDENTIFIER\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> QUOTED_ID: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"QUOTED_ID\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> STRING: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"STRING\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> NUMBER: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"NUMBER\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OPERATOR: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"OPERATOR\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> PUNCTUATION: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"PUNCTUATION\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"UNKNOWN\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"token-structure\">Token Structure</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type     </span><span style=\"color:#B392F0\">TokenType</span><span style=\"color:#6A737D\">   // Classification of this token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Value    </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">      // Raw text of the token (preserves original case)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Line     </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">         // 1-indexed line number where token starts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Column   </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">         // 1-indexed column number where token starts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NumType  </span><span style=\"color:#B392F0\">NumType</span><span style=\"color:#6A737D\">     // Only valid when Type == NUMBER</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NumType</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    NumInteger</span><span style=\"color:#B392F0\"> NumType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    NumFloat</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY each field exists:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Type: Parser dispatches on token type (KEYWORD vs IDENTIFIER)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Value: Needed for identifiers (table/column names) and literals</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Line/Column: Enables precise error messages pointing to source location</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - NumType: Distinguishes 42 (can be INTEGER column type) from 3.14 (REAL)</span></span></code></pre></div>\n\n<h3 id=\"tokenizer-state-machine\">Tokenizer State Machine</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LexerState</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateDefault</span><span style=\"color:#B392F0\"> LexerState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span><span style=\"color:#6A737D\">    // Normal code space, outside any literal</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateInString</span><span style=\"color:#6A737D\">                     // Inside single-quoted string literal</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateInQuotedID</span><span style=\"color:#6A737D\">                   // Inside double-quoted identifier</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateInNumber</span><span style=\"color:#6A737D\">                     // Parsing numeric literal</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateInIdentifier</span><span style=\"color:#6A737D\">                 // Parsing unquoted identifier/keyword</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateInLineComment</span><span style=\"color:#6A737D\">                // After --, consuming until newline</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateInBlockComment</span><span style=\"color:#6A737D\">               // Inside /* ... */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Tokenizer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    input    </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">      // The raw SQL text</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos      </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">         // Current byte position in input (0-indexed)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line     </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">         // Current line number (1-indexed)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    column   </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">         // Current column number (1-indexed)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state    </span><span style=\"color:#B392F0\">LexerState</span><span style=\"color:#6A737D\">  // Current FSM state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    keywords </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">  // Keyword lookup (uppercase -> true)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    allowUnicodeIDs </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">  // If false, only ASCII identifiers allowed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Invariants during tokenization:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - pos always advances forward (never backward)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - line/column accurately track source position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - state always reflects the current parsing context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - keywords map is initialized once and never modified</span></span></code></pre></div>\n\n<h3 id=\"keyword-map\">Keyword Map</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// keywords.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> SQLKeywords </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Query structure</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"SELECT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"FROM\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"WHERE\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"GROUP\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"BY\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"HAVING\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"ORDER\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"LIMIT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"OFFSET\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"DISTINCT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"ALL\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"AS\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // DML</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"INSERT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"INTO\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"VALUES\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"UPDATE\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"SET\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"DELETE\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // DDL</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"CREATE\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"TABLE\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"INDEX\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"UNIQUE\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"DROP\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"ALTER\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"ADD\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"COLUMN\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Data types</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"INTEGER\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"INT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"TEXT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"REAL\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"BLOB\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"NULL\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"BOOLEAN\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"BOOL\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Constraints</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"PRIMARY\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"KEY\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"FOREIGN\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"REFERENCES\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"NOT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"CONSTRAINT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"CHECK\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"DEFAULT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Joins</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"JOIN\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"INNER\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"LEFT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"RIGHT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"OUTER\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"CROSS\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"ON\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"USING\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Logical operators</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"AND\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"OR\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"NOT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"IN\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"BETWEEN\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"LIKE\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"IS\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"EXISTS\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Comparison</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"NULL\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"TRUE\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"FALSE\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Sorting</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"ASC\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"DESC\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Transactions</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"BEGIN\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"COMMIT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"ROLLBACK\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"TRANSACTION\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Aggregates</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"COUNT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"SUM\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"AVG\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"MIN\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"MAX\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Case expressions</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"CASE\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"WHEN\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"THEN\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"ELSE\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"END\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Misc</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"UNION\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"EXCEPT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"INTERSECT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"CAST\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"COLLATE\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"NOCASE\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"PRAGMA\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"ANALYZE\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"EXPLAIN\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"IF\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"AUTOINCREMENT\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"TEMP\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"TEMPORARY\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"interface-contracts\">Interface Contracts</h2>\n<h3 id=\"constructor\">Constructor</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// NewTokenizer creates a tokenizer for the given SQL input.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The input string is not modified; the tokenizer holds a reference.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Line and column tracking starts at 1, 1.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewTokenizer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">input</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Tokenizer</span></span></code></pre></div>\n\n<h3 id=\"primary-method-nexttoken\">Primary Method: NextToken</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// NextToken returns the next token in the stream.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Token with Type == EOF when input is exhausted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Token with Type == ERROR when tokenization fails</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Otherwise, a valid token with populated fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Post-conditions:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Tokenizer position has advanced past the returned token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Line/column reflect the position AFTER the token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Subsequent calls return subsequent tokens</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Error handling:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Unclosed string: returns ERROR with value of partial string and position at opening quote</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Unclosed quoted ID: returns ERROR with partial content and position at opening quote</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Unrecognized character: returns ERROR with that single character and its position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Invalid numeric literal: returns ERROR with the invalid portion</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Tokenizer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">NextToken</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Token</span></span></code></pre></div>\n\n<h3 id=\"tokenizeall-convenience\">TokenizeAll (Convenience)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// TokenizeAll returns all tokens until EOF or first ERROR.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// If an ERROR token is encountered, returns tokens up to and including the ERROR.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complexity: O(n) where n is input length.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Tokenizer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TokenizeAll</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#B392F0\">Token</span></span></code></pre></div>\n\n<h3 id=\"position-queries\">Position Queries</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Position returns the current line and column (1-indexed).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Useful for error reporting when caller detects semantic errors.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Tokenizer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Position</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#FFAB70\">line</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">column</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HasMore returns true if there are more characters to process.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Tokenizer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HasMore</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"algorithm-specification\">Algorithm Specification</h2>\n<h3 id=\"main-tokenization-loop\">Main Tokenization Loop</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: NextToken\nINPUT: Tokenizer t with current position in input\nOUTPUT: Next Token from input\n\n1. Skip whitespace and comments\n   WHILE current character is whitespace OR in a comment:\n     IF current is '-' AND next is '-':\n       Skip until newline (line comment)\n     ELSE IF current is '/' AND next is '*':\n       Skip until '*/' (block comment)\n     ELSE IF current is whitespace:\n       Advance one character, updating line/column\n     ELSE:\n       BREAK\n\n2. IF at end of input:\n     RETURN Token{Type: EOF, Line: t.line, Column: t.column}\n\n3. Let ch = current character, line = t.line, column = t.column\n\n4. SWITCH on ch:\n   CASE ''' (single quote):\n     RETURN readStringLiteral()\n   \n   CASE '&quot;' (double quote):\n     RETURN readQuotedIdentifier()\n   \n   CASE digit '0'-'9' OR (ch == '.' AND next is digit):\n     RETURN readNumberLiteral()\n   \n   CASE letter 'a'-'z', 'A'-'Z' OR '_':\n     RETURN readIdentifierOrKeyword()\n   \n   CASE one of '(', ')', ',', ';', '.':\n     Advance one character\n     RETURN Token{Type: PUNCTUATION, Value: string(ch), Line: line, Column: column}\n   \n   CASE one of '=', '&lt;', '&gt;', '!', '+', '-', '*', '/':\n     RETURN readOperator()\n   \n   DEFAULT:\n     Advance one character\n     RETURN Token{Type: ERROR, Value: string(ch), Line: line, Column: column}\n\nPOST-CONDITION: Tokenizer position is immediately after the returned token</code></pre></div>\n\n<h3 id=\"string-literal-parsing\">String Literal Parsing</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: readStringLiteral\nPRE-CONDITION: Current character is ''' (opening quote)\nPOST-CONDITION: Returns STRING token or ERROR token\n\n1. Let startLine = t.line, startColumn = t.column\n2. Advance past opening quote\n3. Let value = empty string builder\n\n4. WHILE not at end of input:\n     a. Let ch = current character\n     \n     b. IF ch is ''' (single quote):\n        i.   IF next character is also ''' (escaped quote):\n               Append ''' to value\n               Advance TWO characters  // Skip both quotes\n        ii.  ELSE:\n               // Closing quote found\n               Advance one character\n               RETURN Token{Type: STRING, Value: value, Line: startLine, Column: startColumn}\n     \n     c. IF ch is newline:\n        Append ch to value\n        Advance, incrementing line, reset column to 1\n     \n     d. ELSE:\n        Append ch to value\n        Advance one character, incrementing column\n\n5. // Reached end of input without closing quote\n   RETURN Token{Type: ERROR, Value: &quot;unclosed string literal&quot;, Line: startLine, Column: startColumn}</code></pre></div>\n\n<h3 id=\"numeric-literal-parsing\">Numeric Literal Parsing</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: readNumberLiteral\nPRE-CONDITION: Current position is start of a number\nPOST-CONDITION: Returns NUMBER token or ERROR token\n\n1. Let startLine = t.line, startColumn = t.column\n2. Let start = t.pos\n3. Let isFloat = false\n4. Let hasExponent = false\n\n5. // Handle leading digits\n   WHILE current is digit '0'-'9':\n     Advance\n\n6. // Handle decimal point\n   IF current is '.' AND next is digit:\n     isFloat = true\n     Advance  // skip '.'\n     WHILE current is digit:\n       Advance\n\n7. // Handle exponent (optional enhancement)\n   IF current is 'e' OR 'E':\n     hasExponent = true\n     isFloat = true\n     Advance\n     IF current is '+' OR '-':\n       Advance\n     IF current is NOT digit:\n       RETURN Token{Type: ERROR, Value: &quot;invalid exponent&quot;, Line: startLine, Column: startColumn}\n     WHILE current is digit:\n       Advance\n\n8. Let value = input[start : t.pos]\n\n9. IF isFloat:\n     RETURN Token{Type: NUMBER, Value: value, Line: startLine, Column: startColumn, NumType: NumFloat}\n   ELSE:\n     RETURN Token{Type: NUMBER, Value: value, Line: startLine, Column: startColumn, NumType: NumInteger}</code></pre></div>\n\n<h3 id=\"identifierkeyword-recognition\">Identifier/Keyword Recognition</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: readIdentifierOrKeyword\nPRE-CONDITION: Current character is letter or underscore\nPOST-CONDITION: Returns IDENTIFIER or KEYWORD token\n\n1. Let startLine = t.line, startColumn = t.column\n2. Let start = t.pos\n\n3. WHILE current is letter, digit, or underscore:\n     Advance\n\n4. Let value = input[start : t.pos]  // Preserves original case\n\n5. Let upperValue = uppercase(value)\n\n6. IF upperValue is in keyword map:\n     RETURN Token{Type: KEYWORD, Value: value, Line: startLine, Column: startColumn}\n   ELSE:\n     RETURN Token{Type: IDENTIFIER, Value: value, Line: startLine, Column: startColumn}</code></pre></div>\n\n<h3 id=\"operator-recognition\">Operator Recognition</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: readOperator\nPRE-CONDITION: Current character starts an operator\nPOST-CONDITION: Returns OPERATOR token\n\n1. Let startLine = t.line, startColumn = t.column\n2. Let ch = current character\n\n3. SWITCH on ch:\n   CASE '&lt;':\n     Advance\n     IF current is '=':\n       Advance\n       RETURN Token{Type: OPERATOR, Value: &quot;&lt;=&quot;, Line: startLine, Column: startColumn}\n     IF current is '&gt;':\n       Advance\n       RETURN Token{Type: OPERATOR, Value: &quot;&lt;&gt;&quot;, Line: startLine, Column: startColumn}\n     RETURN Token{Type: OPERATOR, Value: &quot;&lt;&quot;, Line: startLine, Column: startColumn}\n   \n   CASE '&gt;':\n     Advance\n     IF current is '=':\n       Advance\n       RETURN Token{Type: OPERATOR, Value: &quot;&gt;=&quot;, Line: startLine, Column: startColumn}\n     RETURN Token{Type: OPERATOR, Value: &quot;&gt;&quot;, Line: startLine, Column: startColumn}\n   \n   CASE '!':\n     Advance\n     IF current is '=':\n       Advance\n       RETURN Token{Type: OPERATOR, Value: &quot;!=&quot;, Line: startLine, Column: startColumn}\n     // '!' alone is not a valid SQL operator - could be ERROR, but some dialects allow it\n     RETURN Token{Type: OPERATOR, Value: &quot;!&quot;, Line: startLine, Column: startColumn}\n   \n   CASE '=':\n     Advance\n     RETURN Token{Type: OPERATOR, Value: &quot;=&quot;, Line: startLine, Column: startColumn}\n   \n   CASE '+', '-', '*', '/':\n     Advance\n     RETURN Token{Type: OPERATOR, Value: string(ch), Line: startLine, Column: startColumn}\n   \n   CASE '|':\n     IF next is '|':\n       Advance twice\n       RETURN Token{Type: OPERATOR, Value: &quot;||&quot;, Line: startLine, Column: startColumn}\n     // Single '|' not valid - return ERROR or handle per dialect\n\n4. // Should not reach here given pre-condition\n   RETURN Token{Type: ERROR, Value: string(ch), Line: startLine, Column: startColumn}</code></pre></div>\n\n<hr>\n<h2 id=\"error-handling-matrix\">Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th>Error</th>\n<th>Detected By</th>\n<th>Recovery</th>\n<th>User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unclosed string literal</td>\n<td><code>readStringLiteral</code>: EOF before closing quote</td>\n<td>Return ERROR token with position of opening quote; subsequent calls return EOF</td>\n<td>Yes: &quot;unclosed string literal at line X, column Y&quot;</td>\n</tr>\n<tr>\n<td>Unclosed quoted identifier</td>\n<td><code>readQuotedIdentifier</code>: EOF before closing quote</td>\n<td>Return ERROR token with position of opening quote</td>\n<td>Yes: &quot;unclosed quoted identifier at line X, column Y&quot;</td>\n</tr>\n<tr>\n<td>Unrecognized character</td>\n<td>Main loop: character doesn&#39;t match any token start</td>\n<td>Return ERROR token for that character; advance one position; continue</td>\n<td>Yes: &quot;unexpected character &#39;X&#39; at line Y, column Z&quot;</td>\n</tr>\n<tr>\n<td>Invalid numeric literal</td>\n<td><code>readNumberLiteral</code>: exponent without digits</td>\n<td>Return ERROR token; position at start of invalid number</td>\n<td>Yes: &quot;invalid numeric literal at line X, column Y&quot;</td>\n</tr>\n<tr>\n<td>Unclosed block comment</td>\n<td>Comment skipping: EOF before <code>*/</code></td>\n<td>Silently return EOF (comment is discarded)</td>\n<td>No: Treated as if query ended</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"implementation-sequence-with-checkpoints\">Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-token-structure-and-state-machine-skeleton-1-hour\">Phase 1: Token Structure and State Machine Skeleton (1 hour)</h3>\n<p><strong>Files to create</strong>: <code>token.go</code>, <code>tokenizer.go</code>, <code>errors.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Define <code>TokenType</code> enum and <code>Token</code> struct</li>\n<li>Define <code>Tokenizer</code> struct with position tracking</li>\n<li>Implement <code>NewTokenizer</code> constructor</li>\n<li>Implement <code>NextToken</code> skeleton that returns EOF</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should be able to create a tokenizer and get EOF tokens. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestEmptyInput</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS</span></span></code></pre></div>\n\n<h3 id=\"phase-2-keyword-recognition-05-hours\">Phase 2: Keyword Recognition (0.5 hours)</h3>\n<p><strong>Files to create</strong>: <code>keywords.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Define <code>SQLKeywords</code> map</li>\n<li>Implement <code>readIdentifierOrKeyword</code></li>\n<li>Implement letter/digit/underscore advancement</li>\n<li>Implement case-insensitive keyword lookup</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should be able to tokenize <code>SELECT FROM WHERE</code>. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestKeywords</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (SELECT -> KEYWORD, FROM -> KEYWORD, etc.)</span></span></code></pre></div>\n\n<h3 id=\"phase-3-string-literal-parsing-with-escape-handling-1-hour\">Phase 3: String Literal Parsing with Escape Handling (1 hour)</h3>\n<p><strong>Files to create</strong>: <code>string_lit.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>readStringLiteral</code></li>\n<li>Handle escaped single quotes (<code>&#39;&#39;</code> → <code>&#39;</code>)</li>\n<li>Handle newlines within strings (multi-line strings are valid in SQL)</li>\n<li>Handle unclosed string error</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should be able to tokenize <code>&#39;hello&#39;</code>, <code>&#39;it&#39;&#39;s&#39;</code>, and detect unclosed strings. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestStringLiterals</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (includes escape and error cases)</span></span></code></pre></div>\n\n<h3 id=\"phase-4-numeric-literal-parsing-05-hours\">Phase 4: Numeric Literal Parsing (0.5 hours)</h3>\n<p><strong>Files to create</strong>: <code>number.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>readNumberLiteral</code></li>\n<li>Handle integers: <code>42</code>, <code>0</code>, <code>007</code></li>\n<li>Handle floats: <code>3.14</code>, <code>0.5</code>, <code>.5</code> (if supported)</li>\n<li>Distinguish INTEGER vs FLOAT in <code>NumType</code></li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should be able to tokenize <code>42</code>, <code>3.14</code>, and distinguish types. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestNumbers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (integer vs float distinction)</span></span></code></pre></div>\n\n<h3 id=\"phase-5-operator-and-punctuation-tokenization-05-hours\">Phase 5: Operator and Punctuation Tokenization (0.5 hours)</h3>\n<p><strong>Files to create</strong>: <code>operator.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>readOperator</code></li>\n<li>Handle single-char operators: <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></li>\n<li>Handle multi-char operators: <code>&lt;=</code>, <code>&gt;=</code>, <code>!=</code>, <code>&lt;&gt;</code>, <code>||</code></li>\n<li>Handle punctuation: <code>(</code>, <code>)</code>, <code>,</code>, <code>;</code>, <code>.</code></li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should be able to tokenize <code>a &lt;= b</code> and <code>x || y</code>. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestOperators</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (all operators recognized)</span></span></code></pre></div>\n\n<h3 id=\"phase-6-quoted-identifiers-comments-and-error-cases-05-hours\">Phase 6: Quoted Identifiers, Comments, and Error Cases (0.5 hours)</h3>\n<p><strong>Files to update</strong>: <code>lexer.go</code>, <code>tokenizer_test.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>readQuotedIdentifier</code></li>\n<li>Implement line comment skipping (<code>--</code>)</li>\n<li>Implement block comment skipping (<code>/* */</code>)</li>\n<li>Implement unrecognized character error</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should pass the full test suite. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> ./tokenizer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: All tests PASS, including 20+ diverse SQL statements</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"test-specification\">Test Specification</h2>\n<h3 id=\"test-categories\">Test Categories</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// tokenizer_test.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestEmptyInput</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tok </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewTokenizer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{Type: EOF, Line: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, Column: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}, tok.</span><span style=\"color:#B392F0\">NextToken</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestKeywords</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        input    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected []</span><span style=\"color:#B392F0\">Token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            input: </span><span style=\"color:#9ECBFF\">\"SELECT\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            expected: []</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                {Type: KEYWORD, Value: </span><span style=\"color:#9ECBFF\">\"SELECT\"</span><span style=\"color:#E1E4E8\">, Line: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, Column: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                {Type: EOF, Line: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, Column: </span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            input: </span><span style=\"color:#9ECBFF\">\"select SELECT Select\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            expected: []</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                {Type: KEYWORD, Value: </span><span style=\"color:#9ECBFF\">\"select\"</span><span style=\"color:#E1E4E8\">, Line: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, Column: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                {Type: KEYWORD, Value: </span><span style=\"color:#9ECBFF\">\"SELECT\"</span><span style=\"color:#E1E4E8\">, Line: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, Column: </span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                {Type: KEYWORD, Value: </span><span style=\"color:#9ECBFF\">\"Select\"</span><span style=\"color:#E1E4E8\">, Line: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, Column: </span><span style=\"color:#79B8FF\">15</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                {Type: EOF, Line: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, Column: </span><span style=\"color:#79B8FF\">21</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... test execution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestIdentifiers</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        input    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected []</span><span style=\"color:#B392F0\">Token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">, expected: []</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{{Type: IDENTIFIER, Value: </span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">, Line: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, Column: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"_private\"</span><span style=\"color:#E1E4E8\">, expected: []</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{{Type: IDENTIFIER, Value: </span><span style=\"color:#9ECBFF\">\"_private\"</span><span style=\"color:#E1E4E8\">, Line: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, Column: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"table123\"</span><span style=\"color:#E1E4E8\">, expected: []</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{{Type: IDENTIFIER, Value: </span><span style=\"color:#9ECBFF\">\"table123\"</span><span style=\"color:#E1E4E8\">, Line: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, Column: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestStringLiterals</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        input    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected </span><span style=\"color:#B392F0\">Token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"'hello'\"</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{Type: STRING, Value: </span><span style=\"color:#9ECBFF\">\"hello\"</span><span style=\"color:#E1E4E8\">}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"''\"</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{Type: STRING, Value: </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">}}, </span><span style=\"color:#6A737D\">// Empty string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"'it''s'\"</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{Type: STRING, Value: </span><span style=\"color:#9ECBFF\">\"it's\"</span><span style=\"color:#E1E4E8\">}}, </span><span style=\"color:#6A737D\">// Escaped quote</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"''''\"</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{Type: STRING, Value: </span><span style=\"color:#9ECBFF\">\"'\"</span><span style=\"color:#E1E4E8\">}}, </span><span style=\"color:#6A737D\">// Single quote</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"'hello</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">world'\"</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{Type: STRING, Value: </span><span style=\"color:#9ECBFF\">\"hello</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">world\"</span><span style=\"color:#E1E4E8\">}}, </span><span style=\"color:#6A737D\">// Multiline</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestStringErrors</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        input       </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expectError </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        errorLine   </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        errorCol    </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"'unclosed\"</span><span style=\"color:#E1E4E8\">, expectError: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, errorLine: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, errorCol: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"'unclosed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, expectError: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, errorLine: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, errorCol: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestNumbers</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        input    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected </span><span style=\"color:#B392F0\">Token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"42\"</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{Type: NUMBER, Value: </span><span style=\"color:#9ECBFF\">\"42\"</span><span style=\"color:#E1E4E8\">, NumType: NumInteger}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"0\"</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{Type: NUMBER, Value: </span><span style=\"color:#9ECBFF\">\"0\"</span><span style=\"color:#E1E4E8\">, NumType: NumInteger}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"3.14\"</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{Type: NUMBER, Value: </span><span style=\"color:#9ECBFF\">\"3.14\"</span><span style=\"color:#E1E4E8\">, NumType: NumFloat}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"0.5\"</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{Type: NUMBER, Value: </span><span style=\"color:#9ECBFF\">\"0.5\"</span><span style=\"color:#E1E4E8\">, NumType: NumFloat}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\".5\"</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{Type: NUMBER, Value: </span><span style=\"color:#9ECBFF\">\".5\"</span><span style=\"color:#E1E4E8\">, NumType: NumFloat}}, </span><span style=\"color:#6A737D\">// If supported</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestOperators</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        input    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected []</span><span style=\"color:#B392F0\">Token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"=\"</span><span style=\"color:#E1E4E8\">, expected: []</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{{Type: OPERATOR, Value: </span><span style=\"color:#9ECBFF\">\"=\"</span><span style=\"color:#E1E4E8\">}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"&#x3C;\"</span><span style=\"color:#E1E4E8\">, expected: []</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{{Type: OPERATOR, Value: </span><span style=\"color:#9ECBFF\">\"&#x3C;\"</span><span style=\"color:#E1E4E8\">}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"&#x3C;=\"</span><span style=\"color:#E1E4E8\">, expected: []</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{{Type: OPERATOR, Value: </span><span style=\"color:#9ECBFF\">\"&#x3C;=\"</span><span style=\"color:#E1E4E8\">}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\">=\"</span><span style=\"color:#E1E4E8\">, expected: []</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{{Type: OPERATOR, Value: </span><span style=\"color:#9ECBFF\">\">=\"</span><span style=\"color:#E1E4E8\">}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"!=\"</span><span style=\"color:#E1E4E8\">, expected: []</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{{Type: OPERATOR, Value: </span><span style=\"color:#9ECBFF\">\"!=\"</span><span style=\"color:#E1E4E8\">}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"&#x3C;>\"</span><span style=\"color:#E1E4E8\">, expected: []</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{{Type: OPERATOR, Value: </span><span style=\"color:#9ECBFF\">\"&#x3C;>\"</span><span style=\"color:#E1E4E8\">}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"||\"</span><span style=\"color:#E1E4E8\">, expected: []</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{{Type: OPERATOR, Value: </span><span style=\"color:#9ECBFF\">\"||\"</span><span style=\"color:#E1E4E8\">}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestQuotedIdentifiers</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        input    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected </span><span style=\"color:#B392F0\">Token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">`\"column name\"`</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{Type: QUOTED_ID, Value: </span><span style=\"color:#9ECBFF\">\"column name\"</span><span style=\"color:#E1E4E8\">}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">`\"SELECT\"`</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{Type: QUOTED_ID, Value: </span><span style=\"color:#9ECBFF\">\"SELECT\"</span><span style=\"color:#E1E4E8\">}}, </span><span style=\"color:#6A737D\">// Not a keyword!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestComments</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        input    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected []</span><span style=\"color:#B392F0\">Token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"-- comment</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">SELECT\"</span><span style=\"color:#E1E4E8\">, expected: []</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{{Type: KEYWORD, Value: </span><span style=\"color:#9ECBFF\">\"SELECT\"</span><span style=\"color:#E1E4E8\">}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"/* block */SELECT\"</span><span style=\"color:#E1E4E8\">, expected: []</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{{Type: KEYWORD, Value: </span><span style=\"color:#9ECBFF\">\"SELECT\"</span><span style=\"color:#E1E4E8\">}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"/* multi</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">line */SELECT\"</span><span style=\"color:#E1E4E8\">, expected: []</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{{Type: KEYWORD, Value: </span><span style=\"color:#9ECBFF\">\"SELECT\"</span><span style=\"color:#E1E4E8\">}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestComplexStatements</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 20+ diverse SQL statements</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    statements </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT id, name FROM users WHERE age > 18\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM users WHERE active = 1 AND role = 'admin'\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"INSERT INTO users (id, name) VALUES (1, 'Alice')\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"INSERT INTO users VALUES (2, 'Bob', 'bob@example.com')\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"UPDATE users SET name = 'Charlie' WHERE id = 1\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"DELETE FROM users WHERE id = 1\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"CREATE TABLE </span><span style=\"color:#79B8FF\">\\\"</span><span style=\"color:#9ECBFF\">Order Items</span><span style=\"color:#79B8FF\">\\\"</span><span style=\"color:#9ECBFF\"> (id INTEGER, qty INTEGER NOT NULL)\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM users ORDER BY name DESC LIMIT 10\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT COUNT(*) FROM users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT status, COUNT(*) FROM orders GROUP BY status\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"BEGIN TRANSACTION\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"COMMIT\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"ROLLBACK\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"CREATE INDEX idx_email ON users(email)\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM users WHERE email LIKE '%@example.com'\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM users WHERE id IN (1, 2, 3)\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM users WHERE created_at BETWEEN '2024-01-01' AND '2024-12-31'\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT a.name, b.name FROM users a JOIN users b ON a.id = b.manager_id\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM users WHERE name IS NULL\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM users WHERE name IS NOT NULL\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"PRAGMA journal_mode=WAL\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"EXPLAIN SELECT * FROM users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"ANALYZE users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, stmt </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> statements {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tok </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewTokenizer</span><span style=\"color:#E1E4E8\">(stmt)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tokens </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tok.</span><span style=\"color:#B392F0\">TokenizeAll</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Verify no ERROR tokens (except for intentionally invalid inputs)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> _, token </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> tokens {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> token.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ERROR {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                t.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Unexpected error tokenizing </span><span style=\"color:#79B8FF\">%q</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, stmt, token)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Verify last token is EOF</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(tokens) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> tokens[</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(tokens)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">].Type </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> EOF {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            t.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Expected EOF as last token for </span><span style=\"color:#79B8FF\">%q</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, stmt)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestPositionTracking</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    input </span><span style=\"color:#F97583\">:=</span><span style=\"color:#9ECBFF\"> \"SELECT *</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">FROM users</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">WHERE id = 1\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tok </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewTokenizer</span><span style=\"color:#E1E4E8\">(input)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tokens </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tok.</span><span style=\"color:#B392F0\">TokenizeAll</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify line/column positions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expected </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {Type: KEYWORD, Value: </span><span style=\"color:#9ECBFF\">\"SELECT\"</span><span style=\"color:#E1E4E8\">, Line: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, Column: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {Type: OPERATOR, Value: </span><span style=\"color:#9ECBFF\">\"*\"</span><span style=\"color:#E1E4E8\">, Line: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, Column: </span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {Type: KEYWORD, Value: </span><span style=\"color:#9ECBFF\">\"FROM\"</span><span style=\"color:#E1E4E8\">, Line: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, Column: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {Type: IDENTIFIER, Value: </span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">, Line: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, Column: </span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {Type: KEYWORD, Value: </span><span style=\"color:#9ECBFF\">\"WHERE\"</span><span style=\"color:#E1E4E8\">, Line: </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, Column: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {Type: IDENTIFIER, Value: </span><span style=\"color:#9ECBFF\">\"id\"</span><span style=\"color:#E1E4E8\">, Line: </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, Column: </span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {Type: OPERATOR, Value: </span><span style=\"color:#9ECBFF\">\"=\"</span><span style=\"color:#E1E4E8\">, Line: </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, Column: </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {Type: NUMBER, Value: </span><span style=\"color:#9ECBFF\">\"1\"</span><span style=\"color:#E1E4E8\">, Line: </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, Column: </span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, exp </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> expected {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> tokens[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> exp {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            t.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Token </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: expected </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">, got </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, i, exp, tokens[i])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-targets\">Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Target</th>\n<th>How to Measure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Tokenize 10KB SQL file</td>\n<td>&lt; 1ms</td>\n<td><code>go test -bench=BenchmarkTokenize10KB</code></td>\n</tr>\n<tr>\n<td>Tokenize 20 diverse statements</td>\n<td>&lt; 10ms total</td>\n<td><code>go test -bench=BenchmarkDiverseStatements</code></td>\n</tr>\n<tr>\n<td>Memory per 1000 tokens</td>\n<td>&lt; 100KB</td>\n<td><code>go test -memprofile</code> and analyze</td>\n</tr>\n<tr>\n<td>Single-pass processing</td>\n<td>No backtracking</td>\n<td>Code review: verify no <code>pos--</code> or similar</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"synced-criteria\">Synced Criteria</h2>\n<p>[[CRITERIA_JSON: {&quot;module_id&quot;: &quot;build-sqlite-m1&quot;, &quot;criteria&quot;: [&quot;Tokenizer recognizes SQL keywords (SELECT, INSERT, CREATE, WHERE, JOIN, etc.) case-insensitively&quot;, &quot;String literals enclosed in single quotes are parsed including escaped quotes (&#39;it&#39;&#39;s&#39; → it&#39;s)&quot;, &quot;Numeric literals including integers and floating-point values (42, 3.14) are recognized as distinct token types&quot;, &quot;Operators (=, &lt;, &gt;, &lt;=, &gt;=, !=, &lt;&gt;) and punctuation (comma, parentheses, semicolon) are tokenized as distinct tokens&quot;, &quot;Identifiers (table names, column names) support quoted identifiers with double quotes (&quot;column name&quot;)&quot;, &quot;Tokenizer reports error position (line and column) for unrecognized characters&quot;, &quot;Token stream correctly tokenizes at least 20 diverse SQL statements in a test suite&quot;, &quot;The tokenizer returns a list or stream of objects containing type, value, line, and column&quot;]}]</p>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-sqlite-m2 -->\n<h1 id=\"technical-design-specification-sql-parser-ast\">Technical Design Specification: SQL Parser (AST)</h1>\n<h2 id=\"module-charter\">Module Charter</h2>\n<p>The SQL Parser transforms a token stream into a hierarchical Abstract Syntax Tree (AST) using recursive descent parsing. It handles SELECT statements (columns, FROM, WHERE, ORDER BY, LIMIT), INSERT statements (table, columns, VALUES), CREATE TABLE statements (column definitions, constraints), and arbitrary expressions with correct operator precedence via precedence climbing. The parser does NOT validate table existence, execute queries, or check semantic constraints—it produces a syntactically valid AST for downstream compilation. Upstream dependencies: Tokenizer (consumes token stream). Downstream dependencies: Bytecode Compiler (consumes AST). Invariants: every token is consumed exactly once; the AST root is always a Statement type; expression trees respect SQL precedence rules (NOT &gt; comparison &gt; AND &gt; OR); all error positions point to specific token locations.</p>\n<hr>\n<h2 id=\"file-structure\">File Structure</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>parser/\n├── ast.go              # (1) AST node type definitions\n├── parser.go           # (2) Parser struct and core dispatch\n├── select.go           # (3) SELECT statement parsing\n├── insert.go           # (4) INSERT statement parsing\n├── create.go           # (5) CREATE TABLE parsing\n├── expression.go       # (6) Expression parsing with precedence climbing\n├── precedence.go       # (7) Operator precedence table\n├── errors.go           # (8) ParseError type with position info\n├── parser_test.go      # (9) Test suite (15+ valid, 10+ invalid)\n└── ast_printer.go      # (10) AST pretty-printing for debugging</code></pre></div>\n\n<hr>\n<h2 id=\"complete-data-model\">Complete Data Model</h2>\n<h3 id=\"statement-types-root-ast-nodes\">Statement Types (Root AST Nodes)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ast.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Statement</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    isStatement</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Pos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Position</span><span style=\"color:#6A737D\">  // Returns starting position for error reporting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Position</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Line   </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Column </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SELECT statement</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SelectStatement</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos       </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Columns   []</span><span style=\"color:#B392F0\">ColumnSelection</span><span style=\"color:#6A737D\">  // * or explicit column list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FromTable </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">             // Table name (required)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Alias     </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">             // Optional table alias (AS alias)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Where     </span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#6A737D\">         // Optional WHERE clause</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GroupBy   []</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#6A737D\">       // Optional GROUP BY columns</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Having    </span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#6A737D\">         // Optional HAVING clause</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OrderBy   []</span><span style=\"color:#B392F0\">OrderByColumn</span><span style=\"color:#6A737D\">    // Optional ORDER BY</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Limit     </span><span style=\"color:#F97583\">*int</span><span style=\"color:#6A737D\">               // Optional LIMIT value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Offset    </span><span style=\"color:#F97583\">*int</span><span style=\"color:#6A737D\">               // Optional OFFSET value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SelectStatement</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isStatement</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SelectStatement</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Pos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Position</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> s.Pos }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ColumnSelection</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expression </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Alias      </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // Optional: \"AS alias\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> OrderByColumn</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expression </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Descending </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">  // true for DESC, false for ASC (default)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// INSERT statement</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> InsertStatement</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos        </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Table      </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">          // Target table name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Columns    []</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">        // Optional column names (nil means all columns)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Values     [][]</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#6A737D\">  // One or more value tuples</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Returning  []</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">        // Optional RETURNING columns (advanced)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">InsertStatement</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isStatement</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">InsertStatement</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Pos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Position</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> s.Pos }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CREATE TABLE statement</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CreateTableStatement</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos         </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Table       </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IfNotExists </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Columns     []</span><span style=\"color:#B392F0\">ColumnDefinition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Constraints []</span><span style=\"color:#B392F0\">TableConstraint</span><span style=\"color:#6A737D\">  // Table-level constraints</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CreateTableStatement</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isStatement</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CreateTableStatement</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Pos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Position</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> s.Pos }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ColumnDefinition</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name        </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type        </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">              // INTEGER, TEXT, REAL, BLOB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Constraints []</span><span style=\"color:#B392F0\">ColumnConstraint</span><span style=\"color:#6A737D\">  // PRIMARY KEY, NOT NULL, etc.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ColumnConstraint</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    isColumnConstraint</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PrimaryKeyConstraint</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AutoIncrement </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PrimaryKeyConstraint</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isColumnConstraint</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NotNullConstraint</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NotNullConstraint</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isColumnConstraint</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> UniqueConstraint</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">UniqueConstraint</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isColumnConstraint</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DefaultConstraint</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Value </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DefaultConstraint</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isColumnConstraint</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CheckConstraint</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expression </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CheckConstraint</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isColumnConstraint</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ForeignKeyConstraint</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ReferencesTable  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ReferencesColumn </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OnDelete         </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // CASCADE, SET NULL, etc.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OnUpdate         </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ForeignKeyConstraint</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isColumnConstraint</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TableConstraint</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    isTableConstraint</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TablePrimaryKeyConstraint</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Columns []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TablePrimaryKeyConstraint</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isTableConstraint</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TableUniqueConstraint</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Columns []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TableUniqueConstraint</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isTableConstraint</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Other statements (stubs for extensibility)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> UpdateStatement</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos     </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Table   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Sets    []</span><span style=\"color:#B392F0\">SetClause</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Where   </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SetClause</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Column </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Value  </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DeleteStatement</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos   </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Table </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Where </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CreateIndexStatement</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos       </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IndexName </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Table     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Columns   []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Unique    </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DropStatement</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos       </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectType </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // \"TABLE\" or \"INDEX\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BeginStatement</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CommitStatement</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RollbackStatement</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"expression-types\">Expression Types</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ast.go (continued)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Expression</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    isExpression</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Pos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Binary expression: a AND b, x = y, etc.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BinaryExpression</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos      </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Operator </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">      // AND, OR, =, &#x3C;, >, &#x3C;=, >=, !=, &#x3C;>, +, -, *, /, ||, LIKE, IN, BETWEEN</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Left     </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Right    </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BinaryExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isExpression</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BinaryExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Pos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Position</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> e.Pos }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Unary expression: NOT a, -5</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> UnaryExpression</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos      </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Operator </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // NOT, - (negation)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Operand  </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">UnaryExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isExpression</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">UnaryExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Pos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Position</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> e.Pos }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Literal value: 42, 'hello', NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LiteralExpression</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos   </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Value </span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}  </span><span style=\"color:#6A737D\">// int64, float64, string, nil (for NULL)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type  </span><span style=\"color:#B392F0\">LiteralType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LiteralType</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LiteralNull</span><span style=\"color:#B392F0\"> LiteralType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LiteralInteger</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LiteralFloat</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LiteralString</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LiteralExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isExpression</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LiteralExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Pos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Position</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> e.Pos }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Column reference: id, users.name</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IdentifierExpression</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos       </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name      </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // Column name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TableName </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // Optional table qualifier (for joins)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IdentifierExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isExpression</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IdentifierExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Pos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Position</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> e.Pos }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Function call: COUNT(*), SUM(amount)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> FunctionCallExpression</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos      </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Args     []</span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Distinct </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">  // COUNT(DISTINCT x)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FunctionCallExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isExpression</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FunctionCallExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Pos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Position</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> e.Pos }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Star expression: * in SELECT *</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> StarExpression</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos       </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TableName </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // Optional: table.* in joins</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StarExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isExpression</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StarExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Pos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Position</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> e.Pos }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IN expression: x IN (1, 2, 3)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> InExpression</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos        </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expression </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Values     []</span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Negated    </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">  // NOT IN</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">InExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isExpression</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">InExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Pos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Position</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> e.Pos }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BETWEEN expression: x BETWEEN 1 AND 10</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BetweenExpression</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos        </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expression </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Low        </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    High       </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Negated    </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">  // NOT BETWEEN</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BetweenExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isExpression</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BetweenExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Pos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Position</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> e.Pos }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IS NULL / IS NOT NULL expression</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IsNullExpression</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos        </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expression </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Negated    </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">  // IS NOT NULL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IsNullExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isExpression</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IsNullExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Pos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Position</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> e.Pos }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LIKE expression: name LIKE '%smith%'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LikeExpression</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos        </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expression </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pattern    </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Negated    </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">  // NOT LIKE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LikeExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isExpression</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LikeExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Pos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Position</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> e.Pos }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parenthesized expression: (a OR b) AND c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ParenExpression</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos        </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expression </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ParenExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isExpression</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ParenExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Pos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Position</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> e.Pos }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CASE expression</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CaseExpression</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos        </span><span style=\"color:#B392F0\">Position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Operand    </span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#6A737D\">  // Optional: CASE x WHEN ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WhenClauses []</span><span style=\"color:#B392F0\">WhenClause</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Else       </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WhenClause</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Condition </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Result    </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CaseExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isExpression</span><span style=\"color:#E1E4E8\">() {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CaseExpression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Pos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Position</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> e.Pos }</span></span></code></pre></div>\n\n<h3 id=\"parser-state\">Parser State</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// parser.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Parser</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tokens   []</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#6A737D\">    // Full token stream</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos      </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">        // Current position in token array</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current  </span><span style=\"color:#B392F0\">Token</span><span style=\"color:#6A737D\">      // Lookahead token (tokens[pos])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    previous </span><span style=\"color:#B392F0\">Token</span><span style=\"color:#6A737D\">      // Last consumed token (for error context)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    errors   []</span><span style=\"color:#B392F0\">ParseError</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ParseError</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Message  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Line     </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Column   </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Token    </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // The unexpected token's text</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expected </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // What was expected (optional)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#B392F0\">ParseError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> e.Expected </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"parse error at line </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, column </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: expected </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, got </span><span style=\"color:#79B8FF\">%q</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            e.Line, e.Column, e.Expected, e.Token)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"parse error at line </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, column </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        e.Line, e.Column, e.Message)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"precedence-table\">Precedence Table</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// precedence.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> OperatorInfo</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Precedence </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IsRightAssoc </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">  // For exponentiation, etc.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SQL operator precedence (higher number = tighter binding)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Based on SQL standard with SQLite extensions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> precedenceTable </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">OperatorInfo</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Logical OR (lowest precedence)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"OR\"</span><span style=\"color:#E1E4E8\">: {Precedence: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Logical AND</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"AND\"</span><span style=\"color:#E1E4E8\">: {Precedence: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Logical NOT</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"NOT\"</span><span style=\"color:#E1E4E8\">: {Precedence: </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Comparison operators</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"=\"</span><span style=\"color:#E1E4E8\">:  {Precedence: </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"&#x3C;\"</span><span style=\"color:#E1E4E8\">:  {Precedence: </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \">\"</span><span style=\"color:#E1E4E8\">:  {Precedence: </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"&#x3C;=\"</span><span style=\"color:#E1E4E8\">: {Precedence: </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \">=\"</span><span style=\"color:#E1E4E8\">: {Precedence: </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"!=\"</span><span style=\"color:#E1E4E8\">: {Precedence: </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"&#x3C;>\"</span><span style=\"color:#E1E4E8\">: {Precedence: </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"IN\"</span><span style=\"color:#E1E4E8\">: {Precedence: </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"BETWEEN\"</span><span style=\"color:#E1E4E8\">: {Precedence: </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"LIKE\"</span><span style=\"color:#E1E4E8\">: {Precedence: </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"IS\"</span><span style=\"color:#E1E4E8\">: {Precedence: </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Addition, subtraction, concatenation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"+\"</span><span style=\"color:#E1E4E8\">:  {Precedence: </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"-\"</span><span style=\"color:#E1E4E8\">:  {Precedence: </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"||\"</span><span style=\"color:#E1E4E8\">: {Precedence: </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Multiplication, division, modulo</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"*\"</span><span style=\"color:#E1E4E8\">: {Precedence: </span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"/\"</span><span style=\"color:#E1E4E8\">: {Precedence: </span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"%\"</span><span style=\"color:#E1E4E8\">: {Precedence: </span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Unary minus, unary plus</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // (handled specially in prefix parsing)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LowestPrecedence</span><span style=\"color:#F97583\">  =</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    HighestPrecedence</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 6</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"interface-contracts\">Interface Contracts</h2>\n<h3 id=\"constructor\">Constructor</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// NewParser creates a parser for the given token stream.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The token stream should include an EOF token at the end.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Panics if tokens is empty.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewParser</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tokens</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span></span></code></pre></div>\n\n<h3 id=\"primary-method-parse\">Primary Method: Parse</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Parse parses the token stream and returns an AST root (Statement).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - (Statement, nil) on successful parse</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - (nil, ParseError) on failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The parser consumes tokens until:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - A complete statement is parsed (semicolon or EOF)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - An error is encountered</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// On error, the parser's internal state is undefined; do not continue parsing.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Parse</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">Statement</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h3 id=\"token-navigation\">Token Navigation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// advance moves to the next token and returns the previous one.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// At EOF, subsequent calls return the EOF token.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">advance</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">Token</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// expect consumes the current token if it matches the expected type and value.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// For keyword matching, value comparison is case-insensitive.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns error if current token doesn't match.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">expect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tokenType</span><span style=\"color:#B392F0\"> TokenType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// expectType consumes the current token if it matches the expected type.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns error if current token's type doesn't match.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">expectType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tokenType</span><span style=\"color:#B392F0\"> TokenType</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// match checks if the current token matches without consuming it.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">match</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tokenType</span><span style=\"color:#B392F0\"> TokenType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// matchKeyword checks if current token is a keyword with the given value (case-insensitive).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">matchKeyword</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// peek returns the token at offset positions ahead without consuming.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// peek(0) returns current token, peek(1) returns next token.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">peek</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Token</span></span></code></pre></div>\n\n<h3 id=\"error-reporting\">Error Reporting</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// error creates a ParseError at the current token's position.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">format</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#F97583\"> ...interface</span><span style=\"color:#E1E4E8\">{}) </span><span style=\"color:#B392F0\">ParseError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// errorExpected creates a ParseError with \"expected X, got Y\" format.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Parser</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">errorExpected</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">expected</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ParseError</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"algorithm-specification\">Algorithm Specification</h2>\n<h3 id=\"main-parse-dispatch\">Main Parse Dispatch</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: Parse\nINPUT: Parser p with token stream positioned at statement start\nOUTPUT: Statement AST or error\n\n1. IF current token is EOF:\n     RETURN error(&quot;unexpected end of input&quot;)\n\n2. SWITCH on current token:\n   CASE KEYWORD &quot;SELECT&quot;:\n     RETURN parseSelect()\n   \n   CASE KEYWORD &quot;INSERT&quot;:\n     RETURN parseInsert()\n   \n   CASE KEYWORD &quot;UPDATE&quot;:\n     RETURN parseUpdate()\n   \n   CASE KEYWORD &quot;DELETE&quot;:\n     RETURN parseDelete()\n   \n   CASE KEYWORD &quot;CREATE&quot;:\n     RETURN parseCreate()\n   \n   CASE KEYWORD &quot;DROP&quot;:\n     RETURN parseDrop()\n   \n   CASE KEYWORD &quot;BEGIN&quot;:\n     RETURN parseBegin()\n   \n   CASE KEYWORD &quot;COMMIT&quot;:\n     RETURN parseCommit()\n   \n   CASE KEYWORD &quot;ROLLBACK&quot;:\n     RETURN parseRollback()\n   \n   CASE KEYWORD &quot;PRAGMA&quot;:\n     RETURN parsePragma()\n   \n   CASE KEYWORD &quot;EXPLAIN&quot;:\n     RETURN parseExplain()\n   \n   DEFAULT:\n     RETURN error(&quot;unexpected token: %s&quot;, current.Value)\n\nPOST-CONDITION: Either a complete Statement is returned, or an error</code></pre></div>\n\n<h3 id=\"select-statement-parsing\">SELECT Statement Parsing</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-5.svg\" alt=\"AST Node Hierarchy\"></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: parseSelect\nPRE-CONDITION: Current token is KEYWORD &quot;SELECT&quot;\nPOST-CONDITION: Returns SelectStatement or error\n\n1. stmt := SelectStatement{Pos: current.Position}\n   advance()  // consume SELECT\n\n2. // Parse column list\n   stmt.Columns = parseColumnList()\n   IF error: RETURN error\n\n3. // Parse FROM clause (required for this implementation)\n   IF matchKeyword(&quot;FROM&quot;):\n     advance()  // consume FROM\n     IF current is not IDENTIFIER:\n       RETURN errorExpected(&quot;table name&quot;)\n     stmt.FromTable = current.Value\n     advance()\n     \n     // Optional table alias\n     IF matchKeyword(&quot;AS&quot;):\n       advance()\n       IF current is not IDENTIFIER:\n         RETURN errorExpected(&quot;alias name&quot;)\n       stmt.Alias = current.Value\n       advance()\n     ELSE IF current.Type == IDENTIFIER:\n       // Alias without AS\n       stmt.Alias = current.Value\n       advance()\n\n4. // Parse optional clauses in order\n   // WHERE clause\n   IF matchKeyword(&quot;WHERE&quot;):\n     advance()\n     stmt.Where = parseExpression()\n     IF error: RETURN error\n\n5. // GROUP BY clause\n   IF matchKeyword(&quot;GROUP&quot;):\n     advance()\n     IF NOT matchKeyword(&quot;BY&quot;):\n       RETURN errorExpected(&quot;BY&quot;)\n     advance()\n     stmt.GroupBy = parseExpressionList()\n     IF error: RETURN error\n\n6. // HAVING clause\n   IF matchKeyword(&quot;HAVING&quot;):\n     advance()\n     stmt.Having = parseExpression()\n     IF error: RETURN error\n\n7. // ORDER BY clause\n   IF matchKeyword(&quot;ORDER&quot;):\n     advance()\n     IF NOT matchKeyword(&quot;BY&quot;):\n       RETURN errorExpected(&quot;BY&quot;)\n     advance()\n     stmt.OrderBy = parseOrderByList()\n     IF error: RETURN error\n\n8. // LIMIT clause\n   IF matchKeyword(&quot;LIMIT&quot;):\n     advance()\n     IF current.Type != NUMBER:\n       RETURN errorExpected(&quot;number&quot;)\n     limit := parseInt(current.Value)\n     stmt.Limit = &amp;limit\n     advance()\n     \n     // Optional OFFSET\n     IF matchKeyword(&quot;OFFSET&quot;):\n       advance()\n       IF current.Type != NUMBER:\n         RETURN errorExpected(&quot;number&quot;)\n       offset := parseInt(current.Value)\n       stmt.Offset = &amp;offset\n       advance()\n\n9. // Optional trailing semicolon\n   IF current.Type == PUNCTUATION &amp;&amp; current.Value == &quot;;&quot;:\n     advance()\n\n10. RETURN stmt</code></pre></div>\n\n<h3 id=\"column-list-parsing\">Column List Parsing</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: parseColumnList\nPRE-CONDITION: Positioned after SELECT keyword\nPOST-CONDITION: Returns slice of ColumnSelection\n\n1. columns := empty list\n\n2. // Handle SELECT *\n   IF current.Type == OPERATOR &amp;&amp; current.Value == &quot;*&quot;:\n     advance()\n     columns.append(ColumnSelection{\n       Expression: StarExpression{}\n     })\n     RETURN columns\n\n3. // Parse column expressions\n   LOOP:\n     a. col := parseSelectColumn()\n        IF error: RETURN error\n        columns.append(col)\n     \n     b. IF current is comma:\n          advance()\n          CONTINUE LOOP\n        ELSE:\n          BREAK LOOP\n\n4. RETURN columns\n\nALGORITHM: parseSelectColumn\nPRE-CONDITION: Positioned at start of column expression\nPOST-CONDITION: Returns ColumnSelection\n\n1. // Handle table.* syntax\n   IF current is IDENTIFIER AND peek(1) is &quot;.&quot; AND peek(2) is &quot;*&quot;:\n     tableName := current.Value\n     advance() // consume identifier\n     advance() // consume &quot;.&quot;\n     advance() // consume &quot;*&quot;\n     RETURN ColumnSelection{\n       Expression: StarExpression{TableName: tableName}\n     }\n\n2. // Parse expression\n   expr := parseExpression()\n   IF error: RETURN error\n\n3. // Optional alias\n   alias := &quot;&quot;\n   IF matchKeyword(&quot;AS&quot;):\n     advance()\n     IF current is not IDENTIFIER:\n       RETURN errorExpected(&quot;alias&quot;)\n     alias = current.Value\n     advance()\n   ELSE IF current.Type == IDENTIFIER AND not a keyword:\n     // Alias without AS keyword\n     alias = current.Value\n     advance()\n\n4. RETURN ColumnSelection{Expression: expr, Alias: alias}</code></pre></div>\n\n<h3 id=\"insert-statement-parsing\">INSERT Statement Parsing</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: parseInsert\nPRE-CONDITION: Current token is KEYWORD &quot;INSERT&quot;\nPOST-CONDITION: Returns InsertStatement or error\n\n1. stmt := InsertStatement{Pos: current.Position}\n   advance()  // consume INSERT\n\n2. // Expect INTO keyword\n   IF NOT matchKeyword(&quot;INTO&quot;):\n     RETURN errorExpected(&quot;INTO&quot;)\n   advance()\n\n3. // Parse table name\n   IF current.Type != IDENTIFIER AND current.Type != QUOTED_ID:\n     RETURN errorExpected(&quot;table name&quot;)\n   stmt.Table = current.Value\n   advance()\n\n4. // Optional column list\n   IF current.Type == PUNCTUATION &amp;&amp; current.Value == &quot;(&quot;:\n     advance()\n     stmt.Columns = parseIdentifierList()\n     IF error: RETURN error\n     IF current.Type != PUNCTUATION || current.Value != &quot;)&quot;:\n       RETURN errorExpected(&quot;)&quot;)\n     advance()\n\n5. // Parse VALUES clause\n   IF NOT matchKeyword(&quot;VALUES&quot;):\n     RETURN errorExpected(&quot;VALUES&quot;)\n   advance()\n\n6. // Parse one or more value tuples\n   stmt.Values = empty list\n   LOOP:\n     a. IF current.Type != PUNCTUATION || current.Value != &quot;(&quot;:\n          RETURN errorExpected(&quot;(&quot;)\n        advance()\n     \n     b. values := parseExpressionList()\n        IF error: RETURN error\n        stmt.Values.append(values)\n     \n     c. IF current.Type != PUNCTUATION || current.Value != &quot;)&quot;:\n          RETURN errorExpected(&quot;)&quot;)\n        advance()\n     \n     d. IF current is comma:\n          advance()\n          CONTINUE LOOP\n        ELSE:\n          BREAK LOOP\n\n7. // Optional semicolon\n   IF current.Type == PUNCTUATION &amp;&amp; current.Value == &quot;;&quot;:\n     advance()\n\n8. RETURN stmt</code></pre></div>\n\n<h3 id=\"create-table-parsing\">CREATE TABLE Parsing</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: parseCreate\nPRE-CONDITION: Current token is KEYWORD &quot;CREATE&quot;\nPOST-CONDITION: Returns CreateTableStatement or error\n\n1. stmt := CreateTableStatement{Pos: current.Position}\n   advance()  // consume CREATE\n\n2. // Expect TABLE keyword\n   IF NOT matchKeyword(&quot;TABLE&quot;):\n     // Could be CREATE INDEX - delegate to parseCreateIndex\n     RETURN parseCreateIndex()\n   advance()\n\n3. // Optional IF NOT EXISTS\n   IF matchKeyword(&quot;IF&quot;):\n     advance()\n     IF NOT matchKeyword(&quot;NOT&quot;):\n       RETURN errorExpected(&quot;NOT&quot;)\n     advance()\n     IF NOT matchKeyword(&quot;EXISTS&quot;):\n       RETURN errorExpected(&quot;EXISTS&quot;)\n     advance()\n     stmt.IfNotExists = true\n\n4. // Parse table name\n   IF current.Type != IDENTIFIER AND current.Type != QUOTED_ID:\n     RETURN errorExpected(&quot;table name&quot;)\n   stmt.Table = current.Value\n   advance()\n\n5. // Expect opening parenthesis\n   IF current.Type != PUNCTUATION || current.Value != &quot;(&quot;:\n     RETURN errorExpected(&quot;(&quot;)\n   advance()\n\n6. // Parse column definitions and table constraints\n   stmt.Columns = empty list\n   stmt.Constraints = empty list\n   \n   LOOP:\n     a. // Check for table-level constraint\n        IF matchKeyword(&quot;PRIMARY&quot;) OR matchKeyword(&quot;UNIQUE&quot;) OR matchKeyword(&quot;FOREIGN&quot;) OR matchKeyword(&quot;CHECK&quot;):\n          constraint := parseTableConstraint()\n          IF error: RETURN error\n          stmt.Constraints.append(constraint)\n     \n     b. ELSE:\n          // Column definition\n          col := parseColumnDefinition()\n          IF error: RETURN error\n          stmt.Columns.append(col)\n     \n     c. IF current is comma:\n          advance()\n          CONTINUE LOOP\n        ELSE:\n          BREAK LOOP\n\n7. // Expect closing parenthesis\n   IF current.Type != PUNCTUATION || current.Value != &quot;)&quot;:\n     RETURN errorExpected(&quot;)&quot;)\n   advance()\n\n8. // Optional semicolon\n   IF current.Type == PUNCTUATION &amp;&amp; current.Value == &quot;;&quot;:\n     advance()\n\n9. RETURN stmt\n\nALGORITHM: parseColumnDefinition\nPRE-CONDITION: Positioned at column name identifier\nPOST-CONDITION: Returns ColumnDefinition\n\n1. col := ColumnDefinition{}\n\n2. // Column name\n   IF current.Type != IDENTIFIER AND current.Type != QUOTED_ID:\n     RETURN errorExpected(&quot;column name&quot;)\n   col.Name = current.Value\n   advance()\n\n3. // Data type\n   IF current.Type != KEYWORD:\n     RETURN errorExpected(&quot;data type&quot;)\n   col.Type = current.Value  // INTEGER, TEXT, REAL, BLOB\n   advance()\n\n4. // Column constraints\n   col.Constraints = empty list\n   LOOP:\n     IF matchKeyword(&quot;PRIMARY&quot;):\n       advance()\n       IF NOT matchKeyword(&quot;KEY&quot;):\n         RETURN errorExpected(&quot;KEY&quot;)\n       advance()\n       \n       // Optional AUTOINCREMENT\n       autoInc := false\n       IF matchKeyword(&quot;AUTOINCREMENT&quot;):\n         advance()\n         autoInc = true\n       \n       col.Constraints.append(PrimaryKeyConstraint{AutoIncrement: autoInc})\n     \n     ELSE IF matchKeyword(&quot;NOT&quot;):\n       advance()\n       IF NOT matchKeyword(&quot;NULL&quot;):\n         RETURN errorExpected(&quot;NULL&quot;)\n       advance()\n       col.Constraints.append(NotNullConstraint{})\n     \n     ELSE IF matchKeyword(&quot;UNIQUE&quot;):\n       advance()\n       col.Constraints.append(UniqueConstraint{})\n     \n     ELSE IF matchKeyword(&quot;DEFAULT&quot;):\n       advance()\n       defaultValue := parseExpression()\n       IF error: RETURN error\n       col.Constraints.append(DefaultConstraint{Value: defaultValue})\n     \n     ELSE IF matchKeyword(&quot;CHECK&quot;):\n       advance()\n       IF current.Type != PUNCTUATION || current.Value != &quot;(&quot;:\n         RETURN errorExpected(&quot;(&quot;)\n       advance()\n       checkExpr := parseExpression()\n       IF error: RETURN error\n       IF current.Type != PUNCTUATION || current.Value != &quot;)&quot;:\n         RETURN errorExpected(&quot;)&quot;)\n       advance()\n       col.Constraints.append(CheckConstraint{Expression: checkExpr})\n     \n     ELSE IF matchKeyword(&quot;REFERENCES&quot;):\n       advance()\n       refTable, refCol := parseReferences()\n       IF error: RETURN error\n       col.Constraints.append(ForeignKeyConstraint{\n         ReferencesTable: refTable,\n         ReferencesColumn: refCol,\n       })\n     \n     ELSE:\n       BREAK LOOP\n\n5. RETURN col</code></pre></div>\n\n<h3 id=\"expression-parsing-with-precedence-climbing\">Expression Parsing with Precedence Climbing</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-6.svg\" alt=\"Expression Precedence Parsing Algorithm\"></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: parseExpression\nINPUT: Parser p positioned at start of expression\nOUTPUT: Expression AST or error\n\n1. RETURN parseBinaryExpression(LowestPrecedence)\n\nALGORITHM: parseBinaryExpression\nINPUT: minPrec - minimum precedence for this level\nOUTPUT: Expression AST\n\n1. // Parse left operand (prefix expression)\n   left := parseUnaryExpression()\n   IF error: RETURN error\n\n2. // Loop while current token is a binary operator with sufficient precedence\n   LOOP:\n     a. IF current is NOT a binary operator:\n          BREAK LOOP\n     \n     b. op := current.Value\n        opInfo := precedenceTable[op]\n        IF opInfo.Precedence &lt; minPrec:\n          BREAK LOOP\n     \n     c. advance()  // consume operator\n     \n     d. // Parse right operand with higher precedence (for left-associativity)\n        // For right-associative operators, use &gt;= instead of &gt;\n        nextMinPrec := opInfo.Precedence + 1\n        right := parseBinaryExpression(nextMinPrec)\n        IF error: RETURN error\n     \n     e. left := BinaryExpression{\n          Operator: op,\n          Left: left,\n          Right: right,\n          Pos: left.Pos()\n        }\n\n3. RETURN left\n\nALGORITHM: parseUnaryExpression\nINPUT: Parser p\nOUTPUT: Expression AST\n\n1. // Handle unary NOT\n   IF matchKeyword(&quot;NOT&quot;):\n     pos := current.Position\n     advance()\n     operand := parseUnaryExpression()\n     IF error: RETURN error\n     RETURN UnaryExpression{\n       Operator: &quot;NOT&quot;,\n       Operand: operand,\n       Pos: pos\n     }\n\n2. // Handle unary minus (negative numbers)\n   IF current.Type == OPERATOR &amp;&amp; current.Value == &quot;-&quot;:\n     pos := current.Position\n     advance()\n     \n     // Check if followed by number - could be literal\n     IF current.Type == NUMBER:\n       value := parseNegativeNumber()\n       RETURN LiteralExpression{Value: value, Pos: pos}\n     \n     operand := parseUnaryExpression()\n     IF error: RETURN error\n     RETURN UnaryExpression{\n       Operator: &quot;-&quot;,\n       Operand: operand,\n       Pos: pos\n     }\n\n3. // Handle unary plus (no-op, but valid syntax)\n   IF current.Type == OPERATOR &amp;&amp; current.Value == &quot;+&quot;:\n     advance()\n     RETURN parseUnaryExpression()\n\n4. // Handle special expressions (IN, BETWEEN, IS NULL, LIKE)\n   left := parsePrimaryExpression()\n   IF error: RETURN error\n\n5. // Postfix operators\n   // [NOT] IN (...)\n   IF matchKeyword(&quot;NOT&quot;):\n     advance()\n     IF NOT matchKeyword(&quot;IN&quot;):\n       // Put back NOT - it's a separate NOT operator\n       p.pos--\n       p.current = p.tokens[p.pos]\n       RETURN left\n     // Fall through to IN handling\n     RETURN parseInExpression(left, true)\n   \n   IF matchKeyword(&quot;IN&quot;):\n     RETURN parseInExpression(left, false)\n   \n   // [NOT] BETWEEN ... AND ...\n   IF matchKeyword(&quot;BETWEEN&quot;):\n     RETURN parseBetweenExpression(left, false)\n   \n   // IS [NOT] NULL\n   IF matchKeyword(&quot;IS&quot;):\n     RETURN parseIsNullExpression(left)\n   \n   // [NOT] LIKE\n   IF matchKeyword(&quot;LIKE&quot;):\n     RETURN parseLikeExpression(left, false)\n\n6. RETURN left\n\nALGORITHM: parsePrimaryExpression\nINPUT: Parser p\nOUTPUT: Expression AST (atom)\n\n1. SWITCH on current token:\n\n   CASE PUNCTUATION &quot;(&quot;:\n     advance()\n     expr := parseExpression()\n     IF error: RETURN error\n     IF current.Type != PUNCTUATION || current.Value != &quot;)&quot;:\n       RETURN errorExpected(&quot;)&quot;)\n     advance()\n     RETURN ParenExpression{Expression: expr, Pos: expr.Pos()}\n\n   CASE NUMBER:\n     value, litType := parseNumberLiteral()\n     pos := current.Position\n     advance()\n     RETURN LiteralExpression{Value: value, Type: litType, Pos: pos}\n\n   CASE STRING:\n     pos := current.Position\n     value := current.Value\n     advance()\n     RETURN LiteralExpression{Value: value, Type: LiteralString, Pos: pos}\n\n   CASE KEYWORD &quot;NULL&quot;:\n     pos := current.Position\n     advance()\n     RETURN LiteralExpression{Value: nil, Type: LiteralNull, Pos: pos}\n\n   CASE KEYWORD &quot;TRUE&quot;:\n     pos := current.Position\n     advance()\n     RETURN LiteralExpression{Value: int64(1), Type: LiteralInteger, Pos: pos}\n\n   CASE KEYWORD &quot;FALSE&quot;:\n     pos := current.Position\n     advance()\n     RETURN LiteralExpression{Value: int64(0), Type: LiteralInteger, Pos: pos}\n\n   CASE OPERATOR &quot;*&quot;:\n     pos := current.Position\n     advance()\n     RETURN StarExpression{Pos: pos}\n\n   CASE IDENTIFIER or QUOTED_ID:\n     pos := current.Position\n     name := current.Value\n     advance()\n     \n     // Check for function call\n     IF current.Type == PUNCTUATION &amp;&amp; current.Value == &quot;(&quot;:\n       RETURN parseFunctionCall(name, pos)\n     \n     // Check for qualified name (table.column)\n     IF current.Type == PUNCTUATION &amp;&amp; current.Value == &quot;.&quot;:\n       advance()\n       IF current.Type != IDENTIFIER AND current.Type != QUOTED_ID:\n         RETURN errorExpected(&quot;column name&quot;)\n       colName := current.Value\n       advance()\n       RETURN IdentifierExpression{\n         TableName: name,\n         Name: colName,\n         Pos: pos\n       }\n     \n     RETURN IdentifierExpression{Name: name, Pos: pos}\n\n   DEFAULT:\n     RETURN errorExpected(&quot;expression&quot;)</code></pre></div>\n\n<h3 id=\"special-expression-parsing\">Special Expression Parsing</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: parseInExpression\nINPUT: left Expression, negated bool\nOUTPUT: InExpression\n\n1. advance()  // consume IN\n   IF current.Type != PUNCTUATION || current.Value != &quot;(&quot;:\n     RETURN errorExpected(&quot;(&quot;)\n   advance()\n\n2. values := parseExpressionList()\n   IF error: RETURN error\n\n3. IF current.Type != PUNCTUATION || current.Value != &quot;)&quot;:\n     RETURN errorExpected(&quot;)&quot;)\n   advance()\n\n4. RETURN InExpression{\n     Expression: left,\n     Values: values,\n     Negated: negated,\n     Pos: left.Pos()\n   }\n\nALGORITHM: parseBetweenExpression\nINPUT: left Expression, negated bool\nOUTPUT: BetweenExpression\n\n1. advance()  // consume BETWEEN\n   low := parseExpression()\n   IF error: RETURN error\n\n2. IF NOT matchKeyword(&quot;AND&quot;):\n     RETURN errorExpected(&quot;AND&quot;)\n   advance()\n\n3. high := parseExpression()\n   IF error: RETURN error\n\n4. RETURN BetweenExpression{\n     Expression: left,\n     Low: low,\n     High: high,\n     Negated: negated,\n     Pos: left.Pos()\n   }\n\nALGORITHM: parseIsNullExpression\nINPUT: left Expression\nOUTPUT: IsNullExpression\n\n1. advance()  // consume IS\n   \n2. negated := false\n   IF matchKeyword(&quot;NOT&quot;):\n     negated = true\n     advance()\n\n3. IF NOT matchKeyword(&quot;NULL&quot;):\n     RETURN errorExpected(&quot;NULL&quot;)\n   advance()\n\n4. RETURN IsNullExpression{\n     Expression: left,\n     Negated: negated,\n     Pos: left.Pos()\n   }\n\nALGORITHM: parseLikeExpression\nINPUT: left Expression, negated bool\nOUTPUT: LikeExpression\n\n1. advance()  // consume LIKE\n   pattern := parseExpression()\n   IF error: RETURN error\n\n2. RETURN LikeExpression{\n     Expression: left,\n     Pattern: pattern,\n     Negated: negated,\n     Pos: left.Pos()\n   }\n\nALGORITHM: parseFunctionCall\nINPUT: functionName string, pos Position\nOUTPUT: FunctionCallExpression\n\n1. advance()  // consume &quot;(&quot;\n\n2. distinct := false\n   IF matchKeyword(&quot;DISTINCT&quot;):\n     distinct = true\n     advance()\n\n3. // Handle COUNT(*) specially\n   IF current.Type == OPERATOR &amp;&amp; current.Value == &quot;*&quot;:\n     advance()\n     IF current.Type != PUNCTUATION || current.Value != &quot;)&quot;:\n       RETURN errorExpected(&quot;)&quot;)\n     advance()\n     RETURN FunctionCallExpression{\n       Name: functionName,\n       Args: []Expression{StarExpression{}},\n       Distinct: distinct,\n       Pos: pos\n     }\n\n4. // Parse arguments\n   args := empty list\n   IF current.Type != PUNCTUATION || current.Value != &quot;)&quot;:\n     args = parseExpressionList()\n     IF error: RETURN error\n\n5. IF current.Type != PUNCTUATION || current.Value != &quot;)&quot;:\n     RETURN errorExpected(&quot;)&quot;)\n   advance()\n\n6. RETURN FunctionCallExpression{\n     Name: functionName,\n     Args: args,\n     Distinct: distinct,\n     Pos: pos\n   }</code></pre></div>\n\n<hr>\n<h2 id=\"error-handling-matrix\">Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th>Error</th>\n<th>Detected By</th>\n<th>Recovery</th>\n<th>User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unexpected token</td>\n<td><code>expect()</code>, <code>expectType()</code></td>\n<td>Return ParseError with position and expected token</td>\n<td>Yes: &quot;expected &#39;FROM&#39;, got &#39;FORM&#39; at line 1, column 10&quot;</td>\n</tr>\n<tr>\n<td>Missing required clause</td>\n<td>Statement parsers</td>\n<td>Return ParseError indicating missing clause</td>\n<td>Yes: &quot;expected table name after FROM&quot;</td>\n</tr>\n<tr>\n<td>Invalid expression</td>\n<td><code>parsePrimaryExpression()</code></td>\n<td>Return ParseError at invalid token</td>\n<td>Yes: &quot;expected expression, got &#39;)&#39;&quot;</td>\n</tr>\n<tr>\n<td>Unmatched parentheses</td>\n<td>Expression parser</td>\n<td>Return ParseError at unmatched paren</td>\n<td>Yes: &quot;unmatched &#39;)&#39; at line 2, column 5&quot;</td>\n</tr>\n<tr>\n<td>Missing closing parenthesis</td>\n<td>Various list parsers</td>\n<td>Return ParseError at end of list</td>\n<td>Yes: &quot;expected &#39;)&#39; after column list&quot;</td>\n</tr>\n<tr>\n<td>Empty column list</td>\n<td><code>parseColumnList()</code></td>\n<td>Return ParseError at opening paren</td>\n<td>Yes: &quot;column list cannot be empty&quot;</td>\n</tr>\n<tr>\n<td>Invalid operator in expression</td>\n<td><code>parseBinaryExpression()</code></td>\n<td>Treat as end of expression, continue</td>\n<td>No: stops expression parsing, may cascade</td>\n</tr>\n<tr>\n<td>Unknown keyword in column type</td>\n<td><code>parseColumnDefinition()</code></td>\n<td>Accept any keyword, validate later</td>\n<td>No: type validation is semantic, not syntactic</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"implementation-sequence-with-checkpoints\">Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-parser-core-and-statement-dispatch-1-hour\">Phase 1: Parser Core and Statement Dispatch (1 hour)</h3>\n<p><strong>Files to create</strong>: <code>parser.go</code>, <code>errors.go</code>, <code>ast.go</code> (statement stubs)</p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Define <code>Parser</code> struct with token navigation</li>\n<li>Implement <code>NewParser</code>, <code>advance</code>, <code>expect</code>, <code>match</code>, <code>peek</code></li>\n<li>Implement <code>Parse</code> with dispatch on first keyword</li>\n<li>Define <code>Statement</code> interface and stub types</li>\n<li>Implement <code>ParseError</code> with position formatting</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should be able to create a parser and dispatch on keywords. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestParserDispatch</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (dispatches to correct parsers, errors on unknown)</span></span></code></pre></div>\n\n<h3 id=\"phase-2-select-statement-parsing-15-hours\">Phase 2: SELECT Statement Parsing (1.5 hours)</h3>\n<p><strong>Files to create</strong>: <code>select.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>parseSelect</code> skeleton</li>\n<li>Implement <code>parseColumnList</code> with <code>*</code> support</li>\n<li>Implement FROM clause parsing</li>\n<li>Implement WHERE clause parsing (using expression parser stub)</li>\n<li>Implement ORDER BY and LIMIT</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should be able to parse <code>SELECT * FROM users</code>. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestSelectBasic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (SELECT * FROM users parses to correct AST)</span></span></code></pre></div>\n\n<h3 id=\"phase-3-insert-statement-parsing-1-hour\">Phase 3: INSERT Statement Parsing (1 hour)</h3>\n<p><strong>Files to create</strong>: <code>insert.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>parseInsert</code></li>\n<li>Implement column list parsing</li>\n<li>Implement VALUES clause with multiple tuples</li>\n<li>Handle quoted identifiers for table names</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should be able to parse <code>INSERT INTO users VALUES (1, &#39;Alice&#39;)</code>. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestInsert</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (INSERT with and without column list)</span></span></code></pre></div>\n\n<h3 id=\"phase-4-create-table-parsing-15-hours\">Phase 4: CREATE TABLE Parsing (1.5 hours)</h3>\n<p><strong>Files to create</strong>: <code>create.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>parseCreate</code> with IF NOT EXISTS</li>\n<li>Implement <code>parseColumnDefinition</code></li>\n<li>Implement constraint parsing (PRIMARY KEY, NOT NULL, UNIQUE, DEFAULT)</li>\n<li>Implement table-level constraints</li>\n<li>Handle quoted identifiers for table/column names</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should be able to parse <code>CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT NOT NULL)</code>. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestCreateTable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (CREATE TABLE with constraints)</span></span></code></pre></div>\n\n<h3 id=\"phase-5-expression-parsing-with-precedence-climbing-2-hours\">Phase 5: Expression Parsing with Precedence Climbing (2 hours)</h3>\n<p><strong>Files to create</strong>: <code>expression.go</code>, <code>precedence.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Define precedence table</li>\n<li>Implement <code>parseExpression</code> entry point</li>\n<li>Implement <code>parseBinaryExpression</code> with precedence climbing</li>\n<li>Implement <code>parseUnaryExpression</code> (NOT, unary minus)</li>\n<li>Implement <code>parsePrimaryExpression</code> (atoms)</li>\n<li>Implement special expressions (IN, BETWEEN, IS NULL, LIKE)</li>\n<li>Implement function call parsing</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should pass the full test suite. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> ./parser</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: All tests PASS, including 15+ valid and 10+ invalid statements</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"test-specification\">Test Specification</h2>\n<h3 id=\"test-categories\">Test Categories</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// parser_test.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestSelectBasic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        input    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SelectStatement</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            input: </span><span style=\"color:#9ECBFF\">\"SELECT * FROM users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            expected: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">SelectStatement</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Columns:   []</span><span style=\"color:#B392F0\">ColumnSelection</span><span style=\"color:#E1E4E8\">{{Expression: </span><span style=\"color:#B392F0\">StarExpression</span><span style=\"color:#E1E4E8\">{}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                FromTable: </span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            input: </span><span style=\"color:#9ECBFF\">\"SELECT id, name FROM users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            expected: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">SelectStatement</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Columns: []</span><span style=\"color:#B392F0\">ColumnSelection</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    {Expression: </span><span style=\"color:#B392F0\">IdentifierExpression</span><span style=\"color:#E1E4E8\">{Name: </span><span style=\"color:#9ECBFF\">\"id\"</span><span style=\"color:#E1E4E8\">}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    {Expression: </span><span style=\"color:#B392F0\">IdentifierExpression</span><span style=\"color:#E1E4E8\">{Name: </span><span style=\"color:#9ECBFF\">\"name\"</span><span style=\"color:#E1E4E8\">}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                FromTable: </span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... test execution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestSelectWithWhere</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        input       </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expectWhere </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // Stringified WHERE clause</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"SELECT * FROM users WHERE id = 1\"</span><span style=\"color:#E1E4E8\">, expectWhere: </span><span style=\"color:#9ECBFF\">\"id = 1\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"SELECT * FROM users WHERE age > 18\"</span><span style=\"color:#E1E4E8\">, expectWhere: </span><span style=\"color:#9ECBFF\">\"age > 18\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"SELECT * FROM users WHERE active = 1 AND role = 'admin'\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">         expectWhere: </span><span style=\"color:#9ECBFF\">\"active = 1 AND role = 'admin'\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestSelectWithOrderByLimit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    input </span><span style=\"color:#F97583\">:=</span><span style=\"color:#9ECBFF\"> \"SELECT * FROM users ORDER BY name DESC LIMIT 10 OFFSET 5\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stmt, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> parse</span><span style=\"color:#E1E4E8\">(input)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    selectStmt </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> stmt.(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SelectStatement</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Len</span><span style=\"color:#E1E4E8\">(t, selectStmt.OrderBy, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">True</span><span style=\"color:#E1E4E8\">(t, selectStmt.OrderBy[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].Descending)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">selectStmt.Limit)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">selectStmt.Offset)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestInsert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        input    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">InsertStatement</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            input: </span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (1, 'Alice')\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            expected: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">InsertStatement</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Table: </span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Values: [][]</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    {</span><span style=\"color:#B392F0\">Literal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#B392F0\">Literal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Alice\"</span><span style=\"color:#E1E4E8\">)},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            input: </span><span style=\"color:#9ECBFF\">\"INSERT INTO users (id, name) VALUES (1, 'Alice')\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            expected: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">InsertStatement</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Table:   </span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Columns: []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"id\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"name\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Values: [][]</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    {</span><span style=\"color:#B392F0\">Literal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#B392F0\">Literal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Alice\"</span><span style=\"color:#E1E4E8\">)},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            input: </span><span style=\"color:#9ECBFF\">\"INSERT INTO logs VALUES (1, 'a'), (2, 'b')\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            expected: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">InsertStatement</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Table: </span><span style=\"color:#9ECBFF\">\"logs\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Values: [][]</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    {</span><span style=\"color:#B392F0\">Literal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#B392F0\">Literal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"a\"</span><span style=\"color:#E1E4E8\">)},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    {</span><span style=\"color:#B392F0\">Literal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#B392F0\">Literal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"b\"</span><span style=\"color:#E1E4E8\">)},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestCreateTable</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        input    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CreateTableStatement</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            input: </span><span style=\"color:#9ECBFF\">\"CREATE TABLE users (id INTEGER, name TEXT)\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            expected: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">CreateTableStatement</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Table: </span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Columns: []</span><span style=\"color:#B392F0\">ColumnDefinition</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    {Name: </span><span style=\"color:#9ECBFF\">\"id\"</span><span style=\"color:#E1E4E8\">, Type: </span><span style=\"color:#9ECBFF\">\"INTEGER\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    {Name: </span><span style=\"color:#9ECBFF\">\"name\"</span><span style=\"color:#E1E4E8\">, Type: </span><span style=\"color:#9ECBFF\">\"TEXT\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            input: </span><span style=\"color:#9ECBFF\">\"CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY)\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            expected: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">CreateTableStatement</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Table:       </span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                IfNotExists: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Columns: []</span><span style=\"color:#B392F0\">ColumnDefinition</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    {Name: </span><span style=\"color:#9ECBFF\">\"id\"</span><span style=\"color:#E1E4E8\">, Type: </span><span style=\"color:#9ECBFF\">\"INTEGER\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                     Constraints: []</span><span style=\"color:#B392F0\">ColumnConstraint</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#B392F0\">PrimaryKeyConstraint</span><span style=\"color:#E1E4E8\">{}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            input: </span><span style=\"color:#9ECBFF\">\"CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL)\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            expected: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">CreateTableStatement</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Table: </span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Columns: []</span><span style=\"color:#B392F0\">ColumnDefinition</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    {Name: </span><span style=\"color:#9ECBFF\">\"id\"</span><span style=\"color:#E1E4E8\">, Type: </span><span style=\"color:#9ECBFF\">\"INTEGER\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                     Constraints: []</span><span style=\"color:#B392F0\">ColumnConstraint</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#B392F0\">PrimaryKeyConstraint</span><span style=\"color:#E1E4E8\">{AutoIncrement: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    {Name: </span><span style=\"color:#9ECBFF\">\"name\"</span><span style=\"color:#E1E4E8\">, Type: </span><span style=\"color:#9ECBFF\">\"TEXT\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                     Constraints: []</span><span style=\"color:#B392F0\">ColumnConstraint</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#B392F0\">NotNullConstraint</span><span style=\"color:#E1E4E8\">{}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestExpressionPrecedence</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        input    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // Stringified AST showing tree structure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // AND binds tighter than OR</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"a OR b AND c\"</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#9ECBFF\">\"OR(a, AND(b, c))\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // NOT binds tighter than comparison</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"NOT a = b\"</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#9ECBFF\">\"NOT(=(a, b))\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Comparison binds tighter than AND</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"a = b AND c = d\"</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#9ECBFF\">\"AND(=(a, b), =(c, d))\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Parentheses override precedence</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"(a OR b) AND c\"</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#9ECBFF\">\"AND(OR(a, b), c)\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Nested parentheses</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"((a))\"</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#9ECBFF\">\"a\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Complex expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"a = 1 OR b = 2 AND c > 3\"</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#9ECBFF\">\"OR(=(a, 1), AND(=(b, 2), >(c, 3)))\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestSpecialExpressions</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        input    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // IN</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"id IN (1, 2, 3)\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">         expected: </span><span style=\"color:#B392F0\">InExpression</span><span style=\"color:#E1E4E8\">{Expression: </span><span style=\"color:#B392F0\">Id</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"id\"</span><span style=\"color:#E1E4E8\">), Values: []</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#B392F0\">Lit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#B392F0\">Lit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#B392F0\">Lit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">)}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // NOT IN</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"id NOT IN (1, 2, 3)\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">         expected: </span><span style=\"color:#B392F0\">InExpression</span><span style=\"color:#E1E4E8\">{Expression: </span><span style=\"color:#B392F0\">Id</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"id\"</span><span style=\"color:#E1E4E8\">), Values: []</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#B392F0\">Lit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#B392F0\">Lit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#B392F0\">Lit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">)}, Negated: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // BETWEEN</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"age BETWEEN 18 AND 65\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">         expected: </span><span style=\"color:#B392F0\">BetweenExpression</span><span style=\"color:#E1E4E8\">{Expression: </span><span style=\"color:#B392F0\">Id</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"age\"</span><span style=\"color:#E1E4E8\">), Low: </span><span style=\"color:#B392F0\">Lit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">18</span><span style=\"color:#E1E4E8\">), High: </span><span style=\"color:#B392F0\">Lit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">65</span><span style=\"color:#E1E4E8\">)}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // IS NULL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"name IS NULL\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">         expected: </span><span style=\"color:#B392F0\">IsNullExpression</span><span style=\"color:#E1E4E8\">{Expression: </span><span style=\"color:#B392F0\">Id</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"name\"</span><span style=\"color:#E1E4E8\">)}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // IS NOT NULL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"name IS NOT NULL\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">         expected: </span><span style=\"color:#B392F0\">IsNullExpression</span><span style=\"color:#E1E4E8\">{Expression: </span><span style=\"color:#B392F0\">Id</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"name\"</span><span style=\"color:#E1E4E8\">), Negated: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // LIKE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"email LIKE '%@example.com'\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">         expected: </span><span style=\"color:#B392F0\">LikeExpression</span><span style=\"color:#E1E4E8\">{Expression: </span><span style=\"color:#B392F0\">Id</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"email\"</span><span style=\"color:#E1E4E8\">), Pattern: </span><span style=\"color:#B392F0\">Lit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"%@example.com\"</span><span style=\"color:#E1E4E8\">)}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestFunctionCalls</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        input    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"COUNT(*)\"</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#B392F0\">FunctionCallExpression</span><span style=\"color:#E1E4E8\">{Name: </span><span style=\"color:#9ECBFF\">\"COUNT\"</span><span style=\"color:#E1E4E8\">, Args: []</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#B392F0\">StarExpression</span><span style=\"color:#E1E4E8\">{}}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"SUM(amount)\"</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#B392F0\">FunctionCallExpression</span><span style=\"color:#E1E4E8\">{Name: </span><span style=\"color:#9ECBFF\">\"SUM\"</span><span style=\"color:#E1E4E8\">, Args: []</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#B392F0\">Id</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"amount\"</span><span style=\"color:#E1E4E8\">)}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"COUNT(DISTINCT user_id)\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">         expected: </span><span style=\"color:#B392F0\">FunctionCallExpression</span><span style=\"color:#E1E4E8\">{Name: </span><span style=\"color:#9ECBFF\">\"COUNT\"</span><span style=\"color:#E1E4E8\">, Args: []</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#B392F0\">Id</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"user_id\"</span><span style=\"color:#E1E4E8\">)}, Distinct: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestErrorCases</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        input       </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expectError </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        errorContains </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"SELECT\"</span><span style=\"color:#E1E4E8\">, expectError: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, errorContains: </span><span style=\"color:#9ECBFF\">\"expected expression\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"SELECT * FROM\"</span><span style=\"color:#E1E4E8\">, expectError: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, errorContains: </span><span style=\"color:#9ECBFF\">\"expected table name\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"SELECT * FORM users\"</span><span style=\"color:#E1E4E8\">, expectError: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, errorContains: </span><span style=\"color:#9ECBFF\">\"expected 'FROM'\"</span><span style=\"color:#E1E4E8\">},  </span><span style=\"color:#6A737D\">// FORM vs FROM</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"INSERT INTO users (\"</span><span style=\"color:#E1E4E8\">, expectError: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, errorContains: </span><span style=\"color:#9ECBFF\">\"expected identifier\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"INSERT INTO users (id\"</span><span style=\"color:#E1E4E8\">, expectError: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, errorContains: </span><span style=\"color:#9ECBFF\">\"expected ')'\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"CREATE TABLE users (id\"</span><span style=\"color:#E1E4E8\">, expectError: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, errorContains: </span><span style=\"color:#9ECBFF\">\"expected ')'\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"SELECT * FROM users WHERE (\"</span><span style=\"color:#E1E4E8\">, expectError: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, errorContains: </span><span style=\"color:#9ECBFF\">\"expected expression\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">\"SELECT * FROM users WHERE (id = 1\"</span><span style=\"color:#E1E4E8\">, expectError: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, errorContains: </span><span style=\"color:#9ECBFF\">\"expected ')'\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestQuotedIdentifiers</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        input    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">`SELECT * FROM \"Order Details\"`</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#9ECBFF\">\"Order Details\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">`CREATE TABLE \"Users Table\" (id INTEGER)`</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#9ECBFF\">\"Users Table\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {input: </span><span style=\"color:#9ECBFF\">`SELECT \"Column Name\" FROM users`</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#9ECBFF\">\"Column Name\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestComplexStatements</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 15+ valid statements</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    validStatements </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT id, name FROM users WHERE age > 18\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM users WHERE active = 1 AND role = 'admin'\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM users WHERE (a = 1 OR b = 2) AND c = 3\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM users ORDER BY name\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM users ORDER BY name DESC LIMIT 10\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM users LIMIT 10 OFFSET 5\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM users WHERE active = 1 ORDER BY created_at DESC LIMIT 5\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"INSERT INTO users VALUES (1, 'Alice')\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"INSERT INTO users (id, name) VALUES (1, 'Alice')\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"INSERT INTO logs (message, level) VALUES ('Error', 'high'), ('Warning', 'medium')\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"CREATE TABLE users (id INTEGER, name TEXT)\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT NOT NULL)\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"CREATE TABLE users (id INTEGER, email TEXT UNIQUE)\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        `CREATE TABLE \"Order Items\" (id INTEGER, qty INTEGER NOT NULL)`</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT COUNT(*) FROM users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT status, COUNT(*) FROM orders GROUP BY status\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM users WHERE id IN (1, 2, 3)\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM users WHERE created_at BETWEEN '2024-01-01' AND '2024-12-31'\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM users WHERE name IS NULL\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 10+ invalid statements</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    invalidStatements </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FORM users\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Misspelled FROM</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"INSERT INTO users (\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"INSERT INTO users VALUES (1, 'Alice'\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Missing closing paren</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"CREATE TABLE users (\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"CREATE TABLE users (id INTEGER\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Missing closing paren</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM users WHERE (\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM users WHERE ()\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Empty parens</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT * FROM WHERE id = 1\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Missing table name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, stmt </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> validStatements {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> parse</span><span style=\"color:#E1E4E8\">(stmt)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err, </span><span style=\"color:#9ECBFF\">\"Expected valid: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, stmt)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, stmt </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> invalidStatements {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> parse</span><span style=\"color:#E1E4E8\">(stmt)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        assert.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(t, err, </span><span style=\"color:#9ECBFF\">\"Expected invalid: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, stmt)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestPositionTracking</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    input </span><span style=\"color:#F97583\">:=</span><span style=\"color:#9ECBFF\"> \"SELECT *</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">FROM users</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">WHERE id = 1\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stmt, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> parse</span><span style=\"color:#E1E4E8\">(input)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    selectStmt </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> stmt.(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SelectStatement</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, selectStmt.Pos.Line)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, selectStmt.Pos.Column)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // WHERE clause should be on line 3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    where </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> selectStmt.Where.(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BinaryExpression</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, where.Pos.Line)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-targets\">Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Target</th>\n<th>How to Measure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Parse 15 valid statements</td>\n<td>&lt; 10ms total</td>\n<td><code>go test -bench=BenchmarkParseValid</code></td>\n</tr>\n<tr>\n<td>Parse 10 invalid statements</td>\n<td>&lt; 5ms total</td>\n<td><code>go test -bench=BenchmarkParseInvalid</code></td>\n</tr>\n<tr>\n<td>Single statement parse</td>\n<td>O(n) in token count</td>\n<td>Code review: verify no backtracking</td>\n</tr>\n<tr>\n<td>Memory per 1000-token AST</td>\n<td>&lt; 500KB</td>\n<td><code>go test -memprofile</code></td>\n</tr>\n<tr>\n<td>Error reporting</td>\n<td>100% with position</td>\n<td>All errors include line/column</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"synced-criteria\">Synced Criteria</h2>\n<p>}]</p>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-sqlite-m3 -->\n<h1 id=\"technical-design-specification-bytecode-compiler-vdbe\">Technical Design Specification: Bytecode Compiler (VDBE)</h1>\n<h2 id=\"module-charter\">Module Charter</h2>\n<p>The Bytecode Compiler transforms parsed SQL ASTs into executable bytecode programs for the Virtual Database Engine (VDBE). It implements a register-based instruction set with opcodes for table operations (OpenTable, Close, Rewind, Column, Next), data manipulation (Insert, Delete, MakeRecord), control flow (Goto, Halt, conditional jumps), and expression evaluation (Integer, String8, Null, comparisons). The compiler performs register allocation, manages jump target patching for loops and conditionals, and produces linear instruction sequences optimized for VDBE execution. It does NOT execute queries, manage storage, or perform query optimization—it produces bytecode that the VM interprets. Upstream dependencies: Parser (consumes AST). Downstream dependencies: VDBE Virtual Machine (executes bytecode). Invariants: every emitted instruction has valid opcode and register references; all forward jump targets are patched before program returns; register allocation never overlaps active values; the final instruction is always Halt.</p>\n<hr>\n<h2 id=\"file-structure\">File Structure</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>compiler/\n├── instruction.go      # (1) Instruction struct and opcode definitions\n├── compiler.go         # (2) Compiler struct and entry point\n├── select.go           # (3) SELECT statement compilation\n├── insert.go           # (4) INSERT statement compilation\n├── update.go           # (5) UPDATE statement compilation\n├── delete.go           # (6) DELETE statement compilation\n├── create.go           # (7) CREATE TABLE/INDEX compilation\n├── expression.go       # (8) Expression to bytecode compilation\n├── register.go         # (9) Register allocator\n├── jumps.go            # (10) Jump target patching utilities\n├── explain.go          # (11) EXPLAIN output formatter\n├── compiler_test.go    # (12) Test suite\n└── vm/\n    ├── vm.go           # (13) Virtual machine execution loop\n    ├── value.go        # (14) Value types and operations\n    ├── cursor.go       # (15) Cursor abstraction\n    └── opcodes.go      # (16) Opcode handler implementations</code></pre></div>\n\n<hr>\n<h2 id=\"complete-data-model\">Complete Data Model</h2>\n<h3 id=\"instruction-structure\">Instruction Structure</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// instruction.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Opcode</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Table operations</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpOpenTable</span><span style=\"color:#B392F0\"> Opcode</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpOpenIndex</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpClose</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Cursor movement</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpRewind</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpNext</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpPrev</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpSeekRowid</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpSeekGe</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpSeekGt</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpSeekLe</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpSeekLt</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Column access</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpColumn</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpRowid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Output</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpResultRow</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Record operations</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpMakeRecord</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpInsert</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpDelete</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Data loading</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpInteger</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpInt64</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpReal</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpString8</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpNull</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpBlob</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Comparison</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpEq</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpNe</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpLt</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpLe</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpGt</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpGe</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Control flow</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpGoto</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpGosub</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpReturn</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpHalt</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpIf</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpIfNot</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpIfNull</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpNot</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Arithmetic</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpAdd</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpSubtract</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpMultiply</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpDivide</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpRemainder</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpConcat</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Aggregates</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpAggStep</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpAggFinal</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpAggContextPush</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpAggContextPop</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Sorter (ORDER BY)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpSorterOpen</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpSorterInsert</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpSorterSort</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpSorterData</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpSorterNext</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Transaction</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpTransaction</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpAutoCommit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Schema</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpTableLock</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Utility</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpNoop</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OpExplain</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">op </span><span style=\"color:#B392F0\">Opcode</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> op {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpOpenTable: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"OpenTable\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpOpenIndex: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"OpenIndex\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpClose: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"Close\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpRewind: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"Rewind\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpNext: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"Next\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpColumn: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"Column\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpResultRow: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"ResultRow\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpMakeRecord: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"MakeRecord\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpInsert: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"Insert\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpDelete: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"Delete\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpInteger: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"Integer\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpString8: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"String8\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpNull: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"Null\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpEq: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"Eq\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpNe: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"Ne\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpLt: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"Lt\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpLe: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"Le\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpGt: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"Gt\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpGe: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"Ge\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpGoto: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"Goto\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpHalt: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"Halt\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpIf: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"If\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpIfNot: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"IfNot\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> OpRowid: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"Rowid\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... all others</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Opcode(</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)\"</span><span style=\"color:#E1E4E8\">, op)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Instruction</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Opcode   </span><span style=\"color:#B392F0\">Opcode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    P1       </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">         // First parameter (often cursor#, register#, or value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    P2       </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">         // Second parameter (often jump target or column#)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    P3       </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">         // Third parameter (often register#)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    P4       </span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#6A737D\">// Optional: string, int64, float64, or byte[]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Comment  </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">      // Human-readable description for EXPLAIN</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY each field exists:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Opcode: Dispatches to the correct VM handler</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - P1: Primary operand (cursor number, source register, integer value)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - P2: Secondary operand (jump target, column index, destination register)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - P3: Tertiary operand (comparison register, record count)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - P4: Variable-size operand (strings, large integers, blobs)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Comment: Enables EXPLAIN output for debugging</span></span></code></pre></div>\n\n<h3 id=\"compiler-state\">Compiler State</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// compiler.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Compiler</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Input</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ast         </span><span style=\"color:#B392F0\">Statement</span><span style=\"color:#6A737D\">      // Parsed AST to compile</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    schema      </span><span style=\"color:#B392F0\">Schema</span><span style=\"color:#6A737D\">         // Database schema for validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Output</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    program     []</span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#6A737D\">  // Emitted bytecode program</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Register allocation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nextReg     </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">            // Next available register number</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxReg      </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">            // Highest register used</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Cursor allocation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nextCursor  </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">            // Next available cursor number</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Jump patching</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    jumpPatches []</span><span style=\"color:#B392F0\">JumpPatch</span><span style=\"color:#6A737D\">    // Forward references to patch</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Loop tracking (for break/continue in future)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    loopStack   []</span><span style=\"color:#B392F0\">LoopInfo</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Error collection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    errors      []</span><span style=\"color:#B392F0\">CompileError</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> JumpPatch</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InstrIndex </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">    // Index in program of instruction needing patch</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TargetName </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // Symbolic name of target (e.g., \"loop_start\", \"halt\")</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LoopInfo</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StartAddr   </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">  // Address of loop start (Rewind)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EndAddr     </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">  // Address of loop end (after Next)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ContinueAddr </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\"> // Address for continue (Next instruction)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CompileError</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Message </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pos     </span><span style=\"color:#B392F0\">Position</span><span style=\"color:#6A737D\">  // AST node position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#B392F0\">CompileError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"compile error at line </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, column </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        e.Pos.Line, e.Pos.Column, e.Message)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Invariants:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - nextReg always points to an unused register</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - All jumpPatches are resolved before Compile() returns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - program always ends with Halt instruction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Cursor numbers are unique within a program</span></span></code></pre></div>\n\n<h3 id=\"register-allocator\">Register Allocator</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// register.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RegisterAllocator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nextReg    </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxReg     </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    allocated  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">  // Currently allocated registers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    freed      []</span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">         // Registers available for reuse</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ra </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RegisterAllocator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Allocate</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Reuse freed register if available</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(ra.freed) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        reg </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ra.freed[</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(ra.freed)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ra.freed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ra.freed[:</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(ra.freed)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ra.allocated[reg] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> reg</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate new register</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    reg </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ra.nextReg</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ra.nextReg</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> reg </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> ra.maxReg {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ra.maxReg </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> reg</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ra.allocated[reg] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> reg</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ra </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RegisterAllocator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Free</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">reg</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> ra.allocated[reg] {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        delete</span><span style=\"color:#E1E4E8\">(ra.allocated, reg)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ra.freed </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(ra.freed, reg)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ra </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RegisterAllocator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AllocateRange</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">count</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate contiguous range of registers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ra.nextReg</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ra.nextReg </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> count</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> ra.nextReg</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> ></span><span style=\"color:#E1E4E8\"> ra.maxReg {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ra.maxReg </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ra.nextReg </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> start</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"vm-value-types\">VM Value Types</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// vm/value.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ValueType</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ValueNull</span><span style=\"color:#B392F0\"> ValueType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ValueInteger</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ValueReal</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ValueText</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ValueBlob</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type  </span><span style=\"color:#B392F0\">ValueType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Int   </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Float </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Str   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Bytes []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">v </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsNull</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> v.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ValueNull</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">v </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsTruthy</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For WHERE clause filtering</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Only non-zero, non-NULL values are truthy</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> v.Type {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueNull:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueInteger:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> v.Int </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueReal:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> v.Float </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueText:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(v.Str) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueBlob:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(v.Bytes) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">v </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Compare</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">other</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Returns -1, 0, or 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // NULL comparisons return 2 (incomparable)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> v.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ValueNull </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> other.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ValueNull {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Type coercion for comparison</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> v.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ValueReal </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> other.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ValueReal {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lv </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> v.</span><span style=\"color:#B392F0\">toFloat</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rv </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> other.</span><span style=\"color:#B392F0\">toFloat</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> lv </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> rv {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> lv </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> rv {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Integer comparison</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> v.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ValueInteger </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> other.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ValueInteger {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> v.Int </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> other.Int {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> v.Int </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> other.Int {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Text comparison</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> v.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ValueText </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> other.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ValueText {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> v.Str </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> other.Str {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> v.Str </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> other.Str {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">v </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">toFloat</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> v.Type {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueInteger:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(v.Int)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueReal:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> v.Float</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"virtual-machine-state\">Virtual Machine State</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// vm/vm.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> VM</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Program</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Program    []</span><span style=\"color:#B392F0\">Instruction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PC         </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">           // Program counter (instruction index)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Registers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Registers  []</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#6A737D\">       // Register file</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Cursors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Cursors    [</span><span style=\"color:#B392F0\">MAX_CURSORS</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Cursor</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Execution state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Halted     </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ErrorCode  </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ErrorMsg   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Output callback</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Output     </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Storage interface</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Storage    </span><span style=\"color:#B392F0\">StorageEngine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Transaction state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InTransaction </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WriteCount    </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> MAX_CURSORS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 100</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> MAX_REGISTERS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1000</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Cursor</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID         </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TableRoot  </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IsIndex    </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PageID     </span><span style=\"color:#F97583\">uint32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CellIndex  </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AtEnd      </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Rowid      </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Record     []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> StorageEngine</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    OpenTable</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rootPage</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TableHandle</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    OpenIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rootPage</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexHandle</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageID</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"interface-contracts\">Interface Contracts</h2>\n<h3 id=\"compiler-entry-point\">Compiler Entry Point</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Compile transforms a parsed AST into a bytecode program.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parameters:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - ast: The root Statement node from the parser</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - schema: Database schema for table/column resolution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - []Instruction: Complete bytecode program ending with Halt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - error: CompileError if compilation fails</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Pre-conditions:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - ast is non-nil and valid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - schema contains all referenced tables</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Post-conditions:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - All forward jump targets are resolved</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Program ends with Halt instruction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Register allocation is complete (no gaps)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Error conditions:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Unknown table reference</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Unknown column reference</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Type mismatch in expressions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Register exhaustion</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> Compile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ast</span><span style=\"color:#B392F0\"> Statement</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">schema</span><span style=\"color:#B392F0\"> Schema</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h3 id=\"compiler-methods\">Compiler Methods</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// emit appends an instruction to the program and returns its index.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Compiler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">emit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">op</span><span style=\"color:#B392F0\"> Opcode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">p1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">p2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">p3</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">p4</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#FFAB70\">comment</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// emitJump emits a jump instruction with a symbolic target to be patched later.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Compiler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">emitJump</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">op</span><span style=\"color:#B392F0\"> Opcode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">p1</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">targetName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// patchJump resolves a forward reference to the current program position.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Compiler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">patchJump</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">instrIndex</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// patchJumpTo resolves a forward reference to a specific address.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Compiler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">patchJumpTo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">instrIndex</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">targetAddr</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// currentAddr returns the index of the next instruction to be emitted.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Compiler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">currentAddr</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// allocateRegister allocates and returns a new register number.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Compiler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">allocateRegister</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// allocateRegisters allocates a contiguous range of registers.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Compiler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">allocateRegisters</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">count</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// freeRegister marks a register as available for reuse.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Compiler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">freeRegister</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">reg</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// allocateCursor allocates and returns a new cursor number.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Compiler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">allocateCursor</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int</span></span></code></pre></div>\n\n<h3 id=\"vm-entry-point\">VM Entry Point</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Run executes the bytecode program until Halt or error.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - error: Execution error, or nil on success</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The Output callback is called for each ResultRow instruction.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">vm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VM</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Run</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Step executes a single instruction and returns.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Useful for debugging and interruptible execution.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">vm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VM</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Step</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Reset prepares the VM for re-execution with new parameters.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Preserves the program but clears registers and cursors.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">vm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VM</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Reset</span><span style=\"color:#E1E4E8\">()</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"algorithm-specification\">Algorithm Specification</h2>\n<h3 id=\"select-statement-compilation\">SELECT Statement Compilation</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-9.svg\" alt=\"Bytecode Instruction Format\"></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: compileSelect\nINPUT: SelectStatement AST\nOUTPUT: Bytecode program (appended to compiler.program)\n\n1. stmt := SelectStatement AST\n   cursor := allocateCursor()\n\n2. // Emit OpenTable instruction\n   rootPage := schema.GetTableRootPage(stmt.FromTable)\n   emit(OpOpenTable, cursor, rootPage, 0, nil, &quot;table=&quot; + stmt.FromTable)\n\n3. // Emit Rewind (position before first row)\n   rewindAddr := currentAddr()\n   emit(OpRewind, cursor, 0, 0, nil, &quot;jump to halt if empty&quot;)\n   // P2 will be patched to halt address after loop\n\n4. // Loop start marker for jump patching\n   loopStartAddr := currentAddr()\n\n5. // Compile WHERE clause (if present)\n   IF stmt.Where != nil:\n     a. condReg := compileExpression(stmt.Where)\n     b. // Jump to Next if condition is false/NULL\n        emit(OpIfNot, condReg, 0, 0, nil, &quot;skip row if WHERE false&quot;)\n        whereJumpIndex := last instruction index\n     c. freeRegister(condReg)\n\n6. // Compile column reads for projection\n   colStartReg := allocateRegisters(len(stmt.Columns))\n   FOR i, col := range stmt.Columns:\n     a. colIndex := schema.GetColumnIndex(stmt.FromTable, col.Name)\n     b. destReg := colStartReg + i\n     c. emit(OpColumn, cursor, colIndex, destReg, nil, \n             fmt.Sprintf(&quot;col=%s -&gt; r%d&quot;, col.Name, destReg))\n\n7. // Emit ResultRow to output the row\n   emit(OpResultRow, colStartReg, len(stmt.Columns), 0, nil, \n        fmt.Sprintf(&quot;output %d columns&quot;, len(stmt.Columns)))\n\n8. // Emit Next instruction (loop back)\n   emit(OpNext, cursor, loopStartAddr, 0, nil, &quot;loop back&quot;)\n   nextAddr := currentAddr() - 1  // Index of Next instruction\n\n9. // Emit Halt\n   haltAddr := currentAddr()\n   emit(OpHalt, 0, 0, 0, nil, &quot;end of query&quot;)\n\n10. // Patch forward references\n    a. Patch Rewind jump to haltAddr\n    b. IF stmt.Where != nil:\n         Patch WHERE jump to nextAddr (the Next instruction)\n\n11. // Emit Close (optional, for cleanup)\n    emit(OpClose, cursor, 0, 0, nil, &quot;&quot;)\n\nPOST-CONDITION: Program contains complete table scan with filtering</code></pre></div>\n\n<h3 id=\"insert-statement-compilation\">INSERT Statement Compilation</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: compileInsert\nINPUT: InsertStatement AST\nOUTPUT: Bytecode program\n\n1. stmt := InsertStatement AST\n   cursor := allocateCursor()\n\n2. // Open table\n   rootPage := schema.GetTableRootPage(stmt.Table)\n   emit(OpOpenTable, cursor, rootPage, 0, nil, &quot;table=&quot; + stmt.Table)\n\n3. // For each VALUES tuple\n   FOR _, valueTuple := range stmt.Values:\n     a. // Compile each value expression into registers\n        valueStartReg := allocateRegisters(len(valueTuple))\n        FOR i, valExpr := range valueTuple:\n          reg := compileExpression(valExpr)\n          IF reg != valueStartReg + i:\n            // Move to correct position\n            emit(OpCopy, reg, valueStartReg + i, 0, nil, &quot;&quot;)\n            freeRegister(reg)\n     \n     b. // Create record from values\n        recordReg := allocateRegister()\n        emit(OpMakeRecord, valueStartReg, len(valueTuple), recordReg, nil,\n             &quot;create record from values&quot;)\n     \n     c. // Get new rowid (auto-increment or explicit)\n        rowidReg := allocateRegister()\n        IF hasExplicitRowid(valueTuple):\n          rowidReg = getExplicitRowidReg()\n        ELSE:\n          emit(OpNewRowid, cursor, rowidReg, 0, nil, &quot;generate new rowid&quot;)\n     \n     d. // Insert the record\n        emit(OpInsert, cursor, recordReg, rowidReg, nil, &quot;insert record&quot;)\n     \n     e. // Free temporary registers\n        freeRegisters(valueStartReg, len(valueTuple))\n        freeRegister(recordReg)\n        freeRegister(rowidReg)\n\n4. // Close cursor\n   emit(OpClose, cursor, 0, 0, nil, &quot;&quot;)\n\n5. // Halt\n   emit(OpHalt, 0, 0, 0, nil, &quot;&quot;)\n\nPOST-CONDITION: Program inserts all value tuples</code></pre></div>\n\n<h3 id=\"expression-compilation\">Expression Compilation</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-10.svg\" alt=\"SELECT Compilation to Bytecode\"></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: compileExpression\nINPUT: Expression AST node\nOUTPUT: Register number containing result\n\n1. SWITCH on expression type:\n\n   CASE LiteralExpression:\n     a. resultReg := allocateRegister()\n     b. SWITCH on literal type:\n        CASE LiteralNull:\n          emit(OpNull, resultReg, 0, 0, nil, &quot;NULL&quot;)\n        CASE LiteralInteger:\n          IF value fits in P1 (32-bit signed):\n            emit(OpInteger, int(value), resultReg, 0, nil, fmt.Sprintf(&quot;r%d=%d&quot;, resultReg, value))\n          ELSE:\n            emit(OpInt64, 0, resultReg, 0, value, fmt.Sprintf(&quot;r%d=%d&quot;, resultReg, value))\n        CASE LiteralFloat:\n          emit(OpReal, 0, resultReg, 0, value, fmt.Sprintf(&quot;r%d=%f&quot;, resultReg, value))\n        CASE LiteralString:\n          emit(OpString8, 0, resultReg, 0, value, fmt.Sprintf(&quot;r%d=\\&quot;%s\\&quot;&quot;, resultReg, value))\n     c. RETURN resultReg\n\n   CASE IdentifierExpression:\n     a. // Column reference - already loaded by Column instruction\n        // For now, allocate and load from cursor\n        resultReg := allocateRegister()\n        colIndex := schema.GetColumnIndex(currentTable, expr.Name)\n        emit(OpColumn, currentCursor, colIndex, resultReg, nil,\n             fmt.Sprintf(&quot;load %s -&gt; r%d&quot;, expr.Name, resultReg))\n        RETURN resultReg\n\n   CASE BinaryExpression:\n     a. leftReg := compileExpression(expr.Left)\n     b. rightReg := compileExpression(expr.Right)\n     c. resultReg := allocateRegister()\n     d. SWITCH on operator:\n        CASE &quot;+&quot;:\n          emit(OpAdd, leftReg, rightReg, resultReg, nil, &quot;add&quot;)\n        CASE &quot;-&quot;:\n          emit(OpSubtract, leftReg, rightReg, resultReg, nil, &quot;subtract&quot;)\n        CASE &quot;*&quot;:\n          emit(OpMultiply, leftReg, rightReg, resultReg, nil, &quot;multiply&quot;)\n        CASE &quot;/&quot;:\n          emit(OpDivide, leftReg, rightReg, resultReg, nil, &quot;divide&quot;)\n        CASE &quot;||&quot;:\n          emit(OpConcat, leftReg, rightReg, resultReg, nil, &quot;concatenate&quot;)\n        CASE &quot;=&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&lt;=&quot;, &quot;&gt;=&quot;, &quot;!=&quot;, &quot;&lt;&gt;&quot;:\n          // Comparisons don't produce a value, they jump\n          // Return leftReg as the &quot;result&quot; for If/IfNot to test\n          emit(opcodeForComparison(expr.Operator), leftReg, 0, rightReg, nil,\n               fmt.Sprintf(&quot;compare %s&quot;, expr.Operator))\n          // Mark that this is a comparison result\n          RETURN leftReg  // Actually, comparisons set condition flags\n        CASE &quot;AND&quot;, &quot;OR&quot;:\n          // Logical operators compile to conditional jumps\n          RETURN compileLogicalExpression(expr)\n     e. freeRegister(leftReg)\n        freeRegister(rightReg)\n        RETURN resultReg\n\n   CASE UnaryExpression:\n     a. operandReg := compileExpression(expr.Operand)\n     b. SWITCH on operator:\n        CASE &quot;NOT&quot;:\n          emit(OpNot, operandReg, 0, 0, nil, &quot;logical NOT&quot;)\n          RETURN operandReg\n        CASE &quot;-&quot;:\n          resultReg := allocateRegister()\n          emit(OpInteger, 0, resultReg, 0, nil, &quot;zero&quot;)\n          emit(OpSubtract, resultReg, operandReg, resultReg, nil, &quot;negate&quot;)\n          freeRegister(operandReg)\n          RETURN resultReg\n\n   CASE FunctionCallExpression:\n     a. // Handle aggregate functions specially\n     b. // For now, just compile arguments\n     c. RETURN compileFunctionCall(expr)\n\n   DEFAULT:\n     error(&quot;unknown expression type: %T&quot;, expr)\n     RETURN -1\n\nPOST-CONDITION: Result is in returned register; caller owns the register</code></pre></div>\n\n<h3 id=\"where-clause-with-conditional-jumps\">WHERE Clause with Conditional Jumps</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-11.svg\" alt=\"VM Fetch-Decode-Execute Cycle\"></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: compileWhereClause\nINPUT: Expression (WHERE condition), jumpTarget (where to jump if false)\nOUTPUT: None (emits conditional jump instructions)\n\n1. expr := WHERE expression\n   jumpToNext := address to jump to when condition is false\n\n2. SWITCH on expression type:\n\n   CASE BinaryExpression with comparison operator:\n     a. leftReg := compileExpression(expr.Left)\n     b. rightReg := compileExpression(expr.Right)\n     c. // Emit comparison with jump-if-NOT-condition\n        // For &quot;age &gt; 18&quot;, jump to Next if age &lt;= 18\n        emit(negatedComparisonOpcode(expr.Operator), \n             leftReg, jumpToNext, rightReg, nil,\n             &quot;skip if NOT &quot; + expr.Operator)\n     d. freeRegister(leftReg)\n        freeRegister(rightReg)\n\n   CASE BinaryExpression with &quot;AND&quot;:\n     // AND: both must be true; short-circuit on first false\n     a. compileWhereClause(expr.Left, jumpToNext)\n     b. compileWhereClause(expr.Right, jumpToNext)\n\n   CASE BinaryExpression with &quot;OR&quot;:\n     // OR: at least one must be true\n     // If first is true, continue; if first is false, check second\n     a. // Label for &quot;first was true, continue&quot;\n        continueLabel := newLabel(&quot;or_continue&quot;)\n     b. // Check first condition; if true, jump to continue\n        compileCondition(expr.Left, continueLabel)\n     c. // First was false, check second; if false, jump to Next\n        compileWhereClause(expr.Right, jumpToNext)\n     d. // Continue label\n        defineLabel(continueLabel)\n\n   CASE UnaryExpression with &quot;NOT&quot;:\n     // NOT: invert the condition\n     a. compileCondition(expr.Operand, jumpToNext)  // Jump to Next if operand is TRUE\n\n   CASE ParenExpression:\n     a. compileWhereClause(expr.Expression, jumpToNext)\n\n   DEFAULT:\n     // General expression: evaluate and test truthiness\n     a. condReg := compileExpression(expr)\n     b. emit(OpIfNot, condReg, jumpToNext, 0, nil, &quot;skip if condition false/NULL&quot;)\n     c. freeRegister(condReg)\n\nPOST-CONDITION: Conditional jumps emitted; control flow correct</code></pre></div>\n\n<h3 id=\"vm-execution-loop\">VM Execution Loop</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-12.svg\" alt=\"Register Allocation for SELECT\"></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: VM.Run\nINPUT: VM with loaded program\nOUTPUT: Execution result (via Output callback)\n\n1. vm.Halted = false\n   vm.PC = 0\n\n2. WHILE NOT vm.Halted AND vm.PC &lt; len(vm.Program):\n     a. instr := vm.Program[vm.PC]\n     b. err := vm.executeInstruction(instr)\n     c. IF err != nil:\n          RETURN err\n\n3. RETURN nil\n\nALGORITHM: VM.executeInstruction\nINPUT: Instruction to execute\nOUTPUT: Error or nil\n\n1. instr := current instruction\n\n2. SWITCH on instr.Opcode:\n\n   CASE OpHalt:\n     vm.Halted = true\n     // Don't increment PC\n\n   CASE OpGoto:\n     vm.PC = instr.P2\n     RETURN nil  // Skip PC increment\n\n   CASE OpInteger:\n     vm.Registers[instr.P2] = Value{Type: ValueInteger, Int: int64(instr.P1)}\n\n   CASE OpString8:\n     vm.Registers[instr.P2] = Value{Type: ValueText, Str: instr.P4.(string)}\n\n   CASE OpNull:\n     vm.Registers[instr.P1] = Value{Type: ValueNull}\n\n   CASE OpOpenTable:\n     cursor := vm.Storage.OpenTable(uint32(instr.P2))\n     vm.Cursors[instr.P1] = &amp;Cursor{\n       ID:        instr.P1,\n       TableRoot: uint32(instr.P2),\n     }\n\n   CASE OpClose:\n     vm.Cursors[instr.P1] = nil\n\n   CASE OpRewind:\n     cursor := vm.Cursors[instr.P1]\n     IF cursor == nil:\n       RETURN error(&quot;cursor not open&quot;)\n     err := vm.rewindCursor(cursor)\n     IF err != nil OR cursor.AtEnd:\n       // Table is empty, jump to P2\n       vm.PC = instr.P2\n       RETURN nil\n\n   CASE OpNext:\n     cursor := vm.Cursors[instr.P1]\n     err := vm.advanceCursor(cursor)\n     IF err != nil OR cursor.AtEnd:\n       // No more rows, continue to next instruction\n       vm.PC++\n       RETURN nil\n     ELSE:\n       // More rows, jump to P2 (loop start)\n       vm.PC = instr.P2\n       RETURN nil\n\n   CASE OpColumn:\n     cursor := vm.Cursors[instr.P1]\n     value := vm.readColumn(cursor, instr.P2)\n     vm.Registers[instr.P3] = value\n\n   CASE OpResultRow:\n     row := make([]Value, instr.P2)\n     FOR i := 0; i &lt; instr.P2; i++:\n       row[i] = vm.Registers[instr.P1 + i]\n     IF vm.Output != nil:\n       err := vm.Output(row)\n       IF err != nil:\n         RETURN err\n\n   CASE OpMakeRecord:\n     // Serialize registers [P1, P1+P2-1] into a record\n     record := vm.serializeRecord(vm.Registers[instr.P1 : instr.P1+instr.P2])\n     vm.Registers[instr.P3] = Value{Type: ValueBlob, Bytes: record}\n\n   CASE OpInsert:\n     cursor := vm.Cursors[instr.P1]\n     record := vm.Registers[instr.P2].Bytes\n     rowid := vm.Registers[instr.P3].Int\n     err := vm.insertRecord(cursor, rowid, record)\n     IF err != nil:\n       RETURN err\n\n   CASE OpEq, OpNe, OpLt, OpLe, OpGt, OpGe:\n     left := vm.Registers[instr.P1]\n     right := vm.Registers[instr.P3]\n     result := left.Compare(right)\n     \n     shouldJump := false\n     SWITCH instr.Opcode:\n       CASE OpEq: shouldJump = (result == 0)\n       CASE OpNe: shouldJump = (result != 0 AND result != 2)  // Not equal and not NULL\n       CASE OpLt: shouldJump = (result == -1)\n       CASE OpLe: shouldJump = (result == -1 OR result == 0)\n       CASE OpGt: shouldJump = (result == 1)\n       CASE OpGe: shouldJump = (result == 1 OR result == 0)\n     \n     IF shouldJump:\n       vm.PC = instr.P2\n       RETURN nil\n\n   CASE OpIf:\n     IF vm.Registers[instr.P1].IsTruthy():\n       vm.PC = instr.P2\n       RETURN nil\n\n   CASE OpIfNot:\n     IF NOT vm.Registers[instr.P1].IsTruthy():\n       vm.PC = instr.P2\n       RETURN nil\n\n   CASE OpAdd:\n     left := vm.Registers[instr.P1].toFloat()\n     right := vm.Registers[instr.P2].toFloat()\n     vm.Registers[instr.P3] = Value{Type: ValueReal, Float: left + right}\n\n   CASE OpSubtract:\n     left := vm.Registers[instr.P1].toFloat()\n     right := vm.Registers[instr.P2].toFloat()\n     vm.Registers[instr.P3] = Value{Type: ValueReal, Float: left - right}\n\n   CASE OpMultiply:\n     left := vm.Registers[instr.P1].toFloat()\n     right := vm.Registers[instr.P2].toFloat()\n     vm.Registers[instr.P3] = Value{Type: ValueReal, Float: left * right}\n\n   CASE OpDivide:\n     left := vm.Registers[instr.P1].toFloat()\n     right := vm.Registers[instr.P2].toFloat()\n     IF right == 0:\n       vm.Registers[instr.P3] = Value{Type: ValueNull}\n     ELSE:\n       vm.Registers[instr.P3] = Value{Type: ValueReal, Float: left / right}\n\n   DEFAULT:\n     RETURN error(&quot;unknown opcode: %d&quot;, instr.Opcode)\n\n3. vm.PC++\n   RETURN nil\n\nPOST-CONDITION: Either Halted or PC advanced; registers/cursors updated</code></pre></div>\n\n<hr>\n<h2 id=\"error-handling-matrix\">Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th>Error</th>\n<th>Detected By</th>\n<th>Recovery</th>\n<th>User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unknown table</td>\n<td><code>compileSelect</code> during schema lookup</td>\n<td>Return CompileError immediately</td>\n<td>Yes: &quot;no such table: {name}&quot;</td>\n</tr>\n<tr>\n<td>Unknown column</td>\n<td><code>compileExpression</code> during column resolution</td>\n<td>Return CompileError immediately</td>\n<td>Yes: &quot;no such column: {table}.{name}&quot;</td>\n</tr>\n<tr>\n<td>Type mismatch</td>\n<td>Expression compiler</td>\n<td>Return CompileError with context</td>\n<td>Yes: &quot;cannot compare TEXT to INTEGER&quot;</td>\n</tr>\n<tr>\n<td>Register exhaustion</td>\n<td><code>allocateRegister</code></td>\n<td>Return CompileError when max exceeded</td>\n<td>Yes: &quot;too many registers required&quot;</td>\n</tr>\n<tr>\n<td>Unresolved jump target</td>\n<td><code>Compile</code> finalization</td>\n<td>Return CompileError with target name</td>\n<td>Yes: &quot;internal error: unresolved jump to {name}&quot;</td>\n</tr>\n<tr>\n<td>Division by zero</td>\n<td>VM <code>OpDivide</code> handler</td>\n<td>Store NULL in result register</td>\n<td>No: SQL semantics, returns NULL</td>\n</tr>\n<tr>\n<td>Cursor not open</td>\n<td>VM cursor operations</td>\n<td>Return execution error</td>\n<td>Yes: &quot;cursor {n} is not open&quot;</td>\n</tr>\n<tr>\n<td>Invalid instruction</td>\n<td>VM execution loop</td>\n<td>Return execution error</td>\n<td>Yes: &quot;invalid opcode at address {n}&quot;</td>\n</tr>\n<tr>\n<td>Output callback error</td>\n<td>VM <code>OpResultRow</code></td>\n<td>Propagate error, halt execution</td>\n<td>Yes: depends on callback</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"implementation-sequence-with-checkpoints\">Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-instruction-set-and-compiler-skeleton-2-hours\">Phase 1: Instruction Set and Compiler Skeleton (2 hours)</h3>\n<p><strong>Files to create</strong>: <code>instruction.go</code>, <code>compiler.go</code>, <code>register.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Define <code>Opcode</code> enum with all opcodes</li>\n<li>Define <code>Instruction</code> struct</li>\n<li>Define <code>Compiler</code> struct with register allocator</li>\n<li>Implement <code>emit</code>, <code>currentAddr</code>, <code>allocateRegister</code>, <code>allocateCursor</code></li>\n<li>Implement jump patching: <code>emitJump</code>, <code>patchJump</code>, <code>patchJumpTo</code></li>\n<li>Define <code>Value</code> type and basic operations</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should be able to emit a simple program. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestCompilerSkeleton</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (can emit and patch instructions)</span></span></code></pre></div>\n\n<h3 id=\"phase-2-select-compilation-2-hours\">Phase 2: SELECT Compilation (2 hours)</h3>\n<p><strong>Files to create</strong>: <code>select.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>compileSelect</code> skeleton</li>\n<li>Implement OpenTable, Rewind, Next, Column, ResultRow emission</li>\n<li>Implement loop structure with correct jump targets</li>\n<li>Implement column projection</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should be able to compile <code>SELECT * FROM users</code>. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestCompileSelect</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (SELECT produces correct bytecode structure)</span></span></code></pre></div>\n\n<h3 id=\"phase-3-insertupdatedelete-compilation-2-hours\">Phase 3: INSERT/UPDATE/DELETE Compilation (2 hours)</h3>\n<p><strong>Files to create</strong>: <code>insert.go</code>, <code>update.go</code>, <code>delete.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>compileInsert</code> with MakeRecord, Insert</li>\n<li>Implement <code>compileUpdate</code> with Column, MakeRecord, Insert (delete+insert)</li>\n<li>Implement <code>compileDelete</code> with Delete opcode</li>\n<li>Handle multiple VALUES tuples in INSERT</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should be able to compile INSERT statements. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestCompileInsert</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (INSERT produces correct bytecode)</span></span></code></pre></div>\n\n<h3 id=\"phase-4-where-clause-compilation-2-hours\">Phase 4: WHERE Clause Compilation (2 hours)</h3>\n<p><strong>Files to create</strong>: <code>expression.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>compileExpression</code> for literals</li>\n<li>Implement <code>compileExpression</code> for identifiers (column references)</li>\n<li>Implement <code>compileExpression</code> for binary operators</li>\n<li>Implement <code>compileWhereClause</code> with conditional jumps</li>\n<li>Implement comparison opcodes with negation</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should pass WHERE clause tests. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestCompileWhere</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (WHERE clauses produce correct jumps)</span></span></code></pre></div>\n\n<h3 id=\"phase-5-vm-execution-loop-2-hours\">Phase 5: VM Execution Loop (2 hours)</h3>\n<p><strong>Files to create</strong>: <code>vm/vm.go</code>, <code>vm/opcodes.go</code>, <code>vm/value.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>VM</code> struct with registers and cursors</li>\n<li>Implement <code>Run</code> main loop</li>\n<li>Implement opcode handlers: Halt, Goto, Integer, String8, Null</li>\n<li>Implement cursor opcodes: OpenTable, Rewind, Next, Column</li>\n<li>Implement output: ResultRow</li>\n<li>Implement record operations: MakeRecord, Insert</li>\n<li>Implement comparison opcodes</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should pass the full test suite. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> ./compiler</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> ./vm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: All tests PASS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify: 10,000-row table scan completes in &#x3C; 100ms</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"test-specification\">Test Specification</h2>\n<h3 id=\"test-categories\">Test Categories</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// compiler_test.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestCompileSelectBasic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ast </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">SelectStatement</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Columns:   []</span><span style=\"color:#B392F0\">ColumnSelection</span><span style=\"color:#E1E4E8\">{{Expression: </span><span style=\"color:#B392F0\">StarExpression</span><span style=\"color:#E1E4E8\">{}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        FromTable: </span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    program, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> Compile</span><span style=\"color:#E1E4E8\">(ast, testSchema)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify program structure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, OpOpenTable, program[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].Opcode)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, OpRewind, program[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">].Opcode)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, OpColumn, program[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">].Opcode)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, OpResultRow, program[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">].Opcode)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, OpNext, program[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">].Opcode)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, OpHalt, program[</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(program)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">].Opcode)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify jump targets are resolved</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, instr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> program {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> instr.Opcode </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> OpRewind </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> instr.Opcode </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> OpNext {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            assert.</span><span style=\"color:#B392F0\">Greater</span><span style=\"color:#E1E4E8\">(t, instr.P2, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Jump target should be resolved\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            assert.</span><span style=\"color:#B392F0\">Less</span><span style=\"color:#E1E4E8\">(t, instr.P2, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(program), </span><span style=\"color:#9ECBFF\">\"Jump target within bounds\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestCompileSelectWithWhere</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ast </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">SelectStatement</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Columns:   []</span><span style=\"color:#B392F0\">ColumnSelection</span><span style=\"color:#E1E4E8\">{{Expression: </span><span style=\"color:#B392F0\">StarExpression</span><span style=\"color:#E1E4E8\">{}}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        FromTable: </span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Where: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">BinaryExpression</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Operator: </span><span style=\"color:#9ECBFF\">\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Left:     </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">IdentifierExpression</span><span style=\"color:#E1E4E8\">{Name: </span><span style=\"color:#9ECBFF\">\"age\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Right:    </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">LiteralExpression</span><span style=\"color:#E1E4E8\">{Value: </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">18</span><span style=\"color:#E1E4E8\">)},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    program, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> Compile</span><span style=\"color:#E1E4E8\">(ast, testSchema)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find the comparison instruction</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> foundCompare </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, instr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> program {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> instr.Opcode </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> OpLe {  </span><span style=\"color:#6A737D\">// Negated > is &#x3C;=</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            foundCompare </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Should jump to Next instruction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            assert.</span><span style=\"color:#B392F0\">Greater</span><span style=\"color:#E1E4E8\">(t, instr.P2, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">True</span><span style=\"color:#E1E4E8\">(t, foundCompare, </span><span style=\"color:#9ECBFF\">\"Should emit comparison for WHERE\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestCompileInsert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ast </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">InsertStatement</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Table:   </span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Columns: []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"id\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"name\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Values: [][]</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                &#x26;</span><span style=\"color:#B392F0\">LiteralExpression</span><span style=\"color:#E1E4E8\">{Value: </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)},</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                &#x26;</span><span style=\"color:#B392F0\">LiteralExpression</span><span style=\"color:#E1E4E8\">{Value: </span><span style=\"color:#9ECBFF\">\"Alice\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    program, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> Compile</span><span style=\"color:#E1E4E8\">(ast, testSchema)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify program structure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#B392F0\">opcodeSequence</span><span style=\"color:#E1E4E8\">(program), []</span><span style=\"color:#B392F0\">Opcode</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        OpOpenTable, OpInteger, OpString8, OpMakeRecord, OpInsert, OpClose, OpHalt,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestCompileExpressionLiterals</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expr     </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected </span><span style=\"color:#B392F0\">Opcode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {expr: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">LiteralExpression</span><span style=\"color:#E1E4E8\">{Value: </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">42</span><span style=\"color:#E1E4E8\">)}, expected: OpInteger},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {expr: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">LiteralExpression</span><span style=\"color:#E1E4E8\">{Value: </span><span style=\"color:#79B8FF\">3.14</span><span style=\"color:#E1E4E8\">}, expected: OpReal},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {expr: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">LiteralExpression</span><span style=\"color:#E1E4E8\">{Value: </span><span style=\"color:#9ECBFF\">\"hello\"</span><span style=\"color:#E1E4E8\">}, expected: OpString8},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {expr: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">LiteralExpression</span><span style=\"color:#E1E4E8\">{Value: </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">}, expected: OpNull},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, tc </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> tests {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewCompiler</span><span style=\"color:#E1E4E8\">(testSchema)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        reg </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">compileExpression</span><span style=\"color:#E1E4E8\">(tc.expr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        assert.</span><span style=\"color:#B392F0\">GreaterOrEqual</span><span style=\"color:#E1E4E8\">(t, reg, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, tc.expected, c.program[</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(c.program)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">].Opcode)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestJumpPatching</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewCompiler</span><span style=\"color:#E1E4E8\">(testSchema)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Emit forward jump</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    jumpIdx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">emitJump</span><span style=\"color:#E1E4E8\">(OpGoto, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"target\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Emit some instructions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.</span><span style=\"color:#B392F0\">emit</span><span style=\"color:#E1E4E8\">(OpInteger, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.</span><span style=\"color:#B392F0\">emit</span><span style=\"color:#E1E4E8\">(OpInteger, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Define target</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    targetAddr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">currentAddr</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.</span><span style=\"color:#B392F0\">emit</span><span style=\"color:#E1E4E8\">(OpHalt, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Patch the jump</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.</span><span style=\"color:#B392F0\">patchJumpTo</span><span style=\"color:#E1E4E8\">(jumpIdx, targetAddr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, targetAddr, c.program[jumpIdx].P2)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestExplainOutput</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ast </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> parseSQL</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT id, name FROM users WHERE age > 18\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    program, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> Compile</span><span style=\"color:#E1E4E8\">(ast, testSchema)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    explain </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> FormatExplain</span><span style=\"color:#E1E4E8\">(program)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify EXPLAIN format</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(t, explain, </span><span style=\"color:#9ECBFF\">\"addr\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(t, explain, </span><span style=\"color:#9ECBFF\">\"opcode\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(t, explain, </span><span style=\"color:#9ECBFF\">\"OpenTable\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(t, explain, </span><span style=\"color:#9ECBFF\">\"Column\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(t, explain, </span><span style=\"color:#9ECBFF\">\"ResultRow\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(t, explain, </span><span style=\"color:#9ECBFF\">\"Halt\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// vm/vm_test.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestVMExecuteInteger</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">VM</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Program:   []</span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">{{Opcode: OpInteger, P1: </span><span style=\"color:#79B8FF\">42</span><span style=\"color:#E1E4E8\">, P2: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Registers: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">Step</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">42</span><span style=\"color:#E1E4E8\">), vm.Registers[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].Int)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestVMExecuteGoto</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">VM</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Program: []</span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            {Opcode: OpGoto, P2: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            {Opcode: OpInteger, P1: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, P2: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">},  </span><span style=\"color:#6A737D\">// Skipped</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            {Opcode: OpInteger, P1: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, P2: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">},  </span><span style=\"color:#6A737D\">// Target</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            {Opcode: OpHalt},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Registers: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">Run</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">), vm.Registers[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].Int)  </span><span style=\"color:#6A737D\">// Not 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestVMTableScan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create mock storage with 3 rows</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    storage </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMockStorage</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    storage.</span><span style=\"color:#B392F0\">AddTable</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, [][]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"Alice\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"Bob\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"Charlie\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Compile SELECT * FROM users</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ast </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> parseSQL</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM users\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    program, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> Compile</span><span style=\"color:#E1E4E8\">(ast, storage.</span><span style=\"color:#B392F0\">Schema</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Execute</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> results [][]</span><span style=\"color:#B392F0\">Value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">VM</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Program:   program,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Registers: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Storage:   storage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Output: </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">row</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            results </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(results, row)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">Run</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Len</span><span style=\"color:#E1E4E8\">(t, results, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#9ECBFF\">\"Alice\"</span><span style=\"color:#E1E4E8\">, results[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">][</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">].Str)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestVMWhereClause</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    storage </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMockStorage</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    storage.</span><span style=\"color:#B392F0\">AddTable</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">, [][]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"Alice\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">25</span><span style=\"color:#E1E4E8\">)},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"Bob\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">17</span><span style=\"color:#E1E4E8\">)},   </span><span style=\"color:#6A737D\">// Filtered out</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"Charlie\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">30</span><span style=\"color:#E1E4E8\">)},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"Diana\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">15</span><span style=\"color:#E1E4E8\">)}, </span><span style=\"color:#6A737D\">// Filtered out</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"Eve\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">22</span><span style=\"color:#E1E4E8\">)},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ast </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> parseSQL</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT name FROM users WHERE age > 18\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    program, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> Compile</span><span style=\"color:#E1E4E8\">(ast, storage.</span><span style=\"color:#B392F0\">Schema</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> results []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">VM</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Program:   program,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Registers: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Storage:   storage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Output: </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">row</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            results </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(results, row[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].Str)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">Run</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"Alice\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Charlie\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Eve\"</span><span style=\"color:#E1E4E8\">}, results)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestPerformance10KRows</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create table with 10,000 rows</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    storage </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMockStorage</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> rows [][]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rows </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(rows, []</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(i), fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"user</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, i)})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    storage.</span><span style=\"color:#B392F0\">AddTable</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"t\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">10000</span><span style=\"color:#E1E4E8\">, rows)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ast </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> parseSQL</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM t\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    program, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> Compile</span><span style=\"color:#E1E4E8\">(ast, storage.</span><span style=\"color:#B392F0\">Schema</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    count </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">VM</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Program:   program,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Registers: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Storage:   storage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Output: </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">row</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            count</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">Run</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    elapsed </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Since</span><span style=\"color:#E1E4E8\">(start)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">10000</span><span style=\"color:#E1E4E8\">, count)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Less</span><span style=\"color:#E1E4E8\">(t, elapsed.</span><span style=\"color:#B392F0\">Milliseconds</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">), </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"10K row scan should complete in &#x3C; 100ms\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> opcodeSequence</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">program</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Instruction</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#B392F0\">Opcode</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ops </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">Opcode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(program))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, instr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> program {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ops[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> instr.Opcode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ops</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-targets\">Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Target</th>\n<th>How to Measure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Compile simple SELECT</td>\n<td>&lt; 1ms</td>\n<td><code>go test -bench=BenchmarkCompileSelect</code></td>\n</tr>\n<tr>\n<td>Compile with WHERE</td>\n<td>&lt; 2ms</td>\n<td><code>go test -bench=BenchmarkCompileWhere</code></td>\n</tr>\n<tr>\n<td>Execute 10K-row table scan</td>\n<td>&lt; 100ms</td>\n<td><code>go test -bench=BenchmarkTableScan10K</code></td>\n</tr>\n<tr>\n<td>Execute with WHERE filtering 50%</td>\n<td>&lt; 100ms</td>\n<td><code>go test -bench=BenchmarkWhereFilter</code></td>\n</tr>\n<tr>\n<td>Bytecode program size (SELECT *)</td>\n<td>&lt; 20 instructions</td>\n<td>Count instructions in compiled program</td>\n</tr>\n<tr>\n<td>Register usage (simple query)</td>\n<td>&lt; 10 registers</td>\n<td>Check <code>compiler.maxReg</code> after compilation</td>\n</tr>\n<tr>\n<td>Jump target resolution</td>\n<td>100%</td>\n<td>All P2 &gt; 0 for jump instructions</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"synced-criteria\">Synced Criteria</h2>\n<p>[[CRITERIA_JSON: {&quot;module_id&quot;: &quot;build-sqlite-m3&quot;, &quot;criteria&quot;: [&quot;Compiler translates SELECT AST into opcodes including OpenTable, Rewind, Column, ResultRow, Next, and Halt&quot;, &quot;Compiler translates INSERT AST into opcodes including OpenTable, MakeRecord, and Insert&quot;, &quot;VM executes bytecode in a fetch-decode-execute loop, processing one opcode per cycle&quot;, &quot;VM manages a register file of typed values for intermediate calculations&quot;, &quot;WHERE clauses are correctly compiled into conditional jump opcodes (e.g., Gt, Le, Ne)&quot;, &quot;The EXPLAIN command displays the human-readable opcode sequence for any valid SQL statement&quot;, &quot;The VM executes a full table scan of 10,000 rows in under 100ms&quot;]}]</p>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-sqlite-m4 -->\n<h1 id=\"technical-design-specification-buffer-pool-manager\">Technical Design Specification: Buffer Pool Manager</h1>\n<h2 id=\"module-charter\">Module Charter</h2>\n<p>The Buffer Pool Manager provides a page-level cache between the B-tree storage layer and disk, managing a fixed pool of memory frames to minimize disk I/O. It implements LRU (Least Recently Used) eviction to select victim pages when the pool is full, pin counting to prevent eviction of pages actively in use by B-tree operations, dirty page tracking for deferred write-back, and <code>FlushAll</code> for transaction commit boundaries. The buffer pool does NOT interpret page contents, manage B-tree structure, or handle transaction semantics—it provides transparent page caching with durability guarantees via dirty page write-back. Upstream dependencies: B-tree layer (consumes page handles). Downstream dependencies: DiskManager (reads/writes pages to storage). Invariants: pinned pages (PinCount &gt; 0) are never evicted; dirty pages are written to disk before eviction; page data remains valid only while page is pinned; PageID uniquely identifies a page across the database.</p>\n<hr>\n<h2 id=\"file-structure\">File Structure</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>bufferpool/\n├── buffer_pool.go      # (1) BufferPool struct, constructor, FetchPage\n├── frame.go            # (2) Frame metadata (PageID, PinCount, Dirty, LastAccess)\n├── page.go             # (3) Page handle with data slice and lifecycle methods\n├── page_id.go          # (4) PageID type definition\n├── eviction.go         # (5) LRU eviction algorithm\n├── disk_manager.go     # (6) DiskManager interface and file implementation\n├── flush.go            # (7) FlushAll and FlushPage implementations\n├── stats.go            # (8) Hit rate and performance metrics\n├── buffer_pool_test.go # (9) Comprehensive test suite\n└── errors.go           # (10) Error types</code></pre></div>\n\n<hr>\n<h2 id=\"complete-data-model\">Complete Data Model</h2>\n<h3 id=\"pageid-unique-page-identifier\">PageID: Unique Page Identifier</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// page_id.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FileID  </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">  // Database file identifier (0 for single-file databases)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PageNum </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">  // Page number within the file (1-indexed, page 1 is first)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsValid</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> p.PageNum </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, p.FileID, p.PageNum)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY PageID exists:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - FileID enables multi-file database support (main DB, attached databases)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - PageNum is the page's offset in the file (page N is at byte (N-1) * PageSize)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Together they form a globally unique identifier within the database system</span></span></code></pre></div>\n\n<h3 id=\"frame-metadata-per-frame-tracking\">Frame Metadata: Per-Frame Tracking</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// frame.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> FrameMetadata</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PageID     </span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#6A737D\">      // Which page occupies this frame (invalid if empty)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PinCount   </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">         // Number of active references (0 = evictable)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Dirty      </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">        // Has this page been modified since load?</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastAccess </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#6A737D\">   // For LRU eviction ordering</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY each field exists:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - PageID: Maps frame back to disk page; invalid PageID means frame is empty</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - PinCount: Prevents use-after-free; B-tree operations increment during page access</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Dirty: Enables write-back caching; dirty pages must be flushed before eviction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - LastAccess: Drives LRU eviction; updated on every access for accurate ordering</span></span></code></pre></div>\n\n<h3 id=\"page-handle-safe-access-to-page-data\">Page Handle: Safe Access to Page Data</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// page.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Page</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Data     []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\">   // Slice into frame's buffer (do not retain beyond pin!)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PageID   </span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#6A737D\">   // Identifier of this page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frameIdx </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">      // Index into buffer pool's frames array</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bp       </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#6A737D\">  // Back-reference for Unpin</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetData returns the page data slice.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WARNING: This slice becomes invalid after the page is unpinned and potentially</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// evicted. Always complete page operations before calling Unpin.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetData</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> p.Data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MarkDirty flags this page as modified, requiring write-back before eviction.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">MarkDirty</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.bp.</span><span style=\"color:#B392F0\">markDirty</span><span style=\"color:#E1E4E8\">(p.frameIdx)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Unpin releases this page reference, decrementing the pin count.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// If isDirty is true, the page is marked dirty before unpinning.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Panics if called on a page with zero pin count (double-unpin bug).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">isDirty</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.bp.</span><span style=\"color:#B392F0\">UnpinPage</span><span style=\"color:#E1E4E8\">(p.PageID, isDirty)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY Page exists:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Provides controlled access to frame data without exposing frame index</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Encapsulates the unpin operation for RAII-style resource management</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Documents the lifetime constraint (data valid only while pinned)</span></span></code></pre></div>\n\n<h3 id=\"bufferpool-core-data-structure\">BufferPool: Core Data Structure</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// buffer_pool.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BufferPool</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pageSize   </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">  // Fixed size per page (default 4096)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frameCount </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">  // Number of frames (default 1000)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Frame storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frames   [][]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\">         // Actual page data: [frameCount][pageSize]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metadata []</span><span style=\"color:#B392F0\">FrameMetadata</span><span style=\"color:#6A737D\">  // Per-frame metadata</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Lookup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pageTable </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">  // page_id -> frame_index for O(1) lookup</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Disk I/O</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diskMgr </span><span style=\"color:#B392F0\">DiskManager</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Metrics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hits       </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">  // Cache hits</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    misses     </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">  // Cache misses</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    evictions  </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">  // Pages evicted</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    writeBacks </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">  // Dirty pages written to disk</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Concurrency (for future enhancement)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // mutex sync.RWMutex</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Transaction coordination</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    txManager </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TransactionManager</span><span style=\"color:#6A737D\">  // Optional: for journal integration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY each field exists:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - pageSize/frameCount: Define memory budget (pageSize * frameCount bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - frames: Pre-allocated buffers eliminate runtime allocation overhead</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - metadata: Tracks pin count, dirty flag, and LRU ordering per frame</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - pageTable: O(1) lookup from PageID to frame; critical for FetchPage performance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - diskMgr: Abstraction for disk I/O; enables mocking in tests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - metrics: Essential for performance tuning and monitoring</span></span></code></pre></div>\n\n<h3 id=\"diskmanager-storage-abstraction\">DiskManager: Storage Abstraction</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// disk_manager.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DiskManager</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ReadPage reads pageSize bytes from the specified page into the buffer.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Returns error if page doesn't exist or I/O fails.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ReadPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageID</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // WritePage writes pageSize bytes from the buffer to the specified page.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Returns error if I/O fails.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    WritePage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageID</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // AllocatePage allocates a new page and returns its PageID.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // The page is initially zero-filled.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    AllocatePage</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // DeallocatePage marks a page as free for reuse.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    DeallocatePage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageID</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Sync flushes all pending writes to durable storage.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Sync</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Close releases resources held by the disk manager.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Close</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FileDiskManager implements DiskManager using os.File</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> FileDiskManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    file     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">os</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">File</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filePath </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pageSize </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY DiskManager interface:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Enables unit testing with mock storage (no actual disk I/O)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Abstracts file vs raw device vs network storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Separates buffer pool logic from I/O implementation details</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"interface-contracts\">Interface Contracts</h2>\n<h3 id=\"constructor\">Constructor</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// NewBufferPool creates a buffer pool with the specified configuration.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parameters:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - frameCount: Number of page frames (default 1000)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - pageSize: Bytes per page (default 4096)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - diskMgr: Disk manager for I/O operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Pre-conditions:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - frameCount > 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - pageSize > 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - diskMgr != nil</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Post-conditions:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - All frames are allocated and zero-filled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - All frames have invalid PageID (empty state)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - pageTable is empty</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - *BufferPool: Initialized buffer pool</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - error: If frameCount or pageSize is invalid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewBufferPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frameCount</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">pageSize</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">diskMgr</span><span style=\"color:#B392F0\"> DiskManager</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h3 id=\"core-operations\">Core Operations</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// FetchPage retrieves a page from the buffer pool, loading from disk if necessary.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is the primary entry point for page access. The returned Page handle</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// has PinCount = 1; caller must call Unpin when done.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parameters:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - pageID: Identifier of the page to fetch</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - *Page: Handle to the page data (pinned, PinCount = 1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - error: If page cannot be loaded (disk error, all frames pinned)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Post-conditions on success:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Page is in buffer pool (pageTable has entry)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Page's PinCount >= 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Page's LastAccess is updated to current time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - metrics.hits or metrics.misses is incremented</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Error conditions:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - All frames are pinned (cannot evict to make room)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Disk I/O error during page load</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Invalid PageID (PageNum &#x3C;= 0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Thread safety: Caller must hold appropriate locks (future enhancement)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageID</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// UnpinPage decrements the pin count for a page.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parameters:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - pageID: Identifier of the page to unpin</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - isDirty: If true, marks the page as dirty before unpinning</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - error: If page is not in buffer pool or pin count is already 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Post-conditions:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - PinCount decremented by 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - If isDirty, Dirty flag set to true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - If PinCount becomes 0, page is eligible for eviction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Error conditions:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Page not in buffer pool</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - PinCount already 0 (double-unpin bug)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UnpinPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageID</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">isDirty</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PinPage increments the pin count for an already-loaded page.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Use this when you need to extend a page's lifetime without fetching it again.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parameters:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - pageID: Identifier of the page to pin</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - error: If page is not currently in the buffer pool</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Post-conditions:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - PinCount incremented by 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - LastAccess updated to current time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PinPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageID</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span></code></pre></div>\n\n<h3 id=\"flush-operations\">Flush Operations</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// FlushAll writes all dirty pages to disk.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Called at transaction commit boundaries to ensure durability.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Does NOT clear the dirty flag for pages that are still pinned.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - error: If any write operation fails</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Post-conditions:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - All dirty pages have been written to disk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Dirty flag cleared for flushed pages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FlushAll</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FlushPage writes a specific dirty page to disk.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - error: If write operation fails or page is not in buffer pool</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Post-conditions:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - If page was dirty, it has been written to disk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Dirty flag cleared</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FlushPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageID</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span></code></pre></div>\n\n<h3 id=\"metrics\">Metrics</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Stats returns current performance metrics.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Stats</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">BufferPoolStats</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BufferPoolStats</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Hits       </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">   // Cache hits</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Misses     </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">   // Cache misses</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HitRate    </span><span style=\"color:#F97583\">float64</span><span style=\"color:#6A737D\"> // hits / (hits + misses)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Evictions  </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">   // Pages evicted</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WriteBacks </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">   // Dirty pages written to disk</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FrameCount </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">     // Total frames</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PinnedCount </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">    // Frames currently pinned</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DirtyCount </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">     // Frames marked dirty</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ResetStats clears all accumulated metrics.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ResetStats</span><span style=\"color:#E1E4E8\">()</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"algorithm-specification\">Algorithm Specification</h2>\n<h3 id=\"fetchpage-the-core-operation\">FetchPage: The Core Operation</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-13.svg\" alt=\"Buffer Pool Architecture\"></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: FetchPage\nINPUT: BufferPool bp, PageID pageID\nOUTPUT: *Page handle or error\n\n1. VALIDATE INPUT\n   IF pageID.PageNum &lt;= 0:\n     RETURN nil, InvalidPageIDError{PageID: pageID}\n\n2. CHECK CACHE (HIT PATH)\n   frameIdx, exists := bp.pageTable[pageID]\n   IF exists:\n     a. bp.hits++\n     b. meta := &amp;bp.metadata[frameIdx]\n     c. meta.PinCount++\n     d. meta.LastAccess = time.Now()\n     e. RETURN &amp;Page{\n          Data:     bp.frames[frameIdx],\n          PageID:   pageID,\n          frameIdx: frameIdx,\n          bp:       bp,\n        }, nil\n\n3. HANDLE CACHE MISS\n   bp.misses++\n\n4. FIND VICTIM FRAME\n   frameIdx, err := bp.findVictimFrame()\n   IF err != nil:\n     RETURN nil, AllFramesPinnedError{PageID: pageID}\n\n5. EVICT OLD PAGE (if frame occupied)\n   meta := bp.metadata[frameIdx]\n   IF meta.PageID.IsValid():\n     a. IF meta.Dirty:\n        i.   err := bp.diskMgr.WritePage(meta.PageID, bp.frames[frameIdx])\n        ii.  IF err != nil:\n               RETURN nil, DiskIOError{Operation: &quot;write&quot;, PageID: meta.PageID, Cause: err}\n        iii. bp.writeBacks++\n        iv.  meta.Dirty = false\n     b. delete(bp.pageTable, meta.PageID)\n     c. bp.evictions++\n\n6. LOAD NEW PAGE FROM DISK\n   err := bp.diskMgr.ReadPage(pageID, bp.frames[frameIdx])\n   IF err != nil:\n     RETURN nil, DiskIOError{Operation: &quot;read&quot;, PageID: pageID, Cause: err}\n\n7. UPDATE METADATA\n   bp.metadata[frameIdx] = FrameMetadata{\n     PageID:     pageID,\n     PinCount:   1,\n     Dirty:      false,\n     LastAccess: time.Now(),\n   }\n\n8. UPDATE PAGE TABLE\n   bp.pageTable[pageID] = frameIdx\n\n9. RETURN PAGE HANDLE\n   RETURN &amp;Page{\n     Data:     bp.frames[frameIdx],\n     PageID:   pageID,\n     frameIdx: frameIdx,\n     bp:       bp,\n   }, nil\n\nPOST-CONDITIONS:\n   - pageID is in pageTable with correct frameIdx\n   - Frame at frameIdx has PinCount &gt;= 1\n   - Frame's LastAccess is current time\n   - If page was loaded from disk, frame contains correct data</code></pre></div>\n\n<h3 id=\"lru-eviction-finding-a-victim-frame\">LRU Eviction: Finding a Victim Frame</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-14.svg\" alt=\"Frame Metadata Structure\"></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: findVictimFrame\nINPUT: BufferPool bp\nOUTPUT: frame index or error\n\n1. emptyFrameIdx := -1\n   victimIdx := -1\n   oldestAccess := time.Now()\n\n2. SCAN ALL FRAMES\n   FOR i := 0; i &lt; bp.frameCount; i++:\n     meta := &amp;bp.metadata[i]\n\n     a. // Skip pinned pages\n        IF meta.PinCount &gt; 0:\n          CONTINUE\n\n     b. // Found an empty frame - use immediately\n        IF !meta.PageID.IsValid():\n          emptyFrameIdx = i\n          BREAK  // Empty frame is always best choice\n\n     c. // Track least recently used\n        IF meta.LastAccess.Before(oldestAccess):\n          oldestAccess = meta.LastAccess\n          victimIdx = i\n\n3. RETURN RESULT\n   IF emptyFrameIdx &gt;= 0:\n     RETURN emptyFrameIdx, nil\n\n   IF victimIdx &gt;= 0:\n     RETURN victimIdx, nil\n\n   RETURN -1, AllFramesPinnedError{}\n\nCOMPLEXITY: O(frameCount) per eviction\nOPTIMIZATION OPPORTUNITIES:\n   - CLOCK algorithm: O(1) amortized per eviction\n   - LRU-K: Better handling of sequential scans\n   - Separate queues for clean vs dirty pages</code></pre></div>\n\n<h3 id=\"unpinpage-releasing-a-page-reference\">UnpinPage: Releasing a Page Reference</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: UnpinPage\nINPUT: BufferPool bp, PageID pageID, bool isDirty\nOUTPUT: error\n\n1. FIND FRAME\n   frameIdx, exists := bp.pageTable[pageID]\n   IF !exists:\n     RETURN PageNotFoundError{PageID: pageID}\n\n2. VALIDATE PIN COUNT\n   meta := &amp;bp.metadata[frameIdx]\n   IF meta.PinCount &lt;= 0:\n     RETURN DoubleUnpinError{PageID: pageID}\n\n3. UPDATE METADATA\n   meta.PinCount--\n   IF isDirty:\n     meta.Dirty = true\n\n4. RETURN SUCCESS\n   RETURN nil\n\nPOST-CONDITIONS:\n   - PinCount decremented by 1\n   - If isDirty, Dirty flag is true\n   - If PinCount is now 0, page is eligible for eviction</code></pre></div>\n\n<h3 id=\"flushall-writing-dirty-pages-to-disk\">FlushAll: Writing Dirty Pages to Disk</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: FlushAll\nINPUT: BufferPool bp\nOUTPUT: error\n\n1. FOR each pageID, frameIdx in bp.pageTable:\n     meta := bp.metadata[frameIdx]\n\n     a. IF meta.Dirty:\n        i.   err := bp.diskMgr.WritePage(pageID, bp.frames[frameIdx])\n        ii.  IF err != nil:\n               RETURN DiskIOError{Operation: &quot;write&quot;, PageID: pageID, Cause: err}\n        iii. meta.Dirty = false\n        iv.  bp.writeBacks++\n\n2. RETURN nil\n\nPOST-CONDITIONS:\n   - All dirty pages have been written to disk\n   - Dirty flags are cleared\n   - Pages remain in buffer pool (not evicted)</code></pre></div>\n\n<h3 id=\"pinunpin-pattern-for-b-tree-operations\">Pin/Unpin Pattern for B-tree Operations</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>PATTERN: Safe Page Access in B-tree Operations\n\nfunc (btree *BTree) Insert(key, value []byte) error {\n    // 1. Fetch the target page\n    page, err := btree.bufferPool.FetchPage(btree.rootPageID)\n    if err != nil {\n        return err\n    }\n    // Page is now pinned (PinCount = 1)\n\n    // 2. Perform operations on the page\n    // ... read/write page.Data ...\n    \n    // 3. Mark dirty if modified\n    page.MarkDirty()\n\n    // 4. Unpin when done (allows eviction)\n    page.Unpin(true)  // true = page was modified\n\n    return nil\n}\n\nINVARIANT: Between FetchPage and Unpin, the page's frame will not be evicted.\nVIOLATION CONSEQUENCE: Use-after-free, data corruption, crashes.</code></pre></div>\n\n<hr>\n<h2 id=\"error-handling-matrix\">Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th>Error</th>\n<th>Detected By</th>\n<th>Recovery</th>\n<th>User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Invalid PageID (PageNum &lt;= 0)</td>\n<td><code>FetchPage</code> validation</td>\n<td>Return error immediately</td>\n<td>Yes: &quot;invalid page ID: {pageID}&quot;</td>\n</tr>\n<tr>\n<td>Page not in buffer pool</td>\n<td><code>UnpinPage</code> lookup</td>\n<td>Return error immediately</td>\n<td>Yes: &quot;page not found: {pageID}&quot;</td>\n</tr>\n<tr>\n<td>Double unpin (PinCount already 0)</td>\n<td><code>UnpinPage</code> validation</td>\n<td>Return error immediately</td>\n<td>Yes: &quot;double unpin detected for page {pageID}&quot;</td>\n</tr>\n<tr>\n<td>All frames pinned</td>\n<td><code>findVictimFrame</code></td>\n<td>Return error, cannot load page</td>\n<td>Yes: &quot;buffer pool exhausted: all frames pinned&quot;</td>\n</tr>\n<tr>\n<td>Disk read error</td>\n<td><code>FetchPage</code> during load</td>\n<td>Return error, frame remains empty</td>\n<td>Yes: &quot;disk read error for page {pageID}: {cause}&quot;</td>\n</tr>\n<tr>\n<td>Disk write error</td>\n<td><code>FlushAll</code>, eviction</td>\n<td>Return error, page remains dirty</td>\n<td>Yes: &quot;disk write error for page {pageID}: {cause}&quot;</td>\n</tr>\n<tr>\n<td>Disk sync error</td>\n<td><code>FlushAll</code> finalization</td>\n<td>Return error</td>\n<td>Yes: &quot;failed to sync disk: {cause}&quot;</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"implementation-sequence-with-checkpoints\">Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-bufferpool-structure-and-frame-allocation-15-hours\">Phase 1: BufferPool Structure and Frame Allocation (1.5 hours)</h3>\n<p><strong>Files to create</strong>: <code>buffer_pool.go</code>, <code>frame.go</code>, <code>page_id.go</code>, <code>page.go</code>, <code>errors.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Define <code>PageID</code> type with validation</li>\n<li>Define <code>FrameMetadata</code> struct</li>\n<li>Define <code>Page</code> handle struct with methods</li>\n<li>Define error types: <code>InvalidPageIDError</code>, <code>PageNotFoundError</code>, etc.</li>\n<li>Implement <code>NewBufferPool</code> constructor with frame allocation</li>\n<li>Initialize all frames with invalid PageID (empty state)</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should be able to create a buffer pool and verify frame allocation. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestNewBufferPool</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (frames allocated, metadata initialized)</span></span></code></pre></div>\n\n<h3 id=\"phase-2-fetchpage-with-hitmiss-logic-2-hours\">Phase 2: FetchPage with Hit/Miss Logic (2 hours)</h3>\n<p><strong>Files to create</strong>: <code>disk_manager.go</code> (interface + mock)</p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Define <code>DiskManager</code> interface</li>\n<li>Implement <code>MockDiskManager</code> for testing</li>\n<li>Implement <code>FetchPage</code> cache-hit path (page already in pool)</li>\n<li>Implement <code>FetchPage</code> cache-miss path (load from disk)</li>\n<li>Update <code>pageTable</code> on successful load</li>\n<li>Increment hits/misses metrics</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should be able to fetch pages with hit/miss tracking. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestFetchPage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (hit on second fetch, miss on first)</span></span></code></pre></div>\n\n<h3 id=\"phase-3-lru-eviction-algorithm-15-hours\">Phase 3: LRU Eviction Algorithm (1.5 hours)</h3>\n<p><strong>Files to create</strong>: <code>eviction.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>findVictimFrame</code> with LRU scan</li>\n<li>Handle empty frames (prefer over eviction)</li>\n<li>Skip pinned pages during scan</li>\n<li>Implement eviction logic: write dirty page, update pageTable</li>\n<li>Increment evictions/writeBacks metrics</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should be able to evict pages when pool is full. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestEviction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (LRU page evicted, dirty page written back)</span></span></code></pre></div>\n\n<h3 id=\"phase-4-pinunpin-and-dirty-page-tracking-15-hours\">Phase 4: Pin/Unpin and Dirty Page Tracking (1.5 hours)</h3>\n<p><strong>Files to update</strong>: <code>buffer_pool.go</code>, <code>page.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>UnpinPage</code> with pin count decrement</li>\n<li>Implement <code>PinPage</code> for re-pinning loaded pages</li>\n<li>Implement <code>Page.MarkDirty()</code> method</li>\n<li>Detect double-unpin errors</li>\n<li>Update <code>LastAccess</code> on pin operations</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should pass pin/unpin tests. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestPinUnpin</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (pin prevents eviction, unpin allows it)</span></span></code></pre></div>\n\n<h3 id=\"phase-5-flushall-and-flushpage-15-hours\">Phase 5: FlushAll and FlushPage (1.5 hours)</h3>\n<p><strong>Files to create</strong>: <code>flush.go</code>, <code>stats.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>FlushAll</code> to write all dirty pages</li>\n<li>Implement <code>FlushPage</code> for single-page flush</li>\n<li>Clear dirty flag after successful write</li>\n<li>Implement <code>Stats()</code> for metrics access</li>\n<li>Implement <code>ResetStats()</code> for testing</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should pass the full test suite. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> ./bufferpool</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: All tests PASS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify: 95%+ hit rate on typical workload test</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify: Cache hit completes in &#x3C; 100ns (microbenchmark)</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"test-specification\">Test Specification</h2>\n<h3 id=\"test-categories\">Test Categories</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// buffer_pool_test.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestNewBufferPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diskMgr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMockDiskManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bp, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewBufferPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, diskMgr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">, bp.frameCount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, bp.pageSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Len</span><span style=\"color:#E1E4E8\">(t, bp.frames, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Len</span><span style=\"color:#E1E4E8\">(t, bp.metadata, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify all frames are initially empty</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, meta </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> bp.metadata {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        assert.</span><span style=\"color:#B392F0\">False</span><span style=\"color:#E1E4E8\">(t, meta.PageID.</span><span style=\"color:#B392F0\">IsValid</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, meta.PinCount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        assert.</span><span style=\"color:#B392F0\">False</span><span style=\"color:#E1E4E8\">(t, meta.Dirty)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestFetchPageHit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diskMgr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMockDiskManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diskMgr.</span><span style=\"color:#B392F0\">SetPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#B392F0\">makePageData</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bp, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewBufferPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, diskMgr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // First fetch: miss</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page1, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), bp.misses)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">), bp.hits)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page1.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Second fetch: hit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page2, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), bp.misses)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), bp.hits)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Same frame should be used</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, page1.frameIdx, page2.frameIdx)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page2.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestFetchPageMiss</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diskMgr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMockDiskManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diskMgr.</span><span style=\"color:#B392F0\">SetPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#B392F0\">makePageData</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bp, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewBufferPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, diskMgr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NotNil</span><span style=\"color:#E1E4E8\">(t, page)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">}, page.PageID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), bp.misses)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify page data was loaded</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#B392F0\">makePageData</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">), page.Data)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestLRUEviction</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diskMgr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMockDiskManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        diskMgr.</span><span style=\"color:#B392F0\">SetPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: i}, </span><span style=\"color:#B392F0\">makePageData</span><span style=\"color:#E1E4E8\">(i))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bp, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewBufferPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, diskMgr)  </span><span style=\"color:#6A737D\">// Only 3 frames</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Load pages 1, 2, 3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p1, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p2, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p3, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Unpin all</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p1.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p2.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p3.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Access page 1 to make it recently used</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    time.</span><span style=\"color:#B392F0\">Sleep</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Millisecond)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p1Again, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p1Again.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Load page 4 - should evict page 2 (LRU)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p4, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p4.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Page 1 should still be in memory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.pageTable[</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">True</span><span style=\"color:#E1E4E8\">(t, exists)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Page 2 should have been evicted</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, exists </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> bp.pageTable[</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">}]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">False</span><span style=\"color:#E1E4E8\">(t, exists)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), bp.evictions)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestPinPreventsEviction</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diskMgr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMockDiskManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        diskMgr.</span><span style=\"color:#B392F0\">SetPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: i}, </span><span style=\"color:#B392F0\">makePageData</span><span style=\"color:#E1E4E8\">(i))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bp, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewBufferPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, diskMgr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Load and pin pages 1, 2, 3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p1, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p2, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p3, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // All still pinned (PinCount = 1)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Try to load page 4 - should fail (all frames pinned)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(t, err.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#9ECBFF\">\"all frames pinned\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Unpin page 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p2.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Now page 4 should load (evicts page 2)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p4, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p4.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p1.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p3.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestDirtyPageWriteback</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diskMgr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMockDiskManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diskMgr.</span><span style=\"color:#B392F0\">SetPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bp, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewBufferPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, diskMgr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Load page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Modify page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page.Data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">42</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page.</span><span style=\"color:#B392F0\">MarkDirty</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify dirty flag is set</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frameIdx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.pageTable[</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">True</span><span style=\"color:#E1E4E8\">(t, bp.metadata[frameIdx].Dirty)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Flush to disk</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FlushAll</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify dirty flag cleared</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">False</span><span style=\"color:#E1E4E8\">(t, bp.metadata[frameIdx].Dirty)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify data was written to disk</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diskData, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> diskMgr.</span><span style=\"color:#B392F0\">GetPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">42</span><span style=\"color:#E1E4E8\">), diskData[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestFlushAll</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diskMgr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMockDiskManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bp, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewBufferPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, diskMgr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create and dirty multiple pages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        diskMgr.</span><span style=\"color:#B392F0\">SetPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: i}, </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: i})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page.Data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> byte</span><span style=\"color:#E1E4E8\">(i)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page.</span><span style=\"color:#B392F0\">MarkDirty</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Flush all</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FlushAll</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify all pages written</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        data, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> diskMgr.</span><span style=\"color:#B392F0\">GetPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: i})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(i), data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">), bp.writeBacks)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestDoubleUnpinError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diskMgr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMockDiskManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diskMgr.</span><span style=\"color:#B392F0\">SetPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bp, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewBufferPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, diskMgr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Second unpin should fail</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">UnpinPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(t, err.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#9ECBFF\">\"double unpin\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestStats</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diskMgr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMockDiskManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diskMgr.</span><span style=\"color:#B392F0\">SetPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diskMgr.</span><span style=\"color:#B392F0\">SetPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bp, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewBufferPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, diskMgr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Generate some activity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p1, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})  </span><span style=\"color:#6A737D\">// miss</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p1.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p1Again, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})  </span><span style=\"color:#6A737D\">// hit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p1Again.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p2, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">})  </span><span style=\"color:#6A737D\">// miss</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p2.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">Stats</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">), stats.Misses)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), stats.Hits)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\">3.0</span><span style=\"color:#E1E4E8\">, stats.HitRate)  </span><span style=\"color:#6A737D\">// 1 hit / 3 total</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestHitRateMetric</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diskMgr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMockDiskManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        diskMgr.</span><span style=\"color:#B392F0\">SetPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: i}, </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bp, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewBufferPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">50</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, diskMgr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Simulate typical workload: 95% accesses to hot pages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hotPages </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    coldPages </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> makeRange</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        var</span><span style=\"color:#E1E4E8\"> pageNum </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> i</span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {  </span><span style=\"color:#6A737D\">// 5% cold access</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pageNum </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> coldPages[i</span><span style=\"color:#F97583\">%</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(coldPages)]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {  </span><span style=\"color:#6A737D\">// 95% hot access</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pageNum </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hotPages[i</span><span style=\"color:#F97583\">%</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(hotPages)]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: pageNum})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">Stats</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">GreaterOrEqual</span><span style=\"color:#E1E4E8\">(t, stats.HitRate, </span><span style=\"color:#79B8FF\">0.95</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Expected 95%+ hit rate on typical workload\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestPerformanceCacheHit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> testing.</span><span style=\"color:#B392F0\">Short</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">Skip</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Skipping performance test\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diskMgr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMockDiskManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diskMgr.</span><span style=\"color:#B392F0\">SetPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bp, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewBufferPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, diskMgr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Warm up: load the page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Benchmark cache hits</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bp.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    elapsed </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Since</span><span style=\"color:#E1E4E8\">(start)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    avgHitTime </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> elapsed </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 100000</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Less</span><span style=\"color:#E1E4E8\">(t, avgHitTime.</span><span style=\"color:#B392F0\">Nanoseconds</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">), </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Cache hit should complete in &#x3C; 100ns\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-targets\">Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Target</th>\n<th>How to Measure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cache hit (FetchPage on loaded page)</td>\n<td>&lt; 100ns</td>\n<td><code>go test -bench=BenchmarkCacheHit</code></td>\n</tr>\n<tr>\n<td>Cache miss (FetchPage from disk)</td>\n<td>&lt; 100μs (SSD)</td>\n<td><code>go test -bench=BenchmarkCacheMiss</code></td>\n</tr>\n<tr>\n<td>LRU eviction scan</td>\n<td>O(frameCount)</td>\n<td>Code review; no N² patterns</td>\n</tr>\n<tr>\n<td>FlushAll</td>\n<td>O(dirty pages)</td>\n<td><code>go test -bench=BenchmarkFlushAll</code></td>\n</tr>\n<tr>\n<td>Hit rate on typical workload</td>\n<td>95%+</td>\n<td><code>go test -run TestHitRateMetric</code></td>\n</tr>\n<tr>\n<td>Memory overhead</td>\n<td>pageSize × frameCount + O(frameCount)</td>\n<td>Verify no per-page allocations</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"synced-criteria\">Synced Criteria</h2>\n<p>[[CRITERIA_JSON: {&quot;module_id&quot;: &quot;build-sqlite-m4&quot;, &quot;criteria&quot;: [&quot;Buffer pool initializes with a fixed number of 4096-byte frames&quot;, &quot;FetchPage returns the correct page from memory if already loaded (hit)&quot;, &quot;FetchPage loads page from disk if not in memory (miss)&quot;, &quot;LRU algorithm correctly identifies the least recently used page for eviction&quot;, &quot;Pinned pages (count &gt; 0) are never selected for eviction&quot;, &quot;Dirty pages are written back to disk only when evicted or on FlushAll&quot;, &quot;Buffer pool hit rate is tracked and accessible for performance metrics&quot;]}]</p>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-sqlite-m5 -->\n<h1 id=\"technical-design-specification-b-tree-page-format-amp-table-storage\">Technical Design Specification: B-tree Page Format &amp; Table Storage</h1>\n<h2 id=\"module-charter\">Module Charter</h2>\n<p>The B-tree Page Format implements the on-disk storage layer for tables and indexes using a slotted page architecture with four page types: table leaf (row storage keyed by rowid), table internal (separator keys and child pointers), index leaf (indexed value + rowid pairs), and index internal (separator keys and child pointers). The module provides varint encoding for compact record representation, serial type-based field encoding, cell pointer arrays for sorted access without data shifting, node splitting with separator promotion for tree maintenance, and a system catalog (sqlite_master) for schema persistence. It does NOT manage memory caching (delegates to BufferPool), execute queries (delegates to VM), or handle transaction semantics (delegates to TransactionManager). Upstream dependencies: Bytecode VM (receives row operations), Buffer Pool (reads/writes pages). Downstream dependencies: Disk via BufferPool. Invariants: page size is fixed at 4096 bytes; all multi-byte integers are big-endian; cell pointers are sorted by key within each page; every page has a valid type byte in header; B-tree invariant (balanced, ordered) holds after every operation.</p>\n<hr>\n<h2 id=\"file-structure\">File Structure</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>storage/\n├── page.go             # (1) Page struct, header, slotted format accessors\n├── page_type.go        # (2) Page type constants and validation\n├── cell.go             # (3) Cell pointer array, cell allocation\n├── varint.go           # (4) Variable-length integer encoding/decoding\n├── serial_type.go      # (5) Serial type definitions and value encoding\n├── record.go           # (6) Row serialization to/from record format\n├── btree.go            # (7) BTree struct with root, insert, delete, scan\n├── btree_cursor.go     # (8) Cursor for tree traversal\n├── table_leaf.go       # (9) Table B-tree leaf operations\n├── table_internal.go   # (10) Table B-tree internal page operations\n├── index_leaf.go       # (11) Index B+tree leaf operations\n├── index_internal.go   # (12) Index B+tree internal page operations\n├── split.go            # (13) Node splitting and separator promotion\n├── catalog.go          # (14) System catalog (sqlite_master)\n├── freeblock.go        # (15) Free space management within pages\n└── storage_test.go     # (16) Comprehensive test suite</code></pre></div>\n\n<hr>\n<h2 id=\"complete-data-model\">Complete Data Model</h2>\n<h3 id=\"page-types\">Page Types</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// page_type.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PageType</span><span style=\"color:#F97583\"> uint8</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PageTypeInvalid</span><span style=\"color:#B392F0\">      PageType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">00</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PageTypeIndexLeaf</span><span style=\"color:#B392F0\">    PageType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">0A</span><span style=\"color:#6A737D\">  // Index B+tree leaf: (key, rowid) pairs</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PageTypeIndexInt</span><span style=\"color:#B392F0\">     PageType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">02</span><span style=\"color:#6A737D\">  // Index B+tree internal: separators + children</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PageTypeTableLeaf</span><span style=\"color:#B392F0\">    PageType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">0D</span><span style=\"color:#6A737D\">  // Table B-tree leaf: full records keyed by rowid</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PageTypeTableInt</span><span style=\"color:#B392F0\">     PageType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">05</span><span style=\"color:#6A737D\">  // Table B-tree internal: rowid separators + children</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pt </span><span style=\"color:#B392F0\">PageType</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsValid</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> pt </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PageTypeIndexLeaf </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> pt </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PageTypeIndexInt </span><span style=\"color:#F97583\">||</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           pt </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PageTypeTableLeaf </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> pt </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PageTypeTableInt</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pt </span><span style=\"color:#B392F0\">PageType</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsLeaf</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> pt </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PageTypeTableLeaf </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> pt </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PageTypeIndexLeaf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pt </span><span style=\"color:#B392F0\">PageType</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsTable</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> pt </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PageTypeTableLeaf </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> pt </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PageTypeTableInt</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pt </span><span style=\"color:#B392F0\">PageType</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> pt {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> PageTypeIndexLeaf: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"IndexLeaf\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> PageTypeIndexInt: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"IndexInternal\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> PageTypeTableLeaf: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"TableLeaf\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> PageTypeTableInt: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"TableInternal\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"Invalid\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY four page types:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Table vs Index: Different cell content (full record vs key+rowid)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Leaf vs Internal: Different cell format (data vs separator+child)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Index B+trees have linked leaves; Table B-trees do not</span></span></code></pre></div>\n\n<h3 id=\"page-header-format\">Page Header Format</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-17.svg\" alt=\"Slotted Page Layout\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// page.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PageSize</span><span style=\"color:#F97583\">         =</span><span style=\"color:#79B8FF\"> 4096</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PageHeaderSize</span><span style=\"color:#F97583\">   =</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#6A737D\">   // Leaf pages: 8 bytes</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PageHeaderSizeInt</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#6A737D\">  // Internal pages: 12 bytes (includes rightmost pointer)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PageHeader</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type             </span><span style=\"color:#B392F0\">PageType</span><span style=\"color:#6A737D\">  // 1 byte: page type identifier</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FirstFreeblock   </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\">    // 2 bytes: offset to first freeblock (0 if none)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CellCount        </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\">    // 2 bytes: number of cells on this page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CellContentStart </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#6A737D\">    // 2 bytes: offset to start of cell content area</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FragmentedBytes  </span><span style=\"color:#F97583\">uint8</span><span style=\"color:#6A737D\">     // 1 byte: number of fragmented free bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RightMostPointer </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">    // 4 bytes: rightmost child page (internal pages only)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Byte layout for leaf pages (8 bytes):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Offset 0: PageType (1 byte)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Offset 1-2: FirstFreeblock (2 bytes, big-endian)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Offset 3-4: CellCount (2 bytes, big-endian)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Offset 5-6: CellContentStart (2 bytes, big-endian)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Offset 7: FragmentedBytes (1 byte)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Byte layout for internal pages (12 bytes):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Same as leaf, plus:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Offset 8-11: RightMostPointer (4 bytes, big-endian)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY each field:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Type: Dispatches to correct cell parser/handler</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - FirstFreeblock: Enables free space reuse within page</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - CellCount: Bounds the cell pointer array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - CellContentStart: Marks boundary between pointers and content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - FragmentedBytes: Tracks small gaps that may need coalescing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - RightMostPointer: Child for keys greater than all separators</span></span></code></pre></div>\n\n<h3 id=\"page-structure-slotted-format\">Page Structure: Slotted Format</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// page.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Page</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data     []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\">      // Exactly PageSize bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pageID   </span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#6A737D\">      // Identifier for this page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    isDirty  </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">        // Has been modified</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Layout visualization:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ┌─────────────────────────────────────────────────────────────────┐</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ Header (8/12 bytes)                                             │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ├─────────────────────────────────────────────────────────────────┤</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ Cell Pointer Array (2 bytes each, grows →)                      │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ [ptr0][ptr1][ptr2]...                                           │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ├─────────────────────────────────────────────────────────────────┤</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ Free Space                                                      │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │                                                                 │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ├─────────────────────────────────────────────────────────────────┤</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ Cell Content Area (grows ←)                                     │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ ...[cell2][cell1][cell0]                                        │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// └─────────────────────────────────────────────────────────────────┘</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">headerSize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">Type</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">IsLeaf</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> PageHeaderSize</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> PageHeaderSizeInt</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Header accessors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Type</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">PageType</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> PageType</span><span style=\"color:#E1E4E8\">(p.data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pt</span><span style=\"color:#B392F0\"> PageType</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> byte</span><span style=\"color:#E1E4E8\">(pt)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.isDirty </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FirstFreeblock</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> binary.BigEndian.</span><span style=\"color:#B392F0\">Uint16</span><span style=\"color:#E1E4E8\">(p.data[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetFirstFreeblock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> uint16</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint16</span><span style=\"color:#E1E4E8\">(p.data[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">], offset)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.isDirty </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> binary.BigEndian.</span><span style=\"color:#B392F0\">Uint16</span><span style=\"color:#E1E4E8\">(p.data[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetCellCount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">count</span><span style=\"color:#F97583\"> uint16</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint16</span><span style=\"color:#E1E4E8\">(p.data[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">], count)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.isDirty </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CellContentStart</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    val </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> binary.BigEndian.</span><span style=\"color:#B392F0\">Uint16</span><span style=\"color:#E1E4E8\">(p.data[</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> val </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> PageSize </span><span style=\"color:#6A737D\">// 0 means content starts at page end</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> val</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetCellContentStart</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> uint16</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint16</span><span style=\"color:#E1E4E8\">(p.data[</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">], offset)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.isDirty </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FragmentedBytes</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">uint8</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> p.data[</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetFragmentedBytes</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">count</span><span style=\"color:#F97583\"> uint8</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.data[</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.isDirty </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RightMostPointer</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">Type</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">IsLeaf</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(p.data[</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetRightMostPointer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageNum</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">p.</span><span style=\"color:#B392F0\">Type</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">IsLeaf</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(p.data[</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">], pageNum)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.isDirty </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"cell-pointer-array\">Cell Pointer Array</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// cell.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> CellPointerSize</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#6A737D\"> // Each pointer is 2 bytes</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CellPointer returns the offset of the cell at the given index.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Index must be &#x3C; CellCount().</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CellPointer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">index</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> index </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> index </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(p.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        panic</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"cell index out of bounds: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (count=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)\"</span><span style=\"color:#E1E4E8\">, index, p.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">()))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">headerSize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> index</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">CellPointerSize</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> binary.BigEndian.</span><span style=\"color:#B392F0\">Uint16</span><span style=\"color:#E1E4E8\">(p.data[offset : offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetCellPointer sets the cell pointer at the given index.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetCellPointer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">index</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#F97583\"> uint16</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">headerSize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> index</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">CellPointerSize</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint16</span><span style=\"color:#E1E4E8\">(p.data[offset:offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">], ptr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.isDirty </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FreeSpace calculates available bytes between pointer array and content area.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FreeSpace</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    headerEnd </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">headerSize</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pointerArrayEnd </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> headerEnd </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(p.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">())</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">CellPointerSize</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    contentStart </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(p.</span><span style=\"color:#B392F0\">CellContentStart</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> contentStart </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PageSize {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Page is empty, content would start at end</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> PageSize </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> pointerArrayEnd</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> contentStart </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> pointerArrayEnd</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY cell pointer array:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Enables sorted access (pointers are ordered by key)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Avoids shifting cell content on insert/delete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Cell content can be appended without sorting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Only 2-byte pointers move, not potentially large cells</span></span></code></pre></div>\n\n<h3 id=\"varint-encoding\">Varint Encoding</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-18.svg\" alt=\"Page Header Fields\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// varint.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReadVarint reads a variable-length integer from data at offset.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns (value, bytesRead).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SQLite varint format (1-9 bytes):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - 1 byte:  0xxxxxxx                              (0 to 127)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - 2 bytes: 10xxxxxx xxxxxxxx                     (128 to 16383)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - 3 bytes: 110xxxxx xxxxxxxx xxxxxxxx            (16384 to 2097151)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - 4 bytes: 1110xxxx xxxxxxxx xxxxxxxx xxxxxxxx   (2097152 to 268435455)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - 5-8 bytes: Similar pattern with more leading 1s</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - 9 bytes: 11111111 followed by 8-byte big-endian integer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Maximum value: 2^64 - 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">bytesRead</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">>=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(data) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> data[offset]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Single byte case (0xxxxxxx)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(b), </span><span style=\"color:#79B8FF\">1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Determine length from leading 1 bits</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> length </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">C0</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#6A737D\">// 10xxxxxx</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(b </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">3F</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">E0</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#6A737D\">// 110xxxxx</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(b </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">1F</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">F0</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#6A737D\">// 1110xxxx</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(b </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">0F</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 4</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">F8</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#6A737D\">// 11110xxx</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(b </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">07</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 5</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FC</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#6A737D\">// 111110xx</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(b </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">03</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 6</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FE</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#6A737D\">// 1111110x</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(b </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">01</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 7</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FE</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#6A737D\">// 11111110</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 8</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#6A737D\">// 11111111</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">9</span><span style=\"color:#F97583\"> ></span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(data) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 9-byte encoding: full 8-byte big-endian integer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        value </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(binary.BigEndian.</span><span style=\"color:#B392F0\">Uint64</span><span style=\"color:#E1E4E8\">(data[offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\"> : offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">9</span><span style=\"color:#E1E4E8\">]))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> value, </span><span style=\"color:#79B8FF\">9</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read continuation bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> length; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">i </span><span style=\"color:#F97583\">>=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(data) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (result </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(data[offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">i])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result, length</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WriteVarint encodes a value as a varint and returns the bytes.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> WriteVarint</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle 9-byte case for negative or very large values</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">></span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFFFFFFFFFFFF</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">9</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buf[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FF</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint64</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">9</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#E1E4E8\">(value))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> buf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1-byte case</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(value)}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2-byte case</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">4000</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            byte</span><span style=\"color:#E1E4E8\">((value </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            byte</span><span style=\"color:#E1E4E8\">(value),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3-byte case</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">200000</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            byte</span><span style=\"color:#E1E4E8\">((value </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">C0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            byte</span><span style=\"color:#E1E4E8\">(value </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            byte</span><span style=\"color:#E1E4E8\">(value),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4-byte case</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">10000000</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            byte</span><span style=\"color:#E1E4E8\">((value </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 24</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">E0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            byte</span><span style=\"color:#E1E4E8\">(value </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            byte</span><span style=\"color:#E1E4E8\">(value </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            byte</span><span style=\"color:#E1E4E8\">(value),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5-8 byte cases follow similar pattern</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... (implementation continues for larger values)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Fall back to 9-byte for simplicity in remaining cases</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">9</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buf[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FF</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint64</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">9</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#E1E4E8\">(value))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> buf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// VarintSize returns the number of bytes needed to encode value.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> VarintSize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 9</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">4000</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">200000</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">10000000</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">0800000000</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 5</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">040000000000</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 6</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">02000000000000</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 7</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">0100000000000000</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 8</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 9</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"serial-types\">Serial Types</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// serial_type.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SerialType</span><span style=\"color:#F97583\"> int64</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SerialTypeNull</span><span style=\"color:#B392F0\"> SerialType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SerialTypeInt8</span><span style=\"color:#6A737D\">            // 1-byte signed integer</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SerialTypeInt16</span><span style=\"color:#6A737D\">           // 2-byte big-endian signed integer</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SerialTypeInt24</span><span style=\"color:#6A737D\">           // 3-byte big-endian signed integer</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SerialTypeInt32</span><span style=\"color:#6A737D\">           // 4-byte big-endian signed integer</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SerialTypeInt48</span><span style=\"color:#6A737D\">           // 6-byte big-endian signed integer</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SerialTypeInt64</span><span style=\"color:#6A737D\">           // 8-byte big-endian signed integer</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SerialTypeFloat</span><span style=\"color:#6A737D\">           // 8-byte IEEE 754 float</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SerialTypeZero</span><span style=\"color:#6A737D\">            // Integer constant 0 (0 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SerialTypeOne</span><span style=\"color:#6A737D\">             // Integer constant 1 (0 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 10, 11: Reserved for internal use</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // N >= 12, even: BLOB of (N-12)/2 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // N >= 13, odd: TEXT of (N-13)/2 bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SerialTypeSize returns the data size for a serial type.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> SerialTypeSize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">st</span><span style=\"color:#B392F0\"> SerialType</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> st {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> SerialTypeNull, SerialTypeZero, SerialTypeOne:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> SerialTypeInt8:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> SerialTypeInt16:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> SerialTypeInt24:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> SerialTypeInt32:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 4</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> SerialTypeInt48:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 6</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> SerialTypeInt64, SerialTypeFloat:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 8</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> st </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> st</span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">((st </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#6A737D\">// BLOB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> st </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 13</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">((st </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 13</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#6A737D\">// TEXT</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EncodeSerialType determines the serial type for a Go value.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> EncodeSerialType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}) (</span><span style=\"color:#B392F0\">SerialType</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> value.(</span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> SerialTypeNull, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> EncodeSerialType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(v))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> SerialTypeZero, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> SerialTypeOne, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">128</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 127</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> SerialTypeInt8, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(v)}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32768</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 32767</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            buf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint16</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int16</span><span style=\"color:#E1E4E8\">(v)))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> SerialTypeInt16, buf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">8388608</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 8388607</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            buf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            buf[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> byte</span><span style=\"color:#E1E4E8\">(v </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            buf[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> byte</span><span style=\"color:#E1E4E8\">(v </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            buf[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> byte</span><span style=\"color:#E1E4E8\">(v)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> SerialTypeInt24, buf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">2147483648</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 2147483647</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            buf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int32</span><span style=\"color:#E1E4E8\">(v)))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> SerialTypeInt32, buf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">140737488355328</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 140737488355327</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            buf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#E1E4E8\">(v</span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint16</span><span style=\"color:#E1E4E8\">(buf[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\">(v))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> SerialTypeInt48, buf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint64</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#E1E4E8\">(v))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> SerialTypeInt64, buf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint64</span><span style=\"color:#E1E4E8\">(buf, math.</span><span style=\"color:#B392F0\">Float64bits</span><span style=\"color:#E1E4E8\">(v))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> SerialTypeFloat, buf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(v)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        st </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SerialType</span><span style=\"color:#E1E4E8\">(length</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> +</span><span style=\"color:#79B8FF\"> 13</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> st, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(v)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(v)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        st </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SerialType</span><span style=\"color:#E1E4E8\">(length</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> +</span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> st, v</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        panic</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unsupported type: </span><span style=\"color:#79B8FF\">%T</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, value))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DecodeValue decodes a value given its serial type and data.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> DecodeValue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">st</span><span style=\"color:#B392F0\"> SerialType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> st {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> SerialTypeNull:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> SerialTypeZero:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> SerialTypeOne:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> SerialTypeInt8:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int8</span><span style=\"color:#E1E4E8\">(data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">])), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> SerialTypeInt16:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int16</span><span style=\"color:#E1E4E8\">(binary.BigEndian.</span><span style=\"color:#B392F0\">Uint16</span><span style=\"color:#E1E4E8\">(data))), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> SerialTypeInt24:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        val </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int32</span><span style=\"color:#E1E4E8\">(data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">])</span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#F97583\"> |</span><span style=\"color:#F97583\"> int32</span><span style=\"color:#E1E4E8\">(data[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">])</span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#F97583\"> |</span><span style=\"color:#F97583\"> int32</span><span style=\"color:#E1E4E8\">(data[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">&#x26;0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#F97583\"> !=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            val </span><span style=\"color:#F97583\">|=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FF000000</span><span style=\"color:#6A737D\"> // Sign extend</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(val), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> SerialTypeInt32:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int32</span><span style=\"color:#E1E4E8\">(binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(data))), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> SerialTypeInt48:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        val </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">]))</span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#F97583\"> |</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               int64</span><span style=\"color:#E1E4E8\">(binary.BigEndian.</span><span style=\"color:#B392F0\">Uint16</span><span style=\"color:#E1E4E8\">(data[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">]))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">&#x26;0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#F97583\"> !=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            val </span><span style=\"color:#F97583\">|=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFF000000000000</span><span style=\"color:#6A737D\"> // Sign extend</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> val, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> SerialTypeInt64:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(binary.BigEndian.</span><span style=\"color:#B392F0\">Uint64</span><span style=\"color:#E1E4E8\">(data)), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> SerialTypeFloat:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> math.</span><span style=\"color:#B392F0\">Float64frombits</span><span style=\"color:#E1E4E8\">(binary.BigEndian.</span><span style=\"color:#B392F0\">Uint64</span><span style=\"color:#E1E4E8\">(data)), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> st </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> st</span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // BLOB</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> data[:</span><span style=\"color:#B392F0\">SerialTypeSize</span><span style=\"color:#E1E4E8\">(st)], </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> st </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 13</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TEXT</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">(data[:</span><span style=\"color:#B392F0\">SerialTypeSize</span><span style=\"color:#E1E4E8\">(st)]), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid serial type: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, st)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"record-format\">Record Format</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-19.svg\" alt=\"Record Serialization Format\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// record.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Record format:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ┌─────────────────────────────────────────────────────────────────┐</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ Header Size (varint)                                            │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ Serial Type 0 (varint)                                          │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ Serial Type 1 (varint)                                          │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ ...                                                             │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ Serial Type N-1 (varint)                                        │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ├─────────────────────────────────────────────────────────────────┤</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ Value 0 (size determined by serial type)                        │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ Value 1                                                         │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ ...                                                             │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ Value N-1                                                       │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// └─────────────────────────────────────────────────────────────────┘</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SerializeRow converts a slice of values to a record (byte slice).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> SerializeRow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">values</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // First pass: calculate sizes and encode values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    headerSize </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bodySize </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    serialTypes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">SerialType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(values))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bodies </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([][]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(values))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, val </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> values {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        st, body </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> EncodeSerialType</span><span style=\"color:#E1E4E8\">(val)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        serialTypes[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> st</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bodies[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bodySize </span><span style=\"color:#F97583\">+=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(body)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        headerSize </span><span style=\"color:#F97583\">+=</span><span style=\"color:#B392F0\"> VarintSize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(st))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Total header size includes the header size varint itself</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    totalHeaderSize </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> headerSize </span><span style=\"color:#F97583\">+</span><span style=\"color:#B392F0\"> VarintSize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(headerSize </span><span style=\"color:#F97583\">+</span><span style=\"color:#B392F0\"> VarintSize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(headerSize))))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Recalculate with corrected header size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    totalHeaderSize </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> headerSize </span><span style=\"color:#F97583\">+</span><span style=\"color:#B392F0\"> VarintSize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(totalHeaderSize))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate buffer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    totalSize </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> totalHeaderSize </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> bodySize</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, totalSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> WriteVarintTo</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(totalHeaderSize))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, st </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> serialTypes {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#B392F0\"> WriteVarintTo</span><span style=\"color:#E1E4E8\">(buf, offset, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(st))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write body</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, body </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> bodies {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        copy</span><span style=\"color:#E1E4E8\">(buf[offset:], body)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        offset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(body)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> buf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DeserializeRow converts a record (byte slice) back to values.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> DeserializeRow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read header size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    headerSize, offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid record: cannot read header size\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read serial types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> serialTypes []</span><span style=\"color:#B392F0\">SerialType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    headerEnd </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> offset</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(headerEnd) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> headerSize {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        st, bytesRead </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(data, headerEnd)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> bytesRead </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid record: truncated header\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        serialTypes </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(serialTypes, </span><span style=\"color:#B392F0\">SerialType</span><span style=\"color:#E1E4E8\">(st))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        headerEnd </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> bytesRead</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bodyOffset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> headerEnd</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    values </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(serialTypes))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, st </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> serialTypes {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        size </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SerialTypeSize</span><span style=\"color:#E1E4E8\">(st)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> bodyOffset</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">size </span><span style=\"color:#F97583\">></span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(data) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid record: truncated body at column </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, i)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        value, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> DecodeValue</span><span style=\"color:#E1E4E8\">(st, data[bodyOffset:bodyOffset</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">size])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        values[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bodyOffset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> values, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper: WriteVarintTo writes a varint to buf at offset, returns bytes written.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> WriteVarintTo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    v </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> WriteVarint</span><span style=\"color:#E1E4E8\">(value)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(buf[offset:], v)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(v)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"table-b-tree-leaf-cell\">Table B-tree Leaf Cell</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// table_leaf.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Table leaf cell format:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ┌─────────────┬────────────────┬───────────────────┐</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ Payload Size│ Rowid          │ Payload (record)  │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ (varint)    │ (varint)       │ (bytes)           │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// └─────────────┴────────────────┴───────────────────┘</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReadTableLeafCell reads a cell at the given offset.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns (rowid, record, bytesConsumed).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReadTableLeafCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">record</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">consumed</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> offset</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read payload size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payloadSize, n </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(p.data, pos)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid cell: cannot read payload size\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    consumed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> n</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read rowid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowid, n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(p.data, pos)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid cell: cannot read rowid\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    consumed </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read payload</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> pos</span><span style=\"color:#F97583\">+int</span><span style=\"color:#E1E4E8\">(payloadSize) </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> PageSize {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Handle overflow pages (advanced feature)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"payload overflow: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> bytes\"</span><span style=\"color:#E1E4E8\">, payloadSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    record </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, payloadSize)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(record, p.data[pos:pos</span><span style=\"color:#F97583\">+int</span><span style=\"color:#E1E4E8\">(payloadSize)])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    consumed </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(payloadSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> rowid, record, consumed, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WriteTableLeafCell writes a cell at the given offset.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns bytes consumed or error.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">WriteTableLeafCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">record</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> offset</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payloadSize </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(record))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write payload size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    n </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> WriteVarintTo</span><span style=\"color:#E1E4E8\">(p.data, pos, payloadSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write rowid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> WriteVarintTo</span><span style=\"color:#E1E4E8\">(p.data, pos, rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write payload</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(p.data[pos:], record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.isDirty </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> pos </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> offset, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CellSize returns the size needed for a table leaf cell.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TableLeafCellSize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">record</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> VarintSize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(record))) </span><span style=\"color:#F97583\">+</span><span style=\"color:#B392F0\"> VarintSize</span><span style=\"color:#E1E4E8\">(rowid) </span><span style=\"color:#F97583\">+</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"table-b-tree-internal-cell\">Table B-tree Internal Cell</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// table_internal.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Table internal cell format:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ┌─────────────┬────────────────┐</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ Left Child  │ Rowid          │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ (4 bytes)   │ (varint)       │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// └─────────────┴────────────────┘</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReadTableInternalCell reads an internal cell at offset.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReadTableInternalCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#FFAB70\">leftChild</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">consumed</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> offset</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read left child page number</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> pos</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#F97583\"> ></span><span style=\"color:#E1E4E8\"> PageSize {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid cell: truncated left child\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leftChild </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(p.data[pos : pos</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read rowid (separator key)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowid, n </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(p.data, pos)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid cell: cannot read rowid\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> leftChild, rowid, pos </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> offset, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WriteTableInternalCell writes an internal cell at offset.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">WriteTableInternalCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">leftChild</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> offset</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write left child</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(p.data[pos:pos</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">], leftChild)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write rowid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    n </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> WriteVarintTo</span><span style=\"color:#E1E4E8\">(p.data, pos, rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.isDirty </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> pos </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> offset, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FindChildPage returns the child page number for a given rowid.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FindChildPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cellCount </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(p.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Binary search for the correct child</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> cellCount; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cellOffset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">CellPointer</span><span style=\"color:#E1E4E8\">(i)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        _, separatorRowid, _, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">ReadTableInternalCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(cellOffset))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> rowid </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> separatorRowid {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Go to left child of this separator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            leftChild, _, _, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">ReadTableInternalCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(cellOffset))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> leftChild</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Greater than all separators: use rightmost pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">RightMostPointer</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"index-btree-leaf-cell\">Index B+tree Leaf Cell</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// index_leaf.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Index leaf cell format:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ┌─────────────┬────────────────┬───────────────────┐</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ Payload Size│ Payload        │ Rowid             │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ (varint)    │ (indexed vals) │ (varint)          │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// └─────────────┴────────────────┴───────────────────┘</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The payload contains the serialized indexed column values.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// For a single-column index, this is just the column value's serial type + data.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// For a multi-column index, it's the concatenation of all indexed columns.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReadIndexLeafCell reads an index leaf cell.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReadIndexLeafCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">consumed</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> offset</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read payload size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payloadSize, n </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(p.data, pos)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid cell: cannot read payload size\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read payload</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> pos</span><span style=\"color:#F97583\">+int</span><span style=\"color:#E1E4E8\">(payloadSize) </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> PageSize {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"payload overflow: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> bytes\"</span><span style=\"color:#E1E4E8\">, payloadSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, payloadSize)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(payload, p.data[pos:pos</span><span style=\"color:#F97583\">+int</span><span style=\"color:#E1E4E8\">(payloadSize)])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(payloadSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read rowid (at the end for index cells)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowid, n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(p.data, pos)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid cell: cannot read rowid\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> payload, rowid, pos </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> offset, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"btree-structure\">BTree Structure</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// btree.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BTree</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rootPageID  </span><span style=\"color:#B392F0\">PageID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bufferPool  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pager       </span><span style=\"color:#B392F0\">Pager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    isIndex     </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">  // true for index B+tree, false for table B-tree</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Pager</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    AllocatePage</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    FreePage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageID</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewBTree creates a new B-tree with an empty root page.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewBTree</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">bufferPool</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">pager</span><span style=\"color:#B392F0\"> Pager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">isIndex</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BTree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate root page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rootPageID, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> pager.</span><span style=\"color:#B392F0\">AllocatePage</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize as empty leaf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bufferPool.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(rootPageID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> isIndex {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page.Data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> byte</span><span style=\"color:#E1E4E8\">(PageTypeIndexLeaf)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page.Data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> byte</span><span style=\"color:#E1E4E8\">(PageTypeTableLeaf)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Clear rest of header</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> PageHeaderSize; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page.Data[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">BTree</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rootPageID: rootPageID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bufferPool: bufferPool,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pager:      pager,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        isIndex:    isIndex,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Insert adds a row to the table B-tree.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BTree</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">record</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Navigate to the correct leaf page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    path, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">findLeafPage</span><span style=\"color:#E1E4E8\">(rowid)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leafPageID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> path[</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(path)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Fetch the leaf page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.bufferPool.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(leafPageID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate cell size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cellSize </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> TableLeafCellSize</span><span style=\"color:#E1E4E8\">(rowid, record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if cell fits</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> cellSize</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">CellPointerSize </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">FreeSpace</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Need to split</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">splitAndInsert</span><span style=\"color:#E1E4E8\">(path, rowid, record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Insert the cell</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">insertIntoLeaf</span><span style=\"color:#E1E4E8\">(page, rowid, record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"node-splitting\">Node Splitting</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-20.svg\" alt=\"Varint Encoding Algorithm\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// split.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// splitAndInsert handles insertion when the target page is full.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BTree</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">splitAndInsert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">record</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Phase 1: Split the leaf page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leafPageID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> path[</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(path)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leafPage, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.bufferPool.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(leafPageID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> leafPage.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Collect all existing cells plus the new one</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cells </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">collectCells</span><span style=\"color:#E1E4E8\">(leafPage)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cells </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(cells, </span><span style=\"color:#B392F0\">Cell</span><span style=\"color:#E1E4E8\">{rowid: rowid, record: record})</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sortCells</span><span style=\"color:#E1E4E8\">(cells)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate new page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newPageID, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.pager.</span><span style=\"color:#B392F0\">AllocatePage</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newPage, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.bufferPool.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(newPageID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> newPage.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize new page with same type</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(newPage.Data, </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, PageSize))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newPage.Data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> leafPage.Data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate split point (approximately half)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    medianIndex </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(cells) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    medianKey </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cells[medianIndex].rowid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Distribute cells between old and new pages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.</span><span style=\"color:#B392F0\">clearPage</span><span style=\"color:#E1E4E8\">(leafPage)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> medianIndex; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">insertCell</span><span style=\"color:#E1E4E8\">(leafPage, cells[i])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> medianIndex; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(cells); i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">insertCell</span><span style=\"color:#E1E4E8\">(newPage, cells[i])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Phase 2: Insert separator into parent (or create new root)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(path) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Splitting the root - create new root</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">createNewRoot</span><span style=\"color:#E1E4E8\">(leafPageID, newPageID, medianKey)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Insert separator into parent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parentPageID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> path[</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(path)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">insertSeparator</span><span style=\"color:#E1E4E8\">(parentPageID, newPageID, medianKey)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// createNewRoot creates a new root when the current root splits.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BTree</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">createNewRoot</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">leftChild</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rightChild</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">separatorKey</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate new root</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newRootID, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.pager.</span><span style=\"color:#B392F0\">AllocatePage</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newRoot, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.bufferPool.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(newRootID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> newRoot.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize as internal page</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> PageSize; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        newRoot.Data[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newRoot.Data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> byte</span><span style=\"color:#E1E4E8\">(PageTypeTableInt)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set rightmost pointer to right child</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newRoot.</span><span style=\"color:#B392F0\">SetRightMostPointer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32</span><span style=\"color:#E1E4E8\">(rightChild.PageNum))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Insert separator pointing to left child</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cellOffset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> PageSize </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#F97583\"> -</span><span style=\"color:#B392F0\"> VarintSize</span><span style=\"color:#E1E4E8\">(separatorKey)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newRoot.</span><span style=\"color:#B392F0\">WriteTableInternalCell</span><span style=\"color:#E1E4E8\">(cellOffset, </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#E1E4E8\">(leftChild.PageNum), separatorKey)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newRoot.</span><span style=\"color:#B392F0\">SetCellPointer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\">(cellOffset))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newRoot.</span><span style=\"color:#B392F0\">SetCellCount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newRoot.</span><span style=\"color:#B392F0\">SetCellContentStart</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\">(cellOffset))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update tree root</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.rootPageID </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> newRootID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"system-catalog\">System Catalog</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// catalog.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// sqlite_master stores schema information.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Schema:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CREATE TABLE sqlite_master (</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//     type TEXT,        -- 'table', 'index', 'trigger', 'view'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//     name TEXT,        -- Object name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//     tbl_name TEXT,    -- Table name (for indexes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//     rootpage INTEGER, -- Root page number</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//     sql TEXT          -- CREATE statement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> CatalogRootPage</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Catalog</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    btree      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BTree</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bufferPool </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateTable creates a new table and records it in the catalog.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Catalog</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateTable</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">columns</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">ColumnDefinition</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">sql</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate root page for the table's B-tree</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rootPageID, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.btree.pager.</span><span style=\"color:#B392F0\">AllocatePage</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">{}, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize as empty table leaf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.bufferPool.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(rootPageID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">{}, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> PageSize; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page.Data[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page.Data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> byte</span><span style=\"color:#E1E4E8\">(PageTypeTableLeaf)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Insert into sqlite_master</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SerializeRow</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"table\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        name,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int64</span><span style=\"color:#E1E4E8\">(rootPageID.PageNum),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sql,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Generate rowid for catalog entry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowid </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">generateRowid</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> c.btree.</span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(rowid, record)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">{}, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> rootPageID, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetTableRootPage looks up a table's root page number.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Catalog</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetTableRootPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">uint32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.btree.</span><span style=\"color:#B392F0\">NewCursor</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor.</span><span style=\"color:#B392F0\">First</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">cursor.</span><span style=\"color:#B392F0\">AtEnd</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rowid, record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cursor.</span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        values, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> DeserializeRow</span><span style=\"color:#E1E4E8\">(record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(values) </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            objType </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> values[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].(</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            objName </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> values[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">].(</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> objType </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"table\"</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> objName </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> name {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                rootPage </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> values[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">].(</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">(rootPage), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"no such table: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"free-space-management\">Free Space Management</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// freeblock.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Freeblock format:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ┌─────────────┬────────────────┐</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ Next Offset │ Size           │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ (2 bytes)   │ (2 bytes)      │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// └─────────────┴────────────────┘</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Followed by (Size - 4) bytes of free space</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> FreeblockHeaderSize</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 4</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AllocateCell finds space for a cell of the given size.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns the offset where the cell can be written.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AllocateCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">size</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if there's enough contiguous free space</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">FreeSpace</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> size</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">CellPointerSize {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"insufficient space\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Try to allocate from cell content area</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    contentStart </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(p.</span><span style=\"color:#B392F0\">CellContentStart</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> contentStart </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PageSize {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        contentStart </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PageSize</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newContentStart </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> contentStart </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pointerArrayEnd </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">headerSize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(p.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">())</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">CellPointerSize</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> newContentStart </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> pointerArrayEnd {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">SetCellContentStart</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\">(newContentStart))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> newContentStart, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Try to allocate from freeblock list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">allocateFromFreeblock</span><span style=\"color:#E1E4E8\">(size)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> offset, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Need to defragment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.</span><span style=\"color:#B392F0\">defragment</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Retry allocation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    contentStart </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(p.</span><span style=\"color:#B392F0\">CellContentStart</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newContentStart </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> contentStart </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pointerArrayEnd </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">headerSize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(p.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">())</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">CellPointerSize</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> newContentStart </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> pointerArrayEnd {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.</span><span style=\"color:#B392F0\">SetCellContentStart</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\">(newContentStart))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> newContentStart, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"insufficient space after defragmentation\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// defragment reorganizes the page to consolidate free space.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">defragment</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read all cells</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    type</span><span style=\"color:#B392F0\"> cellEntry</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        offset </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        data   []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> cells []</span><span style=\"color:#B392F0\">cellEntry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(p.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">()); i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(p.</span><span style=\"color:#B392F0\">CellPointer</span><span style=\"color:#E1E4E8\">(i))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Read cell data (simplified - would need to read actual cell size)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cells </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(cells, </span><span style=\"color:#B392F0\">cellEntry</span><span style=\"color:#E1E4E8\">{offset: offset})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Rebuild page from scratch</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tempPage </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, PageSize)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(tempPage[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">:p.</span><span style=\"color:#B392F0\">headerSize</span><span style=\"color:#E1E4E8\">()], p.data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">:p.</span><span style=\"color:#B392F0\">headerSize</span><span style=\"color:#E1E4E8\">()])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write cells contiguously from end</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    contentStart </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> PageSize</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, cell </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> cells {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Copy cell data to new position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // (implementation would read and write actual cell bytes)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        newOffset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> contentStart </span><span style=\"color:#F97583\">-</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(cell.data)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        copy</span><span style=\"color:#E1E4E8\">(tempPage[newOffset:contentStart], cell.data)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Update pointer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ptrOffset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">headerSize</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> i</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">CellPointerSize</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint16</span><span style=\"color:#E1E4E8\">(tempPage[ptrOffset:ptrOffset</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\">(newOffset))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        contentStart </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> newOffset</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint16</span><span style=\"color:#E1E4E8\">(tempPage[</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\">(contentStart))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tempPage[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#6A737D\"> // Clear freeblock pointer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tempPage[</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#6A737D\"> // Clear fragmented bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(p.data, tempPage)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.isDirty </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"interface-contracts\">Interface Contracts</h2>\n<h3 id=\"page-creation-and-initialization\">Page Creation and Initialization</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// NewPage creates a Page handle for existing data.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">pageID</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// InitializeLeafPage sets up a page as an empty leaf.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">InitializeLeafPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageType</span><span style=\"color:#B392F0\"> PageType</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// InitializeInternalPage sets up a page as an empty internal page.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">InitializeInternalPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageType</span><span style=\"color:#B392F0\"> PageType</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h3 id=\"cell-operations\">Cell Operations</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// InsertCell inserts a cell and updates the pointer array.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The pointer array is kept sorted by key.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">InsertCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cellData</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">key</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DeleteCell removes a cell at the given index.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DeleteCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">index</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FindCell returns the index where a cell with the given key would be inserted.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Also returns true if an exact match is found.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FindCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">key</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#FFAB70\">index</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">found</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h3 id=\"btree-operations\">BTree Operations</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Insert adds a record to the table B-tree at the specified rowid.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Handles node splitting if necessary.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BTree</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">record</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Delete removes the record at the specified rowid.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BTree</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Delete</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Fetch retrieves the record at the specified rowid.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns nil if not found.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BTree</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Fetch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Scan returns a cursor for iterating all records in rowid order.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BTree</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Scan</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Cursor</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"algorithm-specification\">Algorithm Specification</h2>\n<h3 id=\"insert-cell-into-page\">Insert Cell into Page</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: InsertCell\nINPUT: Page p, cellData []byte, key int64\nOUTPUT: error\n\n1. CALCULATE CELL SIZE\n   cellSize := len(cellData)\n   totalSize := cellSize + CellPointerSize\n\n2. CHECK AVAILABLE SPACE\n   IF p.FreeSpace() &lt; totalSize:\n     RETURN InsufficientSpaceError\n\n3. ALLOCATE CELL STORAGE\n   offset, err := p.AllocateCell(cellSize)\n   IF err != nil:\n     RETURN err\n\n4. WRITE CELL DATA\n   copy(p.data[offset:offset+cellSize], cellData)\n\n5. FIND INSERTION POINT\n   insertIndex, _ := p.FindCell(key)\n\n6. SHIFT POINTER ARRAY\n   // Make room for new pointer\n   FOR i := p.CellCount() - 1; i &gt;= insertIndex; i--:\n     p.SetCellPointer(i+1, p.CellPointer(i))\n\n7. INSERT NEW POINTER\n   p.SetCellPointer(insertIndex, uint16(offset))\n\n8. UPDATE CELL COUNT\n   p.SetCellCount(p.CellCount() + 1)\n\n9. RETURN nil</code></pre></div>\n\n<h3 id=\"find-leaf-page-for-key\">Find Leaf Page for Key</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: findLeafPage\nINPUT: BTree t, key int64\nOUTPUT: []PageID (path from root to leaf)\n\n1. path := empty list\n   pageID := t.rootPageID\n\n2. WHILE true:\n     a. APPEND pageID to path\n     b. page, err := t.bufferPool.FetchPage(pageID)\n        IF err != nil:\n          RETURN nil, err\n     \n     c. IF page.Type().IsLeaf():\n          page.Unpin(false)\n          RETURN path, nil\n     \n     d. // Internal page: find correct child\n        childPageNum := page.FindChildPage(key)\n        page.Unpin(false)\n        \n        pageID = PageID{PageNum: int(childPageNum)}</code></pre></div>\n\n<h3 id=\"full-table-scan\">Full Table Scan</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: FullTableScan\nINPUT: BTree t\nOUTPUT: Iterator yielding (rowid, record) pairs\n\n1. // Navigate to leftmost leaf\n   path := findLeftmostLeaf(t)\n   pageID := path[len(path)-1]\n\n2. // Iterate through leaves\n   WHILE pageID.IsValid():\n     a. page, err := t.bufferPool.FetchPage(pageID)\n        IF err != nil:\n          YIELD error\n          RETURN\n     \n     b. // Process all cells in this leaf\n        FOR i := 0; i &lt; page.CellCount(); i++:\n          offset := page.CellPointer(i)\n          rowid, record, _, _ := page.ReadTableLeafCell(int(offset))\n          YIELD (rowid, record)\n     \n     c. // Move to next leaf\n        // (SQLite table B-trees don't link leaves; navigate via parent)\n        // Simplified: assume no leaf linking\n        pageID = PageID{} // End of scan\n        page.Unpin(false)\n\n3. RETURN</code></pre></div>\n\n<hr>\n<h2 id=\"error-handling-matrix\">Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th>Error</th>\n<th>Detected By</th>\n<th>Recovery</th>\n<th>User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Page overflow (row &gt; usable page size)</td>\n<td><code>AllocateCell</code></td>\n<td>Return error, suggest overflow pages</td>\n<td>Yes: &quot;row too large: X bytes exceeds limit&quot;</td>\n</tr>\n<tr>\n<td>Corrupted page header</td>\n<td><code>Type()</code> validation</td>\n<td>Return error, refuse to operate</td>\n<td>Yes: &quot;corrupted page header: invalid type byte&quot;</td>\n</tr>\n<tr>\n<td>Invalid cell pointer (offset out of bounds)</td>\n<td><code>CellPointer</code> bounds check</td>\n<td>Return error</td>\n<td>Yes: &quot;invalid cell pointer: offset X exceeds page size&quot;</td>\n</tr>\n<tr>\n<td>Varint truncation</td>\n<td><code>ReadVarint</code> EOF check</td>\n<td>Return error</td>\n<td>Yes: &quot;truncated varint at offset X&quot;</td>\n</tr>\n<tr>\n<td>Serial type mismatch</td>\n<td><code>DecodeValue</code> type validation</td>\n<td>Return NULL value, log warning</td>\n<td>No (graceful degradation)</td>\n</tr>\n<tr>\n<td>Node split cascades to root</td>\n<td><code>splitAndInsert</code> recursion</td>\n<td>Create new root, increase tree height</td>\n<td>No (internal operation)</td>\n</tr>\n<tr>\n<td>Freeblock list corruption</td>\n<td><code>allocateFromFreeblock</code> cycle detection</td>\n<td>Defragment page</td>\n<td>No (auto-recovery)</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"implementation-sequence-with-checkpoints\">Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-page-header-and-slotted-format-2-hours\">Phase 1: Page Header and Slotted Format (2 hours)</h3>\n<p><strong>Files to create</strong>: <code>page.go</code>, <code>page_type.go</code>, <code>cell.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Define <code>PageType</code> constants and validation</li>\n<li>Implement <code>Page</code> struct with header accessors</li>\n<li>Implement cell pointer array operations</li>\n<li>Implement <code>FreeSpace()</code> calculation</li>\n<li>Add basic page initialization</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should be able to create and initialize pages. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestPageHeader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (header read/write works)</span></span></code></pre></div>\n\n<h3 id=\"phase-2-varint-encodingdecoding-1-hour\">Phase 2: Varint Encoding/Decoding (1 hour)</h3>\n<p><strong>Files to create</strong>: <code>varint.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>ReadVarint</code> for all 9 encoding types</li>\n<li>Implement <code>WriteVarint</code> for all value ranges</li>\n<li>Implement <code>VarintSize</code> helper</li>\n<li>Add boundary tests for each encoding size</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should pass varint tests. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestVarint</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (all encoding sizes work correctly)</span></span></code></pre></div>\n\n<h3 id=\"phase-3-record-serialization-with-serial-types-2-hours\">Phase 3: Record Serialization with Serial Types (2 hours)</h3>\n<p><strong>Files to create</strong>: <code>serial_type.go</code>, <code>record.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Define serial type constants</li>\n<li>Implement <code>EncodeSerialType</code> for all Go types</li>\n<li>Implement <code>DecodeValue</code> for all serial types</li>\n<li>Implement <code>SerializeRow</code> and <code>DeserializeRow</code></li>\n<li>Handle NULL, zero, one as special cases</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should serialize/deserialize rows. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestRecord</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (round-trip serialization works)</span></span></code></pre></div>\n\n<h3 id=\"phase-4-table-b-tree-leaf-and-internal-pages-2-hours\">Phase 4: Table B-tree Leaf and Internal Pages (2 hours)</h3>\n<p><strong>Files to create</strong>: <code>table_leaf.go</code>, <code>table_internal.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>ReadTableLeafCell</code> and <code>WriteTableLeafCell</code></li>\n<li>Implement <code>ReadTableInternalCell</code> and <code>WriteTableInternalCell</code></li>\n<li>Implement <code>FindChildPage</code> for internal pages</li>\n<li>Add cell size calculation helpers</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should read/write cells. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestTableLeaf</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestTableInternal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (cell operations work)</span></span></code></pre></div>\n\n<h3 id=\"phase-5-index-btree-pages-15-hours\">Phase 5: Index B+tree Pages (1.5 hours)</h3>\n<p><strong>Files to create</strong>: <code>index_leaf.go</code>, <code>index_internal.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>ReadIndexLeafCell</code> and <code>WriteIndexLeafCell</code></li>\n<li>Implement index internal cell operations</li>\n<li>Handle leaf page linking (right-sibling pointer)</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should handle index pages. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestIndexLeaf</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (index cell format correct)</span></span></code></pre></div>\n\n<h3 id=\"phase-6-node-splitting-and-separator-promotion-2-hours\">Phase 6: Node Splitting and Separator Promotion (2 hours)</h3>\n<p><strong>Files to create</strong>: <code>split.go</code>, <code>btree.go</code>, <code>btree_cursor.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>splitAndInsert</code> for leaf pages</li>\n<li>Implement <code>createNewRoot</code></li>\n<li>Implement <code>insertSeparator</code> into parent</li>\n<li>Handle cascading splits</li>\n<li>Implement cursor for tree traversal</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should handle inserts with splits. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestNodeSplit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (splits maintain tree balance)</span></span></code></pre></div>\n\n<h3 id=\"phase-7-system-catalog-15-hours\">Phase 7: System Catalog (1.5 hours)</h3>\n<p><strong>Files to create</strong>: <code>catalog.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>sqlite_master</code> schema</li>\n<li>Implement <code>CreateTable</code> with catalog update</li>\n<li>Implement <code>GetTableRootPage</code> lookup</li>\n<li>Implement <code>CreateIndex</code> catalog entry</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should pass the full test suite. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> ./storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: All tests PASS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify: 50-200 rows per leaf page</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify: O(log n) lookup for 10K rows</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"test-specification\">Test Specification</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// storage_test.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestPageHeader</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, PageSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewPage</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize as table leaf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page.</span><span style=\"color:#B392F0\">InitializeLeafPage</span><span style=\"color:#E1E4E8\">(PageTypeTableLeaf)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, PageTypeTableLeaf, page.</span><span style=\"color:#B392F0\">Type</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">), page.</span><span style=\"color:#B392F0\">FirstFreeblock</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">), page.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\">(PageSize), page.</span><span style=\"color:#B392F0\">CellContentStart</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestVarintEncoding</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        value    </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00</span><span style=\"color:#E1E4E8\">}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#79B8FF\">127</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">7F</span><span style=\"color:#E1E4E8\">}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">81</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00</span><span style=\"color:#E1E4E8\">}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#79B8FF\">16383</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">BF</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">FF</span><span style=\"color:#E1E4E8\">}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#79B8FF\">16384</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">C1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00</span><span style=\"color:#E1E4E8\">}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#79B8FF\">2097151</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">DF</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">FF</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">FF</span><span style=\"color:#E1E4E8\">}},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">append</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">FF</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, tc </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> tests {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        encoded </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> WriteVarint</span><span style=\"color:#E1E4E8\">(tc.value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, tc.expected, encoded)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        decoded, bytesRead </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(encoded, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, tc.value, decoded)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(encoded), bytesRead)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestRecordSerialization</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    values </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">42</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"hello world\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        nil</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        3.14159</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">01</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">02</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">03</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SerializeRow</span><span style=\"color:#E1E4E8\">(values)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    decoded, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> DeserializeRow</span><span style=\"color:#E1E4E8\">(record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">42</span><span style=\"color:#E1E4E8\">), decoded[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#9ECBFF\">\"hello world\"</span><span style=\"color:#E1E4E8\">, decoded[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Nil</span><span style=\"color:#E1E4E8\">(t, decoded[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">InDelta</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">3.14159</span><span style=\"color:#E1E4E8\">, decoded[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">0.00001</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">01</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">02</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">03</span><span style=\"color:#E1E4E8\">}, decoded[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestTableLeafCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, PageSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewPage</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page.</span><span style=\"color:#B392F0\">InitializeLeafPage</span><span style=\"color:#E1E4E8\">(PageTypeTableLeaf)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SerializeRow</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"Alice\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">30</span><span style=\"color:#E1E4E8\">)})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write cell</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cellSize </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> TableLeafCellSize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">AllocateCell</span><span style=\"color:#E1E4E8\">(cellSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">WriteTableLeafCell</span><span style=\"color:#E1E4E8\">(offset, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read cell back</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowid, readRecord, _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">ReadTableLeafCell</span><span style=\"color:#E1E4E8\">(offset)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, record, readRecord)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestNodeSplit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bufferPool </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMockBufferPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pager </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMockPager</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    btree, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewBTree</span><span style=\"color:#E1E4E8\">(bufferPool, pager, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Insert enough rows to trigger splits</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SerializeRow</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(i), fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"user</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, i)})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> btree.</span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(i), record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify all rows are retrievable</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    count </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> btree.</span><span style=\"color:#B392F0\">Scan</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">cursor.</span><span style=\"color:#B392F0\">AtEnd</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        _, _ </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cursor.</span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        count</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, count)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestCatalog</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bufferPool </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMockBufferPool</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pager </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewMockPager</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create catalog on page 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    catalogBTree, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewBTree</span><span style=\"color:#E1E4E8\">(bufferPool, pager, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    catalog </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Catalog</span><span style=\"color:#E1E4E8\">{btree: catalogBTree, bufferPool: bufferPool}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create a table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rootPage, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> catalog.</span><span style=\"color:#B392F0\">CreateTable</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#B392F0\">ColumnDefinition</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {Name: </span><span style=\"color:#9ECBFF\">\"id\"</span><span style=\"color:#E1E4E8\">, Type: </span><span style=\"color:#9ECBFF\">\"INTEGER\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {Name: </span><span style=\"color:#9ECBFF\">\"name\"</span><span style=\"color:#E1E4E8\">, Type: </span><span style=\"color:#9ECBFF\">\"TEXT\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#9ECBFF\">\"CREATE TABLE users (id INTEGER, name TEXT)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">True</span><span style=\"color:#E1E4E8\">(t, rootPage.</span><span style=\"color:#B392F0\">IsValid</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Look up the table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    foundRootPage, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> catalog.</span><span style=\"color:#B392F0\">GetTableRootPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#E1E4E8\">(rootPage.PageNum), foundRootPage)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Look up non-existent table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> catalog.</span><span style=\"color:#B392F0\">GetTableRootPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"nonexistent\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(t, err.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#9ECBFF\">\"no such table\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestRowsPerPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify 50-200 rows per leaf page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, PageSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewPage</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page.</span><span style=\"color:#B392F0\">InitializeLeafPage</span><span style=\"color:#E1E4E8\">(PageTypeTableLeaf)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Insert small rows</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 200</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SerializeRow</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(i), fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"user</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, i)})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cellSize </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> TableLeafCellSize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(i), record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        offset, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">AllocateCell</span><span style=\"color:#E1E4E8\">(cellSize)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#6A737D\"> // Page full</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page.</span><span style=\"color:#B392F0\">WriteTableLeafCell</span><span style=\"color:#E1E4E8\">(offset, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(i), record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page.</span><span style=\"color:#B392F0\">SetCellCount</span><span style=\"color:#E1E4E8\">(page.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should have at least 50 rows</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">GreaterOrEqual</span><span style=\"color:#E1E4E8\">(t, page.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">50</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should not exceed 200 rows</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">LessOrEqual</span><span style=\"color:#E1E4E8\">(t, page.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#F97583\">uint16</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-targets\">Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Target</th>\n<th>How to Measure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Rows per leaf page</td>\n<td>50-200</td>\n<td><code>go test -run TestRowsPerPage</code></td>\n</tr>\n<tr>\n<td>Point lookup (B-tree seek)</td>\n<td>O(log n), &lt; 1ms for 1M rows</td>\n<td><code>go test -bench=BenchmarkLookup</code></td>\n</tr>\n<tr>\n<td>Node split</td>\n<td>&lt; 1ms</td>\n<td><code>go test -bench=BenchmarkSplit</code></td>\n</tr>\n<tr>\n<td>Full table scan</td>\n<td>O(n), &gt; 100K rows/sec</td>\n<td><code>go test -bench=BenchmarkScan</code></td>\n</tr>\n<tr>\n<td>Varint encode/decode</td>\n<td>&lt; 50ns per operation</td>\n<td><code>go test -bench=BenchmarkVarint</code></td>\n</tr>\n<tr>\n<td>Record serialize</td>\n<td>&lt; 500ns per row</td>\n<td><code>go test -bench=BenchmarkSerialize</code></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"synced-criteria\">Synced Criteria</h2>\n<p>}]</p>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-sqlite-m6 -->\n<h1 id=\"technical-design-specification-select-execution-amp-dml\">Technical Design Specification: SELECT Execution &amp; DML</h1>\n<h2 id=\"module-charter\">Module Charter</h2>\n<p>The SELECT Execution &amp; DML module implements the runtime execution layer that processes bytecode programs generated by the compiler, performing actual data manipulation against B-tree storage. It provides cursor-based B-tree traversal for sequential and positioned access, row deserialization with lazy column extraction, expression evaluation with SQL three-valued logic (TRUE/FALSE/NULL), projection of selected columns, and constraint enforcement (NOT NULL validation, table existence checks). The module does NOT perform query optimization, manage transaction isolation, or handle storage allocation—it executes the plan provided by the compiler. Upstream dependencies: Bytecode Compiler (provides instruction programs), Storage layer (B-trees, buffer pool). Downstream dependencies: Result callback handlers (for SELECT output), Transaction manager (for DML coordination). Invariants: cursor positions remain valid only while page is pinned; NULL comparisons always produce NULL (never TRUE or FALSE); NOT NULL constraints are checked before any write operation; deleted rows are immediately removed from B-tree structure.</p>\n<hr>\n<h2 id=\"file-structure\">File Structure</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>execution/\n├── cursor.go           # (1) Cursor struct with B-tree position state\n├── cursor_scan.go      # (2) Sequential scan operations (First, Next, AtEnd)\n├── cursor_seek.go      # (3) Positioned access (SeekRowid, SeekRange)\n├── value.go            # (4) Value type with NULL representation\n├── three_valued.go     # (5) Three-valued logic operators (AND, OR, NOT, comparison)\n├── expression_eval.go  # (6) Expression evaluation with TVL\n├── column_access.go    # (7) Lazy column deserialization from records\n├── select_exec.go      # (8) SELECT execution handlers (Column, ResultRow)\n├── insert_exec.go      # (9) INSERT execution with constraint checking\n├── update_exec.go      # (10) UPDATE execution (delete + reinsert pattern)\n├── delete_exec.go      # (11) DELETE execution\n├── constraint.go       # (12) Constraint validation (NOT NULL, table existence)\n├── projection.go       # (13) Column projection logic\n├── execution_test.go   # (14) Comprehensive test suite\n└── vm/\n    └── opcodes.go      # (15) VM opcode handlers calling execution layer</code></pre></div>\n\n<hr>\n<h2 id=\"complete-data-model\">Complete Data Model</h2>\n<h3 id=\"value-type-with-null-handling\">Value Type with NULL Handling</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// value.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ValueType</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ValueNull</span><span style=\"color:#B392F0\"> ValueType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ValueInteger</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ValueReal</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ValueText</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ValueBlob</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type  </span><span style=\"color:#B392F0\">ValueType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Int   </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Float </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Str   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Bytes []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IsNull returns true if this value is NULL.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">v </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsNull</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> v.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ValueNull</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IsTruthy returns true if value is TRUE in three-valued logic.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Only non-zero, non-NULL values are truthy.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NULL is NOT truthy (but also NOT false - it's unknown).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">v </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsTruthy</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> v.Type {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueNull:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueInteger:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> v.Int </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueReal:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> v.Float </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueText:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(v.Str) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueBlob:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(v.Bytes) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ToFloat converts integer to float for mixed-type comparisons.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">v </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ToFloat</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> v.Type {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueInteger:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(v.Int)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueReal:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> v.Float</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// String returns a human-readable representation.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">v </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> v.Type {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueNull:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"NULL\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueInteger:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, v.Int)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueReal:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, v.Float)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueText:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> v.Str</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueBlob:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"X'</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\">'\"</span><span style=\"color:#E1E4E8\">, v.Bytes)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"UNKNOWN\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY Value type:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Uniform representation for all SQL values including NULL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - NULL is a distinct type, not a nil pointer (avoids nil checks everywhere)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Type field enables correct comparison semantics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - IsTruthy implements three-valued logic for WHERE clauses</span></span></code></pre></div>\n\n<h3 id=\"cursor-state\">Cursor State</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// cursor.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Cursor</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID           </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">        // Cursor identifier (matches bytecode P1)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Tree         </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BTree</span><span style=\"color:#6A737D\">     // B-tree being traversed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CurrentPage  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#6A737D\">      // Currently loaded page (pinned)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PageID       </span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#6A737D\">     // Current page identifier</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CellIndex    </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">        // Current cell within page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Rowid        </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">      // Current row's rowid (cached for performance)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Record       []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\">     // Current row's serialized record</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AtEnd        </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">       // True when cursor has no more rows</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IsWritable   </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">       // True for write cursors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewCursor creates a cursor for traversing a B-tree.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewCursor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">tree</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">BTree</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">writable</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Cursor</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Cursor</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ID:         id,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Tree:       tree,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        IsWritable: writable,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Current returns the current row's rowid and record.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Panics if cursor is at end.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Cursor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">record</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> c.AtEnd {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"cursor at end\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> c.Rowid, c.Record</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY Cursor:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Encapsulates B-tree position state for VM</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Caches current rowid and record for repeated column access</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - AtEnd flag enables clean loop termination</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Writable flag controls whether cursor can modify data</span></span></code></pre></div>\n\n<h3 id=\"three-valued-logic-operators\">Three-Valued Logic Operators</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// three_valued.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TVLBool represents three-valued logic result.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TVLBool</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TVLFalse</span><span style=\"color:#B392F0\"> TVLBool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TVLTrue</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TVLNull</span><span style=\"color:#6A737D\">  // Unknown</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CompareResult represents comparison outcome.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CompareResult</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CompareLess</span><span style=\"color:#B392F0\">    CompareResult</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CompareEqual</span><span style=\"color:#B392F0\">   CompareResult</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CompareGreater</span><span style=\"color:#B392F0\"> CompareResult</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CompareNull</span><span style=\"color:#B392F0\">    CompareResult</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#6A737D\">  // Incomparable (NULL involved)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CompareValues compares two SQL values with three-valued logic.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns CompareNull if either value is NULL.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> CompareValues</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">left</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">right</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CompareResult</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // NULL compared to anything is NULL (incomparable)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> left.</span><span style=\"color:#B392F0\">IsNull</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> right.</span><span style=\"color:#B392F0\">IsNull</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> CompareNull</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Type coercion: promote to float if either is float</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> left.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ValueReal </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> right.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ValueReal {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lv </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> left.</span><span style=\"color:#B392F0\">ToFloat</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rv </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> right.</span><span style=\"color:#B392F0\">ToFloat</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> lv </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> rv {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> CompareLess</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> lv </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> rv {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> CompareGreater</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> CompareEqual</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Integer comparison</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> left.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ValueInteger </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> right.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ValueInteger {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> left.Int </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> right.Int {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> CompareLess</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> left.Int </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> right.Int {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> CompareGreater</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> CompareEqual</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Text comparison</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> left.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ValueText </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> right.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ValueText {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> left.Str </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> right.Str {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> CompareLess</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> left.Str </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> right.Str {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> CompareGreater</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> CompareEqual</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Blob comparison (lexicographic)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> left.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ValueBlob </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> right.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ValueBlob {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cmp </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bytes.</span><span style=\"color:#B392F0\">Compare</span><span style=\"color:#E1E4E8\">(left.Bytes, right.Bytes)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> CompareResult</span><span style=\"color:#E1E4E8\">(cmp)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> CompareNull</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TVLAnd implements three-valued AND.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Truth table:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   AND | TRUE  | FALSE | NULL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   ----+-------+-------+------</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   TRUE| TRUE  | FALSE | NULL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   FALS| FALSE | FALSE | FALSE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   NULL| NULL  | FALSE | NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TVLAnd</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">left</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">right</span><span style=\"color:#B392F0\"> TVLBool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TVLBool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // FALSE dominates: any FALSE makes result FALSE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> left </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> TVLFalse </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> right </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> TVLFalse {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> TVLFalse</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // NULL propagates if no FALSE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> left </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> TVLNull </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> right </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> TVLNull {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> TVLNull</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TRUE AND TRUE = TRUE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> TVLTrue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TVLOr implements three-valued OR.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Truth table:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   OR  | TRUE  | FALSE | NULL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   ----+-------+-------+------</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   TRUE| TRUE  | TRUE  | TRUE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   FALS| TRUE  | FALSE | NULL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   NULL| TRUE  | NULL  | NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TVLOr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">left</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">right</span><span style=\"color:#B392F0\"> TVLBool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TVLBool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TRUE dominates: any TRUE makes result TRUE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> left </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> TVLTrue </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> right </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> TVLTrue {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> TVLTrue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // NULL propagates if no TRUE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> left </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> TVLNull </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> right </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> TVLNull {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> TVLNull</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // FALSE OR FALSE = FALSE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> TVLFalse</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TVLNot implements three-valued NOT.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NOT(TRUE) = FALSE, NOT(FALSE) = TRUE, NOT(NULL) = NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TVLNot</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">operand</span><span style=\"color:#B392F0\"> TVLBool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TVLBool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> operand {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> TVLTrue:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> TVLFalse</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> TVLFalse:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> TVLTrue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> TVLNull:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> TVLNull</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> TVLNull</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY three-valued logic:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - SQL NULL means \"unknown\", not \"missing\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - NULL = NULL is NULL (unknown), not TRUE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - WHERE only keeps rows where predicate is TRUE (not NULL or FALSE)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - AND/OR have special short-circuit semantics with NULL</span></span></code></pre></div>\n\n<h3 id=\"column-access-with-lazy-deserialization\">Column Access with Lazy Deserialization</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// column_access.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ColumnCache stores deserialized column values to avoid re-parsing.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ColumnCache</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    record      []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\">          // Original serialized record</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    serialTypes []</span><span style=\"color:#B392F0\">SerialType</span><span style=\"color:#6A737D\">    // Parsed serial types</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offsets     []</span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">           // Byte offset of each column in record body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    values      []</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#6A737D\">         // Lazily deserialized values (nil if not yet accessed)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    valid       </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">            // True if cache has been populated</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewColumnCache creates an empty cache.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewColumnCache</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ColumnCache</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ColumnCache</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        values: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetRecord initializes the cache with a new record.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ColumnCache</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetRecord</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">record</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cc.record </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> record</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cc.serialTypes </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cc.offsets </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cc.values </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cc.valid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// parseHeader extracts serial types and calculates column offsets.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ColumnCache</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">parseHeader</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> cc.valid {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(cc.record) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"empty record\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read header size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    headerSize, offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(cc.record, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid record: cannot read header size\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read serial types</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cc.serialTypes </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">SerialType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    headerEnd </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> offset</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(headerEnd) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> headerSize {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        st, bytesRead </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(cc.record, headerEnd)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> bytesRead </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid record: truncated header\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cc.serialTypes </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(cc.serialTypes, </span><span style=\"color:#B392F0\">SerialType</span><span style=\"color:#E1E4E8\">(st))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        headerEnd </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> bytesRead</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate offsets for each column</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cc.offsets </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(cc.serialTypes))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cc.values </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(cc.serialTypes))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bodyOffset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> headerEnd</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, st </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> cc.serialTypes {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cc.offsets[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> bodyOffset</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bodyOffset </span><span style=\"color:#F97583\">+=</span><span style=\"color:#B392F0\"> SerialTypeSize</span><span style=\"color:#E1E4E8\">(st)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cc.valid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetColumn retrieves a column value, deserializing lazily.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// First access parses the header; subsequent accesses are O(1).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ColumnCache</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetColumn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">colIndex</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cc.</span><span style=\"color:#B392F0\">parseHeader</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: ValueNull}, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> colIndex </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> colIndex </span><span style=\"color:#F97583\">>=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(cc.serialTypes) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: ValueNull}, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"column index </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> out of range\"</span><span style=\"color:#E1E4E8\">, colIndex)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return cached value if already deserialized</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> cc.values[colIndex].Type </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> ValueNull </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> cc.serialTypes[colIndex] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SerialTypeNull {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> cc.values[colIndex], </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Deserialize the column</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    st </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cc.serialTypes[colIndex]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cc.offsets[colIndex]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    size </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SerialTypeSize</span><span style=\"color:#E1E4E8\">(st)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    value, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> DecodeValue</span><span style=\"color:#E1E4E8\">(st, cc.record[offset:offset</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">size])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: ValueNull}, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Convert to Value type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> value.(</span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cc.values[colIndex] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: ValueNull}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cc.values[colIndex] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: ValueInteger, Int: v}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cc.values[colIndex] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: ValueReal, Float: v}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cc.values[colIndex] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: ValueText, Str: v}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cc.values[colIndex] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: ValueBlob, Bytes: v}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> cc.values[colIndex], </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ColumnCount returns the number of columns in the current record.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ColumnCache</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ColumnCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cc.</span><span style=\"color:#B392F0\">parseHeader</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(cc.serialTypes)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY lazy column access:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Column N deserialization requires parsing columns 0..N-1 offsets</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Caching avoids re-parsing for repeated access</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - SELECT col50 FROM table only pays cost for col50, not all 50</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - First access O(n), subsequent accesses O(1)</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"interface-contracts\">Interface Contracts</h2>\n<h3 id=\"cursor-operations\">Cursor Operations</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// First positions the cursor at the first row (leftmost leaf, first cell).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns error if B-tree is empty or page fetch fails.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// After call, AtEnd is false if rows exist, true if table is empty.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Cursor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">First</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Next advances the cursor to the next row in rowid order.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns error if page fetch fails.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Sets AtEnd to true when no more rows exist.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Cursor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SeekRowid positions the cursor at the row with the given rowid.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns true if found, false if not found.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// If not found, cursor position is undefined (caller should not read).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Cursor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SeekRowid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#FFAB70\">found</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Close releases resources held by the cursor.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Unpins any held pages.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Cursor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span></code></pre></div>\n\n<h3 id=\"expression-evaluation\">Expression Evaluation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// EvaluateExpression evaluates an AST expression against a row.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns TVLBool for boolean expressions, Value for other expressions.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Context provides column access via ColumnCache.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> EvaluateExpression</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#B392F0\"> Expression</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">cache</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ColumnCache</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EvaluatePredicate evaluates a boolean expression for WHERE clause.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns TVLTrue if row passes filter, TVLFalse or TVLNull if not.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> EvaluatePredicate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">expr</span><span style=\"color:#B392F0\"> Expression</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">cache</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ColumnCache</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TVLBool</span></span></code></pre></div>\n\n<h3 id=\"execution-handlers\">Execution Handlers</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ExecuteColumn handles OpColumn: reads a column into a register.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Uses cursor's current row and column cache for lazy deserialization.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">vm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VM</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ExecuteColumn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">instr</span><span style=\"color:#B392F0\"> Instruction</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ExecuteResultRow handles OpResultRow: outputs current result row.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Calls the Output callback with register values.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">vm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VM</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ExecuteResultRow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">instr</span><span style=\"color:#B392F0\"> Instruction</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ExecuteInsert handles OpInsert: inserts a row into a table.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Checks NOT NULL constraints before insertion.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">vm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VM</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ExecuteInsert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">instr</span><span style=\"color:#B392F0\"> Instruction</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ExecuteDelete handles OpDelete: deletes the current row.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">vm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VM</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ExecuteDelete</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">instr</span><span style=\"color:#B392F0\"> Instruction</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"algorithm-specification\">Algorithm Specification</h2>\n<h3 id=\"cursor-first-navigate-to-leftmost-row\">Cursor First (Navigate to Leftmost Row)</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-23.svg\" alt=\"Three-Valued Logic Truth Tables\"></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: Cursor.First\nINPUT: Cursor c with B-tree reference\nOUTPUT: Cursor positioned at first row, or AtEnd=true if empty\n\n1. // Start at root\n   pageID := c.Tree.RootPageID\n\n2. // Navigate to leftmost leaf\n   WHILE true:\n     a. page, err := c.Tree.BufferPool.FetchPage(pageID)\n        IF err != nil:\n          RETURN err\n     \n     b. pageType := page.Type()\n     \n     c. IF pageType.IsLeaf():\n        // Found leaf - position at first cell\n        c.CurrentPage = page\n        c.PageID = pageID\n        c.CellIndex = 0\n        \n        IF page.CellCount() == 0:\n          // Empty table\n          c.AtEnd = true\n          page.Unpin(false)\n          RETURN nil\n        \n        // Load first cell\n        offset := page.CellPointer(0)\n        c.Rowid, c.Record, _, _ = page.ReadTableLeafCell(int(offset))\n        c.AtEnd = false\n        RETURN nil\n     \n     d. // Internal page: go to leftmost child\n        childPageNum := page.FindChildPage(-1 &lt;&lt; 63)  // Smallest possible rowid\n        page.Unpin(false)\n        pageID = PageID{PageNum: int(childPageNum)}\n\nPOST-CONDITIONS:\n   - If AtEnd is false, cursor points to first row\n   - CurrentPage is pinned (caller must unpin via Close or Next)\n   - Rowid and Record are loaded</code></pre></div>\n\n<h3 id=\"cursor-next-advance-to-next-row\">Cursor Next (Advance to Next Row)</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: Cursor.Next\nINPUT: Cursor c positioned at a valid row\nOUTPUT: Cursor advanced to next row, or AtEnd=true if no more\n\n1. IF c.AtEnd:\n     RETURN nil  // Already at end\n\n2. // Advance within current page\n   c.CellIndex++\n\n3. IF c.CellIndex &lt; int(c.CurrentPage.CellCount()):\n     // More cells in this page\n     offset := c.CurrentPage.CellPointer(c.CellIndex)\n     c.Rowid, c.Record, _, _ = c.CurrentPage.ReadTableLeafCell(int(offset))\n     RETURN nil\n\n4. // Need to move to next leaf page\n   // SQLite table B-trees don't link leaves, so we navigate via parent\n   // Simplified: for single-level trees, we're done\n   // Full implementation would track parent path\n   \n   c.AtEnd = true\n   c.CurrentPage.Unpin(false)\n   c.CurrentPage = nil\n   RETURN nil\n\nPOST-CONDITIONS:\n   - If AtEnd is false, cursor points to next row in rowid order\n   - If AtEnd is true, cursor resources are released</code></pre></div>\n\n<h3 id=\"expression-evaluation-with-three-valued-logic\">Expression Evaluation with Three-Valued Logic</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-24.svg\" alt=\"Cursor State Machine\"></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: EvaluateExpression\nINPUT: Expression AST expr, ColumnCache cache\nOUTPUT: Value (may be NULL)\n\n1. SWITCH on expr type:\n\n   CASE LiteralExpression:\n     IF expr.Value == nil:\n       RETURN Value{Type: ValueNull}\n     SWITCH v := expr.Value.(type):\n       CASE int64:\n         RETURN Value{Type: ValueInteger, Int: v}\n       CASE float64:\n         RETURN Value{Type: ValueReal, Float: v}\n       CASE string:\n         RETURN Value{Type: ValueText, Str: v}\n       CASE []byte:\n         RETURN Value{Type: ValueBlob, Bytes: v}\n\n   CASE IdentifierExpression:\n     // Column reference\n     colIndex := schema.GetColumnIndex(tableName, expr.Name)\n     RETURN cache.GetColumn(colIndex)\n\n   CASE BinaryExpression:\n     left := EvaluateExpression(expr.Left, cache)\n     right := EvaluateExpression(expr.Right, cache)\n     \n     SWITCH expr.Operator:\n       CASE &quot;AND&quot;:\n         return TVLAndToValue(left, right)\n       CASE &quot;OR&quot;:\n         return TVLOrToValue(left, right)\n       CASE &quot;=&quot;, &quot;&lt;&gt;&quot;, &quot;!=&quot;, &quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;&gt;&quot;, &quot;&gt;=&quot;:\n         return CompareToValue(expr.Operator, left, right)\n       CASE &quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;:\n         return ArithmeticOp(expr.Operator, left, right)\n       CASE &quot;||&quot;:\n         return ConcatOp(left, right)\n\n   CASE UnaryExpression:\n     operand := EvaluateExpression(expr.Operand, cache)\n     IF expr.Operator == &quot;NOT&quot;:\n       return TVLNotToValue(operand)\n     IF expr.Operator == &quot;-&quot;:\n       return NegateValue(operand)\n\n   CASE IsNullExpression:\n     val := EvaluateExpression(expr.Expression, cache)\n     result := val.IsNull()\n     IF expr.Negated:  // IS NOT NULL\n       result = !result\n     RETURN BoolToValue(result)\n\n   CASE InExpression:\n     val := EvaluateExpression(expr.Expression, cache)\n     found := false\n     hasNull := false\n     FOR _, listVal := range expr.Values:\n       item := EvaluateExpression(listVal, cache)\n       cmp := CompareValues(val, item)\n       IF cmp == CompareEqual:\n         found = true\n       IF cmp == CompareNull:\n         hasNull = true\n     \n     IF found:\n       RETURN BoolToValue(!expr.Negated)\n     IF hasNull:\n       RETURN Value{Type: ValueNull}  // Result is unknown\n     RETURN BoolToValue(expr.Negated)  // Not found, no NULLs\n\n   CASE BetweenExpression:\n     val := EvaluateExpression(expr.Expression, cache)\n     low := EvaluateExpression(expr.Low, cache)\n     high := EvaluateExpression(expr.High, cache)\n     \n     cmpLow := CompareValues(val, low)\n     cmpHigh := CompareValues(val, high)\n     \n     // NULL involvement makes result NULL\n     IF cmpLow == CompareNull || cmpHigh == CompareNull:\n       RETURN Value{Type: ValueNull}\n     \n     inRange := cmpLow &gt;= CompareEqual &amp;&amp; cmpHigh &lt;= CompareEqual\n     IF expr.Negated:\n       inRange = !inRange\n     RETURN BoolToValue(inRange)\n\n   CASE LikeExpression:\n     val := EvaluateExpression(expr.Expression, cache)\n     pattern := EvaluateExpression(expr.Pattern, cache)\n     \n     IF val.IsNull() || pattern.IsNull():\n       RETURN Value{Type: ValueNull}\n     \n     matched := matchLikePattern(val.Str, pattern.Str)\n     IF expr.Negated:\n       matched = !matched\n     RETURN BoolToValue(matched)\n\n   CASE FunctionCallExpression:\n     // Handle aggregate functions specially (COUNT, SUM, etc.)\n     // For now, just evaluate arguments\n     args := make([]Value, len(expr.Args))\n     FOR i, arg := range expr.Args:\n       args[i] = EvaluateExpression(arg, cache)\n     RETURN EvaluateFunction(expr.Name, args)\n\n// Helper: Convert comparison to Value\nfunc CompareToValue(op string, left, right Value) Value {\n   cmp := CompareValues(left, right)\n   \n   IF cmp == CompareNull:\n     RETURN Value{Type: ValueNull}  // NULL comparison\n   \n   result := false\n   SWITCH op:\n     CASE &quot;=&quot;:  result = (cmp == CompareEqual)\n     CASE &quot;&lt;&gt;&quot;: result = (cmp != CompareEqual)\n     CASE &quot;!=&quot;: result = (cmp != CompareEqual)\n     CASE &quot;&lt;&quot;:  result = (cmp == CompareLess)\n     CASE &quot;&lt;=&quot;: result = (cmp == CompareLess || cmp == CompareEqual)\n     CASE &quot;&gt;&quot;:  result = (cmp == CompareGreater)\n     CASE &quot;&gt;=&quot;: result = (cmp == CompareGreater || cmp == CompareEqual)\n   \n   RETURN BoolToValue(result)\n}</code></pre></div>\n\n<h3 id=\"where-clause-evaluation\">WHERE Clause Evaluation</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-25.svg\" alt=\"Column Deserialization Algorithm\"></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: EvaluatePredicate\nINPUT: Expression expr (boolean expression), ColumnCache cache\nOUTPUT: TVLBool (TVLTrue, TVLFalse, or TVLNull)\n\n1. val := EvaluateExpression(expr, cache)\n\n2. IF val.IsNull():\n     RETURN TVLNull\n\n3. IF val.IsTruthy():\n     RETURN TVLTrue\n\n4. RETURN TVLFalse\n\n// WHERE clause filtering in VM:\n// IF EvaluatePredicate(whereExpr, cache) == TVLTrue:\n//   // Row passes filter, include in result\n// ELSE:\n//   // Row does not pass (FALSE or NULL), skip</code></pre></div>\n\n<h3 id=\"insert-execution\">INSERT Execution</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: ExecuteInsert\nINPUT: VM with OpInsert instruction\nOUTPUT: Row inserted or error\n\n1. cursor := vm.Cursors[instr.P1]\n   recordReg := instr.P2\n   rowidReg := instr.P3\n\n2. // Get record and rowid from registers\n   record := vm.Registers[recordReg].Bytes\n   rowid := vm.Registers[rowidReg].Int\n\n3. // Get table schema\n   schema := vm.GetTableSchema(cursor.Tree.TableName)\n\n4. // Deserialize record to check constraints\n   values, err := DeserializeRow(record)\n   IF err != nil:\n     RETURN err\n\n5. // Check NOT NULL constraints\n   FOR i, col := range schema.Columns:\n     IF col.NotNull &amp;&amp; values[i] == nil:\n       RETURN ConstraintError{\n         Type:    &quot;NOT NULL&quot;,\n         Table:   cursor.Tree.TableName,\n         Column:  col.Name,\n       }\n\n6. // Check UNIQUE constraints (via indexes)\n   FOR _, idx := range schema.Indexes:\n     IF idx.IsUnique:\n       colValue := values[idx.ColumnIndex]\n       exists := idx.Find(colValue)\n       IF exists:\n         RETURN ConstraintError{\n           Type:    &quot;UNIQUE&quot;,\n           Table:   cursor.Tree.TableName,\n           Column:  idx.ColumnName,\n         }\n\n7. // Insert into table B-tree\n   err := cursor.Tree.Insert(rowid, record)\n   IF err != nil:\n     RETURN err\n\n8. // Update indexes\n   FOR _, idx := range schema.Indexes:\n     colValue := values[idx.ColumnIndex]\n     idx.Insert(colValue, rowid)\n\n9. RETURN nil</code></pre></div>\n\n<h3 id=\"delete-execution\">DELETE Execution</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: ExecuteDelete\nINPUT: VM with OpDelete instruction, cursor positioned at row to delete\nOUTPUT: Row deleted\n\n1. cursor := vm.Cursors[instr.P1]\n\n2. IF cursor.AtEnd:\n     RETURN errors.New(&quot;cursor not positioned on a row&quot;)\n\n3. // Get current row's values for index updates\n   values, _ := DeserializeRow(cursor.Record)\n\n4. // Delete from indexes first\n   schema := vm.GetTableSchema(cursor.Tree.TableName)\n   FOR _, idx := range schema.Indexes:\n     colValue := values[idx.ColumnIndex]\n     idx.Delete(colValue, cursor.Rowid)\n\n5. // Delete from table B-tree\n   err := cursor.Tree.Delete(cursor.Rowid)\n   IF err != nil:\n     RETURN err\n\n6. // Cursor position is now invalid\n   cursor.AtEnd = true\n\n7. RETURN nil</code></pre></div>\n\n<h3 id=\"update-execution-delete-reinsert\">UPDATE Execution (Delete + Reinsert)</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-26.svg\" alt=\"DML Execution Flow\"></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: ExecuteUpdate\nINPUT: Table name, rowid, column updates map, WHERE clause\nOUTPUT: Number of rows updated\n\n1. tree := vm.GetTable(tableName)\n   schema := vm.GetTableSchema(tableName)\n\n2. updatedCount := 0\n   toUpdate := []UpdateInfo{}  // Collect updates to apply\n\n3. // First pass: collect matching rows\n   cursor := tree.NewCursor()\n   cursor.First()\n   \n   WHILE NOT cursor.AtEnd:\n     a. rowid, record := cursor.Current()\n     b. cache := NewColumnCache()\n        cache.SetRecord(record)\n     \n     c. // Check WHERE clause\n        IF whereClause != nil:\n          pred := EvaluatePredicate(whereClause, cache)\n          IF pred != TVLTrue:\n            cursor.Next()\n            CONTINUE\n     \n     d. // Deserialize current values\n        values, _ := DeserializeRow(record)\n     \n     e. // Apply updates\n        newValues := make([]interface{}, len(values))\n        copy(newValues, values)\n        \n        FOR colName, newVal := range updates:\n          colIndex := schema.GetColumnIndex(colName)\n          \n          // Check NOT NULL\n          IF schema.Columns[colIndex].NotNull &amp;&amp; newVal == nil:\n            RETURN 0, ConstraintError{Type: &quot;NOT NULL&quot;, Column: colName}\n          \n          newValues[colIndex] = newVal\n     \n     f. toUpdate = append(toUpdate, UpdateInfo{\n          Rowid:    rowid,\n          OldValues: values,\n          NewValues: newValues,\n        })\n     \n     g. cursor.Next()\n\n4. // Second pass: apply updates (can't modify during iteration)\n   FOR _, update := range toUpdate:\n     a. // Delete old row\n        tree.Delete(update.Rowid)\n     \n     b. // Update indexes\n        FOR _, idx := range schema.Indexes:\n          oldValue := update.OldValues[idx.ColumnIndex]\n          newValue := update.NewValues[idx.ColumnIndex]\n          IF CompareValues(oldValue, newValue) != CompareEqual:\n            idx.Delete(oldValue, update.Rowid)\n            idx.Insert(newValue, update.Rowid)\n     \n     c. // Insert new row\n        newRecord := SerializeRow(update.NewValues)\n        tree.Insert(update.Rowid, newRecord)\n     \n     d. updatedCount++\n\n5. RETURN updatedCount, nil</code></pre></div>\n\n<hr>\n<h2 id=\"error-handling-matrix\">Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th>Error</th>\n<th>Detected By</th>\n<th>Recovery</th>\n<th>User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Table does not exist</td>\n<td><code>GetTableTree</code> lookup</td>\n<td>Return error immediately</td>\n<td>Yes: &quot;no such table: {name}&quot;</td>\n</tr>\n<tr>\n<td>Column does not exist</td>\n<td><code>GetColumnIndex</code> lookup</td>\n<td>Return error immediately</td>\n<td>Yes: &quot;no such column: {table}.{column}&quot;</td>\n</tr>\n<tr>\n<td>NOT NULL constraint violation</td>\n<td><code>ExecuteInsert</code> validation</td>\n<td>Reject INSERT/UPDATE</td>\n<td>Yes: &quot;NOT NULL constraint failed: {table}.{column}&quot;</td>\n</tr>\n<tr>\n<td>UNIQUE constraint violation</td>\n<td>Index lookup before insert</td>\n<td>Reject INSERT/UPDATE</td>\n<td>Yes: &quot;UNIQUE constraint failed: {table}.{column}&quot;</td>\n</tr>\n<tr>\n<td>NULL in comparison</td>\n<td><code>CompareValues</code></td>\n<td>Return NULL result</td>\n<td>No: WHERE clause filters out NULL results</td>\n</tr>\n<tr>\n<td>Division by zero</td>\n<td>Arithmetic operations</td>\n<td>Return NULL value</td>\n<td>No: SQL semantics (division by zero = NULL)</td>\n</tr>\n<tr>\n<td>Cursor not positioned</td>\n<td>Cursor operations on AtEnd cursor</td>\n<td>Return error</td>\n<td>Yes: &quot;cursor is not positioned on a row&quot;</td>\n</tr>\n<tr>\n<td>Type mismatch in arithmetic</td>\n<td><code>ArithmeticOp</code> type check</td>\n<td>Return NULL or error</td>\n<td>Yes: &quot;cannot perform arithmetic on TEXT&quot;</td>\n</tr>\n<tr>\n<td>Record deserialization failure</td>\n<td><code>DeserializeRow</code></td>\n<td>Return error</td>\n<td>Yes: &quot;corrupted record in table {name}&quot;</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"implementation-sequence-with-checkpoints\">Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-cursor-abstraction-and-b-tree-traversal-2-hours\">Phase 1: Cursor Abstraction and B-tree Traversal (2 hours)</h3>\n<p><strong>Files to create</strong>: <code>cursor.go</code>, <code>cursor_scan.go</code>, <code>cursor_seek.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Define <code>Cursor</code> struct with position state</li>\n<li>Implement <code>First()</code> to navigate to leftmost row</li>\n<li>Implement <code>Next()</code> to advance through rows</li>\n<li>Implement <code>SeekRowid()</code> for point lookups</li>\n<li>Implement <code>Close()</code> to release resources</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should be able to scan a table. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestCursorScan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (cursor iterates through all rows)</span></span></code></pre></div>\n\n<h3 id=\"phase-2-column-deserialization-with-lazy-access-2-hours\">Phase 2: Column Deserialization with Lazy Access (2 hours)</h3>\n<p><strong>Files to create</strong>: <code>column_access.go</code>, <code>value.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Define <code>Value</code> type with NULL handling</li>\n<li>Implement <code>ColumnCache</code> for lazy deserialization</li>\n<li>Implement <code>GetColumn()</code> with header parsing</li>\n<li>Implement <code>ColumnCount()</code> for projection</li>\n<li>Add caching to avoid re-parsing</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should deserialize columns on demand. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestColumnAccess</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (lazy column access works, repeated access uses cache)</span></span></code></pre></div>\n\n<h3 id=\"phase-3-three-valued-logic-for-comparisons-15-hours\">Phase 3: Three-Valued Logic for Comparisons (1.5 hours)</h3>\n<p><strong>Files to create</strong>: <code>three_valued.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Define <code>TVLBool</code> type (TRUE, FALSE, NULL)</li>\n<li>Implement <code>CompareValues</code> with NULL handling</li>\n<li>Implement <code>TVLAnd</code>, <code>TVLOr</code>, <code>TVLNot</code></li>\n<li>Implement comparison operators (=, &lt;, &gt;, etc.) with TVL</li>\n<li>Add truth tables as tests</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should pass TVL tests. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestThreeValuedLogic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (NULL handling correct in all operators)</span></span></code></pre></div>\n\n<h3 id=\"phase-4-where-clause-evaluation-15-hours\">Phase 4: WHERE Clause Evaluation (1.5 hours)</h3>\n<p><strong>Files to create</strong>: <code>expression_eval.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>EvaluateExpression</code> for all expression types</li>\n<li>Implement <code>EvaluatePredicate</code> for WHERE clauses</li>\n<li>Handle special expressions (IN, BETWEEN, LIKE, IS NULL)</li>\n<li>Integrate TVL into evaluation</li>\n<li>Handle function calls (COUNT, etc.)</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should evaluate WHERE clauses. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestWhereEvaluation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (WHERE filters rows correctly with NULL handling)</span></span></code></pre></div>\n\n<h3 id=\"phase-5-insert-execution-with-constraint-check-15-hours\">Phase 5: INSERT Execution with Constraint Check (1.5 hours)</h3>\n<p><strong>Files to create</strong>: <code>insert_exec.go</code>, <code>constraint.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>ExecuteInsert</code> opcode handler</li>\n<li>Implement NOT NULL constraint checking</li>\n<li>Implement UNIQUE constraint checking via indexes</li>\n<li>Integrate with B-tree insert</li>\n<li>Update indexes after insert</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should insert rows with validation. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestInsertExecution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (INSERT works, constraints are enforced)</span></span></code></pre></div>\n\n<h3 id=\"phase-6-update-and-delete-execution-15-hours\">Phase 6: UPDATE and DELETE Execution (1.5 hours)</h3>\n<p><strong>Files to create</strong>: <code>update_exec.go</code>, <code>delete_exec.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>ExecuteDelete</code> opcode handler</li>\n<li>Implement two-pass UPDATE (collect then apply)</li>\n<li>Update indexes on delete/update</li>\n<li>Handle rowid changes (not allowed)</li>\n<li>Return affected row count</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should pass the full test suite. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> ./execution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: All tests PASS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify: 10,000-row scan in &#x3C; 100ms</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify: WHERE evaluation in &#x3C; 1μs per row</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"test-specification\">Test Specification</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// execution_test.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestCursorScan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tree </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestTree</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\">// 100 rows</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tree.</span><span style=\"color:#B392F0\">NewCursor</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor.</span><span style=\"color:#B392F0\">First</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    count </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> lastRowid </span><span style=\"color:#F97583\">int64</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">cursor.AtEnd {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rowid, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cursor.</span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        assert.</span><span style=\"color:#B392F0\">Greater</span><span style=\"color:#E1E4E8\">(t, rowid, lastRowid)  </span><span style=\"color:#6A737D\">// Ordered by rowid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lastRowid </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> rowid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        count</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">, count)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestColumnAccess</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SerializeRow</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">42</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"hello\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3.14</span><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cache </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewColumnCache</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cache.</span><span style=\"color:#B392F0\">SetRecord</span><span style=\"color:#E1E4E8\">(record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // First access parses header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    col0, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cache.</span><span style=\"color:#B392F0\">GetColumn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">42</span><span style=\"color:#E1E4E8\">), col0.Int)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Subsequent access uses cache</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    col0Again, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cache.</span><span style=\"color:#B392F0\">GetColumn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, col0, col0Again)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Column 2 is NULL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    col2, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cache.</span><span style=\"color:#B392F0\">GetColumn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">True</span><span style=\"color:#E1E4E8\">(t, col2.</span><span style=\"color:#B392F0\">IsNull</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Column 3 is float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    col3, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cache.</span><span style=\"color:#B392F0\">GetColumn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">InDelta</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">3.14</span><span style=\"color:#E1E4E8\">, col3.Float, </span><span style=\"color:#79B8FF\">0.001</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestThreeValuedLogic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        name     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expr     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        left     </span><span style=\"color:#B392F0\">Value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        right    </span><span style=\"color:#B392F0\">Value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected </span><span style=\"color:#B392F0\">TVLBool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#9ECBFF\">\"NULL AND TRUE\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"AND\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">{Type: ValueNull}, </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">{Type: ValueInteger, Int: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}, TVLNull},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#9ECBFF\">\"NULL AND FALSE\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"AND\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">{Type: ValueNull}, </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">{Type: ValueInteger, Int: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">}, TVLFalse},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#9ECBFF\">\"NULL OR TRUE\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"OR\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">{Type: ValueNull}, </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">{Type: ValueInteger, Int: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}, TVLTrue},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#9ECBFF\">\"NULL OR FALSE\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"OR\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">{Type: ValueNull}, </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">{Type: ValueInteger, Int: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">}, TVLNull},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#9ECBFF\">\"NOT NULL\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"NOT\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">{Type: ValueNull}, </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">{}, TVLNull},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#9ECBFF\">\"NULL = NULL\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"=\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">{Type: ValueNull}, </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">{Type: ValueNull}, TVLNull},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#9ECBFF\">\"1 = 1\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"=\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">{Type: ValueInteger, Int: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">{Type: ValueInteger, Int: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}, TVLTrue},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#9ECBFF\">\"1 = 2\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"=\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">{Type: ValueInteger, Int: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">{Type: ValueInteger, Int: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">}, TVLFalse},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, tc </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> tests {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">Run</span><span style=\"color:#E1E4E8\">(tc.name, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            var</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#B392F0\">TVLBool</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            switch</span><span style=\"color:#E1E4E8\"> tc.expr {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> \"AND\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> TVLAnd</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">valueToTVL</span><span style=\"color:#E1E4E8\">(tc.left), </span><span style=\"color:#B392F0\">valueToTVL</span><span style=\"color:#E1E4E8\">(tc.right))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> \"OR\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> TVLOr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">valueToTVL</span><span style=\"color:#E1E4E8\">(tc.left), </span><span style=\"color:#B392F0\">valueToTVL</span><span style=\"color:#E1E4E8\">(tc.right))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> \"NOT\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> TVLNot</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">valueToTVL</span><span style=\"color:#E1E4E8\">(tc.left))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#9ECBFF\"> \"=\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                cmp </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> CompareValues</span><span style=\"color:#E1E4E8\">(tc.left, tc.right)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> cmp </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> CompareNull {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> TVLNull</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> boolToTVL</span><span style=\"color:#E1E4E8\">(cmp </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> CompareEqual)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, tc.expected, result)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestWhereEvaluation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    schema </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestSchema</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tests </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        where    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        row      []</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        passes   </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#9ECBFF\">\"age > 18\"</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"Alice\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">25</span><span style=\"color:#E1E4E8\">)}, </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#9ECBFF\">\"age > 18\"</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"Bob\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">15</span><span style=\"color:#E1E4E8\">)}, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#9ECBFF\">\"age > 18\"</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"Charlie\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">},  </span><span style=\"color:#6A737D\">// NULL > 18 = NULL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#9ECBFF\">\"name = 'Alice'\"</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"Alice\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">25</span><span style=\"color:#E1E4E8\">)}, </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#9ECBFF\">\"name = NULL\"</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"Alice\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">25</span><span style=\"color:#E1E4E8\">)}, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">},  </span><span style=\"color:#6A737D\">// Always false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#9ECBFF\">\"age IS NULL\"</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"Charlie\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span><span style=\"color:#9ECBFF\">\"age IS NOT NULL\"</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"Alice\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">25</span><span style=\"color:#E1E4E8\">)}, </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, tc </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> tests {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">Run</span><span style=\"color:#E1E4E8\">(tc.where, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ast </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> parseExpression</span><span style=\"color:#E1E4E8\">(tc.where)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SerializeRow</span><span style=\"color:#E1E4E8\">(tc.row)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cache </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewColumnCache</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cache.</span><span style=\"color:#B392F0\">SetRecord</span><span style=\"color:#E1E4E8\">(record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> EvaluatePredicate</span><span style=\"color:#E1E4E8\">(ast, cache)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> tc.passes {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, TVLTrue, result)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                assert.</span><span style=\"color:#B392F0\">NotEqual</span><span style=\"color:#E1E4E8\">(t, TVLTrue, result)  </span><span style=\"color:#6A737D\">// FALSE or NULL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestInsertExecution</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestVM</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT NOT NULL)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Valid insert</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (1, 'Alice')\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // NOT NULL violation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (2, NULL)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(t, err.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#9ECBFF\">\"NOT NULL constraint failed\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify row was inserted</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rows </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">Query</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM users\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Len</span><span style=\"color:#E1E4E8\">(t, rows, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestDeleteExecution</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestVM</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE TABLE users (id INTEGER, name TEXT)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (1, 'Alice')\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (2, 'Bob')\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Delete one row</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"DELETE FROM users WHERE id = 1\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rows </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">Query</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM users\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Len</span><span style=\"color:#E1E4E8\">(t, rows, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#9ECBFF\">\"Bob\"</span><span style=\"color:#E1E4E8\">, rows[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">][</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">].Str)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestUpdateExecution</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestVM</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE TABLE users (id INTEGER, name TEXT NOT NULL)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (1, 'Alice')\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (2, 'Bob')\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update one row</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"UPDATE users SET name = 'Alicia' WHERE id = 1\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rows </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">Query</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM users WHERE id = 1\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#9ECBFF\">\"Alicia\"</span><span style=\"color:#E1E4E8\">, rows[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">][</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">].Str)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // NOT NULL violation on update</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"UPDATE users SET name = NULL WHERE id = 2\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(t, err.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#9ECBFF\">\"NOT NULL constraint failed\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestPerformanceScan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> testing.</span><span style=\"color:#B392F0\">Short</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">Skip</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Skipping performance test\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestVM</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE TABLE t (id INTEGER, value TEXT)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Insert 10,000 rows</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vm.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO t VALUES (</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, 'value</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">')\"</span><span style=\"color:#E1E4E8\">, i, i))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Scan all rows</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rows </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">Query</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM t\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    elapsed </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Since</span><span style=\"color:#E1E4E8\">(start)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Len</span><span style=\"color:#E1E4E8\">(t, rows, </span><span style=\"color:#79B8FF\">10000</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Less</span><span style=\"color:#E1E4E8\">(t, elapsed.</span><span style=\"color:#B392F0\">Milliseconds</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"10K scan should complete in &#x3C; 100ms\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestPerformanceWhere</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> testing.</span><span style=\"color:#B392F0\">Short</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">Skip</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Skipping performance test\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestVM</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE TABLE t (id INTEGER, value INTEGER)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Insert 10,000 rows</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vm.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO t VALUES (</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)\"</span><span style=\"color:#E1E4E8\">, i, i</span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Query with WHERE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rows </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">Query</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM t WHERE value > 50\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    elapsed </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Since</span><span style=\"color:#E1E4E8\">(start)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should filter approximately 4900 rows</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Greater</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(rows), </span><span style=\"color:#79B8FF\">4000</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Per-row WHERE evaluation should be &#x3C; 1μs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    perRowTime </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> elapsed </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10000</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Less</span><span style=\"color:#E1E4E8\">(t, perRowTime.</span><span style=\"color:#B392F0\">Microseconds</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"WHERE eval should be &#x3C; 1μs per row\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestTableNotExist</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vm </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestVM</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM nonexistent\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(t, err.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#9ECBFF\">\"no such table\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> vm.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO nonexistent VALUES (1)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(t, err.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#9ECBFF\">\"no such table\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-targets\">Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Target</th>\n<th>How to Measure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>10,000-row table scan</td>\n<td>&lt; 100ms</td>\n<td><code>go test -bench=BenchmarkScan10K</code></td>\n</tr>\n<tr>\n<td>Single-row INSERT</td>\n<td>&lt; 1ms</td>\n<td><code>go test -bench=BenchmarkInsert</code></td>\n</tr>\n<tr>\n<td>WHERE evaluation</td>\n<td>&lt; 1μs per row</td>\n<td><code>go test -bench=BenchmarkWhereEval</code></td>\n</tr>\n<tr>\n<td>Column access (cached)</td>\n<td>&lt; 50ns</td>\n<td><code>go test -bench=BenchmarkColumnAccess</code></td>\n</tr>\n<tr>\n<td>TVL comparison</td>\n<td>&lt; 100ns</td>\n<td><code>go test -bench=BenchmarkTVL</code></td>\n</tr>\n<tr>\n<td>NULL handling overhead</td>\n<td>&lt; 10% vs non-NULL</td>\n<td>Compare benchmarks with/without NULLs</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"synced-criteria\">Synced Criteria</h2>\n<p>[[CRITERIA_JSON: {&quot;module_id&quot;: &quot;build-sqlite-m6&quot;, &quot;criteria&quot;: [&quot;SELECT * returns all rows by iterating through the B-tree leaf sequence&quot;, &quot;SELECT with column names correctly projects only the requested fields&quot;, &quot;WHERE clause correctly filters rows using Three-Valued Logic (handling NULLs)&quot;, &quot;INSERT adds a new row and updates the B-tree structure correctly&quot;, &quot;UPDATE and DELETE modify/remove rows while maintaining B-tree integrity&quot;, &quot;NOT NULL constraints reject invalid writes with a descriptive error&quot;, &quot;Attempting to query a table not in the System Catalog returns an &#39;undefined table&#39; error&quot;]}]</p>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-sqlite-m7 -->\n<h1 id=\"technical-design-specification-secondary-indexes\">Technical Design Specification: Secondary Indexes</h1>\n<h2 id=\"module-charter\">Module Charter</h2>\n<p>The Secondary Indexes module implements B+tree indexes that map (column value, rowid) pairs to table rows, enabling O(log n) lookups instead of O(n) table scans. It provides CREATE INDEX construction from existing table data, automatic synchronous index maintenance on all DML operations (INSERT/UPDATE/DELETE), equality lookup via index seek, range scan via linked leaf traversal, UNIQUE constraint enforcement with duplicate detection, and the double-lookup pattern (index → rowid → table row). The module does NOT choose when to use indexes (that&#39;s the query planner), modify table data directly, or handle concurrent index creation—it maintains index structures in response to DML. Upstream dependencies: DML operations (INSERT/UPDATE/DELETE), CREATE INDEX statement. Downstream dependencies: B+tree page format (index leaf/internal pages), Buffer Pool (page caching), Query Planner (index selection). Invariants: index entries are always (column value, rowid) pairs; index leaf pages are linked for range scans; indexes are updated synchronously with table modifications; UNIQUE indexes reject duplicate column values.</p>\n<hr>\n<h2 id=\"file-structure\">File Structure</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>index/\n├── index.go              # (1) Index struct with metadata and root page reference\n├── index_leaf.go         # (2) Index B+tree leaf cell format (value, rowid)\n├── index_internal.go     # (3) Index B+tree internal page operations\n├── index_cursor.go       # (4) IndexCursor with leaf linking for range scans\n├── create_index.go       # (5) CREATE INDEX from existing table scan\n├── index_lookup.go       # (6) Equality lookup returning rowids\n├── index_range.go        # (7) Range scan via linked leaf traversal\n├── index_maintenance.go  # (8) INSERT/UPDATE/DELETE index update hooks\n├── unique_constraint.go  # (9) UNIQUE constraint checking\n├── index_test.go         # (10) Comprehensive test suite\n└── double_lookup.go      # (11) Index → table row fetch pattern</code></pre></div>\n\n<hr>\n<h2 id=\"complete-data-model\">Complete Data Model</h2>\n<h3 id=\"index-structure\">Index Structure</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// index.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Index</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name        </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">    // Index name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TableName   </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">    // Table being indexed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ColumnName  </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">    // Column being indexed (single-column for now)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RootPageID  </span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#6A737D\">    // Root page of the index B+tree</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IsUnique    </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">      // TRUE for UNIQUE indexes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BufferPool  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Index entry stored in B+tree leaves</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Format: (column_value, rowid) pair</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The composite key ensures:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Entries sorted by column value first</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Duplicate values sorted by rowid (important for non-unique indexes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Every entry unique even if column values aren't</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IndexEntry</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Value  </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#6A737D\">    // Indexed column value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Rowid  </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">    // Rowid of the table row</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY Index struct:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Name/TableName/ColumnName: Schema metadata for lookups</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - RootPageID: Entry point for B+tree operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - IsUnique: Enables constraint checking on INSERT/UPDATE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - BufferPool: Required for page access during index operations</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IndexManager tracks all indexes for a database</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IndexManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexes     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#6A737D\">  // index name -> Index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tableIndex  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // table name -> index names</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bufferPool  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BufferPool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    catalog     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Catalog</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewIndexManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">bufferPool</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">BufferPool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">catalog</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Catalog</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">IndexManager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        indexes:    </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tableIndex: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bufferPool: bufferPool,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        catalog:    catalog,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetTableIndexes returns all indexes for a table</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">im </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetTableIndexes</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    names </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> im.tableIndex[tableName]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(names))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, name </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> names {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> idx, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> im.indexes[name]; exists {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            indexes </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(indexes, idx)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> indexes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"index-btree-leaf-cell-format\">Index B+tree Leaf Cell Format</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-27.svg\" alt=\"Index Entry Format\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// index_leaf.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Index leaf cell format:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ┌─────────────┬────────────────┬───────────────────┬─────────────────┐</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ Payload Size│ Payload        │ Rowid             │ Right Sibling    │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ (varint)    │ (serialized    │ (varint)          │ (4 bytes, in     │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │             │  column value) │                   │  page header)    │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// └─────────────┴────────────────┴───────────────────┴─────────────────┘</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The payload contains the serialized indexed column value.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// For a TEXT column, payload = serial_type + text bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// For an INTEGER column, payload = serial_type + integer bytes</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReadIndexLeafCell reads an index leaf cell at the given offset.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReadIndexLeafCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">consumed</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> offset</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read payload size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payloadSize, n </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(p.data, pos)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid cell: cannot read payload size\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read payload (serialized column value)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> pos</span><span style=\"color:#F97583\">+int</span><span style=\"color:#E1E4E8\">(payloadSize) </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> PageSize {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"payload overflow: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> bytes\"</span><span style=\"color:#E1E4E8\">, payloadSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, payloadSize)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(payload, p.data[pos:pos</span><span style=\"color:#F97583\">+int</span><span style=\"color:#E1E4E8\">(payloadSize)])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(payloadSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read rowid (at the end for index cells, not part of sort key)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowid, n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(p.data, pos)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid cell: cannot read rowid\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> payload, rowid, pos </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> offset, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WriteIndexLeafCell writes an index leaf cell at the given offset.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">WriteIndexLeafCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> offset</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payloadSize </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(payload))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write payload size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    n </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> WriteVarintTo</span><span style=\"color:#E1E4E8\">(p.data, pos, payloadSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write payload</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(p.data[pos:], payload)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(payload)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write rowid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> WriteVarintTo</span><span style=\"color:#E1E4E8\">(p.data, pos, rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p.isDirty </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> pos </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> offset, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IndexCellSize calculates the size needed for an index leaf cell.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> IndexCellSize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> VarintSize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(payload))) </span><span style=\"color:#F97583\">+</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(payload) </span><span style=\"color:#F97583\">+</span><span style=\"color:#B392F0\"> VarintSize</span><span style=\"color:#E1E4E8\">(rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RightSibling returns the right-sibling page number (leaf linking).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Stored in a special location for index leaf pages.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RightSibling</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">Type</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> PageTypeIndexLeaf {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // SQLite stores right-sibling at offset 8 in index leaf header</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // (reusing space that would be RightMostPointer in internal pages)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(p.data[</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetRightSibling</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pageNum</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">Type</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PageTypeIndexLeaf {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        binary.BigEndian.</span><span style=\"color:#B392F0\">PutUint32</span><span style=\"color:#E1E4E8\">(p.data[</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">], pageNum)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p.isDirty </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY right-sibling linking:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Enables O(1) next-leaf access during range scans</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Without linking, range scan requires parent navigation per leaf</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - B+tree design choice: trade page header space for scan performance</span></span></code></pre></div>\n\n<h3 id=\"index-btree-internal-cell-format\">Index B+tree Internal Cell Format</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// index_internal.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Index internal cell format:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ┌─────────────┬────────────────┐</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ Left Child  │ Separator Key  │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// │ (4 bytes)   │ (payload only) │</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// └─────────────┴────────────────┘</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Note: Internal cells do NOT include rowid (only leaf cells do)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReadIndexInternalCell reads an index internal cell.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReadIndexInternalCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">offset</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#FFAB70\">leftChild</span><span style=\"color:#F97583\"> uint32</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">separatorPayload</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">consumed</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> offset</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read left child page number</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> pos</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#F97583\"> ></span><span style=\"color:#E1E4E8\"> PageSize {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid cell: truncated left child\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leftChild </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> binary.BigEndian.</span><span style=\"color:#B392F0\">Uint32</span><span style=\"color:#E1E4E8\">(p.data[pos : pos</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read payload size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payloadSize, n </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(p.data, pos)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid cell: cannot read payload size\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read separator payload (no rowid in internal cells)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> pos</span><span style=\"color:#F97583\">+int</span><span style=\"color:#E1E4E8\">(payloadSize) </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> PageSize {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"payload overflow: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> bytes\"</span><span style=\"color:#E1E4E8\">, payloadSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    separatorPayload </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, payloadSize)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(separatorPayload, p.data[pos:pos</span><span style=\"color:#F97583\">+int</span><span style=\"color:#E1E4E8\">(payloadSize)])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pos </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(payloadSize)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> leftChild, separatorPayload, pos </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> offset, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FindChildPage returns the child page for a given search key.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FindChildPageForIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">searchPayload</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cellCount </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(p.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> cellCount; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cellOffset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">CellPointer</span><span style=\"color:#E1E4E8\">(i)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        _, separatorPayload, _, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">ReadIndexInternalCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(cellOffset))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Compare search key to separator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cmp </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> CompareIndexPayloads</span><span style=\"color:#E1E4E8\">(searchPayload, separatorPayload)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> cmp </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Search key &#x3C; separator, go to left child</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            leftChild, _, _, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">ReadIndexInternalCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(cellOffset))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> leftChild</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Greater than or equal to all separators: use rightmost pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">RightMostPointer</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CompareIndexPayloads compares two index payloads.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns -1, 0, or 1.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> CompareIndexPayloads</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Deserialize both payloads to get the column values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    valA </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> DeserializeIndexPayload</span><span style=\"color:#E1E4E8\">(a)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    valB </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> DeserializeIndexPayload</span><span style=\"color:#E1E4E8\">(b)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cmp </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> CompareValues</span><span style=\"color:#E1E4E8\">(valA, valB)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> cmp {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> CompareLess:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> CompareGreater:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DeserializeIndexPayload extracts the column value from an index payload.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> DeserializeIndexPayload</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(payload) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: ValueNull}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read serial type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    serialType, n </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ReadVarint</span><span style=\"color:#E1E4E8\">(payload, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: ValueNull}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Decode value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    value, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> DecodeValue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">SerialType</span><span style=\"color:#E1E4E8\">(serialType), payload[n:])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: ValueNull}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Convert to Value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> value.(</span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: ValueNull}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: ValueInteger, Int: v}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: ValueReal, Float: v}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: ValueText, Str: v}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: ValueBlob, Bytes: v}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">{Type: ValueNull}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SerializeIndexPayload creates an index payload from a value.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> SerializeIndexPayload</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> goValue </span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> value.Type {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueNull:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        goValue </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueInteger:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        goValue </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value.Int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueReal:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        goValue </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value.Float</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueText:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        goValue </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value.Str</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ValueBlob:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        goValue </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value.Bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    serialType, body </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> EncodeSerialType</span><span style=\"color:#E1E4E8\">(goValue)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Build payload: serial type + body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(payload, </span><span style=\"color:#B392F0\">WriteVarint</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(serialType))</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(payload, body</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> payload</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"index-cursor-with-leaf-linking\">Index Cursor with Leaf Linking</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// index_cursor.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IndexCursor</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Index       </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CurrentPage </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PageID      </span><span style=\"color:#B392F0\">PageID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CellIndex   </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AtEnd       </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Current entry (cached)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Payload     []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Rowid       </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Value       </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#6A737D\">  // Deserialized column value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewIndexCursor creates a cursor for index traversal.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">NewCursor</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexCursor</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">IndexCursor</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Index: idx,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// First positions the cursor at the first index entry.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexCursor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">First</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pageID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.Index.RootPageID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Navigate to leftmost leaf</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.Index.BufferPool.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(pageID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">Type</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PageTypeIndexLeaf {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            c.CurrentPage </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            c.PageID </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pageID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            c.CellIndex </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                c.AtEnd </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                page.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Load first entry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">CellPointer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            c.Payload, c.Rowid, _, _ </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">ReadIndexLeafCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(offset))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            c.Value </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> DeserializeIndexPayload</span><span style=\"color:#E1E4E8\">(c.Payload)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            c.AtEnd </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Internal page: go to leftmost child</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        childPageNum </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">FindChildPageForIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#6A737D\">// nil = smallest</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pageID </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(childPageNum)}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Next advances to the next index entry.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Uses leaf linking for efficient range scans.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexCursor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> c.AtEnd {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.CellIndex</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if more cells in current leaf</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> c.CellIndex </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">(c.CurrentPage.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.CurrentPage.</span><span style=\"color:#B392F0\">CellPointer</span><span style=\"color:#E1E4E8\">(c.CellIndex)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.Payload, c.Rowid, _, _ </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> c.CurrentPage.</span><span style=\"color:#B392F0\">ReadIndexLeafCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(offset))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.Value </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> DeserializeIndexPayload</span><span style=\"color:#E1E4E8\">(c.Payload)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Move to next leaf via right-sibling link</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nextLeaf </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.CurrentPage.</span><span style=\"color:#B392F0\">RightSibling</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.CurrentPage.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> nextLeaf </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.AtEnd </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.CurrentPage </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Load next leaf</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.Index.BufferPool.</span><span style=\"color:#B392F0\">FetchPage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(nextLeaf)})</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.CurrentPage </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.PageID </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> PageID</span><span style=\"color:#E1E4E8\">{PageNum: </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(nextLeaf)}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.CellIndex </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">CellCount</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.AtEnd </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        page.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    offset </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">CellPointer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.Payload, c.Rowid, _, _ </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> page.</span><span style=\"color:#B392F0\">ReadIndexLeafCell</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(offset))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.Value </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> DeserializeIndexPayload</span><span style=\"color:#E1E4E8\">(c.Payload)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Current returns the current index entry.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexCursor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> c.AtEnd {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"cursor at end\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> c.Value, c.Rowid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Close releases cursor resources.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexCursor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> c.CurrentPage </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.CurrentPage.</span><span style=\"color:#B392F0\">Unpin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.CurrentPage </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY IndexCursor:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Encapsulates index position state for VM</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Right-sibling linking enables O(1) leaf-to-leaf navigation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Caches deserialized value to avoid repeated parsing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Same pattern as table cursor for consistency</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"interface-contracts\">Interface Contracts</h2>\n<h3 id=\"index-creation\">Index Creation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// CreateIndex builds an index from existing table data.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parameters:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - stmt: CREATE INDEX statement with name, table, column, unique flag</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - schema: Database schema for validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - *Index: Created index with root page</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - error: If table doesn't exist, column doesn't exist, or unique violation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Pre-conditions:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Table must exist</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Column must exist in table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Index name must be unique</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Post-conditions:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Index B+tree is populated with all existing rows</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Index is registered in catalog</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - For UNIQUE index, no duplicate values exist</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complexity: O(n log n) where n is table row count</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">im </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">CreateIndexStatement</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h3 id=\"index-lookup\">Index Lookup</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// FindEqual returns rowids matching an equality predicate.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parameters:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - value: Column value to search for</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - []int64: Rowids of matching rows (may be multiple for non-unique)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - error: If index seek fails</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complexity: O(log n) for seek + O(k) for collecting matches</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FindEqual</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FindRange returns rowids within a value range.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parameters:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - low: Lower bound (inclusive)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - high: Upper bound (inclusive)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - []int64: Rowids within range</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - error: If range scan fails</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complexity: O(log n) for seek + O(m) for scan where m is result size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FindRange</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">low</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">high</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h3 id=\"index-maintenance\">Index Maintenance</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// InsertEntry adds an entry to the index.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Called by INSERT operation after table row is inserted.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parameters:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - value: Indexed column value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - rowid: Rowid of the new table row</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - error: UNIQUE constraint violation for unique indexes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">InsertEntry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DeleteEntry removes an entry from the index.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Called by DELETE operation before table row is deleted.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parameters:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - value: Indexed column value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - rowid: Rowid of the row being deleted</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DeleteEntry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// UpdateEntry updates an index entry.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Called by UPDATE when the indexed column changes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parameters:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - oldValue: Previous column value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - newValue: New column value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - rowid: Rowid of the updated row</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - error: UNIQUE constraint violation if new value conflicts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UpdateEntry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">oldValue</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">newValue</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"algorithm-specification\">Algorithm Specification</h2>\n<h3 id=\"create-index-from-table-scan\">CREATE INDEX from Table Scan</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-28.svg\" alt=\"Double Lookup Pattern\"></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: CreateIndex\nINPUT: CreateIndexStatement (name, table, column, unique), Schema\nOUTPUT: Populated Index B+tree\n\n1. VALIDATE INPUT\n   a. Verify table exists in schema\n   b. Verify column exists in table\n   c. Verify index name is unique\n\n2. ALLOCATE ROOT PAGE\n   rootPageID := bufferPool.AllocatePage()\n   rootPage := bufferPool.FetchPage(rootPageID)\n   Initialize rootPage as empty index leaf (PageTypeIndexLeaf)\n   rootPage.Unpin(true)\n\n3. CREATE INDEX STRUCT\n   idx := &amp;Index{\n     Name:       stmt.Name,\n     TableName:  stmt.TableName,\n     ColumnName: stmt.ColumnName,\n     RootPageID: rootPageID,\n     IsUnique:   stmt.Unique,\n   }\n\n4. SCAN TABLE AND POPULATE INDEX\n   tableTree := catalog.GetTableTree(stmt.TableName)\n   colIndex := schema.GetColumnIndex(stmt.TableName, stmt.ColumnName)\n   \n   cursor := tableTree.NewCursor()\n   cursor.First()\n   \n   WHILE NOT cursor.AtEnd:\n     a. rowid, record := cursor.Current()\n     \n     b. // Extract indexed column value\n        cache := NewColumnCache()\n        cache.SetRecord(record)\n        value, err := cache.GetColumn(colIndex)\n        IF err != nil:\n          RETURN nil, err\n     \n     c. // Check UNIQUE constraint\n        IF stmt.Unique:\n          existing, _ := idx.FindEqual(value)\n          IF len(existing) &gt; 0:\n            RETURN nil, UniqueConstraintError{\n              Index:     stmt.Name,\n              Value:     value,\n              ExistingRowid: existing[0],\n            }\n     \n     d. // Insert into index B+tree\n        payload := SerializeIndexPayload(value)\n        err := idx.insertIntoBTree(payload, rowid)\n        IF err != nil:\n          RETURN nil, err\n     \n     e. cursor.Next()\n\n5. REGISTER INDEX\n   a. im.indexes[stmt.Name] = idx\n   b. im.tableIndex[stmt.TableName] = append(im.tableIndex[stmt.TableName], stmt.Name)\n   c. catalog.RecordIndex(stmt.Name, stmt.TableName, stmt.ColumnName, rootPageID)\n\n6. RETURN idx, nil\n\nCOMPLEXITY: O(n log n) for n table rows\nSPACE: O(n) index entries, ~1-2 pages per 100 rows depending on value size</code></pre></div>\n\n<h3 id=\"index-equality-lookup\">Index Equality Lookup</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-29.svg\" alt=\"Index Range Scan via Leaf Links\"></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: Index.FindEqual\nINPUT: Value to search for\nOUTPUT: []int64 of matching rowids\n\n1. targetPayload := SerializeIndexPayload(value)\n   results := []int64{}\n\n2. // Navigate to leaf containing target\n   pageID := idx.RootPageID\n   \n   WHILE true:\n     a. page := bufferPool.FetchPage(pageID)\n     \n     b. IF page.Type() == PageTypeIndexLeaf:\n        // Found leaf - binary search for target\n        c.Cursor = &amp;IndexCursor{Index: idx, CurrentPage: page, PageID: pageID}\n        found := c.seekToValue(value)\n        IF NOT found:\n          page.Unpin(false)\n          RETURN results, nil\n        BREAK\n     \n     c. // Internal page: find child\n        childPageNum := page.FindChildPageForIndex(targetPayload)\n        page.Unpin(false)\n        pageID = PageID{PageNum: int(childPageNum)}\n\n3. // Collect all matching entries (may span multiple cells)\n   WHILE NOT c.AtEnd:\n     a. currentValue, rowid := c.Current()\n     \n     b. // Compare values\n        cmp := CompareValues(currentValue, value)\n        IF cmp != 0:\n          BREAK  // Past matching range\n     \n     c. results = append(results, rowid)\n     d. c.Next()\n\n4. c.Close()\n   RETURN results, nil\n\nALGORITHM: IndexCursor.seekToValue\nINPUT: Target value\nOUTPUT: True if found, cursor positioned at first match\n\n1. // Binary search within leaf\n   cellCount := c.CurrentPage.CellCount()\n   low, high := 0, cellCount-1\n   \n   WHILE low &lt;= high:\n     a. mid := (low + high) / 2\n     b. offset := c.CurrentPage.CellPointer(mid)\n     c. payload, rowid, _, _ := c.CurrentPage.ReadIndexLeafCell(int(offset))\n     d. midValue := DeserializeIndexPayload(payload)\n     \n     e. cmp := CompareValues(midValue, target)\n        IF cmp == 0:\n          // Found match - position cursor\n          c.CellIndex = mid\n          c.Payload = payload\n          c.Rowid = rowid\n          c.Value = midValue\n          RETURN true\n        ELSE IF cmp &lt; 0:\n          low = mid + 1\n        ELSE:\n          high = mid - 1\n\n2. // Not found - position at insertion point\n   c.CellIndex = low\n   IF low &lt; cellCount:\n     offset := c.CurrentPage.CellPointer(low)\n     c.Payload, c.Rowid, _, _ = c.CurrentPage.ReadIndexLeafCell(int(offset))\n     c.Value = DeserializeIndexPayload(c.Payload)\n   ELSE:\n     c.AtEnd = true\n   \n   RETURN false\n\nCOMPLEXITY: O(log n) for tree descent + O(log m) for leaf binary search\n           where n = total entries, m = entries per leaf</code></pre></div>\n\n<h3 id=\"index-range-scan-via-leaf-linking\">Index Range Scan via Leaf Linking</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: Index.FindRange\nINPUT: Low value (inclusive), High value (inclusive)\nOUTPUT: []int64 of rowids within range\n\n1. results := []int64{}\n   cursor := idx.NewCursor()\n\n2. // Seek to low value\n   found := cursor.seekToValue(low)\n   IF NOT found AND cursor.AtEnd:\n     RETURN results, nil  // Empty range\n\n3. // Scan forward until past high value\n   WHILE NOT cursor.AtEnd:\n     a. currentValue, rowid := cursor.Current()\n     \n     b. // Check if still in range\n        cmpHigh := CompareValues(currentValue, high)\n        IF cmpHigh &gt; 0:\n          BREAK  // Past high end of range\n     \n     c. // Entry is in range\n        results = append(results, rowid)\n     \n     d. cursor.Next()\n\n4. cursor.Close()\n   RETURN results, nil\n\nCOMPLEXITY: O(log n) for seek + O(k) for scan where k = results\nKEY INSIGHT: Leaf linking enables sequential I/O for range scans\n            Each leaf transition is O(1), not O(log n)</code></pre></div>\n\n<h3 id=\"index-maintenance-on-insert\">Index Maintenance on INSERT</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// index_maintenance.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// OnInsert is called after a row is inserted into the table.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Updates all indexes for the table.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">im </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">OnInsert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">values</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> im.</span><span style=\"color:#B392F0\">GetTableIndexes</span><span style=\"color:#E1E4E8\">(tableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    schema </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> im.catalog.</span><span style=\"color:#B392F0\">GetSchema</span><span style=\"color:#E1E4E8\">(tableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, idx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> indexes {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        colIndex </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> schema.</span><span style=\"color:#B392F0\">GetColumnIndex</span><span style=\"color:#E1E4E8\">(idx.ColumnName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        value </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> values[colIndex]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Convert to Value type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        val </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> interfaceToValue</span><span style=\"color:#E1E4E8\">(value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check UNIQUE constraint</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> idx.IsUnique {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            existing, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">FindEqual</span><span style=\"color:#E1E4E8\">(val)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(existing) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#B392F0\"> UniqueConstraintError</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    Table:  tableName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    Column: idx.ColumnName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    Value:  val,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Insert into index</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">InsertEntry</span><span style=\"color:#E1E4E8\">(val, rowid); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// InsertEntry adds an entry to the index B+tree.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">InsertEntry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SerializeIndexPayload</span><span style=\"color:#E1E4E8\">(value)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">insertIntoBTree</span><span style=\"color:#E1E4E8\">(payload, rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">insertIntoBTree</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Navigate to correct leaf</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Insert cell (payload, rowid)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle split if necessary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Similar to table B-tree insert but with index cell format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"index-maintenance-on-update\">Index Maintenance on UPDATE</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// OnUpdate is called when a row is updated.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Only updates indexes for changed columns.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">im </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">OnUpdate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">oldValues</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">newValues</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> im.</span><span style=\"color:#B392F0\">GetTableIndexes</span><span style=\"color:#E1E4E8\">(tableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    schema </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> im.catalog.</span><span style=\"color:#B392F0\">GetSchema</span><span style=\"color:#E1E4E8\">(tableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, idx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> indexes {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        colIndex </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> schema.</span><span style=\"color:#B392F0\">GetColumnIndex</span><span style=\"color:#E1E4E8\">(idx.ColumnName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        oldValue </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> interfaceToValue</span><span style=\"color:#E1E4E8\">(oldValues[colIndex])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        newValue </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> interfaceToValue</span><span style=\"color:#E1E4E8\">(newValues[colIndex])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Skip if indexed column didn't change</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#B392F0\"> CompareValues</span><span style=\"color:#E1E4E8\">(oldValue, newValue) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> CompareEqual {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check UNIQUE constraint on new value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> idx.IsUnique {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            existing, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">FindEqual</span><span style=\"color:#E1E4E8\">(newValue)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(existing) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> existing[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> rowid {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#B392F0\"> UniqueConstraintError</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    Table:  tableName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    Column: idx.ColumnName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    Value:  newValue,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Update index: delete old, insert new</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">DeleteEntry</span><span style=\"color:#E1E4E8\">(oldValue, rowid); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">InsertEntry</span><span style=\"color:#E1E4E8\">(newValue, rowid); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"index-maintenance-on-delete\">Index Maintenance on DELETE</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// OnDelete is called before a row is deleted from the table.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Removes entries from all indexes.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">im </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">OnDelete</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">values</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> im.</span><span style=\"color:#B392F0\">GetTableIndexes</span><span style=\"color:#E1E4E8\">(tableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    schema </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> im.catalog.</span><span style=\"color:#B392F0\">GetSchema</span><span style=\"color:#E1E4E8\">(tableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, idx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> indexes {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        colIndex </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> schema.</span><span style=\"color:#B392F0\">GetColumnIndex</span><span style=\"color:#E1E4E8\">(idx.ColumnName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        value </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> interfaceToValue</span><span style=\"color:#E1E4E8\">(values[colIndex])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">DeleteEntry</span><span style=\"color:#E1E4E8\">(value, rowid); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DeleteEntry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rowid</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find the entry (value, rowid)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remove from B+tree</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle underflow if necessary (optional for initial implementation)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"unique-constraint-enforcement\">UNIQUE Constraint Enforcement</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// unique_constraint.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> UniqueConstraintError</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Table   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Column  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Value   </span><span style=\"color:#B392F0\">Value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Index   </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // For index-level errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ExistingRowid </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#B392F0\">UniqueConstraintError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> e.Index </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"UNIQUE constraint failed: index </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, value </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, e.Index, e.Value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"UNIQUE constraint failed: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, e.Table, e.Column)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CheckUnique verifies no duplicate exists before insert.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CheckUnique</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">idx.IsUnique {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#6A737D\">  // Not a unique index, always OK</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    existing, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">FindEqual</span><span style=\"color:#E1E4E8\">(value)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(existing) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> existing[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#6A737D\">  // Duplicate found</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#6A737D\">  // No duplicate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"double-lookup-pattern\">Double Lookup Pattern</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-30.svg\" alt=\"Index Maintenance on DML\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// double_lookup.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DoubleLookup performs index lookup followed by table fetch.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is the core pattern for index-driven queries.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DoubleLookup</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IndexCursor  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexCursor</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TableCursor  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Cursor</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TableTree    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BTree</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewDoubleLookup creates a double-lookup iterator.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewDoubleLookup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">idx</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">tableTree</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">BTree</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DoubleLookup</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">DoubleLookup</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        IndexCursor: idx.</span><span style=\"color:#B392F0\">NewCursor</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TableTree:   tableTree,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SeekEqual positions at rows matching an equality predicate.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">dl </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DoubleLookup</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SeekEqual</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#B392F0\"> Value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    found </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> dl.IndexCursor.</span><span style=\"color:#B392F0\">seekToValue</span><span style=\"color:#E1E4E8\">(value)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">found {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dl.IndexCursor.AtEnd </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Next fetches the next matching row.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns (rowid, record, error).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">dl </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DoubleLookup</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> dl.IndexCursor.AtEnd {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, io.EOF</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get rowid from index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, rowid </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> dl.IndexCursor.</span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Fetch row from table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dl.TableCursor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> dl.TableTree.</span><span style=\"color:#B392F0\">NewCursor</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    found, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> dl.TableCursor.</span><span style=\"color:#B392F0\">SeekRowid</span><span style=\"color:#E1E4E8\">(rowid)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">found {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Row was deleted but index not updated - corruption</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"index corruption: rowid </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> in index but not in table\"</span><span style=\"color:#E1E4E8\">, rowid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> dl.TableCursor.</span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dl.TableCursor.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Advance index cursor</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dl.IndexCursor.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> rowid, record, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Close releases resources.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">dl </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DoubleLookup</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dl.IndexCursor.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> dl.TableCursor </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dl.TableCursor.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY double lookup:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Index gives O(log n) seek instead of O(n) scan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Table fetch gets full row (index only has indexed column)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Tradeoff: 2 B-tree traversals vs 1 full scan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Break-even point: ~20% selectivity threshold</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Covering indexes avoid double lookup (future enhancement)</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"error-handling-matrix\">Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th>Error</th>\n<th>Detected By</th>\n<th>Recovery</th>\n<th>User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>UNIQUE constraint violation</td>\n<td><code>CheckUnique</code> before insert</td>\n<td>Reject INSERT/UPDATE</td>\n<td>Yes: &quot;UNIQUE constraint failed: {table}.{column}&quot;</td>\n</tr>\n<tr>\n<td>Table doesn&#39;t exist</td>\n<td><code>CreateIndex</code> validation</td>\n<td>Return error immediately</td>\n<td>Yes: &quot;no such table: {name}&quot;</td>\n</tr>\n<tr>\n<td>Column doesn&#39;t exist</td>\n<td><code>CreateIndex</code> validation</td>\n<td>Return error immediately</td>\n<td>Yes: &quot;no such column: {table}.{column}&quot;</td>\n</tr>\n<tr>\n<td>Index name conflict</td>\n<td><code>CreateIndex</code> validation</td>\n<td>Return error immediately</td>\n<td>Yes: &quot;index {name} already exists&quot;</td>\n</tr>\n<tr>\n<td>Index corruption (rowid in index but not table)</td>\n<td><code>DoubleLookup.Next</code></td>\n<td>Return error, suggest REINDEX</td>\n<td>Yes: &quot;index corruption detected&quot;</td>\n</tr>\n<tr>\n<td>Page allocation failure</td>\n<td><code>insertIntoBTree</code></td>\n<td>Return error, rollback transaction</td>\n<td>Yes: &quot;database or disk is full&quot;</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"implementation-sequence-with-checkpoints\">Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-index-btree-leaf-and-internal-pages-2-hours\">Phase 1: Index B+tree Leaf and Internal Pages (2 hours)</h3>\n<p><strong>Files to create</strong>: <code>index_leaf.go</code>, <code>index_internal.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>ReadIndexLeafCell</code> and <code>WriteIndexLeafCell</code></li>\n<li>Implement <code>RightSibling</code>/<code>SetRightSibling</code> for leaf linking</li>\n<li>Implement <code>ReadIndexInternalCell</code></li>\n<li>Implement <code>FindChildPageForIndex</code></li>\n<li>Implement <code>SerializeIndexPayload</code> and <code>DeserializeIndexPayload</code></li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should read/write index cells. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestIndexCellFormat</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (index cell serialization works)</span></span></code></pre></div>\n\n<h3 id=\"phase-2-create-index-from-table-scan-2-hours\">Phase 2: CREATE INDEX from Table Scan (2 hours)</h3>\n<p><strong>Files to create</strong>: <code>create_index.go</code>, <code>index.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>Index</code> struct and <code>IndexManager</code></li>\n<li>Implement <code>CreateIndex</code> with table scan</li>\n<li>Implement index B-tree insertion</li>\n<li>Handle UNIQUE constraint during creation</li>\n<li>Register index in catalog</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should create indexes. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestCreateIndex</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (index created and populated from table)</span></span></code></pre></div>\n\n<h3 id=\"phase-3-index-equality-and-range-lookup-15-hours\">Phase 3: Index Equality and Range Lookup (1.5 hours)</h3>\n<p><strong>Files to create</strong>: <code>index_cursor.go</code>, <code>index_lookup.go</code>, <code>index_range.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>IndexCursor</code> with leaf linking</li>\n<li>Implement <code>seekToValue</code> with binary search</li>\n<li>Implement <code>FindEqual</code> returning rowids</li>\n<li>Implement <code>FindRange</code> via leaf traversal</li>\n<li>Test cursor positioning</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should look up values. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestIndexLookup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (equality and range lookups work)</span></span></code></pre></div>\n\n<h3 id=\"phase-4-index-maintenance-on-insertupdatedelete-2-hours\">Phase 4: Index Maintenance on INSERT/UPDATE/DELETE (2 hours)</h3>\n<p><strong>Files to create</strong>: <code>index_maintenance.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>OnInsert</code> hook for all table indexes</li>\n<li>Implement <code>OnUpdate</code> for changed columns only</li>\n<li>Implement <code>OnDelete</code> to remove index entries</li>\n<li>Integrate with DML execution layer</li>\n<li>Test consistency after operations</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point indexes should stay consistent. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestIndexMaintenance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (indexes updated on DML)</span></span></code></pre></div>\n\n<h3 id=\"phase-5-unique-constraint-enforcement-05-hours\">Phase 5: UNIQUE Constraint Enforcement (0.5 hours)</h3>\n<p><strong>Files to create</strong>: <code>unique_constraint.go</code>, <code>double_lookup.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>CheckUnique</code> for constraint checking</li>\n<li>Implement <code>UniqueConstraintError</code></li>\n<li>Implement <code>DoubleLookup</code> pattern</li>\n<li>Integrate UNIQUE check with INSERT/UPDATE</li>\n<li>Full test suite</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should pass all tests. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> ./index</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: All tests PASS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify: Index lookup faster than table scan for low selectivity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify: UNIQUE constraint rejects duplicates</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"test-specification\">Test Specification</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// index_test.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestCreateIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create table with data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDB</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE TABLE users (id INTEGER, name TEXT, email TEXT)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, 'user</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">', 'user</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">@example.com')\"</span><span style=\"color:#E1E4E8\">, i, i, i))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE INDEX idx_email ON users(email)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify index exists</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    idx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.IndexManager.</span><span style=\"color:#B392F0\">GetIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"idx_email\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NotNil</span><span style=\"color:#E1E4E8\">(t, idx)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">, idx.TableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#9ECBFF\">\"email\"</span><span style=\"color:#E1E4E8\">, idx.ColumnName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestIndexEqualityLookup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDBWithUsers</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE INDEX idx_email ON users(email)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    idx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.IndexManager.</span><span style=\"color:#B392F0\">GetIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"idx_email\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Lookup existing value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowids, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">FindEqual</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">StringValue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"user50@example.com\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Len</span><span style=\"color:#E1E4E8\">(t, rowids, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">50</span><span style=\"color:#E1E4E8\">), rowids[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Lookup non-existent value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowids, err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">FindEqual</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">StringValue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"nonexistent@example.com\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Len</span><span style=\"color:#E1E4E8\">(t, rowids, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestIndexRangeScan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDBWithUsers</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE INDEX idx_id ON users(id)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    idx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.IndexManager.</span><span style=\"color:#B392F0\">GetIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"idx_id\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Range scan 20-30</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowids, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">FindRange</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">IntegerValue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#B392F0\">IntegerValue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">30</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Len</span><span style=\"color:#E1E4E8\">(t, rowids, </span><span style=\"color:#79B8FF\">11</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\">// 20 through 30 inclusive</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify sorted order</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(rowids)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        assert.</span><span style=\"color:#B392F0\">Less</span><span style=\"color:#E1E4E8\">(t, rowids[i], rowids[i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestIndexMaintenanceInsert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDBWithUsers</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE INDEX idx_email ON users(email)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Insert new row</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (100, 'newuser', 'new@example.com')\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    idx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.IndexManager.</span><span style=\"color:#B392F0\">GetIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"idx_email\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify index updated</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowids, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">FindEqual</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">StringValue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"new@example.com\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Len</span><span style=\"color:#E1E4E8\">(t, rowids, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">), rowids[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestIndexMaintenanceUpdate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDBWithUsers</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE INDEX idx_email ON users(email)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update email</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"UPDATE users SET email = 'updated@example.com' WHERE id = 5\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    idx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.IndexManager.</span><span style=\"color:#B392F0\">GetIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"idx_email\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Old value should not be in index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowids, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">FindEqual</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">StringValue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"user5@example.com\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Len</span><span style=\"color:#E1E4E8\">(t, rowids, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // New value should be in index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowids, _ </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">FindEqual</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">StringValue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"updated@example.com\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Len</span><span style=\"color:#E1E4E8\">(t, rowids, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestIndexMaintenanceDelete</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDBWithUsers</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE INDEX idx_email ON users(email)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Delete row</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"DELETE FROM users WHERE id = 5\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    idx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.IndexManager.</span><span style=\"color:#B392F0\">GetIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"idx_email\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Deleted value should not be in index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowids, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">FindEqual</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">StringValue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"user5@example.com\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Len</span><span style=\"color:#E1E4E8\">(t, rowids, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestUniqueConstraint</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDB</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE TABLE users (id INTEGER, email TEXT)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE UNIQUE INDEX idx_unique_email ON users(email)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (1, 'alice@example.com')\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Duplicate insert should fail</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (2, 'alice@example.com')\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(t, err.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#9ECBFF\">\"UNIQUE constraint failed\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify only one row exists</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rows </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Query</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM users\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Len</span><span style=\"color:#E1E4E8\">(t, rows, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestUniqueConstraintOnUpdate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDB</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE TABLE users (id INTEGER, email TEXT)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE UNIQUE INDEX idx_unique_email ON users(email)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (1, 'alice@example.com')\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (2, 'bob@example.com')\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update to duplicate should fail</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"UPDATE users SET email = 'alice@example.com' WHERE id = 2\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(t, err.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#9ECBFF\">\"UNIQUE constraint failed\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestDoubleLookup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDBWithUsers</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE INDEX idx_email ON users(email)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Query using index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rows </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Query</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM users WHERE email = 'user50@example.com'\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Len</span><span style=\"color:#E1E4E8\">(t, rows, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">50</span><span style=\"color:#E1E4E8\">), rows[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">][</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].Int)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#9ECBFF\">\"user50\"</span><span style=\"color:#E1E4E8\">, rows[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">][</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">].Str)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestIndexPerformanceVsTableScan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> testing.</span><span style=\"color:#B392F0\">Short</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">Skip</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Skipping performance test\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDB</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE TABLE users (id INTEGER, email TEXT)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, 'user</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">@example.com')\"</span><span style=\"color:#E1E4E8\">, i, i))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE INDEX idx_email ON users(email)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Measure table scan</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">ResetStats</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Query</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM users WHERE email = 'user9999@example.com'\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    scanTime </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Since</span><span style=\"color:#E1E4E8\">(start)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    scanPages </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Stats</span><span style=\"color:#E1E4E8\">().PagesRead</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Reset and measure index lookup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">ResetStats</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Query should use index (when planner is implemented)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For now, manually test index lookup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    idx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.IndexManager.</span><span style=\"color:#B392F0\">GetIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"idx_email\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowids, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">FindEqual</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">StringValue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"user9999@example.com\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexTime </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Since</span><span style=\"color:#E1E4E8\">(start)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexPages </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Stats</span><span style=\"color:#E1E4E8\">().PagesRead</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Index should be significantly faster</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Less</span><span style=\"color:#E1E4E8\">(t, indexPages, scanPages</span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Index should read far fewer pages\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Less</span><span style=\"color:#E1E4E8\">(t, indexTime, scanTime</span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Index should be significantly faster\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Len</span><span style=\"color:#E1E4E8\">(t, rowids, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">9999</span><span style=\"color:#E1E4E8\">), rowids[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestIndexOnNullValues</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDB</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE TABLE users (id INTEGER, email TEXT)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (1, 'alice@example.com')\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (2, NULL)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (3, NULL)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create index (should succeed with NULLs)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE INDEX idx_email ON users(email)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // NULL lookups</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    idx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.IndexManager.</span><span style=\"color:#B392F0\">GetIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"idx_email\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rowids, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">FindEqual</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">{Type: ValueNull})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Len</span><span style=\"color:#E1E4E8\">(t, rowids, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\">// Both NULL rows</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestUniqueIndexWithNulls</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDB</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE TABLE users (id INTEGER, email TEXT)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (1, NULL)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // SQLite allows multiple NULLs in UNIQUE index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE UNIQUE INDEX idx_email ON users(email)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Second NULL should be allowed (SQLite behavior)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (2, NULL)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)  </span><span style=\"color:#6A737D\">// NULLs are distinct in UNIQUE index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-targets\">Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Target</th>\n<th>How to Measure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Index equality lookup</td>\n<td>O(log n) + 2 page reads</td>\n<td><code>go test -bench=BenchmarkIndexLookup</code></td>\n</tr>\n<tr>\n<td>Index range scan</td>\n<td>O(log n) + O(k) pages</td>\n<td><code>go test -bench=BenchmarkRangeScan</code></td>\n</tr>\n<tr>\n<td>Index maintenance on INSERT</td>\n<td>+50-200% vs no index</td>\n<td>Compare INSERT with/without indexes</td>\n</tr>\n<tr>\n<td>Index maintenance on UPDATE</td>\n<td>+50-200% if indexed column changes</td>\n<td>Compare UPDATE on indexed vs non-indexed column</td>\n</tr>\n<tr>\n<td>CREATE INDEX on 10K rows</td>\n<td>&lt; 500ms</td>\n<td><code>go test -bench=BenchmarkCreateIndex</code></td>\n</tr>\n<tr>\n<td>Double lookup vs table scan</td>\n<td>&lt; 10% of scan for 1% selectivity</td>\n<td><code>go test -bench=BenchmarkSelectivity</code></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"synced-criteria\">Synced Criteria</h2>\n<p>[[CRITERIA_JSON: {&quot;module_id&quot;: &quot;build-sqlite-m7&quot;, &quot;criteria&quot;: [&quot;CREATE INDEX builds a B+tree mapping column values to rowids&quot;, &quot;INSERT/UPDATE/DELETE operations maintain all associated indexes synchronously&quot;, &quot;Index lookup (equality) avoids full table scan and visits significantly fewer pages&quot;, &quot;Index range scan (BETWEEN or &lt; &gt;) traverses linked leaf pages&quot;, &quot;UNIQUE index correctly rejects duplicate value insertions&quot;, &quot;Bytecode VM can perform a &#39;Double Lookup&#39; from index cursor to table cursor&quot;]}]</p>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-sqlite-m8 -->\n<h1 id=\"technical-design-specification-query-planner-amp-statistics\">Technical Design Specification: Query Planner &amp; Statistics</h1>\n<h2 id=\"module-charter\">Module Charter</h2>\n<p>The Query Planner transforms a parsed SELECT AST into an execution plan by estimating the cost of alternative access paths and selecting the cheapest. It implements ANALYZE to collect table statistics (row counts, distinct value counts per column), selectivity estimation for predicates, a cost model comparing sequential I/O (table scan) vs random I/O (index scan), and greedy join order optimization for multi-table queries. The planner does NOT execute queries, modify data, or guarantee optimal plans—it makes best-effort decisions with available statistics. Upstream dependencies: Parser (provides AST), Index Manager (provides index metadata), Storage (provides row counts). Downstream dependencies: Bytecode Compiler (receives QueryPlan). Invariants: all plans are executable (valid table/index references); cost estimates are non-negative; selectivity is always between 0 and 1; planner never modifies database state.</p>\n<hr>\n<h2 id=\"file-structure\">File Structure</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>planner/\n├── statistics.go         # (1) Statistics struct, storage, ANALYZE command\n├── stat_storage.go       # (2) sqlite_stat1 table persistence\n├── selectivity.go        # (3) Predicate selectivity estimation\n├── cost_model.go         # (4) Cost model for table scan vs index scan\n├── planner.go            # (5) Planner struct and PlanSelect entry point\n├── access_path.go        # (6) AccessPath interface and implementations\n├── query_plan.go         # (7) QueryPlan with cost and row estimates\n├── table_scan_path.go    # (8) TableScanPath implementation\n├── index_scan_path.go    # (9) IndexScanPath implementation\n├── join_planner.go       # (10) Join order optimization (greedy)\n├── explain.go            # (11) EXPLAIN output formatter\n├── planner_test.go       # (12) Comprehensive test suite\n└── defaults.go           # (13) Default assumptions without statistics</code></pre></div>\n\n<hr>\n<h2 id=\"complete-data-model\">Complete Data Model</h2>\n<h3 id=\"statistics-structure\">Statistics Structure</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// statistics.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TableStatistics holds collected statistics for a single table.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TableStatistics</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TableName     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RowCount      </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">                    // Total rows in table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PageCount     </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">                    // Total pages (calculated from rows)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ColumnStats   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ColumnStats</span><span style=\"color:#6A737D\">  // Column name -> statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastAnalyzed  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#6A737D\">                // When ANALYZE was run</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ColumnStats holds statistics for a single column.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ColumnStats</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ColumnName    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DistinctCount </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">    // Number of distinct values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NullCount     </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">    // Number of NULL values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MinValue      </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#6A737D\">    // Minimum value (for range estimation)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxValue      </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#6A737D\">    // Maximum value (for range estimation)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Histogram buckets (optional, for advanced selectivity)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Histogram     []HistogramBucket</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StatisticsManager manages statistics for all tables.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> StatisticsManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats      </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TableStatistics</span><span style=\"color:#6A737D\">  // table name -> stats</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    storage    </span><span style=\"color:#B392F0\">StatStorage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    catalog    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Catalog</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewStatisticsManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">storage</span><span style=\"color:#B392F0\"> StatStorage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">catalog</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Catalog</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StatisticsManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">StatisticsManager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stats:   </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TableStatistics</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        storage: storage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        catalog: catalog,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetTableStats returns statistics for a table, or default estimates.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StatisticsManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetTableStats</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TableStatistics</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> stats, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sm.stats[tableName]; exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> stats</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Try to load from storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sm.storage.</span><span style=\"color:#B392F0\">Load</span><span style=\"color:#E1E4E8\">(tableName)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sm.stats[tableName] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> stats</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> stats</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return default estimates</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> sm.</span><span style=\"color:#B392F0\">defaultStats</span><span style=\"color:#E1E4E8\">(tableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// defaultStats returns conservative default statistics.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StatisticsManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">defaultStats</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TableStatistics</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">TableStatistics</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TableName: tableName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        RowCount:  DefaultRowCount,      </span><span style=\"color:#6A737D\">// 1000 rows</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        PageCount: DefaultPageCount,     </span><span style=\"color:#6A737D\">// 50 pages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ColumnStats: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ColumnStats</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY Statistics:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - RowCount: Base for all selectivity calculations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - DistinctCount: Enables equality predicate selectivity (1/distinct)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - PageCount: Drives I/O cost estimation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Defaults: Enable planning even without ANALYZE</span></span></code></pre></div>\n\n<h3 id=\"stat-storage-sqlite_stat1\">Stat Storage (sqlite_stat1)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// stat_storage.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StatStorage persists statistics to sqlite_stat1 table.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> StatStorage</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Save</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">stats</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TableStatistics</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Load</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TableStatistics</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Delete</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SQLiteStat1Storage implements StatStorage using sqlite_stat1 table.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SQLiteStat1Storage</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// sqlite_stat1 schema:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CREATE TABLE sqlite_stat1 (</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//     tbl TEXT,     -- Table name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//     idx TEXT,     -- Index name (NULL for table stats)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//     stat TEXT     -- Space-separated: \"rows distinct1 distinct2 ...\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// );</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SQLiteStat1Storage</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Save</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">stats</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TableStatistics</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Build stat string: \"rowcount\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    statStr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, stats.RowCount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Delete existing entry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"DELETE FROM sqlite_stat1 WHERE tbl = ? AND idx IS NULL\"</span><span style=\"color:#E1E4E8\">, stats.TableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Insert new entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> s.db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"INSERT INTO sqlite_stat1 (tbl, idx, stat) VALUES (?, NULL, ?)\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stats.TableName, statStr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SQLiteStat1Storage</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SaveIndexStats</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tableName</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">indexName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rowCount</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">distinctCount</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    statStr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#79B8FF\"> %d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, rowCount, distinctCount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"DELETE FROM sqlite_stat1 WHERE tbl = ? AND idx = ?\"</span><span style=\"color:#E1E4E8\">, tableName, indexName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> s.db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"INSERT INTO sqlite_stat1 (tbl, idx, stat) VALUES (?, ?, ?)\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tableName, indexName, statStr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SQLiteStat1Storage</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Load</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TableStatistics</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rows, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> s.db.</span><span style=\"color:#B392F0\">Query</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"SELECT idx, stat FROM sqlite_stat1 WHERE tbl = ?\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tableName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">TableStatistics</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TableName:   tableName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ColumnStats: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ColumnStats</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, row </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> rows {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        idxName </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> row[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].Str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        statStr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> row[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">].Str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        parts </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">Split</span><span style=\"color:#E1E4E8\">(statStr, </span><span style=\"color:#9ECBFF\">\" \"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(parts) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rowCount, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strconv.</span><span style=\"color:#B392F0\">ParseInt</span><span style=\"color:#E1E4E8\">(parts[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stats.RowCount </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> rowCount</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> idxName </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Table-level stats</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            stats.PageCount </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (rowCount </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> RowsPerPage </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> RowsPerPage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Index stats</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(parts) </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                distinctCount, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strconv.</span><span style=\"color:#B392F0\">ParseInt</span><span style=\"color:#E1E4E8\">(parts[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Store in column stats (index maps to column)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                stats.ColumnStats[idxName] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ColumnStats</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    DistinctCount: distinctCount,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> stats.RowCount </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"no statistics found\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> stats, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"selectivity-estimation\">Selectivity Estimation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// selectivity.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SelectivityEstimator estimates predicate selectivity.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SelectivityEstimator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StatisticsManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EstimateSelectivity returns the fraction of rows matching a predicate.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns a value between 0.0 and 1.0.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">se </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SelectivityEstimator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">EstimateSelectivity</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    predicate</span><span style=\"color:#B392F0\"> Expression</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> predicate </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#6A737D\">  // No filter = all rows</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> se.</span><span style=\"color:#B392F0\">estimateExpression</span><span style=\"color:#E1E4E8\">(tableName, predicate)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">se </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SelectivityEstimator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">estimateExpression</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    expr</span><span style=\"color:#B392F0\"> Expression</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> e </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> expr.(</span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">BinaryExpression</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> se.</span><span style=\"color:#B392F0\">estimateBinary</span><span style=\"color:#E1E4E8\">(tableName, e)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">UnaryExpression</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> e.Operator </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"NOT\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // NOT flips selectivity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> se.</span><span style=\"color:#B392F0\">estimateExpression</span><span style=\"color:#E1E4E8\">(tableName, e.Operand)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\"> sel</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> DefaultSelectivity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ParenExpression</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> se.</span><span style=\"color:#B392F0\">estimateExpression</span><span style=\"color:#E1E4E8\">(tableName, e.Expression)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">InExpression</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // IN (a, b, c) selectivity = count / distinct</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> se.</span><span style=\"color:#B392F0\">estimateIn</span><span style=\"color:#E1E4E8\">(tableName, e)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">BetweenExpression</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // BETWEEN selectivity: assume uniform distribution</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> se.</span><span style=\"color:#B392F0\">estimateBetween</span><span style=\"color:#E1E4E8\">(tableName, e)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">IsNullExpression</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // IS NULL selectivity = null_count / row_count</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> se.</span><span style=\"color:#B392F0\">estimateIsNull</span><span style=\"color:#E1E4E8\">(tableName, e)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">LikeExpression</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // LIKE selectivity: hard to estimate, use default</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> DefaultLikeSelectivity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> DefaultSelectivity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">se </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SelectivityEstimator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">estimateBinary</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    expr</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">BinaryExpression</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> expr.Operator {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"AND\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        left </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> se.</span><span style=\"color:#B392F0\">estimateExpression</span><span style=\"color:#E1E4E8\">(tableName, expr.Left)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        right </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> se.</span><span style=\"color:#B392F0\">estimateExpression</span><span style=\"color:#E1E4E8\">(tableName, expr.Right)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Assume independence (may over/underestimate)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> left </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> right</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"OR\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        left </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> se.</span><span style=\"color:#B392F0\">estimateExpression</span><span style=\"color:#E1E4E8\">(tableName, expr.Left)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        right </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> se.</span><span style=\"color:#B392F0\">estimateExpression</span><span style=\"color:#E1E4E8\">(tableName, expr.Right)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // P(A OR B) = P(A) + P(B) - P(A AND B)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> left </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> right </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> left</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">right</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"=\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> se.</span><span style=\"color:#B392F0\">estimateEquality</span><span style=\"color:#E1E4E8\">(tableName, expr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"&#x3C;>\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"!=\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Not equal: 1 - equality selectivity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        eqSel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> se.</span><span style=\"color:#B392F0\">estimateEquality</span><span style=\"color:#E1E4E8\">(tableName, expr)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\"> eqSel</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"&#x3C;\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"&#x3C;=\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\">=\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> se.</span><span style=\"color:#B392F0\">estimateRange</span><span style=\"color:#E1E4E8\">(tableName, expr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> DefaultSelectivity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">se </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SelectivityEstimator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">estimateEquality</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    expr</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">BinaryExpression</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Extract column name from left side</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    colName </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> extractColumnName</span><span style=\"color:#E1E4E8\">(expr.Left)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> colName </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> DefaultEqualitySelectivity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> se.stats.</span><span style=\"color:#B392F0\">GetTableStats</span><span style=\"color:#E1E4E8\">(tableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    colStats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> stats.ColumnStats[colName]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> colStats </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> colStats.DistinctCount </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Selectivity = 1 / distinct values</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#F97583\"> /</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(colStats.DistinctCount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // No statistics: use default</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> DefaultEqualitySelectivity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">se </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SelectivityEstimator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">estimateRange</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    expr</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">BinaryExpression</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Range selectivity: assume 1/3 of rows</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Better: use histogram if available</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> DefaultRangeSelectivity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">se </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SelectivityEstimator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">estimateIn</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    expr</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">InExpression</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // IN (a, b, c) selectivity = min(count / distinct, 1.0)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    count </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(expr.Values)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    colName </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> extractColumnName</span><span style=\"color:#E1E4E8\">(expr.Expression)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> colName </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> min</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">(count)</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">DefaultEqualitySelectivity, </span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> se.stats.</span><span style=\"color:#B392F0\">GetTableStats</span><span style=\"color:#E1E4E8\">(tableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    colStats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> stats.ColumnStats[colName]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> colStats </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> colStats.DistinctCount </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> min</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">(count)</span><span style=\"color:#F97583\">/float64</span><span style=\"color:#E1E4E8\">(colStats.DistinctCount), </span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> min</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">(count)</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">DefaultEqualitySelectivity, </span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">se </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SelectivityEstimator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">estimateBetween</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    expr</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">BetweenExpression</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // BETWEEN a AND b: estimate fraction of range</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Without histograms, assume 10% selectivity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> DefaultRangeSelectivity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">se </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SelectivityEstimator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">estimateIsNull</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    expr</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">IsNullExpression</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    colName </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> extractColumnName</span><span style=\"color:#E1E4E8\">(expr.Expression)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> colName </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> DefaultNullSelectivity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> se.stats.</span><span style=\"color:#B392F0\">GetTableStats</span><span style=\"color:#E1E4E8\">(tableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    colStats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> stats.ColumnStats[colName]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> colStats </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> stats.RowCount </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(colStats.NullCount) </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(stats.RowCount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> DefaultNullSelectivity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Default selectivity constants</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DefaultSelectivity</span><span style=\"color:#F97583\">        =</span><span style=\"color:#79B8FF\"> 0.1</span><span style=\"color:#6A737D\">   // 10% for unknown predicates</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DefaultEqualitySelectivity</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.1</span><span style=\"color:#6A737D\">  // 10% for = without stats</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DefaultRangeSelectivity</span><span style=\"color:#F97583\">   =</span><span style=\"color:#79B8FF\"> 0.33</span><span style=\"color:#6A737D\">  // 33% for range predicates</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DefaultLikeSelectivity</span><span style=\"color:#F97583\">    =</span><span style=\"color:#79B8FF\"> 0.1</span><span style=\"color:#6A737D\">   // 10% for LIKE</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DefaultNullSelectivity</span><span style=\"color:#F97583\">    =</span><span style=\"color:#79B8FF\"> 0.1</span><span style=\"color:#6A737D\">   // 10% for IS NULL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY selectivity estimation:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Drives index vs table scan decision</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Equality: 1/distinct is the key insight</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - AND/OR: independence assumption (may be wrong but workable)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Defaults: Conservative estimates prevent catastrophically bad plans</span></span></code></pre></div>\n\n<h3 id=\"cost-model\">Cost Model</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// cost_model.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CostModel estimates the I/O cost of different access paths.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CostModel</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SequentialIOCost </span><span style=\"color:#F97583\">float64</span><span style=\"color:#6A737D\">  // Cost per page for sequential read</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RandomIOCost     </span><span style=\"color:#F97583\">float64</span><span style=\"color:#6A737D\">  // Cost per page for random read</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CPUCostPerRow    </span><span style=\"color:#F97583\">float64</span><span style=\"color:#6A737D\">  // CPU cost per row processed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewDefaultCostModel</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CostModel</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">CostModel</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        SequentialIOCost: </span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#E1E4E8\">,   </span><span style=\"color:#6A737D\">// Baseline</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        RandomIOCost:     </span><span style=\"color:#79B8FF\">10.0</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Random I/O is ~10x slower</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CPUCostPerRow:    </span><span style=\"color:#79B8FF\">0.01</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// Small CPU overhead per row</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TableScanCost estimates cost of full table scan.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CostModel</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TableScanCost</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tableStats</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TableStatistics</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Table scan reads all pages sequentially</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ioCost </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(tableStats.PageCount) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> cm.SequentialIOCost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cpuCost </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(tableStats.RowCount) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> cm.CPUCostPerRow</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ioCost </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> cpuCost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IndexScanCost estimates cost of index lookup + table fetch.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CostModel</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IndexScanCost</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    tableStats</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TableStatistics</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    selectivity</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    matchingRows </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(tableStats.RowCount) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> selectivity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Index traversal: log_f(n) pages (usually 3-4 for any size)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexTraversalCost </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 4.0</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> cm.RandomIOCost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Table fetches: one random I/O per matching row</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // But rows may cluster, so assume rowsPerPage rows per fetch</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pagesRead </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> matchingRows </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> RowsPerPage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tableFetchCost </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> pagesRead </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> cm.RandomIOCost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cpuCost </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> matchingRows </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> cm.CPUCostPerRow</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> indexTraversalCost </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> tableFetchCost </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> cpuCost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY cost model:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Sequential I/O (table scan) is much faster than random I/O</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Index scan trades fewer rows for random access pattern</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Break-even point: ~20% selectivity (configurable)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Simple model captures the essential tradeoff</span></span></code></pre></div>\n\n<h3 id=\"access-path-and-query-plan\">Access Path and Query Plan</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// access_path.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AccessPath represents a way to access table data.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AccessPath</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    PlanType</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    EstimatedRows</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    EstimatedCost</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TableScanPath represents a full table scan.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TableScanPath</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TableName     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EstimatedRows </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Cost          </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TableScanPath</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PlanType</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"TABLE SCAN\"</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TableScanPath</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">EstimatedRows</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> p.EstimatedRows }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TableScanPath</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">EstimatedCost</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> p.Cost }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IndexScanPath represents an index-driven scan.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IndexScanPath</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TableName     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IndexName     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Predicate     </span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#6A737D\">  // Original predicate for index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Selectivity   </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EstimatedRows </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Cost          </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexScanPath</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PlanType</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"INDEX SCAN\"</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexScanPath</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">EstimatedRows</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> p.EstimatedRows }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexScanPath</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">EstimatedCost</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> p.Cost }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NestedLoopJoinPath represents a nested loop join.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NestedLoopJoinPath</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Left          </span><span style=\"color:#B392F0\">AccessPath</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Right         </span><span style=\"color:#B392F0\">AccessPath</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    JoinCondition </span><span style=\"color:#B392F0\">Expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EstimatedRows </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Cost          </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NestedLoopJoinPath</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PlanType</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"NESTED LOOP JOIN\"</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NestedLoopJoinPath</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">EstimatedRows</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> p.EstimatedRows }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NestedLoopJoinPath</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">EstimatedCost</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> p.Cost }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// query_plan.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// QueryPlan represents a complete execution plan.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> QueryPlan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AccessPath     </span><span style=\"color:#B392F0\">AccessPath</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Projection     []</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">    // Columns to output</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OrderBy        []</span><span style=\"color:#B392F0\">OrderBySpec</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Limit          </span><span style=\"color:#F97583\">*int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Offset         </span><span style=\"color:#F97583\">*int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EstimatedCost  </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EstimatedRows  </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> OrderBySpec</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Column     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Descending </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"planner\">Planner</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// planner.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SelectivityThreshold for choosing index vs table scan.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> IndexSelectivityThreshold</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.2</span><span style=\"color:#6A737D\">  // 20%</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Planner creates execution plans from SELECT ASTs.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Planner</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats         </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StatisticsManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    costModel     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CostModel</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    catalog       </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Catalog</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexManager  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    selectivity   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SelectivityEstimator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewPlanner</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    stats</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">StatisticsManager</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    catalog</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Catalog</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    indexManager</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">IndexManager</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Planner</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Planner</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stats:        stats,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        costModel:    </span><span style=\"color:#B392F0\">NewDefaultCostModel</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        catalog:      catalog,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        indexManager: indexManager,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        selectivity:  </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">SelectivityEstimator</span><span style=\"color:#E1E4E8\">{stats: stats},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PlanSelect creates an execution plan for a SELECT statement.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Planner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PlanSelect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">SelectStatement</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">QueryPlan</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validate table exists</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tableSchema </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.catalog.</span><span style=\"color:#B392F0\">GetSchema</span><span style=\"color:#E1E4E8\">(stmt.FromTable)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> tableSchema </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"no such table: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, stmt.FromTable)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get table statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tableStats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.stats.</span><span style=\"color:#B392F0\">GetTableStats</span><span style=\"color:#E1E4E8\">(stmt.FromTable)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate selectivity of WHERE clause</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    selectivity </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.selectivity.</span><span style=\"color:#B392F0\">EstimateSelectivity</span><span style=\"color:#E1E4E8\">(stmt.FromTable, stmt.Where)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Choose access path</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    accessPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">chooseAccessPath</span><span style=\"color:#E1E4E8\">(stmt.FromTable, stmt.Where, selectivity, tableStats)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Build projection list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    projection </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.</span><span style=\"color:#B392F0\">buildProjection</span><span style=\"color:#E1E4E8\">(stmt.Columns, tableSchema)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Estimate result rows</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    estimatedRows </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">(tableStats.RowCount) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> selectivity)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">QueryPlan</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        AccessPath:    accessPath,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Projection:    projection,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        OrderBy:       p.</span><span style=\"color:#B392F0\">buildOrderBy</span><span style=\"color:#E1E4E8\">(stmt.OrderBy),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Limit:         stmt.Limit,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Offset:        stmt.Offset,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        EstimatedCost: accessPath.</span><span style=\"color:#B392F0\">EstimatedCost</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        EstimatedRows: estimatedRows,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// chooseAccessPath selects between table scan and index scan.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Planner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">chooseAccessPath</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    where</span><span style=\"color:#B392F0\"> Expression</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    selectivity</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    tableStats</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TableStatistics</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AccessPath</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate table scan cost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tableScanCost </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.costModel.</span><span style=\"color:#B392F0\">TableScanCost</span><span style=\"color:#E1E4E8\">(tableStats)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find usable indexes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.indexManager.</span><span style=\"color:#B392F0\">GetTableIndexes</span><span style=\"color:#E1E4E8\">(tableName)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> bestIndex </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Index</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> bestIndexCost </span><span style=\"color:#F97583\">float64</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> math.MaxFloat64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, idx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> indexes {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check if index is usable for this query</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">p.</span><span style=\"color:#B392F0\">isIndexUsable</span><span style=\"color:#E1E4E8\">(idx, where) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        indexCost </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> p.costModel.</span><span style=\"color:#B392F0\">IndexScanCost</span><span style=\"color:#E1E4E8\">(tableStats, selectivity)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> indexCost </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> bestIndexCost {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            bestIndexCost </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> indexCost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            bestIndex </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> idx</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Decision: use index if selectivity is below threshold AND cost is lower</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> bestIndex </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> selectivity </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> IndexSelectivityThreshold </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> bestIndexCost </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> tableScanCost {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">IndexScanPath</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            TableName:     tableName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            IndexName:     bestIndex.Name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Predicate:     where,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Selectivity:   selectivity,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            EstimatedRows: </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">(tableStats.RowCount) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> selectivity),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Cost:          bestIndexCost,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Default: table scan</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">TableScanPath</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TableName:     tableName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        EstimatedRows: </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">(tableStats.RowCount) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> selectivity),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Cost:          tableScanCost,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// isIndexUsable checks if an index can serve the WHERE clause.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Planner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">isIndexUsable</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">idx</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">where</span><span style=\"color:#B392F0\"> Expression</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> where </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#6A737D\">  // No filter, index not useful</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Extract columns referenced in WHERE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    referencedCols </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> extractReferencedColumns</span><span style=\"color:#E1E4E8\">(where)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if indexed column is referenced</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, col </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> referencedCols {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> col </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> idx.ColumnName {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Planner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">buildProjection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">columns</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">ColumnSelection</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">schema</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Schema</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(columns) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> _, isStar </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> columns[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].Expression.(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StarExpression</span><span style=\"color:#E1E4E8\">); isStar {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // SELECT * - include all columns</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(schema.Columns))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> i, col </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> schema.Columns {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                result[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> col.Name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(columns))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, col </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> columns {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> id, ok </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> col.Expression.(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IdentifierExpression</span><span style=\"color:#E1E4E8\">); ok {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> id.Name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Planner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">buildOrderBy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">orderBy</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">OrderByColumn</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#B392F0\">OrderBySpec</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">OrderBySpec</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(orderBy))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, col </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> orderBy {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> id, ok </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> col.Expression.(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IdentifierExpression</span><span style=\"color:#E1E4E8\">); ok {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> OrderBySpec</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Column:     id.Name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Descending: col.Descending,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY planner:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Central decision point for query execution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Cost-based: uses statistics and I/O model</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Selectivity threshold prevents index overuse</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Extensible: can add more access paths (hash join, etc.)</span></span></code></pre></div>\n\n<h3 id=\"join-order-optimization\">Join Order Optimization</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-32.svg\" alt=\"Selectivity Estimation Algorithm\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// join_planner.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// JoinPlanner optimizes join order for multi-table queries.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> JoinPlanner</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats       </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StatisticsManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    costModel   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CostModel</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    selectivity </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SelectivityEstimator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PlanJoin creates a plan for a multi-table join.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Uses greedy algorithm: start with smallest table, join in order of increasing cost.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">jp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">JoinPlanner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PlanJoin</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    tables</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    joinConditions</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    whereClause</span><span style=\"color:#B392F0\"> Expression</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">AccessPath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(tables) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Single table - not a join</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"single table, not a join\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get statistics for all tables</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tableStats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TableStatistics</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, t </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> tables {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tableStats[t] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> jp.stats.</span><span style=\"color:#B392F0\">GetTableStats</span><span style=\"color:#E1E4E8\">(t)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Greedy: start with smallest table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    remaining </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(tables))</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(remaining, tables)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Sort by row count (ascending)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sort.</span><span style=\"color:#B392F0\">Slice</span><span style=\"color:#E1E4E8\">(remaining, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">i</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">j</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> tableStats[remaining[i]].RowCount </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> tableStats[remaining[j]].RowCount</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Build plan by joining one table at a time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> currentPlan </span><span style=\"color:#B392F0\">AccessPath</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // First table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    firstTable </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> remaining[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    selectivity </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> jp.selectivity.</span><span style=\"color:#B392F0\">EstimateSelectivity</span><span style=\"color:#E1E4E8\">(firstTable, </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        extractPredicatesForTable</span><span style=\"color:#E1E4E8\">(whereClause, firstTable))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentPlan </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">TableScanPath</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TableName:     firstTable,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        EstimatedRows: </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">(tableStats[firstTable].RowCount) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> selectivity),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Cost:          jp.costModel.</span><span style=\"color:#B392F0\">TableScanCost</span><span style=\"color:#E1E4E8\">(tableStats[firstTable]),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    remaining </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> remaining[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Join remaining tables</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(remaining) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Find best next table to join</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bestIdx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bestCost </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> math.MaxFloat64</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        var</span><span style=\"color:#E1E4E8\"> bestPlan </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NestedLoopJoinPath</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i, nextTable </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> remaining {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Estimate join cost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            nextStats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tableStats[nextTable]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            nextSelectivity </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> jp.selectivity.</span><span style=\"color:#B392F0\">EstimateSelectivity</span><span style=\"color:#E1E4E8\">(nextTable,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                extractPredicatesForTable</span><span style=\"color:#E1E4E8\">(whereClause, nextTable))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            nextRows </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">(nextStats.RowCount) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> nextSelectivity)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Join cardinality: assume independence, apply join selectivity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            joinSelectivity </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> jp.</span><span style=\"color:#B392F0\">estimateJoinSelectivity</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                currentPlan.</span><span style=\"color:#B392F0\">EstimatedRows</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                nextRows,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                joinConditions,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            resultRows </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">(currentPlan.</span><span style=\"color:#B392F0\">EstimatedRows</span><span style=\"color:#E1E4E8\">()) </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(nextRows) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> joinSelectivity)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Cost: scan outer + inner for each outer row</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cost </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> currentPlan.</span><span style=\"color:#B392F0\">EstimatedCost</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    float64</span><span style=\"color:#E1E4E8\">(currentPlan.</span><span style=\"color:#B392F0\">EstimatedRows</span><span style=\"color:#E1E4E8\">()) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> jp.costModel.</span><span style=\"color:#B392F0\">TableScanCost</span><span style=\"color:#E1E4E8\">(nextStats)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> cost </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> bestCost {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                bestCost </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                bestIdx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                bestPlan </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">NestedLoopJoinPath</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    Left:          currentPlan,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    Right:         </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">TableScanPath</span><span style=\"color:#E1E4E8\">{TableName: nextTable, EstimatedRows: nextRows},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    JoinCondition: </span><span style=\"color:#B392F0\">findJoinCondition</span><span style=\"color:#E1E4E8\">(currentPlan, nextTable, joinConditions),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    EstimatedRows: resultRows,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    Cost:          cost,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        currentPlan </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> bestPlan</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        remaining </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(remaining[:bestIdx], remaining[bestIdx</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:]</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> currentPlan, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// estimateJoinSelectivity estimates the fraction of rows that survive a join.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">jp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">JoinPlanner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">estimateJoinSelectivity</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    leftRows</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rightRows</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    conditions</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Simplified: assume 1/distinct for equality joins</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For a.id = b.id, selectivity ~ 1/max(distinct_left, distinct_right)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> DefaultJoinSelectivity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> DefaultJoinSelectivity</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.01</span><span style=\"color:#6A737D\">  // 1% of cartesian product</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WHY greedy join order:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - NP-hard problem in general</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Greedy is simple and often good enough</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Start with smallest table minimizes intermediate results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// - Can extend to dynamic programming for better plans</span></span></code></pre></div>\n\n<h3 id=\"analyze-command\">ANALYZE Command</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// statistics.go (continued)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Analyze collects statistics for a table.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StatisticsManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Analyze</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get table B-tree</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tree </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sm.catalog.</span><span style=\"color:#B392F0\">GetTableTree</span><span style=\"color:#E1E4E8\">(tableName)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> tree </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"no such table: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, tableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Scan all rows</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">TableStatistics</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TableName:   tableName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ColumnStats: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ColumnStats</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    schema </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sm.catalog.</span><span style=\"color:#B392F0\">GetSchema</span><span style=\"color:#E1E4E8\">(tableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    distinctValues </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}]</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nullCounts </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, col </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> schema.Columns {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        distinctValues[col.Name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}]</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nullCounts[col.Name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Scan table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tree.</span><span style=\"color:#B392F0\">NewCursor</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor.</span><span style=\"color:#B392F0\">First</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">cursor.</span><span style=\"color:#B392F0\">AtEnd</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        _, record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cursor.</span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        values, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> DeserializeRow</span><span style=\"color:#E1E4E8\">(record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stats.RowCount</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i, col </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> schema.Columns {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            val </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> values[i]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> val </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                nullCounts[col.Name]</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                distinctValues[col.Name][val] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate page count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats.PageCount </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (stats.RowCount </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> RowsPerPage </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> RowsPerPage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Store column statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, col </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> schema.Columns {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stats.ColumnStats[col.Name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ColumnStats</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ColumnName:    col.Name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            DistinctCount: </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(distinctValues[col.Name])),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            NullCount:     nullCounts[col.Name],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats.LastAnalyzed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Save to storage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sm.storage.</span><span style=\"color:#B392F0\">Save</span><span style=\"color:#E1E4E8\">(stats); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update in-memory cache</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sm.stats[tableName] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> stats</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Analyze indexes too</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> sm.</span><span style=\"color:#B392F0\">analyzeIndexes</span><span style=\"color:#E1E4E8\">(tableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StatisticsManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">analyzeIndexes</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sm.catalog.</span><span style=\"color:#B392F0\">GetTableIndexes</span><span style=\"color:#E1E4E8\">(tableName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, idx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> indexes {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Count distinct values in index</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        distinctCount </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sm.</span><span style=\"color:#B392F0\">countDistinctInIndex</span><span style=\"color:#E1E4E8\">(idx)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Get table row count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tableStats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sm.stats[tableName]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Save index stats</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sm.storage.</span><span style=\"color:#B392F0\">SaveIndexStats</span><span style=\"color:#E1E4E8\">(tableName, idx.Name, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tableStats.RowCount, distinctCount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StatisticsManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">countDistinctInIndex</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">idx</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Index</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> idx.</span><span style=\"color:#B392F0\">NewCursor</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cursor.</span><span style=\"color:#B392F0\">First</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> lastValue </span><span style=\"color:#B392F0\">Value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">cursor.AtEnd {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        value, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cursor.</span><span style=\"color:#B392F0\">Current</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#B392F0\"> CompareValues</span><span style=\"color:#E1E4E8\">(value, lastValue) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            count</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            lastValue </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor.</span><span style=\"color:#B392F0\">Next</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> RowsPerPage</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 50</span><span style=\"color:#6A737D\">  // Approximate rows per 4KB page</span></span></code></pre></div>\n\n<h3 id=\"explain-output\">EXPLAIN Output</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// explain.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Explain formats a query plan for display.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> Explain</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">plan</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">QueryPlan</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> buf </span><span style=\"color:#B392F0\">strings</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Builder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Access path</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    explainAccessPath</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">buf, plan.AccessPath, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">  Estimated rows: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, plan.EstimatedRows))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">  Estimated cost: </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, plan.EstimatedCost))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(plan.Projection) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">  Projection: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, strings.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(plan.Projection, </span><span style=\"color:#9ECBFF\">\", \"</span><span style=\"color:#E1E4E8\">)))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(plan.OrderBy) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">  Order By: \"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i, ob </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> plan.OrderBy {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\", \"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(ob.Column)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> ob.Descending {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\" DESC\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> plan.Limit </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">  Limit: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">plan.Limit))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> buf.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> explainAccessPath</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Builder</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">path</span><span style=\"color:#B392F0\"> AccessPath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">indent</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    prefix </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">Repeat</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  \"</span><span style=\"color:#E1E4E8\">, indent)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> p </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> path.(</span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TableScanPath</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">TABLE SCAN </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, prefix, p.TableName))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">IndexScanPath</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">INDEX SCAN </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> VIA </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, prefix, p.TableName, p.IndexName))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\" (selectivity=</span><span style=\"color:#79B8FF\">%.2f%%</span><span style=\"color:#9ECBFF\">)\"</span><span style=\"color:#E1E4E8\">, p.Selectivity</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">NestedLoopJoinPath</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">NESTED LOOP JOIN</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, prefix))</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        explainAccessPath</span><span style=\"color:#E1E4E8\">(buf, p.Left, indent</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buf.</span><span style=\"color:#B392F0\">WriteString</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        explainAccessPath</span><span style=\"color:#E1E4E8\">(buf, p.Right, indent</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"interface-contracts\">Interface Contracts</h2>\n<h3 id=\"planner-entry-point\">Planner Entry Point</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// PlanSelect creates an execution plan for a SELECT statement.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parameters:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - stmt: Parsed SELECT AST</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - *QueryPlan: Complete execution plan with access path and cost</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - error: If table doesn't exist or planning fails</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Pre-conditions:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - stmt is non-nil and valid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - All referenced tables exist in catalog</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Post-conditions:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Plan is executable (valid table/index references)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Cost and row estimates are non-negative</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Access path is chosen based on available statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Planner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PlanSelect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">stmt</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">SelectStatement</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">QueryPlan</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h3 id=\"statistics-management\">Statistics Management</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Analyze collects statistics for a table by scanning all rows.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parameters:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - tableName: Table to analyze</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - error: If table doesn't exist or scan fails</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Post-conditions:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Statistics are stored in sqlite_stat1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - In-memory cache is updated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   - Index statistics are also collected</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complexity: O(n) where n is table row count</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StatisticsManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Analyze</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetTableStats returns statistics for a table.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns default estimates if ANALYZE hasn't been run.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StatisticsManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetTableStats</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tableName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TableStatistics</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"algorithm-specification\">Algorithm Specification</h2>\n<h3 id=\"cost-based-access-path-selection\">Cost-Based Access Path Selection</h3>\n<p>{{DIAGRAM:tdd-diag-31}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: chooseAccessPath\nINPUT: tableName, WHERE clause, selectivity, table statistics\nOUTPUT: AccessPath (TableScanPath or IndexScanPath)\n\n1. CALCULATE TABLE SCAN COST\n   tableScanCost := costModel.TableScanCost(tableStats)\n   // = pageCount * sequentialIOCost + rowCount * cpuCost\n\n2. FIND USABLE INDEXES\n   indexes := indexManager.GetTableIndexes(tableName)\n   bestIndex := nil\n   bestIndexCost := infinity\n\n3. FOR each index in indexes:\n     a. IF NOT isIndexUsable(index, whereClause):\n          CONTINUE\n     \n     b. indexCost := costModel.IndexScanCost(tableStats, selectivity)\n        // = indexTraversalCost + (matchingRows/rowsPerPage) * randomIOCost + cpuCost\n     \n     c. IF indexCost &lt; bestIndexCost:\n          bestIndexCost = indexCost\n          bestIndex = index\n\n4. DECISION\n   IF bestIndex != nil \n      AND selectivity &lt; IndexSelectivityThreshold (20%)\n      AND bestIndexCost &lt; tableScanCost:\n     RETURN IndexScanPath{tableName, bestIndex.Name, selectivity, bestIndexCost}\n   \n   ELSE:\n     RETURN TableScanPath{tableName, selectivity, tableScanCost}\n\nKEY INSIGHT: \n  - Low selectivity (&lt; 20%) favors index (fewer rows to fetch)\n  - High selectivity favors table scan (sequential I/O wins)\n  - Cost model captures the essential tradeoff</code></pre></div>\n\n<h3 id=\"selectivity-estimation\">Selectivity Estimation</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: EstimateSelectivity\nINPUT: tableName, predicate expression\nOUTPUT: float64 (0.0 to 1.0)\n\n1. IF predicate == nil:\n     RETURN 1.0  // No filter\n\n2. SWITCH on expression type:\n\n   CASE BinaryExpression with &quot;=&quot;:\n     a. colName := extractColumnName(expr.Left)\n     b. colStats := stats.GetColumnStats(tableName, colName)\n     c. IF colStats != nil AND colStats.DistinctCount &gt; 0:\n          RETURN 1.0 / colStats.DistinctCount\n     d. ELSE:\n          RETURN DefaultEqualitySelectivity (0.1)\n\n   CASE BinaryExpression with &quot;AND&quot;:\n     left := EstimateSelectivity(tableName, expr.Left)\n     right := EstimateSelectivity(tableName, expr.Right)\n     RETURN left * right  // Independence assumption\n\n   CASE BinaryExpression with &quot;OR&quot;:\n     left := EstimateSelectivity(tableName, expr.Left)\n     right := EstimateSelectivity(tableName, expr.Right)\n     RETURN left + right - left*right  // P(A or B) formula\n\n   CASE BinaryExpression with &quot;&lt;&quot;, &quot;&gt;&quot;, etc.:\n     RETURN DefaultRangeSelectivity (0.33)\n\n   DEFAULT:\n     RETURN DefaultSelectivity (0.1)\n\nASSUMPTIONS:\n  - Column values are uniformly distributed (no histograms)\n  - Predicates are independent (AND selectivity = product)\n  - Without statistics, use conservative defaults</code></pre></div>\n\n<h3 id=\"greedy-join-order\">Greedy Join Order</h3>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-33.svg\" alt=\"Cost Model Comparison\"></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALGORITHM: PlanJoin (Greedy)\nINPUT: List of tables, join conditions, WHERE clause\nOUTPUT: AccessPath representing join tree\n\n1. COLLECT STATISTICS\n   FOR each table:\n     tableStats[table] = stats.GetTableStats(table)\n\n2. SORT TABLES BY SIZE (ascending)\n   sorted := sort tables by tableStats.RowCount\n\n3. INITIALIZE\n   currentPlan := TableScanPath{sorted[0]}\n   remaining := sorted[1:]\n\n4. WHILE remaining is not empty:\n     a. bestCost := infinity\n        bestIdx := -1\n        bestPlan := nil\n     \n     b. FOR i, nextTable in remaining:\n          // Cost = outer scan + (outer rows * inner scan)\n          cost := currentPlan.Cost + \n                  currentPlan.EstimatedRows * tableScanCost(nextTable)\n          \n          IF cost &lt; bestCost:\n            bestCost = cost\n            bestIdx = i\n            bestPlan = NestedLoopJoinPath{\n              Left: currentPlan,\n              Right: TableScanPath{nextTable},\n              EstimatedRows: estimateJoinCardinality(...),\n              Cost: cost,\n            }\n     \n     c. currentPlan = bestPlan\n        remaining = remove remaining[bestIdx]\n\n5. RETURN currentPlan\n\nCOMPLEXITY: O(n^2) for n tables\nWHY GREEDY: \n  - NP-hard to find optimal join order\n  - Greedy is simple and often good\n  - Starting with smallest table minimizes intermediate results</code></pre></div>\n\n<hr>\n<h2 id=\"error-handling-matrix\">Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th>Error</th>\n<th>Detected By</th>\n<th>Recovery</th>\n<th>User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Table doesn&#39;t exist</td>\n<td><code>PlanSelect</code> table lookup</td>\n<td>Return error immediately</td>\n<td>Yes: &quot;no such table: {name}&quot;</td>\n</tr>\n<tr>\n<td>No statistics available</td>\n<td><code>GetTableStats</code></td>\n<td>Use default estimates</td>\n<td>No: defaults enable planning</td>\n</tr>\n<tr>\n<td>Stale statistics</td>\n<td>Periodic ANALYZE check</td>\n<td>Log warning, use available stats</td>\n<td>No: query still executes</td>\n</tr>\n<tr>\n<td>Complex predicate (unknown selectivity)</td>\n<td><code>EstimateSelectivity</code></td>\n<td>Use DefaultSelectivity</td>\n<td>No: conservative estimate</td>\n</tr>\n<tr>\n<td>Index doesn&#39;t exist</td>\n<td><code>GetTableIndexes</code></td>\n<td>Fall back to table scan</td>\n<td>No: automatic fallback</td>\n</tr>\n<tr>\n<td>Circular join (no join condition)</td>\n<td><code>PlanJoin</code></td>\n<td>Treat as cartesian product</td>\n<td>No: but result may be large</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"implementation-sequence-with-checkpoints\">Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-statistics-collection-analyze-2-hours\">Phase 1: Statistics Collection (ANALYZE) (2 hours)</h3>\n<p><strong>Files to create</strong>: <code>statistics.go</code>, <code>stat_storage.go</code>, <code>defaults.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Define <code>TableStatistics</code> and <code>ColumnStats</code> structs</li>\n<li>Implement <code>StatisticsManager</code> with cache</li>\n<li>Implement <code>Analyze</code> command with table scan</li>\n<li>Implement <code>StatStorage</code> for sqlite_stat1</li>\n<li>Implement default statistics</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should collect and store statistics. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestAnalyze</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (ANALYZE creates statistics)</span></span></code></pre></div>\n\n<h3 id=\"phase-2-selectivity-estimation-2-hours\">Phase 2: Selectivity Estimation (2 hours)</h3>\n<p><strong>Files to create</strong>: <code>selectivity.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>SelectivityEstimator</code></li>\n<li>Implement equality selectivity (1/distinct)</li>\n<li>Implement AND/OR selectivity</li>\n<li>Implement range and IN selectivity</li>\n<li>Implement default fallbacks</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should estimate predicate selectivity. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestSelectivity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (selectivity estimates are reasonable)</span></span></code></pre></div>\n\n<h3 id=\"phase-3-cost-model-2-hours\">Phase 3: Cost Model (2 hours)</h3>\n<p><strong>Files to create</strong>: <code>cost_model.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>CostModel</code> with I/O costs</li>\n<li>Implement <code>TableScanCost</code></li>\n<li>Implement <code>IndexScanCost</code></li>\n<li>Configure sequential vs random I/O ratio</li>\n<li>Test cost calculations</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should compare access path costs. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestCostModel</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (cost model chooses correctly for known cases)</span></span></code></pre></div>\n\n<h3 id=\"phase-4-plan-selection-and-explain-2-hours\">Phase 4: Plan Selection and EXPLAIN (2 hours)</h3>\n<p><strong>Files to create</strong>: <code>planner.go</code>, <code>access_path.go</code>, <code>query_plan.go</code>, <code>explain.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>AccessPath</code> interface</li>\n<li>Implement <code>Planner.PlanSelect</code></li>\n<li>Implement <code>chooseAccessPath</code> with threshold</li>\n<li>Implement <code>Explain</code> formatter</li>\n<li>Integrate with compiler</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should create complete plans. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestPlanSelect</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: PASS (plans are correct, EXPLAIN works)</span></span></code></pre></div>\n\n<h3 id=\"phase-5-join-order-optimization-2-hours\">Phase 5: Join Order Optimization (2 hours)</h3>\n<p><strong>Files to create</strong>: <code>join_planner.go</code></p>\n<p><strong>Implementation</strong>:</p>\n<ol>\n<li>Implement <code>JoinPlanner</code></li>\n<li>Implement greedy join ordering</li>\n<li>Implement join cardinality estimation</li>\n<li>Handle multi-table WHERE clauses</li>\n<li>Full test suite</li>\n</ol>\n<p><strong>Checkpoint</strong>: At this point you should pass all tests. Run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> ./planner</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: All tests PASS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify: Plan simple query in &#x3C; 100μs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify: Choose index when selectivity &#x3C; 20%</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"test-specification\">Test Specification</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// planner_test.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestAnalyze</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDB</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE TABLE users (id INTEGER, name TEXT, status TEXT)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Insert 1000 rows</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        status </span><span style=\"color:#F97583\">:=</span><span style=\"color:#9ECBFF\"> \"active\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> i</span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            status </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"inactive\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO users VALUES (</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, 'user</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">', '</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">')\"</span><span style=\"color:#E1E4E8\">, i, i, status))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Run ANALYZE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ANALYZE users\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.Planner.Stats.</span><span style=\"color:#B392F0\">GetTableStats</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">), stats.RowCount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">), stats.ColumnStats[</span><span style=\"color:#9ECBFF\">\"status\"</span><span style=\"color:#E1E4E8\">].DistinctCount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestSelectivityEquality</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    se </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">SelectivityEstimator</span><span style=\"color:#E1E4E8\">{stats: testStats}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // With statistics: selectivity = 1/distinct</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> se.</span><span style=\"color:#B392F0\">EstimateSelectivity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">parseExpr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"status = 'active'\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\">100.0</span><span style=\"color:#E1E4E8\">, sel)  </span><span style=\"color:#6A737D\">// 100 distinct status values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Without statistics: default</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sel </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> se.</span><span style=\"color:#B392F0\">EstimateSelectivity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"no_stats_table\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">parseExpr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"col = 1\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, DefaultEqualitySelectivity, sel)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestSelectivityAnd</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    se </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">SelectivityEstimator</span><span style=\"color:#E1E4E8\">{stats: testStats}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // AND: selectivity = left * right</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> se.</span><span style=\"color:#B392F0\">EstimateSelectivity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        parseExpr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"status = 'active' AND id = 5\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should be product of individual selectivities</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expectedSel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\">100.0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\">1000.0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">InDelta</span><span style=\"color:#E1E4E8\">(t, expectedSel, sel, </span><span style=\"color:#79B8FF\">0.0001</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestSelectivityOr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    se </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">SelectivityEstimator</span><span style=\"color:#E1E4E8\">{stats: testStats}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // OR: selectivity = left + right - left*right</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> se.</span><span style=\"color:#B392F0\">EstimateSelectivity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"users\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        parseExpr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"status = 'active' OR status = 'inactive'\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Two status values out of 100</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expectedSel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 2.0</span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\">100.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">InDelta</span><span style=\"color:#E1E4E8\">(t, expectedSel, sel, </span><span style=\"color:#79B8FF\">0.01</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestCostModel</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cm </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewDefaultCostModel</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">TableStatistics</span><span style=\"color:#E1E4E8\">{RowCount: </span><span style=\"color:#79B8FF\">10000</span><span style=\"color:#E1E4E8\">, PageCount: </span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Table scan: sequential I/O</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tableScanCost </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cm.</span><span style=\"color:#B392F0\">TableScanCost</span><span style=\"color:#E1E4E8\">(stats)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Greater</span><span style=\"color:#E1E4E8\">(t, tableScanCost, </span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Index scan with low selectivity (1%)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexScanCost </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cm.</span><span style=\"color:#B392F0\">IndexScanCost</span><span style=\"color:#E1E4E8\">(stats, </span><span style=\"color:#79B8FF\">0.01</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Low selectivity: index should be cheaper</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Less</span><span style=\"color:#E1E4E8\">(t, indexScanCost, tableScanCost)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Index scan with high selectivity (50%)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexScanCostHigh </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cm.</span><span style=\"color:#B392F0\">IndexScanCost</span><span style=\"color:#E1E4E8\">(stats, </span><span style=\"color:#79B8FF\">0.5</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // High selectivity: table scan should be cheaper</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Less</span><span style=\"color:#E1E4E8\">(t, tableScanCost, indexScanCostHigh)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestPlanSelectTableScan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDBWithStats</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE INDEX idx_status ON users(status)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // High selectivity query (90% match)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    plan, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.Planner.</span><span style=\"color:#B392F0\">PlanSelect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">parseSQL</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM users WHERE id > 100\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should choose table scan (selectivity > 20%)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, isTableScan </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> plan.AccessPath.(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TableScanPath</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">True</span><span style=\"color:#E1E4E8\">(t, isTableScan, </span><span style=\"color:#9ECBFF\">\"Should choose table scan for high selectivity\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestPlanSelectIndexScan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDBWithStats</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE INDEX idx_email ON users(email)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Low selectivity query (0.1% match - 1 row)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    plan, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.Planner.</span><span style=\"color:#B392F0\">PlanSelect</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        parseSQL</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM users WHERE email = 'user50@example.com'\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should choose index scan (selectivity &#x3C; 20%)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indexScan, isIndexScan </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> plan.AccessPath.(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IndexScanPath</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">True</span><span style=\"color:#E1E4E8\">(t, isIndexScan, </span><span style=\"color:#9ECBFF\">\"Should choose index scan for low selectivity\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#9ECBFF\">\"idx_email\"</span><span style=\"color:#E1E4E8\">, indexScan.IndexName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestExplain</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDBWithStats</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE INDEX idx_email ON users(email)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    plan, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.Planner.</span><span style=\"color:#B392F0\">PlanSelect</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        parseSQL</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT name FROM users WHERE email = 'test@example.com'\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    explain </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> Explain</span><span style=\"color:#E1E4E8\">(plan)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(t, explain, </span><span style=\"color:#9ECBFF\">\"INDEX SCAN\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(t, explain, </span><span style=\"color:#9ECBFF\">\"idx_email\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(t, explain, </span><span style=\"color:#9ECBFF\">\"Estimated rows\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(t, explain, </span><span style=\"color:#9ECBFF\">\"Estimated cost\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestJoinOrder</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDB</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create tables with different sizes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE TABLE small (id INTEGER)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO small VALUES (</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)\"</span><span style=\"color:#E1E4E8\">, i))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE TABLE large (id INTEGER, small_id INTEGER)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO large VALUES (</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)\"</span><span style=\"color:#E1E4E8\">, i, i</span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ANALYZE small\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ANALYZE large\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Plan join</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    plan, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.Planner.</span><span style=\"color:#B392F0\">PlanJoin</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"small\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"large\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        []</span><span style=\"color:#B392F0\">Expression</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#B392F0\">parseExpr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"small.id = large.small_id\"</span><span style=\"color:#E1E4E8\">)},</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        nil</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should start with small table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    join </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> plan.(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NestedLoopJoinPath</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leftTable </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> extractTableName</span><span style=\"color:#E1E4E8\">(join.Left)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#9ECBFF\">\"small\"</span><span style=\"color:#E1E4E8\">, leftTable, </span><span style=\"color:#9ECBFF\">\"Should start with smaller table\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestPlanPerformance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> testing.</span><span style=\"color:#B392F0\">Short</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">Skip</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Skipping performance test\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDBWithStats</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Plan 1000 simple queries</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db.Planner.</span><span style=\"color:#B392F0\">PlanSelect</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            parseSQL</span><span style=\"color:#E1E4E8\">(fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM users WHERE id = </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, i)))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    elapsed </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Since</span><span style=\"color:#E1E4E8\">(start)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    avgTime </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> elapsed </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1000</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Less</span><span style=\"color:#E1E4E8\">(t, avgTime.</span><span style=\"color:#B392F0\">Microseconds</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">), </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Plan should complete in &#x3C; 100μs\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestSelectivityThreshold</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDBWithStats</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE INDEX idx_status ON users(status)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // At exactly 20% selectivity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // With 3 distinct status values, each has ~33% selectivity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should choose table scan</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    plan, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.Planner.</span><span style=\"color:#B392F0\">PlanSelect</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        parseSQL</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM users WHERE status = 'active'\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Status has 3 values, selectivity = 33% > 20%</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, isTableScan </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> plan.AccessPath.(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TableScanPath</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">True</span><span style=\"color:#E1E4E8\">(t, isTableScan, </span><span style=\"color:#9ECBFF\">\"Should use table scan when selectivity > 20%\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestNoStatisticsFallback</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> createTestDB</span><span style=\"color:#E1E4E8\">()  </span><span style=\"color:#6A737D\">// No ANALYZE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CREATE TABLE test (id INTEGER)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">Execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO test VALUES (1)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should still produce a valid plan</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    plan, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.Planner.</span><span style=\"color:#B392F0\">PlanSelect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">parseSQL</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"SELECT * FROM test WHERE id = 1\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">NotNil</span><span style=\"color:#E1E4E8\">(t, plan)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should use default statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.Planner.Stats.</span><span style=\"color:#B392F0\">GetTableStats</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"test\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assert.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(t, DefaultRowCount, stats.RowCount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-targets\">Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Target</th>\n<th>How to Measure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Plan simple query</td>\n<td>&lt; 100μs</td>\n<td><code>go test -bench=BenchmarkPlanSimple</code></td>\n</tr>\n<tr>\n<td>ANALYZE on 10K rows</td>\n<td>&lt; 500ms</td>\n<td><code>go test -bench=BenchmarkAnalyze</code></td>\n</tr>\n<tr>\n<td>Index selection accuracy</td>\n<td>95%+ for selectivity &lt; 5%</td>\n<td>Test index chosen when appropriate</td>\n</tr>\n<tr>\n<td>Table scan selection accuracy</td>\n<td>95%+ for selectivity &gt; 30%</td>\n<td>Test table scan chosen when appropriate</td>\n</tr>\n<tr>\n<td>Join order quality</td>\n<td>Within 2x of optimal</td>\n<td>Compare greedy vs brute force</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"synced-criteria\">Synced Criteria</h2>\n<p>[[CRITERIA_JSON: {&quot;module_id&quot;: &quot;build-sqlite-m8&quot;, &quot;criteria&quot;: [&quot;ANALYZE command collects table and index statistics&quot;, &quot;Cost model estimates I/O for table scan vs index scan&quot;, &quot;Plan selection chooses cheapest access path per table&quot;, &quot;EXPLAIN command displays chosen plan with cost estimates&quot;, &quot;Join order optimization for multi-table queries&quot;, &quot;Planner falls back to table scan when no suitable index exists or selectivity is too low&quot;]}]</p>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-sqlite-m9 -->\n<p>I&#39;ll continue with creating the Full Technical Design Specification for build-sqlite-m9: Transactions (Rollback Journal). Let me first check the existing architecture documentation and previous TDD specs to ensure consistency.</p>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-sqlite-m10 -->\n<p>I&#39;ll continue creating the Full Technical Design Specification for Module 10: WAL Mode. Let me first read the existing file to see what&#39;s already there.</p>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-sqlite-m11 -->\n<p>I&#39;ll continue by writing the Full Technical Design Specification for Module 11: Aggregate Functions &amp; JOIN. Let me first read the current state of the file to see where I need to add this specification.</p>\n<!-- END_TDD_MOD -->\n\n\n<p>I&#39;ll help you create a &quot;Further Reading&quot; document for this SQLite implementation project. Let me analyze the content and curate high-quality resources for each major concept.</p>\n","toc":[{"level":1,"text":"Build Your Own SQLite","id":"build-your-own-sqlite"},{"level":1,"text":"Milestone 1: SQL Tokenizer","id":"milestone-1-sql-tokenizer"},{"level":2,"text":"Where We Are in the System","id":"where-we-are-in-the-system"},{"level":2,"text":"The Tension: Context Changes Meaning","id":"the-tension-context-changes-meaning"},{"level":2,"text":"The Tokenizer State Machine","id":"the-tokenizer-state-machine"},{"level":2,"text":"Building the Tokenizer: Step by Step","id":"building-the-tokenizer-step-by-step"},{"level":3,"text":"The Token Structure","id":"the-token-structure"},{"level":3,"text":"Keyword Recognition: Case-Insensitive Matching","id":"keyword-recognition-case-insensitive-matching"},{"level":3,"text":"String Literals: The Escape Sequence Problem","id":"string-literals-the-escape-sequence-problem"},{"level":3,"text":"Numeric Literals: Integers vs Floats","id":"numeric-literals-integers-vs-floats"},{"level":3,"text":"Operators: Single and Double Character","id":"operators-single-and-double-character"},{"level":3,"text":"Quoted Identifiers: Double Quotes","id":"quoted-identifiers-double-quotes"},{"level":3,"text":"Whitespace and Comments","id":"whitespace-and-comments"},{"level":2,"text":"Error Reporting: Line and Column Tracking","id":"error-reporting-line-and-column-tracking"},{"level":2,"text":"The Token Stream Output","id":"the-token-stream-output"},{"level":2,"text":"A Complete Tokenization Example","id":"a-complete-tokenization-example"},{"level":2,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"1. Not Handling Escaped Quotes","id":"1-not-handling-escaped-quotes"},{"level":3,"text":"2. Case Sensitivity Confusion","id":"2-case-sensitivity-confusion"},{"level":3,"text":"3. Negative Numbers vs Subtraction","id":"3-negative-numbers-vs-subtraction"},{"level":3,"text":"4. Unicode and Multi-byte Characters","id":"4-unicode-and-multi-byte-characters"},{"level":3,"text":"5. Forgetting to Track Position","id":"5-forgetting-to-track-position"},{"level":2,"text":"Test Suite: What to Verify","id":"test-suite-what-to-verify"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":1,"text":"Milestone 2: SQL Parser (AST)","id":"milestone-2-sql-parser-ast"},{"level":2,"text":"Where We Are in the System","id":"where-we-are-in-the-system"},{"level":2,"text":"The Tension: Ambiguity and Infinite Loops","id":"the-tension-ambiguity-and-infinite-loops"},{"level":2,"text":"The Revelation: Precedence Is Not Natural","id":"the-revelation-precedence-is-not-natural"},{"level":2,"text":"Three-Level View: From Token Stream to AST","id":"three-level-view-from-token-stream-to-ast"},{"level":2,"text":"Building the Parser: Step by Step","id":"building-the-parser-step-by-step"},{"level":3,"text":"The Parser Structure","id":"the-parser-structure"},{"level":3,"text":"Statement Parsing: Dispatch on First Token","id":"statement-parsing-dispatch-on-first-token"},{"level":3,"text":"SELECT Statement Parsing","id":"select-statement-parsing"},{"level":3,"text":"INSERT Statement Parsing","id":"insert-statement-parsing"},{"level":3,"text":"CREATE TABLE Parsing","id":"create-table-parsing"},{"level":2,"text":"Expression Parsing: The Heart of the Parser","id":"expression-parsing-the-heart-of-the-parser"},{"level":3,"text":"Approach 1: Explicit Precedence Levels (Grammar Rewriting)","id":"approach-1-explicit-precedence-levels-grammar-rewriting"},{"level":3,"text":"Approach 2: Precedence Climbing (Compact)","id":"approach-2-precedence-climbing-compact"},{"level":2,"text":"Parentheses Override Precedence","id":"parentheses-override-precedence"},{"level":2,"text":"NULL: The Special Keyword","id":"null-the-special-keyword"},{"level":2,"text":"Error Reporting: Position Tracking","id":"error-reporting-position-tracking"},{"level":2,"text":"AST Structure Reference","id":"ast-structure-reference"},{"level":2,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"1. Left Recursion in Grammar","id":"1-left-recursion-in-grammar"},{"level":3,"text":"2. AND Binds Tighter Than OR","id":"2-and-binds-tighter-than-or"},{"level":3,"text":"3. NULL Is Not an Identifier","id":"3-null-is-not-an-identifier"},{"level":3,"text":"4. Parentheses Require Recursive Parsing","id":"4-parentheses-require-recursive-parsing"},{"level":2,"text":"Test Suite: What to Verify","id":"test-suite-what-to-verify"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":1,"text":"Milestone 3: Bytecode Compiler (VDBE)","id":"milestone-3-bytecode-compiler-vdbe"},{"level":2,"text":"Where We Are in the System","id":"where-we-are-in-the-system"},{"level":2,"text":"The Revelation: Why Bytecode, Not Tree Walking?","id":"the-revelation-why-bytecode-not-tree-walking"},{"level":3,"text":"Reason 1: Caching Amortizes Compilation Cost","id":"reason-1-caching-amortizes-compilation-cost"},{"level":3,"text":"Reason 2: The VM Provides a Clean Abstraction Boundary","id":"reason-2-the-vm-provides-a-clean-abstraction-boundary"},{"level":3,"text":"Reason 3: Optimization Opportunities","id":"reason-3-optimization-opportunities"},{"level":2,"text":"The Tension: Compilation Time vs Execution Speed","id":"the-tension-compilation-time-vs-execution-speed"},{"level":2,"text":"The Instruction Set: Your VM&#39;s Vocabulary","id":"the-instruction-set-your-vm39s-vocabulary"},{"level":2,"text":"Three-Level View: From AST to Bytecode to Execution","id":"three-level-view-from-ast-to-bytecode-to-execution"},{"level":2,"text":"Building the Compiler: SELECT Statements","id":"building-the-compiler-select-statements"},{"level":3,"text":"Step-by-Step Compilation","id":"step-by-step-compilation"},{"level":3,"text":"The Compiled Bytecode","id":"the-compiled-bytecode"},{"level":2,"text":"Building the Compiler: INSERT Statements","id":"building-the-compiler-insert-statements"},{"level":2,"text":"Building the Virtual Machine","id":"building-the-virtual-machine"},{"level":3,"text":"The Register File","id":"the-register-file"},{"level":2,"text":"WHERE Clause Compilation: Conditional Jumps","id":"where-clause-compilation-conditional-jumps"},{"level":2,"text":"EXPLAIN: Making Bytecode Visible","id":"explain-making-bytecode-visible"},{"level":2,"text":"Performance Target: 10,000 Rows in 100ms","id":"performance-target-10000-rows-in-100ms"},{"level":2,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"1. Missing the Halt Opcode","id":"1-missing-the-halt-opcode"},{"level":3,"text":"2. Forgetting to Patch Jump Targets","id":"2-forgetting-to-patch-jump-targets"},{"level":3,"text":"3. Register Clobbering","id":"3-register-clobbering"},{"level":3,"text":"4. Three-Valued Logic in Comparisons","id":"4-three-valued-logic-in-comparisons"},{"level":2,"text":"Test Suite: What to Verify","id":"test-suite-what-to-verify"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":1,"text":"Milestone 4: Buffer Pool Manager","id":"milestone-4-buffer-pool-manager"},{"level":2,"text":"Where We Are in the System","id":"where-we-are-in-the-system"},{"level":2,"text":"The Revelation: The OS Page Cache Is Not Enough","id":"the-revelation-the-os-page-cache-is-not-enough"},{"level":3,"text":"Reason 1: Pinning Prevents Use-After-Free","id":"reason-1-pinning-prevents-use-after-free"},{"level":3,"text":"Reason 2: Dirty Page Tracking Enables Transactions","id":"reason-2-dirty-page-tracking-enables-transactions"},{"level":3,"text":"Reason 3: Database-Specific Eviction Policies","id":"reason-3-database-specific-eviction-policies"},{"level":2,"text":"The Tension: Memory Is Finite","id":"the-tension-memory-is-finite"},{"level":2,"text":"Three-Level View: From VM Opcodes to Disk Blocks","id":"three-level-view-from-vm-opcodes-to-disk-blocks"},{"level":2,"text":"Building the Buffer Pool: Data Structures","id":"building-the-buffer-pool-data-structures"},{"level":3,"text":"Initialization","id":"initialization"},{"level":2,"text":"FetchPage: The Core Operation","id":"fetchpage-the-core-operation"},{"level":2,"text":"LRU Eviction: Finding a Victim Frame","id":"lru-eviction-finding-a-victim-frame"},{"level":3,"text":"Why Not Real LRU?","id":"why-not-real-lru"},{"level":2,"text":"Pin and Unpin: Protecting Active Pages","id":"pin-and-unpin-protecting-active-pages"},{"level":2,"text":"Dirty Page Tracking and FlushAll","id":"dirty-page-tracking-and-flushall"},{"level":2,"text":"The Page Handle: Safe Access to Page Data","id":"the-page-handle-safe-access-to-page-data"},{"level":2,"text":"Hit Rate: The Performance Metric","id":"hit-rate-the-performance-metric"},{"level":2,"text":"Performance Analysis: Where Time Goes","id":"performance-analysis-where-time-goes"},{"level":2,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"1. Evicting a Pinned Page","id":"1-evicting-a-pinned-page"},{"level":3,"text":"2. Forgetting to Unpin","id":"2-forgetting-to-unpin"},{"level":3,"text":"3. Not Flushing Before Eviction","id":"3-not-flushing-before-eviction"},{"level":3,"text":"4. Buffer Pool Deadlock","id":"4-buffer-pool-deadlock"},{"level":2,"text":"Test Suite: What to Verify","id":"test-suite-what-to-verify"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":1,"text":"Milestone 5: B-tree Page Format &amp; Table Storage","id":"milestone-5-b-tree-page-format-amp-table-storage"},{"level":2,"text":"Where We Are in the System","id":"where-we-are-in-the-system"},{"level":2,"text":"The Tension: Variable Records in Fixed Pages","id":"the-tension-variable-records-in-fixed-pages"},{"level":2,"text":"The Revelation: Records Are Not Stored Sorted","id":"the-revelation-records-are-not-stored-sorted"},{"level":3,"text":"The Slotted Page Format","id":"the-slotted-page-format"},{"level":3,"text":"Why This Matters for Node Splits","id":"why-this-matters-for-node-splits"},{"level":2,"text":"Three-Level View: From SQL Row to Disk Bytes","id":"three-level-view-from-sql-row-to-disk-bytes"},{"level":2,"text":"Page Types: Four Flavors","id":"page-types-four-flavors"},{"level":3,"text":"Table B-tree vs Index B+tree","id":"table-b-tree-vs-index-btree"},{"level":2,"text":"Page Header Format","id":"page-header-format"},{"level":2,"text":"Cell Pointer Array","id":"cell-pointer-array"},{"level":2,"text":"Cell Content Area","id":"cell-content-area"},{"level":2,"text":"Record Serialization: Variable-Length Encoding","id":"record-serialization-variable-length-encoding"},{"level":3,"text":"Varint Format","id":"varint-format"},{"level":3,"text":"Record Format","id":"record-format"},{"level":3,"text":"Full Record Serialization","id":"full-record-serialization"},{"level":2,"text":"Table B-tree Leaf Page Cells","id":"table-b-tree-leaf-page-cells"},{"level":2,"text":"Table B-tree Internal Page Cells","id":"table-b-tree-internal-page-cells"},{"level":2,"text":"Index B+tree Page Cells","id":"index-btree-page-cells"},{"level":2,"text":"Node Splitting: The Complex Case","id":"node-splitting-the-complex-case"},{"level":3,"text":"Cascading Splits","id":"cascading-splits"},{"level":2,"text":"System Catalog: sqlite_master","id":"system-catalog-sqlite_master"},{"level":2,"text":"Full Table Scan: Traversing the Leaves","id":"full-table-scan-traversing-the-leaves"},{"level":2,"text":"Endianness: Big-Endian for Portability","id":"endianness-big-endian-for-portability"},{"level":2,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"1. Confusing B-tree and B+tree","id":"1-confusing-b-tree-and-btree"},{"level":3,"text":"2. Forgetting Overflow Pages","id":"2-forgetting-overflow-pages"},{"level":3,"text":"3. Page Fragmentation After Deletes","id":"3-page-fragmentation-after-deletes"},{"level":3,"text":"4. Varint Edge Cases","id":"4-varint-edge-cases"},{"level":3,"text":"5. Off-by-One in Page Calculations","id":"5-off-by-one-in-page-calculations"},{"level":2,"text":"Test Suite: What to Verify","id":"test-suite-what-to-verify"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":1,"text":"Milestone 6: SELECT Execution &amp; DML","id":"milestone-6-select-execution-amp-dml"},{"level":2,"text":"Where We Are in the System","id":"where-we-are-in-the-system"},{"level":2,"text":"The Revelation: NULL Breaks Everything You Know","id":"the-revelation-null-breaks-everything-you-know"},{"level":3,"text":"NULL Does Not Equal NULL","id":"null-does-not-equal-null"},{"level":3,"text":"Three-Valued Logic: TRUE, FALSE, and NULL","id":"three-valued-logic-true-false-and-null"},{"level":3,"text":"Column Projection Is Not Array Indexing","id":"column-projection-is-not-array-indexing"},{"level":2,"text":"The Tension: Correctness vs Performance","id":"the-tension-correctness-vs-performance"},{"level":2,"text":"Three-Level View: From Bytecode to Deserialized Values","id":"three-level-view-from-bytecode-to-deserialized-values"},{"level":2,"text":"Building SELECT Execution","id":"building-select-execution"},{"level":3,"text":"The Cursor Abstraction","id":"the-cursor-abstraction"},{"level":3,"text":"Column Deserialization","id":"column-deserialization"},{"level":3,"text":"Expression Evaluation with Three-Valued Logic","id":"expression-evaluation-with-three-valued-logic"},{"level":3,"text":"WHERE Clause Evaluation in the VM","id":"where-clause-evaluation-in-the-vm"},{"level":2,"text":"Building INSERT Execution","id":"building-insert-execution"},{"level":3,"text":"Constraint Checking: NOT NULL","id":"constraint-checking-not-null"},{"level":2,"text":"Building UPDATE Execution","id":"building-update-execution"},{"level":2,"text":"Building DELETE Execution","id":"building-delete-execution"},{"level":3,"text":"B-tree Deletion and Rebalancing","id":"b-tree-deletion-and-rebalancing"},{"level":2,"text":"Table Existence Checking","id":"table-existence-checking"},{"level":2,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"1. NULL = NULL Is TRUE (Wrong!)","id":"1-null-null-is-true-wrong"},{"level":3,"text":"2. WHERE NULL Is Falsy (Misleading!)","id":"2-where-null-is-falsy-misleading"},{"level":3,"text":"3. Modifying a Cursor During Iteration","id":"3-modifying-a-cursor-during-iteration"},{"level":3,"text":"4. Column Index Off-by-One","id":"4-column-index-off-by-one"},{"level":3,"text":"5. UPDATE Changing Rowid","id":"5-update-changing-rowid"},{"level":2,"text":"Test Suite: What to Verify","id":"test-suite-what-to-verify"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":1,"text":"Milestone 7: Secondary Indexes","id":"milestone-7-secondary-indexes"},{"level":2,"text":"Where We Are in the System","id":"where-we-are-in-the-system"},{"level":2,"text":"The Revelation: Indexes Are Not Automatic Magic","id":"the-revelation-indexes-are-not-automatic-magic"},{"level":3,"text":"Indexes Store Pointers, Not Data","id":"indexes-store-pointers-not-data"},{"level":3,"text":"Query Planner Decides, Not the Index","id":"query-planner-decides-not-the-index"},{"level":3,"text":"Every Write Maintains Every Index","id":"every-write-maintains-every-index"},{"level":2,"text":"The Tension: Read Performance vs Write Cost","id":"the-tension-read-performance-vs-write-cost"},{"level":2,"text":"Three-Level View: From Index Creation to Query Execution","id":"three-level-view-from-index-creation-to-query-execution"},{"level":2,"text":"Building CREATE INDEX","id":"building-create-index"},{"level":3,"text":"Index Structure: B+tree with (Value, Rowid) Keys","id":"index-structure-btree-with-value-rowid-keys"},{"level":3,"text":"Building the Index from Existing Data","id":"building-the-index-from-existing-data"},{"level":2,"text":"Index Lookup: Equality Search","id":"index-lookup-equality-search"},{"level":3,"text":"The Seek Operation","id":"the-seek-operation"},{"level":2,"text":"Range Scan: Traversing Leaf Pages","id":"range-scan-traversing-leaf-pages"},{"level":3,"text":"Leaf Page Linking in B+trees","id":"leaf-page-linking-in-btrees"},{"level":2,"text":"Index Maintenance on DML","id":"index-maintenance-on-dml"},{"level":3,"text":"INSERT: Add to All Indexes","id":"insert-add-to-all-indexes"},{"level":3,"text":"UPDATE: Modify Affected Indexes","id":"update-modify-affected-indexes"},{"level":3,"text":"DELETE: Remove from All Indexes","id":"delete-remove-from-all-indexes"},{"level":2,"text":"Double Lookup in the Bytecode VM","id":"double-lookup-in-the-bytecode-vm"},{"level":3,"text":"VM Implementation of SeekRowid","id":"vm-implementation-of-seekrowid"},{"level":3,"text":"Coordinating Two Cursors","id":"coordinating-two-cursors"},{"level":2,"text":"UNIQUE Index Constraint","id":"unique-index-constraint"},{"level":2,"text":"Covering Indexes: Skipping the Table Lookup","id":"covering-indexes-skipping-the-table-lookup"},{"level":2,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"1. Forgetting to Update Indexes on Write","id":"1-forgetting-to-update-indexes-on-write"},{"level":3,"text":"2. UNIQUE Index Allowing Duplicates","id":"2-unique-index-allowing-duplicates"},{"level":3,"text":"3. Not Handling NULL in Indexes","id":"3-not-handling-null-in-indexes"},{"level":3,"text":"4. Index Fragmentation from Many Deletes","id":"4-index-fragmentation-from-many-deletes"},{"level":3,"text":"5. Composite Index Column Order","id":"5-composite-index-column-order"},{"level":2,"text":"Test Suite: What to Verify","id":"test-suite-what-to-verify"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":1,"text":"Milestone 8: Query Planner &amp; Statistics","id":"milestone-8-query-planner-amp-statistics"},{"level":2,"text":"Where We Are in the System","id":"where-we-are-in-the-system"},{"level":2,"text":"The Revelation: An Index Can Make Queries Slower","id":"the-revelation-an-index-can-make-queries-slower"},{"level":3,"text":"When Indexes Hurt: The Selectivity Trap","id":"when-indexes-hurt-the-selectivity-trap"},{"level":3,"text":"The Threshold: Selectivity Determines Everything","id":"the-threshold-selectivity-determines-everything"},{"level":3,"text":"Flying Blind: The Default Assumption Problem","id":"flying-blind-the-default-assumption-problem"},{"level":3,"text":"Cardinality Estimation Errors Compound Exponentially","id":"cardinality-estimation-errors-compound-exponentially"},{"level":2,"text":"The Tension: Accuracy vs Estimation Cost","id":"the-tension-accuracy-vs-estimation-cost"},{"level":2,"text":"Three-Level View: From Statistics to Plan to Bytecode","id":"three-level-view-from-statistics-to-plan-to-bytecode"},{"level":2,"text":"Building ANALYZE: Collecting Statistics","id":"building-analyze-collecting-statistics"},{"level":3,"text":"Statistics Storage","id":"statistics-storage"},{"level":3,"text":"ANALYZE Implementation","id":"analyze-implementation"},{"level":3,"text":"Histogram Storage (Advanced)","id":"histogram-storage-advanced"},{"level":2,"text":"Building the Cost Model","id":"building-the-cost-model"},{"level":3,"text":"Cost Model: Table Scan","id":"cost-model-table-scan"},{"level":3,"text":"Cost Model: Index Scan","id":"cost-model-index-scan"},{"level":3,"text":"Selectivity Estimation","id":"selectivity-estimation"},{"level":2,"text":"Building the Planner","id":"building-the-planner"},{"level":3,"text":"Plan Representation","id":"plan-representation"},{"level":3,"text":"Planner Implementation","id":"planner-implementation"},{"level":3,"text":"The Selectivity Threshold","id":"the-selectivity-threshold"},{"level":2,"text":"EXPLAIN: Revealing the Plan","id":"explain-revealing-the-plan"},{"level":2,"text":"Join Planning: Order Matters","id":"join-planning-order-matters"},{"level":3,"text":"Join Cardinality Estimation","id":"join-cardinality-estimation"},{"level":3,"text":"Join Order Selection","id":"join-order-selection"},{"level":2,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"1. Using an Index for Low-Selectivity Queries","id":"1-using-an-index-for-low-selectivity-queries"},{"level":3,"text":"2. Stale Statistics After Bulk Changes","id":"2-stale-statistics-after-bulk-changes"},{"level":3,"text":"3. Correlated Predicates Treated as Independent","id":"3-correlated-predicates-treated-as-independent"},{"level":3,"text":"4. Forcing Plans Without Escape Hatch","id":"4-forcing-plans-without-escape-hatch"},{"level":2,"text":"Test Suite: What to Verify","id":"test-suite-what-to-verify"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":1,"text":"Milestone 9: Transactions (Rollback Journal)","id":"milestone-9-transactions-rollback-journal"},{"level":2,"text":"Where We Are in the System","id":"where-we-are-in-the-system"},{"level":2,"text":"The Revelation: Durability Requires Write Ordering, Not Immediate Writes","id":"the-revelation-durability-requires-write-ordering-not-immediate-writes"},{"level":3,"text":"The Torn Page Problem","id":"the-torn-page-problem"},{"level":3,"text":"The Write Ordering Solution","id":"the-write-ordering-solution"},{"level":3,"text":"What the Journal Contains","id":"what-the-journal-contains"},{"level":2,"text":"The Tension: Durability vs Performance","id":"the-tension-durability-vs-performance"},{"level":2,"text":"Three-Level View: From SQL Transaction to Disk Operations","id":"three-level-view-from-sql-transaction-to-disk-operations"},{"level":2,"text":"ACID: The Four Pillars","id":"acid-the-four-pillars"},{"level":2,"text":"Building the Transaction Manager","id":"building-the-transaction-manager"},{"level":3,"text":"Transaction State","id":"transaction-state"},{"level":3,"text":"The Rollback Journal Structure","id":"the-rollback-journal-structure"},{"level":3,"text":"Creating the Journal","id":"creating-the-journal"},{"level":3,"text":"Recording Page Modifications","id":"recording-page-modifications"},{"level":3,"text":"Integration with Buffer Pool","id":"integration-with-buffer-pool"},{"level":2,"text":"COMMIT: Making Changes Permanent","id":"commit-making-changes-permanent"},{"level":3,"text":"The Critical Write Ordering","id":"the-critical-write-ordering"},{"level":2,"text":"ROLLBACK: Undoing Changes","id":"rollback-undoing-changes"},{"level":3,"text":"Buffer Pool Invalidation","id":"buffer-pool-invalidation"},{"level":2,"text":"Crash Recovery: Detecting and Applying the Hot Journal","id":"crash-recovery-detecting-and-applying-the-hot-journal"},{"level":2,"text":"Isolation: Basic Locking","id":"isolation-basic-locking"},{"level":3,"text":"Transaction Visibility","id":"transaction-visibility"},{"level":2,"text":"SQL Interface: BEGIN, COMMIT, ROLLBACK","id":"sql-interface-begin-commit-rollback"},{"level":3,"text":"Auto-Commit Mode","id":"auto-commit-mode"},{"level":2,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"1. Writing Database Before Journal","id":"1-writing-database-before-journal"},{"level":3,"text":"2. Forgetting to fsync the Journal","id":"2-forgetting-to-fsync-the-journal"},{"level":3,"text":"3. Partial Page Writes (Torn Pages)","id":"3-partial-page-writes-torn-pages"},{"level":3,"text":"4. Not Detecting Hot Journals on Startup","id":"4-not-detecting-hot-journals-on-startup"},{"level":3,"text":"5. Lock Deadlocks","id":"5-lock-deadlocks"},{"level":2,"text":"Test Suite: What to Verify","id":"test-suite-what-to-verify"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":1,"text":"Milestone 10: WAL Mode","id":"milestone-10-wal-mode"},{"level":2,"text":"Where We Are in the System","id":"where-we-are-in-the-system"},{"level":2,"text":"The Revelation: WAL Enables True Concurrency","id":"the-revelation-wal-enables-true-concurrency"},{"level":3,"text":"The Reader-Writer Conflict in Rollback Journal Mode","id":"the-reader-writer-conflict-in-rollback-journal-mode"},{"level":3,"text":"WAL Mode: Readers and Writers Coexist","id":"wal-mode-readers-and-writers-coexist"},{"level":3,"text":"The Cost: Complexity and Checkpointing","id":"the-cost-complexity-and-checkpointing"},{"level":2,"text":"The Tension: WAL Growth vs Checkpoint Frequency","id":"the-tension-wal-growth-vs-checkpoint-frequency"},{"level":2,"text":"Three-Level View: From SQL Write to WAL to Database","id":"three-level-view-from-sql-write-to-wal-to-database"},{"level":2,"text":"WAL File Format","id":"wal-file-format"},{"level":3,"text":"WAL Header","id":"wal-header"},{"level":3,"text":"Frame Structure","id":"frame-structure"},{"level":3,"text":"Checksum Algorithm","id":"checksum-algorithm"},{"level":2,"text":"WAL Page Lookup: The WAL-Index","id":"wal-page-lookup-the-wal-index"},{"level":3,"text":"WAL-Index Structure","id":"wal-index-structure"},{"level":3,"text":"Building the WAL-Index","id":"building-the-wal-index"},{"level":3,"text":"Page Lookup with WAL","id":"page-lookup-with-wal"},{"level":2,"text":"Concurrent Readers: Snapshot Isolation","id":"concurrent-readers-snapshot-isolation"},{"level":3,"text":"Snapshot Lifecycle","id":"snapshot-lifecycle"},{"level":2,"text":"Checkpoint: Merging WAL to Database","id":"checkpoint-merging-wal-to-database"},{"level":3,"text":"Auto-Checkpoint","id":"auto-checkpoint"},{"level":3,"text":"PRAGMA wal_checkpoint","id":"pragma-wal_checkpoint"},{"level":2,"text":"Switching Between Modes","id":"switching-between-modes"},{"level":2,"text":"WAL Recovery","id":"wal-recovery"},{"level":2,"text":"Concurrent Execution Flow","id":"concurrent-execution-flow"},{"level":3,"text":"Writer Flow","id":"writer-flow"},{"level":3,"text":"Reader Flow","id":"reader-flow"},{"level":2,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"1. WAL Grows Unbounded Without Checkpointing","id":"1-wal-grows-unbounded-without-checkpointing"},{"level":3,"text":"2. Long-Running Readers Block Checkpointing","id":"2-long-running-readers-block-checkpointing"},{"level":3,"text":"3. Corrupted WAL Not Detected","id":"3-corrupted-wal-not-detected"},{"level":3,"text":"4. Switching Modes During Active Transaction","id":"4-switching-modes-during-active-transaction"},{"level":3,"text":"5. Forgetting to Sync WAL","id":"5-forgetting-to-sync-wal"},{"level":2,"text":"Test Suite: What to Verify","id":"test-suite-what-to-verify"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":1,"text":"Milestone 11: Aggregate Functions &amp; JOIN","id":"milestone-11-aggregate-functions-amp-join"},{"level":2,"text":"Where We Are in the System","id":"where-we-are-in-the-system"},{"level":2,"text":"The Revelation: Aggregates Have Subtle NULL Behavior","id":"the-revelation-aggregates-have-subtle-null-behavior"},{"level":3,"text":"COUNT(*) vs COUNT(column): NULLs Are Counted Differently","id":"count-vs-countcolumn-nulls-are-counted-differently"},{"level":3,"text":"AVG Must Return a Float, Even for Integer Columns","id":"avg-must-return-a-float-even-for-integer-columns"},{"level":3,"text":"SUM and AVG Ignore NULLs","id":"sum-and-avg-ignore-nulls"},{"level":3,"text":"GROUP BY Without ORDER BY Has No Guaranteed Order","id":"group-by-without-order-by-has-no-guaranteed-order"},{"level":3,"text":"Nested Loop Joins Are O(n*m)","id":"nested-loop-joins-are-onm"},{"level":2,"text":"The Tension: Correctness vs Memory vs Performance","id":"the-tension-correctness-vs-memory-vs-performance"},{"level":2,"text":"Three-Level View: From SQL to Aggregate State to Results","id":"three-level-view-from-sql-to-aggregate-state-to-results"},{"level":2,"text":"Building Aggregate Functions","id":"building-aggregate-functions"},{"level":3,"text":"Aggregate State Structure","id":"aggregate-state-structure"},{"level":3,"text":"Aggregate Function Factory","id":"aggregate-function-factory"},{"level":2,"text":"GROUP BY Execution","id":"group-by-execution"},{"level":3,"text":"Hash-Based Aggregation","id":"hash-based-aggregation"},{"level":3,"text":"Ungrouped Aggregation","id":"ungrouped-aggregation"},{"level":3,"text":"Empty Table Handling","id":"empty-table-handling"},{"level":2,"text":"HAVING: Filtering Groups","id":"having-filtering-groups"},{"level":3,"text":"HAVING vs WHERE","id":"having-vs-where"},{"level":2,"text":"INNER JOIN: Nested Loop Implementation","id":"inner-join-nested-loop-implementation"},{"level":3,"text":"The Cross Product with Filter","id":"the-cross-product-with-filter"},{"level":3,"text":"Table Alias Support","id":"table-alias-support"},{"level":2,"text":"JOIN with WHERE Clause","id":"join-with-where-clause"},{"level":2,"text":"Multiple JOINs","id":"multiple-joins"},{"level":2,"text":"Bytecode Compilation for Aggregates","id":"bytecode-compilation-for-aggregates"},{"level":3,"text":"GROUP BY Bytecode","id":"group-by-bytecode"},{"level":3,"text":"Aggregation in the VM","id":"aggregation-in-the-vm"},{"level":2,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"1. COUNT(column) Including NULLs","id":"1-countcolumn-including-nulls"},{"level":3,"text":"2. AVG Returning Integer","id":"2-avg-returning-integer"},{"level":3,"text":"3. SUM of Empty Set Returning 0 Instead of NULL","id":"3-sum-of-empty-set-returning-0-instead-of-null"},{"level":3,"text":"4. Nested Loop JOIN on Large Tables","id":"4-nested-loop-join-on-large-tables"},{"level":3,"text":"5. GROUP BY Without Aggregate","id":"5-group-by-without-aggregate"},{"level":3,"text":"6. HAVING Using Non-Aggregate Columns","id":"6-having-using-non-aggregate-columns"},{"level":2,"text":"Test Suite: What to Verify","id":"test-suite-what-to-verify"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":1,"text":"TDD","id":"tdd"},{"level":1,"text":"Technical Design Specification: SQL Tokenizer","id":"technical-design-specification-sql-tokenizer"},{"level":2,"text":"Module Charter","id":"module-charter"},{"level":2,"text":"File Structure","id":"file-structure"},{"level":2,"text":"Complete Data Model","id":"complete-data-model"},{"level":3,"text":"Token Type Enumeration","id":"token-type-enumeration"},{"level":3,"text":"Token Structure","id":"token-structure"},{"level":3,"text":"Tokenizer State Machine","id":"tokenizer-state-machine"},{"level":3,"text":"Keyword Map","id":"keyword-map"},{"level":2,"text":"Interface Contracts","id":"interface-contracts"},{"level":3,"text":"Constructor","id":"constructor"},{"level":3,"text":"Primary Method: NextToken","id":"primary-method-nexttoken"},{"level":3,"text":"TokenizeAll (Convenience)","id":"tokenizeall-convenience"},{"level":3,"text":"Position Queries","id":"position-queries"},{"level":2,"text":"Algorithm Specification","id":"algorithm-specification"},{"level":3,"text":"Main Tokenization Loop","id":"main-tokenization-loop"},{"level":3,"text":"String Literal Parsing","id":"string-literal-parsing"},{"level":3,"text":"Numeric Literal Parsing","id":"numeric-literal-parsing"},{"level":3,"text":"Identifier/Keyword Recognition","id":"identifierkeyword-recognition"},{"level":3,"text":"Operator Recognition","id":"operator-recognition"},{"level":2,"text":"Error Handling Matrix","id":"error-handling-matrix"},{"level":2,"text":"Implementation Sequence with Checkpoints","id":"implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Token Structure and State Machine Skeleton (1 hour)","id":"phase-1-token-structure-and-state-machine-skeleton-1-hour"},{"level":3,"text":"Phase 2: Keyword Recognition (0.5 hours)","id":"phase-2-keyword-recognition-05-hours"},{"level":3,"text":"Phase 3: String Literal Parsing with Escape Handling (1 hour)","id":"phase-3-string-literal-parsing-with-escape-handling-1-hour"},{"level":3,"text":"Phase 4: Numeric Literal Parsing (0.5 hours)","id":"phase-4-numeric-literal-parsing-05-hours"},{"level":3,"text":"Phase 5: Operator and Punctuation Tokenization (0.5 hours)","id":"phase-5-operator-and-punctuation-tokenization-05-hours"},{"level":3,"text":"Phase 6: Quoted Identifiers, Comments, and Error Cases (0.5 hours)","id":"phase-6-quoted-identifiers-comments-and-error-cases-05-hours"},{"level":2,"text":"Test Specification","id":"test-specification"},{"level":3,"text":"Test Categories","id":"test-categories"},{"level":2,"text":"Performance Targets","id":"performance-targets"},{"level":2,"text":"Synced Criteria","id":"synced-criteria"},{"level":1,"text":"Technical Design Specification: SQL Parser (AST)","id":"technical-design-specification-sql-parser-ast"},{"level":2,"text":"Module Charter","id":"module-charter"},{"level":2,"text":"File Structure","id":"file-structure"},{"level":2,"text":"Complete Data Model","id":"complete-data-model"},{"level":3,"text":"Statement Types (Root AST Nodes)","id":"statement-types-root-ast-nodes"},{"level":3,"text":"Expression Types","id":"expression-types"},{"level":3,"text":"Parser State","id":"parser-state"},{"level":3,"text":"Precedence Table","id":"precedence-table"},{"level":2,"text":"Interface Contracts","id":"interface-contracts"},{"level":3,"text":"Constructor","id":"constructor"},{"level":3,"text":"Primary Method: Parse","id":"primary-method-parse"},{"level":3,"text":"Token Navigation","id":"token-navigation"},{"level":3,"text":"Error Reporting","id":"error-reporting"},{"level":2,"text":"Algorithm Specification","id":"algorithm-specification"},{"level":3,"text":"Main Parse Dispatch","id":"main-parse-dispatch"},{"level":3,"text":"SELECT Statement Parsing","id":"select-statement-parsing"},{"level":3,"text":"Column List Parsing","id":"column-list-parsing"},{"level":3,"text":"INSERT Statement Parsing","id":"insert-statement-parsing"},{"level":3,"text":"CREATE TABLE Parsing","id":"create-table-parsing"},{"level":3,"text":"Expression Parsing with Precedence Climbing","id":"expression-parsing-with-precedence-climbing"},{"level":3,"text":"Special Expression Parsing","id":"special-expression-parsing"},{"level":2,"text":"Error Handling Matrix","id":"error-handling-matrix"},{"level":2,"text":"Implementation Sequence with Checkpoints","id":"implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Parser Core and Statement Dispatch (1 hour)","id":"phase-1-parser-core-and-statement-dispatch-1-hour"},{"level":3,"text":"Phase 2: SELECT Statement Parsing (1.5 hours)","id":"phase-2-select-statement-parsing-15-hours"},{"level":3,"text":"Phase 3: INSERT Statement Parsing (1 hour)","id":"phase-3-insert-statement-parsing-1-hour"},{"level":3,"text":"Phase 4: CREATE TABLE Parsing (1.5 hours)","id":"phase-4-create-table-parsing-15-hours"},{"level":3,"text":"Phase 5: Expression Parsing with Precedence Climbing (2 hours)","id":"phase-5-expression-parsing-with-precedence-climbing-2-hours"},{"level":2,"text":"Test Specification","id":"test-specification"},{"level":3,"text":"Test Categories","id":"test-categories"},{"level":2,"text":"Performance Targets","id":"performance-targets"},{"level":2,"text":"Synced Criteria","id":"synced-criteria"},{"level":1,"text":"Technical Design Specification: Bytecode Compiler (VDBE)","id":"technical-design-specification-bytecode-compiler-vdbe"},{"level":2,"text":"Module Charter","id":"module-charter"},{"level":2,"text":"File Structure","id":"file-structure"},{"level":2,"text":"Complete Data Model","id":"complete-data-model"},{"level":3,"text":"Instruction Structure","id":"instruction-structure"},{"level":3,"text":"Compiler State","id":"compiler-state"},{"level":3,"text":"Register Allocator","id":"register-allocator"},{"level":3,"text":"VM Value Types","id":"vm-value-types"},{"level":3,"text":"Virtual Machine State","id":"virtual-machine-state"},{"level":2,"text":"Interface Contracts","id":"interface-contracts"},{"level":3,"text":"Compiler Entry Point","id":"compiler-entry-point"},{"level":3,"text":"Compiler Methods","id":"compiler-methods"},{"level":3,"text":"VM Entry Point","id":"vm-entry-point"},{"level":2,"text":"Algorithm Specification","id":"algorithm-specification"},{"level":3,"text":"SELECT Statement Compilation","id":"select-statement-compilation"},{"level":3,"text":"INSERT Statement Compilation","id":"insert-statement-compilation"},{"level":3,"text":"Expression Compilation","id":"expression-compilation"},{"level":3,"text":"WHERE Clause with Conditional Jumps","id":"where-clause-with-conditional-jumps"},{"level":3,"text":"VM Execution Loop","id":"vm-execution-loop"},{"level":2,"text":"Error Handling Matrix","id":"error-handling-matrix"},{"level":2,"text":"Implementation Sequence with Checkpoints","id":"implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Instruction Set and Compiler Skeleton (2 hours)","id":"phase-1-instruction-set-and-compiler-skeleton-2-hours"},{"level":3,"text":"Phase 2: SELECT Compilation (2 hours)","id":"phase-2-select-compilation-2-hours"},{"level":3,"text":"Phase 3: INSERT/UPDATE/DELETE Compilation (2 hours)","id":"phase-3-insertupdatedelete-compilation-2-hours"},{"level":3,"text":"Phase 4: WHERE Clause Compilation (2 hours)","id":"phase-4-where-clause-compilation-2-hours"},{"level":3,"text":"Phase 5: VM Execution Loop (2 hours)","id":"phase-5-vm-execution-loop-2-hours"},{"level":2,"text":"Test Specification","id":"test-specification"},{"level":3,"text":"Test Categories","id":"test-categories"},{"level":2,"text":"Performance Targets","id":"performance-targets"},{"level":2,"text":"Synced Criteria","id":"synced-criteria"},{"level":1,"text":"Technical Design Specification: Buffer Pool Manager","id":"technical-design-specification-buffer-pool-manager"},{"level":2,"text":"Module Charter","id":"module-charter"},{"level":2,"text":"File Structure","id":"file-structure"},{"level":2,"text":"Complete Data Model","id":"complete-data-model"},{"level":3,"text":"PageID: Unique Page Identifier","id":"pageid-unique-page-identifier"},{"level":3,"text":"Frame Metadata: Per-Frame Tracking","id":"frame-metadata-per-frame-tracking"},{"level":3,"text":"Page Handle: Safe Access to Page Data","id":"page-handle-safe-access-to-page-data"},{"level":3,"text":"BufferPool: Core Data Structure","id":"bufferpool-core-data-structure"},{"level":3,"text":"DiskManager: Storage Abstraction","id":"diskmanager-storage-abstraction"},{"level":2,"text":"Interface Contracts","id":"interface-contracts"},{"level":3,"text":"Constructor","id":"constructor"},{"level":3,"text":"Core Operations","id":"core-operations"},{"level":3,"text":"Flush Operations","id":"flush-operations"},{"level":3,"text":"Metrics","id":"metrics"},{"level":2,"text":"Algorithm Specification","id":"algorithm-specification"},{"level":3,"text":"FetchPage: The Core Operation","id":"fetchpage-the-core-operation"},{"level":3,"text":"LRU Eviction: Finding a Victim Frame","id":"lru-eviction-finding-a-victim-frame"},{"level":3,"text":"UnpinPage: Releasing a Page Reference","id":"unpinpage-releasing-a-page-reference"},{"level":3,"text":"FlushAll: Writing Dirty Pages to Disk","id":"flushall-writing-dirty-pages-to-disk"},{"level":3,"text":"Pin/Unpin Pattern for B-tree Operations","id":"pinunpin-pattern-for-b-tree-operations"},{"level":2,"text":"Error Handling Matrix","id":"error-handling-matrix"},{"level":2,"text":"Implementation Sequence with Checkpoints","id":"implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: BufferPool Structure and Frame Allocation (1.5 hours)","id":"phase-1-bufferpool-structure-and-frame-allocation-15-hours"},{"level":3,"text":"Phase 2: FetchPage with Hit/Miss Logic (2 hours)","id":"phase-2-fetchpage-with-hitmiss-logic-2-hours"},{"level":3,"text":"Phase 3: LRU Eviction Algorithm (1.5 hours)","id":"phase-3-lru-eviction-algorithm-15-hours"},{"level":3,"text":"Phase 4: Pin/Unpin and Dirty Page Tracking (1.5 hours)","id":"phase-4-pinunpin-and-dirty-page-tracking-15-hours"},{"level":3,"text":"Phase 5: FlushAll and FlushPage (1.5 hours)","id":"phase-5-flushall-and-flushpage-15-hours"},{"level":2,"text":"Test Specification","id":"test-specification"},{"level":3,"text":"Test Categories","id":"test-categories"},{"level":2,"text":"Performance Targets","id":"performance-targets"},{"level":2,"text":"Synced Criteria","id":"synced-criteria"},{"level":1,"text":"Technical Design Specification: B-tree Page Format &amp; Table Storage","id":"technical-design-specification-b-tree-page-format-amp-table-storage"},{"level":2,"text":"Module Charter","id":"module-charter"},{"level":2,"text":"File Structure","id":"file-structure"},{"level":2,"text":"Complete Data Model","id":"complete-data-model"},{"level":3,"text":"Page Types","id":"page-types"},{"level":3,"text":"Page Header Format","id":"page-header-format"},{"level":3,"text":"Page Structure: Slotted Format","id":"page-structure-slotted-format"},{"level":3,"text":"Cell Pointer Array","id":"cell-pointer-array"},{"level":3,"text":"Varint Encoding","id":"varint-encoding"},{"level":3,"text":"Serial Types","id":"serial-types"},{"level":3,"text":"Record Format","id":"record-format"},{"level":3,"text":"Table B-tree Leaf Cell","id":"table-b-tree-leaf-cell"},{"level":3,"text":"Table B-tree Internal Cell","id":"table-b-tree-internal-cell"},{"level":3,"text":"Index B+tree Leaf Cell","id":"index-btree-leaf-cell"},{"level":3,"text":"BTree Structure","id":"btree-structure"},{"level":3,"text":"Node Splitting","id":"node-splitting"},{"level":3,"text":"System Catalog","id":"system-catalog"},{"level":3,"text":"Free Space Management","id":"free-space-management"},{"level":2,"text":"Interface Contracts","id":"interface-contracts"},{"level":3,"text":"Page Creation and Initialization","id":"page-creation-and-initialization"},{"level":3,"text":"Cell Operations","id":"cell-operations"},{"level":3,"text":"BTree Operations","id":"btree-operations"},{"level":2,"text":"Algorithm Specification","id":"algorithm-specification"},{"level":3,"text":"Insert Cell into Page","id":"insert-cell-into-page"},{"level":3,"text":"Find Leaf Page for Key","id":"find-leaf-page-for-key"},{"level":3,"text":"Full Table Scan","id":"full-table-scan"},{"level":2,"text":"Error Handling Matrix","id":"error-handling-matrix"},{"level":2,"text":"Implementation Sequence with Checkpoints","id":"implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Page Header and Slotted Format (2 hours)","id":"phase-1-page-header-and-slotted-format-2-hours"},{"level":3,"text":"Phase 2: Varint Encoding/Decoding (1 hour)","id":"phase-2-varint-encodingdecoding-1-hour"},{"level":3,"text":"Phase 3: Record Serialization with Serial Types (2 hours)","id":"phase-3-record-serialization-with-serial-types-2-hours"},{"level":3,"text":"Phase 4: Table B-tree Leaf and Internal Pages (2 hours)","id":"phase-4-table-b-tree-leaf-and-internal-pages-2-hours"},{"level":3,"text":"Phase 5: Index B+tree Pages (1.5 hours)","id":"phase-5-index-btree-pages-15-hours"},{"level":3,"text":"Phase 6: Node Splitting and Separator Promotion (2 hours)","id":"phase-6-node-splitting-and-separator-promotion-2-hours"},{"level":3,"text":"Phase 7: System Catalog (1.5 hours)","id":"phase-7-system-catalog-15-hours"},{"level":2,"text":"Test Specification","id":"test-specification"},{"level":2,"text":"Performance Targets","id":"performance-targets"},{"level":2,"text":"Synced Criteria","id":"synced-criteria"},{"level":1,"text":"Technical Design Specification: SELECT Execution &amp; DML","id":"technical-design-specification-select-execution-amp-dml"},{"level":2,"text":"Module Charter","id":"module-charter"},{"level":2,"text":"File Structure","id":"file-structure"},{"level":2,"text":"Complete Data Model","id":"complete-data-model"},{"level":3,"text":"Value Type with NULL Handling","id":"value-type-with-null-handling"},{"level":3,"text":"Cursor State","id":"cursor-state"},{"level":3,"text":"Three-Valued Logic Operators","id":"three-valued-logic-operators"},{"level":3,"text":"Column Access with Lazy Deserialization","id":"column-access-with-lazy-deserialization"},{"level":2,"text":"Interface Contracts","id":"interface-contracts"},{"level":3,"text":"Cursor Operations","id":"cursor-operations"},{"level":3,"text":"Expression Evaluation","id":"expression-evaluation"},{"level":3,"text":"Execution Handlers","id":"execution-handlers"},{"level":2,"text":"Algorithm Specification","id":"algorithm-specification"},{"level":3,"text":"Cursor First (Navigate to Leftmost Row)","id":"cursor-first-navigate-to-leftmost-row"},{"level":3,"text":"Cursor Next (Advance to Next Row)","id":"cursor-next-advance-to-next-row"},{"level":3,"text":"Expression Evaluation with Three-Valued Logic","id":"expression-evaluation-with-three-valued-logic"},{"level":3,"text":"WHERE Clause Evaluation","id":"where-clause-evaluation"},{"level":3,"text":"INSERT Execution","id":"insert-execution"},{"level":3,"text":"DELETE Execution","id":"delete-execution"},{"level":3,"text":"UPDATE Execution (Delete + Reinsert)","id":"update-execution-delete-reinsert"},{"level":2,"text":"Error Handling Matrix","id":"error-handling-matrix"},{"level":2,"text":"Implementation Sequence with Checkpoints","id":"implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Cursor Abstraction and B-tree Traversal (2 hours)","id":"phase-1-cursor-abstraction-and-b-tree-traversal-2-hours"},{"level":3,"text":"Phase 2: Column Deserialization with Lazy Access (2 hours)","id":"phase-2-column-deserialization-with-lazy-access-2-hours"},{"level":3,"text":"Phase 3: Three-Valued Logic for Comparisons (1.5 hours)","id":"phase-3-three-valued-logic-for-comparisons-15-hours"},{"level":3,"text":"Phase 4: WHERE Clause Evaluation (1.5 hours)","id":"phase-4-where-clause-evaluation-15-hours"},{"level":3,"text":"Phase 5: INSERT Execution with Constraint Check (1.5 hours)","id":"phase-5-insert-execution-with-constraint-check-15-hours"},{"level":3,"text":"Phase 6: UPDATE and DELETE Execution (1.5 hours)","id":"phase-6-update-and-delete-execution-15-hours"},{"level":2,"text":"Test Specification","id":"test-specification"},{"level":2,"text":"Performance Targets","id":"performance-targets"},{"level":2,"text":"Synced Criteria","id":"synced-criteria"},{"level":1,"text":"Technical Design Specification: Secondary Indexes","id":"technical-design-specification-secondary-indexes"},{"level":2,"text":"Module Charter","id":"module-charter"},{"level":2,"text":"File Structure","id":"file-structure"},{"level":2,"text":"Complete Data Model","id":"complete-data-model"},{"level":3,"text":"Index Structure","id":"index-structure"},{"level":3,"text":"Index B+tree Leaf Cell Format","id":"index-btree-leaf-cell-format"},{"level":3,"text":"Index B+tree Internal Cell Format","id":"index-btree-internal-cell-format"},{"level":3,"text":"Index Cursor with Leaf Linking","id":"index-cursor-with-leaf-linking"},{"level":2,"text":"Interface Contracts","id":"interface-contracts"},{"level":3,"text":"Index Creation","id":"index-creation"},{"level":3,"text":"Index Lookup","id":"index-lookup"},{"level":3,"text":"Index Maintenance","id":"index-maintenance"},{"level":2,"text":"Algorithm Specification","id":"algorithm-specification"},{"level":3,"text":"CREATE INDEX from Table Scan","id":"create-index-from-table-scan"},{"level":3,"text":"Index Equality Lookup","id":"index-equality-lookup"},{"level":3,"text":"Index Range Scan via Leaf Linking","id":"index-range-scan-via-leaf-linking"},{"level":3,"text":"Index Maintenance on INSERT","id":"index-maintenance-on-insert"},{"level":3,"text":"Index Maintenance on UPDATE","id":"index-maintenance-on-update"},{"level":3,"text":"Index Maintenance on DELETE","id":"index-maintenance-on-delete"},{"level":3,"text":"UNIQUE Constraint Enforcement","id":"unique-constraint-enforcement"},{"level":3,"text":"Double Lookup Pattern","id":"double-lookup-pattern"},{"level":2,"text":"Error Handling Matrix","id":"error-handling-matrix"},{"level":2,"text":"Implementation Sequence with Checkpoints","id":"implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Index B+tree Leaf and Internal Pages (2 hours)","id":"phase-1-index-btree-leaf-and-internal-pages-2-hours"},{"level":3,"text":"Phase 2: CREATE INDEX from Table Scan (2 hours)","id":"phase-2-create-index-from-table-scan-2-hours"},{"level":3,"text":"Phase 3: Index Equality and Range Lookup (1.5 hours)","id":"phase-3-index-equality-and-range-lookup-15-hours"},{"level":3,"text":"Phase 4: Index Maintenance on INSERT/UPDATE/DELETE (2 hours)","id":"phase-4-index-maintenance-on-insertupdatedelete-2-hours"},{"level":3,"text":"Phase 5: UNIQUE Constraint Enforcement (0.5 hours)","id":"phase-5-unique-constraint-enforcement-05-hours"},{"level":2,"text":"Test Specification","id":"test-specification"},{"level":2,"text":"Performance Targets","id":"performance-targets"},{"level":2,"text":"Synced Criteria","id":"synced-criteria"},{"level":1,"text":"Technical Design Specification: Query Planner &amp; Statistics","id":"technical-design-specification-query-planner-amp-statistics"},{"level":2,"text":"Module Charter","id":"module-charter"},{"level":2,"text":"File Structure","id":"file-structure"},{"level":2,"text":"Complete Data Model","id":"complete-data-model"},{"level":3,"text":"Statistics Structure","id":"statistics-structure"},{"level":3,"text":"Stat Storage (sqlite_stat1)","id":"stat-storage-sqlite_stat1"},{"level":3,"text":"Selectivity Estimation","id":"selectivity-estimation"},{"level":3,"text":"Cost Model","id":"cost-model"},{"level":3,"text":"Access Path and Query Plan","id":"access-path-and-query-plan"},{"level":3,"text":"Planner","id":"planner"},{"level":3,"text":"Join Order Optimization","id":"join-order-optimization"},{"level":3,"text":"ANALYZE Command","id":"analyze-command"},{"level":3,"text":"EXPLAIN Output","id":"explain-output"},{"level":2,"text":"Interface Contracts","id":"interface-contracts"},{"level":3,"text":"Planner Entry Point","id":"planner-entry-point"},{"level":3,"text":"Statistics Management","id":"statistics-management"},{"level":2,"text":"Algorithm Specification","id":"algorithm-specification"},{"level":3,"text":"Cost-Based Access Path Selection","id":"cost-based-access-path-selection"},{"level":3,"text":"Selectivity Estimation","id":"selectivity-estimation"},{"level":3,"text":"Greedy Join Order","id":"greedy-join-order"},{"level":2,"text":"Error Handling Matrix","id":"error-handling-matrix"},{"level":2,"text":"Implementation Sequence with Checkpoints","id":"implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Statistics Collection (ANALYZE) (2 hours)","id":"phase-1-statistics-collection-analyze-2-hours"},{"level":3,"text":"Phase 2: Selectivity Estimation (2 hours)","id":"phase-2-selectivity-estimation-2-hours"},{"level":3,"text":"Phase 3: Cost Model (2 hours)","id":"phase-3-cost-model-2-hours"},{"level":3,"text":"Phase 4: Plan Selection and EXPLAIN (2 hours)","id":"phase-4-plan-selection-and-explain-2-hours"},{"level":3,"text":"Phase 5: Join Order Optimization (2 hours)","id":"phase-5-join-order-optimization-2-hours"},{"level":2,"text":"Test Specification","id":"test-specification"},{"level":2,"text":"Performance Targets","id":"performance-targets"},{"level":2,"text":"Synced Criteria","id":"synced-criteria"}],"title":"Build Your Own SQLite","markdown":"# Build Your Own SQLite\n\nThis project constructs a fully functional embedded SQL database from scratch, implementing the complete SQLite architecture: a tokenizer and recursive-descent parser producing ASTs, a bytecode compiler targeting a virtual database engine (VDBE), and a page-based storage engine with B-trees for clustered tables and B+trees for secondary indexes. The system includes a buffer pool with LRU eviction, a cost-based query planner with statistics-driven optimization, and ACID transactions via both rollback journal and write-ahead logging modes.\n\nBuilding SQLite reveals why databases are designed the way they are. Every layer—the virtual machine, the page format, the WAL—exists to solve a specific tension between speed and durability. You'll discover that SQL execution is essentially running bytecode on a register machine, that B-tree splits are where theory meets messy reality, and that crash recovery is an intricate dance of write ordering and checksums.\n\n\n\n<!-- MS_ID: build-sqlite-m1 -->\n# Milestone 1: SQL Tokenizer\n\n## Where We Are in the System\n\n\n![SQLite Architecture: The Complete System Map](./diagrams/diag-satellite-overview.svg)\n\n\nYou're building the **front door** of the database. Before any SQL can be parsed, optimized, or executed, it must be broken into tokens—the atomic units of meaning. This tokenizer sits at the very beginning of the query pipeline, converting raw character input into a structured stream that the parser can consume.\n\nEvery query your database will ever process passes through this code. A bug here corrupts everything downstream.\n\n---\n\n## The Tension: Context Changes Meaning\n\nConsider this SQL fragment:\n\n```sql\nSELECT 'SELECT' FROM \"FROM\"\n```\n\nThere are **four** occurrences of the word \"SELECT\" and \"FROM\" in that line. But only **two** are keywords. The others are data—literally the strings 'SELECT' and \"FROM\" (the latter being a quoted table name).\n\nNow consider:\n\n```sql\na-7    -- subtraction: identifier MINUS number\n-7     -- negative number\n'a-7'  -- string literal containing dash\n```\n\nThe dash character means three different things depending on context.\n\n**This is the fundamental tension of tokenization: the same character sequence can have completely different meanings based on parser state.** A simple `split()` on whitespace cannot distinguish between a keyword inside quotes and a keyword outside them. Regex patterns that don't track state will misclassify tokens.\n\nThe solution is a **finite state machine**—code that explicitly tracks whether you're currently inside a string literal, a quoted identifier, a numeric literal, or normal \"code\" space, and transitions between these states based on input characters.\n\n---\n\n## The Tokenizer State Machine\n\n{{DIAGRAM:diag-tokenizer-state-machine}}\n\nYour tokenizer will operate as a character-by-character state machine with these primary states:\n\n| State | Meaning | What Transitions Out |\n|-------|---------|---------------------|\n| **DEFAULT** | Normal code space | Letter → keyword/identifier, Digit → number, `'` → string, `\"` → quoted identifier, Operator char → operator |\n| **IN_STRING** | Inside `'...'` literal | `'` → check for escape (`''`), otherwise end string |\n| **IN_QUOTED_ID** | Inside `\"...\"` identifier | `\"` → end identifier |\n| **IN_NUMBER** | Parsing numeric literal | Digit/`.` → continue, other → emit token, return to DEFAULT |\n| **IN_IDENTIFIER** | Parsing unquoted identifier/keyword | Letter/digit/`_` → continue, other → emit token, return to DEFAULT |\n\nThe key insight: **you cannot determine token boundaries without tracking state.** When you see a `'` character, you don't know if it starts a string, ends a string, or is an escaped quote until you know the current state and look at the next character.\n\n---\n\n## Building the Tokenizer: Step by Step\n\n### The Token Structure\n\nEvery token your tokenizer emits needs four pieces of information:\n\n```go\ntype Token struct {\n    Type   TokenType  // Classification: KEYWORD, IDENTIFIER, STRING, NUMBER, OPERATOR, etc.\n    Value  string     // The actual text: \"SELECT\", \"users\", \"hello world\", \"42\"\n    Line   int        // 1-indexed line number for error reporting\n    Column int        // 1-indexed column number for error reporting\n}\n```\n\nThe line and column fields are **not optional**. When a user writes malformed SQL like `SELECT * FORM users` (misspelled FROM), the parser needs to report exactly where the error occurred. The tokenizer is the only component that sees the raw input—it must count newlines and track position.\n\n### Keyword Recognition: Case-Insensitive Matching\n\nSQL keywords are case-insensitive. These are all valid:\n\n```sql\nSELECT * FROM users\nselect * from users  \nSelect * From Users\n```\n\nYour tokenizer should:\n1. Collect the identifier text character by character\n2. Convert to uppercase (or lowercase) for comparison\n3. Check against a keyword set/map\n4. Emit either a KEYWORD token or an IDENTIFIER token\n\n```go\nvar keywords = map[string]bool{\n    \"SELECT\": true, \"FROM\": true, \"WHERE\": true, \"INSERT\": true,\n    \"INTO\": true, \"VALUES\": true, \"UPDATE\": true, \"DELETE\": true,\n    \"CREATE\": true, \"TABLE\": true, \"INDEX\": true, \"DROP\": true,\n    \"AND\": true, \"OR\": true, \"NOT\": true, \"NULL\": true,\n    \"PRIMARY\": true, \"KEY\": true, \"UNIQUE\": true, \"FOREIGN\": true,\n    \"JOIN\": true, \"INNER\": true, \"LEFT\": true, \"RIGHT\": true, \"ON\": true,\n    \"ORDER\": true, \"BY\": true, \"ASC\": true, \"DESC\": true,\n    \"GROUP\": true, \"HAVING\": true, \"LIMIT\": true, \"OFFSET\": true,\n    \"INTEGER\": true, \"TEXT\": true, \"REAL\": true, \"BLOB\": true,\n    \"BEGIN\": true, \"COMMIT\": true, \"ROLLBACK\": true,\n}\n\nfunc (t *Tokenizer) classifyIdentifier(text string) TokenType {\n    upper := strings.ToUpper(text)\n    if keywords[upper] {\n        return KEYWORD\n    }\n    return IDENTIFIER\n}\n```\n\n**Important**: The original case is preserved in the `Value` field. Only the classification uses case-insensitive matching. This matters for identifiers—`\"Users\"` and `users` may be different tables depending on quoting rules.\n\n### String Literals: The Escape Sequence Problem\n\nSQL string literals use single quotes, and a single quote *inside* the string is escaped by doubling it:\n\n```sql\n'It''s a beautiful day'   -- String value: It's a beautiful day\n'O''Brien'                -- String value: O'Brien\n''''                      -- String value: ' (single quote)\n```\n\nThis is where naive approaches fail. A tokenizer that just looks for the next `'` character will incorrectly terminate at the first escape.\n\nThe correct logic in the `IN_STRING` state:\n\n```\nWhen current char is ':\n    Peek at next char\n    If next char is also ':\n        This is an escape - append ' to value, advance past both quotes\n    Else:\n        This is the closing quote - emit STRING token, return to DEFAULT\n```\n\n### Numeric Literals: Integers vs Floats\n\nNumbers require distinguishing between integers and floating-point values:\n\n```sql\n42        -- INTEGER\n3.14      -- FLOAT (has decimal point)\n-7        -- INTEGER (negative, but handled carefully - see pitfalls)\n1e10      -- FLOAT (scientific notation - optional enhancement)\n```\n\nThe state machine for numbers:\n1. If first char is a digit, enter `IN_NUMBER` state\n2. Continue collecting digits\n3. If `.` encountered, mark as FLOAT and continue\n4. On non-numeric char, emit NUMBER token with appropriate subtype\n\n**Note on negative numbers**: The `-` in `-7` is actually the unary minus *operator* applied to the literal `7`. Some tokenizers treat `-7` as a single negative number token; others emit `OPERATOR(-)` followed by `NUMBER(7)`. The latter approach is cleaner because it handles `-  7` (with spaces) correctly. However, for SQL, it's common to lex `-7` as a single negative number token for convenience. Either approach works if your parser handles it consistently.\n\n### Operators: Single and Double Character\n\nSQL has operators that are one character (`=`, `<`, `>`, `+`, `-`, `*`, `/`) and operators that are two characters (`<=`, `>=`, `!=`, `<>`).\n\nThe tokenizer needs to **peek ahead** when it encounters a character that could start a multi-character operator:\n\n```go\nfunc (t *Tokenizer) readOperator() Token {\n    start := t.pos\n    ch := t.current()\n    \n    // Check for two-character operators\n    switch ch {\n    case '<':\n        if t.peek() == '=' {\n            t.advance(2)\n            return t.makeToken(OPERATOR, \"<=\", start)\n        }\n        if t.peek() == '>' {  // <> is also not-equals\n            t.advance(2)\n            return t.makeToken(OPERATOR, \"<>\", start)\n        }\n    case '>':\n        if t.peek() == '=' {\n            t.advance(2)\n            return t.makeToken(OPERATOR, \">=\", start)\n        }\n    case '!':\n        if t.peek() == '=' {\n            t.advance(2)\n            return t.makeToken(OPERATOR, \"!=\", start)\n        }\n    case '=':\n        // Could be == in some dialects, but SQL uses = for equality\n    }\n    \n    // Single character operator\n    t.advance(1)\n    return t.makeToken(OPERATOR, string(ch), start)\n}\n```\n\n### Quoted Identifiers: Double Quotes\n\nSQL allows identifiers containing spaces or special characters when wrapped in double quotes:\n\n```sql\nCREATE TABLE \"Order Details\" (\n    \"Item Name\" TEXT,\n    \"Price ($)\" REAL\n)\n```\n\nThe `IN_QUOTED_ID` state is similar to `IN_STRING`, but SQL quoted identifiers typically don't use escape doubling—`\"a\"\"b\"` would end the identifier at the second quote, producing `a` followed by a syntax error or another identifier `b`. Check your target SQL dialect's rules.\n\n### Whitespace and Comments\n\nWhitespace (spaces, tabs, newlines) separates tokens but is not emitted as tokens itself. The tokenizer simply skips over it in the DEFAULT state.\n\nComments should also be skipped:\n- `-- This is a line comment` (continues to end of line)\n- `/* This is a block comment */` (can span multiple lines)\n\nSkipping comments happens in the DEFAULT state before attempting to read a token.\n\n---\n\n## Error Reporting: Line and Column Tracking\n\nWhen the tokenizer encounters an unexpected character (like `@` or a stray `\"` that's never closed), it must report the location precisely.\n\nThis requires maintaining position state:\n\n```go\ntype Tokenizer struct {\n    input   string\n    pos     int  // Current byte position in input\n    line    int  // Current line number (1-indexed)\n    column  int  // Current column number (1-indexed)\n}\n\nfunc (t *Tokenizer) advance(n int) {\n    for i := 0; i < n; i++ {\n        if t.input[t.pos] == '\\n' {\n            t.line++\n            t.column = 1\n        } else {\n            t.column++\n        }\n        t.pos++\n    }\n}\n```\n\nEvery token captures the line and column at its **start** position. An unclosed string literal error reports where the string *began*, not where the input ended.\n\n---\n\n## The Token Stream Output\n\n\n![Token Stream: SELECT Statement Before and After](./diagrams/diag-token-stream-example.svg)\n\n\nFor input:\n\n```sql\nSELECT name, age FROM users WHERE age > 18;\n```\n\nThe tokenizer produces:\n\n```\n[0] KEYWORD(\"SELECT\")      line:1, col:1\n[1] IDENTIFIER(\"name\")     line:1, col:8\n[2] PUNCTUATION(\",\")       line:1, col:12\n[3] IDENTIFIER(\"age\")      line:1, col:14\n[4] KEYWORD(\"FROM\")        line:1, col:18\n[5] IDENTIFIER(\"users\")    line:1, col:23\n[6] KEYWORD(\"WHERE\")       line:1, col:29\n[7] IDENTIFIER(\"age\")      line:1, col:35\n[8] OPERATOR(\">\")          line:1, col:39\n[9] NUMBER(\"18\")           line:1, col:41\n[10] PUNCTUATION(\";\")      line:1, col:43\n```\n\nThis array of tokens is what the parser (next milestone) will consume to build an AST.\n\n---\n\n## A Complete Tokenization Example\n\nLet's trace through a complex statement:\n\n```sql\nINSERT INTO \"User Data\" (id, name) VALUES (1, 'Alice''s Restaurant');\n```\n\n| Step | Char | State → State | Token Emitted |\n|------|------|---------------|---------------|\n| 1 | I | DEFAULT → IN_IDENTIFIER | — |\n| 2-6 | NSERT | IN_IDENTIFIER | — |\n| 7 | (space) | IN_IDENTIFIER → DEFAULT | KEYWORD(\"INSERT\") |\n| 8-11 | INTO | DEFAULT → IN_IDENTIFIER → DEFAULT | KEYWORD(\"INTO\") |\n| 12 | \" | DEFAULT → IN_QUOTED_ID | — |\n| 13-21 | User Data | IN_QUOTED_ID | — |\n| 22 | \" | IN_QUOTED_ID → DEFAULT | IDENTIFIER(\"User Data\") |\n| 23 | ( | DEFAULT | PUNCTUATION(\"(\") |\n| 24-25 | id | IN_IDENTIFIER | IDENTIFIER(\"id\") |\n| 26 | , | DEFAULT | PUNCTUATION(\",\") |\n| 27-30 | name | IN_IDENTIFIER | IDENTIFIER(\"name\") |\n| 31 | ) | DEFAULT | PUNCTUATION(\")\") |\n| 32-36 | VALUES | IN_IDENTIFIER | KEYWORD(\"VALUES\") |\n| 37 | ( | DEFAULT | PUNCTUATION(\"(\") |\n| 38 | 1 | IN_NUMBER | NUMBER(\"1\", INTEGER) |\n| 39 | , | DEFAULT | PUNCTUATION(\",\") |\n| 40 | ' | DEFAULT → IN_STRING | — |\n| 41-45 | Alice | IN_STRING | — |\n| 46 | ' | IN_STRING (check next) | — (next is also ') |\n| 47 | ' | IN_STRING (escaped) | — (append ' to value) |\n| 48-58 | s Restaurant | IN_STRING | — |\n| 59 | ' | IN_STRING → DEFAULT | STRING(\"Alice's Restaurant\") |\n| 60 | ) | DEFAULT | PUNCTUATION(\")\") |\n| 61 | ; | DEFAULT | PUNCTUATION(\";\") |\n\nNotice step 46-47: the doubled quote inside the string is recognized as an escape, and only a single quote is added to the token value.\n\n---\n\n## Common Pitfalls\n\n### 1. Not Handling Escaped Quotes\n\n```sql\n'It''s broken'   -- Without escape handling, produces: \"It\" followed by error\n```\n\nThe tokenizer would emit STRING(\"It\"), then see `s broken'` and fail because `s` isn't a valid token start in that context.\n\n**Fix**: In the `IN_STRING` state, always peek ahead when you see `'` to check for the escape sequence.\n\n### 2. Case Sensitivity Confusion\n\n```sql\nSELECT * FROM Users   -- \"Users\" should be IDENTIFIER, not keyword\n```\n\nKeywords are case-insensitive, but the *text* of the token should preserve original case. Don't lowercase the `Value` field—only use lowercase/uppercase for the keyword *lookup*.\n\n### 3. Negative Numbers vs Subtraction\n\n```sql\nSELECT a-7 FROM t   -- Is this \"a minus 7\" or \"a negative-7\"?\n```\n\nWith whitespace: `a - 7` is clearly subtraction. Without: `a-7` is ambiguous.\n\nThe safest approach: **emit the `-` as an operator always**, let the parser decide if it's unary minus (negation) or binary minus (subtraction). This handles both `a-7` and `a - 7` and `-7` uniformly.\n\nIf you *do* want to lex `-7` as a single negative number, only do so when `-` is immediately followed by a digit AND the preceding token (if any) suggests an expression context (after an operator, after `(`, at start of statement, etc.). This is complex and error-prone.\n\n### 4. Unicode and Multi-byte Characters\n\nIf your SQL supports Unicode identifiers like `名前`, you cannot use simple byte indexing. UTF-8 encodes characters as 1-4 bytes, and your line/column tracking must count *characters*, not bytes.\n\n**For this project**: Start with ASCII-only identifiers. Document the limitation. Unicode support can be added later with a proper UTF-8 decoder.\n\n### 5. Forgetting to Track Position\n\nIf you don't increment line/column during tokenization, you can't provide useful error messages. The parser will be left saying \"unexpected token\" without being able to show *where*.\n\n---\n\n## Test Suite: What to Verify\n\nYour tokenizer test suite should cover:\n\n**Basic tokens:**\n```sql\nSELECT        -- KEYWORD\nmy_table      -- IDENTIFIER  \n42            -- NUMBER (integer)\n3.14          -- NUMBER (float)\n=             -- OPERATOR\n(             -- PUNCTUATION\n```\n\n**Case insensitivity:**\n```sql\nselect SELECT Select sElEcT   -- All KEYWORD\n```\n\n**String escapes:**\n```sql\n'hello'         -- STRING(\"hello\")\n'It''s'         -- STRING(\"It's\")\n''''            -- STRING(\"'\")\n''              -- STRING(\"\") (empty string)\n```\n\n**Quoted identifiers:**\n```sql\n\"column name\"   -- IDENTIFIER(\"column name\")\n\"SELECT\"        -- IDENTIFIER(\"SELECT\") -- NOT a keyword!\n```\n\n**Operators:**\n```sql\n= < > <= >= != <>   -- All distinct OPERATOR tokens\n```\n\n**Complex statements:**\n```sql\nSELECT id, name FROM users WHERE age >= 21 AND status = 'active' ORDER BY name;\nINSERT INTO logs (message, ts) VALUES ('User logged in', '2024-01-15');\nCREATE TABLE \"Order Items\" (id INTEGER PRIMARY KEY, qty INTEGER NOT NULL);\n```\n\n**Error cases:**\n```sql\n'It never ends    -- Unclosed string: error at line 1, column 1\n\"also unclosed    -- Unclosed identifier: error at line 1, column 1\n@bad_char         -- Unrecognized character: error at line 1, column 1\n```\n\nAim for **20+ diverse SQL statements** in your test suite, including edge cases.\n\n---\n\n## Knowledge Cascade: What This Unlocks\n\nYou've just built a **lexer**—the foundation of all language processing. Here's where this knowledge connects:\n\n**Immediate connections:**\n- **Parser (next milestone)**: Your token stream feeds directly into the recursive-descent parser. The token types you defined become the grammar terminals.\n- **Error messages**: The line/column tracking you implemented will be used by every error message the database produces.\n\n**Same domain:**\n- **Regular expressions**: The state machine you built is what regex engines compile patterns into. A regex like `'[']*'` compiles to nearly the same state transitions as your string literal handler.\n- **Lexer generators (flex, lex, ANTLR)**: Tools that generate tokenizers from declarative specifications. Your hand-written version gives you complete control and better error messages.\n\n**Cross-domain:**\n- **IDE syntax highlighting**: The colored SQL you see in editors comes from a tokenizer nearly identical to this one, running on every keystroke to recolor the text.\n- **UTF-8/Unicode handling**: Multi-byte character processing is a state machine problem too—you're doing character-by-character processing, which is the right mental model for handling variable-width encodings.\n- **SQL injection detection**: Understanding token boundaries reveals why sanitization is hard. An attacker who knows your tokenizer's rules can craft inputs like `' OR '1'='1` that break out of string contexts. Tokenization is the first line of defense—you must handle all escape sequences correctly or leave vulnerabilities.\n\n**Forward:**\n- **With this knowledge, you could now build**: A syntax highlighter for SQL, a SQL formatter/prettifier, a basic SQL linter that detects syntax issues before parsing, or a query logger that redacts string literals for privacy.\n\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-sqlite-m2 -->\n# Milestone 2: SQL Parser (AST)\n\n## Where We Are in the System\n\n\n![SQLite Architecture: The Complete System Map](./diagrams/diag-satellite-overview.svg)\n\n\nYour tokenizer hands you a clean stream of tokens—`KEYWORD(\"SELECT\")`, `IDENTIFIER(\"users\")`, `OPERATOR(\">\")`, `NUMBER(\"18\")`. Now you must answer: **what does this sequence mean?**\n\nThe parser's job is to impose structure on this flat stream. It recognizes that `SELECT` starts a query, that `FROM` introduces a table reference, that `WHERE` begins a filter condition, and that `age > 18` is an expression with an operator and two operands. The output is an **Abstract Syntax Tree** (AST)—a hierarchical representation that captures the *meaning* of the SQL statement.\n\n\n![AST Structure: SELECT Statement Tree](./diagrams/diag-ast-structure.svg)\n\n\nThis AST is what the bytecode compiler (next milestone) will traverse to generate executable instructions. A malformed AST produces incorrect bytecode, which produces wrong query results.\n\n---\n\n## The Tension: Ambiguity and Infinite Loops\n\nConsider parsing this SQL expression:\n\n```sql\nSELECT * FROM users WHERE active = 1 OR role = 'admin' AND level > 5\n```\n\nDoes this mean:\n- `(active = 1 OR role = 'admin') AND level > 5` — users who are either active or admins, AND have level > 5?\n- `active = 1 OR (role = 'admin' AND level > 5)` — users who are active, OR admins with level > 5?\n\nThese return **different results**. The parser must resolve this ambiguity using operator precedence rules.\n\nNow consider this grammar rule for expressions:\n\n```\nexpression → expression AND expression\n           | expression OR expression\n           | comparison\n```\n\nLooks reasonable. But try parsing `a OR b`:\n\n1. Try to match `expression AND expression`\n2. To match the left `expression`, try `expression AND expression` again\n3. To match *that* left `expression`, try `expression AND expression` again\n4. **Infinite recursion**—the parser never makes progress\n\nThis is **left recursion**, and it's fatal for recursive descent parsers. The grammar is mathematically valid, but the implementation strategy (recursive functions calling themselves with the same input position) cannot handle it.\n\n**Two problems emerge:**\n1. **Ambiguity**: The same token sequence can be interpreted multiple ways—precedence rules must pick one\n2. **Left recursion**: Naive grammar encoding causes infinite loops—structure must be rewritten or a different algorithm used\n\n---\n\n## The Revelation: Precedence Is Not Natural\n\nYou might expect operator precedence to \"just work\" if you structure your grammar correctly. It doesn't.\n\nSQL's precedence hierarchy (highest to lowest):\n1. `NOT` — unary negation\n2. Comparison operators: `=`, `<`, `>`, `<=`, `>=`, `!=`, `<>`\n3. `AND` — conjunction\n4. `OR` — disjunction (lowest precedence)\n\nThis means:\n\n```sql\nNOT a = b AND c > d OR e < f\n```\n\nIs parsed as:\n\n```\nOR\n├── AND\n│   ├── NOT\n│   │   └── = (a, b)\n│   └── > (c, d)\n└── < (e, f)\n```\n\nA naive grammar that treats all binary operators equally produces a flat or wrong tree. A grammar that encodes precedence explicitly becomes verbose and hard to maintain:\n\n```\nor_expr     → and_expr (OR and_expr)*\nand_expr    → not_expr (AND not_expr)*\nnot_expr    → NOT not_expr | comparison\ncomparison  → primary (('=' | '<' | '>') primary)?\n```\n\nThis works but requires four separate functions for expressions alone. Add more operators and the complexity grows.\n\nThe elegant solution is **precedence climbing** or **Pratt parsing**—a single algorithm that handles all operators using precedence values and associativity rules. You write one function, configure a table of operators, and the algorithm produces correct trees automatically.\n\n---\n\n## Three-Level View: From Token Stream to AST\n\n{{DIAGRAM:diag-query-execution-pipeline}}\n\n| Level | What It Does | Example |\n|-------|--------------|---------|\n| **Statement** | Top-level structure: SELECT, INSERT, CREATE, etc. | `SELECT ... FROM ... WHERE ...` |\n| **Clause** | Components within a statement | `WHERE active = 1` |\n| **Expression** | Computable values with operators | `a OR b AND NOT c` |\n\nYour parser descends through these levels:\n1. **Statement level**: Look at first token to choose SELECT parser, INSERT parser, etc.\n2. **Clause level**: Parse column list, FROM clause, WHERE clause, etc.\n3. **Expression level**: Handle operators with correct precedence\n\n---\n\n## Building the Parser: Step by Step\n\n### The Parser Structure\n\n```go\ntype Parser struct {\n    tokens    []Token\n    pos       int       // Current position in token array\n    current   Token     // Lookahead token\n    errors    []ParseError\n}\n\ntype ParseError struct {\n    Message string\n    Line    int\n    Column  int\n}\n```\n\nThe parser maintains a **lookahead**—the current token being examined. One token of lookahead is sufficient for SQL (it's an LL(1) grammar with some exceptions handled by context).\n\n```go\nfunc (p *Parser) advance() {\n    p.pos++\n    if p.pos < len(p.tokens) {\n        p.current = p.tokens[p.pos]\n    } else {\n        p.current = Token{Type: EOF}\n    }\n}\n\nfunc (p *Parser) expect(tokenType TokenType, value string) error {\n    if p.current.Type != tokenType || p.current.Value != value {\n        return p.error(\"expected %s, got %s\", value, p.current.Value)\n    }\n    p.advance()\n    return nil\n}\n```\n\n### Statement Parsing: Dispatch on First Token\n\n```go\nfunc (p *Parser) ParseStatement() (Statement, error) {\n    switch {\n    case p.current.Type == KEYWORD && p.current.Value == \"SELECT\":\n        return p.parseSelect()\n    case p.current.Type == KEYWORD && p.current.Value == \"INSERT\":\n        return p.parseInsert()\n    case p.current.Type == KEYWORD && p.current.Value == \"CREATE\":\n        return p.parseCreate()\n    // ... other statement types\n    default:\n        return nil, p.error(\"unexpected token: %s\", p.current.Value)\n    }\n}\n```\n\nEach statement type has its own parsing function that knows the expected structure.\n\n### SELECT Statement Parsing\n\n```go\ntype SelectStatement struct {\n    Columns    []ColumnSelection  // * or explicit column list\n    FromTable  string             // Table name\n    Where      Expression         // Optional filter\n    OrderBy    []OrderByColumn    // Optional ordering\n    Limit      *int               // Optional row limit\n}\n\ntype ColumnSelection struct {\n    Expression Expression\n    Alias      string  // Optional: \"AS alias\"\n}\n\nfunc (p *Parser) parseSelect() (*SelectStatement, error) {\n    stmt := &SelectStatement{}\n    \n    // SELECT\n    if err := p.expect(KEYWORD, \"SELECT\"); err != nil {\n        return nil, err\n    }\n    \n    // Column list (or *)\n    columns, err := p.parseColumnList()\n    if err != nil {\n        return nil, err\n    }\n    stmt.Columns = columns\n    \n    // FROM clause (required)\n    if p.current.Type == KEYWORD && p.current.Value == \"FROM\" {\n        p.advance()\n        if p.current.Type != IDENTIFIER {\n            return nil, p.error(\"expected table name after FROM\")\n        }\n        stmt.FromTable = p.current.Value\n        p.advance()\n    }\n    \n    // WHERE clause (optional)\n    if p.current.Type == KEYWORD && p.current.Value == \"WHERE\" {\n        p.advance()\n        expr, err := p.parseExpression()\n        if err != nil {\n            return nil, err\n        }\n        stmt.Where = expr\n    }\n    \n    // ORDER BY (optional)\n    if p.current.Type == KEYWORD && p.current.Value == \"ORDER\" {\n        p.advance()\n        if err := p.expect(KEYWORD, \"BY\"); err != nil {\n            return nil, err\n        }\n        stmt.OrderBy, _ = p.parseOrderByList()\n    }\n    \n    // LIMIT (optional)\n    if p.current.Type == KEYWORD && p.current.Value == \"LIMIT\" {\n        p.advance()\n        if p.current.Type != NUMBER {\n            return nil, p.error(\"expected number after LIMIT\")\n        }\n        limit := parseInt(p.current.Value)\n        stmt.Limit = &limit\n        p.advance()\n    }\n    \n    return stmt, nil\n}\n```\n\nKey insight: **keywords structure the parse**. After `SELECT`, you expect columns. After `FROM`, you expect a table. After `WHERE`, you expect an expression. The parser follows this roadmap.\n\n### INSERT Statement Parsing\n\n```go\ntype InsertStatement struct {\n    Table    string\n    Columns  []string      // Optional column names\n    Values   [][]Expression  // VALUES clause(s)\n}\n\nfunc (p *Parser) parseInsert() (*InsertStatement, error) {\n    stmt := &InsertStatement{}\n    \n    // INSERT INTO\n    if err := p.expect(KEYWORD, \"INSERT\"); err != nil {\n        return nil, err\n    }\n    if err := p.expect(KEYWORD, \"INTO\"); err != nil {\n        return nil, err\n    }\n    \n    // Table name\n    if p.current.Type != IDENTIFIER {\n        return nil, p.error(\"expected table name\")\n    }\n    stmt.Table = p.current.Value\n    p.advance()\n    \n    // Optional column list: (col1, col2, ...)\n    if p.current.Type == PUNCTUATION && p.current.Value == \"(\" {\n        p.advance()\n        stmt.Columns = p.parseIdentifierList()\n        if err := p.expect(PUNCTUATION, \")\"); err != nil {\n            return nil, err\n        }\n    }\n    \n    // VALUES clause\n    if err := p.expect(KEYWORD, \"VALUES\"); err != nil {\n        return nil, err\n    }\n    \n    // One or more value tuples: (1, 'a'), (2, 'b')\n    for {\n        if p.current.Type != PUNCTUATION || p.current.Value != \"(\" {\n            return nil, p.error(\"expected '(' to start VALUES tuple\")\n        }\n        p.advance()\n        values, err := p.parseExpressionList()\n        if err != nil {\n            return nil, err\n        }\n        stmt.Values = append(stmt.Values, values)\n        \n        if err := p.expect(PUNCTUATION, \")\"); err != nil {\n            return nil, err\n        }\n        \n        // Check for more tuples\n        if p.current.Type != PUNCTUATION || p.current.Value != \",\" {\n            break\n        }\n        p.advance()\n    }\n    \n    return stmt, nil\n}\n```\n\n### CREATE TABLE Parsing\n\n```go\ntype CreateTableStatement struct {\n    Table       string\n    Columns     []ColumnDefinition\n    Constraints []TableConstraint\n}\n\ntype ColumnDefinition struct {\n    Name        string\n    Type        string       // INTEGER, TEXT, REAL, BLOB\n    Constraints []ColumnConstraint  // PRIMARY KEY, NOT NULL, UNIQUE, etc.\n}\n\nfunc (p *Parser) parseCreate() (*CreateTableStatement, error) {\n    stmt := &CreateTableStatement{}\n    \n    // CREATE TABLE\n    if err := p.expect(KEYWORD, \"CREATE\"); err != nil {\n        return nil, err\n    }\n    if err := p.expect(KEYWORD, \"TABLE\"); err != nil {\n        return nil, err\n    }\n    \n    // Table name (may be quoted)\n    if p.current.Type != IDENTIFIER {\n        return nil, p.error(\"expected table name\")\n    }\n    stmt.Table = p.current.Value\n    p.advance()\n    \n    // Column definitions in parentheses\n    if err := p.expect(PUNCTUATION, \"(\"); err != nil {\n        return nil, err\n    }\n    \n    for {\n        col, err := p.parseColumnDefinition()\n        if err != nil {\n            return nil, err\n        }\n        stmt.Columns = append(stmt.Columns, col)\n        \n        // More columns?\n        if p.current.Type == PUNCTUATION && p.current.Value == \",\" {\n            p.advance()\n            continue\n        }\n        break\n    }\n    \n    if err := p.expect(PUNCTUATION, \")\"); err != nil {\n        return nil, err\n    }\n    \n    return stmt, nil\n}\n\nfunc (p *Parser) parseColumnDefinition() (ColumnDefinition, error) {\n    col := ColumnDefinition{}\n    \n    // Column name\n    if p.current.Type != IDENTIFIER {\n        return col, p.error(\"expected column name\")\n    }\n    col.Name = p.current.Value\n    p.advance()\n    \n    // Data type\n    if p.current.Type != KEYWORD {\n        return col, p.error(\"expected data type\")\n    }\n    col.Type = p.current.Value  // INTEGER, TEXT, REAL, BLOB\n    p.advance()\n    \n    // Optional constraints\n    for {\n        if p.current.Type != KEYWORD {\n            break\n        }\n        \n        switch p.current.Value {\n        case \"PRIMARY\":\n            p.advance()\n            if err := p.expect(KEYWORD, \"KEY\"); err != nil {\n                return col, err\n            }\n            col.Constraints = append(col.Constraints, PrimaryKeyConstraint{})\n        case \"NOT\":\n            p.advance()\n            if err := p.expect(KEYWORD, \"NULL\"); err != nil {\n                return col, err\n            }\n            col.Constraints = append(col.Constraints, NotNullConstraint{})\n        case \"UNIQUE\":\n            p.advance()\n            col.Constraints = append(col.Constraints, UniqueConstraint{})\n        default:\n            // Not a constraint keyword - stop parsing constraints\n            return col, nil\n        }\n    }\n    \n    return col, nil\n}\n```\n\n---\n\n## Expression Parsing: The Heart of the Parser\n\nThis is where precedence matters. You have two approaches:\n\n### Approach 1: Explicit Precedence Levels (Grammar Rewriting)\n\n```go\n// OR has lowest precedence - start here\nfunc (p *Parser) parseExpression() (Expression, error) {\n    return p.parseOrExpression()\n}\n\nfunc (p *Parser) parseOrExpression() (Expression, error) {\n    left, err := p.parseAndExpression()\n    if err != nil {\n        return nil, err\n    }\n    \n    for p.current.Type == KEYWORD && p.current.Value == \"OR\" {\n        p.advance()\n        right, err := p.parseAndExpression()\n        if err != nil {\n            return nil, err\n        }\n        left = &BinaryExpression{Operator: \"OR\", Left: left, Right: right}\n    }\n    \n    return left, nil\n}\n\nfunc (p *Parser) parseAndExpression() (Expression, error) {\n    left, err := p.parseNotExpression()\n    if err != nil {\n        return nil, err\n    }\n    \n    for p.current.Type == KEYWORD && p.current.Value == \"AND\" {\n        p.advance()\n        right, err := p.parseNotExpression()\n        if err != nil {\n            return nil, err\n        }\n        left = &BinaryExpression{Operator: \"AND\", Left: left, Right: right}\n    }\n    \n    return left, nil\n}\n\nfunc (p *Parser) parseNotExpression() (Expression, error) {\n    if p.current.Type == KEYWORD && p.current.Value == \"NOT\" {\n        p.advance()\n        operand, err := p.parseNotExpression()\n        if err != nil {\n            return nil, err\n        }\n        return &UnaryExpression{Operator: \"NOT\", Operand: operand}, nil\n    }\n    \n    return p.parseComparisonExpression()\n}\n\nfunc (p *Parser) parseComparisonExpression() (Expression, error) {\n    left, err := p.parsePrimaryExpression()\n    if err != nil {\n        return nil, err\n    }\n    \n    // Check for comparison operators\n    if p.current.Type == OPERATOR {\n        op := p.current.Value\n        if op == \"=\" || op == \"<\" || op == \">\" || op == \"<=\" || op == \">=\" || op == \"!=\" || op == \"<>\" {\n            p.advance()\n            right, err := p.parsePrimaryExpression()\n            if err != nil {\n                return nil, err\n            }\n            return &BinaryExpression{Operator: op, Left: left, Right: right}, nil\n        }\n    }\n    \n    return left, nil\n}\n\nfunc (p *Parser) parsePrimaryExpression() (Expression, error) {\n    // Parenthesized expression - highest precedence\n    if p.current.Type == PUNCTUATION && p.current.Value == \"(\" {\n        p.advance()\n        expr, err := p.parseExpression()  // Start over at top\n        if err != nil {\n            return nil, err\n        }\n        if err := p.expect(PUNCTUATION, \")\"); err != nil {\n            return nil, err\n        }\n        return expr, nil\n    }\n    \n    // Literals\n    if p.current.Type == NUMBER {\n        val := parseIntOrFloat(p.current.Value)\n        p.advance()\n        return &LiteralExpression{Value: val}, nil\n    }\n    \n    if p.current.Type == STRING {\n        val := p.current.Value\n        p.advance()\n        return &LiteralExpression{Value: val}, nil\n    }\n    \n    // NULL\n    if p.current.Type == KEYWORD && p.current.Value == \"NULL\" {\n        p.advance()\n        return &LiteralExpression{Value: nil}, nil\n    }\n    \n    // Identifier (column reference)\n    if p.current.Type == IDENTIFIER {\n        name := p.current.Value\n        p.advance()\n        return &IdentifierExpression{Name: name}, nil\n    }\n    \n    return nil, p.error(\"expected expression\")\n}\n```\n\n\n![Expression Precedence: How AND/OR Are Parsed](./diagrams/diag-precedence-climbing.svg)\n\n\nThis works correctly. `a OR b AND c` is parsed as `a OR (b AND c)` because `parseOrExpression` calls `parseAndExpression` first, which binds the `AND` tighter.\n\n### Approach 2: Precedence Climbing (Compact)\n\nIf you want a single function for all binary operators:\n\n```go\nvar precedence = map[string]int{\n    \"OR\":  1,\n    \"AND\": 2,\n    \"=\":   3, \"<\": 3, \">\": 3, \"<=\": 3, \">=\": 3, \"!=\": 3, \"<>\": 3,\n    \"NOT\": 4,  // Unary, handled separately\n}\n\nfunc (p *Parser) parseExpressionWithPrecedence(minPrec int) (Expression, error) {\n    // Parse left operand (handles NOT, atoms, parenthesized expressions)\n    left, err := p.parseUnaryOrAtom()\n    if err != nil {\n        return nil, err\n    }\n    \n    // While current token is a binary operator with sufficient precedence\n    for {\n        op := p.current.Value\n        prec, isBinary := precedence[op]\n        if !isBinary || prec < minPrec {\n            break\n        }\n        \n        p.advance()\n        \n        // Parse right operand with higher precedence\n        right, err := p.parseExpressionWithPrecedence(prec + 1)\n        if err != nil {\n            return nil, err\n        }\n        \n        left = &BinaryExpression{Operator: op, Left: left, Right: right}\n    }\n    \n    return left, nil\n}\n\nfunc (p *Parser) parseExpression() (Expression, error) {\n    return p.parseExpressionWithPrecedence(1)  // Start with lowest precedence\n}\n```\n\nThe algorithm:\n1. Parse a \"primary\" expression (literal, identifier, or parenthesized)\n2. Look at the current operator—if its precedence is >= `minPrec`, consume it and parse the right side\n3. For the right side, require *higher* precedence (`prec + 1`) to ensure left-associativity\n4. Loop until you hit an operator with lower precedence than `minPrec`\n\nThis single 20-line function replaces the four separate functions from Approach 1.\n\n---\n\n## Parentheses Override Precedence\n\n```sql\nSELECT * FROM users WHERE (active = 1 OR role = 'admin') AND level > 5\n```\n\nThe parentheses force the `OR` to be evaluated first, then the result is ANDed with `level > 5`.\n\nIn both approaches, `parsePrimaryExpression` handles parentheses by recursively calling `parseExpression()`:\n\n```go\nif p.current.Type == PUNCTUATION && p.current.Value == \"(\" {\n    p.advance()\n    expr, err := p.parseExpression()  // Full expression inside parens\n    if err != nil {\n        return nil, err\n    }\n    if err := p.expect(PUNCTUATION, \")\"); err != nil {\n        return nil, p.error(\"unclosed parenthesis\")\n    }\n    return expr, nil\n}\n```\n\nThe recursive call starts precedence over from the top—anything inside parentheses is parsed as a fresh expression.\n\n---\n\n## NULL: The Special Keyword\n\n`NULL` is not an identifier. It's a keyword representing the absence of a value.\n\n```sql\nSELECT * FROM users WHERE middle_name IS NULL\nSELECT * FROM users WHERE deleted_at IS NOT NULL\n```\n\nYour expression parser must recognize `NULL` as a literal:\n\n```go\nif p.current.Type == KEYWORD && p.current.Value == \"NULL\" {\n    p.advance()\n    return &LiteralExpression{Value: nil, Type: \"NULL\"}, nil\n}\n```\n\nNote: `NULL = NULL` does not evaluate to TRUE in SQL—it evaluates to NULL. This three-valued logic will matter when you execute queries, but for parsing, just recognize `NULL` as a valid expression.\n\n---\n\n## Error Reporting: Position Tracking\n\nWhen parsing fails, report *where*:\n\n```sql\nSELECT * FORM users\n--          ^^^^\n-- Error at line 1, column 10: unexpected token \"FORM\", expected \"FROM\"\n```\n\nYour tokenizer already attached line/column to each token. Propagate this into error messages:\n\n```go\nfunc (p *Parser) error(format string, args ...interface{}) error {\n    return ParseError{\n        Message: fmt.Sprintf(format, args...),\n        Line:    p.current.Line,\n        Column:  p.current.Column,\n    }\n}\n```\n\nFor multi-token constructs, report the **start** position:\n\n```go\nfunc (p *Parser) parseSelect() (*SelectStatement, error) {\n    startLine := p.current.Line\n    startCol := p.current.Column\n    \n    // ... parsing ...\n    \n    if err != nil {\n        return nil, ParseError{\n            Message: err.Error(),\n            Line:    startLine,\n            Column:  startCol,\n        }\n    }\n}\n```\n\n---\n\n## AST Structure Reference\n\nYour AST types should capture all the information needed for the bytecode compiler:\n\n```go\n// Statements\ntype Statement interface { isStatement() }\n\ntype SelectStatement struct {\n    Columns    []ColumnSelection\n    FromTable  string\n    Alias      string              // Optional table alias\n    Where      Expression          // Optional\n    GroupBy    []Expression        // Optional\n    Having     Expression          // Optional\n    OrderBy    []OrderByColumn     // Optional\n    Limit      *int                // Optional\n    Offset     *int                // Optional\n}\n\ntype InsertStatement struct {\n    Table    string\n    Columns  []string\n    Values   [][]Expression\n}\n\ntype CreateTableStatement struct {\n    Table       string\n    IfNotExists bool\n    Columns     []ColumnDefinition\n}\n\n// Expressions\ntype Expression interface { isExpression() }\n\ntype BinaryExpression struct {\n    Operator string        // AND, OR, =, <, >, etc.\n    Left     Expression\n    Right    Expression\n}\n\ntype UnaryExpression struct {\n    Operator string        // NOT, - (negation)\n    Operand  Expression\n}\n\ntype LiteralExpression struct {\n    Value interface{}      // string, int, float, nil\n}\n\ntype IdentifierExpression struct {\n    Name string            // Column or table name\n}\n\n// Column definitions\ntype ColumnDefinition struct {\n    Name        string\n    Type        string\n    Constraints []ColumnConstraint\n}\n\ntype ColumnConstraint interface { isConstraint() }\n\ntype PrimaryKeyConstraint struct{}\ntype NotNullConstraint struct{}\ntype UniqueConstraint struct{}\n```\n\n---\n\n## Common Pitfalls\n\n### 1. Left Recursion in Grammar\n\n**Wrong:**\n```\nexpression → expression AND expression | atom\n```\n\nThis causes infinite recursion. The parser calls `parseExpression()`, which tries to match `expression AND expression`, which calls `parseExpression()` again with the same position.\n\n**Right:**\n```\nexpression → atom (AND atom)*\n```\n\nOr use precedence climbing, which avoids left recursion entirely by iterating instead of recursing on the left side.\n\n### 2. AND Binds Tighter Than OR\n\n```sql\na OR b AND c\n```\n\n**Wrong parse:** `(a OR b) AND c`\n\n**Correct parse:** `a OR (b AND c)`\n\nSQL follows mathematical convention where AND is like multiplication (binds tight) and OR is like addition (binds loose). Your precedence table must reflect this.\n\n### 3. NULL Is Not an Identifier\n\n```sql\nSELECT NULL FROM users\n```\n\n`NULL` is a keyword, not a column name. If you try to parse it as an identifier, you'll produce a column reference instead of a null literal.\n\n**Fix**: Check for `NULL` explicitly in your primary expression parser before checking for identifiers.\n\n### 4. Parentheses Require Recursive Parsing\n\n```sql\nSELECT ((a + b) * c) FROM t\n```\n\nEach opening parenthesis starts a **new** expression parse at the top level. Don't try to handle nesting with explicit levels—recursion handles arbitrary depth naturally.\n\n---\n\n## Test Suite: What to Verify\n\n**SELECT statements:**\n```sql\nSELECT * FROM users\nSELECT id, name FROM users\nSELECT * FROM users WHERE active = 1\nSELECT * FROM users WHERE age > 18 AND status = 'active'\nSELECT * FROM users WHERE (a = 1 OR b = 2) AND c = 3\nSELECT * FROM users ORDER BY name\nSELECT * FROM users LIMIT 10\nSELECT * FROM users WHERE active = 1 ORDER BY created_at DESC LIMIT 5\n```\n\n**INSERT statements:**\n```sql\nINSERT INTO users VALUES (1, 'Alice')\nINSERT INTO users (id, name) VALUES (1, 'Alice')\nINSERT INTO logs (message, level) VALUES ('Error', 'high'), ('Warning', 'medium')\n```\n\n**CREATE TABLE statements:**\n```sql\nCREATE TABLE users (id INTEGER, name TEXT)\nCREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT NOT NULL)\nCREATE TABLE users (id INTEGER, email TEXT UNIQUE)\nCREATE TABLE \"Order Items\" (id INTEGER, qty INTEGER NOT NULL)\n```\n\n**Expression precedence:**\n```sql\n-- These should parse differently\na OR b AND c            -- a OR (b AND c)\nNOT a = b               -- NOT (a = b), not (NOT a) = b\na = b OR c = d AND e = f  -- (a = b) OR ((c = d) AND (e = f))\n```\n\n**Parentheses:**\n```sql\n(a OR b) AND c          -- Force OR first\nNOT (a AND b)           -- Negate the whole AND\n((a))                   -- Nested parens\n```\n\n**Error cases:**\n```sql\nSELECT                  -- Missing column list\nSELECT * FROM           -- Missing table name\nSELECT * FORM users     -- Misspelled keyword (token-level error, but parser should report position)\nINSERT INTO users (     -- Unclosed column list\nCREATE TABLE users (id  -- Unclosed column definition\n```\n\nAim for **15+ valid statements** and **10+ invalid statements** that produce meaningful error messages.\n\n---\n\n## Knowledge Cascade: What This Unlocks\n\nYou've just built a **parser**—the gateway to language understanding. Here's where this connects:\n\n**Immediate connections:**\n- **Bytecode compiler (next milestone)**: Your AST is the direct input. The compiler traverses the tree depth-first, emitting opcodes for each node.\n- **Error messages**: The position tracking you implemented now appears in every syntax error the database reports.\n\n**Same domain:**\n- **Query optimizers**: Every database optimizer works on ASTs. Transformations like \"push WHERE predicates down\" or \"reorder JOINs\" are tree rewrites on the structure you just learned to build.\n- **SQL dialects**: MySQL, PostgreSQL, SQLite, and SQL Server all parse into similar ASTs but with dialect-specific nodes. Understanding AST structure lets you write cross-database tools.\n\n**Cross-domain:**\n- **Spreadsheet formulas**: `=A1+B2*C3` has the same precedence challenges. Excel's formula parser uses the same precedence climbing algorithm.\n- **Linter and static analysis tools**: ESLint, pylint, and SQL linters all parse code into ASTs, then walk the tree looking for patterns. You could now build a SQL linter that detects `SELECT *` on production tables.\n- **Prepared statements**: When you run `db.prepare(\"SELECT ...\")`, the database parses once and caches the AST. Subsequent executions skip parsing. Your AST structure is what gets cached.\n- **SQL translation**: Converting MySQL's `` backtick quotes to PostgreSQL's \"double quotes\" or SQLite's [brackets] requires parsing, transforming the AST, and re-serializing. The AST is the common representation.\n\n**Forward:**\n- **With this knowledge, you could now build**: A SQL formatter/prettifier (walk the AST, pretty-print), a SQL linter that enforces style rules, a schema migration tool that parses `CREATE TABLE` and compares schemas, or a query builder that constructs ASTs programmatically instead of string concatenation.\n\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-sqlite-m3 -->\n# Milestone 3: Bytecode Compiler (VDBE)\n\n## Where We Are in the System\n\n\n![SQLite Architecture: The Complete System Map](./diagrams/diag-satellite-overview.svg)\n\n\nYour parser hands you a beautiful AST—a tree structure that captures the *meaning* of a SQL statement. Now comes a critical architectural decision: **how do you execute this tree?**\n\nThe naive approach is a **tree-walking interpreter**: recursively evaluate each AST node. For `SELECT * FROM users WHERE age > 18`, you'd walk the SELECT node, which walks the WHERE node, which walks the comparison node, which walks the identifier and literal nodes. Simple, clean, obvious.\n\nSQLite does something different. It **compiles the AST into bytecode** and executes that bytecode on a **virtual machine**—the Virtual Database Engine (VDBE). This extra compilation step is not premature optimization. It's architectural necessity.\n\n---\n\n## The Revelation: Why Bytecode, Not Tree Walking?\n\nHere's what most developers assume: \"Databases interpret SQL directly. Bytecode is overkill for a simple database—just recursively evaluate AST nodes.\"\n\nThis assumption is wrong for three reasons.\n\n### Reason 1: Caching Amortizes Compilation Cost\n\nConsider a web application that runs the same parameterized query 10,000 times per minute:\n\n```sql\nSELECT * FROM users WHERE id = ?\n```\n\nA tree-walking interpreter parses and validates the AST on *every* execution. That's 10,000 parses per minute of the identical structure.\n\nWith bytecode compilation:\n1. Parse once → AST\n2. Compile once → bytecode program\n3. Execute 10,000 times with different parameters\n\nThe bytecode program is a flat array of instructions. Caching it is trivial—store it keyed by the SQL text. SQLite's prepared statements are exactly this: cached bytecode programs waiting for parameters.\n\n### Reason 2: The VM Provides a Clean Abstraction Boundary\n\nYour database has multiple moving parts:\n- **Frontend**: Tokenizer, parser, compiler\n- **Execution**: Virtual machine\n- **Storage**: B-trees, buffer pool, WAL\n\nWith bytecode, the compiler knows nothing about B-tree internals. It emits high-level opcodes like `OpenTable`, `Column`, `Next`. The VM translates these into storage engine calls. Want to swap the storage engine? The compiler doesn't change. Want to add a new SQL feature? The storage engine doesn't change.\n\nThis decoupling is why SQLite can support multiple storage formats (rollback journal vs WAL) without rewriting the compiler.\n\n### Reason 3: Optimization Opportunities\n\nTree-walking interpreters evaluate nodes as they encounter them. Bytecode compilation enables optimizations *before* execution:\n\n- **Instruction combining**: `Column` followed by `Column` on the same row can be optimized\n- **Dead code elimination**: `WHERE 1=1` compiles to no conditional jump at all\n- **Register allocation**: Intermediate values are placed in numbered registers, enabling efficient memory access patterns\n\n{{DIAGRAM:diag-query-execution-pipeline}}\n\n---\n\n## The Tension: Compilation Time vs Execution Speed\n\nEvery design decision is a tradeoff. Bytecode compilation introduces overhead: you must traverse the AST, generate instructions, and allocate registers *before* any rows are processed.\n\nFor a query that returns one row, this overhead might be 50% of total execution time. For a query that scans a million rows, the overhead is negligible.\n\n**The constraint**: Compilation must be fast enough that one-time queries aren't noticeably slow, while the generated bytecode must be efficient enough to handle large datasets.\n\nSQLite's solution: a **simple compiler** with linear-time algorithms. No complex optimizations, just straightforward code generation. The bytecode is \"good enough\"—not optimal, but fast to produce and fast to execute.\n\n---\n\n## The Instruction Set: Your VM's Vocabulary\n\n{{DIAGRAM:diag-bytecode-instruction-set}}\n\nThe VDBE instruction set is deliberately small—about 180 opcodes in real SQLite, but you'll implement around 20-30 for this project. Each instruction has:\n\n- **Opcode**: What operation to perform\n- **P1, P2, P3**: Operands (register numbers, page numbers, column indexes)\n- **P4**: Optional string or pointer operand\n- **Comment**: Human-readable description (for EXPLAIN)\n\nHere are the core opcodes you'll implement:\n\n| Opcode | P1 | P2 | P3 | Description |\n|--------|----|----|----|----|\n| **OpenTable** | cursor# | root page | 0 | Open a B-tree cursor on table |\n| **Close** | cursor# | | | Close a cursor |\n| **Rewind** | cursor# | jump target | | Position cursor before first row; jump if empty |\n| **Column** | cursor# | column# | dest reg | Read column value into register |\n| **ResultRow** | start reg | count | | Output current result row |\n| **Next** | cursor# | jump target | | Advance cursor; jump if more rows |\n| **Halt** | | | | End program execution |\n| **MakeRecord** | start reg | count | dest reg | Serialize registers into a record |\n| **Insert** | cursor# | record reg | | Insert record at cursor position |\n| **Delete** | cursor# | | | Delete row at cursor position |\n| **Integer** | value | dest reg | | Load integer constant |\n| **String8** | | dest reg | string | Load string constant |\n| **Null** | dest reg | | | Load NULL into register |\n| **Eq/Ne/Lt/Le/Gt/Ge** | reg1 | jump target | reg2 | Compare registers; jump if condition true |\n| **Goto** | target | | | Unconditional jump |\n\n---\n\n## Three-Level View: From AST to Bytecode to Execution\n\n| Level | What Happens | Example |\n|-------|--------------|---------|\n| **Compiler** | Traverses AST, emits instructions | SELECT → OpenTable, Rewind, Column loop, Halt |\n| **Bytecode** | Flat array of instructions | `[0] OpenTable 0 2 0`, `[1] Rewind 0 5`, ... |\n| **VM** | Fetch-decode-execute cycle | Read instruction, dispatch to handler, update PC |\n\nThe compiler is a **depth-first AST walker** that emits instructions as it goes. The VM is a **simple loop** that reads and executes instructions one at a time.\n\n---\n\n## Building the Compiler: SELECT Statements\n\nConsider this SQL:\n\n```sql\nSELECT id, name FROM users WHERE age > 18\n```\n\nThe compiler must produce bytecode that:\n1. Opens a cursor on the `users` table\n2. Positions the cursor before the first row\n3. For each row: reads columns, evaluates WHERE, outputs if matched\n4. Closes the cursor and halts\n\n### Step-by-Step Compilation\n\n```go\nfunc (c *Compiler) compileSelect(stmt *SelectStatement) ([]Instruction, error) {\n    var program []Instruction\n    \n    // 1. Open cursor on the table\n    // P1=0 (cursor number), P2=2 (root page of 'users' table)\n    program = append(program, Instruction{\n        Opcode: \"OpenTable\",\n        P1:     0,  // Cursor 0\n        P2:     c.getTableRootPage(stmt.FromTable),\n        P3:     0,\n        Comment: fmt.Sprintf(\"table=%s\", stmt.FromTable),\n    })\n    \n    // 2. Rewind cursor (position before first row)\n    // P2 is the instruction to jump to if table is empty\n    rewindPC := len(program)\n    program = append(program, Instruction{\n        Opcode: \"Rewind\",\n        P1:     0,  // Cursor 0\n        P2:     0,  // Will patch this later (jump to Halt if empty)\n        Comment: \"jump to Halt if empty\",\n    })\n    \n    // 3. Compile WHERE clause (if exists)\n    // This emits comparison and conditional jump instructions\n    // If WHERE evaluates to false, jump to Next instruction\n    var whereJumpTarget int\n    if stmt.Where != nil {\n        whereStartPC := len(program)\n        c.compileExpression(program, stmt.Where, 0)  // Result in register 0\n        \n        // Conditional jump: if condition is false/NULL, skip to Next\n        program = append(program, Instruction{\n            Opcode: \"IfNot\",  // Jump if register 0 is false or NULL\n            P1:     0,        // Register with condition result\n            P2:     0,        // Will patch: jump to Next\n            Comment: \"skip row if WHERE false\",\n        })\n        whereJumpTarget = len(program) - 1\n    }\n    \n    // 4. Read columns and output row\n    // For \"SELECT id, name\", read columns into registers 1, 2\n    for i, col := range stmt.Columns {\n        colIndex := c.getColumnIndex(stmt.FromTable, col.Name)\n        program = append(program, Instruction{\n            Opcode: \"Column\",\n            P1:     0,     // Cursor 0\n            P2:     colIndex,\n            P3:     i + 1, // Destination register\n            Comment: fmt.Sprintf(\"col=%s -> r%d\", col.Name, i+1),\n        })\n    }\n    \n    // 5. Output the result row\n    program = append(program, Instruction{\n        Opcode: \"ResultRow\",\n        P1:     1,  // Start register\n        P2:     len(stmt.Columns),  // Number of registers\n        Comment: fmt.Sprintf(\"output %d columns\", len(stmt.Columns)),\n    })\n    \n    // 6. Next: advance cursor and loop back\n    nextPC := len(program)\n    program = append(program, Instruction{\n        Opcode: \"Next\",\n        P1:     0,  // Cursor 0\n        P2:     rewindPC + 1,  // Jump back to start of loop (after Rewind)\n        Comment: \"loop back to process next row\",\n    })\n    \n    // 7. Halt\n    haltPC := len(program)\n    program = append(program, Instruction{\n        Opcode: \"Halt\",\n        Comment: \"end of query\",\n    })\n    \n    // 8. Patch jump targets\n    program[rewindPC].P2 = haltPC  // Rewind jumps to Halt if empty\n    if stmt.Where != nil {\n        program[whereJumpTarget].P2 = nextPC  // WHERE false jumps to Next\n    }\n    \n    return program, nil\n}\n```\n\n### The Compiled Bytecode\n\nFor `SELECT id, name FROM users WHERE age > 18`:\n\n```\naddr  opcode      p1  p2  p3  comment\n----  ----------  --  --  --  -------\n0     OpenTable   0   2   0   table=users\n1     Rewind      0   9   0   jump to 9 if empty\n2     Column      0   2   0   col=age -> r0\n3     Integer     18  1   0   r1 = 18\n4     Gt          0   6   1   if r0>r1 goto 6\n5     Goto        0   8   0   skip to Next (row doesn't match)\n6     Column      0   0   1   col=id -> r1\n7     Column      0   1   2   col=name -> r2\n8     ResultRow   1   2   0   output 2 columns\n9     Next        0   2   0   loop back to instruction 2\n10    Halt        0   0   0   end\n```\n\n\n![Trace Example: SELECT * WHERE id > 5](./diagrams/diag-bytecode-compiled-example.svg)\n\n\nTrace through this with a 3-row table where ages are [25, 15, 30]:\n\n| Step | PC | Instruction | Action | Result |\n|------|----|-------------|--------|--------|\n| 1 | 0 | OpenTable | Open cursor 0 on users | Cursor ready |\n| 2 | 1 | Rewind | Position before row 1 | Not empty, continue |\n| 3 | 2 | Column | Read age (25) into r0 | r0=25 |\n| 4 | 3 | Integer | Load 18 into r1 | r1=18 |\n| 5 | 4 | Gt | 25 > 18? Yes | Don't jump |\n| 6 | 6 | Column | Read id into r1 | r1=1 |\n| 7 | 7 | Column | Read name into r2 | r2=\"Alice\" |\n| 8 | 8 | ResultRow | Output r1, r2 | Emit row (1, \"Alice\") |\n| 9 | 9 | Next | Advance to row 2 | More rows, jump to 2 |\n| 10 | 2 | Column | Read age (15) into r0 | r0=15 |\n| 11 | 3 | Integer | Load 18 into r1 | r1=18 |\n| 12 | 4 | Gt | 15 > 18? No | Jump to 6 |\n| 13 | 6 | Goto | Unconditional jump | Go to 8 |\n| 14 | 8 | Next | Advance to row 3 | More rows, jump to 2 |\n| 15 | 2-8 | ... | Process row 3 (age=30) | Emit row (3, \"Charlie\") |\n| 16 | 9 | Next | No more rows | Don't jump, continue |\n| 17 | 10 | Halt | End execution | Done |\n\nTwo rows emitted: (1, \"Alice\") and (3, \"Charlie\").\n\n---\n\n## Building the Compiler: INSERT Statements\n\n```sql\nINSERT INTO users (id, name, age) VALUES (4, 'Diana', 28)\n```\n\nThe compilation strategy:\n\n1. Load the VALUES into registers\n2. Create a record (serialized row) from those registers\n3. Insert the record into the table's B-tree\n4. Halt\n\n```go\nfunc (c *Compiler) compileInsert(stmt *InsertStatement) ([]Instruction, error) {\n    var program []Instruction\n    \n    // 1. Open cursor on the table\n    program = append(program, Instruction{\n        Opcode: \"OpenTable\",\n        P1:     0,  // Cursor 0\n        P2:     c.getTableRootPage(stmt.Table),\n        P3:     0,\n        Comment: fmt.Sprintf(\"table=%s\", stmt.Table),\n    })\n    \n    // 2. Load VALUES into registers\n    // For simplicity, assume single-row INSERT\n    values := stmt.Values[0]\n    for i, val := range values {\n        c.compileLiteral(program, val, i+1)  // Registers 1, 2, 3, ...\n    }\n    \n    // 3. MakeRecord: serialize registers into a record\n    program = append(program, Instruction{\n        Opcode: \"MakeRecord\",\n        P1:     1,  // Start register\n        P2:     len(values),  // Number of registers\n        P3:     0,  // Destination register (record in r0)\n        Comment: fmt.Sprintf(\"create record from %d values\", len(values)),\n    })\n    \n    // 4. Insert the record\n    program = append(program, Instruction{\n        Opcode: \"Insert\",\n        P1:     0,  // Cursor 0\n        P2:     0,  // Register with record\n        P3:     0,\n        Comment: \"insert record into table\",\n    })\n    \n    // 5. Close and Halt\n    program = append(program, Instruction{\n        Opcode: \"Close\",\n        P1:     0,\n    })\n    program = append(program, Instruction{\n        Opcode: \"Halt\",\n    })\n    \n    return program, nil\n}\n```\n\nCompiled bytecode for `INSERT INTO users (id, name, age) VALUES (4, 'Diana', 28)`:\n\n```\naddr  opcode      p1  p2  p3  p4        comment\n----  ----------  --  --  --  --------  -------\n0     OpenTable   0   2   0             table=users\n1     Integer     4   1   0             r1 = 4\n2     String8     0   2   0   Diana     r2 = \"Diana\"\n3     Integer     28  3   0             r3 = 28\n4     MakeRecord  1   3   0             record from r1-r3 -> r0\n5     Insert      0   0   0             insert r0 into cursor 0\n6     Close       0   0   0             \n7     Halt        0   0   0             \n```\n\n---\n\n## Building the Virtual Machine\n\nThe VM is beautifully simple: a fetch-decode-execute loop.\n\n\n![VDBE Execution Cycle](./diagrams/diag-vm-fetch-decode-execute.svg)\n\n\n```go\ntype VM struct {\n    Program    []Instruction\n    PC         int           // Program counter\n    Registers  []Value       // Register file (typed values)\n    Cursors    []*Cursor     // Open cursors\n    Halted     bool\n    Output     func([]Value) // Callback for ResultRow\n}\n\ntype Value struct {\n    Type  ValueType  // INTEGER, TEXT, REAL, BLOB, NULL\n    Int   int64\n    Float float64\n    Str   string\n    Bytes []byte\n}\n\nfunc (vm *VM) Run() error {\n    for !vm.Halted && vm.PC < len(vm.Program) {\n        instr := vm.Program[vm.PC]\n        if err := vm.execute(instr); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n\nfunc (vm *VM) execute(instr Instruction) error {\n    switch instr.Opcode {\n    case \"Halt\":\n        vm.Halted = true\n        \n    case \"Goto\":\n        vm.PC = instr.P2\n        return nil  // Don't increment PC\n        \n    case \"Integer\":\n        vm.Registers[instr.P2] = Value{Type: INTEGER, Int: int64(instr.P1)}\n        \n    case \"String8\":\n        vm.Registers[instr.P2] = Value{Type: TEXT, Str: instr.P4.(string)}\n        \n    case \"Null\":\n        vm.Registers[instr.P1] = Value{Type: NULL}\n        \n    case \"OpenTable\":\n        cursor := vm.storage.OpenTable(instr.P2)\n        vm.Cursors[instr.P1] = cursor\n        \n    case \"Close\":\n        vm.Cursors[instr.P1] = nil\n        \n    case \"Rewind\":\n        cursor := vm.Cursors[instr.P1]\n        if !cursor.Rewind() {\n            // Table is empty, jump to P2\n            vm.PC = instr.P2\n            return nil\n        }\n        \n    case \"Next\":\n        cursor := vm.Cursors[instr.P1]\n        if cursor.Next() {\n            vm.PC = instr.P2  // Jump back to loop start\n            return nil\n        }\n        // No more rows, continue to next instruction\n        \n    case \"Column\":\n        cursor := vm.Cursors[instr.P1]\n        value := cursor.GetColumn(instr.P2)\n        vm.Registers[instr.P3] = value\n        \n    case \"ResultRow\":\n        row := make([]Value, instr.P2)\n        for i := 0; i < instr.P2; i++ {\n            row[i] = vm.Registers[instr.P1 + i]\n        }\n        vm.Output(row)\n        \n    case \"MakeRecord\":\n        // Serialize registers [P1, P1+P2-1] into a record\n        record := vm.serializeRecord(vm.Registers[instr.P1 : instr.P1+instr.P2])\n        vm.Registers[instr.P3] = Value{Type: BLOB, Bytes: record}\n        \n    case \"Insert\":\n        cursor := vm.Cursors[instr.P1]\n        record := vm.Registers[instr.P2].Bytes\n        cursor.Insert(record)\n        \n    case \"Eq\", \"Ne\", \"Lt\", \"Le\", \"Gt\", \"Ge\":\n        left := vm.Registers[instr.P1]\n        right := vm.Registers[instr.P3]\n        if vm.compare(instr.Opcode, left, right) {\n            vm.PC = instr.P2\n            return nil\n        }\n        \n    default:\n        return fmt.Errorf(\"unknown opcode: %s\", instr.Opcode)\n    }\n    \n    vm.PC++\n    return nil\n}\n```\n\n### The Register File\n\nThe VM uses a **register-based** architecture (not stack-based). This means:\n- Instructions specify exactly which registers to read/write\n- Intermediate values persist across instructions\n- Register allocation happens at compile time\n\nFor `SELECT id, name FROM users WHERE age > 18`:\n- Register 0: Temporary (WHERE condition result, then age value)\n- Register 1: id column value\n- Register 2: name column value\n- Register 3: Literal 18 for comparison\n\nThe compiler decides which register holds what. The VM just executes.\n\n---\n\n## WHERE Clause Compilation: Conditional Jumps\n\nThe WHERE clause is where control flow gets interesting. Consider:\n\n```sql\nSELECT * FROM users WHERE age > 18 AND status = 'active'\n```\n\nThe compiler must emit:\n1. Code to evaluate `age > 18` (true/false/NULL in a register)\n2. Conditional jump to skip the row if false\n3. Code to evaluate `status = 'active'`\n4. Conditional jump to skip the row if false\n5. If we reach here, both conditions passed → output the row\n\n```go\nfunc (c *Compiler) compileWhereClause(program *[]Instruction, where Expression, skipTarget int) {\n    switch expr := where.(type) {\n    case *BinaryExpression:\n        if expr.Operator == \"AND\" {\n            // Compile left side; if false, jump to skip\n            c.compileWhereClause(program, expr.Left, skipTarget)\n            // Compile right side; if false, jump to skip\n            c.compileWhereClause(program, expr.Right, skipTarget)\n        } else if expr.Operator == \"OR\" {\n            // More complex: need a label for \"success\"\n            // If left is true, jump to success\n            // If left is false, check right\n            // If right is true, jump to success\n            // Otherwise, skip\n            // (simplified here)\n        } else {\n            // Comparison operator: =, <, >, etc.\n            c.compileExpression(program, expr.Left, 0)   // Result in r0\n            c.compileExpression(program, expr.Right, 1)  // Result in r1\n            \n            // Emit comparison with negated jump\n            // If NOT (r0 op r1), skip this row\n            *program = append(*program, Instruction{\n                Opcode: c.negateOperator(expr.Operator),  // Gt -> Le, Eq -> Ne, etc.\n                P1:     0,\n                P2:     skipTarget,\n                P3:     1,\n                Comment: fmt.Sprintf(\"skip if NOT %s\", expr.Operator),\n            })\n        }\n    }\n}\n```\n\nThe key insight: **WHERE compilation emits early-exit jumps**. Each condition that fails jumps immediately to the `Next` instruction. Only rows that pass all conditions reach `ResultRow`.\n\n---\n\n## EXPLAIN: Making Bytecode Visible\n\nThe `EXPLAIN` command is your debugging superpower. It shows exactly what bytecode the compiler generated:\n\n```sql\nEXPLAIN SELECT id FROM users WHERE age > 18\n```\n\nOutput:\n\n```\naddr  opcode      p1  p2  p3  p4\n----  ----------  --  --  --  -------\n0     OpenTable   0   2   0   \n1     Rewind      0   7   0   \n2     Column      0   2   0   \n3     Integer     18  1   0   \n4     Le          0   6   1   skip if age <= 18\n5     Column      0   0   1   \n6     ResultRow   1   1   0   \n7     Next        0   2   0   \n8     Halt        0   0   0   \n```\n\nImplementation is trivial—just print the program:\n\n```go\nfunc (c *Compiler) Explain(program []Instruction) string {\n    var buf strings.Builder\n    buf.WriteString(\"addr  opcode      p1  p2  p3  p4\\n\")\n    buf.WriteString(\"----  ----------  --  --  --  -------\\n\")\n    for i, instr := range program {\n        buf.WriteString(fmt.Sprintf(\"%-4d  %-10s  %-2d  %-2d  %-2d\", \n            i, instr.Opcode, instr.P1, instr.P2, instr.P3))\n        if instr.P4 != nil {\n            buf.WriteString(fmt.Sprintf(\"  %v\", instr.P4))\n        }\n        if instr.Comment != \"\" {\n            buf.WriteString(fmt.Sprintf(\"  ; %s\", instr.Comment))\n        }\n        buf.WriteString(\"\\n\")\n    }\n    return buf.String()\n}\n```\n\nWhen a query doesn't do what you expect, `EXPLAIN` reveals the exact execution plan. This is how database engineers debug query performance.\n\n---\n\n## Performance Target: 10,000 Rows in 100ms\n\nThe acceptance criteria state: \"Bytecode execution of `SELECT * FROM t` on a 10,000-row table completes in under 100ms.\"\n\nThis translates to **100,000 rows per second** or **10 microseconds per row**. On modern hardware, this is achievable with straightforward bytecode execution—the VM loop is tight, and row operations are simple.\n\nWhat *will* kill performance:\n- **Excessive memory allocation**: Allocating a new object per row\n- **String copies**: Copying column values unnecessarily\n- **Branch misprediction**: Irregular jump patterns\n\nWhat's fine:\n- **The fetch-decode-execute loop itself**: A few nanoseconds per instruction\n- **Cursor operations**: B-tree traversal is O(log n) for seeks, O(1) for Next\n- **Register access**: Array indexing is essentially free\n\nThe benchmark:\n\n```go\nfunc BenchmarkTableScan(b *testing.B) {\n    // Create table with 10,000 rows\n    db := createTestDatabase(10000)\n    \n    start := time.Now()\n    count := 0\n    db.Execute(\"SELECT * FROM t\", func(row []Value) {\n        count++\n    })\n    elapsed := time.Since(start)\n    \n    fmt.Printf(\"Scanned %d rows in %v (%.0f rows/sec)\\n\", \n        count, elapsed, float64(count)/elapsed.Seconds())\n}\n```\n\nIf you're not hitting 100,000 rows/sec, profile to find the bottleneck. It's usually in the storage layer (B-tree page fetches), not the VM loop.\n\n---\n\n## Common Pitfalls\n\n### 1. Missing the Halt Opcode\n\n```go\nprogram = append(program, Instruction{Opcode: \"Halt\"})\n```\n\nForget this, and the VM will run past the end of your program into garbage memory. The `PC < len(Program)` check catches this, but a proper `Halt` is cleaner.\n\n### 2. Forgetting to Patch Jump Targets\n\nJump targets often aren't known when you emit the instruction:\n\n```go\nrewindPC := len(program)\nprogram = append(program, Instruction{Opcode: \"Rewind\", P2: ???})\n// ... more code ...\nhaltPC := len(program)\nprogram = append(program, Instruction{Opcode: \"Halt\"})\n\n// NOW patch the Rewind\nprogram[rewindPC].P2 = haltPC\n```\n\nForgetting to patch means the Rewind jumps to address 0 (or garbage), causing infinite loops or crashes.\n\n### 3. Register Clobbering\n\nIf you use register 0 for the WHERE condition, then use register 0 for something else before the conditional jump, you've clobbered your condition.\n\n**Fix**: Use a consistent register allocation strategy. Simple approach: reserve low registers for temporaries, use higher registers for column values.\n\n### 4. Three-Valued Logic in Comparisons\n\n```sql\nSELECT * FROM users WHERE age > NULL\n```\n\nThis evaluates to NULL, not FALSE. The `Gt` opcode must handle NULL correctly: if either operand is NULL, the comparison result is NULL, and `IfNot` (jump if false/NULL) should skip the row.\n\n```go\nfunc (vm *VM) compare(op string, left, right Value) bool {\n    if left.Type == NULL || right.Type == NULL {\n        // NULL compared to anything is NULL (not true, not false)\n        // The IfNot opcode treats NULL as \"not true\", so it will jump\n        return false\n    }\n    // ... actual comparison ...\n}\n```\n\n---\n\n## Test Suite: What to Verify\n\n**SELECT compilation:**\n```sql\nSELECT * FROM users                    -- Full table scan\nSELECT id, name FROM users             -- Projection\nSELECT * FROM users WHERE id = 5       -- Equality filter\nSELECT * FROM users WHERE age > 18     -- Range filter\nSELECT * FROM users WHERE a = 1 AND b = 2  -- AND condition\nSELECT * FROM users ORDER BY name      -- (Later milestone)\nSELECT * FROM users LIMIT 10           -- (Later milestone)\n```\n\n**INSERT compilation:**\n```sql\nINSERT INTO users VALUES (1, 'Alice', 25)\nINSERT INTO users (id, name) VALUES (1, 'Alice')\n```\n\n**EXPLAIN output:**\n```sql\nEXPLAIN SELECT * FROM users\n-- Should show OpenTable, Rewind, Column, ResultRow, Next, Halt\n```\n\n**Execution correctness:**\n```go\n// Insert 10 rows\ndb.Execute(\"INSERT INTO users VALUES (1, 'A')\", nil)\n// ... 9 more ...\n\n// Query and verify\nvar results []Row\ndb.Execute(\"SELECT * FROM users\", func(row []Value) {\n    results = append(results, row)\n})\nassert.Equal(t, 10, len(results))\n```\n\n**Performance:**\n```go\n// 10,000 row table scan in < 100ms\ndb := createTestDatabase(10000)\nstart := time.Now()\ncount := 0\ndb.Execute(\"SELECT * FROM t\", func(row []Value) { count++ })\nassert.Less(t, time.Since(start).Milliseconds(), int64(100))\n```\n\n---\n\n## Knowledge Cascade: What This Unlocks\n\nYou've just built a **bytecode compiler and virtual machine**—the execution engine at the heart of many language runtimes. Here's where this connects:\n\n**Immediate connections:**\n- **Query planner (Milestone 8)**: The planner chooses between different bytecode programs (table scan vs index scan). The VM executes whatever it's given.\n- **Storage engine (Milestones 4-5)**: The VM's `OpenTable`, `Column`, `Next` opcodes call into the B-tree layer. The compiler doesn't know how B-trees work.\n\n**Same domain:**\n- **Query plan caching**: Your bytecode programs can be cached. Real SQLite stores prepared statements as bytecode, reusing them for repeated queries with different parameters.\n- **EXPLAIN in all databases**: Every database's `EXPLAIN` shows its internal execution plan. PostgreSQL shows a tree of plan nodes; SQLite shows bytecode. Both reveal *how* the query will execute.\n\n**Cross-domain:**\n- **Java JVM and .NET CLR**: The same bytecode-VM architecture powers enterprise applications. Java compiles to JVM bytecode; C# compiles to IL. Both are stack-based (SQLite is register-based), but the principle is identical: compile once, execute many times.\n- **JIT compilation in modern databases**: Bytecode is the intermediate representation that JIT compilers optimize. LuaJIT traces bytecode to generate machine code. V8 starts with bytecode, then hot-spots get JIT-compiled. Your bytecode is a step toward this.\n- **WebAssembly**: Compiling to a portable bytecode VM is a pattern repeated across computing. WASM is a stack-based bytecode designed for the web, but the architecture is the same: language → compiler → bytecode → VM.\n\n**Forward:**\n- **With this knowledge, you could now build**: A simple scripting language with bytecode compilation, a regular expression engine (regex compiles to bytecode for a NFA/DFA VM), or a rules engine that compiles business rules to bytecode for fast evaluation.\n\nThe bytecode VM pattern appears everywhere because it works: compilation amortizes analysis cost, bytecode is cacheable, and the VM provides a clean abstraction boundary. You've just implemented one of the most powerful patterns in systems programming.\n\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-sqlite-m4 -->\n# Milestone 4: Buffer Pool Manager\n\n## Where We Are in the System\n\n\n![SQLite Architecture: The Complete System Map](./diagrams/diag-satellite-overview.svg)\n\n\nYour bytecode VM now emits opcodes like `OpenTable`, `Column`, and `Next`. These opcodes need to read and write pages—but where do those pages live?\n\nDisk access is slow. A random read from an SSD takes 25-100 microseconds. From an HDD, 5-10 milliseconds. If every `Column` opcode triggered a disk read, your 10,000-row table scan would take seconds, not milliseconds.\n\nThe buffer pool is the critical layer between in-memory operations and disk persistence. It caches fixed-size pages in memory, manages memory pressure through eviction, and ensures that pages currently in use aren't evicted mid-operation. This is where database performance is made or lost.\n\n---\n\n## The Revelation: The OS Page Cache Is Not Enough\n\nHere's what most developers assume: \"The operating system's page cache handles this automatically. I can just `read()` and `write()` pages as needed. The OS knows how to cache file data efficiently.\"\n\nThis assumption is wrong for databases. Here's why.\n\n### Reason 1: Pinning Prevents Use-After-Free\n\nConsider a B-tree insertion that modifies a page:\n\n1. Read page 42 into memory\n2. Start modifying the page header\n3. **OS decides page 42 hasn't been accessed recently and evicts it**\n4. Your next write corrupts memory or crashes\n\nThe OS page cache doesn't know you're in the middle of a B-tree operation. It just sees \"page not recently accessed\" and evicts it. Database operations need **atomicity at the page level**—a page must stay resident from the start of an operation to its end.\n\nThe buffer pool solves this with **pinning**: a page can be marked \"in use\" with a pin count. Pinned pages are invisible to the eviction algorithm.\n\n### Reason 2: Dirty Page Tracking Enables Transactions\n\nWhen you execute `INSERT INTO users VALUES (1, 'Alice')`:\n\n1. Modify page 5 (the table's B-tree root)\n2. Modify page 12 (a leaf page)\n3. Modify page 3 (an index page)\n\nAll three pages are now **dirty**—modified in memory but not yet written to disk. The OS page cache will eventually flush them, but it doesn't guarantee *when* or in *what order*.\n\nFor ACID transactions, you need precise control:\n- **Rollback journal mode**: All dirty pages must be flushed together before the journal is deleted\n- **WAL mode**: Dirty pages must be flushed to the WAL, not the main database file\n\nThe buffer pool tracks exactly which pages are dirty and provides `FlushAll()` for transaction boundaries.\n\n### Reason 3: Database-Specific Eviction Policies\n\nOS page cache uses LRU (Least Recently Used) or variants like CLOCK. These work well for general workloads but ignore database semantics:\n\n- A B-tree root page is accessed on *every* query—it should never be evicted\n- A leaf page being scanned sequentially will be accessed once and never again—it should be evicted first\n- A page that's been modified (dirty) costs more to evict (requires a disk write)\n\nThe buffer pool can implement policies that understand these patterns: LRU with hot-page protection, or CLOCK with dirty-page penalty.\n\n\n![Buffer Pool Architecture](./diagrams/diag-buffer-pool-structure.svg)\n\n\n---\n\n## The Tension: Memory Is Finite\n\nA 1TB database contains 244 million 4KB pages. A server might have 64GB of RAM—enough for 16 million pages, or about 6.5% of the database.\n\n**The constraint**: Most of your data lives on disk. You must choose carefully which pages occupy the precious memory slots. A poor choice means unnecessary disk I/O. A good choice means the working set stays hot in memory.\n\nThe tension manifests as:\n- **Hit rate**: What fraction of page requests are satisfied from memory vs disk?\n- **Eviction overhead**: How much CPU time is spent deciding which page to evict?\n- **Write amplification**: How many dirty pages are written to disk unnecessarily?\n\nThe buffer pool must balance these competing concerns.\n\n---\n\n## Three-Level View: From VM Opcodes to Disk Blocks\n\n| Level | What Happens | Latency |\n|-------|--------------|---------|\n| **VM** | `Column` opcode requests page 42 | Expects < 1 microsecond |\n| **Buffer Pool** | Check if page 42 is cached; if not, evict something and load | 0.1-1 microsecond (hit), 25-100 microseconds (miss) |\n| **Disk I/O** | Read 4KB block from SSD/HDD into a frame | 25 microseconds (SSD), 5-10 milliseconds (HDD) |\n\nThe buffer pool's job is to make level 3 invisible as often as possible. When the hit rate is 99%, the average page access is dominated by level 2, not level 3.\n\n---\n\n## Building the Buffer Pool: Data Structures\n\nThe buffer pool manages three things:\n\n1. **Frames**: Fixed-size memory slots that hold page data\n2. **Page Table**: Maps page IDs to frames (for fast lookup)\n3. **Metadata**: For each frame, tracks pin count, dirty flag, and access time\n\n```go\ntype BufferPool struct {\n    pageSize   int           // Fixed size per page (default 4096)\n    frameCount int           // Number of frames (default 1000)\n    frames     [][]byte      // The actual page data [frameCount][pageSize]\n    \n    pageTable  map[PageID]int  // page_id -> frame_index\n    metadata   []FrameMetadata // Metadata for each frame\n    \n    diskMgr    DiskManager    // Interface for reading/writing pages\n    hits       int64          // Performance metrics\n    misses     int64\n}\n\ntype PageID struct {\n    FileID   int  // Which database file (for multi-file support)\n    PageNum  int  // Page number within the file\n}\n\ntype FrameMetadata struct {\n    PageID    PageID   // Which page is in this frame (invalid if empty)\n    PinCount  int      // Number of active users of this page\n    Dirty     bool     // Has this page been modified?\n    LastAccess time.Time // For LRU eviction\n}\n```\n\n### Initialization\n\n```go\nfunc NewBufferPool(frameCount, pageSize int, diskMgr DiskManager) *BufferPool {\n    bp := &BufferPool{\n        pageSize:   pageSize,\n        frameCount: frameCount,\n        frames:     make([][]byte, frameCount),\n        pageTable:  make(map[PageID]int),\n        metadata:   make([]FrameMetadata, frameCount),\n        diskMgr:    diskMgr,\n    }\n    \n    // Allocate all frames up front\n    for i := 0; i < frameCount; i++ {\n        bp.frames[i] = make([]byte, pageSize)\n        bp.metadata[i] = FrameMetadata{\n            PageID: PageID{FileID: -1, PageNum: -1}, // Invalid = empty frame\n        }\n    }\n    \n    return bp\n}\n```\n\nThe buffer pool allocates all memory at startup. This prevents runtime allocation overhead and makes memory usage predictable.\n\n---\n\n## FetchPage: The Core Operation\n\nWhen the VM (or B-tree layer) needs a page, it calls `FetchPage`:\n\n\n![Buffer Pool: Hit vs Miss Paths](./diagrams/diag-buffer-pool-hit-miss.svg)\n\n\n```go\nfunc (bp *BufferPool) FetchPage(pageID PageID) (*Page, error) {\n    // 1. Check if page is already in memory (hit)\n    if frameIdx, exists := bp.pageTable[pageID]; exists {\n        bp.hits++\n        bp.metadata[frameIdx].PinCount++\n        bp.metadata[frameIdx].LastAccess = time.Now()\n        return &Page{\n            Data:     bp.frames[frameIdx],\n            PageID:   pageID,\n            frameIdx: frameIdx,\n            bp:       bp,\n        }, nil\n    }\n    \n    // 2. Page not in memory (miss) - need to load it\n    bp.misses++\n    \n    // 3. Find a frame to put the page in\n    frameIdx, err := bp.findVictimFrame()\n    if err != nil {\n        return nil, err // All frames are pinned\n    }\n    \n    // 4. If the frame has a dirty page, write it back first\n    if bp.metadata[frameIdx].Dirty {\n        oldPageID := bp.metadata[frameIdx].PageID\n        if err := bp.diskMgr.WritePage(oldPageID, bp.frames[frameIdx]); err != nil {\n            return nil, err\n        }\n    }\n    \n    // 5. Remove old page from page table\n    delete(bp.pageTable, bp.metadata[frameIdx].PageID)\n    \n    // 6. Read the new page from disk\n    if err := bp.diskMgr.ReadPage(pageID, bp.frames[frameIdx]); err != nil {\n        return nil, err\n    }\n    \n    // 7. Update metadata and page table\n    bp.metadata[frameIdx] = FrameMetadata{\n        PageID:     pageID,\n        PinCount:   1,\n        Dirty:      false,\n        LastAccess: time.Now(),\n    }\n    bp.pageTable[pageID] = frameIdx\n    \n    return &Page{\n        Data:     bp.frames[frameIdx],\n        PageID:   pageID,\n        frameIdx: frameIdx,\n        bp:       bp,\n    }, nil\n}\n```\n\nThe critical path is step 1: the cache hit case is just a map lookup and a few field updates. This should take less than 100 nanoseconds.\n\n---\n\n## LRU Eviction: Finding a Victim Frame\n\nWhen all frames are occupied and a new page is requested, one must be evicted. LRU (Least Recently Used) selects the page that was accessed longest ago.\n\n\n![LRU Eviction: Data Walk Through](./diagrams/diag-lru-eviction-flow.svg)\n\n\n```go\nfunc (bp *BufferPool) findVictimFrame() (int, error) {\n    var victimIdx int = -1\n    var oldestAccess time.Time = time.Now()\n    \n    // Scan all frames for the best victim\n    for i := 0; i < bp.frameCount; i++ {\n        meta := &bp.metadata[i]\n        \n        // Skip pinned pages - they're in use\n        if meta.PinCount > 0 {\n            continue\n        }\n        \n        // Skip empty frames - we can use them directly\n        if meta.PageID.FileID == -1 {\n            return i, nil // Found an empty frame, use it immediately\n        }\n        \n        // Among unpinned pages, find the least recently used\n        if meta.LastAccess.Before(oldestAccess) {\n            oldestAccess = meta.LastAccess\n            victimIdx = i\n        }\n    }\n    \n    if victimIdx == -1 {\n        return -1, errors.New(\"all frames are pinned\")\n    }\n    \n    return victimIdx, nil\n}\n```\n\n### Why Not Real LRU?\n\nTrue LRU requires updating a data structure (like a linked list) on *every* access. This adds overhead to every `FetchPage` call.\n\nMany databases use **approximate LRU** instead:\n\n- **CLOCK algorithm**: A \"clock hand\" scans frames circularly. Each frame has a \"reference bit\" set on access. The clock hand clears bits as it passes. The first frame with a cleared bit is evicted. This approximates LRU with O(1) overhead per access.\n\n- **LRU-K**: Track the last K access times. Evict based on the K-th most recent access. This prevents a single recent access from making a page \"hot.\"\n\nFor this project, true LRU is acceptable. The overhead of `time.Now()` and comparison is negligible compared to disk I/O.\n\n---\n\n## Pin and Unpin: Protecting Active Pages\n\n```go\nfunc (bp *BufferPool) PinPage(pageID PageID) error {\n    frameIdx, exists := bp.pageTable[pageID]\n    if !exists {\n        return errors.New(\"page not in buffer pool\")\n    }\n    bp.metadata[frameIdx].PinCount++\n    return nil\n}\n\nfunc (bp *BufferPool) UnpinPage(pageID PageID, isDirty bool) error {\n    frameIdx, exists := bp.pageTable[pageID]\n    if !exists {\n        return errors.New(\"page not in buffer pool\")\n    }\n    \n    meta := &bp.metadata[frameIdx]\n    if meta.PinCount <= 0 {\n        return errors.New(\"unpin called on page with zero pin count\")\n    }\n    \n    meta.PinCount--\n    if isDirty {\n        meta.Dirty = true\n    }\n    \n    return nil\n}\n```\n\nThe pin count works like a reference count:\n\n- `FetchPage` returns a page with pin count = 1\n- The caller calls `UnpinPage` when done (often with `isDirty=true` if modified)\n- Only pages with pin count = 0 are eligible for eviction\n\n**Critical rule**: Never hold a page reference without incrementing its pin count. If you do, the page might be evicted and your reference becomes invalid—use-after-free.\n\n---\n\n## Dirty Page Tracking and FlushAll\n\n```go\nfunc (bp *BufferPool) MarkDirty(pageID PageID) {\n    frameIdx, exists := bp.pageTable[pageID]\n    if exists {\n        bp.metadata[frameIdx].Dirty = true\n    }\n}\n\nfunc (bp *BufferPool) FlushAll() error {\n    for pageID, frameIdx := range bp.pageTable {\n        if bp.metadata[frameIdx].Dirty {\n            if err := bp.diskMgr.WritePage(pageID, bp.frames[frameIdx]); err != nil {\n                return err\n            }\n            bp.metadata[frameIdx].Dirty = false\n        }\n    }\n    return nil\n}\n\nfunc (bp *BufferPool) FlushPage(pageID PageID) error {\n    frameIdx, exists := bp.pageTable[pageID]\n    if !exists {\n        return nil // Page not in memory, nothing to flush\n    }\n    \n    if bp.metadata[frameIdx].Dirty {\n        if err := bp.diskMgr.WritePage(pageID, bp.frames[frameIdx]); err != nil {\n            return err\n        }\n        bp.metadata[frameIdx].Dirty = false\n    }\n    return nil\n}\n```\n\n`FlushAll` is called at transaction boundaries:\n- Before deleting a rollback journal (commit)\n- Before a WAL checkpoint\n- At database shutdown\n\nDirty pages are only written to disk when:\n1. They're evicted (to make room for another page)\n2. `FlushAll` or `FlushPage` is explicitly called\n\nThis minimizes disk writes while ensuring durability.\n\n---\n\n## The Page Handle: Safe Access to Page Data\n\nThe `Page` struct is the handle that upper layers use:\n\n```go\ntype Page struct {\n    Data     []byte   // The actual page data\n    PageID   PageID\n    frameIdx int\n    bp       *BufferPool\n}\n\nfunc (p *Page) MarkDirty() {\n    p.bp.MarkDirty(p.PageID)\n}\n\nfunc (p *Page) Unpin(isDirty bool) {\n    p.bp.UnpinPage(p.PageID, isDirty)\n}\n\n// GetData returns a slice into the page data\n// CAUTION: This slice becomes invalid if the page is evicted!\n// Always keep the page pinned while using this data.\nfunc (p *Page) GetData() []byte {\n    return p.Data\n}\n```\n\nThe pattern for B-tree operations:\n\n```go\nfunc (btree *BTree) Insert(key, value []byte) error {\n    // 1. Fetch the target page\n    page, err := btree.bufferPool.FetchPage(btree.rootPageID)\n    if err != nil {\n        return err\n    }\n    \n    // Page is now pinned (pin count = 1)\n    \n    // 2. Modify the page\n    // ... perform insertion, may require node splits ...\n    page.MarkDirty()\n    \n    // 3. Unpin when done\n    page.Unpin(true) // true = page is dirty\n    \n    return nil\n}\n```\n\nIf the insertion requires reading multiple pages (for a split that propagates up the tree), each page is pinned before use and unpinned after.\n\n---\n\n## Hit Rate: The Performance Metric\n\n```go\nfunc (bp *BufferPool) HitRate() float64 {\n    total := bp.hits + bp.misses\n    if total == 0 {\n        return 0\n    }\n    return float64(bp.hits) / float64(total)\n}\n\nfunc (bp *BufferPool) Stats() string {\n    return fmt.Sprintf(\n        \"Buffer Pool Stats: hits=%d, misses=%d, hit_rate=%.2f%%\",\n        bp.hits, bp.misses, bp.HitRate()*100,\n    )\n}\n```\n\nA well-tuned buffer pool achieves 95%+ hit rate on typical workloads. If your hit rate is below 90%, consider:\n- Increasing the frame count (more memory)\n- Checking for sequential scans that flush the cache\n- Identifying hot pages that should never be evicted\n\n---\n\n## Performance Analysis: Where Time Goes\n\nFor a buffer pool with 1000 frames and 4KB pages:\n\n| Operation | Time | Notes |\n|-----------|------|-------|\n| Cache hit (map lookup + pin) | 50-100 ns | Just memory operations |\n| Cache miss (eviction + disk read) | 25-100 μs (SSD), 5-10 ms (HDD) | 250-100,000x slower than hit |\n| LRU scan for victim | 1-10 μs | Proportional to frame count |\n| Dirty page writeback | 25-100 μs (SSD) | Only on eviction or FlushAll |\n\n**The golden rule**: Every cache miss costs as much as 1000+ cache hits. Optimizing the hit path (cache hit) is less important than optimizing the miss rate (cache misses).\n\nA 99% hit rate means 1 in 100 page requests goes to disk. A 90% hit rate means 1 in 10. The difference is 10x more disk I/O—potentially 10x slower query execution.\n\n---\n\n## Common Pitfalls\n\n### 1. Evicting a Pinned Page\n\n```go\n// WRONG: Checking PinCount after selecting victim\nvictimIdx := bp.findVictimFrame()\nif bp.metadata[victimIdx].PinCount > 0 {\n    // Too late! You already decided to evict this page.\n}\n```\n\n**Fix**: The `findVictimFrame` function must skip pinned pages during its scan. Never evict a page with `PinCount > 0`.\n\n### 2. Forgetting to Unpin\n\n```go\npage, _ := bp.FetchPage(pageID)\n// ... use the page ...\n// BUG: Forgot to call page.Unpin()\n```\n\nIf you forget to unpin, that page stays in memory forever (or until restart). With enough forgotten unpins, all frames become pinned and the buffer pool can't load any new pages.\n\n**Fix**: Use defer immediately after fetching:\n\n```go\npage, _ := bp.FetchPage(pageID)\ndefer page.Unpin(false) // Will unpin even if panic occurs\n```\n\n### 3. Not Flushing Before Eviction\n\n```go\n// WRONG: Overwriting frame without checking dirty flag\nbp.diskMgr.ReadPage(newPageID, bp.frames[victimIdx])\n```\n\nIf the victim page was dirty, you just lost those modifications.\n\n**Fix**: Always check and write back dirty pages before reusing a frame:\n\n```go\nif bp.metadata[victimIdx].Dirty {\n    bp.diskMgr.WritePage(oldPageID, bp.frames[victimIdx])\n}\n```\n\n### 4. Buffer Pool Deadlock\n\nIf a B-tree operation pins 5 pages simultaneously, and your buffer pool has 5 frames, you've just deadlocked yourself. No frame can be evicted, but you need another frame.\n\n**Fix**: \n- Set a maximum pin limit per operation\n- Use a buffer pool large enough for your working set\n- Design B-tree operations to minimize simultaneous pins (unpin early)\n\n---\n\n## Test Suite: What to Verify\n\n**Basic operations:**\n```go\n// Initialize\nbp := NewBufferPool(100, 4096, diskMgr)\n\n// Fetch a page (miss)\npage, err := bp.FetchPage(PageID{FileID: 0, PageNum: 1})\nassert.NoError(t, err)\nassert.NotNil(t, page)\n\n// Fetch the same page again (hit)\npage2, err := bp.FetchPage(PageID{FileID: 0, PageNum: 1})\nassert.NoError(t, err)\nassert.Equal(t, page.frameIdx, page2.frameIdx) // Same frame\n\n// Check hit rate\nassert.Equal(t, 0.5, bp.HitRate()) // 1 hit, 1 miss\n```\n\n**LRU eviction:**\n```go\nbp := NewBufferPool(3, 4096, diskMgr) // Only 3 frames\n\n// Load 3 pages\nbp.FetchPage(PageID{0, 1})\nbp.FetchPage(PageID{0, 2})\nbp.FetchPage(PageID{0, 3})\n\n// Unpin all\nfor _, meta := range bp.metadata {\n    meta.PinCount = 0\n}\n\n// Access page 1 to make it recently used\nbp.FetchPage(PageID{0, 1})\n\n// Load page 4 - should evict page 2 (LRU)\nbp.FetchPage(PageID{0, 4})\n\n// Page 1 should still be in memory\n_, exists := bp.pageTable[PageID{0, 1}]\nassert.True(t, exists)\n\n// Page 2 should have been evicted\n_, exists = bp.pageTable[PageID{0, 2}]\nassert.False(t, exists)\n```\n\n**Pin prevents eviction:**\n```go\nbp := NewBufferPool(2, 4096, diskMgr)\n\n// Load and pin page 1\npage1, _ := bp.FetchPage(PageID{0, 1})\n\n// Load page 2\nbp.FetchPage(PageID{0, 2})\nbp.UnpinPage(PageID{0, 2}, false)\n\n// Try to load page 3 - should fail (page 1 is pinned)\n_, err := bp.FetchPage(PageID{0, 3})\nassert.Error(t, err) // \"all frames are pinned\"\n```\n\n**Dirty page writeback:**\n```go\n// Mark page as dirty\npage, _ := bp.FetchPage(PageID{0, 1})\npage.Data[0] = 0x42\npage.MarkDirty()\npage.Unpin(true)\n\n// Flush to disk\nbp.FlushAll()\n\n// Verify disk has the change\ndiskData, _ := diskMgr.ReadPage(PageID{0, 1})\nassert.Equal(t, byte(0x42), diskData[0])\n```\n\n---\n\n## Knowledge Cascade: What This Unlocks\n\nYou've just built a **buffer pool**—a pattern that appears wherever memory is scarce and data is large. Here's where this connects:\n\n**Immediate connections:**\n- **B-tree layer (next milestone)**: Every B-tree operation starts with `FetchPage`. The B-tree relies on the buffer pool to keep hot pages resident.\n- **Transactions (Milestone 9)**: The rollback journal and WAL both depend on dirty page tracking. You can't implement ACID without knowing which pages need to be flushed.\n\n**Same domain:**\n- **Operating system virtual memory**: The OS uses the same LRU/CLOCK algorithms for swapping pages to disk. But databases have additional constraints: pinning prevents use-after-free, and write ordering must respect transaction boundaries.\n- **Redis eviction policies**: When Redis runs out of memory, it evicts keys using LRU, LFU, or TTL. The same principle applies: a bounded cache must choose what to discard.\n- **Database checkpoint strategies**: Dirty page tracking enables efficient checkpointing. Instead of flushing the entire buffer pool, you flush only dirty pages—often a small fraction of the total.\n\n**Cross-domain:**\n- **Browser caching**: Images, scripts, and stylesheets are cached with eviction policies. A browser's image cache is a buffer pool for network resources instead of disk blocks.\n- **CDN edge caching**: Content delivery networks cache popular content at edge locations. When the cache is full, something must be evicted—the same LRU logic applies.\n- **SSD wear leveling**: Understanding page lifecycle helps reason about write amplification. Every dirty page eviction is a disk write; minimizing evictions minimizes SSD wear.\n\n**Forward:**\n- **With this knowledge, you could now build**: An in-memory cache with TTL and eviction (like memcached), a browser cache with size limits, or a CDN edge server that caches popular content.\n\nThe buffer pool is where database performance meets systems programming. Every decision—frame count, page size, eviction policy—affects throughput and latency. You've built the foundation for all storage operations.\n\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-sqlite-m5 -->\n# Milestone 5: B-tree Page Format & Table Storage\n\n## Where We Are in the System\n\n\n![SQLite Architecture: The Complete System Map](./diagrams/diag-satellite-overview.svg)\n\n\nYour bytecode VM executes opcodes like `OpenTable`, `Column`, and `Next`. Your buffer pool caches pages in memory with pin/unpin lifecycle management. Now you confront the central design challenge of any database: **how do you organize data on disk?**\n\nThe page format is the most consequential design decision in your database. It determines:\n- How many rows fit per page (affecting scan performance)\n- How fast inserts happen (affecting write throughput)\n- How efficiently space is used (affecting storage costs)\n- How complex the code becomes (affecting maintainability)\n\nEvery other component—the VM, the buffer pool, the query planner—exists to work with pages. Get this wrong, and nothing else can compensate.\n\n---\n\n## The Tension: Variable Records in Fixed Pages\n\nA SQL table contains rows of varying sizes:\n\n```sql\nCREATE TABLE users (\n    id INTEGER,        -- 4 bytes\n    name TEXT,         -- 3 bytes (\"Bob\") or 300 bytes (a very long name)\n    bio TEXT           -- 0 bytes (NULL) or 10,000 bytes (a memoir)\n);\n```\n\nYour pages are fixed at 4096 bytes. You must fit these variable-length rows into that fixed space, and you must find them again when queried.\n\nThe constraints are brutal:\n\n1. **Insertion order is not sorted order**: Rows arrive in arbitrary order. Row 1 might have rowid 1, row 2 might have rowid 100, row 3 might have rowid 5.\n\n2. **Rows change size**: An `UPDATE` that changes \"Bob\" to \"Bartholomew\" grows the row. Where does the extra space come from?\n\n3. **Deletions leave gaps**: Deleting row 5 leaves a hole. How do you track and reuse that space?\n\n4. **Page boundaries are hard**: A 4096-byte page with 3900 bytes used cannot accept a 500-byte row. But it could accept a 100-byte row.\n\n5. **Sorted access must be fast**: Even though rows are inserted in arbitrary order, `SELECT * FROM users ORDER BY id` must be efficient.\n\nThe naive approach—storing rows in sorted order within the page—requires shifting all subsequent rows on every insert. That's O(n) per insert, which becomes O(n²) for loading a table.\n\nThe solution is the **slotted page format**, which separates storage order from access order.\n\n---\n\n## The Revelation: Records Are Not Stored Sorted\n\nHere's what most developers assume: \"B-tree nodes store records in sorted order. When I insert rowid 50 between rowid 40 and rowid 60, the page shifts records to make room. Node splitting just moves half the sorted records to a new node.\"\n\nThis assumption is wrong, and understanding why reveals the elegance of real database design.\n\n### The Slotted Page Format\n\nA B-tree page has two regions that grow toward each other:\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│ Header   │ Cell Pointers        │ Free Space │ Cell Content    │\n│ (8 bytes)│ (grow →)             │            │ (grow ←)        │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n\n![B-tree Page Format: Slotted Page Layout](./diagrams/diag-page-format-layout.svg)\n\n\n- **Header**: Fixed metadata (page type, cell count, free space offset)\n- **Cell Pointer Array**: 2-byte offsets pointing to each cell, stored in **sorted order by key**\n- **Free Space**: The gap between the pointer array and cell content\n- **Cell Content Area**: The actual row data, stored in **insertion order**\n\nWhen you insert a row with rowid 50:\n\n1. **Append the cell** to the end of the cell content area (no shifting!)\n2. **Insert a pointer** in the pointer array at the correct sorted position (2 bytes, minimal shift)\n3. **Update the header** to reflect new cell count and free space\n\nThe pointer array provides sorted access. The cell content area provides append-only storage. Both goals achieved without O(n) shifting of large records.\n\n### Why This Matters for Node Splits\n\nWhen a page overflows, you split it:\n\n1. **Find the median key** (using the sorted pointer array)\n2. **Create a new page**\n3. **Move half the cells** to the new page (copying the cell content, not shifting)\n4. **Promote the separator key** to the parent\n\nBut here's the complication the naive model misses: **the parent might also overflow**.\n\nConsider a B-tree of height 3. You insert a row that causes a leaf split. The separator key is promoted to the parent. The parent is also full, so it splits too. The new separator is promoted to the root. The root splits, creating a new root.\n\n**Cascading splits can propagate from leaf to root**, increasing tree height by 1. A single insert can touch O(height) pages and allocate O(height) new pages.\n\nThis is why B-tree operations are O(log n) even though finding the right leaf is O(log n)—the split cascade adds another log factor.\n\n---\n\n## Three-Level View: From SQL Row to Disk Bytes\n\n| Level | What Happens | Size Concern |\n|-------|--------------|--------------|\n| **Row** | SQL values (INTEGER, TEXT, NULL) | Variable per column |\n| **Record** | Serialized bytes with type headers | Variable per row |\n| **Page** | Fixed 4096 bytes containing multiple records | Fixed, forces tradeoffs |\n\nThe serialization layer (row → record) must handle variable-length encoding. The page layer (records → page) must handle variable-length records in fixed space.\n\n---\n\n## Page Types: Four Flavors\n\nYour database uses four page types, distinguished by a byte in the header:\n\n{{DIAGRAM:diag-btree-vs-bptree}}\n\n| Page Type | Byte Value | Contains | Used For |\n|-----------|------------|----------|----------|\n| **Table Leaf** | 0x0D | Full records keyed by rowid | Table data |\n| **Table Internal** | 0x05 | Rowid keys + child page numbers | Table index structure |\n| **Index Leaf** | 0x0A | (indexed value, rowid) pairs | Secondary indexes |\n| **Index Internal** | 0x02 | Separator keys + child page numbers | Index structure |\n\n### Table B-tree vs Index B+tree\n\n**Table B-tree**: Stores the actual row data in leaf nodes. The key is the rowid (an auto-incrementing integer). Internal nodes store only separator keys and child pointers.\n\n**Index B+tree**: Stores only (indexed column value, rowid) pairs in leaf nodes. The row data stays in the table B-tree. Internal nodes store separator keys. Leaf nodes are linked for efficient range scans.\n\nThe distinction matters:\n- A table B-tree leaf page contains full rows (potentially large)\n- An index B+tree leaf page contains only keys + rowids (typically smaller)\n- Index leaves link together; table leaves do not (in SQLite's design)\n\n---\n\n## Page Header Format\n\nEvery page begins with a header:\n\n```go\ntype PageHeader struct {\n    PageType       uint8   // 0x02, 0x05, 0x0A, or 0x0D\n    FirstFreeblock uint16  // Offset to first freeblock (0 if none)\n    CellCount      uint16  // Number of cells on this page\n    CellContentStart uint16 // Offset to start of cell content area\n    FragmentedBytes uint8  // Number of fragmented free bytes\n    RightMostPointer uint32 // Rightmost child (internal pages only)\n}\n```\n\n**Size**: 8 bytes for leaf pages, 12 bytes for internal pages (the rightmost pointer).\n\n**Offsets**: All offsets are from the start of the page (byte 0).\n\n```go\nfunc (p *Page) Header() PageHeader {\n    return PageHeader{\n        PageType:        p.data[0],\n        FirstFreeblock:  binary.BigEndian.Uint16(p.data[1:3]),\n        CellCount:       binary.BigEndian.Uint16(p.data[3:5]),\n        CellContentStart: binary.BigEndian.Uint16(p.data[5:7]),\n        FragmentedBytes: p.data[7],\n        RightMostPointer: binary.BigEndian.Uint32(p.data[8:12]), // Internal only\n    }\n}\n\nfunc (p *Page) SetHeader(h PageHeader) {\n    p.data[0] = h.PageType\n    binary.BigEndian.PutUint16(p.data[1:3], h.FirstFreeblock)\n    binary.BigEndian.PutUint16(p.data[3:5], h.CellCount)\n    binary.BigEndian.PutUint16(p.data[5:7], h.CellContentStart)\n    p.data[7] = h.FragmentedBytes\n    if h.PageType == 0x02 || h.PageType == 0x05 { // Internal pages\n        binary.BigEndian.PutUint32(p.data[8:12], h.RightMostPointer)\n    }\n}\n```\n\n---\n\n## Cell Pointer Array\n\nImmediately after the header, the cell pointer array stores 2-byte offsets to each cell:\n\n```go\nfunc (p *Page) CellPointer(index int) uint16 {\n    offset := p.headerSize() + index*2\n    return binary.BigEndian.Uint16(p.data[offset : offset+2])\n}\n\nfunc (p *Page) SetCellPointer(index int, ptr uint16) {\n    offset := p.headerSize() + index*2\n    binary.BigEndian.PutUint16(p.data[offset:offset+2], ptr)\n}\n\nfunc (p *Page) headerSize() int {\n    if p.data[0] == 0x02 || p.data[0] == 0x05 {\n        return 12 // Internal page\n    }\n    return 8 // Leaf page\n}\n```\n\nThe pointer array is **sorted by key**. To find the cell with rowid 50:\n\n```go\nfunc (p *Page) FindCell(targetRowid int64) (int, bool) {\n    cellCount := p.CellCount()\n    \n    // Binary search through the pointer array\n    low, high := 0, cellCount-1\n    for low <= high {\n        mid := (low + high) / 2\n        cellOffset := p.CellPointer(mid)\n        rowid := p.readRowidFromCell(cellOffset)\n        \n        if rowid == targetRowid {\n            return mid, true\n        } else if rowid < targetRowid {\n            low = mid + 1\n        } else {\n            high = mid - 1\n        }\n    }\n    \n    return low, false // Insertion point, not found\n}\n```\n\nBinary search on the pointer array is O(log n) where n is the number of cells per page (typically 50-500). The actual cell data is never shifted—only 2-byte pointers move.\n\n---\n\n## Cell Content Area\n\nCells grow from the end of the page toward the beginning:\n\n```go\nfunc (p *Page) FreeSpace() int {\n    headerEnd := p.headerSize()\n    pointerArrayEnd := headerEnd + int(p.CellCount())*2\n    cellContentStart := int(p.CellContentStart())\n    \n    if cellContentStart == 0 {\n        // Page is empty, cell content starts at end of page\n        return PageSize - pointerArrayEnd\n    }\n    \n    return cellContentStart - pointerArrayEnd\n}\n\nfunc (p *Page) AllocateCell(size int) (offset int, err error) {\n    if p.FreeSpace() < size+2 { // +2 for new pointer\n        return 0, errors.New(\"insufficient space\")\n    }\n    \n    // Cell content area grows backward from end of page\n    newContentStart := int(p.CellContentStart()) - size\n    if p.CellContentStart() == 0 {\n        newContentStart = PageSize - size\n    }\n    \n    p.SetCellContentStart(uint16(newContentStart))\n    return newContentStart, nil\n}\n```\n\nWhen a cell is deleted, its space becomes a \"freeblock\" linked into a free list. The `FirstFreeblock` header field points to the first freeblock, and each freeblock contains a pointer to the next.\n\n---\n\n## Record Serialization: Variable-Length Encoding\n\nA row must be serialized into bytes before storage. The format uses **variable-length integers (varints)** to minimize space.\n\n{{DIAGRAM:diag-varint-encoding}}\n\n### Varint Format\n\nSQLite's varint encoding uses 1-9 bytes for 64-bit integers:\n\n| Value Range | Bytes | Format |\n|-------------|-------|--------|\n| 0 - 127 | 1 | `0xxxxxxx` |\n| 128 - 16383 | 2 | `10xxxxxx xxxxxxxx` |\n| 16384 - 2097151 | 3 | `110xxxxx ...` |\n| ... | ... | ... |\n| Large values | 9 | `11111111` + 8 bytes |\n\nThe high bits indicate how many continuation bytes follow.\n\n```go\nfunc ReadVarint(data []byte, offset int) (value int64, bytesRead int) {\n    b := data[offset]\n    \n    if b < 0x80 {\n        return int64(b), 1\n    }\n    \n    // Count leading 1 bits to determine length\n    var result int64\n    var length int\n    \n    if b < 0xC0 {\n        result = int64(b & 0x3F)\n        length = 2\n    } else if b < 0xE0 {\n        result = int64(b & 0x1F)\n        length = 3\n    } else if b < 0xF0 {\n        result = int64(b & 0x0F)\n        length = 4\n    } else if b < 0xF8 {\n        result = int64(b & 0x07)\n        length = 5\n    } else if b < 0xFC {\n        result = int64(b & 0x03)\n        length = 6\n    } else if b < 0xFE {\n        result = int64(b & 0x01)\n        length = 7\n    } else if b == 0xFE {\n        length = 8\n    } else {\n        length = 9\n    }\n    \n    // Read continuation bytes\n    for i := 1; i < length; i++ {\n        result = (result << 8) | int64(data[offset+i])\n    }\n    \n    return result, length\n}\n\nfunc WriteVarint(value int64) []byte {\n    if value < 0 {\n        // Handle negative: 9-byte encoding\n        result := make([]byte, 9)\n        result[0] = 0xFF\n        binary.BigEndian.PutUint64(result[1:9], uint64(value))\n        return result\n    }\n    \n    if value < 0x80 {\n        return []byte{byte(value)}\n    }\n    \n    // ... handle 2-8 byte encodings ...\n}\n```\n\n### Record Format\n\n\n![Row Record Format: Variable-Length Columns](./diagrams/diag-record-serialization.svg)\n\n\nA record has two parts:\n\n1. **Header**: Varint header size, followed by serial types for each column\n2. **Body**: The actual column values\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│ Header Size  │ Serial Type 1 │ Serial Type 2 │ ... │ Body │\n│ (varint)     │ (varint)      │ (varint)      │     │      │\n└─────────────────────────────────────────────────────────────┘\n```\n\nThe **serial type** encodes both the type and size:\n\n| Serial Type | Meaning | Size |\n|-------------|---------|------|\n| 0 | NULL | 0 bytes |\n| 1 | 8-bit signed integer | 1 byte |\n| 2 | 16-bit signed integer (big-endian) | 2 bytes |\n| 3 | 24-bit signed integer (big-endian) | 3 bytes |\n| 4 | 32-bit signed integer (big-endian) | 4 bytes |\n| 5 | 48-bit signed integer (big-endian) | 6 bytes |\n| 6 | 64-bit signed integer (big-endian) | 8 bytes |\n| 7 | IEEE 754 float (big-endian) | 8 bytes |\n| 8 | Integer 0 | 0 bytes |\n| 9 | Integer 1 | 0 bytes |\n| 10, 11 | Reserved | - |\n| N ≥ 12, even | BLOB of (N-12)/2 bytes | (N-12)/2 bytes |\n| N ≥ 13, odd | TEXT of (N-13)/2 bytes | (N-13)/2 bytes |\n\n```go\ntype SerialType int64\n\nfunc EncodeValue(value interface{}) (SerialType, []byte) {\n    switch v := value.(type) {\n    case nil:\n        return 0, nil\n    case int:\n        return encodeInt(int64(v))\n    case int64:\n        return encodeInt(v)\n    case float64:\n        return 7, encodeFloat(v)\n    case string:\n        length := len(v)\n        serialType := SerialType(length*2 + 13)\n        return serialType, []byte(v)\n    case []byte:\n        length := len(v)\n        serialType := SerialType(length*2 + 12)\n        return serialType, v\n    default:\n        panic(fmt.Sprintf(\"unsupported type: %T\", v))\n    }\n}\n\nfunc encodeInt(v int64) (SerialType, []byte) {\n    if v == 0 {\n        return 8, nil\n    }\n    if v == 1 {\n        return 9, nil\n    }\n    \n    // Choose smallest representation\n    switch {\n    case v >= -128 && v <= 127:\n        return 1, []byte{byte(v)}\n    case v >= -32768 && v <= 32767:\n        buf := make([]byte, 2)\n        binary.BigEndian.PutUint16(buf, uint16(int16(v)))\n        return 2, buf\n    // ... more cases ...\n    default:\n        buf := make([]byte, 8)\n        binary.BigEndian.PutUint64(buf, uint64(v))\n        return 6, buf\n    }\n}\n```\n\n### Full Record Serialization\n\n```go\nfunc SerializeRow(values []interface{}) []byte {\n    // First pass: calculate sizes\n    var headerSize int64 = 1 // Header size varint itself\n    var bodySize int\n    \n    serialTypes := make([]SerialType, len(values))\n    bodies := make([][]byte, len(values))\n    \n    for i, val := range values {\n        st, body := EncodeValue(val)\n        serialTypes[i] = st\n        bodies[i] = body\n        bodySize += len(body)\n        \n        // Calculate varint size for serial type\n        headerSize += int64(varintSize(int64(st)))\n    }\n    \n    // Recalculate header size including the size varint itself\n    totalHeaderSize := headerSize + int64(varintSize(headerSize))\n    \n    // Allocate buffer\n    totalSize := int(totalHeaderSize) + bodySize\n    buf := make([]byte, totalSize)\n    \n    // Write header\n    offset := writeVarint(buf, 0, totalHeaderSize)\n    for _, st := range serialTypes {\n        offset = writeVarint(buf, offset, int64(st))\n    }\n    \n    // Write body\n    for _, body := range bodies {\n        copy(buf[offset:], body)\n        offset += len(body)\n    }\n    \n    return buf\n}\n\nfunc DeserializeRow(data []byte) []interface{} {\n    // Read header size\n    headerSize, offset := ReadVarint(data, 0)\n    \n    // Read serial types\n    var serialTypes []SerialType\n    headerEnd := int(offset)\n    for headerEnd < int(headerSize) {\n        st, bytesRead := ReadVarint(data, headerEnd)\n        serialTypes = append(serialTypes, SerialType(st))\n        headerEnd += bytesRead\n    }\n    \n    // Read values\n    bodyOffset := headerEnd\n    values := make([]interface{}, len(serialTypes))\n    \n    for i, st := range serialTypes {\n        value, size := decodeValue(data, bodyOffset, st)\n        values[i] = value\n        bodyOffset += size\n    }\n    \n    return values\n}\n```\n\n---\n\n## Table B-tree Leaf Page Cells\n\nA cell in a table leaf page contains:\n\n```\n┌─────────────┬────────────────┬───────────────────┐\n│ Payload Size│ Rowid          │ Payload (record)  │\n│ (varint)    │ (varint)       │ (bytes)           │\n└─────────────┴────────────────┴───────────────────┘\n```\n\n```go\nfunc (p *Page) ReadTableCell(offset int) (rowid int64, record []byte) {\n    pos := offset\n    \n    // Read payload size\n    payloadSize, bytesRead := ReadVarint(p.data, pos)\n    pos += bytesRead\n    \n    // Read rowid\n    rowid, bytesRead = ReadVarint(p.data, pos)\n    pos += bytesRead\n    \n    // Read payload\n    record = make([]byte, payloadSize)\n    copy(record, p.data[pos:pos+int(payloadSize)])\n    \n    return rowid, record\n}\n\nfunc (p *Page) WriteTableCell(rowid int64, record []byte) (int, error) {\n    cellSize := varintSize(int64(len(record))) + varintSize(rowid) + len(record)\n    \n    // Allocate space\n    offset, err := p.AllocateCell(cellSize)\n    if err != nil {\n        return 0, err\n    }\n    \n    // Write cell\n    pos := offset\n    pos = writeVarint(p.data, pos, int64(len(record)))\n    pos = writeVarint(p.data, pos, rowid)\n    copy(p.data[pos:], record)\n    \n    return offset, nil\n}\n```\n\n---\n\n## Table B-tree Internal Page Cells\n\nInternal pages store separator keys and child pointers:\n\n```\n┌─────────────┬────────────────┬───────────────────┐\n│ Left Child  │ Rowid          │ (no payload)      │\n│ (4 bytes)   │ (varint)       │                   │\n└─────────────┴────────────────┴───────────────────┘\n```\n\nPlus the rightmost pointer in the header.\n\n```go\nfunc (p *Page) ReadInternalCell(offset int) (leftChild uint32, rowid int64) {\n    leftChild = binary.BigEndian.Uint32(p.data[offset : offset+4])\n    rowid, _ = ReadVarint(p.data, offset+4)\n    return leftChild, rowid\n}\n\nfunc (p *Page) FindChildPage(rowid int64) uint32 {\n    cellCount := p.CellCount()\n    \n    // Binary search for the right child\n    for i := 0; i < cellCount; i++ {\n        _, separatorRowid := p.ReadInternalCell(int(p.CellPointer(i)))\n        if rowid < separatorRowid {\n            leftChild, _ := p.ReadInternalCell(int(p.CellPointer(i)))\n            return leftChild\n        }\n    }\n    \n    // If greater than all separators, use rightmost pointer\n    return p.RightMostPointer()\n}\n```\n\n---\n\n## Index B+tree Page Cells\n\nIndex pages store (key, rowid) pairs:\n\n**Leaf cell**:\n```\n┌─────────────┬────────────────┬───────────────────┐\n│ Payload Size│ Payload        │ Rowid             │\n│ (varint)    │ (indexed vals) │ (varint)          │\n└─────────────┴────────────────┴───────────────────┘\n```\n\n**Internal cell**:\n```\n┌─────────────┬────────────────┬───────────────────┐\n│ Left Child  │ Payload        │ (no rowid)        │\n│ (4 bytes)   │ (separator)    │                   │\n└─────────────┴────────────────┴───────────────────┘\n```\n\nThe payload for an index is the serialized indexed column values, without the row data from the table.\n\n---\n\n## Node Splitting: The Complex Case\n\nWhen a page runs out of space, it must split:\n\n{{DIAGRAM:diag-node-split-operation}}\n\n```go\nfunc (t *BTree) SplitPage(pageID uint32) error {\n    page := t.bufferPool.FetchPage(pageID)\n    defer page.Unpin(true)\n    \n    // 1. Find median key\n    cellCount := page.CellCount()\n    medianIndex := cellCount / 2\n    \n    // 2. Create new page\n    newPageID := t.allocatePage()\n    newPage := t.bufferPool.FetchPage(newPageID)\n    defer newPage.Unpin(true)\n    \n    // Initialize new page with same type\n    newPage.SetPageType(page.PageType())\n    \n    // 3. Move cells after median to new page\n    for i := medianIndex + 1; i < cellCount; i++ {\n        cellOffset := page.CellPointer(i)\n        cellData := page.ReadCell(cellOffset)\n        newPage.InsertCell(cellData)\n    }\n    \n    // 4. Remove moved cells from old page\n    page.SetCellCount(uint16(medianIndex))\n    \n    // 5. Get the median key to promote\n    medianOffset := page.CellPointer(medianIndex)\n    medianKey := page.ReadKey(medianOffset)\n    \n    // 6. Insert separator into parent (or create new root)\n    if pageID == t.rootPageID {\n        // Splitting the root - create new root\n        t.createRootWithChildren(pageID, newPageID, medianKey)\n    } else {\n        parentID := t.findParent(pageID)\n        t.insertSeparator(parentID, medianKey, newPageID)\n    }\n    \n    return nil\n}\n```\n\n### Cascading Splits\n\nIf the parent is also full, `insertSeparator` triggers another split:\n\n```go\nfunc (t *BTree) insertSeparator(parentID uint32, key int64, rightChild uint32) error {\n    parent := t.bufferPool.FetchPage(parentID)\n    \n    // Check if parent has space\n    if parent.FreeSpace() < requiredSpace {\n        parent.Unpin(false)\n        \n        // Recursively split parent\n        t.SplitPage(parentID)\n        \n        // Retry insertion after split\n        return t.insertSeparator(parentID, key, rightChild)\n    }\n    \n    // Find insertion point and insert\n    // ...\n}\n```\n\nThe recursion can propagate to the root, at which point a new root is created and the tree height increases by 1.\n\n---\n\n## System Catalog: sqlite_master\n\nThe database needs to remember which tables exist and where their root pages are. SQLite uses a special table called `sqlite_master`:\n\n```sql\nCREATE TABLE sqlite_master (\n    type TEXT,        -- 'table', 'index', 'trigger', 'view'\n    name TEXT,        -- Object name\n    tbl_name TEXT,    -- Table name (for indexes)\n    rootpage INTEGER, -- Root page number\n    sql TEXT          -- CREATE statement\n);\n```\n\n\n![System Catalog: sqlite_master Table](./diagrams/diag-system-catalog.svg)\n\n\n```go\nfunc (db *Database) CreateTable(stmt *CreateTableStatement) error {\n    // 1. Allocate a root page for the table's B-tree\n    rootPageID := db.allocatePage()\n    \n    // 2. Initialize the page as an empty table leaf\n    rootPage := db.bufferPool.FetchPage(rootPageID)\n    rootPage.SetPageType(PageTypeTableLeaf)\n    rootPage.SetCellCount(0)\n    rootPage.SetCellContentStart(0)\n    rootPage.Unpin(true)\n    \n    // 3. Insert into sqlite_master\n    sql := serializeCreateStatement(stmt)\n    db.Execute(fmt.Sprintf(\n        \"INSERT INTO sqlite_master (type, name, tbl_name, rootpage, sql) VALUES ('table', '%s', '%s', %d, '%s')\",\n        stmt.Table, stmt.Table, rootPageID, sql,\n    ))\n    \n    return nil\n}\n\nfunc (db *Database) GetTableRootPage(tableName string) (uint32, error) {\n    var rootPage int\n    db.QueryRow(\n        \"SELECT rootpage FROM sqlite_master WHERE type='table' AND name=?\",\n        tableName,\n    ).Scan(&rootPage)\n    \n    if rootPage == 0 {\n        return 0, fmt.Errorf(\"table %s does not exist\", tableName)\n    }\n    \n    return uint32(rootPage), nil\n}\n```\n\nThe `sqlite_master` table itself has a well-known root page (page 1 in SQLite).\n\n---\n\n## Full Table Scan: Traversing the Leaves\n\nA full table scan iterates through all rows in rowid order:\n\n```go\nfunc (t *BTree) FullTableScan(callback func(rowid int64, record []byte)) {\n    // 1. Start at the root\n    pageID := t.rootPageID\n    \n    // 2. Navigate to the leftmost leaf\n    for {\n        page := t.bufferPool.FetchPage(pageID)\n        \n        if page.PageType() == PageTypeTableLeaf {\n            // Found a leaf - start scanning\n            page.Unpin(false)\n            break\n        }\n        \n        // Internal page - go to leftmost child\n        leftChild, _ := page.ReadInternalCell(int(page.CellPointer(0)))\n        page.Unpin(false)\n        pageID = leftChild\n    }\n    \n    // 3. Scan leaf pages from left to right\n    for {\n        page := t.bufferPool.FetchPage(pageID)\n        \n        // Process all cells in this leaf\n        cellCount := page.CellCount()\n        for i := 0; i < int(cellCount); i++ {\n            cellOffset := page.CellPointer(i)\n            rowid, record := page.ReadTableCell(int(cellOffset))\n            callback(rowid, record)\n        }\n        \n        // Check for next leaf (via rightmost pointer in SQLite's design)\n        // In a pure B-tree without leaf linking, we'd need to track the path\n        // and navigate to the next leaf via the parent\n        \n        nextLeaf := page.RightMostPointer()\n        page.Unpin(false)\n        \n        if nextLeaf == 0 {\n            break // No more leaves\n        }\n        \n        pageID = nextLeaf\n    }\n}\n```\n\nNote: SQLite's table B-trees don't link leaf pages together (unlike index B+trees). A full table scan must navigate via the parent nodes. For simplicity, some implementations add leaf linking.\n\n---\n\n## Endianness: Big-Endian for Portability\n\nAll multi-byte integers in the page format are stored **big-endian** (most significant byte first). This ensures the database file is portable across architectures—a database created on x86 (little-endian) can be read on ARM (could be either).\n\n```go\n// Always use big-endian for page format\nbinary.BigEndian.PutUint16(buf[0:2], value)\nbinary.BigEndian.PutUint32(buf[0:4], value)\n\n// Reading\nvalue := binary.BigEndian.Uint16(buf[0:2])\n```\n\n---\n\n## Common Pitfalls\n\n### 1. Confusing B-tree and B+tree\n\n**Wrong**: \"I'll store row data in internal nodes too, for faster lookups.\"\n\n**Right**: Table B-trees store data only in leaves. Index B+trees store (key, rowid) only in leaves. Internal nodes store only separators and pointers.\n\nStoring data in internal nodes seems efficient—why traverse to a leaf if you find the key in an internal node? But it breaks the invariant that internal node entries are separators, not data. It also reduces fan-out (fewer keys per page) and increases tree height.\n\n### 2. Forgetting Overflow Pages\n\n**Wrong**: \"A row will always fit in a page.\"\n\n**Right**: A row can exceed page size. You need overflow pages.\n\nIf a serialized row exceeds the usable page size (4096 - header), the cell stores a prefix and a pointer to an overflow page chain:\n\n```go\nconst MaxLocalPayload = 4096 - 35 // Usable space minus header and cell overhead\n\nfunc (p *Page) InsertCell(rowid int64, record []byte) error {\n    if len(record) > MaxLocalPayload {\n        // Store prefix locally, rest in overflow pages\n        prefix := record[:MaxLocalPayload]\n        overflowPageID := t.writeOverflowChain(record[MaxLocalPayload:])\n        \n        // Cell format changes to include overflow pointer\n        // ...\n    }\n    // Normal insertion\n}\n```\n\n### 3. Page Fragmentation After Deletes\n\n**Wrong**: \"Deleting a cell frees space immediately.\"\n\n**Right**: Deleted cells leave gaps. The freeblock list tracks them, but pages can become fragmented.\n\nA page with 10 cells, then 9 deletions, might have 90% free space but it's fragmented into 9 small chunks. A large row won't fit even though \"free space\" suggests it should.\n\n**Solutions**:\n- Periodic compaction (VACUUM)\n- In-page defragmentation during inserts\n- Merge underfull pages (B-tree deletion)\n\n### 4. Varint Edge Cases\n\n**Wrong**: \"Varints handle 64-bit integers, so I'll use them for everything.\"\n\n**Right**: Varints are space-efficient but slower to read/write than fixed-width integers.\n\nFor hot paths (like rowids that are accessed frequently), consider whether the space savings justify the CPU cost. SQLite uses varints throughout, but some databases use fixed-width for certain fields.\n\n### 5. Off-by-One in Page Calculations\n\nThe page is 4096 bytes, indexed 0-4095. The cell content area starts at some offset and grows downward. A common bug:\n\n```go\n// WRONG: Off by one\nnewStart := pageSize - cellSize // If cellSize=100, newStart=3996\n\n// RIGHT: The last valid index is pageSize-1\nnewStart := pageSize - cellSize // Correct, last byte is at 4095\n```\n\nActually, this is correct—but the off-by-one errors creep in when calculating free space or checking if a cell fits.\n\n---\n\n## Test Suite: What to Verify\n\n**Page header parsing:**\n```go\npage := NewPage(4096)\npage.SetPageType(PageTypeTableLeaf)\npage.SetCellCount(5)\npage.SetCellContentStart(3500)\n\nh := page.Header()\nassert.Equal(t, uint8(PageTypeTableLeaf), h.PageType)\nassert.Equal(t, uint16(5), h.CellCount)\nassert.Equal(t, uint16(3500), h.CellContentStart)\n```\n\n**Varint encoding/decoding:**\n```go\ntestCases := []int64{0, 1, 127, 128, 16383, 16384, 2097151, 1<<32 - 1, -1}\nfor _, tc := range testCases {\n    encoded := WriteVarint(tc)\n    decoded, _ := ReadVarint(encoded, 0)\n    assert.Equal(t, tc, decoded)\n}\n```\n\n**Record serialization:**\n```go\nvalues := []interface{}{int64(42), \"hello\", nil, 3.14}\nrecord := SerializeRow(values)\ndecoded := DeserializeRow(record)\n\nassert.Equal(t, int64(42), decoded[0])\nassert.Equal(t, \"hello\", decoded[1])\nassert.Nil(t, decoded[2])\nassert.Equal(t, 3.14, decoded[3])\n```\n\n**Cell insertion and retrieval:**\n```go\npage := NewPage(4096)\npage.Initialize(PageTypeTableLeaf)\n\nrecord := SerializeRow([]interface{}{int64(1), \"Alice\"})\noffset, _ := page.WriteTableCell(1, record)\npage.InsertPointer(0, offset)\n\nrowid, retrieved := page.ReadTableCell(int(offset))\nassert.Equal(t, int64(1), rowid)\nassert.Equal(t, record, retrieved)\n```\n\n**B-tree insertion with split:**\n```go\ntree := NewBTree(bufferPool, pageSize)\n\n// Insert until split is forced\nfor i := 0; i < 1000; i++ {\n    tree.Insert(int64(i), SerializeRow([]interface{}{i, fmt.Sprintf(\"user%d\", i)}))\n}\n\n// Verify all rows are retrievable\ncount := 0\ntree.Scan(func(rowid int64, record []byte) {\n    count++\n})\nassert.Equal(t, 1000, count)\n```\n\n**Full table scan:**\n```go\ntree := createPopulatedTree(100) // 100 rows\n\nvar rowids []int64\ntree.FullTableScan(func(rowid int64, record []byte) {\n    rowids = append(rowids, rowid)\n})\n\n// Rowids should be in sorted order\nfor i := 1; i < len(rowids); i++ {\n    assert.Less(t, rowids[i-1], rowids[i])\n}\n```\n\n---\n\n## Knowledge Cascade: What This Unlocks\n\nYou've just built a **page-based storage engine**—the foundation of all modern databases. Here's where this connects:\n\n**Immediate connections:**\n- **SELECT execution (Milestone 6)**: The VM's `Column` opcode deserializes values from the record format you just defined.\n- **Secondary indexes (Milestone 7)**: Index B+trees use the same page format with different cell contents.\n\n**Same domain:**\n- **LSM-trees in RocksDB/Cassandra**: The alternative to B-trees. LSM-trees buffer writes in memory, then flush to sorted files (SSTables). Reads check multiple levels. The tradeoff: B-trees optimize reads, LSM-trees optimize writes.\n- **Index-organized tables in MySQL/Oracle**: MySQL's InnoDB stores table data in the primary key B-tree, just like SQLite. This is \"clustered\" storage—the table IS the B-tree.\n- **Database page fragmentation**: Understanding free space management explains why `VACUUM` is needed. As pages fragment from inserts/deletes, space is wasted. VACUUM rewrites pages to reclaim fragmented space.\n\n**Cross-domain:**\n- **File systems (ext4, NTFS)**: Directories and extent maps use B-trees with similar page management. The free space bitmap is analogous to the freeblock list. Filesystems face the same fragmentation challenges.\n- **Variable-length encoding in protocols**: Protocol Buffers use varints identical to SQLite's. The same space/speed tradeoff appears in network protocols—varints save bandwidth but cost CPU.\n- **Browser localStorage**: Some browsers use SQLite under the hood. Your web app's localStorage might be stored in the same B-tree format you just implemented.\n\n**Forward:**\n- **With this knowledge, you could now build**: A key-value store with B-tree persistence, a document database that stores JSON records in B-tree leaves, or a time-series database that organizes timestamped records in B-tree pages.\n\nThe slotted page format, varint encoding, and split cascade are patterns repeated across database implementations. You've just learned the vocabulary that database engineers use to discuss storage—terms like \"fan-out,\" \"page utilization,\" and \"cascading split\" will now make sense when you encounter them in documentation and research papers.\n\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-sqlite-m6 -->\n# Milestone 6: SELECT Execution & DML\n\n## Where We Are in the System\n\n\n![SQLite Architecture: The Complete System Map](./diagrams/diag-satellite-overview.svg)\n\n\nYour bytecode VM executes opcodes. Your buffer pool caches pages. Your B-tree stores serialized records in a slotted page format. Now you must make these components work together to execute actual SQL statements.\n\nThis is where the rubber meets the road. A user types `SELECT name FROM users WHERE age > 21` and expects to see results. Behind that simple query lies:\n- **Deserialization**: Converting binary records back into typed values\n- **Projection**: Extracting only the requested columns\n- **Predicate evaluation**: Filtering rows based on WHERE conditions\n- **Three-valued logic**: Handling NULL correctly in every comparison\n\nAnd that's just SELECT. INSERT, UPDATE, and DELETE add their own complexities: constraint checking, B-tree modifications, and maintaining structural integrity.\n\n---\n\n## The Revelation: NULL Breaks Everything You Know\n\nHere's what most developers assume: \"NULL is like null in programming languages—it's a special value that equals itself. `NULL = NULL` is TRUE. WHERE clauses are boolean expressions that evaluate to TRUE or FALSE. Column projection is just selecting array indices.\"\n\nAll three assumptions are wrong, and understanding why is essential to building a correct database.\n\n### NULL Does Not Equal NULL\n\nIn SQL, `NULL = NULL` evaluates to **NULL**, not TRUE.\n\n```sql\nSELECT * FROM users WHERE middle_name = middle_name\n```\n\nYou might expect this to return all users. It doesn't. For a user with `middle_name = NULL`, the comparison `NULL = NULL` evaluates to NULL. The WHERE clause only keeps rows where the predicate is TRUE. NULL is not TRUE, so that row is excluded.\n\nThis isn't arbitrary—it's fundamental to SQL's design. NULL represents \"unknown value.\" If you don't know my middle name, and you don't know your middle name, can you say whether they're equal? No—you don't know. The answer is unknown. Hence: NULL.\n\nTo check for NULL, you must use `IS NULL` or `IS NOT NULL`:\n\n```sql\nSELECT * FROM users WHERE middle_name IS NULL      -- Correct\nSELECT * FROM users WHERE middle_name = NULL       -- WRONG: always returns empty\n```\n\n### Three-Valued Logic: TRUE, FALSE, and NULL\n\n{{DIAGRAM:diag-three-valued-logic}}\n\nWHERE clauses don't evaluate to TRUE or FALSE. They evaluate to TRUE, FALSE, or NULL. Only TRUE passes the filter.\n\nThe truth tables are counterintuitive:\n\n| A | B | A AND B | A OR B |\n|---|---|---------|--------|\n| TRUE | TRUE | TRUE | TRUE |\n| TRUE | FALSE | FALSE | TRUE |\n| TRUE | NULL | NULL | TRUE |\n| FALSE | TRUE | FALSE | TRUE |\n| FALSE | FALSE | FALSE | FALSE |\n| FALSE | NULL | FALSE | NULL |\n| NULL | TRUE | NULL | TRUE |\n| NULL | FALSE | FALSE | NULL |\n| NULL | NULL | NULL | NULL |\n\nThe surprising rules:\n- **NULL AND TRUE = NULL**: \"Unknown AND true\" is still unknown\n- **NULL AND FALSE = FALSE**: \"Unknown AND false\" is definitely false (one false kills the AND)\n- **NULL OR TRUE = TRUE**: \"Unknown OR true\" is definitely true (one true satisfies the OR)\n- **NULL OR FALSE = NULL**: \"Unknown OR false\" is still unknown\n\nEvery arithmetic operation involving NULL produces NULL:\n\n```sql\nNULL + 5 = NULL\nNULL * 10 = NULL\nNULL || 'text' = NULL  -- Concatenation\n```\n\nThis propagation means a single NULL column can cascade through an entire expression.\n\n### Column Projection Is Not Array Indexing\n\n\n![Column Projection: Finding the Right Field](./diagrams/diag-projection-deserialization.svg)\n\n\nIn a programming language, accessing `row[2]` is O(1)—just pointer arithmetic. In your database, records are serialized with variable-length encoding. Column 2's offset cannot be calculated without first deserializing columns 0 and 1.\n\nConsider this record:\n\n```\nHeader: [size=12] [type1=6] [type2=13+6] [type3=0]\nBody:   [8-byte int] [6-byte string] [0 bytes]\n```\n\nTo read column 2:\n1. Read header size varint\n2. Read serial type for column 0 (determines column 0's body size)\n3. Skip column 0's body\n4. Read serial type for column 1 (determines column 1's body size)\n5. Skip column 1's body\n6. Read serial type for column 2 (NULL, 0 bytes)\n7. Return NULL\n\nThis is O(n) in the number of columns before the target. For `SELECT col50 FROM table`, you must deserialize 49 columns you don't need.\n\n**Optimization**: Store column offsets in a separate array when deserializing, then use that for projection. The first access is O(n), subsequent column accesses are O(1).\n\n---\n\n## The Tension: Correctness vs Performance\n\nEvery row processed by SELECT must:\n1. Deserialize the record (O(n) in column count for naive approach)\n2. Evaluate the WHERE clause (may involve multiple column reads)\n3. Project the requested columns (may require re-reading)\n\nFor a 10,000-row table with 50 columns, a naive implementation deserializes 500,000 column values even if the query only touches 3 columns.\n\nThe tension is between:\n- **Correctness**: Three-valued logic must be implemented exactly right\n- **Performance**: Minimize deserialization work for columns not needed\n\nSQLite's approach: deserialize lazily. The `Column` opcode reads only the requested column, traversing the record to find it. This means reading column 5 is slower than reading column 0, but reading *only* column 5 is faster than deserializing all 50 columns.\n\n---\n\n## Three-Level View: From Bytecode to Deserialized Values\n\n| Level | What Happens | Example |\n|-------|--------------|---------|\n| **VM** | Executes opcodes, manages cursors and registers | `Column 0 2 r1` |\n| **Cursor** | Navigates B-tree, provides row access | `cursor.GetColumn(2)` |\n| **Record** | Deserializes variable-length fields | Parse header, skip to offset, decode value |\n\nThe VM doesn't know about record formats. It calls `cursor.GetColumn(index)` and receives a typed `Value`. The cursor handles all the parsing complexity.\n\n---\n\n## Building SELECT Execution\n\n### The Cursor Abstraction\n\nA cursor abstracts B-tree traversal:\n\n```go\ntype Cursor struct {\n    tree        *BTree\n    currentPage *Page\n    currentPageID uint32\n    cellIndex   int\n    atEnd       bool\n}\n\nfunc (c *Cursor) First() error {\n    // Navigate to leftmost leaf\n    c.currentPageID = c.tree.rootPageID\n    \n    for {\n        page := c.tree.bufferPool.FetchPage(c.currentPageID)\n        \n        if page.PageType() == PageTypeTableLeaf {\n            c.currentPage = page\n            c.cellIndex = 0\n            c.atEnd = page.CellCount() == 0\n            return nil\n        }\n        \n        // Internal page: go to leftmost child\n        leftChild, _ := page.ReadInternalCell(0)\n        c.currentPageID = leftChild\n        page.Unpin(false)\n    }\n}\n\nfunc (c *Cursor) Next() error {\n    c.cellIndex++\n    \n    if c.cellIndex >= int(c.currentPage.CellCount()) {\n        // Need to move to next leaf page\n        // In SQLite's design, this requires navigating via parent\n        // For simplicity, we'll use a right-sibling pointer approach\n        nextLeaf := c.currentPage.RightMostPointer()\n        \n        if nextLeaf == 0 {\n            c.atEnd = true\n            return nil\n        }\n        \n        c.currentPage.Unpin(false)\n        c.currentPage = c.tree.bufferPool.FetchPage(nextLeaf)\n        c.cellIndex = 0\n    }\n    \n    return nil\n}\n\nfunc (c *Cursor) GetColumn(colIndex int) (Value, error) {\n    // Read the record for current row\n    _, record := c.currentPage.ReadTableCell(int(c.currentPage.CellPointer(c.cellIndex)))\n    \n    // Deserialize the requested column\n    return DeserializeColumn(record, colIndex)\n}\n```\n\n### Column Deserialization\n\n```go\nfunc DeserializeColumn(record []byte, colIndex int) (Value, error) {\n    // Parse header to find serial types\n    headerSize, offset := ReadVarint(record, 0)\n    \n    serialTypes := make([]SerialType, 0)\n    headerEnd := int(offset)\n    \n    for headerEnd < int(headerSize) {\n        st, bytesRead := ReadVarint(record, headerEnd)\n        serialTypes = append(serialTypes, SerialType(st))\n        headerEnd += bytesRead\n    }\n    \n    if colIndex >= len(serialTypes) {\n        return Value{Type: NULL}, fmt.Errorf(\"column index %d out of range\", colIndex)\n    }\n    \n    // Skip to the target column\n    bodyOffset := headerEnd\n    for i := 0; i < colIndex; i++ {\n        bodyOffset += serialTypeSize(serialTypes[i])\n    }\n    \n    // Decode the target column\n    return decodeValue(record, bodyOffset, serialTypes[colIndex])\n}\n\nfunc serialTypeSize(st SerialType) int {\n    switch st {\n    case 0: return 0  // NULL\n    case 1: return 1  // 8-bit int\n    case 2: return 2  // 16-bit int\n    case 3: return 3  // 24-bit int\n    case 4: return 4  // 32-bit int\n    case 5: return 6  // 48-bit int\n    case 6: return 8  // 64-bit int\n    case 7: return 8  // float\n    case 8: return 0  // integer 0\n    case 9: return 0  // integer 1\n    default:\n        if st >= 12 && st%2 == 0 {\n            return int((st - 12) / 2) // BLOB\n        }\n        if st >= 13 && st%2 == 1 {\n            return int((st - 13) / 2) // TEXT\n        }\n    }\n    return 0\n}\n\nfunc decodeValue(record []byte, offset int, st SerialType) (Value, error) {\n    switch st {\n    case 0:\n        return Value{Type: NULL}, nil\n    case 1:\n        return Value{Type: INTEGER, Int: int64(int8(record[offset]))}, nil\n    case 2:\n        val := int64(int16(binary.BigEndian.Uint16(record[offset : offset+2])))\n        return Value{Type: INTEGER, Int: val}, nil\n    case 4:\n        val := int64(binary.BigEndian.Uint32(record[offset : offset+4]))\n        return Value{Type: INTEGER, Int: val}, nil\n    case 6:\n        val := int64(binary.BigEndian.Uint64(record[offset : offset+8]))\n        return Value{Type: INTEGER, Int: val}, nil\n    case 7:\n        val := math.Float64frombits(binary.BigEndian.Uint64(record[offset : offset+8]))\n        return Value{Type: REAL, Float: val}, nil\n    case 8:\n        return Value{Type: INTEGER, Int: 0}, nil\n    case 9:\n        return Value{Type: INTEGER, Int: 1}, nil\n    default:\n        if st >= 12 && st%2 == 0 {\n            // BLOB\n            size := int((st - 12) / 2)\n            return Value{Type: BLOB, Bytes: record[offset : offset+size]}, nil\n        }\n        if st >= 13 && st%2 == 1 {\n            // TEXT\n            size := int((st - 13) / 2)\n            return Value{Type: TEXT, Str: string(record[offset : offset+size])}, nil\n        }\n    }\n    return Value{Type: NULL}, fmt.Errorf(\"unknown serial type: %d\", st)\n}\n```\n\n### Expression Evaluation with Three-Valued Logic\n\n```go\ntype Value struct {\n    Type  ValueType\n    Int   int64\n    Float float64\n    Str   string\n    Bytes []byte\n}\n\ntype ValueType int\n\nconst (\n    NULL ValueType = iota\n    INTEGER\n    REAL\n    TEXT\n    BLOB\n)\n\nfunc (v Value) IsNull() bool {\n    return v.Type == NULL\n}\n\nfunc (v Value) IsTruthy() bool {\n    // For WHERE clause filtering\n    // Only TRUE is truthy; FALSE and NULL are not\n    switch v.Type {\n    case NULL:\n        return false\n    case INTEGER:\n        return v.Int != 0\n    case REAL:\n        return v.Float != 0\n    default:\n        return false\n    }\n}\n\nfunc EvaluateComparison(op string, left, right Value) Value {\n    // Three-valued logic: NULL compared to anything is NULL\n    if left.IsNull() || right.IsNull() {\n        return Value{Type: NULL}\n    }\n    \n    // Promote types for comparison\n    if left.Type == REAL || right.Type == REAL {\n        leftFloat := toFloat(left)\n        rightFloat := toFloat(right)\n        \n        switch op {\n        case \"=\":\n            return boolToValue(leftFloat == rightFloat)\n        case \"<>\":\n            return boolToValue(leftFloat != rightFloat)\n        case \"<\":\n            return boolToValue(leftFloat < rightFloat)\n        case \"<=\":\n            return boolToValue(leftFloat <= rightFloat)\n        case \">\":\n            return boolToValue(leftFloat > rightFloat)\n        case \">=\":\n            return boolToValue(leftFloat >= rightFloat)\n        }\n    }\n    \n    // Integer comparison\n    switch op {\n    case \"=\":\n        return boolToValue(left.Int == right.Int)\n    case \"<>\":\n        return boolToValue(left.Int != right.Int)\n    case \"<\":\n        return boolToValue(left.Int < right.Int)\n    case \"<=\":\n        return boolToValue(left.Int <= right.Int)\n    case \">\":\n        return boolToValue(left.Int > right.Int)\n    case \">=\":\n        return boolToValue(left.Int >= right.Int)\n    }\n    \n    return Value{Type: NULL}\n}\n\nfunc EvaluateAnd(left, right Value) Value {\n    // NULL AND FALSE = FALSE (one false kills it)\n    if isDefinitelyFalse(left) || isDefinitelyFalse(right) {\n        return Value{Type: INTEGER, Int: 0}\n    }\n    \n    // NULL AND TRUE = NULL\n    // NULL AND NULL = NULL\n    if left.IsNull() || right.IsNull() {\n        return Value{Type: NULL}\n    }\n    \n    // TRUE AND TRUE = TRUE\n    return Value{Type: INTEGER, Int: 1}\n}\n\nfunc EvaluateOr(left, right Value) Value {\n    // NULL OR TRUE = TRUE (one true satisfies it)\n    if isDefinitelyTrue(left) || isDefinitelyTrue(right) {\n        return Value{Type: INTEGER, Int: 1}\n    }\n    \n    // NULL OR FALSE = NULL\n    // NULL OR NULL = NULL\n    if left.IsNull() || right.IsNull() {\n        return Value{Type: NULL}\n    }\n    \n    // FALSE OR FALSE = FALSE\n    return Value{Type: INTEGER, Int: 0}\n}\n\nfunc EvaluateNot(operand Value) Value {\n    if operand.IsNull() {\n        return Value{Type: NULL}\n    }\n    return boolToValue(!operand.IsTruthy())\n}\n\nfunc isDefinitelyFalse(v Value) bool {\n    return (v.Type == INTEGER && v.Int == 0) || (v.Type == REAL && v.Float == 0)\n}\n\nfunc isDefinitelyTrue(v Value) bool {\n    return (v.Type == INTEGER && v.Int != 0) || (v.Type == REAL && v.Float != 0)\n}\n\nfunc boolToValue(b bool) Value {\n    if b {\n        return Value{Type: INTEGER, Int: 1}\n    }\n    return Value{Type: INTEGER, Int: 0}\n}\n```\n\n### WHERE Clause Evaluation in the VM\n\nThe VM's comparison opcodes (`Eq`, `Ne`, `Lt`, `Le`, `Gt`, `Ge`) must handle three-valued logic:\n\n```go\nfunc (vm *VM) executeComparison(instr Instruction) error {\n    left := vm.Registers[instr.P1]\n    right := vm.Registers[instr.P3]\n    \n    result := EvaluateComparison(instr.Opcode, left, right)\n    \n    // Jump only if result is TRUE\n    // If result is NULL or FALSE, continue to next instruction\n    if result.IsTruthy() {\n        vm.PC = instr.P2\n        return nil\n    }\n    \n    vm.PC++\n    return nil\n}\n```\n\nFor conditional jumps based on general expressions (not just comparisons):\n\n```go\ncase \"IfTrue\":  // Jump if register is TRUE (not FALSE, not NULL)\n    if vm.Registers[instr.P1].IsTruthy() {\n        vm.PC = instr.P2\n        return nil\n    }\n    vm.PC++\n\ncase \"IfNot\":  // Jump if register is FALSE or NULL\n    if !vm.Registers[instr.P1].IsTruthy() {\n        vm.PC = instr.P2\n        return nil\n    }\n    vm.PC++\n\ncase \"IfNull\":  // Jump if register is NULL\n    if vm.Registers[instr.P1].IsNull() {\n        vm.PC = instr.P2\n        return nil\n    }\n    vm.PC++\n```\n\n---\n\n## Building INSERT Execution\n\nINSERT is conceptually simpler than SELECT: serialize the values into a record, insert into the B-tree.\n\n```go\nfunc (vm *VM) executeInsert(instr Instruction) error {\n    cursor := vm.Cursors[instr.P1]\n    recordReg := instr.P2\n    \n    record := vm.Registers[recordReg].Bytes\n    \n    // Insert into B-tree\n    return cursor.tree.Insert(record)\n}\n```\n\n### Constraint Checking: NOT NULL\n\nBefore inserting, check constraints:\n\n```go\nfunc (db *Database) InsertRow(table string, values []interface{}) error {\n    // Get table schema\n    schema := db.GetTableSchema(table)\n    \n    // Check NOT NULL constraints\n    for i, col := range schema.Columns {\n        if col.NotNull && values[i] == nil {\n            return fmt.Errorf(\"NOT NULL constraint failed: %s.%s\", table, col.Name)\n        }\n    }\n    \n    // Serialize and insert\n    record := SerializeRow(values)\n    tree := db.GetTableTree(table)\n    return tree.Insert(record)\n}\n```\n\nThe constraint check happens in the compiler or execution layer, not the B-tree. The B-tree just stores bytes—it doesn't know about constraints.\n\n---\n\n## Building UPDATE Execution\n\nUPDATE is a delete followed by an insert at the same rowid:\n\n```go\nfunc (db *Database) UpdateRows(table string, updates map[string]interface{}, where Expression) (int, error) {\n    tree := db.GetTableTree(table)\n    schema := db.GetTableSchema(table)\n    \n    var updatedCount int\n    \n    // Scan all rows\n    cursor := tree.NewCursor()\n    cursor.First()\n    \n    for !cursor.AtEnd() {\n        rowid, record := cursor.Current()\n        values := DeserializeRow(record)\n        \n        // Evaluate WHERE clause\n        rowMap := valuesToMap(schema, values)\n        cond := EvaluateExpression(where, rowMap)\n        \n        if cond.IsTruthy() {\n            // Apply updates\n            newValues := make([]interface{}, len(values))\n            copy(newValues, values)\n            \n            for colName, newVal := range updates {\n                colIndex := schema.ColumnIndex(colName)\n                \n                // Check NOT NULL constraint\n                if schema.Columns[colIndex].NotNull && newVal == nil {\n                    return 0, fmt.Errorf(\"NOT NULL constraint failed: %s.%s\", table, colName)\n                }\n                \n                newValues[colIndex] = newVal\n            }\n            \n            // Delete old row and insert new (same rowid)\n            cursor.Delete()\n            newRecord := SerializeRow(newValues)\n            tree.InsertAtRowid(rowid, newRecord)\n            \n            updatedCount++\n        }\n        \n        cursor.Next()\n    }\n    \n    return updatedCount, nil\n}\n```\n\n**Important**: UPDATE cannot change the rowid (primary key). Changing the rowid would require a delete at the old position and insert at the new position—essentially a different operation.\n\n---\n\n## Building DELETE Execution\n\nDELETE removes rows matching the WHERE clause:\n\n```go\nfunc (db *Database) DeleteRows(table string, where Expression) (int, error) {\n    tree := db.GetTableTree(table)\n    schema := db.GetTableSchema(table)\n    \n    var deletedCount int\n    var toDelete []int64  // Collect rowids to delete\n    \n    // First pass: collect matching rowids\n    cursor := tree.NewCursor()\n    cursor.First()\n    \n    for !cursor.AtEnd() {\n        rowid, record := cursor.Current()\n        values := DeserializeRow(record)\n        \n        rowMap := valuesToMap(schema, values)\n        cond := EvaluateExpression(where, rowMap)\n        \n        if cond.IsTruthy() {\n            toDelete = append(toDelete, rowid)\n        }\n        \n        cursor.Next()\n    }\n    \n    // Second pass: delete collected rows\n    // (Can't delete while iterating without corrupting cursor state)\n    for _, rowid := range toDelete {\n        tree.Delete(rowid)\n        deletedCount++\n    }\n    \n    return deletedCount, nil\n}\n```\n\n**Two-pass approach**: You cannot delete while iterating—the cursor state becomes invalid. Collect rowids first, then delete.\n\n### B-tree Deletion and Rebalancing\n\nDeleting a row from a B-tree leaf can leave the page underfull. SQLite's approach: mark the cell as deleted but don't immediately rebalance. Rebalancing (merging underfull pages) happens during `VACUUM` or opportunistically.\n\nFor simplicity, your initial implementation can skip rebalancing. Just remove the cell and update the page. This leaves pages underfull but doesn't corrupt the tree.\n\n---\n\n## Table Existence Checking\n\nBefore any operation, verify the table exists:\n\n```go\nfunc (db *Database) GetTableTree(tableName string) (*BTree, error) {\n    rootPage, err := db.catalog.GetTableRootPage(tableName)\n    if err != nil {\n        return nil, fmt.Errorf(\"no such table: %s\", tableName)\n    }\n    \n    return db.btrees[tableName], nil\n}\n```\n\nThe error message must include the table name:\n\n```sql\nSELECT * FROM nonexistent;\n-- Error: no such table: nonexistent\n```\n\n---\n\n## Common Pitfalls\n\n### 1. NULL = NULL Is TRUE (Wrong!)\n\n```go\n// WRONG\nif left.Value == right.Value {\n    return TRUE\n}\n\n// RIGHT\nif left.IsNull() || right.IsNull() {\n    return NULL\n}\nif left.Value == right.Value {\n    return TRUE\n}\n```\n\nEvery comparison must check for NULL first.\n\n### 2. WHERE NULL Is Falsy (Misleading!)\n\n```sql\nSELECT * FROM users WHERE NULL\n```\n\nThis returns zero rows—not because NULL is \"false,\" but because NULL is \"not true.\" The distinction matters for understanding:\n\n```sql\nSELECT * FROM users WHERE NOT (NULL)\n```\n\n`NOT (NULL)` is NULL. This also returns zero rows. There is no way to make a NULL predicate return rows.\n\n### 3. Modifying a Cursor During Iteration\n\n```go\n// WRONG: Delete during iteration\nfor !cursor.AtEnd() {\n    if matches(cursor) {\n        tree.Delete(cursor.rowid)  // Cursor state corrupted!\n    }\n    cursor.Next()\n}\n\n// RIGHT: Collect then delete\nvar toDelete []int64\nfor !cursor.AtEnd() {\n    if matches(cursor) {\n        toDelete = append(toDelete, cursor.rowid)\n    }\n    cursor.Next()\n}\nfor _, rowid := range toDelete {\n    tree.Delete(rowid)\n}\n```\n\n### 4. Column Index Off-by-One\n\nColumn indices in your schema might be 0-based, but SQL is 1-based in some contexts. Ensure consistency:\n\n```go\n// Schema column index\ncolIndex := schema.ColumnIndex(\"name\")  // Returns 0 for first column\n\n// This matches the record format (also 0-based)\nvalue := DeserializeColumn(record, colIndex)\n```\n\n### 5. UPDATE Changing Rowid\n\n```sql\nUPDATE users SET id = 999 WHERE id = 1\n```\n\nIf `id` is the rowid (INTEGER PRIMARY KEY), this is not a simple UPDATE. The row must be deleted from position 1 and inserted at position 999. Your B-tree must support this, or you must reject such updates.\n\n---\n\n## Test Suite: What to Verify\n\n**SELECT with projection:**\n```sql\nCREATE TABLE users (id INTEGER, name TEXT, age INTEGER);\nINSERT INTO users VALUES (1, 'Alice', 30);\nINSERT INTO users VALUES (2, 'Bob', 25);\n\nSELECT * FROM users;\n-- Expected: (1, 'Alice', 30), (2, 'Bob', 25)\n\nSELECT name, age FROM users;\n-- Expected: ('Alice', 30), ('Bob', 25)\n\nSELECT id FROM users WHERE age > 26;\n-- Expected: (1,)\n```\n\n**Three-valued logic:**\n```sql\nCREATE TABLE test (a INTEGER, b INTEGER);\nINSERT INTO test VALUES (1, NULL);\nINSERT INTO test VALUES (NULL, 1);\nINSERT INTO test VALUES (NULL, NULL);\nINSERT INTO test VALUES (1, 2);\n\nSELECT * FROM test WHERE a = b;\n-- Expected: Only (1, 2) - NULL = NULL is not TRUE\n\nSELECT * FROM test WHERE a IS NULL;\n-- Expected: (NULL, 1), (NULL, NULL)\n\nSELECT * FROM test WHERE a = 1 OR b = 1;\n-- Expected: (1, NULL), (NULL, 1), (1, 2)\n-- NULL OR TRUE = TRUE, TRUE OR NULL = TRUE\n\nSELECT * FROM test WHERE a = 1 AND b = 1;\n-- Expected: (empty)\n-- TRUE AND NULL = NULL, NULL AND TRUE = NULL\n```\n\n**INSERT and verification:**\n```sql\nCREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT NOT NULL);\nINSERT INTO users VALUES (1, 'Alice');\nSELECT * FROM users;\n-- Expected: (1, 'Alice')\n\nINSERT INTO users VALUES (NULL, 'Bob');\n-- If id is INTEGER PRIMARY KEY, NULL means auto-increment\n-- Expected: (2, 'Bob')\n\nINSERT INTO users VALUES (3, NULL);\n-- Expected: Error - NOT NULL constraint failed: users.name\n```\n\n**UPDATE:**\n```sql\nUPDATE users SET name = 'Alicia' WHERE id = 1;\nSELECT name FROM users WHERE id = 1;\n-- Expected: 'Alicia'\n\nUPDATE users SET name = NULL WHERE id = 2;\n-- Expected: Error - NOT NULL constraint failed: users.name\n```\n\n**DELETE:**\n```sql\nDELETE FROM users WHERE id = 1;\nSELECT * FROM users WHERE id = 1;\n-- Expected: (empty)\n\nDELETE FROM users;\nSELECT * FROM users;\n-- Expected: (empty)\n```\n\n**Table existence:**\n```sql\nSELECT * FROM nonexistent;\n-- Expected: Error - no such table: nonexistent\n\nINSERT INTO nonexistent VALUES (1);\n-- Expected: Error - no such table: nonexistent\n```\n\n---\n\n## Knowledge Cascade: What This Unlocks\n\nYou've just implemented **data manipulation through a virtual machine**—the execution layer that makes SQL useful. Here's where this connects:\n\n**Immediate connections:**\n- **Secondary indexes (next milestone)**: The same cursor abstraction and deserialization logic applies to index scans. The difference is what the record contains.\n- **Query planner (Milestone 8)**: The planner chooses between table scans and index scans based on estimated cost. You now have both execution paths.\n\n**Same domain:**\n- **Prepared statements in production databases**: Your bytecode VM can cache compiled programs. A prepared statement is just a bytecode program waiting for parameters. This is why prepared statements are faster for repeated queries.\n- **ORM query execution**: When you call `User.where(age: 18..65)` in Rails or `User.filter(age >= 18)` in SQLAlchemy, the ORM generates SQL that your execution engine processes. Understanding execution helps debug ORM performance issues.\n- **Trigger execution**: Triggers are SQL statements that execute on INSERT/UPDATE/DELETE. Your execution engine is what runs them.\n\n**Cross-domain:**\n- **Optional types in programming languages**: Rust's `Option<T>`, Haskell's `Maybe a`, and Java's `Optional<T>` all encode the same concept as SQL NULL—a value that may or may not exist. The difference is that SQL NULL propagates through operations (NULL + 5 = NULL), while `Option` requires explicit handling.\n- **Data pipeline filtering in ETL systems**: Apache Spark, dbt, and other data tools face the same NULL propagation challenges. A filter like `WHERE amount > 100` in Spark SQL behaves identically to your implementation.\n- **CSV/JSON parsing**: Variable-length record handling isn't unique to databases. A CSV parser that reads \"id,name,bio\\n1,Alice,\" must handle the empty bio field correctly. The same serial type / body offset pattern applies.\n- **Constraint checking in ORMs**: Rails validations like `validates :name, presence: true` implement the same logic as your NOT NULL constraint. The difference is enforcement location: database vs application layer.\n\n**Forward:**\n- **With this knowledge, you could now build**: A query result cache that stores (SQL text, parameters) → (result rows), invalidating on DML to referenced tables; a read replica that executes SELECT queries against a copy of the database; or a change data capture (CDC) system that logs every INSERT/UPDATE/DELETE for downstream consumers.\n\nThe combination of bytecode execution, cursor-based iteration, and three-valued logic is the foundation of SQL query processing. Every database—from SQLite to PostgreSQL to distributed systems like CockroachDB—implements these same patterns.\n\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-sqlite-m7 -->\n# Milestone 7: Secondary Indexes\n\n## Where We Are in the System\n\n\n![SQLite Architecture: The Complete System Map](./diagrams/diag-satellite-overview.svg)\n\n\nYour database can now execute SELECT, INSERT, UPDATE, and DELETE through the bytecode VM. The B-tree storage engine organizes rows by rowid, enabling efficient full table scans and point lookups. But there's a glaring performance gap.\n\nConsider this query:\n\n```sql\nSELECT * FROM users WHERE email = 'alice@example.com'\n```\n\nYour current implementation performs a **full table scan**: read every row, deserialize the email column, compare to the target. For a table with 1 million users, this reads potentially thousands of pages. Yet the query returns exactly one row.\n\nThe email column is unique—there's only one matching row. A full scan wastes 999,999 comparisons. What you need is a structure that maps email values directly to their rowids, enabling O(log n) lookup instead of O(n) scan.\n\nThis is the purpose of a **secondary index**: a separate B+tree that stores (column value → rowid) pairs, pointing into the main table B-tree. Create an index on email, and the query becomes: find 'alice@example.com' in the index (O(log n)), get the rowid, fetch that single row from the table (O(log n)). Two log-n operations instead of a linear scan.\n\nBut indexes are not free. This milestone reveals why.\n\n---\n\n## The Revelation: Indexes Are Not Automatic Magic\n\nHere's what most developers assume: \"Indexes are just sorted copies of table data. Once I create an index, queries automatically use it. Adding indexes always improves performance.\"\n\nAll three assumptions are wrong.\n\n### Indexes Store Pointers, Not Data\n\nA secondary index does **not** store a copy of the row. It stores a (column value, rowid) pair. The actual row data lives only in the table B-tree.\n\n\n![Index Lookup: The Double Lookup Pattern](./diagrams/diag-index-double-lookup.svg)\n\n\nConsider:\n\n```sql\nCREATE INDEX idx_email ON users(email);\nSELECT name, age FROM users WHERE email = 'alice@example.com';\n```\n\nExecution requires a **double lookup**:\n\n1. **Index lookup**: Search the email index for 'alice@example.com' → find rowid 42\n2. **Table lookup**: Search the table B-tree for rowid 42 → fetch the full row\n3. **Projection**: Extract name and age from the row\n\nThe index gives you the rowid. You must still fetch the row. This is why indexes on columns you never query (like a secret_hash column used only for authentication) are less useful—they require the double lookup, while querying the secret_hash column directly would be a single lookup.\n\n### Query Planner Decides, Not the Index\n\nCreating an index does not guarantee its use. The query planner must **decide** whether the index helps or hurts.\n\nFor `SELECT * FROM users WHERE age > 18` on a table where 95% of users are adults:\n\n- **Table scan**: Read 1000 pages, filter in memory\n- **Index scan**: Read index pages to get 950,000 rowids, then perform 950,000 table lookups (one per matching row)\n\nThe index scan is **slower**. Each rowid lookup is a separate B-tree traversal. The planner must estimate: how many rows match the predicate? If it's a large fraction, a table scan is faster. If it's a small fraction, the index wins.\n\nThis is **selectivity**: the fraction of rows a predicate matches. Low selectivity (0.1% match) → index helps. High selectivity (90% match) → index hurts.\n\n\n![Selectivity: When Indexes Help vs Hurt](./diagrams/diag-selectivity-visualization.svg)\n\n\n### Every Write Maintains Every Index\n\nWhen you execute:\n\n```sql\nINSERT INTO users (id, name, email, age) VALUES (100, 'Charlie', 'charlie@example.com', 35);\n```\n\nThe database must:\n\n1. Insert the row into the table B-tree\n2. Insert (email='charlie@example.com', rowid=100) into the email index\n3. Insert (age=35, rowid=100) into the age index (if it exists)\n4. Insert (name='Charlie', rowid=100) into the name index (if it exists)\n\n**Every index adds overhead to every write.** A table with 10 indexes has 10x the write cost of a table with no indexes. This is why production databases carefully limit the number of indexes—each one is a tax on INSERT, UPDATE, and DELETE.\n\n\n![Index Maintenance on INSERT](./diagrams/diag-index-maintenance.svg)\n\n\n---\n\n## The Tension: Read Performance vs Write Cost\n\nThe fundamental tension of indexing is the tradeoff between query speed and write overhead:\n\n| Metric | No Indexes | Many Indexes |\n|--------|------------|--------------|\n| SELECT speed | Slow (full scans) | Fast (direct lookups) |\n| INSERT speed | Fast (one B-tree update) | Slow (many B-tree updates) |\n| UPDATE speed | Fast (one B-tree update) | Slow (update indexed columns) |\n| DELETE speed | Fast (one B-tree update) | Slow (remove from all indexes) |\n| Storage | Minimal | Indexes can exceed table size |\n\n**The constraint**: You cannot optimize for both reads and writes simultaneously. Every index is a bet that the read performance gain outweighs the write cost over the workload's lifetime.\n\nThis tension manifests in real systems:\n- **OLTP (Online Transaction Processing)**: Many writes, few reads per row → fewer indexes\n- **OLAP (Online Analytical Processing)**: Few writes, many reads → many indexes\n\n---\n\n## Three-Level View: From Index Creation to Query Execution\n\n| Level | What Happens | Example |\n|-------|--------------|---------|\n| **DDL** | CREATE INDEX builds a new B+tree from existing table data | Scan table, insert (col, rowid) into new index |\n| **DML** | Every INSERT/UPDATE/DELETE updates all affected indexes | Insert row, then insert into each index |\n| **Query** | Planner chooses index scan vs table scan, VM executes | Seek index, get rowids, fetch from table |\n\nThe index is a separate data structure with its own B-tree, managed independently from the table B-tree but synchronized on every write.\n\n---\n\n## Building CREATE INDEX\n\n### Index Structure: B+tree with (Value, Rowid) Keys\n\nAn index B+tree stores entries in leaf pages with this format:\n\n```\n┌─────────────────┬────────────────┬───────────────────┐\n│ Payload Size    │ Indexed Value  │ Rowid             │\n│ (varint)        │ (serialized)   │ (varint)          │\n└─────────────────┴────────────────┴───────────────────┘\n```\n\nThe key for ordering is the **composite** of (indexed value, rowid). This ensures:\n- Entries are sorted by the indexed value first\n- Duplicate values are sorted by rowid (important for non-unique indexes)\n- The rowid makes every entry unique even if the indexed value isn't\n\n```go\ntype Index struct {\n    name       string\n    tableName  string\n    columnName string\n    rootPageID uint32\n    isUnique   bool\n    bufferPool *BufferPool\n}\n\nfunc (idx *Index) SerializeEntry(value interface{}, rowid int64) []byte {\n    // Serialize the indexed value\n    serialType, valueBytes := EncodeValue(value)\n    \n    // Calculate total size\n    valueSize := len(valueBytes)\n    rowidSize := varintSize(rowid)\n    totalSize := valueSize + rowidSize\n    \n    // Build the entry\n    buf := make([]byte, varintSize(int64(totalSize)) + totalSize)\n    \n    offset := 0\n    offset = writeVarint(buf, offset, int64(totalSize))\n    offset += copy(buf[offset:], valueBytes)\n    writeVarint(buf, offset, rowid)\n    \n    return buf\n}\n\nfunc (idx *Index) DeserializeEntry(data []byte, offset int) (value interface{}, rowid int64, bytesRead int) {\n    // Read payload size\n    payloadSize, n := ReadVarint(data, offset)\n    offset += n\n    \n    // The payload contains: serialized value + rowid varint\n    // We need to deserialize the value first to know its size\n    startOffset := offset\n    \n    // Read the serial type (first varint in the value encoding)\n    serialType, n := ReadVarint(data, offset)\n    offset += n\n    \n    // Decode the value based on serial type\n    value, valueSize := decodeValue(data, offset, SerialType(serialType))\n    offset += valueSize\n    \n    // Read the rowid\n    rowid, n = ReadVarint(data, offset)\n    \n    return value, rowid, (offset - startOffset) + n + int(n)\n}\n```\n\n### Building the Index from Existing Data\n\n```go\nfunc (db *Database) CreateIndex(stmt *CreateIndexStatement) error {\n    // 1. Verify the table exists\n    tableRootPage, err := db.catalog.GetTableRootPage(stmt.TableName)\n    if err != nil {\n        return fmt.Errorf(\"no such table: %s\", stmt.TableName)\n    }\n    \n    // 2. Allocate a root page for the index\n    indexRootPage := db.allocatePage()\n    \n    // 3. Initialize the index B+tree\n    indexPage := db.bufferPool.FetchPage(indexRootPage)\n    indexPage.SetPageType(PageTypeIndexLeaf)\n    indexPage.SetCellCount(0)\n    indexPage.SetCellContentStart(0)\n    indexPage.Unpin(true)\n    \n    // 4. Scan the table and populate the index\n    tableTree := db.GetTableTree(stmt.TableName)\n    index := &Index{\n        name:       stmt.IndexName,\n        tableName:  stmt.TableName,\n        columnName: stmt.ColumnName,\n        rootPageID: indexRootPage,\n        isUnique:   stmt.Unique,\n        bufferPool: db.bufferPool,\n    }\n    \n    cursor := tableTree.NewCursor()\n    cursor.First()\n    \n    for !cursor.AtEnd() {\n        rowid, record := cursor.Current()\n        \n        // Get the indexed column value\n        colIndex := db.schema.GetColumnIndex(stmt.TableName, stmt.ColumnName)\n        value, err := DeserializeColumn(record, colIndex)\n        if err != nil {\n            return err\n        }\n        \n        // Check UNIQUE constraint if applicable\n        if stmt.Unique {\n            exists, _ := index.Find(value)\n            if exists {\n                return fmt.Errorf(\"UNIQUE constraint failed: duplicate value in index %s\", stmt.IndexName)\n            }\n        }\n        \n        // Insert into the index\n        entry := index.SerializeEntry(value, rowid)\n        if err := index.Insert(entry); err != nil {\n            return err\n        }\n        \n        cursor.Next()\n    }\n    \n    // 5. Record the index in sqlite_master\n    db.Execute(fmt.Sprintf(\n        \"INSERT INTO sqlite_master (type, name, tbl_name, rootpage, sql) VALUES ('index', '%s', '%s', %d, '%s')\",\n        stmt.IndexName, stmt.TableName, indexRootPage, serializeCreateIndex(stmt),\n    ))\n    \n    return nil\n}\n```\n\nThe CREATE INDEX operation is O(n) in the number of rows—it must read every row to build the index. For large tables, this can take significant time, which is why production databases often support `CREATE INDEX CONCURRENTLY` that builds the index without blocking writes.\n\n---\n\n## Index Lookup: Equality Search\n\nFor a query like `SELECT * FROM users WHERE email = 'alice@example.com'`:\n\n```go\nfunc (idx *Index) FindEqual(targetValue interface{}) ([]int64, error) {\n    var rowids []int64\n    \n    // Navigate to the first matching entry\n    cursor := idx.NewCursor()\n    found := cursor.Seek(targetValue)\n    \n    if !found {\n        return nil, nil // No match\n    }\n    \n    // Collect all matching rowids (for non-unique indexes)\n    for !cursor.AtEnd() {\n        value, rowid := cursor.Current()\n        \n        // Compare the value\n        cmp := compareValues(value, targetValue)\n        if cmp != 0 {\n            break // Past the matching range\n        }\n        \n        rowids = append(rowids, rowid)\n        cursor.Next()\n    }\n    \n    return rowids, nil\n}\n```\n\n### The Seek Operation\n\nThe Seek operation finds the first entry >= the target value:\n\n```go\nfunc (c *IndexCursor) Seek(targetValue interface{}) bool {\n    // Start at root\n    c.pageID = c.index.rootPageID\n    \n    for {\n        page := c.index.bufferPool.FetchPage(c.pageID)\n        \n        if page.PageType() == PageTypeIndexLeaf {\n            // Binary search within leaf\n            c.cellIndex = c.binarySearchLeaf(page, targetValue)\n            c.currentPage = page\n            \n            // Check if we found an exact match\n            if c.cellIndex < int(page.CellCount()) {\n                value, _ := c.Current()\n                return compareValues(value, targetValue) == 0\n            }\n            return false\n        }\n        \n        // Internal page: find the right child\n        c.pageID = c.findChildPage(page, targetValue)\n        page.Unpin(false)\n    }\n}\n\nfunc (c *IndexCursor) binarySearchLeaf(page *Page, target interface{}) int {\n    cellCount := int(page.CellCount())\n    \n    low, high := 0, cellCount-1\n    for low <= high {\n        mid := (low + high) / 2\n        cellOffset := page.CellPointer(mid)\n        value, _ := c.index.DeserializeEntry(page.Data, int(cellOffset))\n        \n        cmp := compareValues(value, target)\n        if cmp < 0 {\n            low = mid + 1\n        } else if cmp > 0 {\n            high = mid - 1\n        } else {\n            return mid // Exact match\n        }\n    }\n    \n    return low // Insertion point\n}\n```\n\n---\n\n## Range Scan: Traversing Leaf Pages\n\nFor `SELECT * FROM users WHERE age BETWEEN 25 AND 35`:\n\n```go\nfunc (idx *Index) RangeScan(lowValue, highValue interface{}) ([]int64, error) {\n    var rowids []int64\n    \n    cursor := idx.NewCursor()\n    cursor.Seek(lowValue)\n    \n    for !cursor.AtEnd() {\n        value, rowid := cursor.Current()\n        \n        // Check if we've passed the high end of the range\n        if compareValues(value, highValue) > 0 {\n            break\n        }\n        \n        // This value is in range\n        rowids = append(rowids, rowid)\n        cursor.Next()\n    }\n    \n    return rowids, nil\n}\n```\n\n### Leaf Page Linking in B+trees\n\nIndex B+trees link leaf pages together for efficient range scans. Each leaf page has a pointer to the next leaf:\n\n```go\ntype IndexLeafPage struct {\n    *Page\n    NextLeaf uint32  // Right-sibling pointer\n}\n\nfunc (p *IndexLeafPage) ReadHeader() {\n    p.Page.ReadHeader()\n    // Next leaf pointer stored after the standard header\n    p.NextLeaf = binary.BigEndian.Uint32(p.Data[8:12])\n}\n\nfunc (c *IndexCursor) Next() error {\n    c.cellIndex++\n    \n    if c.cellIndex >= int(c.currentPage.CellCount()) {\n        // Move to next leaf\n        nextLeaf := c.currentPage.NextLeaf\n        \n        if nextLeaf == 0 {\n            c.atEnd = true\n            return nil\n        }\n        \n        c.currentPage.Unpin(false)\n        c.currentPage = c.index.bufferPool.FetchPage(nextLeaf)\n        c.pageID = nextLeaf\n        c.cellIndex = 0\n    }\n    \n    return nil\n}\n```\n\nWithout leaf linking, a range scan would require navigating through internal pages to find each successive leaf—O(log n) per leaf instead of O(1).\n\n---\n\n## Index Maintenance on DML\n\n### INSERT: Add to All Indexes\n\n```go\nfunc (db *Database) InsertRow(table string, values []interface{}) error {\n    // 1. Get table schema and tree\n    schema := db.GetTableSchema(table)\n    tree := db.GetTableTree(table)\n    \n    // 2. Check NOT NULL constraints\n    for i, col := range schema.Columns {\n        if col.NotNull && values[i] == nil {\n            return fmt.Errorf(\"NOT NULL constraint failed: %s.%s\", table, col.Name)\n        }\n    }\n    \n    // 3. Generate rowid (or use provided)\n    rowid := db.generateRowid(table)\n    \n    // 4. Serialize and insert into table B-tree\n    record := SerializeRow(values)\n    if err := tree.Insert(rowid, record); err != nil {\n        return err\n    }\n    \n    // 5. Update all indexes on this table\n    indexes := db.GetTableIndexes(table)\n    for _, idx := range indexes {\n        colIndex := schema.ColumnIndex(idx.columnName)\n        value := values[colIndex]\n        \n        // Check UNIQUE constraint\n        if idx.isUnique {\n            exists, _ := idx.Find(value)\n            if exists {\n                // Rollback the table insert\n                tree.Delete(rowid)\n                return fmt.Errorf(\"UNIQUE constraint failed: %s.%s\", table, idx.columnName)\n            }\n        }\n        \n        // Insert into index\n        entry := idx.SerializeEntry(value, rowid)\n        if err := idx.Insert(entry); err != nil {\n            // Rollback everything on failure\n            tree.Delete(rowid)\n            return err\n        }\n    }\n    \n    return nil\n}\n```\n\n### UPDATE: Modify Affected Indexes\n\n```go\nfunc (db *Database) UpdateRow(table string, rowid int64, updates map[string]interface{}) error {\n    schema := db.GetTableSchema(table)\n    tree := db.GetTableTree(table)\n    indexes := db.GetTableIndexes(table)\n    \n    // 1. Fetch the current row\n    record, err := tree.Fetch(rowid)\n    if err != nil {\n        return err\n    }\n    oldValues := DeserializeRow(record)\n    \n    // 2. Build new values\n    newValues := make([]interface{}, len(oldValues))\n    copy(newValues, oldValues)\n    \n    for colName, newVal := range updates {\n        colIndex := schema.ColumnIndex(colName)\n        \n        // Check NOT NULL\n        if schema.Columns[colIndex].NotNull && newVal == nil {\n            return fmt.Errorf(\"NOT NULL constraint failed: %s.%s\", table, colName)\n        }\n        \n        newValues[colIndex] = newVal\n    }\n    \n    // 3. Update indexes for changed columns\n    for _, idx := range indexes {\n        colIndex := schema.ColumnIndex(idx.columnName)\n        oldValue := oldValues[colIndex]\n        newValue := newValues[colIndex]\n        \n        // Skip if the indexed column didn't change\n        if compareValues(oldValue, newValue) == 0 {\n            continue\n        }\n        \n        // Check UNIQUE constraint on new value\n        if idx.isUnique {\n            existingRowid, err := idx.FindExact(newValue)\n            if err == nil && existingRowid != rowid {\n                return fmt.Errorf(\"UNIQUE constraint failed: %s.%s\", table, idx.columnName)\n            }\n        }\n        \n        // Delete old entry from index\n        idx.Delete(oldValue, rowid)\n        \n        // Insert new entry into index\n        entry := idx.SerializeEntry(newValue, rowid)\n        idx.Insert(entry)\n    }\n    \n    // 4. Update the table B-tree\n    newRecord := SerializeRow(newValues)\n    return tree.Update(rowid, newRecord)\n}\n```\n\n### DELETE: Remove from All Indexes\n\n```go\nfunc (db *Database) DeleteRow(table string, rowid int64) error {\n    tree := db.GetTableTree(table)\n    indexes := db.GetTableIndexes(table)\n    schema := db.GetTableSchema(table)\n    \n    // 1. Fetch the row to get values for index deletion\n    record, err := tree.Fetch(rowid)\n    if err != nil {\n        return err\n    }\n    values := DeserializeRow(record)\n    \n    // 2. Delete from all indexes\n    for _, idx := range indexes {\n        colIndex := schema.ColumnIndex(idx.columnName)\n        value := values[colIndex]\n        \n        if err := idx.Delete(value, rowid); err != nil {\n            return err\n        }\n    }\n    \n    // 3. Delete from table B-tree\n    return tree.Delete(rowid)\n}\n```\n\n---\n\n## Double Lookup in the Bytecode VM\n\nThe VM must coordinate between an index cursor and a table cursor:\n\n```go\n// Bytecode for: SELECT * FROM users WHERE email = 'alice@example.com'\n// (assuming index on email)\n\n// 0: OpenIndex cursor=0 rootpage=5    ; Open the email index\n// 1: OpenTable cursor=1 rootpage=2    ; Open the users table\n// 2: String8 'alice@example.com' r0   ; Load the search value\n// 3: SeekGe cursor=0 r0               ; Position index cursor\n// 4: Column cursor=0 1 r1             ; Read rowid from index (column 1 is rowid)\n// 5: SeekRowid cursor=1 r1            ; Position table cursor at rowid\n// 6: Column cursor=1 0 r2             ; Read id from table\n// 7: Column cursor=1 1 r3             ; Read name from table\n// 8: Column cursor=1 2 r4             ; Read email from table\n// 9: ResultRow r2 3                   ; Output 3 columns\n// 10: Next cursor=0 4                 ; Loop back for more matches\n// 11: Halt\n```\n\n### VM Implementation of SeekRowid\n\n```go\ncase \"SeekRowid\":\n    cursor := vm.Cursors[instr.P1]\n    rowidReg := instr.P2\n    rowid := vm.Registers[rowidReg].Int\n    \n    // Seek the table cursor to the rowid\n    if !cursor.SeekRowid(rowid) {\n        // Row not found, skip to the next iteration\n        vm.PC = instr.P3 // Jump target\n        return nil\n    }\n```\n\n### Coordinating Two Cursors\n\nThe pattern for index-driven queries:\n\n```go\nfunc (vm *VM) executeIndexScan(indexCursor, tableCursor int, predicate func() bool, callback func()) {\n    idxCur := vm.Cursors[indexCursor]\n    tblCur := vm.Cursors[tableCursor]\n    \n    for !idxCur.AtEnd() {\n        // Get rowid from index\n        _, rowid := idxCur.Current()\n        \n        // Fetch row from table\n        tblCur.SeekRowid(rowid)\n        \n        // Check predicate (if any)\n        if predicate() {\n            callback()\n        }\n        \n        idxCur.Next()\n    }\n}\n```\n\n---\n\n## UNIQUE Index Constraint\n\nA UNIQUE index rejects duplicate values:\n\n```go\nfunc (idx *Index) Insert(entry []byte) error {\n    // Extract the value and rowid\n    value, rowid := idx.DeserializeEntry(entry)\n    \n    // For UNIQUE index, check for existing value\n    if idx.isUnique {\n        existingRowids, err := idx.Find(value)\n        if err != nil {\n            return err\n        }\n        \n        if len(existingRowids) > 0 {\n            return fmt.Errorf(\"UNIQUE constraint failed: duplicate value\")\n        }\n    }\n    \n    // Insert into the B+tree\n    return idx.btree.Insert(entry)\n}\n```\n\nThe UNIQUE check happens during INSERT and UPDATE, not at index creation time. When creating a UNIQUE index on a table that already has duplicates, the CREATE INDEX fails:\n\n```sql\n-- If users table already has duplicate emails:\nCREATE UNIQUE INDEX idx_email ON users(email);\n-- Error: UNIQUE constraint failed: duplicate value\n```\n\n---\n\n## Covering Indexes: Skipping the Table Lookup\n\n\n![Covering Index: Skipping the Table Lookup](./diagrams/diag-covering-index.svg)\n\n\nIf all columns needed by a query are in the index, the table lookup can be skipped entirely:\n\n```sql\nCREATE INDEX idx_email_name ON users(email, name);\n\nSELECT name FROM users WHERE email = 'alice@example.com';\n```\n\nThis query only needs `email` (for the WHERE clause) and `name` (for the result). Both are in the index. No table lookup required.\n\n```go\nfunc (p *Planner) isCoveringIndex(query *SelectStatement, index *Index) bool {\n    // Check if all referenced columns are in the index\n    indexedColumns := index.GetColumns()\n    \n    for _, col := range query.ReferencedColumns() {\n        if !contains(indexedColumns, col) {\n            return false\n        }\n    }\n    \n    return true\n}\n```\n\nCovering indexes are a powerful optimization. A query like `SELECT COUNT(*) FROM users WHERE status = 'active'` with an index on `(status)` doesn't need to touch the table at all—the index has all the information.\n\n---\n\n## Common Pitfalls\n\n### 1. Forgetting to Update Indexes on Write\n\n```go\n// WRONG: Only update the table\ntree.Insert(rowid, record)\n// BUG: Indexes now have stale data!\n```\n\nEvery INSERT, UPDATE, and DELETE must update all affected indexes. Forgetting this causes incorrect query results—index lookups return rowids that don't exist, or miss rows that do exist.\n\n### 2. UNIQUE Index Allowing Duplicates\n\n```go\n// WRONG: Only check at index creation\nfunc (idx *Index) Insert(entry []byte) error {\n    return idx.btree.Insert(entry)  // No uniqueness check!\n}\n```\n\nUNIQUE must be enforced on every INSERT and UPDATE, not just at index creation.\n\n### 3. Not Handling NULL in Indexes\n\n```sql\nCREATE UNIQUE INDEX idx_email ON users(email);\nINSERT INTO users (id, email) VALUES (1, NULL);\nINSERT INTO users (id, email) VALUES (2, NULL);\n-- Should this succeed or fail?\n```\n\nSQLite allows multiple NULLs in a UNIQUE index (NULL != NULL). Some databases reject this. Document your behavior clearly.\n\n### 4. Index Fragmentation from Many Deletes\n\nAfter deleting 90% of rows from a table, the index still has 100% of its pages—most entries are deleted but the pages remain. Index fragmentation wastes space and reduces cache efficiency.\n\n**Solution**: Periodic `REINDEX` or `VACUUM` to rebuild fragmented indexes.\n\n### 5. Composite Index Column Order\n\n```sql\nCREATE INDEX idx_name_email ON users(name, email);\n\nSELECT * FROM users WHERE email = 'alice@example.com';  -- Can't use index efficiently!\nSELECT * FROM users WHERE name = 'Alice';               -- Can use index\nSELECT * FROM users WHERE name = 'Alice' AND email = 'alice@example.com';  -- Can use index\n```\n\nA composite index on (A, B, C) can efficiently serve queries on A, (A, B), or (A, B, C), but not B alone or C alone. The leftmost columns must be specified.\n\n---\n\n## Test Suite: What to Verify\n\n**CREATE INDEX:**\n```sql\nCREATE TABLE users (id INTEGER, name TEXT, email TEXT);\nINSERT INTO users VALUES (1, 'Alice', 'alice@example.com');\nINSERT INTO users VALUES (2, 'Bob', 'bob@example.com');\n\nCREATE INDEX idx_email ON users(email);\n\n-- Verify index exists\nSELECT * FROM sqlite_master WHERE type='index' AND name='idx_email';\n```\n\n**Index lookup (equality):**\n```sql\nSELECT * FROM users WHERE email = 'alice@example.com';\n-- Should use index, read ~2 pages instead of all table pages\n-- Verify by counting buffer pool misses before/after\n```\n\n**Index range scan:**\n```sql\nCREATE INDEX idx_id ON users(id);\nSELECT * FROM users WHERE id BETWEEN 1 AND 100;\n-- Should traverse index leaves efficiently\n```\n\n**UNIQUE constraint:**\n```sql\nCREATE UNIQUE INDEX idx_unique_email ON users(email);\nINSERT INTO users VALUES (3, 'Charlie', 'alice@example.com');\n-- Expected: Error - UNIQUE constraint failed\n\nINSERT INTO users VALUES (3, 'Charlie', 'charlie@example.com');\n-- Expected: Success\n```\n\n**Index maintenance on INSERT:**\n```sql\nCREATE INDEX idx_name ON users(name);\nINSERT INTO users VALUES (4, 'Diana', 'diana@example.com');\nSELECT * FROM users WHERE name = 'Diana';\n-- Expected: Returns (4, 'Diana', 'diana@example.com')\n```\n\n**Index maintenance on UPDATE:**\n```sql\nUPDATE users SET name = 'David' WHERE id = 4;\nSELECT * FROM users WHERE name = 'Diana';\n-- Expected: Empty result\nSELECT * FROM users WHERE name = 'David';\n-- Expected: Returns (4, 'David', 'diana@example.com')\n```\n\n**Index maintenance on DELETE:**\n```sql\nDELETE FROM users WHERE id = 4;\nSELECT * FROM users WHERE name = 'David';\n-- Expected: Empty result (index entry was deleted)\n```\n\n**Double lookup verification:**\n```go\n// Verify index lookup followed by table fetch\nbp := NewBufferPool(1000, 4096, diskMgr)\ndb := NewDatabase(bp)\n\n// Create table with 1000 rows\nfor i := 0; i < 1000; i++ {\n    db.Execute(fmt.Sprintf(\"INSERT INTO users VALUES (%d, 'user%d', 'user%d@example.com')\", i, i, i))\n}\n\n// Create index\ndb.Execute(\"CREATE INDEX idx_email ON users(email)\")\n\n// Reset stats\nbp.ResetStats()\n\n// Query with index\ndb.Execute(\"SELECT * FROM users WHERE email = 'user500@example.com'\")\n\n// Should read ~2-3 pages (index seek + table fetch), not 100+ pages\nassert.Less(t, bp.Misses, 5)\n```\n\n---\n\n## Knowledge Cascade: What This Unlocks\n\nYou've just implemented **secondary indexes**—one of the most impactful database features for query performance. Here's where this connects:\n\n**Immediate connections:**\n- **Query planner (next milestone)**: The planner needs statistics to decide when an index is beneficial. You now have the execution capability; the planner provides the intelligence.\n- **Cost model**: The double lookup cost (index seek + table fetch) must be weighed against table scan cost. This is the foundation of cost-based optimization.\n\n**Same domain:**\n- **Covering indexes**: When all queried columns are in the index, the table lookup is skipped entirely. This is why multi-column indexes are powerful—they can \"cover\" more queries.\n- **Index-only scans in PostgreSQL/MySQL**: Modern databases track \"visibility\" in indexes to enable index-only scans even with concurrent updates. Your implementation assumes the table lookup is always needed, but production databases optimize this.\n- **Write amplification in LSM-trees**: RocksDB and Cassandra use LSM-trees where writes are buffered and periodically merged. Index maintenance in B-trees is synchronous; in LSM-trees, it's batched. Different tradeoffs, same fundamental concern: indexes add write cost.\n\n**Cross-domain:**\n- **Search engine inverted indexes**: Elasticsearch and Lucene build inverted indexes mapping (term → document IDs). This is the same pattern as your (column value → rowid) mapping. The difference is scale—search engines handle billions of documents and optimize for recall/precision tradeoffs.\n- **Database replication lag**: In a primary-replica setup, the primary applies writes to all indexes before acknowledging. Replicas replay the write log. If the primary has many indexes, write latency increases, and replication lag grows. This is why read replicas often have fewer indexes than the primary.\n- **Git object storage**: Git's pack files index objects by SHA-1 hash. An idx file maps hash prefixes to pack file offsets—essentially an index structure for fast object lookup.\n- **Elasticsearch/Lucene segment merging**: Multiple index segments must be merged periodically. This is analogous to B-tree rebalancing—maintaining index structure efficiency over time requires maintenance operations.\n\n**Forward:**\n- **With this knowledge, you could now build**: A query cost estimator that predicts whether an index helps or hurts for a given query; a schema advisor that recommends indexes based on query patterns; or a change data capture (CDC) system that tracks which rows were modified by indexing the transaction log.\n\nSecondary indexes are where database performance tuning lives. Understanding the double lookup pattern, the write overhead, and the selectivity threshold empowers you to design schemas that balance read and write performance—a skill that separates database administrators from developers who \"just add indexes until it's fast.\"\n\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-sqlite-m8 -->\n# Milestone 8: Query Planner & Statistics\n\n## Where We Are in the System\n\n\n![SQLite Architecture: The Complete System Map](./diagrams/diag-satellite-overview.svg)\n\n\nYour database can now execute queries through bytecode, store data in B-trees, and accelerate lookups with secondary indexes. But there's a critical missing piece: intelligence.\n\nWhen a user runs `SELECT * FROM users WHERE age > 21`, your database faces a choice:\n\n- **Table scan**: Read every page sequentially, filter rows in memory\n- **Index scan**: Seek the index for matching entries, fetch each row by rowid\n\nWhich is faster? The answer depends on data you don't have: how many rows match the predicate? What fraction of the table is \"age > 21\"? Is the index clustered or scattered?\n\nThe query planner is the brain that makes this decision. It estimates the cost of each execution path and chooses the cheapest. Without a planner, your database is like a car without a GPS—it can move, but it doesn't know the best route.\n\n---\n\n## The Revelation: An Index Can Make Queries Slower\n\nHere's what most developers assume: \"Indexes always speed up queries. If I create an index on a column, the database will use it. The optimizer is smart enough to always pick the fastest plan.\"\n\nAll three assumptions are catastrophically wrong.\n\n### When Indexes Hurt: The Selectivity Trap\n\nConsider a `users` table with 1 million rows and an index on the `status` column:\n\n```sql\nCREATE INDEX idx_status ON users(status);\nSELECT * FROM users WHERE status = 'active';\n```\n\nIf 90% of users are active (900,000 rows match), which is faster?\n\n**Table scan**:\n- Read ~10,000 pages sequentially\n- Filter in memory: 900,000 rows pass\n- **Total I/O: ~10,000 page reads**\n\n**Index scan**:\n- Read index pages to find 900,000 matching rowids\n- For each rowid, fetch the row from the table\n- **Total I/O: ~900,000 page reads** (one per matching row, assuming random distribution)\n\nThe index scan is **90x slower**. Each rowid lookup is a random I/O to a different page. Sequential reads (table scan) are vastly faster than random reads (index scan) when the result set is large.\n\n\n![Selectivity: When Indexes Help vs Hurt](./diagrams/diag-selectivity-visualization.svg)\n\n\n### The Threshold: Selectivity Determines Everything\n\n**Selectivity** = matching rows / total rows\n\n| Selectivity | Recommended Strategy |\n|-------------|---------------------|\n| < 5% | Index scan (few rows, random I/O acceptable) |\n| 5-20% | Either could win, depends on data distribution |\n| > 20% | Table scan (many rows, sequential I/O wins) |\n| > 50% | Table scan is dramatically faster |\n\nThe planner must know the selectivity to choose correctly. Without statistics, it's flying blind.\n\n### Flying Blind: The Default Assumption Problem\n\nBefore `ANALYZE` is run, the planner has no statistics. It must assume defaults:\n\n- **Default row count**: Assume 1,000,000 rows (or 1000, or 10,000—databases pick different values)\n- **Default selectivity**: Assume 10% of rows match any equality predicate\n- **Default distinct values**: Assume 10 distinct values per column\n\nThese defaults are often wrong by orders of magnitude:\n\n```sql\n-- Table has 10 rows, planner assumes 1,000,000\nSELECT * FROM tiny_table WHERE id = 5;\n-- Planner chooses table scan (correct for 10 rows)\n-- But if table had 1M rows, index scan would be right\n\n-- Table has 100M rows, planner assumes 1,000\nSELECT * FROM huge_table WHERE status = 'rare_value';\n-- Planner might choose index scan\n-- But if 50M rows match, table scan is 1000x faster\n```\n\n### Cardinality Estimation Errors Compound Exponentially\n\nFor single-table queries, a 10x cardinality error means a 10x cost error. For joins, errors compound:\n\n```sql\nSELECT * FROM orders o JOIN customers c ON o.customer_id = c.id\nWHERE o.status = 'pending' AND c.country = 'US';\n```\n\nIf the planner underestimates `o.status = 'pending'` by 10x and `c.country = 'US'` by 10x:\n- Estimated join result: 1,000 rows\n- Actual join result: 100,000 rows\n\nThe join output is off by 100x. If this feeds into another join, the error compounds again. A three-table join with 10x errors at each step produces a 1000x cardinality error.\n\nThis is why production DBAs religiously run `ANALYZE` after major data changes. Stale statistics cause the planner to choose catastrophically wrong plans.\n\n---\n\n## The Tension: Accuracy vs Estimation Cost\n\nThe planner faces a fundamental tradeoff:\n\n| Approach | Accuracy | Cost |\n|----------|----------|------|\n| **Exact statistics** | 100% accurate | O(n) per table scan |\n| **Sampled statistics** | ~95% accurate | O(sample size) |\n| **Histograms** | Good for skewed data | O(buckets) storage |\n| **No statistics** | Default guesses | Zero cost |\n\nThe constraint: you cannot afford to scan the entire table on every query to get exact statistics. The statistics themselves must be collected once (via `ANALYZE`) and used for many queries.\n\n**The planner's job**: Make the best decision with imperfect information. Perfect information costs more than the query itself; no information leads to wrong plans. Statistics are the compromise.\n\n---\n\n## Three-Level View: From Statistics to Plan to Bytecode\n\n{{DIAGRAM:diag-query-execution-pipeline}}\n\n| Level | What Happens | Output |\n|-------|--------------|--------|\n| **Statistics** | ANALYZE collects row counts, distinct values | Metadata stored in system tables |\n| **Planning** | Cost model estimates I/O for each access path | Chosen plan with estimated cost |\n| **Compilation** | Plan is converted to bytecode | VDBE program ready for execution |\n\nThe planner sits between the parsed AST and the bytecode compiler. It transforms a logical plan (what to do) into a physical plan (how to do it).\n\n---\n\n## Building ANALYZE: Collecting Statistics\n\n### Statistics Storage\n\nStatistics are stored in a system table, often called `sqlite_stat1`:\n\n```sql\nCREATE TABLE sqlite_stat1 (\n    tbl TEXT,    -- Table name\n    idx TEXT,    -- Index name (NULL for table)\n    stat TEXT    -- Space-separated statistics: \"rows distinct1 distinct2 ...\"\n);\n```\n\nExample data:\n\n```\ntbl     | idx         | stat\n--------|-------------|------------------\nusers   | NULL        | 1000000\nusers   | idx_email   | 1000000 1000000\nusers   | idx_status  | 1000000 3\norders  | NULL        | 50000000\norders  | idx_cust_id | 50000000 200000\n```\n\nInterpretation:\n- `users` table has 1,000,000 rows\n- `idx_email` has 1,000,000 distinct values (unique)\n- `idx_status` has 3 distinct values (active/inactive/pending)\n- `orders` table has 50,000,000 rows\n- `idx_cust_id` has 200,000 distinct customer IDs\n\n### ANALYZE Implementation\n\n```go\ntype Statistics struct {\n    RowCount      int64\n    DistinctCount map[string]int64  // column name -> distinct values\n}\n\nfunc (db *Database) Analyze(tableName string) error {\n    schema := db.GetTableSchema(tableName)\n    tree := db.GetTableTree(tableName)\n    \n    // 1. Count total rows\n    var rowCount int64\n    cursor := tree.NewCursor()\n    cursor.First()\n    for !cursor.AtEnd() {\n        rowCount++\n        cursor.Next()\n    }\n    \n    // 2. Count distinct values for each indexed column\n    distinctCounts := make(map[string]int64)\n    \n    indexes := db.GetTableIndexes(tableName)\n    for _, idx := range indexes {\n        distinctCount := db.countDistinctValues(idx)\n        distinctCounts[idx.columnName] = distinctCount\n        \n        // Store index statistics\n        statStr := fmt.Sprintf(\"%d %d\", rowCount, distinctCount)\n        db.UpsertStat(tableName, idx.name, statStr)\n    }\n    \n    // 3. Store table statistics\n    statStr := fmt.Sprintf(\"%d\", rowCount)\n    db.UpsertStat(tableName, \"\", statStr)  // Empty index name = table\n    \n    return nil\n}\n\nfunc (db *Database) countDistinctValues(idx *Index) int64 {\n    var count int64\n    var lastValue interface{}\n    \n    cursor := idx.NewCursor()\n    cursor.First()\n    \n    for !cursor.AtEnd() {\n        value, _ := cursor.Current()\n        \n        if count == 0 || compareValues(value, lastValue) != 0 {\n            count++\n            lastValue = value\n        }\n        \n        cursor.Next()\n    }\n    \n    return count\n}\n```\n\n### Histogram Storage (Advanced)\n\nFor columns with skewed distribution, a single \"distinct count\" isn't enough:\n\n```sql\n-- Status distribution: 95% active, 4% inactive, 1% pending\n-- A query for 'pending' should use the index\n-- A query for 'active' should not\n```\n\nHistograms capture this:\n\n```go\ntype Histogram struct {\n    ColumnName string\n    Buckets    []HistogramBucket\n}\n\ntype HistogramBucket struct {\n    LowerBound interface{}\n    UpperBound interface{}\n    Count      int64\n    Distinct   int64\n}\n\nfunc (db *Database) BuildHistogram(tableName, columnName string, numBuckets int) *Histogram {\n    // Sample the column values\n    values := db.sampleColumnValues(tableName, columnName, 10000)\n    sort.Slice(values, func(i, j int) bool {\n        return compareValues(values[i], values[j]) < 0\n    })\n    \n    // Create equal-width buckets\n    bucketSize := len(values) / numBuckets\n    buckets := make([]HistogramBucket, numBuckets)\n    \n    for i := 0; i < numBuckets; i++ {\n        start := i * bucketSize\n        end := (i + 1) * bucketSize\n        if i == numBuckets-1 {\n            end = len(values)\n        }\n        \n        buckets[i] = HistogramBucket{\n            LowerBound: values[start],\n            UpperBound: values[end-1],\n            Count:      int64(end - start),\n            Distinct:   countDistinct(values[start:end]),\n        }\n    }\n    \n    return &Histogram{ColumnName: columnName, Buckets: buckets}\n}\n```\n\nFor this project, distinct counts are sufficient. Histograms are an advanced optimization.\n\n---\n\n## Building the Cost Model\n\n\n![Cost Model: Table Scan vs Index Scan](./diagrams/diag-cost-model-comparison.svg)\n\n\n### Cost Model: Table Scan\n\n```go\nfunc (p *Planner) costTableScan(table *TableInfo) float64 {\n    // Table scan reads all pages sequentially\n    // Cost = number of pages * sequential I/O cost\n    \n    pages := p.estimatePageCount(table)\n    seqIOCost := 1.0  // Baseline cost per page\n    \n    return float64(pages) * seqIOCost\n}\n\nfunc (p *Planner) estimatePageCount(table *TableInfo) int64 {\n    stats := p.getStats(table.Name)\n    \n    if stats == nil {\n        // No statistics: assume 1000 pages\n        return 1000\n    }\n    \n    // Estimate: rows / rows_per_page\n    // Average row size varies, but ~20 rows per 4KB page is reasonable\n    rowsPerPage := 20\n    pages := (stats.RowCount + rowsPerPage - 1) / rowsPerPage\n    \n    // Minimum 1 page\n    if pages < 1 {\n        pages = 1\n    }\n    \n    return pages\n}\n```\n\n### Cost Model: Index Scan\n\n```go\nfunc (p *Planner) costIndexScan(table *TableInfo, index *IndexInfo, selectivity float64) float64 {\n    // Index scan has two components:\n    // 1. Index traversal: log_f(n) page reads to find start position\n    // 2. Row fetches: selectivity * rows * random I/O per row\n    \n    stats := p.getStats(table.Name)\n    if stats == nil {\n        // No statistics: assume index is not helpful\n        return float64(1<<30)  // Very high cost\n    }\n    \n    matchingRows := float64(stats.RowCount) * selectivity\n    \n    // Index traversal cost: ~3-4 page reads for B-tree of any size\n    indexTraversalCost := 4.0\n    \n    // Row fetch cost: random I/O per matching row\n    // Random I/O is ~10x more expensive than sequential I/O\n    randomIOCost := 10.0\n    \n    // But: if rows are clustered, multiple rows per page\n    // Assume 20 rows per page, so rows/20 pages actually read\n    rowsPerPage := 20.0\n    pagesRead := matchingRows / rowsPerPage\n    \n    rowFetchCost := pagesRead * randomIOCost\n    \n    // Total cost\n    return indexTraversalCost + rowFetchCost\n}\n```\n\n### Selectivity Estimation\n\n```go\nfunc (p *Planner) estimateSelectivity(table *TableInfo, predicate Expression) float64 {\n    stats := p.getStats(table.Name)\n    \n    if stats == nil {\n        // No statistics: assume 10% selectivity\n        return 0.1\n    }\n    \n    switch pred := predicate.(type) {\n    case *BinaryExpression:\n        switch pred.Operator {\n        case \"=\":\n            // Equality: 1 / distinct_values\n            colName := getColumnName(pred.Left)\n            distinct := stats.DistinctCount[colName]\n            if distinct == 0 {\n                distinct = 10  // Default assumption\n            }\n            return 1.0 / float64(distinct)\n            \n        case \"<\", \">\", \"<=\", \">=\":\n            // Range: assume 33% selectivity\n            // (Better: use histogram if available)\n            return 0.33\n            \n        case \"!=\":\n            // Not equal: 1 - (1/distinct)\n            colName := getColumnName(pred.Left)\n            distinct := stats.DistinctCount[colName]\n            if distinct == 0 {\n                distinct = 10\n            }\n            return 1.0 - 1.0/float64(distinct)\n        }\n        \n    case *BinaryExpression:\n        if pred.Operator == \"AND\" {\n            // AND: selectivities multiply\n            leftSel := p.estimateSelectivity(table, pred.Left)\n            rightSel := p.estimateSelectivity(table, pred.Right)\n            return leftSel * rightSel\n        }\n        if pred.Operator == \"OR\" {\n            // OR: selectivities combine (approximate)\n            leftSel := p.estimateSelectivity(table, pred.Left)\n            rightSel := p.estimateSelectivity(table, pred.Right)\n            return leftSel + rightSel - leftSel*rightSel\n        }\n    }\n    \n    // Default: 10% selectivity\n    return 0.1\n}\n```\n\n---\n\n## Building the Planner\n\n### Plan Representation\n\n```go\ntype QueryPlan struct {\n    AccessPath   AccessPath\n    EstimatedCost float64\n    EstimatedRows int64\n}\n\ntype AccessPath interface {\n    PlanType() string\n}\n\ntype TableScanPath struct {\n    TableName string\n}\n\nfunc (p *TableScanPath) PlanType() string { return \"TABLE SCAN\" }\n\ntype IndexScanPath struct {\n    TableName  string\n    IndexName  string\n    Predicate  Expression\n    Selectivity float64\n}\n\nfunc (p *IndexScanPath) PlanType() string { return \"INDEX SCAN\" }\n```\n\n### Planner Implementation\n\n```go\nfunc (p *Planner) PlanSelect(stmt *SelectStatement) (*QueryPlan, error) {\n    table := p.getTableInfo(stmt.FromTable)\n    if table == nil {\n        return nil, fmt.Errorf(\"no such table: %s\", stmt.FromTable)\n    }\n    \n    // 1. Calculate selectivity of WHERE clause\n    var selectivity float64 = 1.0\n    if stmt.Where != nil {\n        selectivity = p.estimateSelectivity(table, stmt.Where)\n    }\n    \n    // 2. Calculate cost of table scan\n    tableScanCost := p.costTableScan(table)\n    \n    // 3. Find usable indexes and calculate their costs\n    var bestIndex *IndexInfo\n    var bestIndexCost float64 = math.MaxFloat64\n    \n    for _, idx := range p.getTableIndexes(table.Name) {\n        // Check if index is usable for this query\n        if !p.isIndexUsable(idx, stmt.Where) {\n            continue\n        }\n        \n        indexCost := p.costIndexScan(table, idx, selectivity)\n        \n        if indexCost < bestIndexCost {\n            bestIndexCost = indexCost\n            bestIndex = idx\n        }\n    }\n    \n    // 4. Choose the cheaper option\n    stats := p.getStats(table.Name)\n    var estimatedRows int64 = 1000\n    if stats != nil {\n        estimatedRows = int64(float64(stats.RowCount) * selectivity)\n    }\n    \n    if bestIndex != nil && bestIndexCost < tableScanCost {\n        return &QueryPlan{\n            AccessPath: &IndexScanPath{\n                TableName:   table.Name,\n                IndexName:   bestIndex.Name,\n                Predicate:   stmt.Where,\n                Selectivity: selectivity,\n            },\n            EstimatedCost: bestIndexCost,\n            EstimatedRows: estimatedRows,\n        }, nil\n    }\n    \n    return &QueryPlan{\n        AccessPath: &TableScanPath{\n            TableName: table.Name,\n        },\n        EstimatedCost: tableScanCost,\n        EstimatedRows: estimatedRows,\n    }, nil\n}\n\nfunc (p *Planner) isIndexUsable(idx *IndexInfo, where Expression) bool {\n    // Check if the WHERE clause references the indexed column\n    if where == nil {\n        return false\n    }\n    \n    referencedCols := extractReferencedColumns(where)\n    \n    for _, col := range referencedCols {\n        if col == idx.ColumnName {\n            return true\n        }\n    }\n    \n    return false\n}\n```\n\n### The Selectivity Threshold\n\nThe planner chooses an index scan only when selectivity is below a threshold:\n\n```go\nconst IndexSelectivityThreshold = 0.2  // 20%\n\nfunc (p *Planner) shouldUseIndex(table *TableInfo, idx *IndexInfo, selectivity float64) bool {\n    if selectivity > IndexSelectivityThreshold {\n        // Too many rows match; table scan is faster\n        return false\n    }\n    \n    // Index scan is likely faster\n    return true\n}\n```\n\nThis threshold is a heuristic. Real databases use more sophisticated models that consider:\n- Cache behavior (are the pages already in memory?)\n- Index clustering (are rows physically ordered by the index?)\n- CPU cost (comparing keys vs deserializing rows)\n\n---\n\n## EXPLAIN: Revealing the Plan\n\n```go\nfunc (p *Planner) Explain(plan *QueryPlan) string {\n    var buf strings.Builder\n    \n    switch ap := plan.AccessPath.(type) {\n    case *TableScanPath:\n        buf.WriteString(fmt.Sprintf(\"TABLE SCAN %s\", ap.TableName))\n        \n    case *IndexScanPath:\n        buf.WriteString(fmt.Sprintf(\"INDEX SCAN %s VIA %s\", ap.TableName, ap.IndexName))\n        buf.WriteString(fmt.Sprintf(\" (selectivity=%.2f%%)\", ap.Selectivity*100))\n    }\n    \n    buf.WriteString(fmt.Sprintf(\"\\n  Estimated rows: %d\", plan.EstimatedRows))\n    buf.WriteString(fmt.Sprintf(\"\\n  Estimated cost: %.2f\", plan.EstimatedCost))\n    \n    return buf.String()\n}\n```\n\nExample output:\n\n```sql\nEXPLAIN SELECT * FROM users WHERE email = 'alice@example.com';\n\n-- Output:\n-- INDEX SCAN users VIA idx_email (selectivity=0.00%)\n--   Estimated rows: 1\n--   Estimated cost: 14.00\n\nEXPLAIN SELECT * FROM users WHERE status = 'active';\n\n-- Output (assuming 90% active):\n-- TABLE SCAN users\n--   Estimated rows: 900000\n--   Estimated cost: 10000.00\n```\n\n---\n\n## Join Planning: Order Matters\n\nFor multi-table queries, the planner must choose a join order:\n\n```sql\nSELECT * FROM orders o JOIN customers c ON o.customer_id = c.id\nWHERE o.status = 'pending' AND c.country = 'US';\n```\n\nTwo possible orders:\n\n1. **orders → customers**: Find pending orders (assume 1000), then look up customers\n2. **customers → orders**: Find US customers (assume 100000), then look up orders\n\nOrder 1 produces 1000 lookups. Order 2 produces 100,000 lookups. **Order matters**.\n\n### Join Cardinality Estimation\n\n```go\nfunc (p *Planner) estimateJoinCardinality(left, right *TableInfo, joinCondition Expression) int64 {\n    leftStats := p.getStats(left.Name)\n    rightStats := p.getStats(right.Name)\n    \n    if leftStats == nil || rightStats == nil {\n        // Default: assume cartesian product / 100\n        return 10000\n    }\n    \n    // Extract join columns\n    leftCol, rightCol := extractJoinColumns(joinCondition)\n    \n    // Estimate: smaller table * (1 / distinct values in larger table)\n    leftDistinct := leftStats.DistinctCount[leftCol]\n    rightDistinct := rightStats.DistinctCount[rightCol]\n    \n    if leftDistinct == 0 {\n        leftDistinct = 100\n    }\n    if rightDistinct == 0 {\n        rightDistinct = 100\n    }\n    \n    // Each row in smaller table matches rows / distinct in larger table\n    if leftStats.RowCount < rightStats.RowCount {\n        return leftStats.RowCount * (rightStats.RowCount / rightDistinct)\n    } else {\n        return rightStats.RowCount * (leftStats.RowCount / leftDistinct)\n    }\n}\n```\n\n### Join Order Selection\n\nFor small numbers of tables (≤10), use dynamic programming:\n\n```go\nfunc (p *Planner) planJoin(tables []*TableInfo, conditions []Expression) *QueryPlan {\n    n := len(tables)\n    \n    // dp[mask] = best plan for joining tables in mask\n    dp := make(map[uint32]*QueryPlan)\n    \n    // Base case: single tables\n    for i, t := range tables {\n        mask := uint32(1) << i\n        dp[mask] = p.planTableAccess(t, conditions)\n    }\n    \n    // Build up larger joins\n    for size := 2; size <= n; size++ {\n        for mask := uint32(0); mask < (1 << n); mask++ {\n            if bitCount(mask) != size {\n                continue\n            }\n            \n            // Try all ways to split mask into left ⊕ right\n            for sub := uint32(1); sub < mask; sub++ {\n                if sub & ^mask != 0 {\n                    continue  // sub has bits not in mask\n                }\n                \n                left := sub\n                right := mask ^ sub\n                \n                if dp[left] == nil || dp[right] == nil {\n                    continue\n                }\n                \n                // Calculate cost of joining left and right\n                joinCost := dp[left].EstimatedCost + dp[right].EstimatedCost\n                joinCard := p.estimateJoinCardinalityFromPlans(dp[left], dp[right], conditions)\n                joinCost += float64(joinCard) * 10.0  // Per-row join cost\n                \n                if dp[mask] == nil || joinCost < dp[mask].EstimatedCost {\n                    dp[mask] = &QueryPlan{\n                        AccessPath: &NestedLoopJoinPath{\n                            Left:  dp[left],\n                            Right: dp[right],\n                        },\n                        EstimatedCost: joinCost,\n                        EstimatedRows: joinCard,\n                    }\n                }\n            }\n        }\n    }\n    \n    return dp[(1<<n)-1]  // Best plan for all tables\n}\n```\n\nFor this project, a simple greedy approach is sufficient:\n\n```go\nfunc (p *Planner) planJoinGreedy(tables []*TableInfo, conditions []Expression) *QueryPlan {\n    // Start with the smallest table (after filtering)\n    remaining := make([]*TableInfo, len(tables))\n    copy(remaining, tables)\n    \n    var currentPlan *QueryPlan\n    \n    for len(remaining) > 0 {\n        // Find the table with lowest estimated join cost\n        var bestIdx int\n        var bestCost float64 = math.MaxFloat64\n        \n        for i, t := range remaining {\n            cost := p.estimateJoinCost(currentPlan, t, conditions)\n            if cost < bestCost {\n                bestCost = cost\n                bestIdx = i\n            }\n        }\n        \n        // Add the best table to the plan\n        if currentPlan == nil {\n            currentPlan = p.planTableAccess(remaining[bestIdx], conditions)\n        } else {\n            currentPlan = p.joinPlans(currentPlan, p.planTableAccess(remaining[bestIdx], conditions), conditions)\n        }\n        \n        // Remove from remaining\n        remaining = append(remaining[:bestIdx], remaining[bestIdx+1:]...)\n    }\n    \n    return currentPlan\n}\n```\n\n---\n\n## Common Pitfalls\n\n### 1. Using an Index for Low-Selectivity Queries\n\n```go\n// WRONG: Always use index if available\nif index != nil {\n    return indexScanPlan\n}\n\n// RIGHT: Check selectivity threshold\nif index != nil && selectivity < 0.2 {\n    return indexScanPlan\n}\n```\n\n### 2. Stale Statistics After Bulk Changes\n\n```sql\n-- Load 10 million rows\nINSERT INTO logs SELECT ... FROM generate_series(1, 10000000);\n\n-- Query without ANALYZE\nSELECT * FROM logs WHERE level = 'ERROR';\n-- Planner thinks table has 0 rows, chooses wrong plan\n\n-- Solution: Run ANALYZE after bulk changes\nANALYZE logs;\n```\n\n### 3. Correlated Predicates Treated as Independent\n\n```sql\nSELECT * FROM products WHERE category = 'Electronics' AND subcategory = 'Laptops';\n```\n\nThe planner might estimate selectivity as:\n- `category = 'Electronics'`: 10%\n- `subcategory = 'Laptops'`: 5%\n- Combined: 10% × 5% = 0.5%\n\nBut in reality, 'Laptops' only exists within 'Electronics'. The actual selectivity is 5%, not 0.5%.\n\n**Solution**: Correlated column statistics or multi-column histograms. For this project, document the limitation.\n\n### 4. Forcing Plans Without Escape Hatch\n\nProduction databases need `FORCE INDEX` hints when the planner gets it wrong:\n\n```sql\n-- MySQL style\nSELECT * FROM users FORCE INDEX (idx_email) WHERE email = 'alice@example.com';\n\n-- PostgreSQL style\nSELECT * FROM users WITH (INDEX(idx_email)) WHERE email = 'alice@example.com';\n```\n\nYour planner should support hints, or at least document how to override bad decisions.\n\n---\n\n## Test Suite: What to Verify\n\n**ANALYZE command:**\n```sql\nCREATE TABLE users (id INTEGER, name TEXT, status TEXT);\nINSERT INTO users SELECT ... FROM generate_series(1, 1000);\n\nANALYZE users;\n\n-- Verify statistics were collected\nSELECT * FROM sqlite_stat1 WHERE tbl = 'users';\n-- Expected: row count = 1000\n```\n\n**Index selection based on selectivity:**\n```go\n// Create table with 1000 rows, 10% matching\ndb := createTestDB(1000, matchFraction=0.1)\n\n// Create index\ndb.Execute(\"CREATE INDEX idx_status ON users(status)\")\n\n// Query\nplan := db.PlanQuery(\"SELECT * FROM users WHERE status = 'rare'\")\n\n// Should choose index scan (10% < 20% threshold)\nassert.IsType(t, &IndexScanPath{}, plan.AccessPath)\n\n// Now with 50% matching\ndb = createTestDB(1000, matchFraction=0.5)\nplan = db.PlanQuery(\"SELECT * FROM users WHERE status = 'common'\")\n\n// Should choose table scan (50% > 20% threshold)\nassert.IsType(t, &TableScanPath{}, plan.AccessPath)\n```\n\n**EXPLAIN output:**\n```sql\nEXPLAIN SELECT * FROM users WHERE id = 500;\n-- Expected: Shows scan type, index name (if used), estimated rows\n\nEXPLAIN SELECT * FROM users WHERE status = 'active';\n-- Expected: Shows TABLE SCAN if status is common\n```\n\n**Join order optimization:**\n```sql\nCREATE TABLE orders (id INTEGER, customer_id INTEGER, status TEXT);\nCREATE TABLE customers (id INTEGER, country TEXT);\n\n-- 1 million orders, 1000 customers\nINSERT INTO orders ...\nINSERT INTO customers ...\n\nANALYZE;\n\nEXPLAIN SELECT * FROM orders o JOIN customers c ON o.customer_id = c.id WHERE c.country = 'US';\n-- Expected: Start with customers (smaller after filter), then join orders\n```\n\n**Fallback without statistics:**\n```sql\n-- New table, no ANALYZE\nCREATE TABLE new_table (id INTEGER, value TEXT);\nINSERT INTO new_table VALUES (1, 'a'), (2, 'b');\n\nEXPLAIN SELECT * FROM new_table WHERE id = 1;\n-- Expected: Uses default assumptions, still produces a valid plan\n```\n\n---\n\n## Knowledge Cascade: What This Unlocks\n\nYou've just implemented **cost-based query optimization**—the intelligence layer that makes databases fast. Here's where this connects:\n\n**Immediate connections:**\n- **Previous milestones**: The planner chooses between the table scan (Milestone 6) and index scan (Milestone 7) paths you built. Without the planner, indexes are useless—the database wouldn't know when to use them.\n- **EXPLAIN in production**: Every production database query you debug will involve reading an EXPLAIN output. You now understand what \"rows=1000\" and \"cost=14.00\" mean.\n\n**Same domain:**\n- **Adaptive query execution in Spark/Presto**: Modern query engines can re-optimize mid-query. If actual cardinalities differ from estimates, they switch strategies on the fly. Your planner is static; theirs is dynamic—but the cost model is the same.\n- **Database hints and forced plans**: When the planner gets it wrong, production systems need escape hatches. MySQL's `FORCE INDEX`, PostgreSQL's `SET enable_seqscan = off`, and Oracle's hints all exist because cost models aren't perfect.\n- **Materialized view selection**: Choosing which views to materialize is a planning problem. The same cost-benefit analysis (storage cost vs query speed) applies.\n\n**Cross-domain:**\n- **Compiler optimization passes**: LLVM and GCC run multiple optimization passes, each with a cost model. Dead code elimination, loop unrolling, and function inlining all follow cost-benefit analysis. A loop that runs 3 times shouldn't be unrolled; a loop that runs 1000000 times should. The same selectivity logic applies.\n- **Network routing protocols**: OSPF and BGP use cost-based path selection. Each router estimates the \"cost\" of paths through neighbors and chooses the cheapest. The analogy is exact: network topology ≈ join graph, link cost ≈ I/O cost, path selection ≈ join ordering.\n- **Machine learning cost models**: Neo4J and other modern databases use ML models trained on query logs to predict execution time. Your cost model is hand-crafted; theirs is learned. But both estimate cost from statistics.\n- **Caching decisions in CDNs**: A CDN must decide whether to cache content at edge locations. The decision depends on request frequency (selectivity), content size (I/O cost), and storage cost. Same tradeoffs, different domain.\n\n**Forward:**\n- **With this knowledge, you could now build**: A query advisor that analyzes slow query logs and recommends indexes; a database tuner that suggests when to run ANALYZE; or a query visualizer that shows why the planner chose a particular plan.\n\nThe query planner is where database theory meets engineering reality. Statistics are imperfect, cost models are approximations, and yet—most of the time—the planner gets it right. Understanding why it sometimes gets it wrong (and how to fix it) is a skill that separates database experts from application developers.\n\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-sqlite-m9 -->\n# Milestone 9: Transactions (Rollback Journal)\n\n## Where We Are in the System\n\n\n![SQLite Architecture: The Complete System Map](./diagrams/diag-satellite-overview.svg)\n\n\nYour database can parse SQL, compile it to bytecode, execute queries against B-trees, and use indexes to accelerate lookups. But there's a catastrophic vulnerability hiding in plain sight.\n\nPull the power cord at the wrong moment, and your database file becomes corrupt. Not \"some data lost\" corrupt—arbitrarily, unrecoverably corrupt. A half-written page here, a missing index entry there, and the entire file is garbage.\n\nTransactions are the armor against this existential threat. They guarantee **atomicity**: either all changes commit, or none do. A crash at any instant leaves the database in a consistent state. This is not optional—it's the defining characteristic of a database versus a file format.\n\n---\n\n## The Revelation: Durability Requires Write Ordering, Not Immediate Writes\n\nHere's what most developers assume: \"To ensure durability, I should write data to disk immediately. If the OS buffers writes, I'll lose data on crash, so I'll disable all caching and use O_SYNC on every write.\"\n\nThis assumption is catastrophically wrong. Immediate writes don't solve the problem—they make it worse.\n\n### The Torn Page Problem\n\nConsider a B-tree page being updated. The page is 4096 bytes. You modify a cell, adjust the header, update the free space pointer. Then you write the page to disk.\n\nA crash mid-write might leave only the first 2048 bytes on disk. This is a **torn page**—half old data, half new data, completely invalid.\n\nIf you were updating the B-tree root page, the entire tree is now corrupt. Every query will crash or return garbage.\n\n\n![Crash Recovery: All Failure Modes](./diagrams/diag-crash-recovery-scenarios.svg)\n\n\n### The Write Ordering Solution\n\nYou cannot prevent crashes. You cannot prevent torn pages. What you *can* do is ensure that **after any crash, you can recover to a consistent state**.\n\nThe rollback journal is the key:\n\n1. **Before** modifying any page in the database file, write the original page to the journal\n2. **fsync** the journal to ensure it's on stable storage\n3. **Then** modify the database file\n4. On commit, delete the journal\n\nIf a crash occurs:\n- **Before journal fsync**: The journal is incomplete or missing. The database is unchanged. Consistent.\n- **After journal fsync, before database write completes**: The journal has original pages. On restart, detect the \"hot journal\" and restore from it. Consistent.\n- **After commit (journal deleted)**: All changes are in the database. Consistent.\n\n\n![Rollback Journal: Write Ordering](./diagrams/diag-rollback-journal-flow.svg)\n\n\nThe critical insight: **the journal must be durable before the database is modified**. This is write ordering. Not \"write immediately\"—write in a specific sequence that guarantees recoverability.\n\n### What the Journal Contains\n\nThe journal stores **complete original page images**:\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│ Journal Header                                              │\n│ - Magic number (identifies this as a journal)               │\n│ - Database page count                                       │\n│ - Checksum algorithm ID                                     │\n│ - Salt values for checksum                                  │\n└─────────────────────────────────────────────────────────────┘\n┌─────────────────────────────────────────────────────────────┐\n│ Page Record 1                                               │\n│ - Page number (4 bytes)                                     │\n│ - Page data (4096 bytes, the ORIGINAL content)              │\n│ - Checksum                                                  │\n└─────────────────────────────────────────────────────────────┘\n┌─────────────────────────────────────────────────────────────┐\n│ Page Record 2                                               │\n│ - Page number                                               │\n│ - Page data (another original page)                         │\n│ - Checksum                                                  │\n└─────────────────────────────────────────────────────────────┘\n│ ... additional page records ...                             |\n└─────────────────────────────────────────────────────────────┘\n```\n\nEach page record is a complete 4096-byte snapshot of the page *before* it was modified. On recovery, you copy these pages back into the database file, overwriting any partial or torn writes.\n\n---\n\n## The Tension: Durability vs Performance\n\nEvery transaction involves:\n\n1. Write original pages to journal\n2. fsync journal\n3. Write modified pages to database\n4. fsync database (optional, depends on pragma)\n5. Delete journal\n6. fsync directory (to ensure journal deletion is durable)\n\nEach `fsync` is a disk round-trip: 25-100 microseconds on SSD, 5-10 milliseconds on HDD. A transaction touching 10 pages might require 3+ fsyncs—that's potentially 30+ milliseconds of pure waiting.\n\n**The constraint**: Durability requires fsync. Performance hates fsync. You cannot have both fast commits and guaranteed durability.\n\nThe tension manifests in production as:\n- **Users disable fsync** (`PRAGMA synchronous=OFF`) for speed, accepting data loss on crash\n- **Group commits** batch multiple transactions into one fsync\n- **WAL mode** (next milestone) reduces fsync frequency by logging changes instead of pages\n\nFor rollback journal mode, accept the cost: durable transactions are slow. That's the tradeoff.\n\n---\n\n## Three-Level View: From SQL Transaction to Disk Operations\n\n| Level | What Happens | Durability Guarantee |\n|-------|--------------|---------------------|\n| **SQL** | BEGIN, execute statements, COMMIT/ROLLBACK | User's mental model of \"all or nothing\" |\n| **Buffer Pool** | Pages are marked dirty, journal records original content | In-memory state tracks what needs recovery |\n| **Disk** | Journal write → fsync → database write → journal delete | Physical write ordering ensures crash recovery |\n\nThe transaction manager coordinates these levels, translating SQL semantics into disk operations with correct ordering.\n\n---\n\n## ACID: The Four Pillars\n\nBefore diving into implementation, understand what you're guaranteeing:\n\n| Property | Meaning | How Rollback Journal Implements It |\n|----------|---------|-----------------------------------|\n| **Atomicity** | All changes commit, or none do | Journal enables rollback on crash |\n| **Consistency** | Database transitions from one valid state to another | Constraint checking (NOT NULL, UNIQUE) before commit |\n| **Isolation** | Concurrent transactions don't see each other's partial work | Locking (simplified: one writer at a time) |\n| **Durability** | Committed changes survive crashes | fsync journal before database modification |\n\nThis milestone focuses on **Atomicity** and **Durability** via the rollback journal. **Consistency** is implemented by constraint checking in earlier milestones. **Isolation** requires locking, which we'll cover at a basic level.\n\n---\n\n## Building the Transaction Manager\n\n### Transaction State\n\n```go\ntype TransactionState int\n\nconst (\n    TxNone TransactionState = iota  // No active transaction\n    TxActive                         // BEGIN executed, waiting for COMMIT/ROLLBACK\n    TxCommitted                      // COMMIT executed\n    TxRolledBack                     // ROLLBACK executed\n)\n\ntype TransactionManager struct {\n    state       TransactionState\n    bufferPool  *BufferPool\n    journal     *RollbackJournal\n    modifiedPages map[PageID][]byte  // Original content of modified pages\n    dbFile      *os.File\n    dbPath      string\n}\n\nfunc (tm *TransactionManager) Begin() error {\n    if tm.state == TxActive {\n        return errors.New(\"transaction already active\")\n    }\n    \n    tm.state = TxActive\n    tm.modifiedPages = make(map[PageID][]byte)\n    \n    return nil\n}\n```\n\n### The Rollback Journal Structure\n\n```go\ntype RollbackJournal struct {\n    path       string  // dbPath + \"-journal\"\n    file       *os.File\n    header     JournalHeader\n    pageRecords []PageRecord\n    isOpen     bool\n}\n\ntype JournalHeader struct {\n    Magic        uint32  // 0xd9d505f9 (SQLite's magic number)\n    FormatVersion uint32  // 1\n    PageCount    uint32  // Number of pages in database\n    ChecksumAlg  uint32  // Checksum algorithm\n    Salt1, Salt2 uint32  // Random values for checksum\n    Checksum1, Checksum2 uint32  // Header checksum\n}\n\ntype PageRecord struct {\n    PageNum  uint32\n    Data     []byte  // 4096 bytes\n    Checksum1, Checksum2 uint32\n}\n\nconst JournalMagic = 0xd9d505f9\nconst JournalHeaderSize = 28\n```\n\n### Creating the Journal\n\n```go\nfunc (tm *TransactionManager) createJournal() error {\n    journalPath := tm.dbPath + \"-journal\"\n    \n    // Create the journal file\n    file, err := os.Create(journalPath)\n    if err != nil {\n        return fmt.Errorf(\"failed to create journal: %w\", err)\n    }\n    \n    tm.journal = &RollbackJournal{\n        path:     journalPath,\n        file:     file,\n        pageRecords: make([]PageRecord, 0),\n        isOpen:   true,\n    }\n    \n    // Write journal header\n    header := JournalHeader{\n        Magic:         JournalMagic,\n        FormatVersion: 1,\n        PageCount:     tm.getPageCount(),\n        ChecksumAlg:   0,  // Simple checksum\n        Salt1:         rand.Uint32(),\n        Salt2:         rand.Uint32(),\n    }\n    \n    tm.journal.header = header\n    tm.writeJournalHeader()\n    \n    return nil\n}\n\nfunc (j *RollbackJournal) writeJournalHeader() error {\n    buf := make([]byte, JournalHeaderSize)\n    \n    binary.BigEndian.PutUint32(buf[0:4], j.header.Magic)\n    binary.BigEndian.PutUint32(buf[4:8], j.header.FormatVersion)\n    binary.BigEndian.PutUint32(buf[8:12], j.header.PageCount)\n    binary.BigEndian.PutUint32(buf[12:16], j.header.ChecksumAlg)\n    binary.BigEndian.PutUint32(buf[16:20], j.header.Salt1)\n    binary.BigEndian.PutUint32(buf[20:24], j.header.Salt2)\n    \n    // Calculate header checksum\n    cs1, cs2 := calculateChecksum(buf[0:24], j.header.Salt1, j.header.Salt2)\n    binary.BigEndian.PutUint32(buf[24:28], cs1)\n    \n    _, err := j.file.WriteAt(buf, 0)\n    return err\n}\n```\n\n### Recording Page Modifications\n\nThe key moment: **before any page is modified, record its original content**.\n\n```go\nfunc (tm *TransactionManager) BeforePageModified(pageID PageID, pageData []byte) error {\n    if tm.state != TxActive {\n        return nil  // Not in a transaction, nothing to journal\n    }\n    \n    // Check if we've already recorded this page\n    if _, exists := tm.modifiedPages[pageID]; exists {\n        return nil  // Already saved the original\n    }\n    \n    // Save the original page content\n    original := make([]byte, len(pageData))\n    copy(original, pageData)\n    tm.modifiedPages[pageID] = original\n    \n    // Write to journal\n    return tm.journal.WritePageRecord(pageID.PageNum, original)\n}\n\nfunc (j *RollbackJournal) WritePageRecord(pageNum uint32, data []byte) error {\n    record := PageRecord{\n        PageNum: pageNum,\n        Data:    data,\n    }\n    \n    // Calculate checksum\n    record.Checksum1, record.Checksum2 = calculateChecksum(data, \n        j.header.Salt1, j.header.Salt2)\n    \n    j.pageRecords = append(j.pageRecords, record)\n    \n    // Write to file: page number + data + checksum\n    buf := make([]byte, 4 + len(data) + 4)\n    binary.BigEndian.PutUint32(buf[0:4], pageNum)\n    copy(buf[4:4+len(data)], data)\n    binary.BigEndian.PutUint32(buf[4+len(data):], record.Checksum1)\n    \n    offset := int64(JournalHeaderSize + len(j.pageRecords) - 1) * int64(4 + len(data) + 4)\n    _, err := j.file.WriteAt(buf, offset)\n    \n    return err\n}\n```\n\n### Integration with Buffer Pool\n\nThe buffer pool must call `BeforePageModified` when a page is first modified:\n\n```go\nfunc (bp *BufferPool) MarkDirty(pageID PageID) error {\n    frameIdx, exists := bp.pageTable[pageID]\n    if !exists {\n        return errors.New(\"page not in buffer pool\")\n    }\n    \n    meta := &bp.metadata[frameIdx]\n    \n    // First modification in transaction?\n    if !meta.Dirty && bp.txManager != nil && bp.txManager.state == TxActive {\n        // Record original content before marking dirty\n        err := bp.txManager.BeforePageModified(pageID, bp.frames[frameIdx])\n        if err != nil {\n            return err\n        }\n    }\n    \n    meta.Dirty = true\n    return nil\n}\n```\n\n---\n\n## COMMIT: Making Changes Permanent\n\n```go\nfunc (tm *TransactionManager) Commit() error {\n    if tm.state != TxActive {\n        return errors.New(\"no active transaction\")\n    }\n    \n    // 1. Sync the journal to disk\n    // This ensures all original pages are durable BEFORE we modify the database\n    if err := tm.journal.file.Sync(); err != nil {\n        return fmt.Errorf(\"failed to sync journal: %w\", err)\n    }\n    \n    // 2. Write all dirty pages to the database file\n    if err := tm.bufferPool.FlushAll(); err != nil {\n        return fmt.Errorf(\"failed to flush dirty pages: %w\", err)\n    }\n    \n    // 3. Sync the database file\n    // This ensures modified pages are on disk\n    if err := tm.dbFile.Sync(); err != nil {\n        return fmt.Errorf(\"failed to sync database: %w\", err)\n    }\n    \n    // 4. Delete the journal\n    // Once the journal is deleted, the transaction is committed\n    if err := tm.deleteJournal(); err != nil {\n        return fmt.Errorf(\"failed to delete journal: %w\", err)\n    }\n    \n    // 5. Sync the directory to ensure journal deletion is durable\n    if err := tm.syncDirectory(); err != nil {\n        return fmt.Errorf(\"failed to sync directory: %w\", err)\n    }\n    \n    tm.state = TxCommitted\n    tm.modifiedPages = nil\n    \n    return nil\n}\n\nfunc (tm *TransactionManager) deleteJournal() error {\n    if tm.journal == nil {\n        return nil\n    }\n    \n    tm.journal.file.Close()\n    \n    err := os.Remove(tm.journal.path)\n    tm.journal = nil\n    \n    return err\n}\n\nfunc (tm *TransactionManager) syncDirectory() error {\n    dirPath := filepath.Dir(tm.dbPath)\n    dirFile, err := os.Open(dirPath)\n    if err != nil {\n        return err\n    }\n    defer dirFile.Close()\n    \n    return dirFile.Sync()\n}\n```\n\n### The Critical Write Ordering\n\n```\n┌──────────────────────────────────────────────────────────────────────┐\n│                        COMMIT WRITE ORDERING                         │\n├──────────────────────────────────────────────────────────────────────┤\n│                                                                      │\n│   1. Write journal (original pages)                                  │\n│      │                                                               │\n│      ▼                                                               │\n│   2. fsync journal  ◄─── CRITICAL POINT                              │\n│      │                   Journal is now durable                      │\n│      ▼                   Recovery is possible                        │\n│   3. Write database (modified pages)                                 │\n│      │                                                               │\n│      ▼                                                               │\n│   4. fsync database                                                  │\n│      │                                                               │\n│      ▼                                                               │\n│   5. Delete journal                                                  │\n│      │                                                               │\n│      ▼                                                               │\n│   6. fsync directory                                                 │\n│      │                                                               │\n│      ▼                                                               │\n│   COMMIT COMPLETE                                                    │\n│                                                                      │\n└──────────────────────────────────────────────────────────────────────┘\n```\n\nIf you crash at any point:\n- **Before step 2**: Journal may be incomplete. Database unchanged. On restart, no hot journal detected. No recovery needed.\n- **After step 2, before step 5**: Journal is durable. Database may be partially written. On restart, hot journal detected. Restore from journal.\n- **After step 5**: Journal is deleted. All changes are in the database. Transaction committed.\n\n---\n\n## ROLLBACK: Undoing Changes\n\n```go\nfunc (tm *TransactionManager) Rollback() error {\n    if tm.state != TxActive {\n        return errors.New(\"no active transaction\")\n    }\n    \n    // 1. Restore all pages from the journal\n    for pageID, originalData := range tm.modifiedPages {\n        if err := tm.restorePage(pageID, originalData); err != nil {\n            return err\n        }\n    }\n    \n    // 2. Invalidate modified pages in buffer pool\n    for pageID := range tm.modifiedPages {\n        tm.bufferPool.InvalidatePage(pageID)\n    }\n    \n    // 3. Delete the journal\n    if err := tm.deleteJournal(); err != nil {\n        return err\n    }\n    \n    tm.state = TxRolledBack\n    tm.modifiedPages = nil\n    \n    return nil\n}\n\nfunc (tm *TransactionManager) restorePage(pageID PageID, data []byte) error {\n    // Write the original page back to the database file\n    offset := int64(pageID.PageNum) * int64(tm.bufferPool.pageSize)\n    \n    _, err := tm.dbFile.WriteAt(data, offset)\n    return err\n}\n```\n\n### Buffer Pool Invalidation\n\nAfter rollback, any cached copies of modified pages in the buffer pool are stale. They must be invalidated:\n\n```go\nfunc (bp *BufferPool) InvalidatePage(pageID PageID) {\n    frameIdx, exists := bp.pageTable[pageID]\n    if !exists {\n        return\n    }\n    \n    // Mark the frame as empty\n    delete(bp.pageTable, pageID)\n    bp.metadata[frameIdx] = FrameMetadata{\n        PageID: PageID{FileID: -1, PageNum: -1},\n    }\n}\n```\n\n---\n\n## Crash Recovery: Detecting and Applying the Hot Journal\n\nOn database startup, check for a hot journal:\n\n```go\nfunc (db *Database) recoverFromCrash() error {\n    journalPath := db.path + \"-journal\"\n    \n    // Check if journal exists\n    if _, err := os.Stat(journalPath); os.IsNotExist(err) {\n        // No journal, database is clean\n        return nil\n    }\n    \n    fmt.Printf(\"Hot journal detected at %s, initiating recovery...\\n\", journalPath)\n    \n    // Open and validate the journal\n    journal, err := openJournal(journalPath)\n    if err != nil {\n        return fmt.Errorf(\"failed to open journal: %w\", err)\n    }\n    defer journal.Close()\n    \n    // Read all page records and restore them\n    for {\n        record, err := journal.ReadNextPageRecord()\n        if err == io.EOF {\n            break\n        }\n        if err != nil {\n            return fmt.Errorf(\"failed to read journal record: %w\", err)\n        }\n        \n        // Verify checksum\n        cs1, cs2 := calculateChecksum(record.Data, journal.header.Salt1, journal.header.Salt2)\n        if cs1 != record.Checksum1 || cs2 != record.Checksum2 {\n            return fmt.Errorf(\"journal checksum mismatch for page %d\", record.PageNum)\n        }\n        \n        // Restore the page\n        offset := int64(record.PageNum) * int64(db.pageSize)\n        _, err = db.file.WriteAt(record.Data, offset)\n        if err != nil {\n            return fmt.Errorf(\"failed to restore page %d: %w\", record.PageNum, err)\n        }\n        \n        fmt.Printf(\"  Restored page %d\\n\", record.PageNum)\n    }\n    \n    // Sync the database\n    db.file.Sync()\n    \n    // Delete the journal\n    os.Remove(journalPath)\n    \n    fmt.Println(\"Recovery complete.\")\n    return nil\n}\n\nfunc openJournal(path string) (*RollbackJournal, error) {\n    file, err := os.Open(path)\n    if err != nil {\n        return nil, err\n    }\n    \n    // Read header\n    headerBuf := make([]byte, JournalHeaderSize)\n    if _, err := file.ReadAt(headerBuf, 0); err != nil {\n        file.Close()\n        return nil, err\n    }\n    \n    header := JournalHeader{\n        Magic:         binary.BigEndian.Uint32(headerBuf[0:4]),\n        FormatVersion: binary.BigEndian.Uint32(headerBuf[4:8]),\n        PageCount:     binary.BigEndian.Uint32(headerBuf[8:12]),\n        ChecksumAlg:   binary.BigEndian.Uint32(headerBuf[12:16]),\n        Salt1:         binary.BigEndian.Uint32(headerBuf[16:20]),\n        Salt2:         binary.BigEndian.Uint32(headerBuf[20:24]),\n        Checksum1:     binary.BigEndian.Uint32(headerBuf[24:28]),\n    }\n    \n    // Verify magic number\n    if header.Magic != JournalMagic {\n        file.Close()\n        return nil, errors.New(\"invalid journal magic number\")\n    }\n    \n    return &RollbackJournal{\n        path:   path,\n        file:   file,\n        header: header,\n        isOpen: true,\n    }, nil\n}\n\nfunc (j *RollbackJournal) ReadNextPageRecord() (*PageRecord, error) {\n    recordSize := 4 + 4096 + 4  // page num + data + checksum\n    buf := make([]byte, recordSize)\n    \n    offset := int64(JournalHeaderSize + len(j.pageRecords) * recordSize)\n    \n    _, err := j.file.ReadAt(buf, offset)\n    if err != nil {\n        return nil, err\n    }\n    \n    record := &PageRecord{\n        PageNum:  binary.BigEndian.Uint32(buf[0:4]),\n        Data:     buf[4 : 4+4096],\n        Checksum1: binary.BigEndian.Uint32(buf[4+4096:]),\n    }\n    \n    j.pageRecords = append(j.pageRecords, *record)\n    \n    return record, nil\n}\n```\n\n---\n\n## Isolation: Basic Locking\n\nFor this milestone, implement a simple locking scheme: **one writer at a time**.\n\n```go\ntype LockManager struct {\n    writeLock bool\n    readers   int\n    mutex     sync.Mutex\n}\n\nfunc (lm *LockManager) AcquireWriteLock() error {\n    lm.mutex.Lock()\n    defer lm.mutex.Unlock()\n    \n    if lm.writeLock {\n        return errors.New(\"database is locked (write in progress)\")\n    }\n    if lm.readers > 0 {\n        return errors.New(\"database is locked (readers active)\")\n    }\n    \n    lm.writeLock = true\n    return nil\n}\n\nfunc (lm *LockManager) ReleaseWriteLock() {\n    lm.mutex.Lock()\n    defer lm.mutex.Unlock()\n    \n    lm.writeLock = false\n}\n\nfunc (lm *LockManager) AcquireReadLock() error {\n    lm.mutex.Lock()\n    defer lm.mutex.Unlock()\n    \n    if lm.writeLock {\n        return errors.New(\"database is locked (write in progress)\")\n    }\n    \n    lm.readers++\n    return nil\n}\n\nfunc (lm *LockManager) ReleaseReadLock() {\n    lm.mutex.Lock()\n    defer lm.mutex.Unlock()\n    \n    lm.readers--\n}\n```\n\n### Transaction Visibility\n\nChanges made during a transaction are **not visible to other connections** until COMMIT:\n\n```go\nfunc (db *Database) ExecuteWrite(sql string) error {\n    // Acquire write lock\n    if err := db.lockManager.AcquireWriteLock(); err != nil {\n        return err\n    }\n    defer db.lockManager.ReleaseWriteLock()\n    \n    // Start transaction\n    db.txManager.Begin()\n    \n    // Execute the statement\n    // ... (this will modify pages and journal them)\n    \n    // Commit\n    return db.txManager.Commit()\n}\n```\n\nOther connections attempting to write will block until the transaction completes. Readers see the database state as of the last committed transaction.\n\n---\n\n## SQL Interface: BEGIN, COMMIT, ROLLBACK\n\n```go\nfunc (p *Parser) parseTransactionStatement() (Statement, error) {\n    if p.current.Type == KEYWORD && p.current.Value == \"BEGIN\" {\n        p.advance()\n        return &BeginStatement{}, nil\n    }\n    \n    if p.current.Type == KEYWORD && p.current.Value == \"COMMIT\" {\n        p.advance()\n        return &CommitStatement{}, nil\n    }\n    \n    if p.current.Type == KEYWORD && p.current.Value == \"ROLLBACK\" {\n        p.advance()\n        return &RollbackStatement{}, nil\n    }\n    \n    return nil, p.error(\"expected BEGIN, COMMIT, or ROLLBACK\")\n}\n\nfunc (db *Database) ExecuteTransactionStatement(stmt Statement) error {\n    switch s := stmt.(type) {\n    case *BeginStatement:\n        return db.txManager.Begin()\n    case *CommitStatement:\n        return db.txManager.Commit()\n    case *RollbackStatement:\n        return db.txManager.Rollback()\n    }\n    return nil\n}\n```\n\n### Auto-Commit Mode\n\nBy default, each statement is its own transaction (auto-commit):\n\n```go\nfunc (db *Database) Execute(sql string) error {\n    // If not in explicit transaction, auto-commit\n    autoCommit := db.txManager.state != TxActive\n    \n    if autoCommit {\n        db.txManager.Begin()\n    }\n    \n    // Parse and execute\n    stmt, err := db.parser.Parse(sql)\n    if err != nil {\n        if autoCommit {\n            db.txManager.Rollback()\n        }\n        return err\n    }\n    \n    err = db.executeStatement(stmt)\n    \n    if autoCommit {\n        if err != nil {\n            db.txManager.Rollback()\n        } else {\n            err = db.txManager.Commit()\n        }\n    }\n    \n    return err\n}\n```\n\n---\n\n## Common Pitfalls\n\n### 1. Writing Database Before Journal\n\n```go\n// WRONG: Modify database, then journal\nbp.MarkDirty(pageID)\nmodifyPage(page)\ntm.journal.WritePageRecord(pageID, originalData)\n\n// RIGHT: Journal first, then modify\ntm.journal.WritePageRecord(pageID, originalData)\nbp.MarkDirty(pageID)\nmodifyPage(page)\n```\n\nIf you crash after modifying the database but before writing the journal, you have no way to undo the change. The database is corrupt.\n\n### 2. Forgetting to fsync the Journal\n\n```go\n// WRONG: No fsync\ntm.journal.file.Write(journalData)\ntm.bufferPool.FlushAll()  // Write database immediately\n\n// RIGHT: fsync journal first\ntm.journal.file.Write(journalData)\ntm.journal.file.Sync()    // Ensure journal is durable\ntm.bufferPool.FlushAll()  // Now write database\n```\n\nWithout the fsync, the journal write might be in the OS cache. A crash loses the journal, and you can't recover.\n\n### 3. Partial Page Writes (Torn Pages)\n\n```go\n// WRONG: Assume writes are atomic\ntm.dbFile.WriteAt(pageData, offset)  // Might write only partial data!\n\n// RIGHT: Journal contains complete pages\n// Journal has the full 4096-byte original\n// Recovery restores the complete page, overwriting any torn write\n```\n\nThe journal must contain **complete** page images. If a page is partially written during a crash, recovery overwrites it with the complete original from the journal.\n\n### 4. Not Detecting Hot Journals on Startup\n\n```go\n// WRONG: Open database without checking for journal\nfunc (db *Database) Open(path string) error {\n    db.file, _ = os.OpenFile(path, os.O_RDWR, 0644)\n    return nil\n}\n\n// RIGHT: Check for hot journal first\nfunc (db *Database) Open(path string) error {\n    db.file, _ = os.OpenFile(path, os.O_RDWR, 0644)\n    \n    // Check for hot journal\n    if err := db.recoverFromCrash(); err != nil {\n        db.file.Close()\n        return err\n    }\n    \n    return nil\n}\n```\n\nIf you don't check for hot journals, an interrupted transaction leaves the database in an inconsistent state forever.\n\n### 5. Lock Deadlocks\n\nWith multiple connections and fine-grained locking, deadlocks are possible:\n\n```\nConnection A: Lock table users\nConnection B: Lock table orders\nConnection A: Wait for orders (blocked)\nConnection B: Wait for users (blocked)\n```\n\n**Simple solution**: Single write lock (what we implemented). One writer at a time eliminates deadlocks at the cost of concurrency.\n\n---\n\n## Test Suite: What to Verify\n\n**BEGIN/COMMIT/ROLLBACK commands:**\n```sql\nBEGIN;\nINSERT INTO users VALUES (1, 'Alice');\nCOMMIT;\nSELECT * FROM users;\n-- Expected: (1, 'Alice')\n\nBEGIN;\nINSERT INTO users VALUES (2, 'Bob');\nROLLBACK;\nSELECT * FROM users;\n-- Expected: Only (1, 'Alice'), Bob was rolled back\n```\n\n**Journal file creation:**\n```go\ndb.Execute(\"BEGIN\")\ndb.Execute(\"INSERT INTO users VALUES (1, 'Alice')\")\n\n// Journal file should exist\n_, err := os.Stat(db.path + \"-journal\")\nassert.NoError(t, err)\n\ndb.Execute(\"COMMIT\")\n\n// Journal file should be deleted\n_, err = os.Stat(db.path + \"-journal\")\nassert.True(t, os.IsNotExist(err))\n```\n\n**Write ordering verification:**\n```go\n// Track fsync order\nvar fsyncOrder []string\n\nmockDisk := &MockDiskManager{\n    OnFsync: func(path string) {\n        fsyncOrder = append(fsyncOrder, path)\n    },\n}\n\ndb.Execute(\"BEGIN\")\ndb.Execute(\"INSERT INTO users VALUES (1, 'Alice')\")\ndb.Execute(\"COMMIT\")\n\n// Journal should be fsync'd before database\nassert.Equal(t, []string{\"journal\", \"database\", \"directory\"}, fsyncOrder)\n```\n\n**Crash recovery:**\n```go\n// Simulate a crash\ndb.Execute(\"BEGIN\")\ndb.Execute(\"INSERT INTO users VALUES (1, 'Alice')\")\n// COMMIT not called - simulate crash\n\n// Reopen database\ndb2 := OpenDatabase(db.path)\n\n// Should have detected hot journal and rolled back\nvar count int\ndb2.QueryRow(\"SELECT COUNT(*) FROM users\").Scan(&count)\nassert.Equal(t, 0, count)  // Transaction was rolled back\n```\n\n**Isolation:**\n```go\ndb1 := OpenDatabase(path)\ndb2 := OpenDatabase(path)\n\ndb1.Execute(\"BEGIN\")\ndb1.Execute(\"INSERT INTO users VALUES (1, 'Alice')\")\n\n// db2 should not see uncommitted changes\nvar count int\ndb2.QueryRow(\"SELECT COUNT(*) FROM users\").Scan(&count)\nassert.Equal(t, 0, count)\n\ndb1.Execute(\"COMMIT\")\n\n// Now db2 can see the changes\ndb2.QueryRow(\"SELECT COUNT(*) FROM users\").Scan(&count)\nassert.Equal(t, 1, count)\n```\n\n**Torn page simulation:**\n```go\n// Write partial page, then crash\ndb.Execute(\"BEGIN\")\ndb.Execute(\"INSERT INTO users VALUES (1, 'Alice')\")\n// Partially write database file, leave journal intact\nwritePartialPage(db.path, pageID, partialData)\n\n// Reopen - should recover\ndb2 := OpenDatabase(db.path)\n// Database should be in pre-transaction state\n```\n\n---\n\n## Knowledge Cascade: What This Unlocks\n\nYou've just implemented **ACID transactions with crash recovery**—the foundation of reliable data storage. Here's where this connects:\n\n**Immediate connections:**\n- **WAL mode (next milestone)**: The rollback journal enables recovery but blocks readers during writes. WAL is an alternative that enables concurrent readers and writers using the same journaling principle.\n- **All previous milestones**: Every B-tree modification, every index update, every INSERT/UPDATE/DELETE now participates in a transaction. The database is no longer fragile—it survives crashes.\n\n**Same domain:**\n- **Database replication**: Transaction logs shipped to replicas are essentially journals. The replica replays the log to catch up. Same write-ahead principle, different context.\n- **Point-in-time recovery**: If you keep journals (archive them instead of deleting), you can restore a database to any point in time. This is how production databases recover from user errors.\n- **Distributed transactions (2PC)**: Two-phase commit extends the rollback journal concept across multiple databases. Each participant logs its intention before committing, enabling atomic cross-database transactions.\n\n**Cross-domain:**\n- **Git object model**: Git's append-only object store is a form of journaling. Commits are atomic snapshots—if the write is interrupted, the commit doesn't exist. The ref update is the \"commit\" point, analogous to journal deletion.\n- **File system journaling (ext4, HFS+, NTFS)**: Modern file systems use the same technique. Metadata changes are logged before being applied. A crash mid-operation is recovered by replaying or rolling back the journal.\n- **Crash-only software design**: Systems designed to recover from crashes are more robust than those trying to prevent crashes. Your database now embodies this principle: pull the power cord, restart, and it just works.\n- **Distributed consensus (Raft, Paxos)**: Write-ahead logging is the foundation of distributed atomic commitment. A Raft leader logs commands before applying them; followers acknowledge before committing. The journal is the persistent log that enables recovery and consensus.\n\n**Forward:**\n- **With this knowledge, you could now build**: A database backup system that copies the database file while transactions are in progress (copy + journal + recover); a change data capture (CDC) system that monitors the journal for changes; or a distributed database that replicates journals across nodes.\n\nThe rollback journal is where databases transition from \"interesting exercise\" to \"production-ready system.\" You can now store critical data—financial transactions, user accounts, medical records—with confidence that a power failure won't corrupt it. This is the trust that makes databases valuable.\n\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-sqlite-m10 -->\n# Milestone 10: WAL Mode\n\n## Where We Are in the System\n\n\n![SQLite Architecture: The Complete System Map](./diagrams/diag-satellite-overview.svg)\n\n\nYour rollback journal provides ACID transactions with crash recovery. But it has a fundamental limitation: **writers block readers**.\n\nWhen a transaction modifies the database:\n1. The rollback journal is created\n2. Pages are modified in the database file\n3. Until COMMIT, no other connection can safely read the database\n\nThis is because the database file itself is being modified. A reader that opens mid-transaction might see half-written pages, inconsistent indexes, or partial updates. The only safe approach is to block all readers during writes.\n\nFor read-heavy workloads (web applications, analytics), this is tolerable. For mixed workloads with concurrent reads and writes, it's a bottleneck. A long-running write transaction blocks all reads for its entire duration.\n\nWrite-Ahead Logging (WAL) solves this by **never modifying the database file during a transaction**. Instead, changes are appended to a separate WAL file. Readers see a consistent snapshot of the database while writers append new versions. This enables true concurrent reads and writes—at the cost of additional complexity.\n\n---\n\n## The Revelation: WAL Enables True Concurrency\n\nHere's what most developers assume: \"WAL and rollback journal are equivalent approaches to durability. WAL just appends instead of overwriting, but the performance is the same.\"\n\nThis assumption is wrong. WAL doesn't just change *where* writes go—it fundamentally transforms the concurrency model.\n\n### The Reader-Writer Conflict in Rollback Journal Mode\n\n\n![Rollback Journal vs WAL: Architecture Comparison](./diagrams/diag-rollback-vs-wal.svg)\n\n\nIn rollback journal mode:\n\n```\nTimeline:\n─────────────────────────────────────────────────────────────\nWriter:  BEGIN ──► Modify pages ──► COMMIT\n                      │\n                      ▼\nReaders: BLOCKED ═════════════════► UNBLOCKED\n```\n\nThe database file is the source of truth. When a writer modifies it, readers can't safely access it. The lock must be held for the entire transaction duration.\n\n### WAL Mode: Readers and Writers Coexist\n\nIn WAL mode:\n\n```\nTimeline:\n─────────────────────────────────────────────────────────────\nWriter:  BEGIN ──► Append to WAL ──► COMMIT\n                      │\n                      ▼\nWAL:     [Page v1] ──► [Page v2] ──► [Page v3]\n                      │\nReaders: ════════════════════════════════════════\n         Read snapshot from DB + WAL up to point X\n```\n\nThe database file is **never modified during a transaction**. All changes go to the WAL. Readers:\n1. Note the current WAL position when they start\n2. Read pages from the database file OR the WAL (whichever is newer)\n3. See a consistent snapshot as of their start time\n\nA writer appending to the WAL doesn't affect a reader that started earlier—the reader simply doesn't see those newer WAL entries.\n\n{{DIAGRAM:diag-wal-architecture}}\n\n### The Cost: Complexity and Checkpointing\n\nThis concurrency isn't free:\n\n1. **Checkpointing**: The WAL grows with every write. Periodically, its contents must be merged back into the database file. This is a checkpoint—a batch operation that blocks briefly.\n\n2. **Page version lookup**: Readers must check the WAL for newer versions of pages before falling back to the database. This requires a **WAL-index**—a shared memory structure mapping (page number → latest WAL position).\n\n3. **Snapshot management**: Each reader pins a \"snapshot\" of the WAL. The WAL can't be checkpointed past the oldest active snapshot, or that reader would lose access to pages it might still need.\n\n4. **Recovery complexity**: On crash, the WAL must be replayed to restore uncommitted changes. The replay logic is more complex than rollback journal recovery.\n\nThe WAL is a bet that the concurrency gain outweighs the complexity cost. For most workloads, it's the right bet—which is why WAL is the default in PostgreSQL, MySQL's InnoDB, and modern SQLite deployments.\n\n---\n\n## The Tension: WAL Growth vs Checkpoint Frequency\n\nEvery write appends to the WAL. Without checkpointing, the WAL grows unbounded:\n\n| Scenario | WAL Size | Impact |\n|----------|----------|--------|\n| 1 million inserts, no checkpoint | ~4 GB | Disk space exhausted |\n| Checkpoint every 1000 pages | ~4 MB | Bounded, but frequent pauses |\n| Long-running reader + no checkpoint | Unbounded | Reader pins old WAL frames |\n\n**The constraint**: You must checkpoint frequently enough to bound WAL size, but not so frequently that checkpoint overhead dominates. And checkpointing is blocked by long-running readers.\n\nThis tension manifests as:\n- **Auto-checkpoint thresholds**: Trigger checkpoint after N pages (SQLite defaults to 1000)\n- **Passive vs aggressive checkpointing**: Passive checkpointing only copies pages not currently in use; aggressive checkpointing blocks writers to make progress\n- **WAL file size monitoring**: Production systems alert when WAL exceeds a threshold, indicating checkpoint issues\n\n---\n\n## Three-Level View: From SQL Write to WAL to Database\n\n| Level | What Happens | File Touched |\n|-------|--------------|--------------|\n| **Transaction** | INSERT/UPDATE/DELETE modifies pages | Pages modified in buffer pool |\n| **WAL Append** | Modified pages written to WAL with checksum | `.db-wal` file |\n| **Checkpoint** | WAL pages copied to database file | `.db` file |\n\nThe database file is only modified during checkpoints, not during regular transactions. This is the key to concurrent access.\n\n---\n\n## WAL File Format\n\nThe WAL file is a sequence of **frames**, each containing a page image and metadata:\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│ WAL Header (32 bytes)                                        │\n│ - Magic number (0x377f0682 or 0x377f0683)                   │\n│ - File format version                                        │\n│ - Page size                                                  │\n│ - Checkpoint sequence number                                 │\n│ - Salt-1, Salt-2 (random values for checksum)               │\n│ - Checksum-1, Checksum-2 (header checksum)                  │\n└─────────────────────────────────────────────────────────────┘\n┌─────────────────────────────────────────────────────────────┐\n│ Frame 1                                                      │\n│ - Frame header (24 bytes)                                    │\n│   - Page number (4 bytes)                                    │\n│   - Commit marker (4 bytes, non-zero for COMMIT frames)      │\n│   - Salt-1, Salt-2 (must match header)                      │\n│   - Checksum-1, Checksum-2 (cumulative checksum)            │\n│ - Page data (page_size bytes)                               │\n└─────────────────────────────────────────────────────────────┘\n┌─────────────────────────────────────────────────────────────┐\n│ Frame 2                                                      │\n│ - ... same structure ...                                     │\n└─────────────────────────────────────────────────────────────┘\n│ ... additional frames ...                                    │\n└─────────────────────────────────────────────────────────────┘\n```\n\n### WAL Header\n\n```go\ntype WALHeader struct {\n    Magic         uint32  // 0x377f0682 (little-endian) or 0x377f0683 (big-endian)\n    FormatVersion uint32  // 3007000\n    PageSize      uint32\n    CheckpointSeq uint32\n    Salt1         uint32\n    Salt2         uint32\n    Checksum1     uint32\n    Checksum2     uint32\n}\n\nconst WALHeaderSize = 32\nconst FrameHeaderSize = 24\n\nfunc (w *WAL) WriteHeader() error {\n    buf := make([]byte, WALHeaderSize)\n    \n    binary.BigEndian.PutUint32(buf[0:4], w.header.Magic)\n    binary.BigEndian.PutUint32(buf[4:8], w.header.FormatVersion)\n    binary.BigEndian.PutUint32(buf[8:12], w.header.PageSize)\n    binary.BigEndian.PutUint32(buf[12:16], w.header.CheckpointSeq)\n    binary.BigEndian.PutUint32(buf[16:20], w.header.Salt1)\n    binary.BigEndian.PutUint32(buf[20:24], w.header.Salt2)\n    \n    // Calculate header checksum\n    cs1, cs2 := walChecksum(buf[0:24], 0, 0, w.header.Magic)\n    binary.BigEndian.PutUint32(buf[24:28], cs1)\n    binary.BigEndian.PutUint32(buf[28:32], cs2)\n    \n    w.header.Checksum1 = cs1\n    w.header.Checksum2 = cs2\n    \n    _, err := w.file.WriteAt(buf, 0)\n    return err\n}\n```\n\n### Frame Structure\n\n```go\ntype FrameHeader struct {\n    PageNumber  uint32\n    CommitSize  uint32  // Database size in pages after commit, 0 if not a commit frame\n    Salt1       uint32\n    Salt2       uint32\n    Checksum1   uint32\n    Checksum2   uint32\n}\n\nfunc (w *WAL) WriteFrame(pageNum uint32, pageData []byte, isCommit bool, dbSize uint32) error {\n    frame := FrameHeader{\n        PageNumber: pageNum,\n        CommitSize: 0,\n        Salt1:      w.header.Salt1,\n        Salt2:      w.header.Salt2,\n    }\n    \n    if isCommit {\n        frame.CommitSize = dbSize\n    }\n    \n    // Calculate cumulative checksum\n    frame.Checksum1, frame.Checksum2 = walChecksum(\n        pageData,\n        w.lastChecksum1,\n        w.lastChecksum2,\n        w.header.Magic,\n    )\n    \n    // Write frame header\n    headerBuf := make([]byte, FrameHeaderSize)\n    binary.BigEndian.PutUint32(headerBuf[0:4], frame.PageNumber)\n    binary.BigEndian.PutUint32(headerBuf[4:8], frame.CommitSize)\n    binary.BigEndian.PutUint32(headerBuf[8:12], frame.Salt1)\n    binary.BigEndian.PutUint32(headerBuf[12:16], frame.Salt2)\n    binary.BigEndian.PutUint32(headerBuf[16:20], frame.Checksum1)\n    binary.BigEndian.PutUint32(headerBuf[20:24], frame.Checksum2)\n    \n    offset := int64(WALHeaderSize + w.frameCount * (FrameHeaderSize + w.pageSize))\n    \n    // Write header\n    if _, err := w.file.WriteAt(headerBuf, offset); err != nil {\n        return err\n    }\n    \n    // Write page data\n    if _, err := w.file.WriteAt(pageData, offset + FrameHeaderSize); err != nil {\n        return err\n    }\n    \n    w.frameCount++\n    w.lastChecksum1 = frame.Checksum1\n    w.lastChecksum2 = frame.Checksum2\n    \n    return nil\n}\n```\n\n### Checksum Algorithm\n\nThe WAL uses a cumulative checksum to detect corruption anywhere in the file:\n\n```go\nfunc walChecksum(data []byte, s1, s2 uint32, magic uint32) (uint32, uint32) {\n    // SQLite uses a modified Fletcher-32 checksum\n    // The algorithm depends on the magic number's endianness\n    \n    if magic == 0x377f0683 {\n        // Big-endian checksum\n        for i := 0; i < len(data); i += 8 {\n            if i+8 <= len(data) {\n                v1 := binary.BigEndian.Uint32(data[i : i+4])\n                v2 := binary.BigEndian.Uint32(data[i+4 : i+8])\n                s1 += v1 + s2\n                s2 += v2 + s1\n            }\n        }\n    } else {\n        // Little-endian checksum\n        for i := 0; i < len(data); i += 8 {\n            if i+8 <= len(data) {\n                v1 := binary.LittleEndian.Uint32(data[i : i+4])\n                v2 := binary.LittleEndian.Uint32(data[i+4 : i+8])\n                s1 += v1 + s2\n                s2 += v2 + s1\n            }\n        }\n    }\n    \n    return s1, s2\n}\n```\n\n---\n\n## WAL Page Lookup: The WAL-Index\n\nReaders need to find the most recent version of each page. Scanning the entire WAL for every page read is O(n)—unacceptable.\n\nThe solution is the **WAL-index**: a shared memory structure that maps (page number → latest frame position).\n\n\n![WAL Page Lookup: Finding the Latest Version](./diagrams/diag-wal-page-lookup.svg)\n\n\n### WAL-Index Structure\n\n```go\ntype WALIndex struct {\n    // Shared memory mapping\n    shmPath   string  // .db-shm file\n    shmFile   *os.File\n    shmData   []byte  // Memory-mapped\n    \n    // Hash table: page number → frame index\n    // Multiple hash tables for different snapshots\n    hashTables []*WALIndexHash\n}\n\ntype WALIndexHash struct {\n    Entries [WALIndexHashSize]WALIndexEntry\n}\n\ntype WALIndexEntry struct {\n    PageNumber uint32\n    FrameIndex uint32  // 0 means not in WAL, 1+ is frame number\n}\n\nconst WALIndexHashSize = 256  // Per hash table\n```\n\n### Building the WAL-Index\n\nWhen a writer commits, it updates the WAL-index:\n\n```go\nfunc (w *WAL) UpdateIndex(frameStart, frameEnd int) error {\n    // Read frames and add to hash table\n    for i := frameStart; i < frameEnd; i++ {\n        frame := w.ReadFrame(i)\n        \n        // Hash the page number\n        hash := frame.PageNumber % WALIndexHashSize\n        \n        // Update or add entry\n        w.index.hashTables[0].Entries[hash] = WALIndexEntry{\n            PageNumber: frame.PageNumber,\n            FrameIndex: uint32(i + 1),  // 1-indexed\n        }\n    }\n    \n    // Sync the index to shared memory\n    return w.index.Sync()\n}\n```\n\n### Page Lookup with WAL\n\n```go\nfunc (bp *BufferPool) FetchPageWithWAL(pageID PageID, snapshot *Snapshot) (*Page, error) {\n    // 1. Check WAL-index for this page\n    frameIdx := bp.walIndex.Lookup(pageID.PageNum, snapshot.maxFrame)\n    \n    if frameIdx > 0 && frameIdx <= snapshot.maxFrame {\n        // Page is in WAL and within our snapshot\n        frame := bp.wal.ReadFrame(int(frameIdx - 1))\n        \n        // Copy to a buffer pool frame\n        frameData := bp.allocateFrame()\n        copy(frameData, frame.PageData)\n        \n        return &Page{Data: frameData, PageID: pageID}, nil\n    }\n    \n    // 2. Fall back to database file\n    return bp.FetchPage(pageID)\n}\n\nfunc (idx *WALIndex) Lookup(pageNum uint32, maxFrame uint32) uint32 {\n    // Check each hash table\n    for _, ht := range idx.hashTables {\n        hash := pageNum % WALIndexHashSize\n        entry := ht.Entries[hash]\n        \n        if entry.PageNumber == pageNum && entry.FrameIndex <= maxFrame {\n            return entry.FrameIndex\n        }\n    }\n    \n    return 0  // Not found in WAL\n}\n```\n\n---\n\n## Concurrent Readers: Snapshot Isolation\n\nEach reader sees a consistent snapshot of the database as of its start time:\n\n```go\ntype Snapshot struct {\n    maxFrame    uint32  // Highest WAL frame visible to this reader\n    startTime   time.Time\n}\n\nfunc (db *Database) BeginRead() *Snapshot {\n    // Capture the current WAL position\n    return &Snapshot{\n        maxFrame:  db.wal.LastCommittedFrame(),\n        startTime: time.Now(),\n    }\n}\n\nfunc (db *Database) ExecuteQuery(sql string, snapshot *Snapshot) ([]Row, error) {\n    // All page reads use this snapshot\n    // The reader sees WAL frames 0..maxFrame, but not newer frames\n    \n    // ... execute query using snapshot-aware page fetches ...\n}\n```\n\n### Snapshot Lifecycle\n\n```go\ntype WAL struct {\n    readers     map[int]*Snapshot  // Active readers\n    nextReaderID int\n    minSnapshot uint32  // Oldest snapshot still in use\n    mutex       sync.RWMutex\n}\n\nfunc (w *WAL) RegisterReader(snapshot *Snapshot) int {\n    w.mutex.Lock()\n    defer w.mutex.Unlock()\n    \n    id := w.nextReaderID\n    w.nextReaderID++\n    w.readers[id] = snapshot\n    \n    // Update minimum snapshot\n    w.updateMinSnapshot()\n    \n    return id\n}\n\nfunc (w *WAL) UnregisterReader(id int) {\n    w.mutex.Lock()\n    defer w.mutex.Unlock()\n    \n    delete(w.readers, id)\n    w.updateMinSnapshot()\n}\n\nfunc (w *WAL) updateMinSnapshot() {\n    w.minSnapshot = 0\n    for _, snap := range w.readers {\n        if w.minSnapshot == 0 || snap.maxFrame < w.minSnapshot {\n            w.minSnapshot = snap.maxFrame\n        }\n    }\n}\n\nfunc (w *WAL) MinActiveSnapshot() uint32 {\n    w.mutex.RLock()\n    defer w.mutex.RUnlock()\n    return w.minSnapshot\n}\n```\n\nThe minimum snapshot determines how much of the WAL can be checkpointed. Frames newer than the minimum snapshot are still needed by at least one reader.\n\n---\n\n## Checkpoint: Merging WAL to Database\n\n\n![Checkpoint: Merging WAL to Database](./diagrams/diag-wal-checkpoint-process.svg)\n\n\nCheckpointing copies WAL frames back into the database file:\n\n```go\ntype CheckpointMode int\n\nconst (\n    CheckpointPassive  CheckpointMode = iota  // Don't block writers\n    CheckpointFull                             // Block writers briefly\n    CheckpointRestart                          // Block writers, restart WAL\n    CheckpointTruncate                         // Block writers, truncate WAL\n)\n\nfunc (w *WAL) Checkpoint(mode CheckpointMode) (int, error) {\n    // 1. Determine checkpoint boundary\n    // Can only checkpoint frames not needed by active readers\n    minSnapshot := w.MinActiveSnapshot()\n    \n    if minSnapshot == 0 {\n        minSnapshot = w.LastCommittedFrame()\n    }\n    \n    // 2. Read frames and write to database\n    framesCopied := 0\n    \n    for i := 0; i < int(minSnapshot); i++ {\n        frame := w.ReadFrame(i)\n        \n        // Write page to database file\n        offset := int64(frame.PageNumber) * int64(w.pageSize)\n        _, err := w.dbFile.WriteAt(frame.PageData, offset)\n        if err != nil {\n            return framesCopied, err\n        }\n        \n        framesCopied++\n    }\n    \n    // 3. Sync database file\n    w.dbFile.Sync()\n    \n    // 4. Update WAL (remove checkpointed frames)\n    if mode == CheckpointTruncate {\n        // Truncate WAL file\n        w.file.Truncate(WALHeaderSize)\n        w.frameCount = 0\n        w.checkpointSeq++\n        w.WriteHeader()\n    } else {\n        // Move read pointer forward\n        w.checkpointedFrames = framesCopied\n    }\n    \n    return framesCopied, nil\n}\n```\n\n### Auto-Checkpoint\n\n```go\nconst DefaultAutoCheckpointPages = 1000\n\nfunc (w *WAL) AfterCommit() {\n    // Check if we should auto-checkpoint\n    if w.frameCount >= w.autoCheckpointThreshold {\n        go func() {\n            // Run checkpoint in background\n            w.Checkpoint(CheckpointPassive)\n        }()\n    }\n}\n\nfunc (db *Database) SetAutoCheckpoint(pages int) {\n    db.wal.autoCheckpointThreshold = pages\n}\n```\n\n### PRAGMA wal_checkpoint\n\n```sql\nPRAGMA wal_checkpoint;           -- Passive checkpoint\nPRAGMA wal_checkpoint(FULL);     -- Full checkpoint (blocks writers)\nPRAGMA wal_checkpoint(RESTART);  -- Restart checkpoint\nPRAGMA wal_checkpoint(TRUNCATE); -- Truncate checkpoint (empties WAL)\n```\n\n```go\nfunc (db *Database) handlePragmaWalCheckpoint(mode string) string {\n    var cpMode CheckpointMode\n    \n    switch strings.ToUpper(mode) {\n    case \"PASSIVE\", \"\":\n        cpMode = CheckpointPassive\n    case \"FULL\":\n        cpMode = CheckpointFull\n    case \"RESTART\":\n        cpMode = CheckpointRestart\n    case \"TRUNCATE\":\n        cpMode = CheckpointTruncate\n    default:\n        return \"error: invalid checkpoint mode\"\n    }\n    \n    framesCopied, err := db.wal.Checkpoint(cpMode)\n    if err != nil {\n        return fmt.Sprintf(\"error: %v\", err)\n    }\n    \n    return fmt.Sprintf(\"%d frames copied\", framesCopied)\n}\n```\n\n---\n\n## Switching Between Modes\n\n```sql\nPRAGMA journal_mode=DELETE;  -- Rollback journal (default)\nPRAGMA journal_mode=WAL;     -- Write-ahead logging\n```\n\n```go\nfunc (db *Database) SetJournalMode(mode string) (string, error) {\n    switch strings.ToUpper(mode) {\n    case \"DELETE\":\n        return db.switchToRollbackJournal()\n    case \"WAL\":\n        return db.switchToWAL()\n    default:\n        return \"\", fmt.Errorf(\"unsupported journal mode: %s\", mode)\n    }\n}\n\nfunc (db *Database) switchToWAL() (string, error) {\n    // 1. Check if already in WAL mode\n    if db.journalMode == \"WAL\" {\n        return \"wal\", nil\n    }\n    \n    // 2. Ensure no active transactions\n    if db.txManager.state == TxActive {\n        return \"\", errors.New(\"cannot switch journal mode during transaction\")\n    }\n    \n    // 3. Create WAL file\n    walPath := db.path + \"-wal\"\n    walFile, err := os.Create(walPath)\n    if err != nil {\n        return \"\", err\n    }\n    \n    // 4. Initialize WAL\n    db.wal = &WAL{\n        file:       walFile,\n        path:       walPath,\n        pageSize:   db.pageSize,\n        dbFile:     db.file,\n        autoCheckpointThreshold: DefaultAutoCheckpointPages,\n        readers:    make(map[int]*Snapshot),\n    }\n    \n    db.wal.header = WALHeader{\n        Magic:         0x377f0683,  // Big-endian\n        FormatVersion: 3007000,\n        PageSize:      uint32(db.pageSize),\n        CheckpointSeq: 0,\n        Salt1:         rand.Uint32(),\n        Salt2:         rand.Uint32(),\n    }\n    db.wal.WriteHeader()\n    \n    // 5. Create WAL-index shared memory\n    shmPath := db.path + \"-shm\"\n    shmFile, err := os.Create(shmPath)\n    if err != nil {\n        walFile.Close()\n        os.Remove(walPath)\n        return \"\", err\n    }\n    \n    db.wal.shmPath = shmPath\n    db.wal.shmFile = shmFile\n    \n    // 6. Clean up rollback journal if it exists\n    if db.rollbackJournal != nil {\n        db.rollbackJournal.Close()\n        os.Remove(db.path + \"-journal\")\n    }\n    \n    db.journalMode = \"WAL\"\n    return \"wal\", nil\n}\n\nfunc (db *Database) switchToRollbackJournal() (string, error) {\n    // 1. Check if already in rollback journal mode\n    if db.journalMode == \"DELETE\" {\n        return \"delete\", nil\n    }\n    \n    // 2. Checkpoint all WAL content to database\n    _, err := db.wal.Checkpoint(CheckpointTruncate)\n    if err != nil {\n        return \"\", err\n    }\n    \n    // 3. Close and delete WAL files\n    db.wal.file.Close()\n    db.wal.shmFile.Close()\n    os.Remove(db.wal.shmPath)\n    os.Remove(db.wal.path)\n    \n    db.wal = nil\n    db.journalMode = \"DELETE\"\n    \n    return \"delete\", nil\n}\n```\n\n---\n\n## WAL Recovery\n\nOn startup, the WAL must be replayed to restore any uncommitted changes:\n\n```go\nfunc (db *Database) recoverFromWAL() error {\n    walPath := db.path + \"-wal\"\n    \n    // Check if WAL exists\n    if _, err := os.Stat(walPath); os.IsNotExist(err) {\n        return nil  // No WAL, nothing to recover\n    }\n    \n    fmt.Println(\"WAL file detected, initiating recovery...\")\n    \n    // Open and validate WAL\n    wal, err := OpenWAL(walPath, db.file, db.pageSize)\n    if err != nil {\n        return fmt.Errorf(\"failed to open WAL: %w\", err)\n    }\n    defer wal.Close()\n    \n    // Read and validate all frames\n    var lastCommitFrame int = -1\n    \n    for i := 0; ; i++ {\n        frame, err := wal.ReadFrame(i)\n        if err == io.EOF {\n            break\n        }\n        if err != nil {\n            return fmt.Errorf(\"failed to read WAL frame %d: %w\", i, err)\n        }\n        \n        // Verify checksum\n        expectedCs1, expectedCs2 := walChecksum(\n            frame.PageData,\n            wal.lastChecksum1,\n            wal.lastChecksum2,\n            wal.header.Magic,\n        )\n        \n        if frame.Checksum1 != expectedCs1 || frame.Checksum2 != expectedCs2 {\n            // Checksum mismatch - WAL is corrupted\n            // Only replay up to the last valid commit\n            fmt.Printf(\"WAL frame %d has checksum mismatch, stopping recovery\\n\", i)\n            break\n        }\n        \n        wal.lastChecksum1 = frame.Checksum1\n        wal.lastChecksum2 = frame.Checksum2\n        \n        // Track commit frames\n        if frame.CommitSize > 0 {\n            lastCommitFrame = i\n        }\n        \n        fmt.Printf(\"  Validated frame %d: page %d\\n\", i, frame.PageNumber)\n    }\n    \n    // Replay up to the last commit\n    if lastCommitFrame >= 0 {\n        fmt.Printf(\"Replaying %d frames to database...\\n\", lastCommitFrame+1)\n        \n        for i := 0; i <= lastCommitFrame; i++ {\n            frame, _ := wal.ReadFrame(i)\n            \n            offset := int64(frame.PageNumber) * int64(db.pageSize)\n            _, err := db.file.WriteAt(frame.PageData, offset)\n            if err != nil {\n                return fmt.Errorf(\"failed to write page %d: %w\", frame.PageNumber, err)\n            }\n        }\n        \n        db.file.Sync()\n        fmt.Println(\"WAL recovery complete.\")\n    } else {\n        fmt.Println(\"No committed frames in WAL, nothing to replay.\")\n    }\n    \n    return nil\n}\n```\n\n---\n\n## Concurrent Execution Flow\n\n{{DIAGRAM:diag-wal-architecture}}\n\n### Writer Flow\n\n```go\nfunc (db *Database) executeWriteWithWAL(stmt Statement) error {\n    // 1. Begin transaction\n    db.txManager.Begin()\n    \n    // 2. Execute statement (modifies pages in buffer pool)\n    err := db.executeStatement(stmt)\n    if err != nil {\n        db.txManager.Rollback()\n        return err\n    }\n    \n    // 3. On commit, write dirty pages to WAL\n    dirtyPages := db.bufferPool.GetDirtyPages()\n    \n    for _, page := range dirtyPages {\n        db.wal.WriteFrame(page.PageID.PageNum, page.Data, false, 0)\n    }\n    \n    // 4. Write commit frame\n    dbSize := db.getPageCount()\n    commitFrame := make([]byte, db.pageSize)\n    db.wal.WriteFrame(0, commitFrame, true, dbSize)\n    \n    // 5. Sync WAL\n    db.wal.file.Sync()\n    \n    // 6. Update WAL-index\n    db.wal.UpdateIndex(0, db.wal.frameCount)\n    \n    // 7. Mark transaction committed\n    db.txManager.Commit()\n    \n    // 8. Check for auto-checkpoint\n    db.wal.AfterCommit()\n    \n    return nil\n}\n```\n\n### Reader Flow\n\n```go\nfunc (db *Database) executeReadWithWAL(sql string) ([]Row, error) {\n    // 1. Register as reader, get snapshot\n    snapshot := db.wal.BeginSnapshot()\n    readerID := db.wal.RegisterReader(snapshot)\n    defer db.wal.UnregisterReader(readerID)\n    \n    // 2. Execute query with snapshot-aware page fetches\n    rows, err := db.executeQuery(sql, snapshot)\n    if err != nil {\n        return nil, err\n    }\n    \n    return rows, nil\n}\n\nfunc (db *Database) fetchPageSnapshot(pageNum uint32, snapshot *Snapshot) ([]byte, error) {\n    // Check WAL-index first\n    frameIdx := db.wal.index.Lookup(pageNum, snapshot.maxFrame)\n    \n    if frameIdx > 0 {\n        // Read from WAL\n        frame := db.wal.ReadFrame(int(frameIdx - 1))\n        return frame.PageData, nil\n    }\n    \n    // Fall back to database file\n    offset := int64(pageNum) * int64(db.pageSize)\n    data := make([]byte, db.pageSize)\n    _, err := db.file.ReadAt(data, offset)\n    return data, err\n}\n```\n\n---\n\n## Common Pitfalls\n\n### 1. WAL Grows Unbounded Without Checkpointing\n\n```go\n// WRONG: Never checkpoint\nfunc (db *Database) Insert(...) {\n    db.wal.WriteFrame(...)\n    // No checkpoint!\n}\n\n// RIGHT: Auto-checkpoint after threshold\nfunc (db *Database) Insert(...) {\n    db.wal.WriteFrame(...)\n    if db.wal.frameCount >= db.autoCheckpointThreshold {\n        db.wal.Checkpoint(CheckpointPassive)\n    }\n}\n```\n\n### 2. Long-Running Readers Block Checkpointing\n\n```go\n// Scenario: Reader holds old snapshot\nreader1 := db.BeginRead()  // snapshot at frame 100\n\n// Writer commits 10000 frames\nfor i := 0; i < 10000; i++ {\n    db.Insert(...)\n}\n\n// Checkpoint can only copy frames 0-99\n// Frames 100-10099 are pinned by reader1\ndb.wal.Checkpoint(CheckpointPassive)  // Only copies 100 frames\n\n// WAL file is now huge\n```\n\n**Solution**: Monitor long-running readers, kill queries that hold snapshots too long, or increase checkpoint threshold.\n\n### 3. Corrupted WAL Not Detected\n\n```go\n// WRONG: Trust WAL data without checksum\nframe := wal.ReadFrame(i)\ndb.file.WriteAt(frame.PageData, offset)\n\n// RIGHT: Verify checksum before using\nexpectedCs1, expectedCs2 := walChecksum(frame.PageData, ...)\nif frame.Checksum1 != expectedCs1 {\n    return errors.New(\"WAL corruption detected\")\n}\n```\n\n### 4. Switching Modes During Active Transaction\n\n```go\n// WRONG: Switch mode mid-transaction\ndb.Execute(\"BEGIN\")\ndb.Execute(\"INSERT ...\")\ndb.Execute(\"PRAGMA journal_mode=WAL\")  // Undefined behavior!\n\n// RIGHT: Only switch when idle\ndb.Execute(\"COMMIT\")\ndb.Execute(\"PRAGMA journal_mode=WAL\")\n```\n\n### 5. Forgetting to Sync WAL\n\n```go\n// WRONG: Commit without sync\ndb.wal.WriteFrame(..., isCommit=true)\n// No sync! WAL might not be on disk\n\n// RIGHT: Sync after commit frame\ndb.wal.WriteFrame(..., isCommit=true)\ndb.wal.file.Sync()  // Ensure durability\n```\n\n---\n\n## Test Suite: What to Verify\n\n**WAL mode activation:**\n```sql\nPRAGMA journal_mode=WAL;\n-- Expected: \"wal\"\n\n-- Files should exist\n-- test.db-wal\n-- test.db-shm\n```\n\n**Concurrent reads during writes:**\n```go\ndb := OpenDatabase(path)\ndb.Execute(\"PRAGMA journal_mode=WAL\")\n\n// Start a long write transaction\ngo func() {\n    db.Execute(\"BEGIN\")\n    for i := 0; i < 10000; i++ {\n        db.Execute(\"INSERT INTO users VALUES (?, ?)\", i, fmt.Sprintf(\"user%d\", i))\n    }\n    db.Execute(\"COMMIT\")\n}()\n\n// Readers should not block\ntime.Sleep(100 * time.Millisecond)  // Let writer start\n\nrows, _ := db.Query(\"SELECT COUNT(*) FROM users\")  // Should return immediately\n// Reader sees snapshot from before the write transaction\n```\n\n**WAL file growth and checkpoint:**\n```go\ndb.Execute(\"PRAGMA journal_mode=WAL\")\ndb.Execute(\"PRAGMA wal_autocheckpoint=100\")  // Checkpoint every 100 pages\n\nfor i := 0; i < 1000; i++ {\n    db.Execute(\"INSERT INTO users VALUES (?, ?)\", i, \"test\")\n}\n\n// WAL should not exceed ~100 pages worth of data\nwalSize, _ := os.Stat(db.path + \"-wal\")\nassert.Less(t, walSize.Size(), 100*4096+32+24*100)  // Header + 100 frames max\n```\n\n**Checkpoint PRAGMA:**\n```sql\nPRAGMA wal_checkpoint;\n-- Expected: Shows frames copied\n\nPRAGMA wal_checkpoint(TRUNCATE);\n-- Expected: WAL file is truncated to header only\n```\n\n**Snapshot isolation:**\n```go\ndb.Execute(\"INSERT INTO users VALUES (1, 'Alice')\")\n\n// Start reader\nrows1, _ := db.Query(\"SELECT * FROM users\")  // Sees Alice\n\ndb.Execute(\"INSERT INTO users VALUES (2, 'Bob')\")\n\n// New reader sees both\nrows2, _ := db.Query(\"SELECT * FROM users\")  // Sees Alice and Bob\n\n// Old reader still sees only Alice\nassert.Equal(t, 1, len(rows1))\nassert.Equal(t, 2, len(rows2))\n```\n\n**WAL recovery:**\n```go\ndb.Execute(\"PRAGMA journal_mode=WAL\")\ndb.Execute(\"INSERT INTO users VALUES (1, 'Alice')\")\n// Don't commit - simulate crash\n\ndb2 := OpenDatabase(path)\n// Should recover from WAL\nrows, _ := db2.Query(\"SELECT * FROM users\")\nassert.Equal(t, 1, len(rows))  // Transaction was recovered\n```\n\n**Checksum detection:**\n```go\ndb.Execute(\"PRAGMA journal_mode=WAL\")\ndb.Execute(\"INSERT INTO users VALUES (1, 'Alice')\")\n\n// Corrupt the WAL\nwalFile, _ := os.OpenFile(db.path + \"-wal\", os.O_RDWR, 0644)\nwalFile.WriteAt([]byte{0xFF, 0xFF, 0xFF, 0xFF}, 100)  // Corrupt a checksum\nwalFile.Close()\n\ndb2 := OpenDatabase(path)\n// Should detect corruption and recover only valid frames\n```\n\n---\n\n## Knowledge Cascade: What This Unlocks\n\nYou've just implemented **Write-Ahead Logging**—the pattern that enables high-concurrency database systems. Here's where this connects:\n\n**Immediate connections:**\n- **Previous milestone (Rollback Journal)**: WAL is the alternative to rollback journaling. Both provide durability, but WAL enables concurrent readers. The choice depends on workload: write-heavy with occasional reads → rollback journal; mixed read/write → WAL.\n- **All storage operations**: Every B-tree modification now goes through the WAL. The buffer pool, B-tree layer, and VM all participate in the WAL protocol.\n\n**Same domain:**\n- **PostgreSQL WAL**: PostgreSQL's WAL (called \"xlog\") is more sophisticated—it logs logical changes (tuple inserts/updates) rather than page images. This enables point-in-time recovery and logical replication. Your WAL logs physical pages; theirs logs logical operations.\n- **MySQL InnoDB Redo Log**: InnoDB uses a circular WAL with fixed size. Old log records are overwritten after checkpointing. This bounds disk usage but requires careful management. Your WAL grows unbounded until checkpoint.\n- **Database logical replication**: WAL records can be parsed and shipped to replicas. PostgreSQL's logical decoding extracts change events from WAL. Your WAL format is simpler but could be extended to support replication.\n\n**Cross-domain:**\n- **Event sourcing**: The append-only event log in event-sourced architectures is a WAL pattern applied at the application level. Events are facts that happened; the current state is derived by replaying events. Same principle: never overwrite, always append.\n- **Kafka log compaction**: Kafka's retention policies mirror WAL checkpointing. A compacted topic keeps only the latest value for each key—like checkpointing old page versions out of the WAL. The \"log\" abstraction unifies databases and message systems.\n- **Copy-on-write file systems (ZFS, Btrfs)**: ZFS never overwrites blocks in place. New data is written to free space, then metadata is updated atomically. This is like a WAL at the file system level—every write creates a new version.\n- **Time-travel queries**: Snowflake and BigQuery expose historical data for point-in-time queries. This is snapshot isolation at scale—readers query a snapshot, and the system keeps old versions until they're no longer needed. Your WAL provides the same capability, just not exposed to users.\n- **Git reflog**: Git's reflog is a WAL for branch references. Every update is logged, and you can recover from mistakes by replaying or resetting to an earlier point. The same durability principle applies to version control.\n\n**Forward:**\n- **With this knowledge, you could now build**: A database replication system that ships WAL frames to replicas; a point-in-time recovery system that archives WAL files for later replay; or a change data capture (CDC) system that extracts logical changes from the WAL for downstream consumers.\n\nWAL is where database engineering meets distributed systems thinking. The append-only log, the snapshot, the checkpoint—these patterns appear everywhere data must be both durable and concurrent. You've implemented the core technique that powers every major database system.\n\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-sqlite-m11 -->\n# Milestone 11: Aggregate Functions & JOIN\n\n## Where We Are in the System\n\n\n![SQLite Architecture: The Complete System Map](./diagrams/diag-satellite-overview.svg)\n\n\nYour database can execute single-table queries with WHERE clauses, projections, and indexes. But real analytical work requires more. Consider these queries:\n\n```sql\nSELECT COUNT(*) FROM orders WHERE status = 'completed'\nSELECT customer_id, SUM(amount) FROM orders GROUP BY customer_id\nSELECT c.name, o.total FROM customers c JOIN orders o ON c.id = o.customer_id\n```\n\nEach requires capabilities you don't yet have: accumulating values across rows, partitioning rows into groups, and combining data from multiple tables. These are **aggregates**, **GROUP BY**, and **JOINs**—the features that transform a key-value store into a relational query engine.\n\nThis milestone adds the final execution capabilities your database needs for real-world queries.\n\n---\n\n## The Revelation: Aggregates Have Subtle NULL Behavior\n\nHere's what most developers assume: \"Aggregate functions are simple. SUM adds values, COUNT counts them, AVG computes the average. GROUP BY just groups rows by a column. JOINs combine matching rows.\"\n\nAll three assumptions hide critical complexity that causes wrong results.\n\n### COUNT(*) vs COUNT(column): NULLs Are Counted Differently\n\nConsider a table with a nullable column:\n\n```sql\nCREATE TABLE users (id INTEGER, name TEXT, middle_name TEXT);\nINSERT INTO users VALUES (1, 'Alice', 'Marie');\nINSERT INTO users VALUES (2, 'Bob', NULL);\nINSERT INTO users VALUES (3, 'Charlie', 'Lee');\n```\n\nWhat does `COUNT(middle_name)` return?\n\n| Query | Result | Why |\n|-------|--------|-----|\n| `COUNT(*)` | 3 | Counts all rows, regardless of NULLs |\n| `COUNT(middle_name)` | 2 | Counts only non-NULL values |\n| `COUNT(id)` | 3 | id has no NULLs |\n\n\n![Aggregate NULL Handling: COUNT(*) vs COUNT(col)](./diagrams/diag-aggregate-null-handling.svg)\n\n\nThis isn't arbitrary—`COUNT(*)` answers \"how many rows?\" while `COUNT(col)` answers \"how many rows have a value for this column?\" The distinction matters for data quality analysis.\n\n### AVG Must Return a Float, Even for Integer Columns\n\n```sql\nCREATE TABLE scores (value INTEGER);\nINSERT INTO scores VALUES (1), (2), (3), (4);\n\nSELECT AVG(value) FROM scores;\n```\n\nIf you compute `AVG` as integer division: (1+2+3+4)/4 = 10/4 = 2 (truncated)\n\nThe correct answer is 2.5. **AVG always returns REAL/float**, even when the input column is INTEGER. This requires type promotion during aggregation.\n\n### SUM and AVG Ignore NULLs\n\n```sql\nINSERT INTO scores VALUES (NULL);\n\nSELECT SUM(value) FROM scores;  -- 10, not NULL\nSELECT AVG(value) FROM scores;  -- 2.5, not 2.0\n```\n\n`SUM` and `AVG` treat NULL as \"no value\" and skip it entirely. The sum is computed over 4 values, not 5. The average divides by 4, not 5.\n\nThis is different from arithmetic: `NULL + 5 = NULL`. Aggregates are special—they filter out NULLs before accumulating.\n\n### GROUP BY Without ORDER BY Has No Guaranteed Order\n\n```sql\nSELECT status, COUNT(*) FROM orders GROUP BY status;\n```\n\nThe result might return groups in any order: ('pending', 5), ('completed', 100), ('cancelled', 3)—or any permutation. GROUP BY partitions rows; it does not sort them. If you need sorted output, add `ORDER BY`.\n\n### Nested Loop Joins Are O(n*m)\n\nThe simplest JOIN algorithm is a nested loop:\n\n```sql\nSELECT * FROM orders o JOIN customers c ON o.customer_id = c.id;\n```\n\n```go\nfor each order o:\n    for each customer c:\n        if o.customer_id == c.id:\n            emit (o, c)\n```\n\nIf `orders` has 10,000 rows and `customers` has 1,000 rows, this performs **10 million comparisons**. For a 1M-row orders table and 100K customers, it's 100 billion comparisons.\n\nThis is why query planners matter. A hash join or merge join can reduce this to O(n+m), but your baseline implementation uses nested loops. Understanding this cost reveals why indexes on join columns are critical.\n\n---\n\n## The Tension: Correctness vs Memory vs Performance\n\nAggregates and JOINs introduce new resource constraints:\n\n| Operation | Memory Concern | Performance Concern |\n|-----------|----------------|---------------------|\n| GROUP BY | Must hold aggregate state per group | Hashing vs sorting for partitioning |\n| Aggregates | Minimal (single accumulator) | NULL handling overhead |\n| Nested loop JOIN | Minimal (no state needed) | O(n*m) comparisons |\n| Hash JOIN | O(smaller table) for hash table | O(n+m) but memory-bound |\n| Sort-merge JOIN | O(both tables) if external sort | O(n log n + m log m) |\n\n**The constraint**: GROUP BY requires holding aggregate state for every distinct group. A GROUP BY on a column with 1 million distinct values needs 1 million accumulator slots. This can exhaust memory.\n\nFor this milestone, we use in-memory hash aggregation. Production databases spill to disk (external hashing) when memory is exceeded, but that's an advanced optimization.\n\n---\n\n## Three-Level View: From SQL to Aggregate State to Results\n\n| Level | What Happens | State Required |\n|-------|--------------|----------------|\n| **SQL** | GROUP BY clause defines partitioning keys | Parser extracts column references |\n| **Execution** | Hash table maps group keys → aggregate state | O(distinct groups) memory |\n| **Output** | Each group produces one result row | HAVING filters groups |\n\n\n![GROUP BY: Partitioning and Aggregation](./diagrams/diag-group-by-execution.svg)\n\n\n---\n\n## Building Aggregate Functions\n\n### Aggregate State Structure\n\nEach aggregate function maintains state across rows:\n\n```go\ntype AggregateState interface {\n    Update(value Value)\n    Finalize() Value\n}\n\ntype CountStarState struct {\n    count int64\n}\n\nfunc (s *CountStarState) Update(value Value) {\n    s.count++  // Count every row, regardless of value\n}\n\nfunc (s *CountStarState) Finalize() Value {\n    return Value{Type: INTEGER, Int: s.count}\n}\n\ntype CountColumnState struct {\n    count int64\n}\n\nfunc (s *CountColumnState) Update(value Value) {\n    if value.Type != NULL {\n        s.count++  // Only count non-NULL values\n    }\n}\n\nfunc (s *CountColumnState) Finalize() Value {\n    return Value{Type: INTEGER, Int: s.count}\n}\n\ntype SumState struct {\n    sum   float64\n    valid bool\n}\n\nfunc (s *SumState) Update(value Value) {\n    if value.Type == NULL {\n        return  // Skip NULLs\n    }\n    \n    s.valid = true\n    s.sum += toFloat(value)\n}\n\nfunc (s *SumState) Finalize() Value {\n    if !s.valid {\n        return Value{Type: NULL}  // SUM of no values is NULL\n    }\n    return Value{Type: REAL, Float: s.sum}\n}\n\ntype AvgState struct {\n    sum   float64\n    count int64\n}\n\nfunc (s *AvgState) Update(value Value) {\n    if value.Type == NULL {\n        return\n    }\n    \n    s.sum += toFloat(value)\n    s.count++\n}\n\nfunc (s *AvgState) Finalize() Value {\n    if s.count == 0 {\n        return Value{Type: NULL}  // AVG of no values is NULL\n    }\n    return Value{Type: REAL, Float: s.sum / float64(s.count)}\n}\n\ntype MinState struct {\n    min   Value\n    valid bool\n}\n\nfunc (s *MinState) Update(value Value) {\n    if value.Type == NULL {\n        return\n    }\n    \n    if !s.valid || compareValues(value, s.min) < 0 {\n        s.min = value\n        s.valid = true\n    }\n}\n\nfunc (s *MinState) Finalize() Value {\n    if !s.valid {\n        return Value{Type: NULL}\n    }\n    return s.min\n}\n\ntype MaxState struct {\n    max   Value\n    valid bool\n}\n\nfunc (s *MaxState) Update(value Value) {\n    if value.Type == NULL {\n        return\n    }\n    \n    if !s.valid || compareValues(value, s.max) > 0 {\n        s.max = value\n        s.valid = true\n    }\n}\n\nfunc (s *MaxState) Finalize() Value {\n    if !s.valid {\n        return Value{Type: NULL}\n    }\n    return s.max\n}\n```\n\n### Aggregate Function Factory\n\n```go\ntype AggregateType int\n\nconst (\n    AggregateCountStar AggregateType = iota\n    AggregateCountColumn\n    AggregateSum\n    AggregateAvg\n    AggregateMin\n    AggregateMax\n)\n\nfunc NewAggregateState(aggType AggregateType) AggregateState {\n    switch aggType {\n    case AggregateCountStar:\n        return &CountStarState{}\n    case AggregateCountColumn:\n        return &CountColumnState{}\n    case AggregateSum:\n        return &SumState{}\n    case AggregateAvg:\n        return &AvgState{}\n    case AggregateMin:\n        return &MinState{}\n    case AggregateMax:\n        return &MaxState{}\n    default:\n        panic(fmt.Sprintf(\"unknown aggregate type: %d\", aggType))\n    }\n}\n\nfunc toFloat(v Value) float64 {\n    switch v.Type {\n    case INTEGER:\n        return float64(v.Int)\n    case REAL:\n        return v.Float\n    case NULL:\n        return 0\n    default:\n        panic(fmt.Sprintf(\"cannot convert %v to float\", v.Type))\n    }\n}\n```\n\n---\n\n## GROUP BY Execution\n\n### Hash-Based Aggregation\n\n```go\ntype GroupByExecutor struct {\n    groupColumns []int           // Column indices for GROUP BY\n    aggregates   []AggregateSpec // Aggregate functions to compute\n    groups       map[string][]AggregateState  // group key → aggregate states\n}\n\ntype AggregateSpec struct {\n    Type      AggregateType\n    Column    int  // Column index for column-based aggregates (-1 for COUNT(*))\n}\n\nfunc (e *GroupByExecutor) ProcessRow(row []Value) {\n    // 1. Extract group key\n    key := e.makeGroupKey(row)\n    \n    // 2. Get or create aggregate states for this group\n    states, exists := e.groups[key]\n    if !exists {\n        states = make([]AggregateState, len(e.aggregates))\n        for i, agg := range e.aggregates {\n            states[i] = NewAggregateState(agg.Type)\n        }\n        e.groups[key] = states\n    }\n    \n    // 3. Update each aggregate with the appropriate value\n    for i, agg := range e.aggregates {\n        var value Value\n        if agg.Column >= 0 {\n            value = row[agg.Column]\n        } else {\n            value = Value{Type: INTEGER, Int: 1}  // Dummy value for COUNT(*)\n        }\n        states[i].Update(value)\n    }\n}\n\nfunc (e *GroupByExecutor) makeGroupKey(row []Value) string {\n    var buf bytes.Buffer\n    for i, colIdx := range e.groupColumns {\n        if i > 0 {\n            buf.WriteByte(0)  // Separator\n        }\n        buf.WriteString(formatValueForKey(row[colIdx]))\n    }\n    return buf.String()\n}\n\nfunc formatValueForKey(v Value) string {\n    switch v.Type {\n    case NULL:\n        return \"\\x00\"\n    case INTEGER:\n        return fmt.Sprintf(\"I%d\", v.Int)\n    case REAL:\n        return fmt.Sprintf(\"R%f\", v.Float)\n    case TEXT:\n        return fmt.Sprintf(\"T%s\", v.Str)\n    case BLOB:\n        return fmt.Sprintf(\"B%x\", v.Bytes)\n    default:\n        return \"\"\n    }\n}\n\nfunc (e *GroupByExecutor) Finalize() []GroupResult {\n    results := make([]GroupResult, 0, len(e.groups))\n    \n    for key, states := range e.groups {\n        // Reconstruct group key values\n        keyValues := e.parseGroupKey(key)\n        \n        // Finalize aggregates\n        aggValues := make([]Value, len(states))\n        for i, state := range states {\n            aggValues[i] = state.Finalize()\n        }\n        \n        results = append(results, GroupResult{\n            Key:    keyValues,\n            Values: aggValues,\n        })\n    }\n    \n    return results\n}\n\ntype GroupResult struct {\n    Key    []Value  // GROUP BY column values\n    Values []Value  // Aggregate results\n}\n```\n\n### Ungrouped Aggregation\n\nQueries without GROUP BY produce a single result row:\n\n```sql\nSELECT COUNT(*), AVG(price) FROM products;\n```\n\n```go\nfunc (e *GroupByExecutor) ProcessRowUngrouped(row []Value) {\n    // Ungrouped queries have a single \"group\" with empty key\n    key := \"\"\n    \n    states, exists := e.groups[key]\n    if !exists {\n        states = make([]AggregateState, len(e.aggregates))\n        for i, agg := range e.aggregates {\n            states[i] = NewAggregateState(agg.Type)\n        }\n        e.groups[key] = states\n    }\n    \n    for i, agg := range e.aggregates {\n        var value Value\n        if agg.Column >= 0 {\n            value = row[agg.Column]\n        } else {\n            value = Value{Type: INTEGER, Int: 1}\n        }\n        states[i].Update(value)\n    }\n}\n```\n\n### Empty Table Handling\n\n```sql\nSELECT COUNT(*), AVG(price) FROM products WHERE 1=0;  -- Empty result set\n```\n\nResult: `(0, NULL)`\n\n- `COUNT(*)` returns 0 (no rows)\n- `AVG(price)` returns NULL (no values to average)\n\n```go\nfunc (e *GroupByExecutor) Finalize() []GroupResult {\n    if len(e.groups) == 0 && len(e.aggregates) > 0 {\n        // Empty table with aggregates: return single row with initial states\n        states := make([]AggregateState, len(e.aggregates))\n        for i, agg := range e.aggregates {\n            states[i] = NewAggregateState(agg.Type)\n        }\n        \n        aggValues := make([]Value, len(states))\n        for i, state := range states {\n            aggValues[i] = state.Finalize()\n        }\n        \n        return []GroupResult{{Key: nil, Values: aggValues}}\n    }\n    \n    // ... normal finalization ...\n}\n```\n\n---\n\n## HAVING: Filtering Groups\n\nHAVING filters groups *after* aggregation, unlike WHERE which filters rows *before* aggregation:\n\n```sql\nSELECT customer_id, SUM(amount) as total\nFROM orders\nGROUP BY customer_id\nHAVING SUM(amount) > 1000;\n```\n\n```go\nfunc (e *GroupByExecutor) FinalizeWithHaving(havingPredicate Expression) []GroupResult {\n    allResults := e.Finalize()\n    filtered := make([]GroupResult, 0)\n    \n    for _, result := range allResults {\n        // Evaluate HAVING predicate with aggregate values\n        rowMap := make(map[string]Value)\n        \n        // Add group key columns\n        for i, col := range e.groupColumns {\n            colName := e.schema.Columns[col].Name\n            rowMap[colName] = result.Key[i]\n        }\n        \n        // Add aggregate results\n        for i, agg := range e.aggregates {\n            aggName := e.aggregateNames[i]\n            rowMap[aggName] = result.Values[i]\n        }\n        \n        // Evaluate predicate\n        cond := EvaluateExpression(havingPredicate, rowMap)\n        if cond.IsTruthy() {\n            filtered = append(filtered, result)\n        }\n    }\n    \n    return filtered\n}\n```\n\n### HAVING vs WHERE\n\n```sql\n-- WHERE filters rows before grouping\nSELECT status, COUNT(*)\nFROM orders\nWHERE amount > 100\nGROUP BY status;\n\n-- HAVING filters groups after aggregation\nSELECT status, COUNT(*)\nFROM orders\nGROUP BY status\nHAVING COUNT(*) > 10;\n```\n\nThe execution order:\n1. FROM: Load orders table\n2. WHERE: Filter rows with amount > 100\n3. GROUP BY: Partition remaining rows by status\n4. Aggregation: Compute COUNT(*) per group\n5. HAVING: Filter groups with count > 10\n6. SELECT: Output results\n\n---\n\n## INNER JOIN: Nested Loop Implementation\n\n### The Cross Product with Filter\n\n{{DIAGRAM:diag-nested-loop-join}}\n\nA JOIN is a cross product followed by a filter:\n\n```sql\nSELECT * FROM orders o JOIN customers c ON o.customer_id = c.id;\n```\n\nConceptually:\n1. For each row in `orders`\n2. For each row in `customers`\n3. If `orders.customer_id == customers.id`, emit the combined row\n\n```go\ntype NestedLoopJoinExecutor struct {\n    leftTable    string\n    rightTable   string\n    leftColumns  []string\n    rightColumns []string\n    joinCondition Expression\n    db           *Database\n}\n\nfunc (e *NestedLoopJoinExecutor) Execute(callback func(joinedRow []Value)) error {\n    // Open cursors on both tables\n    leftCursor := e.db.TableScan(e.leftTable)\n    rightCursor := e.db.TableScan(e.rightTable)\n    \n    // Get schemas for column mapping\n    leftSchema := e.db.GetSchema(e.leftTable)\n    rightSchema := e.db.GetSchema(e.rightTable)\n    \n    // Outer loop: iterate left table\n    for leftCursor.Next() {\n        leftRow := leftCursor.Current()\n        \n        // Inner loop: iterate right table\n        rightCursor.Rewind()\n        for rightCursor.Next() {\n            rightRow := rightCursor.Current()\n            \n            // Build combined row for condition evaluation\n            combinedRow := make(map[string]Value)\n            for i, col := range leftSchema.Columns {\n                combinedRow[e.leftTable+\".\"+col.Name] = leftRow[i]\n                combinedRow[col.Name] = leftRow[i]  // Also available without table prefix\n            }\n            for i, col := range rightSchema.Columns {\n                combinedRow[e.rightTable+\".\"+col.Name] = rightRow[i]\n                // Only add without prefix if not ambiguous\n                if !leftSchema.HasColumn(col.Name) {\n                    combinedRow[col.Name] = rightRow[i]\n                }\n            }\n            \n            // Evaluate join condition\n            cond := EvaluateExpression(e.joinCondition, combinedRow)\n            \n            if cond.IsTruthy() {\n                // Emit joined row\n                joinedRow := append(leftRow, rightRow...)\n                callback(joinedRow)\n            }\n        }\n    }\n    \n    return nil\n}\n```\n\n\n![JOIN Execution: Row-by-Row Trace](./diagrams/diag-join-execution-trace.svg)\n\n\n### Table Alias Support\n\n```sql\nSELECT o.id, c.name\nFROM orders o\nJOIN customers c ON o.customer_id = c.id;\n```\n\n```go\ntype JoinTableRef struct {\n    TableName string\n    Alias     string\n    Columns   []string\n}\n\nfunc (e *NestedLoopJoinExecutor) ExecuteWithAliases(\n    left JoinTableRef,\n    right JoinTableRef,\n    callback func(joinedRow []Value),\n) error {\n    // ... similar to above, but use aliases in combinedRow map ...\n    combinedRow[left.Alias+\".\"+col.Name] = value\n}\n```\n\n---\n\n## JOIN with WHERE Clause\n\nWHERE clauses can filter before, during, or after the join depending on what they reference:\n\n```sql\nSELECT c.name, o.total\nFROM customers c\nJOIN orders o ON c.id = o.customer_id\nWHERE c.country = 'US' AND o.status = 'completed';\n```\n\nOptimal execution:\n1. Filter `customers` on `country = 'US'` (reduces left side)\n2. Filter `orders` on `status = 'completed'` (reduces right side)\n3. Join the filtered results\n\nSimple execution (what we implement):\n1. Join all customers with all orders\n2. Filter the joined results\n\n```go\nfunc (e *NestedLoopJoinExecutor) ExecuteWithWhere(\n    whereClause Expression,\n    callback func(joinedRow []Value),\n) error {\n    return e.Execute(func(joinedRow []Value) {\n        // Build row map for WHERE evaluation\n        rowMap := e.buildRowMap(joinedRow)\n        \n        // Evaluate WHERE\n        cond := EvaluateExpression(whereClause, rowMap)\n        \n        if cond.IsTruthy() {\n            callback(joinedRow)\n        }\n    })\n}\n```\n\nThe query planner (Milestone 8) is responsible for pushing predicates down to reduce the join input size.\n\n---\n\n## Multiple JOINs\n\n```sql\nSELECT c.name, o.id, p.product_name\nFROM customers c\nJOIN orders o ON c.id = o.customer_id\nJOIN products p ON o.product_id = p.id;\n```\n\nThis is a sequence of nested loops:\n\n```go\nfunc (e *QueryExecutor) executeMultiJoin(\n    tables []JoinTableRef,\n    conditions []Expression,\n    callback func(joinedRow []Value),\n) error {\n    // Start with first table\n    cursor0 := e.db.TableScan(tables[0].TableName)\n    \n    for cursor0.Next() {\n        row0 := cursor0.Current()\n        \n        // Join with second table\n        cursor1 := e.db.TableScan(tables[1].TableName)\n        for cursor1.Next() {\n            row1 := cursor1.Current()\n            \n            // Check first join condition\n            combined01 := append(row0, row1...)\n            if !e.evaluateJoinCondition(conditions[0], combined01, tables[0:2]) {\n                continue\n            }\n            \n            // Join with third table\n            cursor2 := e.db.TableScan(tables[2].TableName)\n            for cursor2.Next() {\n                row2 := cursor2.Current()\n                \n                // Check second join condition\n                combined012 := append(combined01, row2...)\n                if !e.evaluateJoinCondition(conditions[1], combined012, tables[0:3]) {\n                    continue\n                }\n                \n                // All conditions passed\n                callback(combined012)\n            }\n        }\n    }\n    \n    return nil\n}\n```\n\nEach additional JOIN adds another nested loop, making the complexity O(n1 × n2 × n3 × ...).\n\n---\n\n## Bytecode Compilation for Aggregates\n\nThe VM needs new opcodes for aggregation:\n\n| Opcode | P1 | P2 | P3 | Description |\n|--------|----|----|----|----|\n| **AggStep** | agg# | column | 0 | Update aggregate with column value |\n| **AggFinal** | agg# | dest | 0 | Finalize aggregate into register |\n| **SorterOpen** | sorter# | 0 | 0 | Open a sorter for GROUP BY |\n| **SorterInsert** | sorter# | record | 0 | Insert row into sorter |\n| **SorterSort** | sorter# | 0 | 0 | Sort the sorter contents |\n| **SorterData** | sorter# | dest | 0 | Read current sorter row |\n| **SorterNext** | sorter# | jump | 0 | Advance sorter; jump if more |\n\n### GROUP BY Bytecode\n\n```sql\nSELECT status, COUNT(*) FROM orders GROUP BY status;\n```\n\n```\naddr  opcode        p1  p2  p3  comment\n----  ----------    --  --  --  -------\n0     OpenTable     0   2   0   table=orders\n1     SorterOpen    1   0   0   for GROUP BY\n2     Rewind        0   8   0   scan orders\n3     Column        0   3   0   status -> r0\n4     MakeRecord    0   1   1   make group key\n5     SorterInsert  1   1   0   insert into sorter\n6     Next          0   3   0   loop\n7     SorterSort    1   0   0   sort by group key\n8     SorterData    1   0   0   read group key\n9     AggStep       0   -1  0   COUNT(*) step\n10    SorterNext    1   8   0   loop groups\n11    AggFinal      0   1   0   finalize count\n12    ResultRow     0   2   0   output status, count\n13    Halt          0   0   0   \n```\n\n### Aggregation in the VM\n\n```go\ncase \"AggStep\":\n    aggIdx := instr.P1\n    colReg := instr.P2\n    \n    // Get the aggregate state\n    agg := vm.Aggregates[aggIdx]\n    \n    // Get the value to aggregate\n    var value Value\n    if colReg == -1 {\n        // COUNT(*) - use dummy value\n        value = Value{Type: INTEGER, Int: 1}\n    } else {\n        value = vm.Registers[colReg]\n    }\n    \n    agg.Update(value)\n\ncase \"AggFinal\":\n    aggIdx := instr.P1\n    destReg := instr.P2\n    \n    agg := vm.Aggregates[aggIdx]\n    vm.Registers[destReg] = agg.Finalize()\n    \n    // Reset for next group\n    vm.Aggregates[aggIdx] = NewAggregateState(agg.Type())\n```\n\n---\n\n## Common Pitfalls\n\n### 1. COUNT(column) Including NULLs\n\n```go\n// WRONG: Count all values\nfunc (s *CountColumnState) Update(value Value) {\n    s.count++\n}\n\n// RIGHT: Only count non-NULL\nfunc (s *CountColumnState) Update(value Value) {\n    if value.Type != NULL {\n        s.count++\n    }\n}\n```\n\n### 2. AVG Returning Integer\n\n```go\n// WRONG: Integer division\nfunc (s *AvgState) Finalize() Value {\n    return Value{Type: INTEGER, Int: s.sum / s.count}\n}\n\n// RIGHT: Float division\nfunc (s *AvgState) Finalize() Value {\n    return Value{Type: REAL, Float: s.sum / float64(s.count)}\n}\n```\n\n### 3. SUM of Empty Set Returning 0 Instead of NULL\n\n```sql\nSELECT SUM(amount) FROM orders WHERE 1=0;\n```\n\nResult should be NULL, not 0. SUM of no values is \"unknown,\" not \"zero.\"\n\n```go\n// WRONG\nfunc (s *SumState) Finalize() Value {\n    return Value{Type: REAL, Float: s.sum}\n}\n\n// RIGHT\nfunc (s *SumState) Finalize() Value {\n    if !s.valid {\n        return Value{Type: NULL}\n    }\n    return Value{Type: REAL, Float: s.sum}\n}\n```\n\n### 4. Nested Loop JOIN on Large Tables\n\n```sql\nSELECT * FROM large_table_a JOIN large_table_b ON a.id = b.a_id;\n```\n\nIf both tables have 100,000 rows, this performs 10 billion comparisons. Always ensure join columns are indexed, or the query planner chooses a different algorithm.\n\n### 5. GROUP BY Without Aggregate\n\n```sql\nSELECT customer_id FROM orders GROUP BY customer_id;\n```\n\nThis is valid SQL—it returns distinct customer_ids. But it's confusing. Better to use `SELECT DISTINCT customer_id FROM orders` for clarity.\n\n```go\n// Handle GROUP BY without aggregates\nfunc (e *GroupByExecutor) Finalize() []GroupResult {\n    if len(e.aggregates) == 0 {\n        // No aggregates - just return distinct group keys\n        results := make([]GroupResult, 0, len(e.groups))\n        for key := range e.groups {\n            results = append(results, GroupResult{\n                Key:    e.parseGroupKey(key),\n                Values: nil,\n            })\n        }\n        return results\n    }\n    // ... normal finalization ...\n}\n```\n\n### 6. HAVING Using Non-Aggregate Columns\n\n```sql\n-- WRONG: HAVING references non-aggregate, non-group column\nSELECT customer_id, SUM(amount)\nFROM orders\nGROUP BY customer_id\nHAVING status = 'completed';  -- status is not in GROUP BY!\n```\n\nThis is invalid SQL. HAVING can only reference:\n- Columns in GROUP BY\n- Aggregate functions\n\nSome databases allow it (returning arbitrary row's value), but it's non-standard.\n\n---\n\n## Test Suite: What to Verify\n\n**Aggregate functions:**\n```sql\nCREATE TABLE numbers (val INTEGER);\nINSERT INTO numbers VALUES (1), (2), (3), (NULL), (5);\n\nSELECT COUNT(*) FROM numbers;\n-- Expected: 5\n\nSELECT COUNT(val) FROM numbers;\n-- Expected: 4 (NULL excluded)\n\nSELECT SUM(val) FROM numbers;\n-- Expected: 11\n\nSELECT AVG(val) FROM numbers;\n-- Expected: 2.75 (11/4, not 11/5)\n\nSELECT MIN(val), MAX(val) FROM numbers;\n-- Expected: 1, 5\n```\n\n**Empty table handling:**\n```sql\nSELECT COUNT(*), SUM(val), AVG(val) FROM numbers WHERE 1=0;\n-- Expected: 0, NULL, NULL\n```\n\n**GROUP BY:**\n```sql\nCREATE TABLE orders (customer_id INTEGER, amount INTEGER);\nINSERT INTO orders VALUES (1, 100), (1, 200), (2, 50), (2, 75), (2, 25);\n\nSELECT customer_id, COUNT(*), SUM(amount)\nFROM orders\nGROUP BY customer_id;\n-- Expected: (1, 2, 300), (2, 3, 150)\n```\n\n**HAVING:**\n```sql\nSELECT customer_id, SUM(amount)\nFROM orders\nGROUP BY customer_id\nHAVING SUM(amount) > 200;\n-- Expected: (1, 300)\n```\n\n**INNER JOIN:**\n```sql\nCREATE TABLE customers (id INTEGER, name TEXT);\nINSERT INTO customers VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');\n\nSELECT c.name, o.amount\nFROM customers c\nJOIN orders o ON c.id = o.customer_id;\n-- Expected: (Alice, 100), (Alice, 200), (Bob, 50), (Bob, 75), (Bob, 25)\n```\n\n**JOIN with WHERE:**\n```sql\nSELECT c.name, o.amount\nFROM customers c\nJOIN orders o ON c.id = o.customer_id\nWHERE o.amount > 100;\n-- Expected: (Alice, 100), (Alice, 200)\n-- Wait, 100 is not > 100, so just (Alice, 200)\n```\n\n**Multiple aggregates:**\n```sql\nSELECT \n    COUNT(*) as total,\n    COUNT(val) as non_null,\n    SUM(val) as sum_val,\n    AVG(val) as avg_val,\n    MIN(val) as min_val,\n    MAX(val) as max_val\nFROM numbers;\n-- Expected: 5, 4, 11, 2.75, 1, 5\n```\n\n**JOIN with no matches:**\n```sql\nSELECT c.name, o.amount\nFROM customers c\nJOIN orders o ON c.id = o.customer_id\nWHERE c.id = 3;  -- Charlie has no orders\n-- Expected: (empty result set)\n```\n\n---\n\n## Knowledge Cascade: What This Unlocks\n\nYou've just implemented **aggregation and joins**—the features that make SQL a powerful analytical language. Here's where this connects:\n\n**Immediate connections:**\n- **Query planner (Milestone 8)**: The planner now has more decisions to make. Should a join use nested loop, hash join, or merge join? Should GROUP BY use hashing or sorting? Cost estimation becomes more complex.\n- **All previous execution**: Aggregates and joins build on the cursor, expression evaluation, and projection infrastructure you already built.\n\n**Same domain:**\n- **Hash aggregation in analytical databases**: DuckDB and ClickHouse use vectorized hash aggregation, processing batches of rows at once for SIMD efficiency. Your row-by-row approach is correct but slower.\n- **Window functions**: `ROW_NUMBER()`, `RANK()`, `LEAD()`, `LAG()` extend aggregation to operate over sliding windows. They use similar partitioning logic to GROUP BY.\n- **Star schema queries in data warehouses**: The canonical analytical query joins a fact table (orders) with dimension tables (customers, products, time). Your JOIN implementation is the foundation.\n\n**Cross-domain:**\n- **MapReduce and data pipelines**: GROUP BY is essentially a map phase (grouping by key) followed by reduce (aggregation). Hadoop's MapReduce, Spark's `groupBy().agg()`, and your SQL GROUP BY all implement the same pattern.\n- **Stream processing windowing**: Aggregates over time windows in Kafka Streams, Flink, and ksqlDB follow the same accumulation pattern. The difference is that window aggregates must handle late-arriving data and eviction.\n- **Query engine vectorization**: Modern databases (ClickHouse, DuckDB, Velox) batch aggregate operations for SIMD acceleration. Instead of `Update(value)` per row, they do `UpdateBatch(values[])` with CPU vector instructions.\n- **ORM N+1 query problem**: Understanding JOINs reveals why ORMs sometimes emit hundreds of queries. An ORM loading `Post` objects with `comments` might N+1: one query for posts, then N queries for each post's comments. A proper JOIN would fetch everything in one query. Understanding JOIN execution helps diagnose and fix these performance issues.\n- **Pandas groupby operations**: Python's `df.groupby('column').agg({'value': 'sum'})` is semantically identical to SQL's `GROUP BY column` with `SUM(value)`. The implementation differs (vectorized operations vs row-by-row), but the abstraction is the same.\n\n**Forward:**\n- **With this knowledge, you could now build**: A data pipeline that extracts groups from a database and processes them in parallel; a query analyzer that detects N+1 patterns in ORM queries; or a stream processor that computes windowed aggregates over event data.\n\nAggregation and joins are where SQL becomes a *query language* rather than just a data access layer. You can now answer analytical questions: \"What's the average order value by customer segment?\" \"Which products are frequently bought together?\" \"How has revenue changed over time?\" These are the questions that drive business decisions—and your database can now answer them.\n\n---\n<!-- END_MS -->\n\n\n\n\n# TDD\n\nA complete embedded SQL database engine implementing the SQLite architecture: tokenizer, recursive-descent parser, bytecode compiler (VDBE), register-based virtual machine, page-based B-tree/B+tree storage with slotted page format, LRU buffer pool manager, cost-based query planner with statistics, and ACID transactions via both rollback journal and write-ahead logging. The system processes SQL through a multi-stage pipeline where text becomes tokens, tokens become AST, AST becomes bytecode, and bytecode executes against a durable storage engine.\n\n\n\n<!-- TDD_MOD_ID: build-sqlite-m1 -->\n# Technical Design Specification: SQL Tokenizer\n\n## Module Charter\n\nThe SQL Tokenizer converts raw SQL text strings into a stream of typed Token objects through character-by-character finite state machine processing. It handles SQL keywords (case-insensitive), string literals with escaped single quotes, numeric literals (integers and floats), single/multi-character operators, punctuation, quoted identifiers, and line comments. The tokenizer does NOT parse SQL syntax, validate query structure, or interpret token semantics—it produces only the token stream for downstream parser consumption. Upstream dependencies: none (accepts raw string). Downstream dependencies: SQL Parser consumes token stream. Invariants: every character in input is consumed exactly once; token line/column positions are monotonically increasing; the tokenizer never emits partial tokens on error (always ERROR token at failure point).\n\n---\n\n## File Structure\n\n```\ntokenizer/\n├── token.go           # (1) Token types and Token struct\n├── tokenizer.go       # (2) Tokenizer struct and state machine\n├── keywords.go        # (3) SQL keyword map\n├── lexer.go           # (4) Core tokenization methods\n├── string_lit.go      # (5) String literal handling with escapes\n├── number.go          # (6) Numeric literal parsing\n├── operator.go        # (7) Operator and punctuation recognition\n├── tokenizer_test.go  # (8) Test suite (20+ SQL statements)\n└── errors.go          # (9) Error types with position info\n```\n\n---\n\n## Complete Data Model\n\n### Token Type Enumeration\n\n```go\ntype TokenType int\n\nconst (\n    // Sentinel\n    EOF TokenType = iota\n    ERROR\n\n    // Literals\n    KEYWORD      // SQL reserved word (SELECT, FROM, WHERE, etc.)\n    IDENTIFIER   // Unquoted identifier (table_name, column_name)\n    QUOTED_ID    // Double-quoted identifier (\"column name\")\n    STRING       // Single-quoted string literal ('hello')\n    NUMBER       // Numeric literal (42, 3.14, -7)\n    \n    // Operators\n    OPERATOR     // =, <, >, <=, >=, !=, <>, +, -, *, /\n    \n    // Punctuation\n    PUNCTUATION  // (, ), ,, ;, .\n)\n\nfunc (t TokenType) String() string {\n    switch t {\n    case EOF: return \"EOF\"\n    case ERROR: return \"ERROR\"\n    case KEYWORD: return \"KEYWORD\"\n    case IDENTIFIER: return \"IDENTIFIER\"\n    case QUOTED_ID: return \"QUOTED_ID\"\n    case STRING: return \"STRING\"\n    case NUMBER: return \"NUMBER\"\n    case OPERATOR: return \"OPERATOR\"\n    case PUNCTUATION: return \"PUNCTUATION\"\n    default: return \"UNKNOWN\"\n    }\n}\n```\n\n### Token Structure\n\n```go\ntype Token struct {\n    Type     TokenType   // Classification of this token\n    Value    string      // Raw text of the token (preserves original case)\n    Line     int         // 1-indexed line number where token starts\n    Column   int         // 1-indexed column number where token starts\n    NumType  NumType     // Only valid when Type == NUMBER\n}\n\ntype NumType int\n\nconst (\n    NumInteger NumType = iota\n    NumFloat\n)\n\n// WHY each field exists:\n// - Type: Parser dispatches on token type (KEYWORD vs IDENTIFIER)\n// - Value: Needed for identifiers (table/column names) and literals\n// - Line/Column: Enables precise error messages pointing to source location\n// - NumType: Distinguishes 42 (can be INTEGER column type) from 3.14 (REAL)\n```\n\n### Tokenizer State Machine\n\n```go\ntype LexerState int\n\nconst (\n    StateDefault LexerState = iota    // Normal code space, outside any literal\n    StateInString                     // Inside single-quoted string literal\n    StateInQuotedID                   // Inside double-quoted identifier\n    StateInNumber                     // Parsing numeric literal\n    StateInIdentifier                 // Parsing unquoted identifier/keyword\n    StateInLineComment                // After --, consuming until newline\n    StateInBlockComment               // Inside /* ... */\n)\n\ntype Tokenizer struct {\n    input    string      // The raw SQL text\n    pos      int         // Current byte position in input (0-indexed)\n    line     int         // Current line number (1-indexed)\n    column   int         // Current column number (1-indexed)\n    state    LexerState  // Current FSM state\n    keywords map[string]bool  // Keyword lookup (uppercase -> true)\n    \n    // Configuration\n    allowUnicodeIDs bool  // If false, only ASCII identifiers allowed\n}\n\n// Invariants during tokenization:\n// - pos always advances forward (never backward)\n// - line/column accurately track source position\n// - state always reflects the current parsing context\n// - keywords map is initialized once and never modified\n```\n\n### Keyword Map\n\n```go\n// keywords.go\nvar SQLKeywords = map[string]bool{\n    // Query structure\n    \"SELECT\": true, \"FROM\": true, \"WHERE\": true, \"GROUP\": true, \"BY\": true,\n    \"HAVING\": true, \"ORDER\": true, \"LIMIT\": true, \"OFFSET\": true,\n    \"DISTINCT\": true, \"ALL\": true, \"AS\": true,\n    \n    // DML\n    \"INSERT\": true, \"INTO\": true, \"VALUES\": true, \"UPDATE\": true, \"SET\": true,\n    \"DELETE\": true,\n    \n    // DDL\n    \"CREATE\": true, \"TABLE\": true, \"INDEX\": true, \"UNIQUE\": true,\n    \"DROP\": true, \"ALTER\": true, \"ADD\": true, \"COLUMN\": true,\n    \n    // Data types\n    \"INTEGER\": true, \"INT\": true, \"TEXT\": true, \"REAL\": true,\n    \"BLOB\": true, \"NULL\": true, \"BOOLEAN\": true, \"BOOL\": true,\n    \n    // Constraints\n    \"PRIMARY\": true, \"KEY\": true, \"FOREIGN\": true, \"REFERENCES\": true,\n    \"NOT\": true, \"CONSTRAINT\": true, \"CHECK\": true, \"DEFAULT\": true,\n    \n    // Joins\n    \"JOIN\": true, \"INNER\": true, \"LEFT\": true, \"RIGHT\": true, \"OUTER\": true,\n    \"CROSS\": true, \"ON\": true, \"USING\": true,\n    \n    // Logical operators\n    \"AND\": true, \"OR\": true, \"NOT\": true, \"IN\": true, \"BETWEEN\": true,\n    \"LIKE\": true, \"IS\": true, \"EXISTS\": true,\n    \n    // Comparison\n    \"NULL\": true, \"TRUE\": true, \"FALSE\": true,\n    \n    // Sorting\n    \"ASC\": true, \"DESC\": true,\n    \n    // Transactions\n    \"BEGIN\": true, \"COMMIT\": true, \"ROLLBACK\": true, \"TRANSACTION\": true,\n    \n    // Aggregates\n    \"COUNT\": true, \"SUM\": true, \"AVG\": true, \"MIN\": true, \"MAX\": true,\n    \n    // Case expressions\n    \"CASE\": true, \"WHEN\": true, \"THEN\": true, \"ELSE\": true, \"END\": true,\n    \n    // Misc\n    \"UNION\": true, \"EXCEPT\": true, \"INTERSECT\": true,\n    \"CAST\": true, \"COLLATE\": true, \"NOCASE\": true,\n    \"PRAGMA\": true, \"ANALYZE\": true, \"EXPLAIN\": true,\n    \"IF\": true, \"AUTOINCREMENT\": true, \"TEMP\": true, \"TEMPORARY\": true,\n}\n```\n\n---\n\n## Interface Contracts\n\n### Constructor\n\n```go\n// NewTokenizer creates a tokenizer for the given SQL input.\n// The input string is not modified; the tokenizer holds a reference.\n// Line and column tracking starts at 1, 1.\nfunc NewTokenizer(input string) *Tokenizer\n```\n\n### Primary Method: NextToken\n\n```go\n// NextToken returns the next token in the stream.\n// \n// Returns:\n//   - Token with Type == EOF when input is exhausted\n//   - Token with Type == ERROR when tokenization fails\n//   - Otherwise, a valid token with populated fields\n//\n// Post-conditions:\n//   - Tokenizer position has advanced past the returned token\n//   - Line/column reflect the position AFTER the token\n//   - Subsequent calls return subsequent tokens\n//\n// Error handling:\n//   - Unclosed string: returns ERROR with value of partial string and position at opening quote\n//   - Unclosed quoted ID: returns ERROR with partial content and position at opening quote\n//   - Unrecognized character: returns ERROR with that single character and its position\n//   - Invalid numeric literal: returns ERROR with the invalid portion\nfunc (t *Tokenizer) NextToken() Token\n```\n\n### TokenizeAll (Convenience)\n\n```go\n// TokenizeAll returns all tokens until EOF or first ERROR.\n// If an ERROR token is encountered, returns tokens up to and including the ERROR.\n// Complexity: O(n) where n is input length.\nfunc (t *Tokenizer) TokenizeAll() []Token\n```\n\n### Position Queries\n\n```go\n// Position returns the current line and column (1-indexed).\n// Useful for error reporting when caller detects semantic errors.\nfunc (t *Tokenizer) Position() (line, column int)\n\n// HasMore returns true if there are more characters to process.\nfunc (t *Tokenizer) HasMore() bool\n```\n\n---\n\n## Algorithm Specification\n\n### Main Tokenization Loop\n\n```\nALGORITHM: NextToken\nINPUT: Tokenizer t with current position in input\nOUTPUT: Next Token from input\n\n1. Skip whitespace and comments\n   WHILE current character is whitespace OR in a comment:\n     IF current is '-' AND next is '-':\n       Skip until newline (line comment)\n     ELSE IF current is '/' AND next is '*':\n       Skip until '*/' (block comment)\n     ELSE IF current is whitespace:\n       Advance one character, updating line/column\n     ELSE:\n       BREAK\n\n2. IF at end of input:\n     RETURN Token{Type: EOF, Line: t.line, Column: t.column}\n\n3. Let ch = current character, line = t.line, column = t.column\n\n4. SWITCH on ch:\n   CASE ''' (single quote):\n     RETURN readStringLiteral()\n   \n   CASE '\"' (double quote):\n     RETURN readQuotedIdentifier()\n   \n   CASE digit '0'-'9' OR (ch == '.' AND next is digit):\n     RETURN readNumberLiteral()\n   \n   CASE letter 'a'-'z', 'A'-'Z' OR '_':\n     RETURN readIdentifierOrKeyword()\n   \n   CASE one of '(', ')', ',', ';', '.':\n     Advance one character\n     RETURN Token{Type: PUNCTUATION, Value: string(ch), Line: line, Column: column}\n   \n   CASE one of '=', '<', '>', '!', '+', '-', '*', '/':\n     RETURN readOperator()\n   \n   DEFAULT:\n     Advance one character\n     RETURN Token{Type: ERROR, Value: string(ch), Line: line, Column: column}\n\nPOST-CONDITION: Tokenizer position is immediately after the returned token\n```\n\n### String Literal Parsing\n\n```\nALGORITHM: readStringLiteral\nPRE-CONDITION: Current character is ''' (opening quote)\nPOST-CONDITION: Returns STRING token or ERROR token\n\n1. Let startLine = t.line, startColumn = t.column\n2. Advance past opening quote\n3. Let value = empty string builder\n\n4. WHILE not at end of input:\n     a. Let ch = current character\n     \n     b. IF ch is ''' (single quote):\n        i.   IF next character is also ''' (escaped quote):\n               Append ''' to value\n               Advance TWO characters  // Skip both quotes\n        ii.  ELSE:\n               // Closing quote found\n               Advance one character\n               RETURN Token{Type: STRING, Value: value, Line: startLine, Column: startColumn}\n     \n     c. IF ch is newline:\n        Append ch to value\n        Advance, incrementing line, reset column to 1\n     \n     d. ELSE:\n        Append ch to value\n        Advance one character, incrementing column\n\n5. // Reached end of input without closing quote\n   RETURN Token{Type: ERROR, Value: \"unclosed string literal\", Line: startLine, Column: startColumn}\n```\n\n### Numeric Literal Parsing\n\n```\nALGORITHM: readNumberLiteral\nPRE-CONDITION: Current position is start of a number\nPOST-CONDITION: Returns NUMBER token or ERROR token\n\n1. Let startLine = t.line, startColumn = t.column\n2. Let start = t.pos\n3. Let isFloat = false\n4. Let hasExponent = false\n\n5. // Handle leading digits\n   WHILE current is digit '0'-'9':\n     Advance\n\n6. // Handle decimal point\n   IF current is '.' AND next is digit:\n     isFloat = true\n     Advance  // skip '.'\n     WHILE current is digit:\n       Advance\n\n7. // Handle exponent (optional enhancement)\n   IF current is 'e' OR 'E':\n     hasExponent = true\n     isFloat = true\n     Advance\n     IF current is '+' OR '-':\n       Advance\n     IF current is NOT digit:\n       RETURN Token{Type: ERROR, Value: \"invalid exponent\", Line: startLine, Column: startColumn}\n     WHILE current is digit:\n       Advance\n\n8. Let value = input[start : t.pos]\n\n9. IF isFloat:\n     RETURN Token{Type: NUMBER, Value: value, Line: startLine, Column: startColumn, NumType: NumFloat}\n   ELSE:\n     RETURN Token{Type: NUMBER, Value: value, Line: startLine, Column: startColumn, NumType: NumInteger}\n```\n\n### Identifier/Keyword Recognition\n\n```\nALGORITHM: readIdentifierOrKeyword\nPRE-CONDITION: Current character is letter or underscore\nPOST-CONDITION: Returns IDENTIFIER or KEYWORD token\n\n1. Let startLine = t.line, startColumn = t.column\n2. Let start = t.pos\n\n3. WHILE current is letter, digit, or underscore:\n     Advance\n\n4. Let value = input[start : t.pos]  // Preserves original case\n\n5. Let upperValue = uppercase(value)\n\n6. IF upperValue is in keyword map:\n     RETURN Token{Type: KEYWORD, Value: value, Line: startLine, Column: startColumn}\n   ELSE:\n     RETURN Token{Type: IDENTIFIER, Value: value, Line: startLine, Column: startColumn}\n```\n\n### Operator Recognition\n\n```\nALGORITHM: readOperator\nPRE-CONDITION: Current character starts an operator\nPOST-CONDITION: Returns OPERATOR token\n\n1. Let startLine = t.line, startColumn = t.column\n2. Let ch = current character\n\n3. SWITCH on ch:\n   CASE '<':\n     Advance\n     IF current is '=':\n       Advance\n       RETURN Token{Type: OPERATOR, Value: \"<=\", Line: startLine, Column: startColumn}\n     IF current is '>':\n       Advance\n       RETURN Token{Type: OPERATOR, Value: \"<>\", Line: startLine, Column: startColumn}\n     RETURN Token{Type: OPERATOR, Value: \"<\", Line: startLine, Column: startColumn}\n   \n   CASE '>':\n     Advance\n     IF current is '=':\n       Advance\n       RETURN Token{Type: OPERATOR, Value: \">=\", Line: startLine, Column: startColumn}\n     RETURN Token{Type: OPERATOR, Value: \">\", Line: startLine, Column: startColumn}\n   \n   CASE '!':\n     Advance\n     IF current is '=':\n       Advance\n       RETURN Token{Type: OPERATOR, Value: \"!=\", Line: startLine, Column: startColumn}\n     // '!' alone is not a valid SQL operator - could be ERROR, but some dialects allow it\n     RETURN Token{Type: OPERATOR, Value: \"!\", Line: startLine, Column: startColumn}\n   \n   CASE '=':\n     Advance\n     RETURN Token{Type: OPERATOR, Value: \"=\", Line: startLine, Column: startColumn}\n   \n   CASE '+', '-', '*', '/':\n     Advance\n     RETURN Token{Type: OPERATOR, Value: string(ch), Line: startLine, Column: startColumn}\n   \n   CASE '|':\n     IF next is '|':\n       Advance twice\n       RETURN Token{Type: OPERATOR, Value: \"||\", Line: startLine, Column: startColumn}\n     // Single '|' not valid - return ERROR or handle per dialect\n\n4. // Should not reach here given pre-condition\n   RETURN Token{Type: ERROR, Value: string(ch), Line: startLine, Column: startColumn}\n```\n\n---\n\n## Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n|-------|-------------|----------|---------------|\n| Unclosed string literal | `readStringLiteral`: EOF before closing quote | Return ERROR token with position of opening quote; subsequent calls return EOF | Yes: \"unclosed string literal at line X, column Y\" |\n| Unclosed quoted identifier | `readQuotedIdentifier`: EOF before closing quote | Return ERROR token with position of opening quote | Yes: \"unclosed quoted identifier at line X, column Y\" |\n| Unrecognized character | Main loop: character doesn't match any token start | Return ERROR token for that character; advance one position; continue | Yes: \"unexpected character 'X' at line Y, column Z\" |\n| Invalid numeric literal | `readNumberLiteral`: exponent without digits | Return ERROR token; position at start of invalid number | Yes: \"invalid numeric literal at line X, column Y\" |\n| Unclosed block comment | Comment skipping: EOF before `*/` | Silently return EOF (comment is discarded) | No: Treated as if query ended |\n\n---\n\n## Implementation Sequence with Checkpoints\n\n### Phase 1: Token Structure and State Machine Skeleton (1 hour)\n\n**Files to create**: `token.go`, `tokenizer.go`, `errors.go`\n\n**Implementation**:\n1. Define `TokenType` enum and `Token` struct\n2. Define `Tokenizer` struct with position tracking\n3. Implement `NewTokenizer` constructor\n4. Implement `NextToken` skeleton that returns EOF\n\n**Checkpoint**: At this point you should be able to create a tokenizer and get EOF tokens. Run:\n```bash\ngo test -run TestEmptyInput\n# Expected: PASS\n```\n\n### Phase 2: Keyword Recognition (0.5 hours)\n\n**Files to create**: `keywords.go`\n\n**Implementation**:\n1. Define `SQLKeywords` map\n2. Implement `readIdentifierOrKeyword`\n3. Implement letter/digit/underscore advancement\n4. Implement case-insensitive keyword lookup\n\n**Checkpoint**: At this point you should be able to tokenize `SELECT FROM WHERE`. Run:\n```bash\ngo test -run TestKeywords\n# Expected: PASS (SELECT -> KEYWORD, FROM -> KEYWORD, etc.)\n```\n\n### Phase 3: String Literal Parsing with Escape Handling (1 hour)\n\n**Files to create**: `string_lit.go`\n\n**Implementation**:\n1. Implement `readStringLiteral`\n2. Handle escaped single quotes (`''` → `'`)\n3. Handle newlines within strings (multi-line strings are valid in SQL)\n4. Handle unclosed string error\n\n**Checkpoint**: At this point you should be able to tokenize `'hello'`, `'it''s'`, and detect unclosed strings. Run:\n```bash\ngo test -run TestStringLiterals\n# Expected: PASS (includes escape and error cases)\n```\n\n### Phase 4: Numeric Literal Parsing (0.5 hours)\n\n**Files to create**: `number.go`\n\n**Implementation**:\n1. Implement `readNumberLiteral`\n2. Handle integers: `42`, `0`, `007`\n3. Handle floats: `3.14`, `0.5`, `.5` (if supported)\n4. Distinguish INTEGER vs FLOAT in `NumType`\n\n**Checkpoint**: At this point you should be able to tokenize `42`, `3.14`, and distinguish types. Run:\n```bash\ngo test -run TestNumbers\n# Expected: PASS (integer vs float distinction)\n```\n\n### Phase 5: Operator and Punctuation Tokenization (0.5 hours)\n\n**Files to create**: `operator.go`\n\n**Implementation**:\n1. Implement `readOperator`\n2. Handle single-char operators: `=`, `<`, `>`, `+`, `-`, `*`, `/`\n3. Handle multi-char operators: `<=`, `>=`, `!=`, `<>`, `||`\n4. Handle punctuation: `(`, `)`, `,`, `;`, `.`\n\n**Checkpoint**: At this point you should be able to tokenize `a <= b` and `x || y`. Run:\n```bash\ngo test -run TestOperators\n# Expected: PASS (all operators recognized)\n```\n\n### Phase 6: Quoted Identifiers, Comments, and Error Cases (0.5 hours)\n\n**Files to update**: `lexer.go`, `tokenizer_test.go`\n\n**Implementation**:\n1. Implement `readQuotedIdentifier`\n2. Implement line comment skipping (`--`)\n3. Implement block comment skipping (`/* */`)\n4. Implement unrecognized character error\n\n**Checkpoint**: At this point you should pass the full test suite. Run:\n```bash\ngo test -v ./tokenizer\n# Expected: All tests PASS, including 20+ diverse SQL statements\n```\n\n---\n\n## Test Specification\n\n### Test Categories\n\n```go\n// tokenizer_test.go\n\nfunc TestEmptyInput(t *testing.T) {\n    tok := NewTokenizer(\"\")\n    assert.Equal(t, Token{Type: EOF, Line: 1, Column: 1}, tok.NextToken())\n}\n\nfunc TestKeywords(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected []Token\n    }{\n        {\n            input: \"SELECT\",\n            expected: []Token{\n                {Type: KEYWORD, Value: \"SELECT\", Line: 1, Column: 1},\n                {Type: EOF, Line: 1, Column: 7},\n            },\n        },\n        {\n            input: \"select SELECT Select\",\n            expected: []Token{\n                {Type: KEYWORD, Value: \"select\", Line: 1, Column: 1},\n                {Type: KEYWORD, Value: \"SELECT\", Line: 1, Column: 8},\n                {Type: KEYWORD, Value: \"Select\", Line: 1, Column: 15},\n                {Type: EOF, Line: 1, Column: 21},\n            },\n        },\n    }\n    // ... test execution\n}\n\nfunc TestIdentifiers(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected []Token\n    }{\n        {input: \"users\", expected: []Token{{Type: IDENTIFIER, Value: \"users\", Line: 1, Column: 1}}},\n        {input: \"_private\", expected: []Token{{Type: IDENTIFIER, Value: \"_private\", Line: 1, Column: 1}}},\n        {input: \"table123\", expected: []Token{{Type: IDENTIFIER, Value: \"table123\", Line: 1, Column: 1}}},\n    }\n}\n\nfunc TestStringLiterals(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected Token\n    }{\n        {input: \"'hello'\", expected: Token{Type: STRING, Value: \"hello\"}},\n        {input: \"''\", expected: Token{Type: STRING, Value: \"\"}}, // Empty string\n        {input: \"'it''s'\", expected: Token{Type: STRING, Value: \"it's\"}}, // Escaped quote\n        {input: \"''''\", expected: Token{Type: STRING, Value: \"'\"}}, // Single quote\n        {input: \"'hello\\nworld'\", expected: Token{Type: STRING, Value: \"hello\\nworld\"}}, // Multiline\n    }\n}\n\nfunc TestStringErrors(t *testing.T) {\n    tests := []struct {\n        input       string\n        expectError bool\n        errorLine   int\n        errorCol    int\n    }{\n        {input: \"'unclosed\", expectError: true, errorLine: 1, errorCol: 1},\n        {input: \"'unclosed\\n\", expectError: true, errorLine: 1, errorCol: 1},\n    }\n}\n\nfunc TestNumbers(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected Token\n    }{\n        {input: \"42\", expected: Token{Type: NUMBER, Value: \"42\", NumType: NumInteger}},\n        {input: \"0\", expected: Token{Type: NUMBER, Value: \"0\", NumType: NumInteger}},\n        {input: \"3.14\", expected: Token{Type: NUMBER, Value: \"3.14\", NumType: NumFloat}},\n        {input: \"0.5\", expected: Token{Type: NUMBER, Value: \"0.5\", NumType: NumFloat}},\n        {input: \".5\", expected: Token{Type: NUMBER, Value: \".5\", NumType: NumFloat}}, // If supported\n    }\n}\n\nfunc TestOperators(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected []Token\n    }{\n        {input: \"=\", expected: []Token{{Type: OPERATOR, Value: \"=\"}}},\n        {input: \"<\", expected: []Token{{Type: OPERATOR, Value: \"<\"}}},\n        {input: \"<=\", expected: []Token{{Type: OPERATOR, Value: \"<=\"}}},\n        {input: \">=\", expected: []Token{{Type: OPERATOR, Value: \">=\"}}},\n        {input: \"!=\", expected: []Token{{Type: OPERATOR, Value: \"!=\"}}},\n        {input: \"<>\", expected: []Token{{Type: OPERATOR, Value: \"<>\"}}},\n        {input: \"||\", expected: []Token{{Type: OPERATOR, Value: \"||\"}}},\n    }\n}\n\nfunc TestQuotedIdentifiers(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected Token\n    }{\n        {input: `\"column name\"`, expected: Token{Type: QUOTED_ID, Value: \"column name\"}},\n        {input: `\"SELECT\"`, expected: Token{Type: QUOTED_ID, Value: \"SELECT\"}}, // Not a keyword!\n    }\n}\n\nfunc TestComments(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected []Token\n    }{\n        {input: \"-- comment\\nSELECT\", expected: []Token{{Type: KEYWORD, Value: \"SELECT\"}}},\n        {input: \"/* block */SELECT\", expected: []Token{{Type: KEYWORD, Value: \"SELECT\"}}},\n        {input: \"/* multi\\nline */SELECT\", expected: []Token{{Type: KEYWORD, Value: \"SELECT\"}}},\n    }\n}\n\nfunc TestComplexStatements(t *testing.T) {\n    // 20+ diverse SQL statements\n    statements := []string{\n        \"SELECT * FROM users\",\n        \"SELECT id, name FROM users WHERE age > 18\",\n        \"SELECT * FROM users WHERE active = 1 AND role = 'admin'\",\n        \"INSERT INTO users (id, name) VALUES (1, 'Alice')\",\n        \"INSERT INTO users VALUES (2, 'Bob', 'bob@example.com')\",\n        \"UPDATE users SET name = 'Charlie' WHERE id = 1\",\n        \"DELETE FROM users WHERE id = 1\",\n        \"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)\",\n        \"CREATE TABLE \\\"Order Items\\\" (id INTEGER, qty INTEGER NOT NULL)\",\n        \"SELECT * FROM users ORDER BY name DESC LIMIT 10\",\n        \"SELECT COUNT(*) FROM users\",\n        \"SELECT status, COUNT(*) FROM orders GROUP BY status\",\n        \"BEGIN TRANSACTION\",\n        \"COMMIT\",\n        \"ROLLBACK\",\n        \"CREATE INDEX idx_email ON users(email)\",\n        \"SELECT * FROM users WHERE email LIKE '%@example.com'\",\n        \"SELECT * FROM users WHERE id IN (1, 2, 3)\",\n        \"SELECT * FROM users WHERE created_at BETWEEN '2024-01-01' AND '2024-12-31'\",\n        \"SELECT a.name, b.name FROM users a JOIN users b ON a.id = b.manager_id\",\n        \"SELECT * FROM users WHERE name IS NULL\",\n        \"SELECT * FROM users WHERE name IS NOT NULL\",\n        \"PRAGMA journal_mode=WAL\",\n        \"EXPLAIN SELECT * FROM users\",\n        \"ANALYZE users\",\n    }\n    \n    for _, stmt := range statements {\n        tok := NewTokenizer(stmt)\n        tokens := tok.TokenizeAll()\n        \n        // Verify no ERROR tokens (except for intentionally invalid inputs)\n        for _, token := range tokens {\n            if token.Type == ERROR {\n                t.Errorf(\"Unexpected error tokenizing %q: %v\", stmt, token)\n            }\n        }\n        \n        // Verify last token is EOF\n        if len(tokens) > 0 && tokens[len(tokens)-1].Type != EOF {\n            t.Errorf(\"Expected EOF as last token for %q\", stmt)\n        }\n    }\n}\n\nfunc TestPositionTracking(t *testing.T) {\n    input := \"SELECT *\\nFROM users\\nWHERE id = 1\"\n    tok := NewTokenizer(input)\n    \n    tokens := tok.TokenizeAll()\n    \n    // Verify line/column positions\n    expected := []Token{\n        {Type: KEYWORD, Value: \"SELECT\", Line: 1, Column: 1},\n        {Type: OPERATOR, Value: \"*\", Line: 1, Column: 8},\n        {Type: KEYWORD, Value: \"FROM\", Line: 2, Column: 1},\n        {Type: IDENTIFIER, Value: \"users\", Line: 2, Column: 6},\n        {Type: KEYWORD, Value: \"WHERE\", Line: 3, Column: 1},\n        {Type: IDENTIFIER, Value: \"id\", Line: 3, Column: 7},\n        {Type: OPERATOR, Value: \"=\", Line: 3, Column: 10},\n        {Type: NUMBER, Value: \"1\", Line: 3, Column: 12},\n    }\n    \n    for i, exp := range expected {\n        if tokens[i] != exp {\n            t.Errorf(\"Token %d: expected %v, got %v\", i, exp, tokens[i])\n        }\n    }\n}\n```\n\n---\n\n## Performance Targets\n\n| Operation | Target | How to Measure |\n|-----------|--------|----------------|\n| Tokenize 10KB SQL file | < 1ms | `go test -bench=BenchmarkTokenize10KB` |\n| Tokenize 20 diverse statements | < 10ms total | `go test -bench=BenchmarkDiverseStatements` |\n| Memory per 1000 tokens | < 100KB | `go test -memprofile` and analyze |\n| Single-pass processing | No backtracking | Code review: verify no `pos--` or similar |\n\n---\n\n## Synced Criteria\n\n[[CRITERIA_JSON: {\"module_id\": \"build-sqlite-m1\", \"criteria\": [\"Tokenizer recognizes SQL keywords (SELECT, INSERT, CREATE, WHERE, JOIN, etc.) case-insensitively\", \"String literals enclosed in single quotes are parsed including escaped quotes ('it''s' → it's)\", \"Numeric literals including integers and floating-point values (42, 3.14) are recognized as distinct token types\", \"Operators (=, <, >, <=, >=, !=, <>) and punctuation (comma, parentheses, semicolon) are tokenized as distinct tokens\", \"Identifiers (table names, column names) support quoted identifiers with double quotes (\\\"column name\\\")\", \"Tokenizer reports error position (line and column) for unrecognized characters\", \"Token stream correctly tokenizes at least 20 diverse SQL statements in a test suite\", \"The tokenizer returns a list or stream of objects containing type, value, line, and column\"]}]\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-sqlite-m2 -->\n# Technical Design Specification: SQL Parser (AST)\n\n## Module Charter\n\nThe SQL Parser transforms a token stream into a hierarchical Abstract Syntax Tree (AST) using recursive descent parsing. It handles SELECT statements (columns, FROM, WHERE, ORDER BY, LIMIT), INSERT statements (table, columns, VALUES), CREATE TABLE statements (column definitions, constraints), and arbitrary expressions with correct operator precedence via precedence climbing. The parser does NOT validate table existence, execute queries, or check semantic constraints—it produces a syntactically valid AST for downstream compilation. Upstream dependencies: Tokenizer (consumes token stream). Downstream dependencies: Bytecode Compiler (consumes AST). Invariants: every token is consumed exactly once; the AST root is always a Statement type; expression trees respect SQL precedence rules (NOT > comparison > AND > OR); all error positions point to specific token locations.\n\n---\n\n## File Structure\n\n```\nparser/\n├── ast.go              # (1) AST node type definitions\n├── parser.go           # (2) Parser struct and core dispatch\n├── select.go           # (3) SELECT statement parsing\n├── insert.go           # (4) INSERT statement parsing\n├── create.go           # (5) CREATE TABLE parsing\n├── expression.go       # (6) Expression parsing with precedence climbing\n├── precedence.go       # (7) Operator precedence table\n├── errors.go           # (8) ParseError type with position info\n├── parser_test.go      # (9) Test suite (15+ valid, 10+ invalid)\n└── ast_printer.go      # (10) AST pretty-printing for debugging\n```\n\n---\n\n## Complete Data Model\n\n### Statement Types (Root AST Nodes)\n\n```go\n// ast.go\n\ntype Statement interface {\n    isStatement()\n    Pos() Position  // Returns starting position for error reporting\n}\n\ntype Position struct {\n    Line   int\n    Column int\n}\n\n// SELECT statement\ntype SelectStatement struct {\n    Pos       Position\n    Columns   []ColumnSelection  // * or explicit column list\n    FromTable string             // Table name (required)\n    Alias     string             // Optional table alias (AS alias)\n    Where     Expression         // Optional WHERE clause\n    GroupBy   []Expression       // Optional GROUP BY columns\n    Having    Expression         // Optional HAVING clause\n    OrderBy   []OrderByColumn    // Optional ORDER BY\n    Limit     *int               // Optional LIMIT value\n    Offset    *int               // Optional OFFSET value\n}\n\nfunc (s *SelectStatement) isStatement() {}\nfunc (s *SelectStatement) Pos() Position { return s.Pos }\n\ntype ColumnSelection struct {\n    Expression Expression\n    Alias      string  // Optional: \"AS alias\"\n}\n\ntype OrderByColumn struct {\n    Expression Expression\n    Descending bool  // true for DESC, false for ASC (default)\n}\n\n// INSERT statement\ntype InsertStatement struct {\n    Pos        Position\n    Table      string          // Target table name\n    Columns    []string        // Optional column names (nil means all columns)\n    Values     [][]Expression  // One or more value tuples\n    Returning  []string        // Optional RETURNING columns (advanced)\n}\n\nfunc (s *InsertStatement) isStatement() {}\nfunc (s *InsertStatement) Pos() Position { return s.Pos }\n\n// CREATE TABLE statement\ntype CreateTableStatement struct {\n    Pos         Position\n    Table       string\n    IfNotExists bool\n    Columns     []ColumnDefinition\n    Constraints []TableConstraint  // Table-level constraints\n}\n\nfunc (s *CreateTableStatement) isStatement() {}\nfunc (s *CreateTableStatement) Pos() Position { return s.Pos }\n\ntype ColumnDefinition struct {\n    Name        string\n    Type        string              // INTEGER, TEXT, REAL, BLOB\n    Constraints []ColumnConstraint  // PRIMARY KEY, NOT NULL, etc.\n}\n\ntype ColumnConstraint interface {\n    isColumnConstraint()\n}\n\ntype PrimaryKeyConstraint struct {\n    AutoIncrement bool\n}\n\nfunc (c *PrimaryKeyConstraint) isColumnConstraint() {}\n\ntype NotNullConstraint struct{}\n\nfunc (c *NotNullConstraint) isColumnConstraint() {}\n\ntype UniqueConstraint struct{}\n\nfunc (c *UniqueConstraint) isColumnConstraint() {}\n\ntype DefaultConstraint struct {\n    Value Expression\n}\n\nfunc (c *DefaultConstraint) isColumnConstraint() {}\n\ntype CheckConstraint struct {\n    Expression Expression\n}\n\nfunc (c *CheckConstraint) isColumnConstraint() {}\n\ntype ForeignKeyConstraint struct {\n    ReferencesTable  string\n    ReferencesColumn string\n    OnDelete         string  // CASCADE, SET NULL, etc.\n    OnUpdate         string\n}\n\nfunc (c *ForeignKeyConstraint) isColumnConstraint() {}\n\ntype TableConstraint interface {\n    isTableConstraint()\n}\n\ntype TablePrimaryKeyConstraint struct {\n    Columns []string\n}\n\nfunc (c *TablePrimaryKeyConstraint) isTableConstraint() {}\n\ntype TableUniqueConstraint struct {\n    Columns []string\n}\n\nfunc (c *TableUniqueConstraint) isTableConstraint() {}\n\n// Other statements (stubs for extensibility)\ntype UpdateStatement struct {\n    Pos     Position\n    Table   string\n    Sets    []SetClause\n    Where   Expression\n}\n\ntype SetClause struct {\n    Column string\n    Value  Expression\n}\n\ntype DeleteStatement struct {\n    Pos   Position\n    Table string\n    Where Expression\n}\n\ntype CreateIndexStatement struct {\n    Pos       Position\n    IndexName string\n    Table     string\n    Columns   []string\n    Unique    bool\n}\n\ntype DropStatement struct {\n    Pos       Position\n    ObjectType string  // \"TABLE\" or \"INDEX\"\n    Name      string\n}\n\ntype BeginStatement struct {\n    Pos Position\n}\n\ntype CommitStatement struct {\n    Pos Position\n}\n\ntype RollbackStatement struct {\n    Pos Position\n}\n```\n\n### Expression Types\n\n```go\n// ast.go (continued)\n\ntype Expression interface {\n    isExpression()\n    Pos() Position\n}\n\n// Binary expression: a AND b, x = y, etc.\ntype BinaryExpression struct {\n    Pos      Position\n    Operator string      // AND, OR, =, <, >, <=, >=, !=, <>, +, -, *, /, ||, LIKE, IN, BETWEEN\n    Left     Expression\n    Right    Expression\n}\n\nfunc (e *BinaryExpression) isExpression() {}\nfunc (e *BinaryExpression) Pos() Position { return e.Pos }\n\n// Unary expression: NOT a, -5\ntype UnaryExpression struct {\n    Pos      Position\n    Operator string  // NOT, - (negation)\n    Operand  Expression\n}\n\nfunc (e *UnaryExpression) isExpression() {}\nfunc (e *UnaryExpression) Pos() Position { return e.Pos }\n\n// Literal value: 42, 'hello', NULL\ntype LiteralExpression struct {\n    Pos   Position\n    Value interface{}  // int64, float64, string, nil (for NULL)\n    Type  LiteralType\n}\n\ntype LiteralType int\n\nconst (\n    LiteralNull LiteralType = iota\n    LiteralInteger\n    LiteralFloat\n    LiteralString\n)\n\nfunc (e *LiteralExpression) isExpression() {}\nfunc (e *LiteralExpression) Pos() Position { return e.Pos }\n\n// Column reference: id, users.name\ntype IdentifierExpression struct {\n    Pos       Position\n    Name      string  // Column name\n    TableName string  // Optional table qualifier (for joins)\n}\n\nfunc (e *IdentifierExpression) isExpression() {}\nfunc (e *IdentifierExpression) Pos() Position { return e.Pos }\n\n// Function call: COUNT(*), SUM(amount)\ntype FunctionCallExpression struct {\n    Pos      Position\n    Name     string\n    Args     []Expression\n    Distinct bool  // COUNT(DISTINCT x)\n}\n\nfunc (e *FunctionCallExpression) isExpression() {}\nfunc (e *FunctionCallExpression) Pos() Position { return e.Pos }\n\n// Star expression: * in SELECT *\ntype StarExpression struct {\n    Pos       Position\n    TableName string  // Optional: table.* in joins\n}\n\nfunc (e *StarExpression) isExpression() {}\nfunc (e *StarExpression) Pos() Position { return e.Pos }\n\n// IN expression: x IN (1, 2, 3)\ntype InExpression struct {\n    Pos        Position\n    Expression Expression\n    Values     []Expression\n    Negated    bool  // NOT IN\n}\n\nfunc (e *InExpression) isExpression() {}\nfunc (e *InExpression) Pos() Position { return e.Pos }\n\n// BETWEEN expression: x BETWEEN 1 AND 10\ntype BetweenExpression struct {\n    Pos        Position\n    Expression Expression\n    Low        Expression\n    High       Expression\n    Negated    bool  // NOT BETWEEN\n}\n\nfunc (e *BetweenExpression) isExpression() {}\nfunc (e *BetweenExpression) Pos() Position { return e.Pos }\n\n// IS NULL / IS NOT NULL expression\ntype IsNullExpression struct {\n    Pos        Position\n    Expression Expression\n    Negated    bool  // IS NOT NULL\n}\n\nfunc (e *IsNullExpression) isExpression() {}\nfunc (e *IsNullExpression) Pos() Position { return e.Pos }\n\n// LIKE expression: name LIKE '%smith%'\ntype LikeExpression struct {\n    Pos        Position\n    Expression Expression\n    Pattern    Expression\n    Negated    bool  // NOT LIKE\n}\n\nfunc (e *LikeExpression) isExpression() {}\nfunc (e *LikeExpression) Pos() Position { return e.Pos }\n\n// Parenthesized expression: (a OR b) AND c\ntype ParenExpression struct {\n    Pos        Position\n    Expression Expression\n}\n\nfunc (e *ParenExpression) isExpression() {}\nfunc (e *ParenExpression) Pos() Position { return e.Pos }\n\n// CASE expression\ntype CaseExpression struct {\n    Pos        Position\n    Operand    Expression  // Optional: CASE x WHEN ...\n    WhenClauses []WhenClause\n    Else       Expression\n}\n\ntype WhenClause struct {\n    Condition Expression\n    Result    Expression\n}\n\nfunc (e *CaseExpression) isExpression() {}\nfunc (e *CaseExpression) Pos() Position { return e.Pos }\n```\n\n### Parser State\n\n```go\n// parser.go\n\ntype Parser struct {\n    tokens   []Token    // Full token stream\n    pos      int        // Current position in token array\n    current  Token      // Lookahead token (tokens[pos])\n    previous Token      // Last consumed token (for error context)\n    errors   []ParseError\n}\n\ntype ParseError struct {\n    Message  string\n    Line     int\n    Column   int\n    Token    string  // The unexpected token's text\n    Expected string  // What was expected (optional)\n}\n\nfunc (e ParseError) Error() string {\n    if e.Expected != \"\" {\n        return fmt.Sprintf(\"parse error at line %d, column %d: expected %s, got %q\", \n            e.Line, e.Column, e.Expected, e.Token)\n    }\n    return fmt.Sprintf(\"parse error at line %d, column %d: %s\", \n        e.Line, e.Column, e.Message)\n}\n```\n\n### Precedence Table\n\n```go\n// precedence.go\n\ntype OperatorInfo struct {\n    Precedence int\n    IsRightAssoc bool  // For exponentiation, etc.\n}\n\n// SQL operator precedence (higher number = tighter binding)\n// Based on SQL standard with SQLite extensions\nvar precedenceTable = map[string]OperatorInfo{\n    // Logical OR (lowest precedence)\n    \"OR\": {Precedence: 1},\n    \n    // Logical AND\n    \"AND\": {Precedence: 2},\n    \n    // Logical NOT\n    \"NOT\": {Precedence: 3},\n    \n    // Comparison operators\n    \"=\":  {Precedence: 4},\n    \"<\":  {Precedence: 4},\n    \">\":  {Precedence: 4},\n    \"<=\": {Precedence: 4},\n    \">=\": {Precedence: 4},\n    \"!=\": {Precedence: 4},\n    \"<>\": {Precedence: 4},\n    \"IN\": {Precedence: 4},\n    \"BETWEEN\": {Precedence: 4},\n    \"LIKE\": {Precedence: 4},\n    \"IS\": {Precedence: 4},\n    \n    // Addition, subtraction, concatenation\n    \"+\":  {Precedence: 5},\n    \"-\":  {Precedence: 5},\n    \"||\": {Precedence: 5},\n    \n    // Multiplication, division, modulo\n    \"*\": {Precedence: 6},\n    \"/\": {Precedence: 6},\n    \"%\": {Precedence: 6},\n    \n    // Unary minus, unary plus\n    // (handled specially in prefix parsing)\n}\n\nconst (\n    LowestPrecedence  = 1\n    HighestPrecedence = 6\n)\n```\n\n---\n\n## Interface Contracts\n\n### Constructor\n\n```go\n// NewParser creates a parser for the given token stream.\n// The token stream should include an EOF token at the end.\n// Panics if tokens is empty.\nfunc NewParser(tokens []Token) *Parser\n```\n\n### Primary Method: Parse\n\n```go\n// Parse parses the token stream and returns an AST root (Statement).\n// \n// Returns:\n//   - (Statement, nil) on successful parse\n//   - (nil, ParseError) on failure\n//\n// The parser consumes tokens until:\n//   - A complete statement is parsed (semicolon or EOF)\n//   - An error is encountered\n//\n// On error, the parser's internal state is undefined; do not continue parsing.\nfunc (p *Parser) Parse() (Statement, error)\n```\n\n### Token Navigation\n\n```go\n// advance moves to the next token and returns the previous one.\n// At EOF, subsequent calls return the EOF token.\nfunc (p *Parser) advance() Token\n\n// expect consumes the current token if it matches the expected type and value.\n// For keyword matching, value comparison is case-insensitive.\n// Returns error if current token doesn't match.\nfunc (p *Parser) expect(tokenType TokenType, value string) error\n\n// expectType consumes the current token if it matches the expected type.\n// Returns error if current token's type doesn't match.\nfunc (p *Parser) expectType(tokenType TokenType) error\n\n// match checks if the current token matches without consuming it.\nfunc (p *Parser) match(tokenType TokenType, value string) bool\n\n// matchKeyword checks if current token is a keyword with the given value (case-insensitive).\nfunc (p *Parser) matchKeyword(value string) bool\n\n// peek returns the token at offset positions ahead without consuming.\n// peek(0) returns current token, peek(1) returns next token.\nfunc (p *Parser) peek(offset int) Token\n```\n\n### Error Reporting\n\n```go\n// error creates a ParseError at the current token's position.\nfunc (p *Parser) error(format string, args ...interface{}) ParseError\n\n// errorExpected creates a ParseError with \"expected X, got Y\" format.\nfunc (p *Parser) errorExpected(expected string) ParseError\n```\n\n---\n\n## Algorithm Specification\n\n### Main Parse Dispatch\n\n```\nALGORITHM: Parse\nINPUT: Parser p with token stream positioned at statement start\nOUTPUT: Statement AST or error\n\n1. IF current token is EOF:\n     RETURN error(\"unexpected end of input\")\n\n2. SWITCH on current token:\n   CASE KEYWORD \"SELECT\":\n     RETURN parseSelect()\n   \n   CASE KEYWORD \"INSERT\":\n     RETURN parseInsert()\n   \n   CASE KEYWORD \"UPDATE\":\n     RETURN parseUpdate()\n   \n   CASE KEYWORD \"DELETE\":\n     RETURN parseDelete()\n   \n   CASE KEYWORD \"CREATE\":\n     RETURN parseCreate()\n   \n   CASE KEYWORD \"DROP\":\n     RETURN parseDrop()\n   \n   CASE KEYWORD \"BEGIN\":\n     RETURN parseBegin()\n   \n   CASE KEYWORD \"COMMIT\":\n     RETURN parseCommit()\n   \n   CASE KEYWORD \"ROLLBACK\":\n     RETURN parseRollback()\n   \n   CASE KEYWORD \"PRAGMA\":\n     RETURN parsePragma()\n   \n   CASE KEYWORD \"EXPLAIN\":\n     RETURN parseExplain()\n   \n   DEFAULT:\n     RETURN error(\"unexpected token: %s\", current.Value)\n\nPOST-CONDITION: Either a complete Statement is returned, or an error\n```\n\n### SELECT Statement Parsing\n\n\n![AST Node Hierarchy](./diagrams/tdd-diag-5.svg)\n\n\n```\nALGORITHM: parseSelect\nPRE-CONDITION: Current token is KEYWORD \"SELECT\"\nPOST-CONDITION: Returns SelectStatement or error\n\n1. stmt := SelectStatement{Pos: current.Position}\n   advance()  // consume SELECT\n\n2. // Parse column list\n   stmt.Columns = parseColumnList()\n   IF error: RETURN error\n\n3. // Parse FROM clause (required for this implementation)\n   IF matchKeyword(\"FROM\"):\n     advance()  // consume FROM\n     IF current is not IDENTIFIER:\n       RETURN errorExpected(\"table name\")\n     stmt.FromTable = current.Value\n     advance()\n     \n     // Optional table alias\n     IF matchKeyword(\"AS\"):\n       advance()\n       IF current is not IDENTIFIER:\n         RETURN errorExpected(\"alias name\")\n       stmt.Alias = current.Value\n       advance()\n     ELSE IF current.Type == IDENTIFIER:\n       // Alias without AS\n       stmt.Alias = current.Value\n       advance()\n\n4. // Parse optional clauses in order\n   // WHERE clause\n   IF matchKeyword(\"WHERE\"):\n     advance()\n     stmt.Where = parseExpression()\n     IF error: RETURN error\n\n5. // GROUP BY clause\n   IF matchKeyword(\"GROUP\"):\n     advance()\n     IF NOT matchKeyword(\"BY\"):\n       RETURN errorExpected(\"BY\")\n     advance()\n     stmt.GroupBy = parseExpressionList()\n     IF error: RETURN error\n\n6. // HAVING clause\n   IF matchKeyword(\"HAVING\"):\n     advance()\n     stmt.Having = parseExpression()\n     IF error: RETURN error\n\n7. // ORDER BY clause\n   IF matchKeyword(\"ORDER\"):\n     advance()\n     IF NOT matchKeyword(\"BY\"):\n       RETURN errorExpected(\"BY\")\n     advance()\n     stmt.OrderBy = parseOrderByList()\n     IF error: RETURN error\n\n8. // LIMIT clause\n   IF matchKeyword(\"LIMIT\"):\n     advance()\n     IF current.Type != NUMBER:\n       RETURN errorExpected(\"number\")\n     limit := parseInt(current.Value)\n     stmt.Limit = &limit\n     advance()\n     \n     // Optional OFFSET\n     IF matchKeyword(\"OFFSET\"):\n       advance()\n       IF current.Type != NUMBER:\n         RETURN errorExpected(\"number\")\n       offset := parseInt(current.Value)\n       stmt.Offset = &offset\n       advance()\n\n9. // Optional trailing semicolon\n   IF current.Type == PUNCTUATION && current.Value == \";\":\n     advance()\n\n10. RETURN stmt\n```\n\n### Column List Parsing\n\n```\nALGORITHM: parseColumnList\nPRE-CONDITION: Positioned after SELECT keyword\nPOST-CONDITION: Returns slice of ColumnSelection\n\n1. columns := empty list\n\n2. // Handle SELECT *\n   IF current.Type == OPERATOR && current.Value == \"*\":\n     advance()\n     columns.append(ColumnSelection{\n       Expression: StarExpression{}\n     })\n     RETURN columns\n\n3. // Parse column expressions\n   LOOP:\n     a. col := parseSelectColumn()\n        IF error: RETURN error\n        columns.append(col)\n     \n     b. IF current is comma:\n          advance()\n          CONTINUE LOOP\n        ELSE:\n          BREAK LOOP\n\n4. RETURN columns\n\nALGORITHM: parseSelectColumn\nPRE-CONDITION: Positioned at start of column expression\nPOST-CONDITION: Returns ColumnSelection\n\n1. // Handle table.* syntax\n   IF current is IDENTIFIER AND peek(1) is \".\" AND peek(2) is \"*\":\n     tableName := current.Value\n     advance() // consume identifier\n     advance() // consume \".\"\n     advance() // consume \"*\"\n     RETURN ColumnSelection{\n       Expression: StarExpression{TableName: tableName}\n     }\n\n2. // Parse expression\n   expr := parseExpression()\n   IF error: RETURN error\n\n3. // Optional alias\n   alias := \"\"\n   IF matchKeyword(\"AS\"):\n     advance()\n     IF current is not IDENTIFIER:\n       RETURN errorExpected(\"alias\")\n     alias = current.Value\n     advance()\n   ELSE IF current.Type == IDENTIFIER AND not a keyword:\n     // Alias without AS keyword\n     alias = current.Value\n     advance()\n\n4. RETURN ColumnSelection{Expression: expr, Alias: alias}\n```\n\n### INSERT Statement Parsing\n\n```\nALGORITHM: parseInsert\nPRE-CONDITION: Current token is KEYWORD \"INSERT\"\nPOST-CONDITION: Returns InsertStatement or error\n\n1. stmt := InsertStatement{Pos: current.Position}\n   advance()  // consume INSERT\n\n2. // Expect INTO keyword\n   IF NOT matchKeyword(\"INTO\"):\n     RETURN errorExpected(\"INTO\")\n   advance()\n\n3. // Parse table name\n   IF current.Type != IDENTIFIER AND current.Type != QUOTED_ID:\n     RETURN errorExpected(\"table name\")\n   stmt.Table = current.Value\n   advance()\n\n4. // Optional column list\n   IF current.Type == PUNCTUATION && current.Value == \"(\":\n     advance()\n     stmt.Columns = parseIdentifierList()\n     IF error: RETURN error\n     IF current.Type != PUNCTUATION || current.Value != \")\":\n       RETURN errorExpected(\")\")\n     advance()\n\n5. // Parse VALUES clause\n   IF NOT matchKeyword(\"VALUES\"):\n     RETURN errorExpected(\"VALUES\")\n   advance()\n\n6. // Parse one or more value tuples\n   stmt.Values = empty list\n   LOOP:\n     a. IF current.Type != PUNCTUATION || current.Value != \"(\":\n          RETURN errorExpected(\"(\")\n        advance()\n     \n     b. values := parseExpressionList()\n        IF error: RETURN error\n        stmt.Values.append(values)\n     \n     c. IF current.Type != PUNCTUATION || current.Value != \")\":\n          RETURN errorExpected(\")\")\n        advance()\n     \n     d. IF current is comma:\n          advance()\n          CONTINUE LOOP\n        ELSE:\n          BREAK LOOP\n\n7. // Optional semicolon\n   IF current.Type == PUNCTUATION && current.Value == \";\":\n     advance()\n\n8. RETURN stmt\n```\n\n### CREATE TABLE Parsing\n\n```\nALGORITHM: parseCreate\nPRE-CONDITION: Current token is KEYWORD \"CREATE\"\nPOST-CONDITION: Returns CreateTableStatement or error\n\n1. stmt := CreateTableStatement{Pos: current.Position}\n   advance()  // consume CREATE\n\n2. // Expect TABLE keyword\n   IF NOT matchKeyword(\"TABLE\"):\n     // Could be CREATE INDEX - delegate to parseCreateIndex\n     RETURN parseCreateIndex()\n   advance()\n\n3. // Optional IF NOT EXISTS\n   IF matchKeyword(\"IF\"):\n     advance()\n     IF NOT matchKeyword(\"NOT\"):\n       RETURN errorExpected(\"NOT\")\n     advance()\n     IF NOT matchKeyword(\"EXISTS\"):\n       RETURN errorExpected(\"EXISTS\")\n     advance()\n     stmt.IfNotExists = true\n\n4. // Parse table name\n   IF current.Type != IDENTIFIER AND current.Type != QUOTED_ID:\n     RETURN errorExpected(\"table name\")\n   stmt.Table = current.Value\n   advance()\n\n5. // Expect opening parenthesis\n   IF current.Type != PUNCTUATION || current.Value != \"(\":\n     RETURN errorExpected(\"(\")\n   advance()\n\n6. // Parse column definitions and table constraints\n   stmt.Columns = empty list\n   stmt.Constraints = empty list\n   \n   LOOP:\n     a. // Check for table-level constraint\n        IF matchKeyword(\"PRIMARY\") OR matchKeyword(\"UNIQUE\") OR matchKeyword(\"FOREIGN\") OR matchKeyword(\"CHECK\"):\n          constraint := parseTableConstraint()\n          IF error: RETURN error\n          stmt.Constraints.append(constraint)\n     \n     b. ELSE:\n          // Column definition\n          col := parseColumnDefinition()\n          IF error: RETURN error\n          stmt.Columns.append(col)\n     \n     c. IF current is comma:\n          advance()\n          CONTINUE LOOP\n        ELSE:\n          BREAK LOOP\n\n7. // Expect closing parenthesis\n   IF current.Type != PUNCTUATION || current.Value != \")\":\n     RETURN errorExpected(\")\")\n   advance()\n\n8. // Optional semicolon\n   IF current.Type == PUNCTUATION && current.Value == \";\":\n     advance()\n\n9. RETURN stmt\n\nALGORITHM: parseColumnDefinition\nPRE-CONDITION: Positioned at column name identifier\nPOST-CONDITION: Returns ColumnDefinition\n\n1. col := ColumnDefinition{}\n\n2. // Column name\n   IF current.Type != IDENTIFIER AND current.Type != QUOTED_ID:\n     RETURN errorExpected(\"column name\")\n   col.Name = current.Value\n   advance()\n\n3. // Data type\n   IF current.Type != KEYWORD:\n     RETURN errorExpected(\"data type\")\n   col.Type = current.Value  // INTEGER, TEXT, REAL, BLOB\n   advance()\n\n4. // Column constraints\n   col.Constraints = empty list\n   LOOP:\n     IF matchKeyword(\"PRIMARY\"):\n       advance()\n       IF NOT matchKeyword(\"KEY\"):\n         RETURN errorExpected(\"KEY\")\n       advance()\n       \n       // Optional AUTOINCREMENT\n       autoInc := false\n       IF matchKeyword(\"AUTOINCREMENT\"):\n         advance()\n         autoInc = true\n       \n       col.Constraints.append(PrimaryKeyConstraint{AutoIncrement: autoInc})\n     \n     ELSE IF matchKeyword(\"NOT\"):\n       advance()\n       IF NOT matchKeyword(\"NULL\"):\n         RETURN errorExpected(\"NULL\")\n       advance()\n       col.Constraints.append(NotNullConstraint{})\n     \n     ELSE IF matchKeyword(\"UNIQUE\"):\n       advance()\n       col.Constraints.append(UniqueConstraint{})\n     \n     ELSE IF matchKeyword(\"DEFAULT\"):\n       advance()\n       defaultValue := parseExpression()\n       IF error: RETURN error\n       col.Constraints.append(DefaultConstraint{Value: defaultValue})\n     \n     ELSE IF matchKeyword(\"CHECK\"):\n       advance()\n       IF current.Type != PUNCTUATION || current.Value != \"(\":\n         RETURN errorExpected(\"(\")\n       advance()\n       checkExpr := parseExpression()\n       IF error: RETURN error\n       IF current.Type != PUNCTUATION || current.Value != \")\":\n         RETURN errorExpected(\")\")\n       advance()\n       col.Constraints.append(CheckConstraint{Expression: checkExpr})\n     \n     ELSE IF matchKeyword(\"REFERENCES\"):\n       advance()\n       refTable, refCol := parseReferences()\n       IF error: RETURN error\n       col.Constraints.append(ForeignKeyConstraint{\n         ReferencesTable: refTable,\n         ReferencesColumn: refCol,\n       })\n     \n     ELSE:\n       BREAK LOOP\n\n5. RETURN col\n```\n\n### Expression Parsing with Precedence Climbing\n\n\n![Expression Precedence Parsing Algorithm](./diagrams/tdd-diag-6.svg)\n\n\n```\nALGORITHM: parseExpression\nINPUT: Parser p positioned at start of expression\nOUTPUT: Expression AST or error\n\n1. RETURN parseBinaryExpression(LowestPrecedence)\n\nALGORITHM: parseBinaryExpression\nINPUT: minPrec - minimum precedence for this level\nOUTPUT: Expression AST\n\n1. // Parse left operand (prefix expression)\n   left := parseUnaryExpression()\n   IF error: RETURN error\n\n2. // Loop while current token is a binary operator with sufficient precedence\n   LOOP:\n     a. IF current is NOT a binary operator:\n          BREAK LOOP\n     \n     b. op := current.Value\n        opInfo := precedenceTable[op]\n        IF opInfo.Precedence < minPrec:\n          BREAK LOOP\n     \n     c. advance()  // consume operator\n     \n     d. // Parse right operand with higher precedence (for left-associativity)\n        // For right-associative operators, use >= instead of >\n        nextMinPrec := opInfo.Precedence + 1\n        right := parseBinaryExpression(nextMinPrec)\n        IF error: RETURN error\n     \n     e. left := BinaryExpression{\n          Operator: op,\n          Left: left,\n          Right: right,\n          Pos: left.Pos()\n        }\n\n3. RETURN left\n\nALGORITHM: parseUnaryExpression\nINPUT: Parser p\nOUTPUT: Expression AST\n\n1. // Handle unary NOT\n   IF matchKeyword(\"NOT\"):\n     pos := current.Position\n     advance()\n     operand := parseUnaryExpression()\n     IF error: RETURN error\n     RETURN UnaryExpression{\n       Operator: \"NOT\",\n       Operand: operand,\n       Pos: pos\n     }\n\n2. // Handle unary minus (negative numbers)\n   IF current.Type == OPERATOR && current.Value == \"-\":\n     pos := current.Position\n     advance()\n     \n     // Check if followed by number - could be literal\n     IF current.Type == NUMBER:\n       value := parseNegativeNumber()\n       RETURN LiteralExpression{Value: value, Pos: pos}\n     \n     operand := parseUnaryExpression()\n     IF error: RETURN error\n     RETURN UnaryExpression{\n       Operator: \"-\",\n       Operand: operand,\n       Pos: pos\n     }\n\n3. // Handle unary plus (no-op, but valid syntax)\n   IF current.Type == OPERATOR && current.Value == \"+\":\n     advance()\n     RETURN parseUnaryExpression()\n\n4. // Handle special expressions (IN, BETWEEN, IS NULL, LIKE)\n   left := parsePrimaryExpression()\n   IF error: RETURN error\n\n5. // Postfix operators\n   // [NOT] IN (...)\n   IF matchKeyword(\"NOT\"):\n     advance()\n     IF NOT matchKeyword(\"IN\"):\n       // Put back NOT - it's a separate NOT operator\n       p.pos--\n       p.current = p.tokens[p.pos]\n       RETURN left\n     // Fall through to IN handling\n     RETURN parseInExpression(left, true)\n   \n   IF matchKeyword(\"IN\"):\n     RETURN parseInExpression(left, false)\n   \n   // [NOT] BETWEEN ... AND ...\n   IF matchKeyword(\"BETWEEN\"):\n     RETURN parseBetweenExpression(left, false)\n   \n   // IS [NOT] NULL\n   IF matchKeyword(\"IS\"):\n     RETURN parseIsNullExpression(left)\n   \n   // [NOT] LIKE\n   IF matchKeyword(\"LIKE\"):\n     RETURN parseLikeExpression(left, false)\n\n6. RETURN left\n\nALGORITHM: parsePrimaryExpression\nINPUT: Parser p\nOUTPUT: Expression AST (atom)\n\n1. SWITCH on current token:\n\n   CASE PUNCTUATION \"(\":\n     advance()\n     expr := parseExpression()\n     IF error: RETURN error\n     IF current.Type != PUNCTUATION || current.Value != \")\":\n       RETURN errorExpected(\")\")\n     advance()\n     RETURN ParenExpression{Expression: expr, Pos: expr.Pos()}\n\n   CASE NUMBER:\n     value, litType := parseNumberLiteral()\n     pos := current.Position\n     advance()\n     RETURN LiteralExpression{Value: value, Type: litType, Pos: pos}\n\n   CASE STRING:\n     pos := current.Position\n     value := current.Value\n     advance()\n     RETURN LiteralExpression{Value: value, Type: LiteralString, Pos: pos}\n\n   CASE KEYWORD \"NULL\":\n     pos := current.Position\n     advance()\n     RETURN LiteralExpression{Value: nil, Type: LiteralNull, Pos: pos}\n\n   CASE KEYWORD \"TRUE\":\n     pos := current.Position\n     advance()\n     RETURN LiteralExpression{Value: int64(1), Type: LiteralInteger, Pos: pos}\n\n   CASE KEYWORD \"FALSE\":\n     pos := current.Position\n     advance()\n     RETURN LiteralExpression{Value: int64(0), Type: LiteralInteger, Pos: pos}\n\n   CASE OPERATOR \"*\":\n     pos := current.Position\n     advance()\n     RETURN StarExpression{Pos: pos}\n\n   CASE IDENTIFIER or QUOTED_ID:\n     pos := current.Position\n     name := current.Value\n     advance()\n     \n     // Check for function call\n     IF current.Type == PUNCTUATION && current.Value == \"(\":\n       RETURN parseFunctionCall(name, pos)\n     \n     // Check for qualified name (table.column)\n     IF current.Type == PUNCTUATION && current.Value == \".\":\n       advance()\n       IF current.Type != IDENTIFIER AND current.Type != QUOTED_ID:\n         RETURN errorExpected(\"column name\")\n       colName := current.Value\n       advance()\n       RETURN IdentifierExpression{\n         TableName: name,\n         Name: colName,\n         Pos: pos\n       }\n     \n     RETURN IdentifierExpression{Name: name, Pos: pos}\n\n   DEFAULT:\n     RETURN errorExpected(\"expression\")\n```\n\n### Special Expression Parsing\n\n```\nALGORITHM: parseInExpression\nINPUT: left Expression, negated bool\nOUTPUT: InExpression\n\n1. advance()  // consume IN\n   IF current.Type != PUNCTUATION || current.Value != \"(\":\n     RETURN errorExpected(\"(\")\n   advance()\n\n2. values := parseExpressionList()\n   IF error: RETURN error\n\n3. IF current.Type != PUNCTUATION || current.Value != \")\":\n     RETURN errorExpected(\")\")\n   advance()\n\n4. RETURN InExpression{\n     Expression: left,\n     Values: values,\n     Negated: negated,\n     Pos: left.Pos()\n   }\n\nALGORITHM: parseBetweenExpression\nINPUT: left Expression, negated bool\nOUTPUT: BetweenExpression\n\n1. advance()  // consume BETWEEN\n   low := parseExpression()\n   IF error: RETURN error\n\n2. IF NOT matchKeyword(\"AND\"):\n     RETURN errorExpected(\"AND\")\n   advance()\n\n3. high := parseExpression()\n   IF error: RETURN error\n\n4. RETURN BetweenExpression{\n     Expression: left,\n     Low: low,\n     High: high,\n     Negated: negated,\n     Pos: left.Pos()\n   }\n\nALGORITHM: parseIsNullExpression\nINPUT: left Expression\nOUTPUT: IsNullExpression\n\n1. advance()  // consume IS\n   \n2. negated := false\n   IF matchKeyword(\"NOT\"):\n     negated = true\n     advance()\n\n3. IF NOT matchKeyword(\"NULL\"):\n     RETURN errorExpected(\"NULL\")\n   advance()\n\n4. RETURN IsNullExpression{\n     Expression: left,\n     Negated: negated,\n     Pos: left.Pos()\n   }\n\nALGORITHM: parseLikeExpression\nINPUT: left Expression, negated bool\nOUTPUT: LikeExpression\n\n1. advance()  // consume LIKE\n   pattern := parseExpression()\n   IF error: RETURN error\n\n2. RETURN LikeExpression{\n     Expression: left,\n     Pattern: pattern,\n     Negated: negated,\n     Pos: left.Pos()\n   }\n\nALGORITHM: parseFunctionCall\nINPUT: functionName string, pos Position\nOUTPUT: FunctionCallExpression\n\n1. advance()  // consume \"(\"\n\n2. distinct := false\n   IF matchKeyword(\"DISTINCT\"):\n     distinct = true\n     advance()\n\n3. // Handle COUNT(*) specially\n   IF current.Type == OPERATOR && current.Value == \"*\":\n     advance()\n     IF current.Type != PUNCTUATION || current.Value != \")\":\n       RETURN errorExpected(\")\")\n     advance()\n     RETURN FunctionCallExpression{\n       Name: functionName,\n       Args: []Expression{StarExpression{}},\n       Distinct: distinct,\n       Pos: pos\n     }\n\n4. // Parse arguments\n   args := empty list\n   IF current.Type != PUNCTUATION || current.Value != \")\":\n     args = parseExpressionList()\n     IF error: RETURN error\n\n5. IF current.Type != PUNCTUATION || current.Value != \")\":\n     RETURN errorExpected(\")\")\n   advance()\n\n6. RETURN FunctionCallExpression{\n     Name: functionName,\n     Args: args,\n     Distinct: distinct,\n     Pos: pos\n   }\n```\n\n---\n\n## Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n|-------|-------------|----------|---------------|\n| Unexpected token | `expect()`, `expectType()` | Return ParseError with position and expected token | Yes: \"expected 'FROM', got 'FORM' at line 1, column 10\" |\n| Missing required clause | Statement parsers | Return ParseError indicating missing clause | Yes: \"expected table name after FROM\" |\n| Invalid expression | `parsePrimaryExpression()` | Return ParseError at invalid token | Yes: \"expected expression, got ')'\" |\n| Unmatched parentheses | Expression parser | Return ParseError at unmatched paren | Yes: \"unmatched ')' at line 2, column 5\" |\n| Missing closing parenthesis | Various list parsers | Return ParseError at end of list | Yes: \"expected ')' after column list\" |\n| Empty column list | `parseColumnList()` | Return ParseError at opening paren | Yes: \"column list cannot be empty\" |\n| Invalid operator in expression | `parseBinaryExpression()` | Treat as end of expression, continue | No: stops expression parsing, may cascade |\n| Unknown keyword in column type | `parseColumnDefinition()` | Accept any keyword, validate later | No: type validation is semantic, not syntactic |\n\n---\n\n## Implementation Sequence with Checkpoints\n\n### Phase 1: Parser Core and Statement Dispatch (1 hour)\n\n**Files to create**: `parser.go`, `errors.go`, `ast.go` (statement stubs)\n\n**Implementation**:\n1. Define `Parser` struct with token navigation\n2. Implement `NewParser`, `advance`, `expect`, `match`, `peek`\n3. Implement `Parse` with dispatch on first keyword\n4. Define `Statement` interface and stub types\n5. Implement `ParseError` with position formatting\n\n**Checkpoint**: At this point you should be able to create a parser and dispatch on keywords. Run:\n```bash\ngo test -run TestParserDispatch\n# Expected: PASS (dispatches to correct parsers, errors on unknown)\n```\n\n### Phase 2: SELECT Statement Parsing (1.5 hours)\n\n**Files to create**: `select.go`\n\n**Implementation**:\n1. Implement `parseSelect` skeleton\n2. Implement `parseColumnList` with `*` support\n3. Implement FROM clause parsing\n4. Implement WHERE clause parsing (using expression parser stub)\n5. Implement ORDER BY and LIMIT\n\n**Checkpoint**: At this point you should be able to parse `SELECT * FROM users`. Run:\n```bash\ngo test -run TestSelectBasic\n# Expected: PASS (SELECT * FROM users parses to correct AST)\n```\n\n### Phase 3: INSERT Statement Parsing (1 hour)\n\n**Files to create**: `insert.go`\n\n**Implementation**:\n1. Implement `parseInsert`\n2. Implement column list parsing\n3. Implement VALUES clause with multiple tuples\n4. Handle quoted identifiers for table names\n\n**Checkpoint**: At this point you should be able to parse `INSERT INTO users VALUES (1, 'Alice')`. Run:\n```bash\ngo test -run TestInsert\n# Expected: PASS (INSERT with and without column list)\n```\n\n### Phase 4: CREATE TABLE Parsing (1.5 hours)\n\n**Files to create**: `create.go`\n\n**Implementation**:\n1. Implement `parseCreate` with IF NOT EXISTS\n2. Implement `parseColumnDefinition`\n3. Implement constraint parsing (PRIMARY KEY, NOT NULL, UNIQUE, DEFAULT)\n4. Implement table-level constraints\n5. Handle quoted identifiers for table/column names\n\n**Checkpoint**: At this point you should be able to parse `CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT NOT NULL)`. Run:\n```bash\ngo test -run TestCreateTable\n# Expected: PASS (CREATE TABLE with constraints)\n```\n\n### Phase 5: Expression Parsing with Precedence Climbing (2 hours)\n\n**Files to create**: `expression.go`, `precedence.go`\n\n**Implementation**:\n1. Define precedence table\n2. Implement `parseExpression` entry point\n3. Implement `parseBinaryExpression` with precedence climbing\n4. Implement `parseUnaryExpression` (NOT, unary minus)\n5. Implement `parsePrimaryExpression` (atoms)\n6. Implement special expressions (IN, BETWEEN, IS NULL, LIKE)\n7. Implement function call parsing\n\n**Checkpoint**: At this point you should pass the full test suite. Run:\n```bash\ngo test -v ./parser\n# Expected: All tests PASS, including 15+ valid and 10+ invalid statements\n```\n\n---\n\n## Test Specification\n\n### Test Categories\n\n```go\n// parser_test.go\n\nfunc TestSelectBasic(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected *SelectStatement\n    }{\n        {\n            input: \"SELECT * FROM users\",\n            expected: &SelectStatement{\n                Columns:   []ColumnSelection{{Expression: StarExpression{}}},\n                FromTable: \"users\",\n            },\n        },\n        {\n            input: \"SELECT id, name FROM users\",\n            expected: &SelectStatement{\n                Columns: []ColumnSelection{\n                    {Expression: IdentifierExpression{Name: \"id\"}},\n                    {Expression: IdentifierExpression{Name: \"name\"}},\n                },\n                FromTable: \"users\",\n            },\n        },\n    }\n    // ... test execution\n}\n\nfunc TestSelectWithWhere(t *testing.T) {\n    tests := []struct {\n        input       string\n        expectWhere string  // Stringified WHERE clause\n    }{\n        {input: \"SELECT * FROM users WHERE id = 1\", expectWhere: \"id = 1\"},\n        {input: \"SELECT * FROM users WHERE age > 18\", expectWhere: \"age > 18\"},\n        {input: \"SELECT * FROM users WHERE active = 1 AND role = 'admin'\", \n         expectWhere: \"active = 1 AND role = 'admin'\"},\n    }\n}\n\nfunc TestSelectWithOrderByLimit(t *testing.T) {\n    input := \"SELECT * FROM users ORDER BY name DESC LIMIT 10 OFFSET 5\"\n    stmt, err := parse(input)\n    assert.NoError(t, err)\n    \n    selectStmt := stmt.(*SelectStatement)\n    assert.Len(t, selectStmt.OrderBy, 1)\n    assert.True(t, selectStmt.OrderBy[0].Descending)\n    assert.Equal(t, 10, *selectStmt.Limit)\n    assert.Equal(t, 5, *selectStmt.Offset)\n}\n\nfunc TestInsert(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected *InsertStatement\n    }{\n        {\n            input: \"INSERT INTO users VALUES (1, 'Alice')\",\n            expected: &InsertStatement{\n                Table: \"users\",\n                Values: [][]Expression{\n                    {Literal(1), Literal(\"Alice\")},\n                },\n            },\n        },\n        {\n            input: \"INSERT INTO users (id, name) VALUES (1, 'Alice')\",\n            expected: &InsertStatement{\n                Table:   \"users\",\n                Columns: []string{\"id\", \"name\"},\n                Values: [][]Expression{\n                    {Literal(1), Literal(\"Alice\")},\n                },\n            },\n        },\n        {\n            input: \"INSERT INTO logs VALUES (1, 'a'), (2, 'b')\",\n            expected: &InsertStatement{\n                Table: \"logs\",\n                Values: [][]Expression{\n                    {Literal(1), Literal(\"a\")},\n                    {Literal(2), Literal(\"b\")},\n                },\n            },\n        },\n    }\n}\n\nfunc TestCreateTable(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected *CreateTableStatement\n    }{\n        {\n            input: \"CREATE TABLE users (id INTEGER, name TEXT)\",\n            expected: &CreateTableStatement{\n                Table: \"users\",\n                Columns: []ColumnDefinition{\n                    {Name: \"id\", Type: \"INTEGER\"},\n                    {Name: \"name\", Type: \"TEXT\"},\n                },\n            },\n        },\n        {\n            input: \"CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY)\",\n            expected: &CreateTableStatement{\n                Table:       \"users\",\n                IfNotExists: true,\n                Columns: []ColumnDefinition{\n                    {Name: \"id\", Type: \"INTEGER\", \n                     Constraints: []ColumnConstraint{PrimaryKeyConstraint{}}},\n                },\n            },\n        },\n        {\n            input: \"CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL)\",\n            expected: &CreateTableStatement{\n                Table: \"users\",\n                Columns: []ColumnDefinition{\n                    {Name: \"id\", Type: \"INTEGER\",\n                     Constraints: []ColumnConstraint{PrimaryKeyConstraint{AutoIncrement: true}}},\n                    {Name: \"name\", Type: \"TEXT\",\n                     Constraints: []ColumnConstraint{NotNullConstraint{}}},\n                },\n            },\n        },\n    }\n}\n\nfunc TestExpressionPrecedence(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected string  // Stringified AST showing tree structure\n    }{\n        // AND binds tighter than OR\n        {input: \"a OR b AND c\", expected: \"OR(a, AND(b, c))\"},\n        \n        // NOT binds tighter than comparison\n        {input: \"NOT a = b\", expected: \"NOT(=(a, b))\"},\n        \n        // Comparison binds tighter than AND\n        {input: \"a = b AND c = d\", expected: \"AND(=(a, b), =(c, d))\"},\n        \n        // Parentheses override precedence\n        {input: \"(a OR b) AND c\", expected: \"AND(OR(a, b), c)\"},\n        \n        // Nested parentheses\n        {input: \"((a))\", expected: \"a\"},\n        \n        // Complex expression\n        {input: \"a = 1 OR b = 2 AND c > 3\", expected: \"OR(=(a, 1), AND(=(b, 2), >(c, 3)))\"},\n    }\n}\n\nfunc TestSpecialExpressions(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected Expression\n    }{\n        // IN\n        {input: \"id IN (1, 2, 3)\", \n         expected: InExpression{Expression: Id(\"id\"), Values: []Expression{Lit(1), Lit(2), Lit(3)}}},\n        \n        // NOT IN\n        {input: \"id NOT IN (1, 2, 3)\",\n         expected: InExpression{Expression: Id(\"id\"), Values: []Expression{Lit(1), Lit(2), Lit(3)}, Negated: true}},\n        \n        // BETWEEN\n        {input: \"age BETWEEN 18 AND 65\",\n         expected: BetweenExpression{Expression: Id(\"age\"), Low: Lit(18), High: Lit(65)}},\n        \n        // IS NULL\n        {input: \"name IS NULL\",\n         expected: IsNullExpression{Expression: Id(\"name\")}},\n        \n        // IS NOT NULL\n        {input: \"name IS NOT NULL\",\n         expected: IsNullExpression{Expression: Id(\"name\"), Negated: true}},\n        \n        // LIKE\n        {input: \"email LIKE '%@example.com'\",\n         expected: LikeExpression{Expression: Id(\"email\"), Pattern: Lit(\"%@example.com\")}},\n    }\n}\n\nfunc TestFunctionCalls(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected Expression\n    }{\n        {input: \"COUNT(*)\", expected: FunctionCallExpression{Name: \"COUNT\", Args: []Expression{StarExpression{}}}},\n        {input: \"SUM(amount)\", expected: FunctionCallExpression{Name: \"SUM\", Args: []Expression{Id(\"amount\")}}},\n        {input: \"COUNT(DISTINCT user_id)\", \n         expected: FunctionCallExpression{Name: \"COUNT\", Args: []Expression{Id(\"user_id\")}, Distinct: true}},\n    }\n}\n\nfunc TestErrorCases(t *testing.T) {\n    tests := []struct {\n        input       string\n        expectError bool\n        errorContains string\n    }{\n        {input: \"SELECT\", expectError: true, errorContains: \"expected expression\"},\n        {input: \"SELECT * FROM\", expectError: true, errorContains: \"expected table name\"},\n        {input: \"SELECT * FORM users\", expectError: true, errorContains: \"expected 'FROM'\"},  // FORM vs FROM\n        {input: \"INSERT INTO users (\", expectError: true, errorContains: \"expected identifier\"},\n        {input: \"INSERT INTO users (id\", expectError: true, errorContains: \"expected ')'\"},\n        {input: \"CREATE TABLE users (id\", expectError: true, errorContains: \"expected ')'\"},\n        {input: \"SELECT * FROM users WHERE (\", expectError: true, errorContains: \"expected expression\"},\n        {input: \"SELECT * FROM users WHERE (id = 1\", expectError: true, errorContains: \"expected ')'\"},\n    }\n}\n\nfunc TestQuotedIdentifiers(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected string\n    }{\n        {input: `SELECT * FROM \"Order Details\"`, expected: \"Order Details\"},\n        {input: `CREATE TABLE \"Users Table\" (id INTEGER)`, expected: \"Users Table\"},\n        {input: `SELECT \"Column Name\" FROM users`, expected: \"Column Name\"},\n    }\n}\n\nfunc TestComplexStatements(t *testing.T) {\n    // 15+ valid statements\n    validStatements := []string{\n        \"SELECT * FROM users\",\n        \"SELECT id, name FROM users WHERE age > 18\",\n        \"SELECT * FROM users WHERE active = 1 AND role = 'admin'\",\n        \"SELECT * FROM users WHERE (a = 1 OR b = 2) AND c = 3\",\n        \"SELECT * FROM users ORDER BY name\",\n        \"SELECT * FROM users ORDER BY name DESC LIMIT 10\",\n        \"SELECT * FROM users LIMIT 10 OFFSET 5\",\n        \"SELECT * FROM users WHERE active = 1 ORDER BY created_at DESC LIMIT 5\",\n        \"INSERT INTO users VALUES (1, 'Alice')\",\n        \"INSERT INTO users (id, name) VALUES (1, 'Alice')\",\n        \"INSERT INTO logs (message, level) VALUES ('Error', 'high'), ('Warning', 'medium')\",\n        \"CREATE TABLE users (id INTEGER, name TEXT)\",\n        \"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT NOT NULL)\",\n        \"CREATE TABLE users (id INTEGER, email TEXT UNIQUE)\",\n        `CREATE TABLE \"Order Items\" (id INTEGER, qty INTEGER NOT NULL)`,\n        \"SELECT COUNT(*) FROM users\",\n        \"SELECT status, COUNT(*) FROM orders GROUP BY status\",\n        \"SELECT * FROM users WHERE id IN (1, 2, 3)\",\n        \"SELECT * FROM users WHERE created_at BETWEEN '2024-01-01' AND '2024-12-31'\",\n        \"SELECT * FROM users WHERE name IS NULL\",\n    }\n    \n    // 10+ invalid statements\n    invalidStatements := []string{\n        \"SELECT\",\n        \"SELECT * FROM\",\n        \"SELECT * FORM users\",  // Misspelled FROM\n        \"INSERT INTO users (\",\n        \"INSERT INTO users VALUES (1, 'Alice'\",  // Missing closing paren\n        \"CREATE TABLE users (\",\n        \"CREATE TABLE users (id INTEGER\",  // Missing closing paren\n        \"SELECT * FROM users WHERE (\",\n        \"SELECT * FROM users WHERE ()\",  // Empty parens\n        \"SELECT * FROM WHERE id = 1\",  // Missing table name\n    }\n    \n    for _, stmt := range validStatements {\n        _, err := parse(stmt)\n        assert.NoError(t, err, \"Expected valid: %s\", stmt)\n    }\n    \n    for _, stmt := range invalidStatements {\n        _, err := parse(stmt)\n        assert.Error(t, err, \"Expected invalid: %s\", stmt)\n    }\n}\n\nfunc TestPositionTracking(t *testing.T) {\n    input := \"SELECT *\\nFROM users\\nWHERE id = 1\"\n    stmt, err := parse(input)\n    assert.NoError(t, err)\n    \n    selectStmt := stmt.(*SelectStatement)\n    assert.Equal(t, 1, selectStmt.Pos.Line)\n    assert.Equal(t, 1, selectStmt.Pos.Column)\n    \n    // WHERE clause should be on line 3\n    where := selectStmt.Where.(*BinaryExpression)\n    assert.Equal(t, 3, where.Pos.Line)\n}\n```\n\n---\n\n## Performance Targets\n\n| Operation | Target | How to Measure |\n|-----------|--------|----------------|\n| Parse 15 valid statements | < 10ms total | `go test -bench=BenchmarkParseValid` |\n| Parse 10 invalid statements | < 5ms total | `go test -bench=BenchmarkParseInvalid` |\n| Single statement parse | O(n) in token count | Code review: verify no backtracking |\n| Memory per 1000-token AST | < 500KB | `go test -memprofile` |\n| Error reporting | 100% with position | All errors include line/column |\n\n---\n\n## Synced Criteria\n\n}]\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-sqlite-m3 -->\n# Technical Design Specification: Bytecode Compiler (VDBE)\n\n## Module Charter\n\nThe Bytecode Compiler transforms parsed SQL ASTs into executable bytecode programs for the Virtual Database Engine (VDBE). It implements a register-based instruction set with opcodes for table operations (OpenTable, Close, Rewind, Column, Next), data manipulation (Insert, Delete, MakeRecord), control flow (Goto, Halt, conditional jumps), and expression evaluation (Integer, String8, Null, comparisons). The compiler performs register allocation, manages jump target patching for loops and conditionals, and produces linear instruction sequences optimized for VDBE execution. It does NOT execute queries, manage storage, or perform query optimization—it produces bytecode that the VM interprets. Upstream dependencies: Parser (consumes AST). Downstream dependencies: VDBE Virtual Machine (executes bytecode). Invariants: every emitted instruction has valid opcode and register references; all forward jump targets are patched before program returns; register allocation never overlaps active values; the final instruction is always Halt.\n\n---\n\n## File Structure\n\n```\ncompiler/\n├── instruction.go      # (1) Instruction struct and opcode definitions\n├── compiler.go         # (2) Compiler struct and entry point\n├── select.go           # (3) SELECT statement compilation\n├── insert.go           # (4) INSERT statement compilation\n├── update.go           # (5) UPDATE statement compilation\n├── delete.go           # (6) DELETE statement compilation\n├── create.go           # (7) CREATE TABLE/INDEX compilation\n├── expression.go       # (8) Expression to bytecode compilation\n├── register.go         # (9) Register allocator\n├── jumps.go            # (10) Jump target patching utilities\n├── explain.go          # (11) EXPLAIN output formatter\n├── compiler_test.go    # (12) Test suite\n└── vm/\n    ├── vm.go           # (13) Virtual machine execution loop\n    ├── value.go        # (14) Value types and operations\n    ├── cursor.go       # (15) Cursor abstraction\n    └── opcodes.go      # (16) Opcode handler implementations\n```\n\n---\n\n## Complete Data Model\n\n### Instruction Structure\n\n```go\n// instruction.go\n\ntype Opcode int\n\nconst (\n    // Table operations\n    OpOpenTable Opcode = iota\n    OpOpenIndex\n    OpClose\n    \n    // Cursor movement\n    OpRewind\n    OpNext\n    OpPrev\n    OpSeekRowid\n    OpSeekGe\n    OpSeekGt\n    OpSeekLe\n    OpSeekLt\n    \n    // Column access\n    OpColumn\n    OpRowid\n    \n    // Output\n    OpResultRow\n    \n    // Record operations\n    OpMakeRecord\n    OpInsert\n    OpDelete\n    \n    // Data loading\n    OpInteger\n    OpInt64\n    OpReal\n    OpString8\n    OpNull\n    OpBlob\n    \n    // Comparison\n    OpEq\n    OpNe\n    OpLt\n    OpLe\n    OpGt\n    OpGe\n    \n    // Control flow\n    OpGoto\n    OpGosub\n    OpReturn\n    OpHalt\n    OpIf\n    OpIfNot\n    OpIfNull\n    OpNot\n    \n    // Arithmetic\n    OpAdd\n    OpSubtract\n    OpMultiply\n    OpDivide\n    OpRemainder\n    OpConcat\n    \n    // Aggregates\n    OpAggStep\n    OpAggFinal\n    OpAggContextPush\n    OpAggContextPop\n    \n    // Sorter (ORDER BY)\n    OpSorterOpen\n    OpSorterInsert\n    OpSorterSort\n    OpSorterData\n    OpSorterNext\n    \n    // Transaction\n    OpTransaction\n    OpAutoCommit\n    \n    // Schema\n    OpTableLock\n    \n    // Utility\n    OpNoop\n    OpExplain\n)\n\nfunc (op Opcode) String() string {\n    switch op {\n    case OpOpenTable: return \"OpenTable\"\n    case OpOpenIndex: return \"OpenIndex\"\n    case OpClose: return \"Close\"\n    case OpRewind: return \"Rewind\"\n    case OpNext: return \"Next\"\n    case OpColumn: return \"Column\"\n    case OpResultRow: return \"ResultRow\"\n    case OpMakeRecord: return \"MakeRecord\"\n    case OpInsert: return \"Insert\"\n    case OpDelete: return \"Delete\"\n    case OpInteger: return \"Integer\"\n    case OpString8: return \"String8\"\n    case OpNull: return \"Null\"\n    case OpEq: return \"Eq\"\n    case OpNe: return \"Ne\"\n    case OpLt: return \"Lt\"\n    case OpLe: return \"Le\"\n    case OpGt: return \"Gt\"\n    case OpGe: return \"Ge\"\n    case OpGoto: return \"Goto\"\n    case OpHalt: return \"Halt\"\n    case OpIf: return \"If\"\n    case OpIfNot: return \"IfNot\"\n    case OpRowid: return \"Rowid\"\n    // ... all others\n    default: return fmt.Sprintf(\"Opcode(%d)\", op)\n    }\n}\n\ntype Instruction struct {\n    Opcode   Opcode\n    P1       int         // First parameter (often cursor#, register#, or value)\n    P2       int         // Second parameter (often jump target or column#)\n    P3       int         // Third parameter (often register#)\n    P4       interface{} // Optional: string, int64, float64, or byte[]\n    Comment  string      // Human-readable description for EXPLAIN\n}\n\n// WHY each field exists:\n// - Opcode: Dispatches to the correct VM handler\n// - P1: Primary operand (cursor number, source register, integer value)\n// - P2: Secondary operand (jump target, column index, destination register)\n// - P3: Tertiary operand (comparison register, record count)\n// - P4: Variable-size operand (strings, large integers, blobs)\n// - Comment: Enables EXPLAIN output for debugging\n```\n\n### Compiler State\n\n```go\n// compiler.go\n\ntype Compiler struct {\n    // Input\n    ast         Statement      // Parsed AST to compile\n    schema      Schema         // Database schema for validation\n    \n    // Output\n    program     []Instruction  // Emitted bytecode program\n    \n    // Register allocation\n    nextReg     int            // Next available register number\n    maxReg      int            // Highest register used\n    \n    // Cursor allocation\n    nextCursor  int            // Next available cursor number\n    \n    // Jump patching\n    jumpPatches []JumpPatch    // Forward references to patch\n    \n    // Loop tracking (for break/continue in future)\n    loopStack   []LoopInfo\n    \n    // Error collection\n    errors      []CompileError\n}\n\ntype JumpPatch struct {\n    InstrIndex int    // Index in program of instruction needing patch\n    TargetName string // Symbolic name of target (e.g., \"loop_start\", \"halt\")\n}\n\ntype LoopInfo struct {\n    StartAddr   int  // Address of loop start (Rewind)\n    EndAddr     int  // Address of loop end (after Next)\n    ContinueAddr int // Address for continue (Next instruction)\n}\n\ntype CompileError struct {\n    Message string\n    Pos     Position  // AST node position\n}\n\nfunc (e CompileError) Error() string {\n    return fmt.Sprintf(\"compile error at line %d, column %d: %s\", \n        e.Pos.Line, e.Pos.Column, e.Message)\n}\n\n// Invariants:\n// - nextReg always points to an unused register\n// - All jumpPatches are resolved before Compile() returns\n// - program always ends with Halt instruction\n// - Cursor numbers are unique within a program\n```\n\n### Register Allocator\n\n```go\n// register.go\n\ntype RegisterAllocator struct {\n    nextReg    int\n    maxReg     int\n    allocated  map[int]bool  // Currently allocated registers\n    freed      []int         // Registers available for reuse\n}\n\nfunc (ra *RegisterAllocator) Allocate() int {\n    // Reuse freed register if available\n    if len(ra.freed) > 0 {\n        reg := ra.freed[len(ra.freed)-1]\n        ra.freed = ra.freed[:len(ra.freed)-1]\n        ra.allocated[reg] = true\n        return reg\n    }\n    \n    // Allocate new register\n    reg := ra.nextReg\n    ra.nextReg++\n    if reg > ra.maxReg {\n        ra.maxReg = reg\n    }\n    ra.allocated[reg] = true\n    return reg\n}\n\nfunc (ra *RegisterAllocator) Free(reg int) {\n    if ra.allocated[reg] {\n        delete(ra.allocated, reg)\n        ra.freed = append(ra.freed, reg)\n    }\n}\n\nfunc (ra *RegisterAllocator) AllocateRange(count int) int {\n    // Allocate contiguous range of registers\n    start := ra.nextReg\n    ra.nextReg += count\n    if ra.nextReg-1 > ra.maxReg {\n        ra.maxReg = ra.nextReg - 1\n    }\n    return start\n}\n```\n\n### VM Value Types\n\n```go\n// vm/value.go\n\ntype ValueType int\n\nconst (\n    ValueNull ValueType = iota\n    ValueInteger\n    ValueReal\n    ValueText\n    ValueBlob\n)\n\ntype Value struct {\n    Type  ValueType\n    Int   int64\n    Float float64\n    Str   string\n    Bytes []byte\n}\n\nfunc (v Value) IsNull() bool {\n    return v.Type == ValueNull\n}\n\nfunc (v Value) IsTruthy() bool {\n    // For WHERE clause filtering\n    // Only non-zero, non-NULL values are truthy\n    switch v.Type {\n    case ValueNull:\n        return false\n    case ValueInteger:\n        return v.Int != 0\n    case ValueReal:\n        return v.Float != 0\n    case ValueText:\n        return len(v.Str) > 0\n    case ValueBlob:\n        return len(v.Bytes) > 0\n    default:\n        return false\n    }\n}\n\nfunc (v Value) Compare(other Value) int {\n    // Returns -1, 0, or 1\n    // NULL comparisons return 2 (incomparable)\n    if v.Type == ValueNull || other.Type == ValueNull {\n        return 2\n    }\n    \n    // Type coercion for comparison\n    if v.Type == ValueReal || other.Type == ValueReal {\n        lv := v.toFloat()\n        rv := other.toFloat()\n        if lv < rv {\n            return -1\n        } else if lv > rv {\n            return 1\n        }\n        return 0\n    }\n    \n    // Integer comparison\n    if v.Type == ValueInteger && other.Type == ValueInteger {\n        if v.Int < other.Int {\n            return -1\n        } else if v.Int > other.Int {\n            return 1\n        }\n        return 0\n    }\n    \n    // Text comparison\n    if v.Type == ValueText && other.Type == ValueText {\n        if v.Str < other.Str {\n            return -1\n        } else if v.Str > other.Str {\n            return 1\n        }\n        return 0\n    }\n    \n    return 2\n}\n\nfunc (v Value) toFloat() float64 {\n    switch v.Type {\n    case ValueInteger:\n        return float64(v.Int)\n    case ValueReal:\n        return v.Float\n    default:\n        return 0\n    }\n}\n```\n\n### Virtual Machine State\n\n```go\n// vm/vm.go\n\ntype VM struct {\n    // Program\n    Program    []Instruction\n    PC         int           // Program counter (instruction index)\n    \n    // Registers\n    Registers  []Value       // Register file\n    \n    // Cursors\n    Cursors    [MAX_CURSORS]*Cursor\n    \n    // Execution state\n    Halted     bool\n    ErrorCode  int\n    ErrorMsg   string\n    \n    // Output callback\n    Output     func([]Value) error\n    \n    // Storage interface\n    Storage    StorageEngine\n    \n    // Transaction state\n    InTransaction bool\n    WriteCount    int\n}\n\nconst MAX_CURSORS = 100\nconst MAX_REGISTERS = 1000\n\ntype Cursor struct {\n    ID         int\n    TableRoot  uint32\n    IsIndex    bool\n    PageID     uint32\n    CellIndex  int\n    AtEnd      bool\n    Rowid      int64\n    Record     []byte\n}\n\ntype StorageEngine interface {\n    OpenTable(rootPage uint32) (*TableHandle, error)\n    OpenIndex(rootPage uint32) (*IndexHandle, error)\n    FetchPage(pageID uint32) (*Page, error)\n}\n```\n\n---\n\n## Interface Contracts\n\n### Compiler Entry Point\n\n```go\n// Compile transforms a parsed AST into a bytecode program.\n//\n// Parameters:\n//   - ast: The root Statement node from the parser\n//   - schema: Database schema for table/column resolution\n//\n// Returns:\n//   - []Instruction: Complete bytecode program ending with Halt\n//   - error: CompileError if compilation fails\n//\n// Pre-conditions:\n//   - ast is non-nil and valid\n//   - schema contains all referenced tables\n//\n// Post-conditions:\n//   - All forward jump targets are resolved\n//   - Program ends with Halt instruction\n//   - Register allocation is complete (no gaps)\n//\n// Error conditions:\n//   - Unknown table reference\n//   - Unknown column reference\n//   - Type mismatch in expressions\n//   - Register exhaustion\nfunc Compile(ast Statement, schema Schema) ([]Instruction, error)\n```\n\n### Compiler Methods\n\n```go\n// emit appends an instruction to the program and returns its index.\nfunc (c *Compiler) emit(op Opcode, p1, p2, p3 int, p4 interface{}, comment string) int\n\n// emitJump emits a jump instruction with a symbolic target to be patched later.\nfunc (c *Compiler) emitJump(op Opcode, p1 int, targetName string) int\n\n// patchJump resolves a forward reference to the current program position.\nfunc (c *Compiler) patchJump(instrIndex int)\n\n// patchJumpTo resolves a forward reference to a specific address.\nfunc (c *Compiler) patchJumpTo(instrIndex int, targetAddr int)\n\n// currentAddr returns the index of the next instruction to be emitted.\nfunc (c *Compiler) currentAddr() int\n\n// allocateRegister allocates and returns a new register number.\nfunc (c *Compiler) allocateRegister() int\n\n// allocateRegisters allocates a contiguous range of registers.\nfunc (c *Compiler) allocateRegisters(count int) int\n\n// freeRegister marks a register as available for reuse.\nfunc (c *Compiler) freeRegister(reg int)\n\n// allocateCursor allocates and returns a new cursor number.\nfunc (c *Compiler) allocateCursor() int\n```\n\n### VM Entry Point\n\n```go\n// Run executes the bytecode program until Halt or error.\n//\n// Returns:\n//   - error: Execution error, or nil on success\n//\n// The Output callback is called for each ResultRow instruction.\nfunc (vm *VM) Run() error\n\n// Step executes a single instruction and returns.\n// Useful for debugging and interruptible execution.\nfunc (vm *VM) Step() error\n\n// Reset prepares the VM for re-execution with new parameters.\n// Preserves the program but clears registers and cursors.\nfunc (vm *VM) Reset()\n```\n\n---\n\n## Algorithm Specification\n\n### SELECT Statement Compilation\n\n\n![Bytecode Instruction Format](./diagrams/tdd-diag-9.svg)\n\n\n```\nALGORITHM: compileSelect\nINPUT: SelectStatement AST\nOUTPUT: Bytecode program (appended to compiler.program)\n\n1. stmt := SelectStatement AST\n   cursor := allocateCursor()\n\n2. // Emit OpenTable instruction\n   rootPage := schema.GetTableRootPage(stmt.FromTable)\n   emit(OpOpenTable, cursor, rootPage, 0, nil, \"table=\" + stmt.FromTable)\n\n3. // Emit Rewind (position before first row)\n   rewindAddr := currentAddr()\n   emit(OpRewind, cursor, 0, 0, nil, \"jump to halt if empty\")\n   // P2 will be patched to halt address after loop\n\n4. // Loop start marker for jump patching\n   loopStartAddr := currentAddr()\n\n5. // Compile WHERE clause (if present)\n   IF stmt.Where != nil:\n     a. condReg := compileExpression(stmt.Where)\n     b. // Jump to Next if condition is false/NULL\n        emit(OpIfNot, condReg, 0, 0, nil, \"skip row if WHERE false\")\n        whereJumpIndex := last instruction index\n     c. freeRegister(condReg)\n\n6. // Compile column reads for projection\n   colStartReg := allocateRegisters(len(stmt.Columns))\n   FOR i, col := range stmt.Columns:\n     a. colIndex := schema.GetColumnIndex(stmt.FromTable, col.Name)\n     b. destReg := colStartReg + i\n     c. emit(OpColumn, cursor, colIndex, destReg, nil, \n             fmt.Sprintf(\"col=%s -> r%d\", col.Name, destReg))\n\n7. // Emit ResultRow to output the row\n   emit(OpResultRow, colStartReg, len(stmt.Columns), 0, nil, \n        fmt.Sprintf(\"output %d columns\", len(stmt.Columns)))\n\n8. // Emit Next instruction (loop back)\n   emit(OpNext, cursor, loopStartAddr, 0, nil, \"loop back\")\n   nextAddr := currentAddr() - 1  // Index of Next instruction\n\n9. // Emit Halt\n   haltAddr := currentAddr()\n   emit(OpHalt, 0, 0, 0, nil, \"end of query\")\n\n10. // Patch forward references\n    a. Patch Rewind jump to haltAddr\n    b. IF stmt.Where != nil:\n         Patch WHERE jump to nextAddr (the Next instruction)\n\n11. // Emit Close (optional, for cleanup)\n    emit(OpClose, cursor, 0, 0, nil, \"\")\n\nPOST-CONDITION: Program contains complete table scan with filtering\n```\n\n### INSERT Statement Compilation\n\n```\nALGORITHM: compileInsert\nINPUT: InsertStatement AST\nOUTPUT: Bytecode program\n\n1. stmt := InsertStatement AST\n   cursor := allocateCursor()\n\n2. // Open table\n   rootPage := schema.GetTableRootPage(stmt.Table)\n   emit(OpOpenTable, cursor, rootPage, 0, nil, \"table=\" + stmt.Table)\n\n3. // For each VALUES tuple\n   FOR _, valueTuple := range stmt.Values:\n     a. // Compile each value expression into registers\n        valueStartReg := allocateRegisters(len(valueTuple))\n        FOR i, valExpr := range valueTuple:\n          reg := compileExpression(valExpr)\n          IF reg != valueStartReg + i:\n            // Move to correct position\n            emit(OpCopy, reg, valueStartReg + i, 0, nil, \"\")\n            freeRegister(reg)\n     \n     b. // Create record from values\n        recordReg := allocateRegister()\n        emit(OpMakeRecord, valueStartReg, len(valueTuple), recordReg, nil,\n             \"create record from values\")\n     \n     c. // Get new rowid (auto-increment or explicit)\n        rowidReg := allocateRegister()\n        IF hasExplicitRowid(valueTuple):\n          rowidReg = getExplicitRowidReg()\n        ELSE:\n          emit(OpNewRowid, cursor, rowidReg, 0, nil, \"generate new rowid\")\n     \n     d. // Insert the record\n        emit(OpInsert, cursor, recordReg, rowidReg, nil, \"insert record\")\n     \n     e. // Free temporary registers\n        freeRegisters(valueStartReg, len(valueTuple))\n        freeRegister(recordReg)\n        freeRegister(rowidReg)\n\n4. // Close cursor\n   emit(OpClose, cursor, 0, 0, nil, \"\")\n\n5. // Halt\n   emit(OpHalt, 0, 0, 0, nil, \"\")\n\nPOST-CONDITION: Program inserts all value tuples\n```\n\n### Expression Compilation\n\n\n![SELECT Compilation to Bytecode](./diagrams/tdd-diag-10.svg)\n\n\n```\nALGORITHM: compileExpression\nINPUT: Expression AST node\nOUTPUT: Register number containing result\n\n1. SWITCH on expression type:\n\n   CASE LiteralExpression:\n     a. resultReg := allocateRegister()\n     b. SWITCH on literal type:\n        CASE LiteralNull:\n          emit(OpNull, resultReg, 0, 0, nil, \"NULL\")\n        CASE LiteralInteger:\n          IF value fits in P1 (32-bit signed):\n            emit(OpInteger, int(value), resultReg, 0, nil, fmt.Sprintf(\"r%d=%d\", resultReg, value))\n          ELSE:\n            emit(OpInt64, 0, resultReg, 0, value, fmt.Sprintf(\"r%d=%d\", resultReg, value))\n        CASE LiteralFloat:\n          emit(OpReal, 0, resultReg, 0, value, fmt.Sprintf(\"r%d=%f\", resultReg, value))\n        CASE LiteralString:\n          emit(OpString8, 0, resultReg, 0, value, fmt.Sprintf(\"r%d=\\\"%s\\\"\", resultReg, value))\n     c. RETURN resultReg\n\n   CASE IdentifierExpression:\n     a. // Column reference - already loaded by Column instruction\n        // For now, allocate and load from cursor\n        resultReg := allocateRegister()\n        colIndex := schema.GetColumnIndex(currentTable, expr.Name)\n        emit(OpColumn, currentCursor, colIndex, resultReg, nil,\n             fmt.Sprintf(\"load %s -> r%d\", expr.Name, resultReg))\n        RETURN resultReg\n\n   CASE BinaryExpression:\n     a. leftReg := compileExpression(expr.Left)\n     b. rightReg := compileExpression(expr.Right)\n     c. resultReg := allocateRegister()\n     d. SWITCH on operator:\n        CASE \"+\":\n          emit(OpAdd, leftReg, rightReg, resultReg, nil, \"add\")\n        CASE \"-\":\n          emit(OpSubtract, leftReg, rightReg, resultReg, nil, \"subtract\")\n        CASE \"*\":\n          emit(OpMultiply, leftReg, rightReg, resultReg, nil, \"multiply\")\n        CASE \"/\":\n          emit(OpDivide, leftReg, rightReg, resultReg, nil, \"divide\")\n        CASE \"||\":\n          emit(OpConcat, leftReg, rightReg, resultReg, nil, \"concatenate\")\n        CASE \"=\", \"<\", \">\", \"<=\", \">=\", \"!=\", \"<>\":\n          // Comparisons don't produce a value, they jump\n          // Return leftReg as the \"result\" for If/IfNot to test\n          emit(opcodeForComparison(expr.Operator), leftReg, 0, rightReg, nil,\n               fmt.Sprintf(\"compare %s\", expr.Operator))\n          // Mark that this is a comparison result\n          RETURN leftReg  // Actually, comparisons set condition flags\n        CASE \"AND\", \"OR\":\n          // Logical operators compile to conditional jumps\n          RETURN compileLogicalExpression(expr)\n     e. freeRegister(leftReg)\n        freeRegister(rightReg)\n        RETURN resultReg\n\n   CASE UnaryExpression:\n     a. operandReg := compileExpression(expr.Operand)\n     b. SWITCH on operator:\n        CASE \"NOT\":\n          emit(OpNot, operandReg, 0, 0, nil, \"logical NOT\")\n          RETURN operandReg\n        CASE \"-\":\n          resultReg := allocateRegister()\n          emit(OpInteger, 0, resultReg, 0, nil, \"zero\")\n          emit(OpSubtract, resultReg, operandReg, resultReg, nil, \"negate\")\n          freeRegister(operandReg)\n          RETURN resultReg\n\n   CASE FunctionCallExpression:\n     a. // Handle aggregate functions specially\n     b. // For now, just compile arguments\n     c. RETURN compileFunctionCall(expr)\n\n   DEFAULT:\n     error(\"unknown expression type: %T\", expr)\n     RETURN -1\n\nPOST-CONDITION: Result is in returned register; caller owns the register\n```\n\n### WHERE Clause with Conditional Jumps\n\n\n![VM Fetch-Decode-Execute Cycle](./diagrams/tdd-diag-11.svg)\n\n\n```\nALGORITHM: compileWhereClause\nINPUT: Expression (WHERE condition), jumpTarget (where to jump if false)\nOUTPUT: None (emits conditional jump instructions)\n\n1. expr := WHERE expression\n   jumpToNext := address to jump to when condition is false\n\n2. SWITCH on expression type:\n\n   CASE BinaryExpression with comparison operator:\n     a. leftReg := compileExpression(expr.Left)\n     b. rightReg := compileExpression(expr.Right)\n     c. // Emit comparison with jump-if-NOT-condition\n        // For \"age > 18\", jump to Next if age <= 18\n        emit(negatedComparisonOpcode(expr.Operator), \n             leftReg, jumpToNext, rightReg, nil,\n             \"skip if NOT \" + expr.Operator)\n     d. freeRegister(leftReg)\n        freeRegister(rightReg)\n\n   CASE BinaryExpression with \"AND\":\n     // AND: both must be true; short-circuit on first false\n     a. compileWhereClause(expr.Left, jumpToNext)\n     b. compileWhereClause(expr.Right, jumpToNext)\n\n   CASE BinaryExpression with \"OR\":\n     // OR: at least one must be true\n     // If first is true, continue; if first is false, check second\n     a. // Label for \"first was true, continue\"\n        continueLabel := newLabel(\"or_continue\")\n     b. // Check first condition; if true, jump to continue\n        compileCondition(expr.Left, continueLabel)\n     c. // First was false, check second; if false, jump to Next\n        compileWhereClause(expr.Right, jumpToNext)\n     d. // Continue label\n        defineLabel(continueLabel)\n\n   CASE UnaryExpression with \"NOT\":\n     // NOT: invert the condition\n     a. compileCondition(expr.Operand, jumpToNext)  // Jump to Next if operand is TRUE\n\n   CASE ParenExpression:\n     a. compileWhereClause(expr.Expression, jumpToNext)\n\n   DEFAULT:\n     // General expression: evaluate and test truthiness\n     a. condReg := compileExpression(expr)\n     b. emit(OpIfNot, condReg, jumpToNext, 0, nil, \"skip if condition false/NULL\")\n     c. freeRegister(condReg)\n\nPOST-CONDITION: Conditional jumps emitted; control flow correct\n```\n\n### VM Execution Loop\n\n\n![Register Allocation for SELECT](./diagrams/tdd-diag-12.svg)\n\n\n```\nALGORITHM: VM.Run\nINPUT: VM with loaded program\nOUTPUT: Execution result (via Output callback)\n\n1. vm.Halted = false\n   vm.PC = 0\n\n2. WHILE NOT vm.Halted AND vm.PC < len(vm.Program):\n     a. instr := vm.Program[vm.PC]\n     b. err := vm.executeInstruction(instr)\n     c. IF err != nil:\n          RETURN err\n\n3. RETURN nil\n\nALGORITHM: VM.executeInstruction\nINPUT: Instruction to execute\nOUTPUT: Error or nil\n\n1. instr := current instruction\n\n2. SWITCH on instr.Opcode:\n\n   CASE OpHalt:\n     vm.Halted = true\n     // Don't increment PC\n\n   CASE OpGoto:\n     vm.PC = instr.P2\n     RETURN nil  // Skip PC increment\n\n   CASE OpInteger:\n     vm.Registers[instr.P2] = Value{Type: ValueInteger, Int: int64(instr.P1)}\n\n   CASE OpString8:\n     vm.Registers[instr.P2] = Value{Type: ValueText, Str: instr.P4.(string)}\n\n   CASE OpNull:\n     vm.Registers[instr.P1] = Value{Type: ValueNull}\n\n   CASE OpOpenTable:\n     cursor := vm.Storage.OpenTable(uint32(instr.P2))\n     vm.Cursors[instr.P1] = &Cursor{\n       ID:        instr.P1,\n       TableRoot: uint32(instr.P2),\n     }\n\n   CASE OpClose:\n     vm.Cursors[instr.P1] = nil\n\n   CASE OpRewind:\n     cursor := vm.Cursors[instr.P1]\n     IF cursor == nil:\n       RETURN error(\"cursor not open\")\n     err := vm.rewindCursor(cursor)\n     IF err != nil OR cursor.AtEnd:\n       // Table is empty, jump to P2\n       vm.PC = instr.P2\n       RETURN nil\n\n   CASE OpNext:\n     cursor := vm.Cursors[instr.P1]\n     err := vm.advanceCursor(cursor)\n     IF err != nil OR cursor.AtEnd:\n       // No more rows, continue to next instruction\n       vm.PC++\n       RETURN nil\n     ELSE:\n       // More rows, jump to P2 (loop start)\n       vm.PC = instr.P2\n       RETURN nil\n\n   CASE OpColumn:\n     cursor := vm.Cursors[instr.P1]\n     value := vm.readColumn(cursor, instr.P2)\n     vm.Registers[instr.P3] = value\n\n   CASE OpResultRow:\n     row := make([]Value, instr.P2)\n     FOR i := 0; i < instr.P2; i++:\n       row[i] = vm.Registers[instr.P1 + i]\n     IF vm.Output != nil:\n       err := vm.Output(row)\n       IF err != nil:\n         RETURN err\n\n   CASE OpMakeRecord:\n     // Serialize registers [P1, P1+P2-1] into a record\n     record := vm.serializeRecord(vm.Registers[instr.P1 : instr.P1+instr.P2])\n     vm.Registers[instr.P3] = Value{Type: ValueBlob, Bytes: record}\n\n   CASE OpInsert:\n     cursor := vm.Cursors[instr.P1]\n     record := vm.Registers[instr.P2].Bytes\n     rowid := vm.Registers[instr.P3].Int\n     err := vm.insertRecord(cursor, rowid, record)\n     IF err != nil:\n       RETURN err\n\n   CASE OpEq, OpNe, OpLt, OpLe, OpGt, OpGe:\n     left := vm.Registers[instr.P1]\n     right := vm.Registers[instr.P3]\n     result := left.Compare(right)\n     \n     shouldJump := false\n     SWITCH instr.Opcode:\n       CASE OpEq: shouldJump = (result == 0)\n       CASE OpNe: shouldJump = (result != 0 AND result != 2)  // Not equal and not NULL\n       CASE OpLt: shouldJump = (result == -1)\n       CASE OpLe: shouldJump = (result == -1 OR result == 0)\n       CASE OpGt: shouldJump = (result == 1)\n       CASE OpGe: shouldJump = (result == 1 OR result == 0)\n     \n     IF shouldJump:\n       vm.PC = instr.P2\n       RETURN nil\n\n   CASE OpIf:\n     IF vm.Registers[instr.P1].IsTruthy():\n       vm.PC = instr.P2\n       RETURN nil\n\n   CASE OpIfNot:\n     IF NOT vm.Registers[instr.P1].IsTruthy():\n       vm.PC = instr.P2\n       RETURN nil\n\n   CASE OpAdd:\n     left := vm.Registers[instr.P1].toFloat()\n     right := vm.Registers[instr.P2].toFloat()\n     vm.Registers[instr.P3] = Value{Type: ValueReal, Float: left + right}\n\n   CASE OpSubtract:\n     left := vm.Registers[instr.P1].toFloat()\n     right := vm.Registers[instr.P2].toFloat()\n     vm.Registers[instr.P3] = Value{Type: ValueReal, Float: left - right}\n\n   CASE OpMultiply:\n     left := vm.Registers[instr.P1].toFloat()\n     right := vm.Registers[instr.P2].toFloat()\n     vm.Registers[instr.P3] = Value{Type: ValueReal, Float: left * right}\n\n   CASE OpDivide:\n     left := vm.Registers[instr.P1].toFloat()\n     right := vm.Registers[instr.P2].toFloat()\n     IF right == 0:\n       vm.Registers[instr.P3] = Value{Type: ValueNull}\n     ELSE:\n       vm.Registers[instr.P3] = Value{Type: ValueReal, Float: left / right}\n\n   DEFAULT:\n     RETURN error(\"unknown opcode: %d\", instr.Opcode)\n\n3. vm.PC++\n   RETURN nil\n\nPOST-CONDITION: Either Halted or PC advanced; registers/cursors updated\n```\n\n---\n\n## Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n|-------|-------------|----------|---------------|\n| Unknown table | `compileSelect` during schema lookup | Return CompileError immediately | Yes: \"no such table: {name}\" |\n| Unknown column | `compileExpression` during column resolution | Return CompileError immediately | Yes: \"no such column: {table}.{name}\" |\n| Type mismatch | Expression compiler | Return CompileError with context | Yes: \"cannot compare TEXT to INTEGER\" |\n| Register exhaustion | `allocateRegister` | Return CompileError when max exceeded | Yes: \"too many registers required\" |\n| Unresolved jump target | `Compile` finalization | Return CompileError with target name | Yes: \"internal error: unresolved jump to {name}\" |\n| Division by zero | VM `OpDivide` handler | Store NULL in result register | No: SQL semantics, returns NULL |\n| Cursor not open | VM cursor operations | Return execution error | Yes: \"cursor {n} is not open\" |\n| Invalid instruction | VM execution loop | Return execution error | Yes: \"invalid opcode at address {n}\" |\n| Output callback error | VM `OpResultRow` | Propagate error, halt execution | Yes: depends on callback |\n\n---\n\n## Implementation Sequence with Checkpoints\n\n### Phase 1: Instruction Set and Compiler Skeleton (2 hours)\n\n**Files to create**: `instruction.go`, `compiler.go`, `register.go`\n\n**Implementation**:\n1. Define `Opcode` enum with all opcodes\n2. Define `Instruction` struct\n3. Define `Compiler` struct with register allocator\n4. Implement `emit`, `currentAddr`, `allocateRegister`, `allocateCursor`\n5. Implement jump patching: `emitJump`, `patchJump`, `patchJumpTo`\n6. Define `Value` type and basic operations\n\n**Checkpoint**: At this point you should be able to emit a simple program. Run:\n```bash\ngo test -run TestCompilerSkeleton\n# Expected: PASS (can emit and patch instructions)\n```\n\n### Phase 2: SELECT Compilation (2 hours)\n\n**Files to create**: `select.go`\n\n**Implementation**:\n1. Implement `compileSelect` skeleton\n2. Implement OpenTable, Rewind, Next, Column, ResultRow emission\n3. Implement loop structure with correct jump targets\n4. Implement column projection\n\n**Checkpoint**: At this point you should be able to compile `SELECT * FROM users`. Run:\n```bash\ngo test -run TestCompileSelect\n# Expected: PASS (SELECT produces correct bytecode structure)\n```\n\n### Phase 3: INSERT/UPDATE/DELETE Compilation (2 hours)\n\n**Files to create**: `insert.go`, `update.go`, `delete.go`\n\n**Implementation**:\n1. Implement `compileInsert` with MakeRecord, Insert\n2. Implement `compileUpdate` with Column, MakeRecord, Insert (delete+insert)\n3. Implement `compileDelete` with Delete opcode\n4. Handle multiple VALUES tuples in INSERT\n\n**Checkpoint**: At this point you should be able to compile INSERT statements. Run:\n```bash\ngo test -run TestCompileInsert\n# Expected: PASS (INSERT produces correct bytecode)\n```\n\n### Phase 4: WHERE Clause Compilation (2 hours)\n\n**Files to create**: `expression.go`\n\n**Implementation**:\n1. Implement `compileExpression` for literals\n2. Implement `compileExpression` for identifiers (column references)\n3. Implement `compileExpression` for binary operators\n4. Implement `compileWhereClause` with conditional jumps\n5. Implement comparison opcodes with negation\n\n**Checkpoint**: At this point you should pass WHERE clause tests. Run:\n```bash\ngo test -run TestCompileWhere\n# Expected: PASS (WHERE clauses produce correct jumps)\n```\n\n### Phase 5: VM Execution Loop (2 hours)\n\n**Files to create**: `vm/vm.go`, `vm/opcodes.go`, `vm/value.go`\n\n**Implementation**:\n1. Implement `VM` struct with registers and cursors\n2. Implement `Run` main loop\n3. Implement opcode handlers: Halt, Goto, Integer, String8, Null\n4. Implement cursor opcodes: OpenTable, Rewind, Next, Column\n5. Implement output: ResultRow\n6. Implement record operations: MakeRecord, Insert\n7. Implement comparison opcodes\n\n**Checkpoint**: At this point you should pass the full test suite. Run:\n```bash\ngo test -v ./compiler\ngo test -v ./vm\n# Expected: All tests PASS\n# Verify: 10,000-row table scan completes in < 100ms\n```\n\n---\n\n## Test Specification\n\n### Test Categories\n\n```go\n// compiler_test.go\n\nfunc TestCompileSelectBasic(t *testing.T) {\n    ast := &SelectStatement{\n        Columns:   []ColumnSelection{{Expression: StarExpression{}}},\n        FromTable: \"users\",\n    }\n    \n    program, err := Compile(ast, testSchema)\n    assert.NoError(t, err)\n    \n    // Verify program structure\n    assert.Equal(t, OpOpenTable, program[0].Opcode)\n    assert.Equal(t, OpRewind, program[1].Opcode)\n    assert.Equal(t, OpColumn, program[2].Opcode)\n    assert.Equal(t, OpResultRow, program[3].Opcode)\n    assert.Equal(t, OpNext, program[4].Opcode)\n    assert.Equal(t, OpHalt, program[len(program)-1].Opcode)\n    \n    // Verify jump targets are resolved\n    for _, instr := range program {\n        if instr.Opcode == OpRewind || instr.Opcode == OpNext {\n            assert.Greater(t, instr.P2, 0, \"Jump target should be resolved\")\n            assert.Less(t, instr.P2, len(program), \"Jump target within bounds\")\n        }\n    }\n}\n\nfunc TestCompileSelectWithWhere(t *testing.T) {\n    ast := &SelectStatement{\n        Columns:   []ColumnSelection{{Expression: StarExpression{}}},\n        FromTable: \"users\",\n        Where: &BinaryExpression{\n            Operator: \">\",\n            Left:     &IdentifierExpression{Name: \"age\"},\n            Right:    &LiteralExpression{Value: int64(18)},\n        },\n    }\n    \n    program, err := Compile(ast, testSchema)\n    assert.NoError(t, err)\n    \n    // Find the comparison instruction\n    var foundCompare bool\n    for _, instr := range program {\n        if instr.Opcode == OpLe {  // Negated > is <=\n            foundCompare = true\n            // Should jump to Next instruction\n            assert.Greater(t, instr.P2, 0)\n        }\n    }\n    assert.True(t, foundCompare, \"Should emit comparison for WHERE\")\n}\n\nfunc TestCompileInsert(t *testing.T) {\n    ast := &InsertStatement{\n        Table:   \"users\",\n        Columns: []string{\"id\", \"name\"},\n        Values: [][]Expression{\n            {\n                &LiteralExpression{Value: int64(1)},\n                &LiteralExpression{Value: \"Alice\"},\n            },\n        },\n    }\n    \n    program, err := Compile(ast, testSchema)\n    assert.NoError(t, err)\n    \n    // Verify program structure\n    assert.Contains(t, opcodeSequence(program), []Opcode{\n        OpOpenTable, OpInteger, OpString8, OpMakeRecord, OpInsert, OpClose, OpHalt,\n    })\n}\n\nfunc TestCompileExpressionLiterals(t *testing.T) {\n    tests := []struct {\n        expr     Expression\n        expected Opcode\n    }{\n        {expr: &LiteralExpression{Value: int64(42)}, expected: OpInteger},\n        {expr: &LiteralExpression{Value: 3.14}, expected: OpReal},\n        {expr: &LiteralExpression{Value: \"hello\"}, expected: OpString8},\n        {expr: &LiteralExpression{Value: nil}, expected: OpNull},\n    }\n    \n    for _, tc := range tests {\n        c := NewCompiler(testSchema)\n        reg := c.compileExpression(tc.expr)\n        assert.GreaterOrEqual(t, reg, 0)\n        assert.Equal(t, tc.expected, c.program[len(c.program)-1].Opcode)\n    }\n}\n\nfunc TestJumpPatching(t *testing.T) {\n    c := NewCompiler(testSchema)\n    \n    // Emit forward jump\n    jumpIdx := c.emitJump(OpGoto, 0, \"target\")\n    \n    // Emit some instructions\n    c.emit(OpInteger, 1, 0, 0, nil, \"\")\n    c.emit(OpInteger, 2, 1, 0, nil, \"\")\n    \n    // Define target\n    targetAddr := c.currentAddr()\n    c.emit(OpHalt, 0, 0, 0, nil, \"\")\n    \n    // Patch the jump\n    c.patchJumpTo(jumpIdx, targetAddr)\n    \n    // Verify\n    assert.Equal(t, targetAddr, c.program[jumpIdx].P2)\n}\n\nfunc TestExplainOutput(t *testing.T) {\n    ast := parseSQL(\"SELECT id, name FROM users WHERE age > 18\")\n    program, _ := Compile(ast, testSchema)\n    \n    explain := FormatExplain(program)\n    \n    // Verify EXPLAIN format\n    assert.Contains(t, explain, \"addr\")\n    assert.Contains(t, explain, \"opcode\")\n    assert.Contains(t, explain, \"OpenTable\")\n    assert.Contains(t, explain, \"Column\")\n    assert.Contains(t, explain, \"ResultRow\")\n    assert.Contains(t, explain, \"Halt\")\n}\n\n// vm/vm_test.go\n\nfunc TestVMExecuteInteger(t *testing.T) {\n    vm := &VM{\n        Program:   []Instruction{{Opcode: OpInteger, P1: 42, P2: 0}},\n        Registers: make([]Value, 10),\n    }\n    \n    err := vm.Step()\n    assert.NoError(t, err)\n    assert.Equal(t, int64(42), vm.Registers[0].Int)\n}\n\nfunc TestVMExecuteGoto(t *testing.T) {\n    vm := &VM{\n        Program: []Instruction{\n            {Opcode: OpGoto, P2: 2},\n            {Opcode: OpInteger, P1: 1, P2: 0},  // Skipped\n            {Opcode: OpInteger, P1: 2, P2: 0},  // Target\n            {Opcode: OpHalt},\n        },\n        Registers: make([]Value, 10),\n    }\n    \n    err := vm.Run()\n    assert.NoError(t, err)\n    assert.Equal(t, int64(2), vm.Registers[0].Int)  // Not 1\n}\n\nfunc TestVMTableScan(t *testing.T) {\n    // Create mock storage with 3 rows\n    storage := NewMockStorage()\n    storage.AddTable(\"users\", 3, [][]interface{}{\n        {int64(1), \"Alice\"},\n        {int64(2), \"Bob\"},\n        {int64(3), \"Charlie\"},\n    })\n    \n    // Compile SELECT * FROM users\n    ast := parseSQL(\"SELECT * FROM users\")\n    program, _ := Compile(ast, storage.Schema())\n    \n    // Execute\n    var results [][]Value\n    vm := &VM{\n        Program:   program,\n        Registers: make([]Value, 100),\n        Storage:   storage,\n        Output: func(row []Value) error {\n            results = append(results, row)\n            return nil\n        },\n    }\n    \n    err := vm.Run()\n    assert.NoError(t, err)\n    assert.Len(t, results, 3)\n    assert.Equal(t, \"Alice\", results[0][1].Str)\n}\n\nfunc TestVMWhereClause(t *testing.T) {\n    storage := NewMockStorage()\n    storage.AddTable(\"users\", 5, [][]interface{}{\n        {int64(1), \"Alice\", int64(25)},\n        {int64(2), \"Bob\", int64(17)},   // Filtered out\n        {int64(3), \"Charlie\", int64(30)},\n        {int64(4), \"Diana\", int64(15)}, // Filtered out\n        {int64(5), \"Eve\", int64(22)},\n    })\n    \n    ast := parseSQL(\"SELECT name FROM users WHERE age > 18\")\n    program, _ := Compile(ast, storage.Schema())\n    \n    var results []string\n    vm := &VM{\n        Program:   program,\n        Registers: make([]Value, 100),\n        Storage:   storage,\n        Output: func(row []Value) error {\n            results = append(results, row[0].Str)\n            return nil\n        },\n    }\n    \n    err := vm.Run()\n    assert.NoError(t, err)\n    assert.Equal(t, []string{\"Alice\", \"Charlie\", \"Eve\"}, results)\n}\n\nfunc TestPerformance10KRows(t *testing.T) {\n    // Create table with 10,000 rows\n    storage := NewMockStorage()\n    var rows [][]interface{}\n    for i := 0; i < 10000; i++ {\n        rows = append(rows, []interface{}{int64(i), fmt.Sprintf(\"user%d\", i)})\n    }\n    storage.AddTable(\"t\", 10000, rows)\n    \n    ast := parseSQL(\"SELECT * FROM t\")\n    program, _ := Compile(ast, storage.Schema())\n    \n    count := 0\n    vm := &VM{\n        Program:   program,\n        Registers: make([]Value, 100),\n        Storage:   storage,\n        Output: func(row []Value) error {\n            count++\n            return nil\n        },\n    }\n    \n    start := time.Now()\n    err := vm.Run()\n    elapsed := time.Since(start)\n    \n    assert.NoError(t, err)\n    assert.Equal(t, 10000, count)\n    assert.Less(t, elapsed.Milliseconds(), int64(100), \n        \"10K row scan should complete in < 100ms\")\n}\n\nfunc opcodeSequence(program []Instruction) []Opcode {\n    ops := make([]Opcode, len(program))\n    for i, instr := range program {\n        ops[i] = instr.Opcode\n    }\n    return ops\n}\n```\n\n---\n\n## Performance Targets\n\n| Operation | Target | How to Measure |\n|-----------|--------|----------------|\n| Compile simple SELECT | < 1ms | `go test -bench=BenchmarkCompileSelect` |\n| Compile with WHERE | < 2ms | `go test -bench=BenchmarkCompileWhere` |\n| Execute 10K-row table scan | < 100ms | `go test -bench=BenchmarkTableScan10K` |\n| Execute with WHERE filtering 50% | < 100ms | `go test -bench=BenchmarkWhereFilter` |\n| Bytecode program size (SELECT *) | < 20 instructions | Count instructions in compiled program |\n| Register usage (simple query) | < 10 registers | Check `compiler.maxReg` after compilation |\n| Jump target resolution | 100% | All P2 > 0 for jump instructions |\n\n---\n\n## Synced Criteria\n\n[[CRITERIA_JSON: {\"module_id\": \"build-sqlite-m3\", \"criteria\": [\"Compiler translates SELECT AST into opcodes including OpenTable, Rewind, Column, ResultRow, Next, and Halt\", \"Compiler translates INSERT AST into opcodes including OpenTable, MakeRecord, and Insert\", \"VM executes bytecode in a fetch-decode-execute loop, processing one opcode per cycle\", \"VM manages a register file of typed values for intermediate calculations\", \"WHERE clauses are correctly compiled into conditional jump opcodes (e.g., Gt, Le, Ne)\", \"The EXPLAIN command displays the human-readable opcode sequence for any valid SQL statement\", \"The VM executes a full table scan of 10,000 rows in under 100ms\"]}]\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-sqlite-m4 -->\n# Technical Design Specification: Buffer Pool Manager\n\n## Module Charter\n\nThe Buffer Pool Manager provides a page-level cache between the B-tree storage layer and disk, managing a fixed pool of memory frames to minimize disk I/O. It implements LRU (Least Recently Used) eviction to select victim pages when the pool is full, pin counting to prevent eviction of pages actively in use by B-tree operations, dirty page tracking for deferred write-back, and `FlushAll` for transaction commit boundaries. The buffer pool does NOT interpret page contents, manage B-tree structure, or handle transaction semantics—it provides transparent page caching with durability guarantees via dirty page write-back. Upstream dependencies: B-tree layer (consumes page handles). Downstream dependencies: DiskManager (reads/writes pages to storage). Invariants: pinned pages (PinCount > 0) are never evicted; dirty pages are written to disk before eviction; page data remains valid only while page is pinned; PageID uniquely identifies a page across the database.\n\n---\n\n## File Structure\n\n```\nbufferpool/\n├── buffer_pool.go      # (1) BufferPool struct, constructor, FetchPage\n├── frame.go            # (2) Frame metadata (PageID, PinCount, Dirty, LastAccess)\n├── page.go             # (3) Page handle with data slice and lifecycle methods\n├── page_id.go          # (4) PageID type definition\n├── eviction.go         # (5) LRU eviction algorithm\n├── disk_manager.go     # (6) DiskManager interface and file implementation\n├── flush.go            # (7) FlushAll and FlushPage implementations\n├── stats.go            # (8) Hit rate and performance metrics\n├── buffer_pool_test.go # (9) Comprehensive test suite\n└── errors.go           # (10) Error types\n```\n\n---\n\n## Complete Data Model\n\n### PageID: Unique Page Identifier\n\n```go\n// page_id.go\n\ntype PageID struct {\n    FileID  int  // Database file identifier (0 for single-file databases)\n    PageNum int  // Page number within the file (1-indexed, page 1 is first)\n}\n\nfunc (p PageID) IsValid() bool {\n    return p.PageNum > 0\n}\n\nfunc (p PageID) String() string {\n    return fmt.Sprintf(\"%d:%d\", p.FileID, p.PageNum)\n}\n\n// WHY PageID exists:\n// - FileID enables multi-file database support (main DB, attached databases)\n// - PageNum is the page's offset in the file (page N is at byte (N-1) * PageSize)\n// - Together they form a globally unique identifier within the database system\n```\n\n### Frame Metadata: Per-Frame Tracking\n\n```go\n// frame.go\n\ntype FrameMetadata struct {\n    PageID     PageID      // Which page occupies this frame (invalid if empty)\n    PinCount   int         // Number of active references (0 = evictable)\n    Dirty      bool        // Has this page been modified since load?\n    LastAccess time.Time   // For LRU eviction ordering\n}\n\n// WHY each field exists:\n// - PageID: Maps frame back to disk page; invalid PageID means frame is empty\n// - PinCount: Prevents use-after-free; B-tree operations increment during page access\n// - Dirty: Enables write-back caching; dirty pages must be flushed before eviction\n// - LastAccess: Drives LRU eviction; updated on every access for accurate ordering\n```\n\n### Page Handle: Safe Access to Page Data\n\n```go\n// page.go\n\ntype Page struct {\n    Data     []byte   // Slice into frame's buffer (do not retain beyond pin!)\n    PageID   PageID   // Identifier of this page\n    frameIdx int      // Index into buffer pool's frames array\n    bp       *BufferPool  // Back-reference for Unpin\n}\n\n// GetData returns the page data slice.\n// WARNING: This slice becomes invalid after the page is unpinned and potentially\n// evicted. Always complete page operations before calling Unpin.\nfunc (p *Page) GetData() []byte {\n    return p.Data\n}\n\n// MarkDirty flags this page as modified, requiring write-back before eviction.\nfunc (p *Page) MarkDirty() {\n    p.bp.markDirty(p.frameIdx)\n}\n\n// Unpin releases this page reference, decrementing the pin count.\n// If isDirty is true, the page is marked dirty before unpinning.\n// Panics if called on a page with zero pin count (double-unpin bug).\nfunc (p *Page) Unpin(isDirty bool) {\n    p.bp.UnpinPage(p.PageID, isDirty)\n}\n\n// WHY Page exists:\n// - Provides controlled access to frame data without exposing frame index\n// - Encapsulates the unpin operation for RAII-style resource management\n// - Documents the lifetime constraint (data valid only while pinned)\n```\n\n### BufferPool: Core Data Structure\n\n```go\n// buffer_pool.go\n\ntype BufferPool struct {\n    // Configuration\n    pageSize   int  // Fixed size per page (default 4096)\n    frameCount int  // Number of frames (default 1000)\n\n    // Frame storage\n    frames   [][]byte         // Actual page data: [frameCount][pageSize]\n    metadata []FrameMetadata  // Per-frame metadata\n\n    // Lookup\n    pageTable map[PageID]int  // page_id -> frame_index for O(1) lookup\n\n    // Disk I/O\n    diskMgr DiskManager\n\n    // Metrics\n    hits       int64  // Cache hits\n    misses     int64  // Cache misses\n    evictions  int64  // Pages evicted\n    writeBacks int64  // Dirty pages written to disk\n\n    // Concurrency (for future enhancement)\n    // mutex sync.RWMutex\n\n    // Transaction coordination\n    txManager *TransactionManager  // Optional: for journal integration\n}\n\n// WHY each field exists:\n// - pageSize/frameCount: Define memory budget (pageSize * frameCount bytes)\n// - frames: Pre-allocated buffers eliminate runtime allocation overhead\n// - metadata: Tracks pin count, dirty flag, and LRU ordering per frame\n// - pageTable: O(1) lookup from PageID to frame; critical for FetchPage performance\n// - diskMgr: Abstraction for disk I/O; enables mocking in tests\n// - metrics: Essential for performance tuning and monitoring\n```\n\n### DiskManager: Storage Abstraction\n\n```go\n// disk_manager.go\n\ntype DiskManager interface {\n    // ReadPage reads pageSize bytes from the specified page into the buffer.\n    // Returns error if page doesn't exist or I/O fails.\n    ReadPage(pageID PageID, buf []byte) error\n\n    // WritePage writes pageSize bytes from the buffer to the specified page.\n    // Returns error if I/O fails.\n    WritePage(pageID PageID, data []byte) error\n\n    // AllocatePage allocates a new page and returns its PageID.\n    // The page is initially zero-filled.\n    AllocatePage() (PageID, error)\n\n    // DeallocatePage marks a page as free for reuse.\n    DeallocatePage(pageID PageID) error\n\n    // Sync flushes all pending writes to durable storage.\n    Sync() error\n\n    // Close releases resources held by the disk manager.\n    Close() error\n}\n\n// FileDiskManager implements DiskManager using os.File\ntype FileDiskManager struct {\n    file     *os.File\n    filePath string\n    pageSize int\n}\n\n// WHY DiskManager interface:\n// - Enables unit testing with mock storage (no actual disk I/O)\n// - Abstracts file vs raw device vs network storage\n// - Separates buffer pool logic from I/O implementation details\n```\n\n---\n\n## Interface Contracts\n\n### Constructor\n\n```go\n// NewBufferPool creates a buffer pool with the specified configuration.\n//\n// Parameters:\n//   - frameCount: Number of page frames (default 1000)\n//   - pageSize: Bytes per page (default 4096)\n//   - diskMgr: Disk manager for I/O operations\n//\n// Pre-conditions:\n//   - frameCount > 0\n//   - pageSize > 0\n//   - diskMgr != nil\n//\n// Post-conditions:\n//   - All frames are allocated and zero-filled\n//   - All frames have invalid PageID (empty state)\n//   - pageTable is empty\n//\n// Returns:\n//   - *BufferPool: Initialized buffer pool\n//   - error: If frameCount or pageSize is invalid\nfunc NewBufferPool(frameCount, pageSize int, diskMgr DiskManager) (*BufferPool, error)\n```\n\n### Core Operations\n\n```go\n// FetchPage retrieves a page from the buffer pool, loading from disk if necessary.\n//\n// This is the primary entry point for page access. The returned Page handle\n// has PinCount = 1; caller must call Unpin when done.\n//\n// Parameters:\n//   - pageID: Identifier of the page to fetch\n//\n// Returns:\n//   - *Page: Handle to the page data (pinned, PinCount = 1)\n//   - error: If page cannot be loaded (disk error, all frames pinned)\n//\n// Post-conditions on success:\n//   - Page is in buffer pool (pageTable has entry)\n//   - Page's PinCount >= 1\n//   - Page's LastAccess is updated to current time\n//   - metrics.hits or metrics.misses is incremented\n//\n// Error conditions:\n//   - All frames are pinned (cannot evict to make room)\n//   - Disk I/O error during page load\n//   - Invalid PageID (PageNum <= 0)\n//\n// Thread safety: Caller must hold appropriate locks (future enhancement)\nfunc (bp *BufferPool) FetchPage(pageID PageID) (*Page, error)\n\n// UnpinPage decrements the pin count for a page.\n//\n// Parameters:\n//   - pageID: Identifier of the page to unpin\n//   - isDirty: If true, marks the page as dirty before unpinning\n//\n// Returns:\n//   - error: If page is not in buffer pool or pin count is already 0\n//\n// Post-conditions:\n//   - PinCount decremented by 1\n//   - If isDirty, Dirty flag set to true\n//   - If PinCount becomes 0, page is eligible for eviction\n//\n// Error conditions:\n//   - Page not in buffer pool\n//   - PinCount already 0 (double-unpin bug)\nfunc (bp *BufferPool) UnpinPage(pageID PageID, isDirty bool) error\n\n// PinPage increments the pin count for an already-loaded page.\n//\n// Use this when you need to extend a page's lifetime without fetching it again.\n//\n// Parameters:\n//   - pageID: Identifier of the page to pin\n//\n// Returns:\n//   - error: If page is not currently in the buffer pool\n//\n// Post-conditions:\n//   - PinCount incremented by 1\n//   - LastAccess updated to current time\nfunc (bp *BufferPool) PinPage(pageID PageID) error\n```\n\n### Flush Operations\n\n```go\n// FlushAll writes all dirty pages to disk.\n//\n// Called at transaction commit boundaries to ensure durability.\n// Does NOT clear the dirty flag for pages that are still pinned.\n//\n// Returns:\n//   - error: If any write operation fails\n//\n// Post-conditions:\n//   - All dirty pages have been written to disk\n//   - Dirty flag cleared for flushed pages\nfunc (bp *BufferPool) FlushAll() error\n\n// FlushPage writes a specific dirty page to disk.\n//\n// Returns:\n//   - error: If write operation fails or page is not in buffer pool\n//\n// Post-conditions:\n//   - If page was dirty, it has been written to disk\n//   - Dirty flag cleared\nfunc (bp *BufferPool) FlushPage(pageID PageID) error\n```\n\n### Metrics\n\n```go\n// Stats returns current performance metrics.\nfunc (bp *BufferPool) Stats() BufferPoolStats\n\ntype BufferPoolStats struct {\n    Hits       int64   // Cache hits\n    Misses     int64   // Cache misses\n    HitRate    float64 // hits / (hits + misses)\n    Evictions  int64   // Pages evicted\n    WriteBacks int64   // Dirty pages written to disk\n    FrameCount int     // Total frames\n    PinnedCount int    // Frames currently pinned\n    DirtyCount int     // Frames marked dirty\n}\n\n// ResetStats clears all accumulated metrics.\nfunc (bp *BufferPool) ResetStats()\n```\n\n---\n\n## Algorithm Specification\n\n### FetchPage: The Core Operation\n\n\n![Buffer Pool Architecture](./diagrams/tdd-diag-13.svg)\n\n\n```\nALGORITHM: FetchPage\nINPUT: BufferPool bp, PageID pageID\nOUTPUT: *Page handle or error\n\n1. VALIDATE INPUT\n   IF pageID.PageNum <= 0:\n     RETURN nil, InvalidPageIDError{PageID: pageID}\n\n2. CHECK CACHE (HIT PATH)\n   frameIdx, exists := bp.pageTable[pageID]\n   IF exists:\n     a. bp.hits++\n     b. meta := &bp.metadata[frameIdx]\n     c. meta.PinCount++\n     d. meta.LastAccess = time.Now()\n     e. RETURN &Page{\n          Data:     bp.frames[frameIdx],\n          PageID:   pageID,\n          frameIdx: frameIdx,\n          bp:       bp,\n        }, nil\n\n3. HANDLE CACHE MISS\n   bp.misses++\n\n4. FIND VICTIM FRAME\n   frameIdx, err := bp.findVictimFrame()\n   IF err != nil:\n     RETURN nil, AllFramesPinnedError{PageID: pageID}\n\n5. EVICT OLD PAGE (if frame occupied)\n   meta := bp.metadata[frameIdx]\n   IF meta.PageID.IsValid():\n     a. IF meta.Dirty:\n        i.   err := bp.diskMgr.WritePage(meta.PageID, bp.frames[frameIdx])\n        ii.  IF err != nil:\n               RETURN nil, DiskIOError{Operation: \"write\", PageID: meta.PageID, Cause: err}\n        iii. bp.writeBacks++\n        iv.  meta.Dirty = false\n     b. delete(bp.pageTable, meta.PageID)\n     c. bp.evictions++\n\n6. LOAD NEW PAGE FROM DISK\n   err := bp.diskMgr.ReadPage(pageID, bp.frames[frameIdx])\n   IF err != nil:\n     RETURN nil, DiskIOError{Operation: \"read\", PageID: pageID, Cause: err}\n\n7. UPDATE METADATA\n   bp.metadata[frameIdx] = FrameMetadata{\n     PageID:     pageID,\n     PinCount:   1,\n     Dirty:      false,\n     LastAccess: time.Now(),\n   }\n\n8. UPDATE PAGE TABLE\n   bp.pageTable[pageID] = frameIdx\n\n9. RETURN PAGE HANDLE\n   RETURN &Page{\n     Data:     bp.frames[frameIdx],\n     PageID:   pageID,\n     frameIdx: frameIdx,\n     bp:       bp,\n   }, nil\n\nPOST-CONDITIONS:\n   - pageID is in pageTable with correct frameIdx\n   - Frame at frameIdx has PinCount >= 1\n   - Frame's LastAccess is current time\n   - If page was loaded from disk, frame contains correct data\n```\n\n### LRU Eviction: Finding a Victim Frame\n\n\n![Frame Metadata Structure](./diagrams/tdd-diag-14.svg)\n\n\n```\nALGORITHM: findVictimFrame\nINPUT: BufferPool bp\nOUTPUT: frame index or error\n\n1. emptyFrameIdx := -1\n   victimIdx := -1\n   oldestAccess := time.Now()\n\n2. SCAN ALL FRAMES\n   FOR i := 0; i < bp.frameCount; i++:\n     meta := &bp.metadata[i]\n\n     a. // Skip pinned pages\n        IF meta.PinCount > 0:\n          CONTINUE\n\n     b. // Found an empty frame - use immediately\n        IF !meta.PageID.IsValid():\n          emptyFrameIdx = i\n          BREAK  // Empty frame is always best choice\n\n     c. // Track least recently used\n        IF meta.LastAccess.Before(oldestAccess):\n          oldestAccess = meta.LastAccess\n          victimIdx = i\n\n3. RETURN RESULT\n   IF emptyFrameIdx >= 0:\n     RETURN emptyFrameIdx, nil\n\n   IF victimIdx >= 0:\n     RETURN victimIdx, nil\n\n   RETURN -1, AllFramesPinnedError{}\n\nCOMPLEXITY: O(frameCount) per eviction\nOPTIMIZATION OPPORTUNITIES:\n   - CLOCK algorithm: O(1) amortized per eviction\n   - LRU-K: Better handling of sequential scans\n   - Separate queues for clean vs dirty pages\n```\n\n### UnpinPage: Releasing a Page Reference\n\n```\nALGORITHM: UnpinPage\nINPUT: BufferPool bp, PageID pageID, bool isDirty\nOUTPUT: error\n\n1. FIND FRAME\n   frameIdx, exists := bp.pageTable[pageID]\n   IF !exists:\n     RETURN PageNotFoundError{PageID: pageID}\n\n2. VALIDATE PIN COUNT\n   meta := &bp.metadata[frameIdx]\n   IF meta.PinCount <= 0:\n     RETURN DoubleUnpinError{PageID: pageID}\n\n3. UPDATE METADATA\n   meta.PinCount--\n   IF isDirty:\n     meta.Dirty = true\n\n4. RETURN SUCCESS\n   RETURN nil\n\nPOST-CONDITIONS:\n   - PinCount decremented by 1\n   - If isDirty, Dirty flag is true\n   - If PinCount is now 0, page is eligible for eviction\n```\n\n### FlushAll: Writing Dirty Pages to Disk\n\n```\nALGORITHM: FlushAll\nINPUT: BufferPool bp\nOUTPUT: error\n\n1. FOR each pageID, frameIdx in bp.pageTable:\n     meta := bp.metadata[frameIdx]\n\n     a. IF meta.Dirty:\n        i.   err := bp.diskMgr.WritePage(pageID, bp.frames[frameIdx])\n        ii.  IF err != nil:\n               RETURN DiskIOError{Operation: \"write\", PageID: pageID, Cause: err}\n        iii. meta.Dirty = false\n        iv.  bp.writeBacks++\n\n2. RETURN nil\n\nPOST-CONDITIONS:\n   - All dirty pages have been written to disk\n   - Dirty flags are cleared\n   - Pages remain in buffer pool (not evicted)\n```\n\n### Pin/Unpin Pattern for B-tree Operations\n\n```\nPATTERN: Safe Page Access in B-tree Operations\n\nfunc (btree *BTree) Insert(key, value []byte) error {\n    // 1. Fetch the target page\n    page, err := btree.bufferPool.FetchPage(btree.rootPageID)\n    if err != nil {\n        return err\n    }\n    // Page is now pinned (PinCount = 1)\n\n    // 2. Perform operations on the page\n    // ... read/write page.Data ...\n    \n    // 3. Mark dirty if modified\n    page.MarkDirty()\n\n    // 4. Unpin when done (allows eviction)\n    page.Unpin(true)  // true = page was modified\n\n    return nil\n}\n\nINVARIANT: Between FetchPage and Unpin, the page's frame will not be evicted.\nVIOLATION CONSEQUENCE: Use-after-free, data corruption, crashes.\n```\n\n---\n\n## Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n|-------|-------------|----------|---------------|\n| Invalid PageID (PageNum <= 0) | `FetchPage` validation | Return error immediately | Yes: \"invalid page ID: {pageID}\" |\n| Page not in buffer pool | `UnpinPage` lookup | Return error immediately | Yes: \"page not found: {pageID}\" |\n| Double unpin (PinCount already 0) | `UnpinPage` validation | Return error immediately | Yes: \"double unpin detected for page {pageID}\" |\n| All frames pinned | `findVictimFrame` | Return error, cannot load page | Yes: \"buffer pool exhausted: all frames pinned\" |\n| Disk read error | `FetchPage` during load | Return error, frame remains empty | Yes: \"disk read error for page {pageID}: {cause}\" |\n| Disk write error | `FlushAll`, eviction | Return error, page remains dirty | Yes: \"disk write error for page {pageID}: {cause}\" |\n| Disk sync error | `FlushAll` finalization | Return error | Yes: \"failed to sync disk: {cause}\" |\n\n---\n\n## Implementation Sequence with Checkpoints\n\n### Phase 1: BufferPool Structure and Frame Allocation (1.5 hours)\n\n**Files to create**: `buffer_pool.go`, `frame.go`, `page_id.go`, `page.go`, `errors.go`\n\n**Implementation**:\n1. Define `PageID` type with validation\n2. Define `FrameMetadata` struct\n3. Define `Page` handle struct with methods\n4. Define error types: `InvalidPageIDError`, `PageNotFoundError`, etc.\n5. Implement `NewBufferPool` constructor with frame allocation\n6. Initialize all frames with invalid PageID (empty state)\n\n**Checkpoint**: At this point you should be able to create a buffer pool and verify frame allocation. Run:\n```bash\ngo test -run TestNewBufferPool\n# Expected: PASS (frames allocated, metadata initialized)\n```\n\n### Phase 2: FetchPage with Hit/Miss Logic (2 hours)\n\n**Files to create**: `disk_manager.go` (interface + mock)\n\n**Implementation**:\n1. Define `DiskManager` interface\n2. Implement `MockDiskManager` for testing\n3. Implement `FetchPage` cache-hit path (page already in pool)\n4. Implement `FetchPage` cache-miss path (load from disk)\n5. Update `pageTable` on successful load\n6. Increment hits/misses metrics\n\n**Checkpoint**: At this point you should be able to fetch pages with hit/miss tracking. Run:\n```bash\ngo test -run TestFetchPage\n# Expected: PASS (hit on second fetch, miss on first)\n```\n\n### Phase 3: LRU Eviction Algorithm (1.5 hours)\n\n**Files to create**: `eviction.go`\n\n**Implementation**:\n1. Implement `findVictimFrame` with LRU scan\n2. Handle empty frames (prefer over eviction)\n3. Skip pinned pages during scan\n4. Implement eviction logic: write dirty page, update pageTable\n5. Increment evictions/writeBacks metrics\n\n**Checkpoint**: At this point you should be able to evict pages when pool is full. Run:\n```bash\ngo test -run TestEviction\n# Expected: PASS (LRU page evicted, dirty page written back)\n```\n\n### Phase 4: Pin/Unpin and Dirty Page Tracking (1.5 hours)\n\n**Files to update**: `buffer_pool.go`, `page.go`\n\n**Implementation**:\n1. Implement `UnpinPage` with pin count decrement\n2. Implement `PinPage` for re-pinning loaded pages\n3. Implement `Page.MarkDirty()` method\n4. Detect double-unpin errors\n5. Update `LastAccess` on pin operations\n\n**Checkpoint**: At this point you should pass pin/unpin tests. Run:\n```bash\ngo test -run TestPinUnpin\n# Expected: PASS (pin prevents eviction, unpin allows it)\n```\n\n### Phase 5: FlushAll and FlushPage (1.5 hours)\n\n**Files to create**: `flush.go`, `stats.go`\n\n**Implementation**:\n1. Implement `FlushAll` to write all dirty pages\n2. Implement `FlushPage` for single-page flush\n3. Clear dirty flag after successful write\n4. Implement `Stats()` for metrics access\n5. Implement `ResetStats()` for testing\n\n**Checkpoint**: At this point you should pass the full test suite. Run:\n```bash\ngo test -v ./bufferpool\n# Expected: All tests PASS\n# Verify: 95%+ hit rate on typical workload test\n# Verify: Cache hit completes in < 100ns (microbenchmark)\n```\n\n---\n\n## Test Specification\n\n### Test Categories\n\n```go\n// buffer_pool_test.go\n\nfunc TestNewBufferPool(t *testing.T) {\n    diskMgr := NewMockDiskManager(4096)\n    \n    bp, err := NewBufferPool(100, 4096, diskMgr)\n    assert.NoError(t, err)\n    assert.Equal(t, 100, bp.frameCount)\n    assert.Equal(t, 4096, bp.pageSize)\n    assert.Len(t, bp.frames, 100)\n    assert.Len(t, bp.metadata, 100)\n    \n    // Verify all frames are initially empty\n    for _, meta := range bp.metadata {\n        assert.False(t, meta.PageID.IsValid())\n        assert.Equal(t, 0, meta.PinCount)\n        assert.False(t, meta.Dirty)\n    }\n}\n\nfunc TestFetchPageHit(t *testing.T) {\n    diskMgr := NewMockDiskManager(4096)\n    diskMgr.SetPage(PageID{PageNum: 1}, makePageData(1))\n    \n    bp, _ := NewBufferPool(10, 4096, diskMgr)\n    \n    // First fetch: miss\n    page1, err := bp.FetchPage(PageID{PageNum: 1})\n    assert.NoError(t, err)\n    assert.Equal(t, int64(1), bp.misses)\n    assert.Equal(t, int64(0), bp.hits)\n    page1.Unpin(false)\n    \n    // Second fetch: hit\n    page2, err := bp.FetchPage(PageID{PageNum: 1})\n    assert.NoError(t, err)\n    assert.Equal(t, int64(1), bp.misses)\n    assert.Equal(t, int64(1), bp.hits)\n    \n    // Same frame should be used\n    assert.Equal(t, page1.frameIdx, page2.frameIdx)\n    page2.Unpin(false)\n}\n\nfunc TestFetchPageMiss(t *testing.T) {\n    diskMgr := NewMockDiskManager(4096)\n    diskMgr.SetPage(PageID{PageNum: 5}, makePageData(5))\n    \n    bp, _ := NewBufferPool(10, 4096, diskMgr)\n    \n    page, err := bp.FetchPage(PageID{PageNum: 5})\n    assert.NoError(t, err)\n    assert.NotNil(t, page)\n    assert.Equal(t, PageID{PageNum: 5}, page.PageID)\n    assert.Equal(t, int64(1), bp.misses)\n    \n    // Verify page data was loaded\n    assert.Equal(t, makePageData(5), page.Data)\n}\n\nfunc TestLRUEviction(t *testing.T) {\n    diskMgr := NewMockDiskManager(4096)\n    for i := 1; i <= 5; i++ {\n        diskMgr.SetPage(PageID{PageNum: i}, makePageData(i))\n    }\n    \n    bp, _ := NewBufferPool(3, 4096, diskMgr)  // Only 3 frames\n    \n    // Load pages 1, 2, 3\n    p1, _ := bp.FetchPage(PageID{PageNum: 1})\n    p2, _ := bp.FetchPage(PageID{PageNum: 2})\n    p3, _ := bp.FetchPage(PageID{PageNum: 3})\n    \n    // Unpin all\n    p1.Unpin(false)\n    p2.Unpin(false)\n    p3.Unpin(false)\n    \n    // Access page 1 to make it recently used\n    time.Sleep(1 * time.Millisecond)\n    p1Again, _ := bp.FetchPage(PageID{PageNum: 1})\n    p1Again.Unpin(false)\n    \n    // Load page 4 - should evict page 2 (LRU)\n    p4, err := bp.FetchPage(PageID{PageNum: 4})\n    assert.NoError(t, err)\n    p4.Unpin(false)\n    \n    // Page 1 should still be in memory\n    _, exists := bp.pageTable[PageID{PageNum: 1}]\n    assert.True(t, exists)\n    \n    // Page 2 should have been evicted\n    _, exists = bp.pageTable[PageID{PageNum: 2}]\n    assert.False(t, exists)\n    \n    assert.Equal(t, int64(1), bp.evictions)\n}\n\nfunc TestPinPreventsEviction(t *testing.T) {\n    diskMgr := NewMockDiskManager(4096)\n    for i := 1; i <= 5; i++ {\n        diskMgr.SetPage(PageID{PageNum: i}, makePageData(i))\n    }\n    \n    bp, _ := NewBufferPool(3, 4096, diskMgr)\n    \n    // Load and pin pages 1, 2, 3\n    p1, _ := bp.FetchPage(PageID{PageNum: 1})\n    p2, _ := bp.FetchPage(PageID{PageNum: 2})\n    p3, _ := bp.FetchPage(PageID{PageNum: 3})\n    // All still pinned (PinCount = 1)\n    \n    // Try to load page 4 - should fail (all frames pinned)\n    _, err := bp.FetchPage(PageID{PageNum: 4})\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"all frames pinned\")\n    \n    // Unpin page 2\n    p2.Unpin(false)\n    \n    // Now page 4 should load (evicts page 2)\n    p4, err := bp.FetchPage(PageID{PageNum: 4})\n    assert.NoError(t, err)\n    p4.Unpin(false)\n    \n    p1.Unpin(false)\n    p3.Unpin(false)\n}\n\nfunc TestDirtyPageWriteback(t *testing.T) {\n    diskMgr := NewMockDiskManager(4096)\n    diskMgr.SetPage(PageID{PageNum: 1}, make([]byte, 4096))\n    \n    bp, _ := NewBufferPool(10, 4096, diskMgr)\n    \n    // Load page\n    page, _ := bp.FetchPage(PageID{PageNum: 1})\n    \n    // Modify page\n    page.Data[0] = 0x42\n    page.MarkDirty()\n    page.Unpin(true)\n    \n    // Verify dirty flag is set\n    frameIdx := bp.pageTable[PageID{PageNum: 1}]\n    assert.True(t, bp.metadata[frameIdx].Dirty)\n    \n    // Flush to disk\n    err := bp.FlushAll()\n    assert.NoError(t, err)\n    \n    // Verify dirty flag cleared\n    assert.False(t, bp.metadata[frameIdx].Dirty)\n    \n    // Verify data was written to disk\n    diskData, _ := diskMgr.GetPage(PageID{PageNum: 1})\n    assert.Equal(t, byte(0x42), diskData[0])\n}\n\nfunc TestFlushAll(t *testing.T) {\n    diskMgr := NewMockDiskManager(4096)\n    \n    bp, _ := NewBufferPool(10, 4096, diskMgr)\n    \n    // Create and dirty multiple pages\n    for i := 1; i <= 3; i++ {\n        diskMgr.SetPage(PageID{PageNum: i}, make([]byte, 4096))\n        page, _ := bp.FetchPage(PageID{PageNum: i})\n        page.Data[0] = byte(i)\n        page.MarkDirty()\n        page.Unpin(true)\n    }\n    \n    // Flush all\n    err := bp.FlushAll()\n    assert.NoError(t, err)\n    \n    // Verify all pages written\n    for i := 1; i <= 3; i++ {\n        data, _ := diskMgr.GetPage(PageID{PageNum: i})\n        assert.Equal(t, byte(i), data[0])\n    }\n    \n    assert.Equal(t, int64(3), bp.writeBacks)\n}\n\nfunc TestDoubleUnpinError(t *testing.T) {\n    diskMgr := NewMockDiskManager(4096)\n    diskMgr.SetPage(PageID{PageNum: 1}, make([]byte, 4096))\n    \n    bp, _ := NewBufferPool(10, 4096, diskMgr)\n    \n    page, _ := bp.FetchPage(PageID{PageNum: 1})\n    page.Unpin(false)\n    \n    // Second unpin should fail\n    err := bp.UnpinPage(PageID{PageNum: 1}, false)\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"double unpin\")\n}\n\nfunc TestStats(t *testing.T) {\n    diskMgr := NewMockDiskManager(4096)\n    diskMgr.SetPage(PageID{PageNum: 1}, make([]byte, 4096))\n    diskMgr.SetPage(PageID{PageNum: 2}, make([]byte, 4096))\n    \n    bp, _ := NewBufferPool(10, 4096, diskMgr)\n    \n    // Generate some activity\n    p1, _ := bp.FetchPage(PageID{PageNum: 1})  // miss\n    p1.Unpin(false)\n    p1Again, _ := bp.FetchPage(PageID{PageNum: 1})  // hit\n    p1Again.Unpin(false)\n    p2, _ := bp.FetchPage(PageID{PageNum: 2})  // miss\n    p2.Unpin(false)\n    \n    stats := bp.Stats()\n    assert.Equal(t, int64(2), stats.Misses)\n    assert.Equal(t, int64(1), stats.Hits)\n    assert.Equal(t, 1.0/3.0, stats.HitRate)  // 1 hit / 3 total\n}\n\nfunc TestHitRateMetric(t *testing.T) {\n    diskMgr := NewMockDiskManager(4096)\n    for i := 1; i <= 100; i++ {\n        diskMgr.SetPage(PageID{PageNum: i}, make([]byte, 4096))\n    }\n    \n    bp, _ := NewBufferPool(50, 4096, diskMgr)\n    \n    // Simulate typical workload: 95% accesses to hot pages\n    hotPages := []int{1, 2, 3, 4, 5}\n    coldPages := makeRange(6, 100)\n    \n    for i := 0; i < 1000; i++ {\n        var pageNum int\n        if i%20 == 0 {  // 5% cold access\n            pageNum = coldPages[i%len(coldPages)]\n        } else {  // 95% hot access\n            pageNum = hotPages[i%len(hotPages)]\n        }\n        \n        page, _ := bp.FetchPage(PageID{PageNum: pageNum})\n        page.Unpin(false)\n    }\n    \n    stats := bp.Stats()\n    assert.GreaterOrEqual(t, stats.HitRate, 0.95, \n        \"Expected 95%+ hit rate on typical workload\")\n}\n\nfunc TestPerformanceCacheHit(t *testing.T) {\n    if testing.Short() {\n        t.Skip(\"Skipping performance test\")\n    }\n    \n    diskMgr := NewMockDiskManager(4096)\n    diskMgr.SetPage(PageID{PageNum: 1}, make([]byte, 4096))\n    \n    bp, _ := NewBufferPool(1000, 4096, diskMgr)\n    \n    // Warm up: load the page\n    p, _ := bp.FetchPage(PageID{PageNum: 1})\n    p.Unpin(false)\n    \n    // Benchmark cache hits\n    start := time.Now()\n    for i := 0; i < 100000; i++ {\n        page, _ := bp.FetchPage(PageID{PageNum: 1})\n        page.Unpin(false)\n    }\n    elapsed := time.Since(start)\n    \n    avgHitTime := elapsed / 100000\n    assert.Less(t, avgHitTime.Nanoseconds(), int64(100), \n        \"Cache hit should complete in < 100ns\")\n}\n```\n\n---\n\n## Performance Targets\n\n| Operation | Target | How to Measure |\n|-----------|--------|----------------|\n| Cache hit (FetchPage on loaded page) | < 100ns | `go test -bench=BenchmarkCacheHit` |\n| Cache miss (FetchPage from disk) | < 100μs (SSD) | `go test -bench=BenchmarkCacheMiss` |\n| LRU eviction scan | O(frameCount) | Code review; no N² patterns |\n| FlushAll | O(dirty pages) | `go test -bench=BenchmarkFlushAll` |\n| Hit rate on typical workload | 95%+ | `go test -run TestHitRateMetric` |\n| Memory overhead | pageSize × frameCount + O(frameCount) | Verify no per-page allocations |\n\n---\n\n## Synced Criteria\n\n[[CRITERIA_JSON: {\"module_id\": \"build-sqlite-m4\", \"criteria\": [\"Buffer pool initializes with a fixed number of 4096-byte frames\", \"FetchPage returns the correct page from memory if already loaded (hit)\", \"FetchPage loads page from disk if not in memory (miss)\", \"LRU algorithm correctly identifies the least recently used page for eviction\", \"Pinned pages (count > 0) are never selected for eviction\", \"Dirty pages are written back to disk only when evicted or on FlushAll\", \"Buffer pool hit rate is tracked and accessible for performance metrics\"]}]\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-sqlite-m5 -->\n# Technical Design Specification: B-tree Page Format & Table Storage\n\n## Module Charter\n\nThe B-tree Page Format implements the on-disk storage layer for tables and indexes using a slotted page architecture with four page types: table leaf (row storage keyed by rowid), table internal (separator keys and child pointers), index leaf (indexed value + rowid pairs), and index internal (separator keys and child pointers). The module provides varint encoding for compact record representation, serial type-based field encoding, cell pointer arrays for sorted access without data shifting, node splitting with separator promotion for tree maintenance, and a system catalog (sqlite_master) for schema persistence. It does NOT manage memory caching (delegates to BufferPool), execute queries (delegates to VM), or handle transaction semantics (delegates to TransactionManager). Upstream dependencies: Bytecode VM (receives row operations), Buffer Pool (reads/writes pages). Downstream dependencies: Disk via BufferPool. Invariants: page size is fixed at 4096 bytes; all multi-byte integers are big-endian; cell pointers are sorted by key within each page; every page has a valid type byte in header; B-tree invariant (balanced, ordered) holds after every operation.\n\n---\n\n## File Structure\n\n```\nstorage/\n├── page.go             # (1) Page struct, header, slotted format accessors\n├── page_type.go        # (2) Page type constants and validation\n├── cell.go             # (3) Cell pointer array, cell allocation\n├── varint.go           # (4) Variable-length integer encoding/decoding\n├── serial_type.go      # (5) Serial type definitions and value encoding\n├── record.go           # (6) Row serialization to/from record format\n├── btree.go            # (7) BTree struct with root, insert, delete, scan\n├── btree_cursor.go     # (8) Cursor for tree traversal\n├── table_leaf.go       # (9) Table B-tree leaf operations\n├── table_internal.go   # (10) Table B-tree internal page operations\n├── index_leaf.go       # (11) Index B+tree leaf operations\n├── index_internal.go   # (12) Index B+tree internal page operations\n├── split.go            # (13) Node splitting and separator promotion\n├── catalog.go          # (14) System catalog (sqlite_master)\n├── freeblock.go        # (15) Free space management within pages\n└── storage_test.go     # (16) Comprehensive test suite\n```\n\n---\n\n## Complete Data Model\n\n### Page Types\n\n```go\n// page_type.go\n\ntype PageType uint8\n\nconst (\n    PageTypeInvalid      PageType = 0x00\n    PageTypeIndexLeaf    PageType = 0x0A  // Index B+tree leaf: (key, rowid) pairs\n    PageTypeIndexInt     PageType = 0x02  // Index B+tree internal: separators + children\n    PageTypeTableLeaf    PageType = 0x0D  // Table B-tree leaf: full records keyed by rowid\n    PageTypeTableInt     PageType = 0x05  // Table B-tree internal: rowid separators + children\n)\n\nfunc (pt PageType) IsValid() bool {\n    return pt == PageTypeIndexLeaf || pt == PageTypeIndexInt ||\n           pt == PageTypeTableLeaf || pt == PageTypeTableInt\n}\n\nfunc (pt PageType) IsLeaf() bool {\n    return pt == PageTypeTableLeaf || pt == PageTypeIndexLeaf\n}\n\nfunc (pt PageType) IsTable() bool {\n    return pt == PageTypeTableLeaf || pt == PageTypeTableInt\n}\n\nfunc (pt PageType) String() string {\n    switch pt {\n    case PageTypeIndexLeaf: return \"IndexLeaf\"\n    case PageTypeIndexInt: return \"IndexInternal\"\n    case PageTypeTableLeaf: return \"TableLeaf\"\n    case PageTypeTableInt: return \"TableInternal\"\n    default: return \"Invalid\"\n    }\n}\n\n// WHY four page types:\n// - Table vs Index: Different cell content (full record vs key+rowid)\n// - Leaf vs Internal: Different cell format (data vs separator+child)\n// - Index B+trees have linked leaves; Table B-trees do not\n```\n\n### Page Header Format\n\n\n![Slotted Page Layout](./diagrams/tdd-diag-17.svg)\n\n\n```go\n// page.go\n\nconst (\n    PageSize         = 4096\n    PageHeaderSize   = 8   // Leaf pages: 8 bytes\n    PageHeaderSizeInt = 12  // Internal pages: 12 bytes (includes rightmost pointer)\n)\n\ntype PageHeader struct {\n    Type             PageType  // 1 byte: page type identifier\n    FirstFreeblock   uint16    // 2 bytes: offset to first freeblock (0 if none)\n    CellCount        uint16    // 2 bytes: number of cells on this page\n    CellContentStart uint16    // 2 bytes: offset to start of cell content area\n    FragmentedBytes  uint8     // 1 byte: number of fragmented free bytes\n    RightMostPointer uint32    // 4 bytes: rightmost child page (internal pages only)\n}\n\n// Byte layout for leaf pages (8 bytes):\n// Offset 0: PageType (1 byte)\n// Offset 1-2: FirstFreeblock (2 bytes, big-endian)\n// Offset 3-4: CellCount (2 bytes, big-endian)\n// Offset 5-6: CellContentStart (2 bytes, big-endian)\n// Offset 7: FragmentedBytes (1 byte)\n\n// Byte layout for internal pages (12 bytes):\n// Same as leaf, plus:\n// Offset 8-11: RightMostPointer (4 bytes, big-endian)\n\n// WHY each field:\n// - Type: Dispatches to correct cell parser/handler\n// - FirstFreeblock: Enables free space reuse within page\n// - CellCount: Bounds the cell pointer array\n// - CellContentStart: Marks boundary between pointers and content\n// - FragmentedBytes: Tracks small gaps that may need coalescing\n// - RightMostPointer: Child for keys greater than all separators\n```\n\n### Page Structure: Slotted Format\n\n```go\n// page.go\n\ntype Page struct {\n    data     []byte      // Exactly PageSize bytes\n    pageID   PageID      // Identifier for this page\n    isDirty  bool        // Has been modified\n}\n\n// Layout visualization:\n// ┌─────────────────────────────────────────────────────────────────┐\n// │ Header (8/12 bytes)                                             │\n// ├─────────────────────────────────────────────────────────────────┤\n// │ Cell Pointer Array (2 bytes each, grows →)                      │\n// │ [ptr0][ptr1][ptr2]...                                           │\n// ├─────────────────────────────────────────────────────────────────┤\n// │ Free Space                                                      │\n// │                                                                 │\n// ├─────────────────────────────────────────────────────────────────┤\n// │ Cell Content Area (grows ←)                                     │\n// │ ...[cell2][cell1][cell0]                                        │\n// └─────────────────────────────────────────────────────────────────┘\n\nfunc (p *Page) headerSize() int {\n    if p.Type().IsLeaf() {\n        return PageHeaderSize\n    }\n    return PageHeaderSizeInt\n}\n\n// Header accessors\nfunc (p *Page) Type() PageType {\n    return PageType(p.data[0])\n}\n\nfunc (p *Page) SetType(pt PageType) {\n    p.data[0] = byte(pt)\n    p.isDirty = true\n}\n\nfunc (p *Page) FirstFreeblock() uint16 {\n    return binary.BigEndian.Uint16(p.data[1:3])\n}\n\nfunc (p *Page) SetFirstFreeblock(offset uint16) {\n    binary.BigEndian.PutUint16(p.data[1:3], offset)\n    p.isDirty = true\n}\n\nfunc (p *Page) CellCount() uint16 {\n    return binary.BigEndian.Uint16(p.data[3:5])\n}\n\nfunc (p *Page) SetCellCount(count uint16) {\n    binary.BigEndian.PutUint16(p.data[3:5], count)\n    p.isDirty = true\n}\n\nfunc (p *Page) CellContentStart() uint16 {\n    val := binary.BigEndian.Uint16(p.data[5:7])\n    if val == 0 {\n        return PageSize // 0 means content starts at page end\n    }\n    return val\n}\n\nfunc (p *Page) SetCellContentStart(offset uint16) {\n    binary.BigEndian.PutUint16(p.data[5:7], offset)\n    p.isDirty = true\n}\n\nfunc (p *Page) FragmentedBytes() uint8 {\n    return p.data[7]\n}\n\nfunc (p *Page) SetFragmentedBytes(count uint8) {\n    p.data[7] = count\n    p.isDirty = true\n}\n\nfunc (p *Page) RightMostPointer() uint32 {\n    if p.Type().IsLeaf() {\n        return 0\n    }\n    return binary.BigEndian.Uint32(p.data[8:12])\n}\n\nfunc (p *Page) SetRightMostPointer(pageNum uint32) {\n    if !p.Type().IsLeaf() {\n        binary.BigEndian.PutUint32(p.data[8:12], pageNum)\n        p.isDirty = true\n    }\n}\n```\n\n### Cell Pointer Array\n\n```go\n// cell.go\n\nconst CellPointerSize = 2 // Each pointer is 2 bytes\n\n// CellPointer returns the offset of the cell at the given index.\n// Index must be < CellCount().\nfunc (p *Page) CellPointer(index int) uint16 {\n    if index < 0 || index >= int(p.CellCount()) {\n        panic(fmt.Sprintf(\"cell index out of bounds: %d (count=%d)\", index, p.CellCount()))\n    }\n    offset := p.headerSize() + index*CellPointerSize\n    return binary.BigEndian.Uint16(p.data[offset : offset+2])\n}\n\n// SetCellPointer sets the cell pointer at the given index.\nfunc (p *Page) SetCellPointer(index int, ptr uint16) {\n    offset := p.headerSize() + index*CellPointerSize\n    binary.BigEndian.PutUint16(p.data[offset:offset+2], ptr)\n    p.isDirty = true\n}\n\n// FreeSpace calculates available bytes between pointer array and content area.\nfunc (p *Page) FreeSpace() int {\n    headerEnd := p.headerSize()\n    pointerArrayEnd := headerEnd + int(p.CellCount())*CellPointerSize\n    contentStart := int(p.CellContentStart())\n    \n    if contentStart == PageSize {\n        // Page is empty, content would start at end\n        return PageSize - pointerArrayEnd\n    }\n    \n    return contentStart - pointerArrayEnd\n}\n\n// WHY cell pointer array:\n// - Enables sorted access (pointers are ordered by key)\n// - Avoids shifting cell content on insert/delete\n// - Cell content can be appended without sorting\n// - Only 2-byte pointers move, not potentially large cells\n```\n\n### Varint Encoding\n\n\n![Page Header Fields](./diagrams/tdd-diag-18.svg)\n\n\n```go\n// varint.go\n\n// ReadVarint reads a variable-length integer from data at offset.\n// Returns (value, bytesRead).\n// \n// SQLite varint format (1-9 bytes):\n// - 1 byte:  0xxxxxxx                              (0 to 127)\n// - 2 bytes: 10xxxxxx xxxxxxxx                     (128 to 16383)\n// - 3 bytes: 110xxxxx xxxxxxxx xxxxxxxx            (16384 to 2097151)\n// - 4 bytes: 1110xxxx xxxxxxxx xxxxxxxx xxxxxxxx   (2097152 to 268435455)\n// - 5-8 bytes: Similar pattern with more leading 1s\n// - 9 bytes: 11111111 followed by 8-byte big-endian integer\n//\n// Maximum value: 2^64 - 1\nfunc ReadVarint(data []byte, offset int) (value int64, bytesRead int) {\n    if offset >= len(data) {\n        return 0, 0\n    }\n    \n    b := data[offset]\n    \n    // Single byte case (0xxxxxxx)\n    if b < 0x80 {\n        return int64(b), 1\n    }\n    \n    // Determine length from leading 1 bits\n    var result int64\n    var length int\n    \n    switch {\n    case b < 0xC0: // 10xxxxxx\n        result = int64(b & 0x3F)\n        length = 2\n    case b < 0xE0: // 110xxxxx\n        result = int64(b & 0x1F)\n        length = 3\n    case b < 0xF0: // 1110xxxx\n        result = int64(b & 0x0F)\n        length = 4\n    case b < 0xF8: // 11110xxx\n        result = int64(b & 0x07)\n        length = 5\n    case b < 0xFC: // 111110xx\n        result = int64(b & 0x03)\n        length = 6\n    case b < 0xFE: // 1111110x\n        result = int64(b & 0x01)\n        length = 7\n    case b == 0xFE: // 11111110\n        length = 8\n    default: // 11111111\n        if offset+9 > len(data) {\n            return 0, 0\n        }\n        // 9-byte encoding: full 8-byte big-endian integer\n        value := int64(binary.BigEndian.Uint64(data[offset+1 : offset+9]))\n        return value, 9\n    }\n    \n    // Read continuation bytes\n    for i := 1; i < length; i++ {\n        if offset+i >= len(data) {\n            return 0, 0\n        }\n        result = (result << 8) | int64(data[offset+i])\n    }\n    \n    return result, length\n}\n\n// WriteVarint encodes a value as a varint and returns the bytes.\nfunc WriteVarint(value int64) []byte {\n    // Handle 9-byte case for negative or very large values\n    if value < 0 || value > 0xFFFFFFFFFFFFFF {\n        buf := make([]byte, 9)\n        buf[0] = 0xFF\n        binary.BigEndian.PutUint64(buf[1:9], uint64(value))\n        return buf\n    }\n    \n    // 1-byte case\n    if value < 0x80 {\n        return []byte{byte(value)}\n    }\n    \n    // 2-byte case\n    if value < 0x4000 {\n        return []byte{\n            byte((value >> 8) | 0x80),\n            byte(value),\n        }\n    }\n    \n    // 3-byte case\n    if value < 0x200000 {\n        return []byte{\n            byte((value >> 16) | 0xC0),\n            byte(value >> 8),\n            byte(value),\n        }\n    }\n    \n    // 4-byte case\n    if value < 0x10000000 {\n        return []byte{\n            byte((value >> 24) | 0xE0),\n            byte(value >> 16),\n            byte(value >> 8),\n            byte(value),\n        }\n    }\n    \n    // 5-8 byte cases follow similar pattern\n    // ... (implementation continues for larger values)\n    \n    // Fall back to 9-byte for simplicity in remaining cases\n    buf := make([]byte, 9)\n    buf[0] = 0xFF\n    binary.BigEndian.PutUint64(buf[1:9], uint64(value))\n    return buf\n}\n\n// VarintSize returns the number of bytes needed to encode value.\nfunc VarintSize(value int64) int {\n    if value < 0 {\n        return 9\n    }\n    if value < 0x80 {\n        return 1\n    }\n    if value < 0x4000 {\n        return 2\n    }\n    if value < 0x200000 {\n        return 3\n    }\n    if value < 0x10000000 {\n        return 4\n    }\n    if value < 0x0800000000 {\n        return 5\n    }\n    if value < 0x040000000000 {\n        return 6\n    }\n    if value < 0x02000000000000 {\n        return 7\n    }\n    if value < 0x0100000000000000 {\n        return 8\n    }\n    return 9\n}\n```\n\n### Serial Types\n\n```go\n// serial_type.go\n\ntype SerialType int64\n\nconst (\n    SerialTypeNull SerialType = iota\n    SerialTypeInt8            // 1-byte signed integer\n    SerialTypeInt16           // 2-byte big-endian signed integer\n    SerialTypeInt24           // 3-byte big-endian signed integer\n    SerialTypeInt32           // 4-byte big-endian signed integer\n    SerialTypeInt48           // 6-byte big-endian signed integer\n    SerialTypeInt64           // 8-byte big-endian signed integer\n    SerialTypeFloat           // 8-byte IEEE 754 float\n    SerialTypeZero            // Integer constant 0 (0 bytes)\n    SerialTypeOne             // Integer constant 1 (0 bytes)\n    // 10, 11: Reserved for internal use\n    // N >= 12, even: BLOB of (N-12)/2 bytes\n    // N >= 13, odd: TEXT of (N-13)/2 bytes\n)\n\n// SerialTypeSize returns the data size for a serial type.\nfunc SerialTypeSize(st SerialType) int {\n    switch st {\n    case SerialTypeNull, SerialTypeZero, SerialTypeOne:\n        return 0\n    case SerialTypeInt8:\n        return 1\n    case SerialTypeInt16:\n        return 2\n    case SerialTypeInt24:\n        return 3\n    case SerialTypeInt32:\n        return 4\n    case SerialTypeInt48:\n        return 6\n    case SerialTypeInt64, SerialTypeFloat:\n        return 8\n    default:\n        if st >= 12 && st%2 == 0 {\n            return int((st - 12) / 2) // BLOB\n        }\n        if st >= 13 {\n            return int((st - 13) / 2) // TEXT\n        }\n        return 0\n    }\n}\n\n// EncodeSerialType determines the serial type for a Go value.\nfunc EncodeSerialType(value interface{}) (SerialType, []byte) {\n    switch v := value.(type) {\n    case nil:\n        return SerialTypeNull, nil\n    \n    case int:\n        return EncodeSerialType(int64(v))\n    \n    case int64:\n        if v == 0 {\n            return SerialTypeZero, nil\n        }\n        if v == 1 {\n            return SerialTypeOne, nil\n        }\n        if v >= -128 && v <= 127 {\n            return SerialTypeInt8, []byte{byte(v)}\n        }\n        if v >= -32768 && v <= 32767 {\n            buf := make([]byte, 2)\n            binary.BigEndian.PutUint16(buf, uint16(int16(v)))\n            return SerialTypeInt16, buf\n        }\n        if v >= -8388608 && v <= 8388607 {\n            buf := make([]byte, 3)\n            buf[0] = byte(v >> 16)\n            buf[1] = byte(v >> 8)\n            buf[2] = byte(v)\n            return SerialTypeInt24, buf\n        }\n        if v >= -2147483648 && v <= 2147483647 {\n            buf := make([]byte, 4)\n            binary.BigEndian.PutUint32(buf, uint32(int32(v)))\n            return SerialTypeInt32, buf\n        }\n        if v >= -140737488355328 && v <= 140737488355327 {\n            buf := make([]byte, 6)\n            binary.BigEndian.PutUint32(buf[0:4], uint32(v>>16))\n            binary.BigEndian.PutUint16(buf[4:6], uint16(v))\n            return SerialTypeInt48, buf\n        }\n        buf := make([]byte, 8)\n        binary.BigEndian.PutUint64(buf, uint64(v))\n        return SerialTypeInt64, buf\n    \n    case float64:\n        buf := make([]byte, 8)\n        binary.BigEndian.PutUint64(buf, math.Float64bits(v))\n        return SerialTypeFloat, buf\n    \n    case string:\n        length := len(v)\n        st := SerialType(length*2 + 13)\n        return st, []byte(v)\n    \n    case []byte:\n        length := len(v)\n        st := SerialType(length*2 + 12)\n        return st, v\n    \n    default:\n        panic(fmt.Sprintf(\"unsupported type: %T\", value))\n    }\n}\n\n// DecodeValue decodes a value given its serial type and data.\nfunc DecodeValue(st SerialType, data []byte) (interface{}, error) {\n    switch st {\n    case SerialTypeNull:\n        return nil, nil\n    \n    case SerialTypeZero:\n        return int64(0), nil\n    \n    case SerialTypeOne:\n        return int64(1), nil\n    \n    case SerialTypeInt8:\n        return int64(int8(data[0])), nil\n    \n    case SerialTypeInt16:\n        return int64(int16(binary.BigEndian.Uint16(data))), nil\n    \n    case SerialTypeInt24:\n        val := int32(data[0])<<16 | int32(data[1])<<8 | int32(data[2])\n        if data[0]&0x80 != 0 {\n            val |= 0xFF000000 // Sign extend\n        }\n        return int64(val), nil\n    \n    case SerialTypeInt32:\n        return int64(int32(binary.BigEndian.Uint32(data))), nil\n    \n    case SerialTypeInt48:\n        val := int64(binary.BigEndian.Uint32(data[0:4]))<<16 |\n               int64(binary.BigEndian.Uint16(data[4:6]))\n        if data[0]&0x80 != 0 {\n            val |= 0xFFFF000000000000 // Sign extend\n        }\n        return val, nil\n    \n    case SerialTypeInt64:\n        return int64(binary.BigEndian.Uint64(data)), nil\n    \n    case SerialTypeFloat:\n        return math.Float64frombits(binary.BigEndian.Uint64(data)), nil\n    \n    default:\n        if st >= 12 && st%2 == 0 {\n            // BLOB\n            return data[:SerialTypeSize(st)], nil\n        }\n        if st >= 13 {\n            // TEXT\n            return string(data[:SerialTypeSize(st)]), nil\n        }\n        return nil, fmt.Errorf(\"invalid serial type: %d\", st)\n    }\n}\n```\n\n### Record Format\n\n\n![Record Serialization Format](./diagrams/tdd-diag-19.svg)\n\n\n```go\n// record.go\n\n// Record format:\n// ┌─────────────────────────────────────────────────────────────────┐\n// │ Header Size (varint)                                            │\n// │ Serial Type 0 (varint)                                          │\n// │ Serial Type 1 (varint)                                          │\n// │ ...                                                             │\n// │ Serial Type N-1 (varint)                                        │\n// ├─────────────────────────────────────────────────────────────────┤\n// │ Value 0 (size determined by serial type)                        │\n// │ Value 1                                                         │\n// │ ...                                                             │\n// │ Value N-1                                                       │\n// └─────────────────────────────────────────────────────────────────┘\n\n// SerializeRow converts a slice of values to a record (byte slice).\nfunc SerializeRow(values []interface{}) []byte {\n    // First pass: calculate sizes and encode values\n    headerSize := 0\n    bodySize := 0\n    serialTypes := make([]SerialType, len(values))\n    bodies := make([][]byte, len(values))\n    \n    for i, val := range values {\n        st, body := EncodeSerialType(val)\n        serialTypes[i] = st\n        bodies[i] = body\n        bodySize += len(body)\n        headerSize += VarintSize(int64(st))\n    }\n    \n    // Total header size includes the header size varint itself\n    totalHeaderSize := headerSize + VarintSize(int64(headerSize + VarintSize(int64(headerSize))))\n    \n    // Recalculate with corrected header size\n    totalHeaderSize = headerSize + VarintSize(int64(totalHeaderSize))\n    \n    // Allocate buffer\n    totalSize := totalHeaderSize + bodySize\n    buf := make([]byte, totalSize)\n    \n    // Write header\n    offset := WriteVarintTo(buf, 0, int64(totalHeaderSize))\n    for _, st := range serialTypes {\n        offset += WriteVarintTo(buf, offset, int64(st))\n    }\n    \n    // Write body\n    for _, body := range bodies {\n        copy(buf[offset:], body)\n        offset += len(body)\n    }\n    \n    return buf\n}\n\n// DeserializeRow converts a record (byte slice) back to values.\nfunc DeserializeRow(data []byte) ([]interface{}, error) {\n    // Read header size\n    headerSize, offset := ReadVarint(data, 0)\n    if offset == 0 {\n        return nil, errors.New(\"invalid record: cannot read header size\")\n    }\n    \n    // Read serial types\n    var serialTypes []SerialType\n    headerEnd := offset\n    for int64(headerEnd) < headerSize {\n        st, bytesRead := ReadVarint(data, headerEnd)\n        if bytesRead == 0 {\n            return nil, errors.New(\"invalid record: truncated header\")\n        }\n        serialTypes = append(serialTypes, SerialType(st))\n        headerEnd += bytesRead\n    }\n    \n    // Read values\n    bodyOffset := headerEnd\n    values := make([]interface{}, len(serialTypes))\n    \n    for i, st := range serialTypes {\n        size := SerialTypeSize(st)\n        if bodyOffset+size > len(data) {\n            return nil, fmt.Errorf(\"invalid record: truncated body at column %d\", i)\n        }\n        \n        value, err := DecodeValue(st, data[bodyOffset:bodyOffset+size])\n        if err != nil {\n            return nil, err\n        }\n        values[i] = value\n        bodyOffset += size\n    }\n    \n    return values, nil\n}\n\n// Helper: WriteVarintTo writes a varint to buf at offset, returns bytes written.\nfunc WriteVarintTo(buf []byte, offset int, value int64) int {\n    v := WriteVarint(value)\n    copy(buf[offset:], v)\n    return len(v)\n}\n```\n\n### Table B-tree Leaf Cell\n\n```go\n// table_leaf.go\n\n// Table leaf cell format:\n// ┌─────────────┬────────────────┬───────────────────┐\n// │ Payload Size│ Rowid          │ Payload (record)  │\n// │ (varint)    │ (varint)       │ (bytes)           │\n// └─────────────┴────────────────┴───────────────────┘\n\n// ReadTableLeafCell reads a cell at the given offset.\n// Returns (rowid, record, bytesConsumed).\nfunc (p *Page) ReadTableLeafCell(offset int) (rowid int64, record []byte, consumed int, err error) {\n    pos := offset\n    \n    // Read payload size\n    payloadSize, n := ReadVarint(p.data, pos)\n    if n == 0 {\n        return 0, nil, 0, errors.New(\"invalid cell: cannot read payload size\")\n    }\n    pos += n\n    consumed = n\n    \n    // Read rowid\n    rowid, n = ReadVarint(p.data, pos)\n    if n == 0 {\n        return 0, nil, 0, errors.New(\"invalid cell: cannot read rowid\")\n    }\n    pos += n\n    consumed += n\n    \n    // Read payload\n    if pos+int(payloadSize) > PageSize {\n        // Handle overflow pages (advanced feature)\n        return 0, nil, 0, fmt.Errorf(\"payload overflow: %d bytes\", payloadSize)\n    }\n    record = make([]byte, payloadSize)\n    copy(record, p.data[pos:pos+int(payloadSize)])\n    consumed += int(payloadSize)\n    \n    return rowid, record, consumed, nil\n}\n\n// WriteTableLeafCell writes a cell at the given offset.\n// Returns bytes consumed or error.\nfunc (p *Page) WriteTableLeafCell(offset int, rowid int64, record []byte) (int, error) {\n    pos := offset\n    payloadSize := int64(len(record))\n    \n    // Write payload size\n    n := WriteVarintTo(p.data, pos, payloadSize)\n    pos += n\n    \n    // Write rowid\n    n = WriteVarintTo(p.data, pos, rowid)\n    pos += n\n    \n    // Write payload\n    copy(p.data[pos:], record)\n    pos += len(record)\n    \n    p.isDirty = true\n    return pos - offset, nil\n}\n\n// CellSize returns the size needed for a table leaf cell.\nfunc TableLeafCellSize(rowid int64, record []byte) int {\n    return VarintSize(int64(len(record))) + VarintSize(rowid) + len(record)\n}\n```\n\n### Table B-tree Internal Cell\n\n```go\n// table_internal.go\n\n// Table internal cell format:\n// ┌─────────────┬────────────────┐\n// │ Left Child  │ Rowid          │\n// │ (4 bytes)   │ (varint)       │\n// └─────────────┴────────────────┘\n\n// ReadTableInternalCell reads an internal cell at offset.\nfunc (p *Page) ReadTableInternalCell(offset int) (leftChild uint32, rowid int64, consumed int, err error) {\n    pos := offset\n    \n    // Read left child page number\n    if pos+4 > PageSize {\n        return 0, 0, 0, errors.New(\"invalid cell: truncated left child\")\n    }\n    leftChild = binary.BigEndian.Uint32(p.data[pos : pos+4])\n    pos += 4\n    \n    // Read rowid (separator key)\n    rowid, n := ReadVarint(p.data, pos)\n    if n == 0 {\n        return 0, 0, 0, errors.New(\"invalid cell: cannot read rowid\")\n    }\n    pos += n\n    \n    return leftChild, rowid, pos - offset, nil\n}\n\n// WriteTableInternalCell writes an internal cell at offset.\nfunc (p *Page) WriteTableInternalCell(offset int, leftChild uint32, rowid int64) (int, error) {\n    pos := offset\n    \n    // Write left child\n    binary.BigEndian.PutUint32(p.data[pos:pos+4], leftChild)\n    pos += 4\n    \n    // Write rowid\n    n := WriteVarintTo(p.data, pos, rowid)\n    pos += n\n    \n    p.isDirty = true\n    return pos - offset, nil\n}\n\n// FindChildPage returns the child page number for a given rowid.\nfunc (p *Page) FindChildPage(rowid int64) uint32 {\n    cellCount := int(p.CellCount())\n    \n    // Binary search for the correct child\n    for i := 0; i < cellCount; i++ {\n        cellOffset := p.CellPointer(i)\n        _, separatorRowid, _, _ := p.ReadTableInternalCell(int(cellOffset))\n        \n        if rowid < separatorRowid {\n            // Go to left child of this separator\n            leftChild, _, _, _ := p.ReadTableInternalCell(int(cellOffset))\n            return leftChild\n        }\n    }\n    \n    // Greater than all separators: use rightmost pointer\n    return p.RightMostPointer()\n}\n```\n\n### Index B+tree Leaf Cell\n\n```go\n// index_leaf.go\n\n// Index leaf cell format:\n// ┌─────────────┬────────────────┬───────────────────┐\n// │ Payload Size│ Payload        │ Rowid             │\n// │ (varint)    │ (indexed vals) │ (varint)          │\n// └─────────────┴────────────────┴───────────────────┘\n\n// The payload contains the serialized indexed column values.\n// For a single-column index, this is just the column value's serial type + data.\n// For a multi-column index, it's the concatenation of all indexed columns.\n\n// ReadIndexLeafCell reads an index leaf cell.\nfunc (p *Page) ReadIndexLeafCell(offset int) (payload []byte, rowid int64, consumed int, err error) {\n    pos := offset\n    \n    // Read payload size\n    payloadSize, n := ReadVarint(p.data, pos)\n    if n == 0 {\n        return nil, 0, 0, errors.New(\"invalid cell: cannot read payload size\")\n    }\n    pos += n\n    \n    // Read payload\n    if pos+int(payloadSize) > PageSize {\n        return nil, 0, 0, fmt.Errorf(\"payload overflow: %d bytes\", payloadSize)\n    }\n    payload = make([]byte, payloadSize)\n    copy(payload, p.data[pos:pos+int(payloadSize)])\n    pos += int(payloadSize)\n    \n    // Read rowid (at the end for index cells)\n    rowid, n = ReadVarint(p.data, pos)\n    if n == 0 {\n        return nil, 0, 0, errors.New(\"invalid cell: cannot read rowid\")\n    }\n    pos += n\n    \n    return payload, rowid, pos - offset, nil\n}\n```\n\n### BTree Structure\n\n```go\n// btree.go\n\ntype BTree struct {\n    rootPageID  PageID\n    bufferPool  *BufferPool\n    pager       Pager\n    isIndex     bool  // true for index B+tree, false for table B-tree\n}\n\ntype Pager interface {\n    AllocatePage() (PageID, error)\n    FreePage(pageID PageID) error\n}\n\n// NewBTree creates a new B-tree with an empty root page.\nfunc NewBTree(bufferPool *BufferPool, pager Pager, isIndex bool) (*BTree, error) {\n    // Allocate root page\n    rootPageID, err := pager.AllocatePage()\n    if err != nil {\n        return nil, err\n    }\n    \n    // Initialize as empty leaf\n    page, err := bufferPool.FetchPage(rootPageID)\n    if err != nil {\n        return nil, err\n    }\n    defer page.Unpin(true)\n    \n    if isIndex {\n        page.Data[0] = byte(PageTypeIndexLeaf)\n    } else {\n        page.Data[0] = byte(PageTypeTableLeaf)\n    }\n    \n    // Clear rest of header\n    for i := 1; i < PageHeaderSize; i++ {\n        page.Data[i] = 0\n    }\n    \n    return &BTree{\n        rootPageID: rootPageID,\n        bufferPool: bufferPool,\n        pager:      pager,\n        isIndex:    isIndex,\n    }, nil\n}\n\n// Insert adds a row to the table B-tree.\nfunc (t *BTree) Insert(rowid int64, record []byte) error {\n    // Navigate to the correct leaf page\n    path, err := t.findLeafPage(rowid)\n    if err != nil {\n        return err\n    }\n    leafPageID := path[len(path)-1]\n    \n    // Fetch the leaf page\n    page, err := t.bufferPool.FetchPage(leafPageID)\n    if err != nil {\n        return err\n    }\n    defer page.Unpin(true)\n    \n    // Calculate cell size\n    cellSize := TableLeafCellSize(rowid, record)\n    \n    // Check if cell fits\n    if cellSize+CellPointerSize > page.FreeSpace() {\n        // Need to split\n        return t.splitAndInsert(path, rowid, record)\n    }\n    \n    // Insert the cell\n    return t.insertIntoLeaf(page, rowid, record)\n}\n```\n\n### Node Splitting\n\n\n![Varint Encoding Algorithm](./diagrams/tdd-diag-20.svg)\n\n\n```go\n// split.go\n\n// splitAndInsert handles insertion when the target page is full.\nfunc (t *BTree) splitAndInsert(path []PageID, rowid int64, record []byte) error {\n    // Phase 1: Split the leaf page\n    leafPageID := path[len(path)-1]\n    leafPage, err := t.bufferPool.FetchPage(leafPageID)\n    if err != nil {\n        return err\n    }\n    defer leafPage.Unpin(true)\n    \n    // Collect all existing cells plus the new one\n    cells := t.collectCells(leafPage)\n    cells = append(cells, Cell{rowid: rowid, record: record})\n    sortCells(cells)\n    \n    // Allocate new page\n    newPageID, err := t.pager.AllocatePage()\n    if err != nil {\n        return err\n    }\n    newPage, err := t.bufferPool.FetchPage(newPageID)\n    if err != nil {\n        return err\n    }\n    defer newPage.Unpin(true)\n    \n    // Initialize new page with same type\n    copy(newPage.Data, make([]byte, PageSize))\n    newPage.Data[0] = leafPage.Data[0]\n    \n    // Calculate split point (approximately half)\n    medianIndex := len(cells) / 2\n    medianKey := cells[medianIndex].rowid\n    \n    // Distribute cells between old and new pages\n    t.clearPage(leafPage)\n    for i := 0; i < medianIndex; i++ {\n        t.insertCell(leafPage, cells[i])\n    }\n    for i := medianIndex; i < len(cells); i++ {\n        t.insertCell(newPage, cells[i])\n    }\n    \n    // Phase 2: Insert separator into parent (or create new root)\n    if len(path) == 1 {\n        // Splitting the root - create new root\n        return t.createNewRoot(leafPageID, newPageID, medianKey)\n    }\n    \n    // Insert separator into parent\n    parentPageID := path[len(path)-2]\n    return t.insertSeparator(parentPageID, newPageID, medianKey)\n}\n\n// createNewRoot creates a new root when the current root splits.\nfunc (t *BTree) createNewRoot(leftChild, rightChild PageID, separatorKey int64) error {\n    // Allocate new root\n    newRootID, err := t.pager.AllocatePage()\n    if err != nil {\n        return err\n    }\n    newRoot, err := t.bufferPool.FetchPage(newRootID)\n    if err != nil {\n        return err\n    }\n    defer newRoot.Unpin(true)\n    \n    // Initialize as internal page\n    for i := 0; i < PageSize; i++ {\n        newRoot.Data[i] = 0\n    }\n    newRoot.Data[0] = byte(PageTypeTableInt)\n    \n    // Set rightmost pointer to right child\n    newRoot.SetRightMostPointer(uint32(rightChild.PageNum))\n    \n    // Insert separator pointing to left child\n    cellOffset := PageSize - 4 - VarintSize(separatorKey)\n    newRoot.WriteTableInternalCell(cellOffset, uint32(leftChild.PageNum), separatorKey)\n    newRoot.SetCellPointer(0, uint16(cellOffset))\n    newRoot.SetCellCount(1)\n    newRoot.SetCellContentStart(uint16(cellOffset))\n    \n    // Update tree root\n    t.rootPageID = newRootID\n    \n    return nil\n}\n```\n\n### System Catalog\n\n```go\n// catalog.go\n\n// sqlite_master stores schema information.\n// Schema:\n// CREATE TABLE sqlite_master (\n//     type TEXT,        -- 'table', 'index', 'trigger', 'view'\n//     name TEXT,        -- Object name\n//     tbl_name TEXT,    -- Table name (for indexes)\n//     rootpage INTEGER, -- Root page number\n//     sql TEXT          -- CREATE statement\n// );\n\nconst CatalogRootPage = 1\n\ntype Catalog struct {\n    btree      *BTree\n    bufferPool *BufferPool\n}\n\n// CreateTable creates a new table and records it in the catalog.\nfunc (c *Catalog) CreateTable(name string, columns []ColumnDefinition, sql string) (PageID, error) {\n    // Allocate root page for the table's B-tree\n    rootPageID, err := c.btree.pager.AllocatePage()\n    if err != nil {\n        return PageID{}, err\n    }\n    \n    // Initialize as empty table leaf\n    page, err := c.bufferPool.FetchPage(rootPageID)\n    if err != nil {\n        return PageID{}, err\n    }\n    defer page.Unpin(true)\n    \n    for i := 0; i < PageSize; i++ {\n        page.Data[i] = 0\n    }\n    page.Data[0] = byte(PageTypeTableLeaf)\n    \n    // Insert into sqlite_master\n    record := SerializeRow([]interface{}{\n        \"table\",\n        name,\n        name,\n        int64(rootPageID.PageNum),\n        sql,\n    })\n    \n    // Generate rowid for catalog entry\n    rowid := c.generateRowid()\n    \n    err = c.btree.Insert(rowid, record)\n    if err != nil {\n        return PageID{}, err\n    }\n    \n    return rootPageID, nil\n}\n\n// GetTableRootPage looks up a table's root page number.\nfunc (c *Catalog) GetTableRootPage(name string) (uint32, error) {\n    cursor := c.btree.NewCursor()\n    cursor.First()\n    \n    for !cursor.AtEnd() {\n        rowid, record := cursor.Current()\n        values, _ := DeserializeRow(record)\n        \n        if len(values) >= 3 {\n            objType := values[0].(string)\n            objName := values[1].(string)\n            \n            if objType == \"table\" && objName == name {\n                rootPage := values[3].(int64)\n                return uint32(rootPage), nil\n            }\n        }\n        \n        cursor.Next()\n    }\n    \n    return 0, fmt.Errorf(\"no such table: %s\", name)\n}\n```\n\n### Free Space Management\n\n```go\n// freeblock.go\n\n// Freeblock format:\n// ┌─────────────┬────────────────┐\n// │ Next Offset │ Size           │\n// │ (2 bytes)   │ (2 bytes)      │\n// └─────────────┴────────────────┘\n// Followed by (Size - 4) bytes of free space\n\nconst FreeblockHeaderSize = 4\n\n// AllocateCell finds space for a cell of the given size.\n// Returns the offset where the cell can be written.\nfunc (p *Page) AllocateCell(size int) (int, error) {\n    // Check if there's enough contiguous free space\n    if p.FreeSpace() < size+CellPointerSize {\n        return 0, errors.New(\"insufficient space\")\n    }\n    \n    // Try to allocate from cell content area\n    contentStart := int(p.CellContentStart())\n    if contentStart == PageSize {\n        contentStart = PageSize\n    }\n    \n    newContentStart := contentStart - size\n    pointerArrayEnd := p.headerSize() + int(p.CellCount())*CellPointerSize\n    \n    if newContentStart >= pointerArrayEnd {\n        p.SetCellContentStart(uint16(newContentStart))\n        return newContentStart, nil\n    }\n    \n    // Try to allocate from freeblock list\n    offset := p.allocateFromFreeblock(size)\n    if offset > 0 {\n        return offset, nil\n    }\n    \n    // Need to defragment\n    p.defragment()\n    \n    // Retry allocation\n    contentStart = int(p.CellContentStart())\n    newContentStart = contentStart - size\n    pointerArrayEnd = p.headerSize() + int(p.CellCount())*CellPointerSize\n    \n    if newContentStart >= pointerArrayEnd {\n        p.SetCellContentStart(uint16(newContentStart))\n        return newContentStart, nil\n    }\n    \n    return 0, errors.New(\"insufficient space after defragmentation\")\n}\n\n// defragment reorganizes the page to consolidate free space.\nfunc (p *Page) defragment() {\n    // Read all cells\n    type cellEntry struct {\n        offset int\n        data   []byte\n    }\n    \n    var cells []cellEntry\n    for i := 0; i < int(p.CellCount()); i++ {\n        offset := int(p.CellPointer(i))\n        // Read cell data (simplified - would need to read actual cell size)\n        cells = append(cells, cellEntry{offset: offset})\n    }\n    \n    // Rebuild page from scratch\n    tempPage := make([]byte, PageSize)\n    copy(tempPage[0:p.headerSize()], p.data[0:p.headerSize()])\n    \n    // Write cells contiguously from end\n    contentStart := PageSize\n    for i, cell := range cells {\n        // Copy cell data to new position\n        // (implementation would read and write actual cell bytes)\n        newOffset := contentStart - len(cell.data)\n        copy(tempPage[newOffset:contentStart], cell.data)\n        \n        // Update pointer\n        ptrOffset := p.headerSize() + i*CellPointerSize\n        binary.BigEndian.PutUint16(tempPage[ptrOffset:ptrOffset+2], uint16(newOffset))\n        \n        contentStart = newOffset\n    }\n    \n    // Update header\n    binary.BigEndian.PutUint16(tempPage[5:7], uint16(contentStart))\n    tempPage[1] = 0 // Clear freeblock pointer\n    tempPage[7] = 0 // Clear fragmented bytes\n    \n    copy(p.data, tempPage)\n    p.isDirty = true\n}\n```\n\n---\n\n## Interface Contracts\n\n### Page Creation and Initialization\n\n```go\n// NewPage creates a Page handle for existing data.\nfunc NewPage(data []byte, pageID PageID) *Page\n\n// InitializeLeafPage sets up a page as an empty leaf.\nfunc (p *Page) InitializeLeafPage(pageType PageType)\n\n// InitializeInternalPage sets up a page as an empty internal page.\nfunc (p *Page) InitializeInternalPage(pageType PageType)\n```\n\n### Cell Operations\n\n```go\n// InsertCell inserts a cell and updates the pointer array.\n// The pointer array is kept sorted by key.\nfunc (p *Page) InsertCell(cellData []byte, key int64) error\n\n// DeleteCell removes a cell at the given index.\nfunc (p *Page) DeleteCell(index int) error\n\n// FindCell returns the index where a cell with the given key would be inserted.\n// Also returns true if an exact match is found.\nfunc (p *Page) FindCell(key int64) (index int, found bool)\n```\n\n### BTree Operations\n\n```go\n// Insert adds a record to the table B-tree at the specified rowid.\n// Handles node splitting if necessary.\nfunc (t *BTree) Insert(rowid int64, record []byte) error\n\n// Delete removes the record at the specified rowid.\nfunc (t *BTree) Delete(rowid int64) error\n\n// Fetch retrieves the record at the specified rowid.\n// Returns nil if not found.\nfunc (t *BTree) Fetch(rowid int64) ([]byte, error)\n\n// Scan returns a cursor for iterating all records in rowid order.\nfunc (t *BTree) Scan() *Cursor\n```\n\n---\n\n## Algorithm Specification\n\n### Insert Cell into Page\n\n```\nALGORITHM: InsertCell\nINPUT: Page p, cellData []byte, key int64\nOUTPUT: error\n\n1. CALCULATE CELL SIZE\n   cellSize := len(cellData)\n   totalSize := cellSize + CellPointerSize\n\n2. CHECK AVAILABLE SPACE\n   IF p.FreeSpace() < totalSize:\n     RETURN InsufficientSpaceError\n\n3. ALLOCATE CELL STORAGE\n   offset, err := p.AllocateCell(cellSize)\n   IF err != nil:\n     RETURN err\n\n4. WRITE CELL DATA\n   copy(p.data[offset:offset+cellSize], cellData)\n\n5. FIND INSERTION POINT\n   insertIndex, _ := p.FindCell(key)\n\n6. SHIFT POINTER ARRAY\n   // Make room for new pointer\n   FOR i := p.CellCount() - 1; i >= insertIndex; i--:\n     p.SetCellPointer(i+1, p.CellPointer(i))\n\n7. INSERT NEW POINTER\n   p.SetCellPointer(insertIndex, uint16(offset))\n\n8. UPDATE CELL COUNT\n   p.SetCellCount(p.CellCount() + 1)\n\n9. RETURN nil\n```\n\n### Find Leaf Page for Key\n\n```\nALGORITHM: findLeafPage\nINPUT: BTree t, key int64\nOUTPUT: []PageID (path from root to leaf)\n\n1. path := empty list\n   pageID := t.rootPageID\n\n2. WHILE true:\n     a. APPEND pageID to path\n     b. page, err := t.bufferPool.FetchPage(pageID)\n        IF err != nil:\n          RETURN nil, err\n     \n     c. IF page.Type().IsLeaf():\n          page.Unpin(false)\n          RETURN path, nil\n     \n     d. // Internal page: find correct child\n        childPageNum := page.FindChildPage(key)\n        page.Unpin(false)\n        \n        pageID = PageID{PageNum: int(childPageNum)}\n```\n\n### Full Table Scan\n\n```\nALGORITHM: FullTableScan\nINPUT: BTree t\nOUTPUT: Iterator yielding (rowid, record) pairs\n\n1. // Navigate to leftmost leaf\n   path := findLeftmostLeaf(t)\n   pageID := path[len(path)-1]\n\n2. // Iterate through leaves\n   WHILE pageID.IsValid():\n     a. page, err := t.bufferPool.FetchPage(pageID)\n        IF err != nil:\n          YIELD error\n          RETURN\n     \n     b. // Process all cells in this leaf\n        FOR i := 0; i < page.CellCount(); i++:\n          offset := page.CellPointer(i)\n          rowid, record, _, _ := page.ReadTableLeafCell(int(offset))\n          YIELD (rowid, record)\n     \n     c. // Move to next leaf\n        // (SQLite table B-trees don't link leaves; navigate via parent)\n        // Simplified: assume no leaf linking\n        pageID = PageID{} // End of scan\n        page.Unpin(false)\n\n3. RETURN\n```\n\n---\n\n## Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n|-------|-------------|----------|---------------|\n| Page overflow (row > usable page size) | `AllocateCell` | Return error, suggest overflow pages | Yes: \"row too large: X bytes exceeds limit\" |\n| Corrupted page header | `Type()` validation | Return error, refuse to operate | Yes: \"corrupted page header: invalid type byte\" |\n| Invalid cell pointer (offset out of bounds) | `CellPointer` bounds check | Return error | Yes: \"invalid cell pointer: offset X exceeds page size\" |\n| Varint truncation | `ReadVarint` EOF check | Return error | Yes: \"truncated varint at offset X\" |\n| Serial type mismatch | `DecodeValue` type validation | Return NULL value, log warning | No (graceful degradation) |\n| Node split cascades to root | `splitAndInsert` recursion | Create new root, increase tree height | No (internal operation) |\n| Freeblock list corruption | `allocateFromFreeblock` cycle detection | Defragment page | No (auto-recovery) |\n\n---\n\n## Implementation Sequence with Checkpoints\n\n### Phase 1: Page Header and Slotted Format (2 hours)\n\n**Files to create**: `page.go`, `page_type.go`, `cell.go`\n\n**Implementation**:\n1. Define `PageType` constants and validation\n2. Implement `Page` struct with header accessors\n3. Implement cell pointer array operations\n4. Implement `FreeSpace()` calculation\n5. Add basic page initialization\n\n**Checkpoint**: At this point you should be able to create and initialize pages. Run:\n```bash\ngo test -run TestPageHeader\n# Expected: PASS (header read/write works)\n```\n\n### Phase 2: Varint Encoding/Decoding (1 hour)\n\n**Files to create**: `varint.go`\n\n**Implementation**:\n1. Implement `ReadVarint` for all 9 encoding types\n2. Implement `WriteVarint` for all value ranges\n3. Implement `VarintSize` helper\n4. Add boundary tests for each encoding size\n\n**Checkpoint**: At this point you should pass varint tests. Run:\n```bash\ngo test -run TestVarint\n# Expected: PASS (all encoding sizes work correctly)\n```\n\n### Phase 3: Record Serialization with Serial Types (2 hours)\n\n**Files to create**: `serial_type.go`, `record.go`\n\n**Implementation**:\n1. Define serial type constants\n2. Implement `EncodeSerialType` for all Go types\n3. Implement `DecodeValue` for all serial types\n4. Implement `SerializeRow` and `DeserializeRow`\n5. Handle NULL, zero, one as special cases\n\n**Checkpoint**: At this point you should serialize/deserialize rows. Run:\n```bash\ngo test -run TestRecord\n# Expected: PASS (round-trip serialization works)\n```\n\n### Phase 4: Table B-tree Leaf and Internal Pages (2 hours)\n\n**Files to create**: `table_leaf.go`, `table_internal.go`\n\n**Implementation**:\n1. Implement `ReadTableLeafCell` and `WriteTableLeafCell`\n2. Implement `ReadTableInternalCell` and `WriteTableInternalCell`\n3. Implement `FindChildPage` for internal pages\n4. Add cell size calculation helpers\n\n**Checkpoint**: At this point you should read/write cells. Run:\n```bash\ngo test -run TestTableLeaf\ngo test -run TestTableInternal\n# Expected: PASS (cell operations work)\n```\n\n### Phase 5: Index B+tree Pages (1.5 hours)\n\n**Files to create**: `index_leaf.go`, `index_internal.go`\n\n**Implementation**:\n1. Implement `ReadIndexLeafCell` and `WriteIndexLeafCell`\n2. Implement index internal cell operations\n3. Handle leaf page linking (right-sibling pointer)\n\n**Checkpoint**: At this point you should handle index pages. Run:\n```bash\ngo test -run TestIndexLeaf\n# Expected: PASS (index cell format correct)\n```\n\n### Phase 6: Node Splitting and Separator Promotion (2 hours)\n\n**Files to create**: `split.go`, `btree.go`, `btree_cursor.go`\n\n**Implementation**:\n1. Implement `splitAndInsert` for leaf pages\n2. Implement `createNewRoot`\n3. Implement `insertSeparator` into parent\n4. Handle cascading splits\n5. Implement cursor for tree traversal\n\n**Checkpoint**: At this point you should handle inserts with splits. Run:\n```bash\ngo test -run TestNodeSplit\n# Expected: PASS (splits maintain tree balance)\n```\n\n### Phase 7: System Catalog (1.5 hours)\n\n**Files to create**: `catalog.go`\n\n**Implementation**:\n1. Implement `sqlite_master` schema\n2. Implement `CreateTable` with catalog update\n3. Implement `GetTableRootPage` lookup\n4. Implement `CreateIndex` catalog entry\n\n**Checkpoint**: At this point you should pass the full test suite. Run:\n```bash\ngo test -v ./storage\n# Expected: All tests PASS\n# Verify: 50-200 rows per leaf page\n# Verify: O(log n) lookup for 10K rows\n```\n\n---\n\n## Test Specification\n\n```go\n// storage_test.go\n\nfunc TestPageHeader(t *testing.T) {\n    data := make([]byte, PageSize)\n    page := NewPage(data, PageID{PageNum: 1})\n    \n    // Initialize as table leaf\n    page.InitializeLeafPage(PageTypeTableLeaf)\n    \n    assert.Equal(t, PageTypeTableLeaf, page.Type())\n    assert.Equal(t, uint16(0), page.FirstFreeblock())\n    assert.Equal(t, uint16(0), page.CellCount())\n    assert.Equal(t, uint16(PageSize), page.CellContentStart())\n}\n\nfunc TestVarintEncoding(t *testing.T) {\n    tests := []struct {\n        value    int64\n        expected []byte\n    }{\n        {0, []byte{0x00}},\n        {127, []byte{0x7F}},\n        {128, []byte{0x81, 0x00}},\n        {16383, []byte{0xBF, 0xFF}},\n        {16384, []byte{0xC1, 0x00, 0x00}},\n        {2097151, []byte{0xDF, 0xFF, 0xFF}},\n        {-1, append([]byte{0xFF}, make([]byte, 8)...)},\n    }\n    \n    for _, tc := range tests {\n        encoded := WriteVarint(tc.value)\n        assert.Equal(t, tc.expected, encoded)\n        \n        decoded, bytesRead := ReadVarint(encoded, 0)\n        assert.Equal(t, tc.value, decoded)\n        assert.Equal(t, len(encoded), bytesRead)\n    }\n}\n\nfunc TestRecordSerialization(t *testing.T) {\n    values := []interface{}{\n        int64(42),\n        \"hello world\",\n        nil,\n        3.14159,\n        []byte{0x01, 0x02, 0x03},\n    }\n    \n    record := SerializeRow(values)\n    decoded, err := DeserializeRow(record)\n    \n    assert.NoError(t, err)\n    assert.Equal(t, int64(42), decoded[0])\n    assert.Equal(t, \"hello world\", decoded[1])\n    assert.Nil(t, decoded[2])\n    assert.InDelta(t, 3.14159, decoded[3], 0.00001)\n    assert.Equal(t, []byte{0x01, 0x02, 0x03}, decoded[4])\n}\n\nfunc TestTableLeafCell(t *testing.T) {\n    data := make([]byte, PageSize)\n    page := NewPage(data, PageID{PageNum: 1})\n    page.InitializeLeafPage(PageTypeTableLeaf)\n    \n    record := SerializeRow([]interface{}{int64(1), \"Alice\", int64(30)})\n    \n    // Write cell\n    cellSize := TableLeafCellSize(1, record)\n    offset, err := page.AllocateCell(cellSize)\n    assert.NoError(t, err)\n    \n    _, err = page.WriteTableLeafCell(offset, 1, record)\n    assert.NoError(t, err)\n    \n    // Read cell back\n    rowid, readRecord, _, err := page.ReadTableLeafCell(offset)\n    assert.NoError(t, err)\n    assert.Equal(t, int64(1), rowid)\n    assert.Equal(t, record, readRecord)\n}\n\nfunc TestNodeSplit(t *testing.T) {\n    bufferPool := NewMockBufferPool(100)\n    pager := NewMockPager()\n    \n    btree, err := NewBTree(bufferPool, pager, false)\n    assert.NoError(t, err)\n    \n    // Insert enough rows to trigger splits\n    for i := 0; i < 1000; i++ {\n        record := SerializeRow([]interface{}{int64(i), fmt.Sprintf(\"user%d\", i)})\n        err := btree.Insert(int64(i), record)\n        assert.NoError(t, err)\n    }\n    \n    // Verify all rows are retrievable\n    count := 0\n    cursor := btree.Scan()\n    for !cursor.AtEnd() {\n        _, _ = cursor.Current()\n        count++\n        cursor.Next()\n    }\n    assert.Equal(t, 1000, count)\n}\n\nfunc TestCatalog(t *testing.T) {\n    bufferPool := NewMockBufferPool(100)\n    pager := NewMockPager()\n    \n    // Create catalog on page 1\n    catalogBTree, _ := NewBTree(bufferPool, pager, false)\n    catalog := &Catalog{btree: catalogBTree, bufferPool: bufferPool}\n    \n    // Create a table\n    rootPage, err := catalog.CreateTable(\"users\", []ColumnDefinition{\n        {Name: \"id\", Type: \"INTEGER\"},\n        {Name: \"name\", Type: \"TEXT\"},\n    }, \"CREATE TABLE users (id INTEGER, name TEXT)\")\n    assert.NoError(t, err)\n    assert.True(t, rootPage.IsValid())\n    \n    // Look up the table\n    foundRootPage, err := catalog.GetTableRootPage(\"users\")\n    assert.NoError(t, err)\n    assert.Equal(t, uint32(rootPage.PageNum), foundRootPage)\n    \n    // Look up non-existent table\n    _, err = catalog.GetTableRootPage(\"nonexistent\")\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"no such table\")\n}\n\nfunc TestRowsPerPage(t *testing.T) {\n    // Verify 50-200 rows per leaf page\n    data := make([]byte, PageSize)\n    page := NewPage(data, PageID{PageNum: 1})\n    page.InitializeLeafPage(PageTypeTableLeaf)\n    \n    // Insert small rows\n    for i := 0; i < 200; i++ {\n        record := SerializeRow([]interface{}{int64(i), fmt.Sprintf(\"user%d\", i)})\n        cellSize := TableLeafCellSize(int64(i), record)\n        \n        offset, err := page.AllocateCell(cellSize)\n        if err != nil {\n            break // Page full\n        }\n        \n        page.WriteTableLeafCell(offset, int64(i), record)\n        page.SetCellCount(page.CellCount() + 1)\n    }\n    \n    // Should have at least 50 rows\n    assert.GreaterOrEqual(t, page.CellCount(), uint16(50))\n    // Should not exceed 200 rows\n    assert.LessOrEqual(t, page.CellCount(), uint16(200))\n}\n```\n\n---\n\n## Performance Targets\n\n| Operation | Target | How to Measure |\n|-----------|--------|----------------|\n| Rows per leaf page | 50-200 | `go test -run TestRowsPerPage` |\n| Point lookup (B-tree seek) | O(log n), < 1ms for 1M rows | `go test -bench=BenchmarkLookup` |\n| Node split | < 1ms | `go test -bench=BenchmarkSplit` |\n| Full table scan | O(n), > 100K rows/sec | `go test -bench=BenchmarkScan` |\n| Varint encode/decode | < 50ns per operation | `go test -bench=BenchmarkVarint` |\n| Record serialize | < 500ns per row | `go test -bench=BenchmarkSerialize` |\n\n---\n\n## Synced Criteria\n\n}]\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-sqlite-m6 -->\n# Technical Design Specification: SELECT Execution & DML\n\n## Module Charter\n\nThe SELECT Execution & DML module implements the runtime execution layer that processes bytecode programs generated by the compiler, performing actual data manipulation against B-tree storage. It provides cursor-based B-tree traversal for sequential and positioned access, row deserialization with lazy column extraction, expression evaluation with SQL three-valued logic (TRUE/FALSE/NULL), projection of selected columns, and constraint enforcement (NOT NULL validation, table existence checks). The module does NOT perform query optimization, manage transaction isolation, or handle storage allocation—it executes the plan provided by the compiler. Upstream dependencies: Bytecode Compiler (provides instruction programs), Storage layer (B-trees, buffer pool). Downstream dependencies: Result callback handlers (for SELECT output), Transaction manager (for DML coordination). Invariants: cursor positions remain valid only while page is pinned; NULL comparisons always produce NULL (never TRUE or FALSE); NOT NULL constraints are checked before any write operation; deleted rows are immediately removed from B-tree structure.\n\n---\n\n## File Structure\n\n```\nexecution/\n├── cursor.go           # (1) Cursor struct with B-tree position state\n├── cursor_scan.go      # (2) Sequential scan operations (First, Next, AtEnd)\n├── cursor_seek.go      # (3) Positioned access (SeekRowid, SeekRange)\n├── value.go            # (4) Value type with NULL representation\n├── three_valued.go     # (5) Three-valued logic operators (AND, OR, NOT, comparison)\n├── expression_eval.go  # (6) Expression evaluation with TVL\n├── column_access.go    # (7) Lazy column deserialization from records\n├── select_exec.go      # (8) SELECT execution handlers (Column, ResultRow)\n├── insert_exec.go      # (9) INSERT execution with constraint checking\n├── update_exec.go      # (10) UPDATE execution (delete + reinsert pattern)\n├── delete_exec.go      # (11) DELETE execution\n├── constraint.go       # (12) Constraint validation (NOT NULL, table existence)\n├── projection.go       # (13) Column projection logic\n├── execution_test.go   # (14) Comprehensive test suite\n└── vm/\n    └── opcodes.go      # (15) VM opcode handlers calling execution layer\n```\n\n---\n\n## Complete Data Model\n\n### Value Type with NULL Handling\n\n```go\n// value.go\n\ntype ValueType int\n\nconst (\n    ValueNull ValueType = iota\n    ValueInteger\n    ValueReal\n    ValueText\n    ValueBlob\n)\n\ntype Value struct {\n    Type  ValueType\n    Int   int64\n    Float float64\n    Str   string\n    Bytes []byte\n}\n\n// IsNull returns true if this value is NULL.\nfunc (v Value) IsNull() bool {\n    return v.Type == ValueNull\n}\n\n// IsTruthy returns true if value is TRUE in three-valued logic.\n// Only non-zero, non-NULL values are truthy.\n// NULL is NOT truthy (but also NOT false - it's unknown).\nfunc (v Value) IsTruthy() bool {\n    switch v.Type {\n    case ValueNull:\n        return false\n    case ValueInteger:\n        return v.Int != 0\n    case ValueReal:\n        return v.Float != 0\n    case ValueText:\n        return len(v.Str) > 0\n    case ValueBlob:\n        return len(v.Bytes) > 0\n    default:\n        return false\n    }\n}\n\n// ToFloat converts integer to float for mixed-type comparisons.\nfunc (v Value) ToFloat() float64 {\n    switch v.Type {\n    case ValueInteger:\n        return float64(v.Int)\n    case ValueReal:\n        return v.Float\n    default:\n        return 0\n    }\n}\n\n// String returns a human-readable representation.\nfunc (v Value) String() string {\n    switch v.Type {\n    case ValueNull:\n        return \"NULL\"\n    case ValueInteger:\n        return fmt.Sprintf(\"%d\", v.Int)\n    case ValueReal:\n        return fmt.Sprintf(\"%f\", v.Float)\n    case ValueText:\n        return v.Str\n    case ValueBlob:\n        return fmt.Sprintf(\"X'%x'\", v.Bytes)\n    default:\n        return \"UNKNOWN\"\n    }\n}\n\n// WHY Value type:\n// - Uniform representation for all SQL values including NULL\n// - NULL is a distinct type, not a nil pointer (avoids nil checks everywhere)\n// - Type field enables correct comparison semantics\n// - IsTruthy implements three-valued logic for WHERE clauses\n```\n\n### Cursor State\n\n```go\n// cursor.go\n\ntype Cursor struct {\n    ID           int        // Cursor identifier (matches bytecode P1)\n    Tree         *BTree     // B-tree being traversed\n    CurrentPage  *Page      // Currently loaded page (pinned)\n    PageID       PageID     // Current page identifier\n    CellIndex    int        // Current cell within page\n    Rowid        int64      // Current row's rowid (cached for performance)\n    Record       []byte     // Current row's serialized record\n    AtEnd        bool       // True when cursor has no more rows\n    IsWritable   bool       // True for write cursors\n}\n\n// NewCursor creates a cursor for traversing a B-tree.\nfunc NewCursor(id int, tree *BTree, writable bool) *Cursor {\n    return &Cursor{\n        ID:         id,\n        Tree:       tree,\n        IsWritable: writable,\n    }\n}\n\n// Current returns the current row's rowid and record.\n// Panics if cursor is at end.\nfunc (c *Cursor) Current() (rowid int64, record []byte) {\n    if c.AtEnd {\n        panic(\"cursor at end\")\n    }\n    return c.Rowid, c.Record\n}\n\n// WHY Cursor:\n// - Encapsulates B-tree position state for VM\n// - Caches current rowid and record for repeated column access\n// - AtEnd flag enables clean loop termination\n// - Writable flag controls whether cursor can modify data\n```\n\n### Three-Valued Logic Operators\n\n```go\n// three_valued.go\n\n// TVLBool represents three-valued logic result.\ntype TVLBool int\n\nconst (\n    TVLFalse TVLBool = iota\n    TVLTrue\n    TVLNull  // Unknown\n)\n\n// CompareResult represents comparison outcome.\ntype CompareResult int\n\nconst (\n    CompareLess    CompareResult = -1\n    CompareEqual   CompareResult = 0\n    CompareGreater CompareResult = 1\n    CompareNull    CompareResult = 2  // Incomparable (NULL involved)\n)\n\n// CompareValues compares two SQL values with three-valued logic.\n// Returns CompareNull if either value is NULL.\nfunc CompareValues(left, right Value) CompareResult {\n    // NULL compared to anything is NULL (incomparable)\n    if left.IsNull() || right.IsNull() {\n        return CompareNull\n    }\n    \n    // Type coercion: promote to float if either is float\n    if left.Type == ValueReal || right.Type == ValueReal {\n        lv := left.ToFloat()\n        rv := right.ToFloat()\n        if lv < rv {\n            return CompareLess\n        } else if lv > rv {\n            return CompareGreater\n        }\n        return CompareEqual\n    }\n    \n    // Integer comparison\n    if left.Type == ValueInteger && right.Type == ValueInteger {\n        if left.Int < right.Int {\n            return CompareLess\n        } else if left.Int > right.Int {\n            return CompareGreater\n        }\n        return CompareEqual\n    }\n    \n    // Text comparison\n    if left.Type == ValueText && right.Type == ValueText {\n        if left.Str < right.Str {\n            return CompareLess\n        } else if left.Str > right.Str {\n            return CompareGreater\n        }\n        return CompareEqual\n    }\n    \n    // Blob comparison (lexicographic)\n    if left.Type == ValueBlob && right.Type == ValueBlob {\n        cmp := bytes.Compare(left.Bytes, right.Bytes)\n        return CompareResult(cmp)\n    }\n    \n    return CompareNull\n}\n\n// TVLAnd implements three-valued AND.\n// Truth table:\n//   AND | TRUE  | FALSE | NULL\n//   ----+-------+-------+------\n//   TRUE| TRUE  | FALSE | NULL\n//   FALS| FALSE | FALSE | FALSE\n//   NULL| NULL  | FALSE | NULL\nfunc TVLAnd(left, right TVLBool) TVLBool {\n    // FALSE dominates: any FALSE makes result FALSE\n    if left == TVLFalse || right == TVLFalse {\n        return TVLFalse\n    }\n    // NULL propagates if no FALSE\n    if left == TVLNull || right == TVLNull {\n        return TVLNull\n    }\n    // TRUE AND TRUE = TRUE\n    return TVLTrue\n}\n\n// TVLOr implements three-valued OR.\n// Truth table:\n//   OR  | TRUE  | FALSE | NULL\n//   ----+-------+-------+------\n//   TRUE| TRUE  | TRUE  | TRUE\n//   FALS| TRUE  | FALSE | NULL\n//   NULL| TRUE  | NULL  | NULL\nfunc TVLOr(left, right TVLBool) TVLBool {\n    // TRUE dominates: any TRUE makes result TRUE\n    if left == TVLTrue || right == TVLTrue {\n        return TVLTrue\n    }\n    // NULL propagates if no TRUE\n    if left == TVLNull || right == TVLNull {\n        return TVLNull\n    }\n    // FALSE OR FALSE = FALSE\n    return TVLFalse\n}\n\n// TVLNot implements three-valued NOT.\n// NOT(TRUE) = FALSE, NOT(FALSE) = TRUE, NOT(NULL) = NULL\nfunc TVLNot(operand TVLBool) TVLBool {\n    switch operand {\n    case TVLTrue:\n        return TVLFalse\n    case TVLFalse:\n        return TVLTrue\n    case TVLNull:\n        return TVLNull\n    default:\n        return TVLNull\n    }\n}\n\n// WHY three-valued logic:\n// - SQL NULL means \"unknown\", not \"missing\"\n// - NULL = NULL is NULL (unknown), not TRUE\n// - WHERE only keeps rows where predicate is TRUE (not NULL or FALSE)\n// - AND/OR have special short-circuit semantics with NULL\n```\n\n### Column Access with Lazy Deserialization\n\n```go\n// column_access.go\n\n// ColumnCache stores deserialized column values to avoid re-parsing.\ntype ColumnCache struct {\n    record      []byte          // Original serialized record\n    serialTypes []SerialType    // Parsed serial types\n    offsets     []int           // Byte offset of each column in record body\n    values      []Value         // Lazily deserialized values (nil if not yet accessed)\n    valid       bool            // True if cache has been populated\n}\n\n// NewColumnCache creates an empty cache.\nfunc NewColumnCache() *ColumnCache {\n    return &ColumnCache{\n        values: make([]Value, 0),\n    }\n}\n\n// SetRecord initializes the cache with a new record.\nfunc (cc *ColumnCache) SetRecord(record []byte) {\n    cc.record = record\n    cc.serialTypes = nil\n    cc.offsets = nil\n    cc.values = nil\n    cc.valid = false\n}\n\n// parseHeader extracts serial types and calculates column offsets.\nfunc (cc *ColumnCache) parseHeader() error {\n    if cc.valid {\n        return nil\n    }\n    \n    if len(cc.record) == 0 {\n        return errors.New(\"empty record\")\n    }\n    \n    // Read header size\n    headerSize, offset := ReadVarint(cc.record, 0)\n    if offset == 0 {\n        return errors.New(\"invalid record: cannot read header size\")\n    }\n    \n    // Read serial types\n    cc.serialTypes = make([]SerialType, 0)\n    headerEnd := offset\n    for int64(headerEnd) < headerSize {\n        st, bytesRead := ReadVarint(cc.record, headerEnd)\n        if bytesRead == 0 {\n            return errors.New(\"invalid record: truncated header\")\n        }\n        cc.serialTypes = append(cc.serialTypes, SerialType(st))\n        headerEnd += bytesRead\n    }\n    \n    // Calculate offsets for each column\n    cc.offsets = make([]int, len(cc.serialTypes))\n    cc.values = make([]Value, len(cc.serialTypes))\n    \n    bodyOffset := headerEnd\n    for i, st := range cc.serialTypes {\n        cc.offsets[i] = bodyOffset\n        bodyOffset += SerialTypeSize(st)\n    }\n    \n    cc.valid = true\n    return nil\n}\n\n// GetColumn retrieves a column value, deserializing lazily.\n// First access parses the header; subsequent accesses are O(1).\nfunc (cc *ColumnCache) GetColumn(colIndex int) (Value, error) {\n    if err := cc.parseHeader(); err != nil {\n        return Value{Type: ValueNull}, err\n    }\n    \n    if colIndex < 0 || colIndex >= len(cc.serialTypes) {\n        return Value{Type: ValueNull}, fmt.Errorf(\"column index %d out of range\", colIndex)\n    }\n    \n    // Return cached value if already deserialized\n    if cc.values[colIndex].Type != ValueNull || cc.serialTypes[colIndex] == SerialTypeNull {\n        return cc.values[colIndex], nil\n    }\n    \n    // Deserialize the column\n    st := cc.serialTypes[colIndex]\n    offset := cc.offsets[colIndex]\n    size := SerialTypeSize(st)\n    \n    value, err := DecodeValue(st, cc.record[offset:offset+size])\n    if err != nil {\n        return Value{Type: ValueNull}, err\n    }\n    \n    // Convert to Value type\n    switch v := value.(type) {\n    case nil:\n        cc.values[colIndex] = Value{Type: ValueNull}\n    case int64:\n        cc.values[colIndex] = Value{Type: ValueInteger, Int: v}\n    case float64:\n        cc.values[colIndex] = Value{Type: ValueReal, Float: v}\n    case string:\n        cc.values[colIndex] = Value{Type: ValueText, Str: v}\n    case []byte:\n        cc.values[colIndex] = Value{Type: ValueBlob, Bytes: v}\n    }\n    \n    return cc.values[colIndex], nil\n}\n\n// ColumnCount returns the number of columns in the current record.\nfunc (cc *ColumnCache) ColumnCount() int {\n    cc.parseHeader()\n    return len(cc.serialTypes)\n}\n\n// WHY lazy column access:\n// - Column N deserialization requires parsing columns 0..N-1 offsets\n// - Caching avoids re-parsing for repeated access\n// - SELECT col50 FROM table only pays cost for col50, not all 50\n// - First access O(n), subsequent accesses O(1)\n```\n\n---\n\n## Interface Contracts\n\n### Cursor Operations\n\n```go\n// First positions the cursor at the first row (leftmost leaf, first cell).\n// Returns error if B-tree is empty or page fetch fails.\n// After call, AtEnd is false if rows exist, true if table is empty.\nfunc (c *Cursor) First() error\n\n// Next advances the cursor to the next row in rowid order.\n// Returns error if page fetch fails.\n// Sets AtEnd to true when no more rows exist.\nfunc (c *Cursor) Next() error\n\n// SeekRowid positions the cursor at the row with the given rowid.\n// Returns true if found, false if not found.\n// If not found, cursor position is undefined (caller should not read).\nfunc (c *Cursor) SeekRowid(rowid int64) (found bool, err error)\n\n// Close releases resources held by the cursor.\n// Unpins any held pages.\nfunc (c *Cursor) Close() error\n```\n\n### Expression Evaluation\n\n```go\n// EvaluateExpression evaluates an AST expression against a row.\n// Returns TVLBool for boolean expressions, Value for other expressions.\n// Context provides column access via ColumnCache.\nfunc EvaluateExpression(expr Expression, cache *ColumnCache) (Value, error)\n\n// EvaluatePredicate evaluates a boolean expression for WHERE clause.\n// Returns TVLTrue if row passes filter, TVLFalse or TVLNull if not.\nfunc EvaluatePredicate(expr Expression, cache *ColumnCache) TVLBool\n```\n\n### Execution Handlers\n\n```go\n// ExecuteColumn handles OpColumn: reads a column into a register.\n// Uses cursor's current row and column cache for lazy deserialization.\nfunc (vm *VM) ExecuteColumn(instr Instruction) error\n\n// ExecuteResultRow handles OpResultRow: outputs current result row.\n// Calls the Output callback with register values.\nfunc (vm *VM) ExecuteResultRow(instr Instruction) error\n\n// ExecuteInsert handles OpInsert: inserts a row into a table.\n// Checks NOT NULL constraints before insertion.\nfunc (vm *VM) ExecuteInsert(instr Instruction) error\n\n// ExecuteDelete handles OpDelete: deletes the current row.\nfunc (vm *VM) ExecuteDelete(instr Instruction) error\n```\n\n---\n\n## Algorithm Specification\n\n### Cursor First (Navigate to Leftmost Row)\n\n\n![Three-Valued Logic Truth Tables](./diagrams/tdd-diag-23.svg)\n\n\n```\nALGORITHM: Cursor.First\nINPUT: Cursor c with B-tree reference\nOUTPUT: Cursor positioned at first row, or AtEnd=true if empty\n\n1. // Start at root\n   pageID := c.Tree.RootPageID\n\n2. // Navigate to leftmost leaf\n   WHILE true:\n     a. page, err := c.Tree.BufferPool.FetchPage(pageID)\n        IF err != nil:\n          RETURN err\n     \n     b. pageType := page.Type()\n     \n     c. IF pageType.IsLeaf():\n        // Found leaf - position at first cell\n        c.CurrentPage = page\n        c.PageID = pageID\n        c.CellIndex = 0\n        \n        IF page.CellCount() == 0:\n          // Empty table\n          c.AtEnd = true\n          page.Unpin(false)\n          RETURN nil\n        \n        // Load first cell\n        offset := page.CellPointer(0)\n        c.Rowid, c.Record, _, _ = page.ReadTableLeafCell(int(offset))\n        c.AtEnd = false\n        RETURN nil\n     \n     d. // Internal page: go to leftmost child\n        childPageNum := page.FindChildPage(-1 << 63)  // Smallest possible rowid\n        page.Unpin(false)\n        pageID = PageID{PageNum: int(childPageNum)}\n\nPOST-CONDITIONS:\n   - If AtEnd is false, cursor points to first row\n   - CurrentPage is pinned (caller must unpin via Close or Next)\n   - Rowid and Record are loaded\n```\n\n### Cursor Next (Advance to Next Row)\n\n```\nALGORITHM: Cursor.Next\nINPUT: Cursor c positioned at a valid row\nOUTPUT: Cursor advanced to next row, or AtEnd=true if no more\n\n1. IF c.AtEnd:\n     RETURN nil  // Already at end\n\n2. // Advance within current page\n   c.CellIndex++\n\n3. IF c.CellIndex < int(c.CurrentPage.CellCount()):\n     // More cells in this page\n     offset := c.CurrentPage.CellPointer(c.CellIndex)\n     c.Rowid, c.Record, _, _ = c.CurrentPage.ReadTableLeafCell(int(offset))\n     RETURN nil\n\n4. // Need to move to next leaf page\n   // SQLite table B-trees don't link leaves, so we navigate via parent\n   // Simplified: for single-level trees, we're done\n   // Full implementation would track parent path\n   \n   c.AtEnd = true\n   c.CurrentPage.Unpin(false)\n   c.CurrentPage = nil\n   RETURN nil\n\nPOST-CONDITIONS:\n   - If AtEnd is false, cursor points to next row in rowid order\n   - If AtEnd is true, cursor resources are released\n```\n\n### Expression Evaluation with Three-Valued Logic\n\n\n![Cursor State Machine](./diagrams/tdd-diag-24.svg)\n\n\n```\nALGORITHM: EvaluateExpression\nINPUT: Expression AST expr, ColumnCache cache\nOUTPUT: Value (may be NULL)\n\n1. SWITCH on expr type:\n\n   CASE LiteralExpression:\n     IF expr.Value == nil:\n       RETURN Value{Type: ValueNull}\n     SWITCH v := expr.Value.(type):\n       CASE int64:\n         RETURN Value{Type: ValueInteger, Int: v}\n       CASE float64:\n         RETURN Value{Type: ValueReal, Float: v}\n       CASE string:\n         RETURN Value{Type: ValueText, Str: v}\n       CASE []byte:\n         RETURN Value{Type: ValueBlob, Bytes: v}\n\n   CASE IdentifierExpression:\n     // Column reference\n     colIndex := schema.GetColumnIndex(tableName, expr.Name)\n     RETURN cache.GetColumn(colIndex)\n\n   CASE BinaryExpression:\n     left := EvaluateExpression(expr.Left, cache)\n     right := EvaluateExpression(expr.Right, cache)\n     \n     SWITCH expr.Operator:\n       CASE \"AND\":\n         return TVLAndToValue(left, right)\n       CASE \"OR\":\n         return TVLOrToValue(left, right)\n       CASE \"=\", \"<>\", \"!=\", \"<\", \"<=\", \">\", \">=\":\n         return CompareToValue(expr.Operator, left, right)\n       CASE \"+\", \"-\", \"*\", \"/\":\n         return ArithmeticOp(expr.Operator, left, right)\n       CASE \"||\":\n         return ConcatOp(left, right)\n\n   CASE UnaryExpression:\n     operand := EvaluateExpression(expr.Operand, cache)\n     IF expr.Operator == \"NOT\":\n       return TVLNotToValue(operand)\n     IF expr.Operator == \"-\":\n       return NegateValue(operand)\n\n   CASE IsNullExpression:\n     val := EvaluateExpression(expr.Expression, cache)\n     result := val.IsNull()\n     IF expr.Negated:  // IS NOT NULL\n       result = !result\n     RETURN BoolToValue(result)\n\n   CASE InExpression:\n     val := EvaluateExpression(expr.Expression, cache)\n     found := false\n     hasNull := false\n     FOR _, listVal := range expr.Values:\n       item := EvaluateExpression(listVal, cache)\n       cmp := CompareValues(val, item)\n       IF cmp == CompareEqual:\n         found = true\n       IF cmp == CompareNull:\n         hasNull = true\n     \n     IF found:\n       RETURN BoolToValue(!expr.Negated)\n     IF hasNull:\n       RETURN Value{Type: ValueNull}  // Result is unknown\n     RETURN BoolToValue(expr.Negated)  // Not found, no NULLs\n\n   CASE BetweenExpression:\n     val := EvaluateExpression(expr.Expression, cache)\n     low := EvaluateExpression(expr.Low, cache)\n     high := EvaluateExpression(expr.High, cache)\n     \n     cmpLow := CompareValues(val, low)\n     cmpHigh := CompareValues(val, high)\n     \n     // NULL involvement makes result NULL\n     IF cmpLow == CompareNull || cmpHigh == CompareNull:\n       RETURN Value{Type: ValueNull}\n     \n     inRange := cmpLow >= CompareEqual && cmpHigh <= CompareEqual\n     IF expr.Negated:\n       inRange = !inRange\n     RETURN BoolToValue(inRange)\n\n   CASE LikeExpression:\n     val := EvaluateExpression(expr.Expression, cache)\n     pattern := EvaluateExpression(expr.Pattern, cache)\n     \n     IF val.IsNull() || pattern.IsNull():\n       RETURN Value{Type: ValueNull}\n     \n     matched := matchLikePattern(val.Str, pattern.Str)\n     IF expr.Negated:\n       matched = !matched\n     RETURN BoolToValue(matched)\n\n   CASE FunctionCallExpression:\n     // Handle aggregate functions specially (COUNT, SUM, etc.)\n     // For now, just evaluate arguments\n     args := make([]Value, len(expr.Args))\n     FOR i, arg := range expr.Args:\n       args[i] = EvaluateExpression(arg, cache)\n     RETURN EvaluateFunction(expr.Name, args)\n\n// Helper: Convert comparison to Value\nfunc CompareToValue(op string, left, right Value) Value {\n   cmp := CompareValues(left, right)\n   \n   IF cmp == CompareNull:\n     RETURN Value{Type: ValueNull}  // NULL comparison\n   \n   result := false\n   SWITCH op:\n     CASE \"=\":  result = (cmp == CompareEqual)\n     CASE \"<>\": result = (cmp != CompareEqual)\n     CASE \"!=\": result = (cmp != CompareEqual)\n     CASE \"<\":  result = (cmp == CompareLess)\n     CASE \"<=\": result = (cmp == CompareLess || cmp == CompareEqual)\n     CASE \">\":  result = (cmp == CompareGreater)\n     CASE \">=\": result = (cmp == CompareGreater || cmp == CompareEqual)\n   \n   RETURN BoolToValue(result)\n}\n```\n\n### WHERE Clause Evaluation\n\n\n![Column Deserialization Algorithm](./diagrams/tdd-diag-25.svg)\n\n\n```\nALGORITHM: EvaluatePredicate\nINPUT: Expression expr (boolean expression), ColumnCache cache\nOUTPUT: TVLBool (TVLTrue, TVLFalse, or TVLNull)\n\n1. val := EvaluateExpression(expr, cache)\n\n2. IF val.IsNull():\n     RETURN TVLNull\n\n3. IF val.IsTruthy():\n     RETURN TVLTrue\n\n4. RETURN TVLFalse\n\n// WHERE clause filtering in VM:\n// IF EvaluatePredicate(whereExpr, cache) == TVLTrue:\n//   // Row passes filter, include in result\n// ELSE:\n//   // Row does not pass (FALSE or NULL), skip\n```\n\n### INSERT Execution\n\n```\nALGORITHM: ExecuteInsert\nINPUT: VM with OpInsert instruction\nOUTPUT: Row inserted or error\n\n1. cursor := vm.Cursors[instr.P1]\n   recordReg := instr.P2\n   rowidReg := instr.P3\n\n2. // Get record and rowid from registers\n   record := vm.Registers[recordReg].Bytes\n   rowid := vm.Registers[rowidReg].Int\n\n3. // Get table schema\n   schema := vm.GetTableSchema(cursor.Tree.TableName)\n\n4. // Deserialize record to check constraints\n   values, err := DeserializeRow(record)\n   IF err != nil:\n     RETURN err\n\n5. // Check NOT NULL constraints\n   FOR i, col := range schema.Columns:\n     IF col.NotNull && values[i] == nil:\n       RETURN ConstraintError{\n         Type:    \"NOT NULL\",\n         Table:   cursor.Tree.TableName,\n         Column:  col.Name,\n       }\n\n6. // Check UNIQUE constraints (via indexes)\n   FOR _, idx := range schema.Indexes:\n     IF idx.IsUnique:\n       colValue := values[idx.ColumnIndex]\n       exists := idx.Find(colValue)\n       IF exists:\n         RETURN ConstraintError{\n           Type:    \"UNIQUE\",\n           Table:   cursor.Tree.TableName,\n           Column:  idx.ColumnName,\n         }\n\n7. // Insert into table B-tree\n   err := cursor.Tree.Insert(rowid, record)\n   IF err != nil:\n     RETURN err\n\n8. // Update indexes\n   FOR _, idx := range schema.Indexes:\n     colValue := values[idx.ColumnIndex]\n     idx.Insert(colValue, rowid)\n\n9. RETURN nil\n```\n\n### DELETE Execution\n\n```\nALGORITHM: ExecuteDelete\nINPUT: VM with OpDelete instruction, cursor positioned at row to delete\nOUTPUT: Row deleted\n\n1. cursor := vm.Cursors[instr.P1]\n\n2. IF cursor.AtEnd:\n     RETURN errors.New(\"cursor not positioned on a row\")\n\n3. // Get current row's values for index updates\n   values, _ := DeserializeRow(cursor.Record)\n\n4. // Delete from indexes first\n   schema := vm.GetTableSchema(cursor.Tree.TableName)\n   FOR _, idx := range schema.Indexes:\n     colValue := values[idx.ColumnIndex]\n     idx.Delete(colValue, cursor.Rowid)\n\n5. // Delete from table B-tree\n   err := cursor.Tree.Delete(cursor.Rowid)\n   IF err != nil:\n     RETURN err\n\n6. // Cursor position is now invalid\n   cursor.AtEnd = true\n\n7. RETURN nil\n```\n\n### UPDATE Execution (Delete + Reinsert)\n\n\n![DML Execution Flow](./diagrams/tdd-diag-26.svg)\n\n\n```\nALGORITHM: ExecuteUpdate\nINPUT: Table name, rowid, column updates map, WHERE clause\nOUTPUT: Number of rows updated\n\n1. tree := vm.GetTable(tableName)\n   schema := vm.GetTableSchema(tableName)\n\n2. updatedCount := 0\n   toUpdate := []UpdateInfo{}  // Collect updates to apply\n\n3. // First pass: collect matching rows\n   cursor := tree.NewCursor()\n   cursor.First()\n   \n   WHILE NOT cursor.AtEnd:\n     a. rowid, record := cursor.Current()\n     b. cache := NewColumnCache()\n        cache.SetRecord(record)\n     \n     c. // Check WHERE clause\n        IF whereClause != nil:\n          pred := EvaluatePredicate(whereClause, cache)\n          IF pred != TVLTrue:\n            cursor.Next()\n            CONTINUE\n     \n     d. // Deserialize current values\n        values, _ := DeserializeRow(record)\n     \n     e. // Apply updates\n        newValues := make([]interface{}, len(values))\n        copy(newValues, values)\n        \n        FOR colName, newVal := range updates:\n          colIndex := schema.GetColumnIndex(colName)\n          \n          // Check NOT NULL\n          IF schema.Columns[colIndex].NotNull && newVal == nil:\n            RETURN 0, ConstraintError{Type: \"NOT NULL\", Column: colName}\n          \n          newValues[colIndex] = newVal\n     \n     f. toUpdate = append(toUpdate, UpdateInfo{\n          Rowid:    rowid,\n          OldValues: values,\n          NewValues: newValues,\n        })\n     \n     g. cursor.Next()\n\n4. // Second pass: apply updates (can't modify during iteration)\n   FOR _, update := range toUpdate:\n     a. // Delete old row\n        tree.Delete(update.Rowid)\n     \n     b. // Update indexes\n        FOR _, idx := range schema.Indexes:\n          oldValue := update.OldValues[idx.ColumnIndex]\n          newValue := update.NewValues[idx.ColumnIndex]\n          IF CompareValues(oldValue, newValue) != CompareEqual:\n            idx.Delete(oldValue, update.Rowid)\n            idx.Insert(newValue, update.Rowid)\n     \n     c. // Insert new row\n        newRecord := SerializeRow(update.NewValues)\n        tree.Insert(update.Rowid, newRecord)\n     \n     d. updatedCount++\n\n5. RETURN updatedCount, nil\n```\n\n---\n\n## Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n|-------|-------------|----------|---------------|\n| Table does not exist | `GetTableTree` lookup | Return error immediately | Yes: \"no such table: {name}\" |\n| Column does not exist | `GetColumnIndex` lookup | Return error immediately | Yes: \"no such column: {table}.{column}\" |\n| NOT NULL constraint violation | `ExecuteInsert` validation | Reject INSERT/UPDATE | Yes: \"NOT NULL constraint failed: {table}.{column}\" |\n| UNIQUE constraint violation | Index lookup before insert | Reject INSERT/UPDATE | Yes: \"UNIQUE constraint failed: {table}.{column}\" |\n| NULL in comparison | `CompareValues` | Return NULL result | No: WHERE clause filters out NULL results |\n| Division by zero | Arithmetic operations | Return NULL value | No: SQL semantics (division by zero = NULL) |\n| Cursor not positioned | Cursor operations on AtEnd cursor | Return error | Yes: \"cursor is not positioned on a row\" |\n| Type mismatch in arithmetic | `ArithmeticOp` type check | Return NULL or error | Yes: \"cannot perform arithmetic on TEXT\" |\n| Record deserialization failure | `DeserializeRow` | Return error | Yes: \"corrupted record in table {name}\" |\n\n---\n\n## Implementation Sequence with Checkpoints\n\n### Phase 1: Cursor Abstraction and B-tree Traversal (2 hours)\n\n**Files to create**: `cursor.go`, `cursor_scan.go`, `cursor_seek.go`\n\n**Implementation**:\n1. Define `Cursor` struct with position state\n2. Implement `First()` to navigate to leftmost row\n3. Implement `Next()` to advance through rows\n4. Implement `SeekRowid()` for point lookups\n5. Implement `Close()` to release resources\n\n**Checkpoint**: At this point you should be able to scan a table. Run:\n```bash\ngo test -run TestCursorScan\n# Expected: PASS (cursor iterates through all rows)\n```\n\n### Phase 2: Column Deserialization with Lazy Access (2 hours)\n\n**Files to create**: `column_access.go`, `value.go`\n\n**Implementation**:\n1. Define `Value` type with NULL handling\n2. Implement `ColumnCache` for lazy deserialization\n3. Implement `GetColumn()` with header parsing\n4. Implement `ColumnCount()` for projection\n5. Add caching to avoid re-parsing\n\n**Checkpoint**: At this point you should deserialize columns on demand. Run:\n```bash\ngo test -run TestColumnAccess\n# Expected: PASS (lazy column access works, repeated access uses cache)\n```\n\n### Phase 3: Three-Valued Logic for Comparisons (1.5 hours)\n\n**Files to create**: `three_valued.go`\n\n**Implementation**:\n1. Define `TVLBool` type (TRUE, FALSE, NULL)\n2. Implement `CompareValues` with NULL handling\n3. Implement `TVLAnd`, `TVLOr`, `TVLNot`\n4. Implement comparison operators (=, <, >, etc.) with TVL\n5. Add truth tables as tests\n\n**Checkpoint**: At this point you should pass TVL tests. Run:\n```bash\ngo test -run TestThreeValuedLogic\n# Expected: PASS (NULL handling correct in all operators)\n```\n\n### Phase 4: WHERE Clause Evaluation (1.5 hours)\n\n**Files to create**: `expression_eval.go`\n\n**Implementation**:\n1. Implement `EvaluateExpression` for all expression types\n2. Implement `EvaluatePredicate` for WHERE clauses\n3. Handle special expressions (IN, BETWEEN, LIKE, IS NULL)\n4. Integrate TVL into evaluation\n5. Handle function calls (COUNT, etc.)\n\n**Checkpoint**: At this point you should evaluate WHERE clauses. Run:\n```bash\ngo test -run TestWhereEvaluation\n# Expected: PASS (WHERE filters rows correctly with NULL handling)\n```\n\n### Phase 5: INSERT Execution with Constraint Check (1.5 hours)\n\n**Files to create**: `insert_exec.go`, `constraint.go`\n\n**Implementation**:\n1. Implement `ExecuteInsert` opcode handler\n2. Implement NOT NULL constraint checking\n3. Implement UNIQUE constraint checking via indexes\n4. Integrate with B-tree insert\n5. Update indexes after insert\n\n**Checkpoint**: At this point you should insert rows with validation. Run:\n```bash\ngo test -run TestInsertExecution\n# Expected: PASS (INSERT works, constraints are enforced)\n```\n\n### Phase 6: UPDATE and DELETE Execution (1.5 hours)\n\n**Files to create**: `update_exec.go`, `delete_exec.go`\n\n**Implementation**:\n1. Implement `ExecuteDelete` opcode handler\n2. Implement two-pass UPDATE (collect then apply)\n3. Update indexes on delete/update\n4. Handle rowid changes (not allowed)\n5. Return affected row count\n\n**Checkpoint**: At this point you should pass the full test suite. Run:\n```bash\ngo test -v ./execution\n# Expected: All tests PASS\n# Verify: 10,000-row scan in < 100ms\n# Verify: WHERE evaluation in < 1μs per row\n```\n\n---\n\n## Test Specification\n\n```go\n// execution_test.go\n\nfunc TestCursorScan(t *testing.T) {\n    tree := createTestTree(100)  // 100 rows\n    \n    cursor := tree.NewCursor()\n    cursor.First()\n    \n    count := 0\n    var lastRowid int64 = -1\n    \n    for !cursor.AtEnd {\n        rowid, _ := cursor.Current()\n        assert.Greater(t, rowid, lastRowid)  // Ordered by rowid\n        lastRowid = rowid\n        count++\n        cursor.Next()\n    }\n    \n    assert.Equal(t, 100, count)\n}\n\nfunc TestColumnAccess(t *testing.T) {\n    record := SerializeRow([]interface{}{int64(42), \"hello\", nil, 3.14})\n    cache := NewColumnCache()\n    cache.SetRecord(record)\n    \n    // First access parses header\n    col0, err := cache.GetColumn(0)\n    assert.NoError(t, err)\n    assert.Equal(t, int64(42), col0.Int)\n    \n    // Subsequent access uses cache\n    col0Again, _ := cache.GetColumn(0)\n    assert.Equal(t, col0, col0Again)\n    \n    // Column 2 is NULL\n    col2, _ := cache.GetColumn(2)\n    assert.True(t, col2.IsNull())\n    \n    // Column 3 is float\n    col3, _ := cache.GetColumn(3)\n    assert.InDelta(t, 3.14, col3.Float, 0.001)\n}\n\nfunc TestThreeValuedLogic(t *testing.T) {\n    tests := []struct {\n        name     string\n        expr     string\n        left     Value\n        right    Value\n        expected TVLBool\n    }{\n        {\"NULL AND TRUE\", \"AND\", Value{Type: ValueNull}, Value{Type: ValueInteger, Int: 1}, TVLNull},\n        {\"NULL AND FALSE\", \"AND\", Value{Type: ValueNull}, Value{Type: ValueInteger, Int: 0}, TVLFalse},\n        {\"NULL OR TRUE\", \"OR\", Value{Type: ValueNull}, Value{Type: ValueInteger, Int: 1}, TVLTrue},\n        {\"NULL OR FALSE\", \"OR\", Value{Type: ValueNull}, Value{Type: ValueInteger, Int: 0}, TVLNull},\n        {\"NOT NULL\", \"NOT\", Value{Type: ValueNull}, Value{}, TVLNull},\n        {\"NULL = NULL\", \"=\", Value{Type: ValueNull}, Value{Type: ValueNull}, TVLNull},\n        {\"1 = 1\", \"=\", Value{Type: ValueInteger, Int: 1}, Value{Type: ValueInteger, Int: 1}, TVLTrue},\n        {\"1 = 2\", \"=\", Value{Type: ValueInteger, Int: 1}, Value{Type: ValueInteger, Int: 2}, TVLFalse},\n    }\n    \n    for _, tc := range tests {\n        t.Run(tc.name, func(t *testing.T) {\n            var result TVLBool\n            switch tc.expr {\n            case \"AND\":\n                result = TVLAnd(valueToTVL(tc.left), valueToTVL(tc.right))\n            case \"OR\":\n                result = TVLOr(valueToTVL(tc.left), valueToTVL(tc.right))\n            case \"NOT\":\n                result = TVLNot(valueToTVL(tc.left))\n            case \"=\":\n                cmp := CompareValues(tc.left, tc.right)\n                if cmp == CompareNull {\n                    result = TVLNull\n                } else {\n                    result = boolToTVL(cmp == CompareEqual)\n                }\n            }\n            assert.Equal(t, tc.expected, result)\n        })\n    }\n}\n\nfunc TestWhereEvaluation(t *testing.T) {\n    schema := createTestSchema()\n    \n    tests := []struct {\n        where    string\n        row      []interface{}\n        passes   bool\n    }{\n        {\"age > 18\", []interface{}{int64(1), \"Alice\", int64(25)}, true},\n        {\"age > 18\", []interface{}{int64(2), \"Bob\", int64(15)}, false},\n        {\"age > 18\", []interface{}{int64(3), \"Charlie\", nil}, false},  // NULL > 18 = NULL\n        {\"name = 'Alice'\", []interface{}{int64(1), \"Alice\", int64(25)}, true},\n        {\"name = NULL\", []interface{}{int64(1), \"Alice\", int64(25)}, false},  // Always false\n        {\"age IS NULL\", []interface{}{int64(3), \"Charlie\", nil}, true},\n        {\"age IS NOT NULL\", []interface{}{int64(1), \"Alice\", int64(25)}, true},\n    }\n    \n    for _, tc := range tests {\n        t.Run(tc.where, func(t *testing.T) {\n            ast := parseExpression(tc.where)\n            record := SerializeRow(tc.row)\n            cache := NewColumnCache()\n            cache.SetRecord(record)\n            \n            result := EvaluatePredicate(ast, cache)\n            \n            if tc.passes {\n                assert.Equal(t, TVLTrue, result)\n            } else {\n                assert.NotEqual(t, TVLTrue, result)  // FALSE or NULL\n            }\n        })\n    }\n}\n\nfunc TestInsertExecution(t *testing.T) {\n    vm := createTestVM()\n    \n    // Create table\n    vm.Execute(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT NOT NULL)\")\n    \n    // Valid insert\n    err := vm.Execute(\"INSERT INTO users VALUES (1, 'Alice')\")\n    assert.NoError(t, err)\n    \n    // NOT NULL violation\n    err = vm.Execute(\"INSERT INTO users VALUES (2, NULL)\")\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"NOT NULL constraint failed\")\n    \n    // Verify row was inserted\n    rows := vm.Query(\"SELECT * FROM users\")\n    assert.Len(t, rows, 1)\n}\n\nfunc TestDeleteExecution(t *testing.T) {\n    vm := createTestVM()\n    vm.Execute(\"CREATE TABLE users (id INTEGER, name TEXT)\")\n    vm.Execute(\"INSERT INTO users VALUES (1, 'Alice')\")\n    vm.Execute(\"INSERT INTO users VALUES (2, 'Bob')\")\n    \n    // Delete one row\n    err := vm.Execute(\"DELETE FROM users WHERE id = 1\")\n    assert.NoError(t, err)\n    \n    rows := vm.Query(\"SELECT * FROM users\")\n    assert.Len(t, rows, 1)\n    assert.Equal(t, \"Bob\", rows[0][1].Str)\n}\n\nfunc TestUpdateExecution(t *testing.T) {\n    vm := createTestVM()\n    vm.Execute(\"CREATE TABLE users (id INTEGER, name TEXT NOT NULL)\")\n    vm.Execute(\"INSERT INTO users VALUES (1, 'Alice')\")\n    vm.Execute(\"INSERT INTO users VALUES (2, 'Bob')\")\n    \n    // Update one row\n    err := vm.Execute(\"UPDATE users SET name = 'Alicia' WHERE id = 1\")\n    assert.NoError(t, err)\n    \n    rows := vm.Query(\"SELECT * FROM users WHERE id = 1\")\n    assert.Equal(t, \"Alicia\", rows[0][1].Str)\n    \n    // NOT NULL violation on update\n    err = vm.Execute(\"UPDATE users SET name = NULL WHERE id = 2\")\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"NOT NULL constraint failed\")\n}\n\nfunc TestPerformanceScan(t *testing.T) {\n    if testing.Short() {\n        t.Skip(\"Skipping performance test\")\n    }\n    \n    vm := createTestVM()\n    vm.Execute(\"CREATE TABLE t (id INTEGER, value TEXT)\")\n    \n    // Insert 10,000 rows\n    for i := 0; i < 10000; i++ {\n        vm.Execute(fmt.Sprintf(\"INSERT INTO t VALUES (%d, 'value%d')\", i, i))\n    }\n    \n    // Scan all rows\n    start := time.Now()\n    rows := vm.Query(\"SELECT * FROM t\")\n    elapsed := time.Since(start)\n    \n    assert.Len(t, rows, 10000)\n    assert.Less(t, elapsed.Milliseconds(), int64(100), \"10K scan should complete in < 100ms\")\n}\n\nfunc TestPerformanceWhere(t *testing.T) {\n    if testing.Short() {\n        t.Skip(\"Skipping performance test\")\n    }\n    \n    vm := createTestVM()\n    vm.Execute(\"CREATE TABLE t (id INTEGER, value INTEGER)\")\n    \n    // Insert 10,000 rows\n    for i := 0; i < 10000; i++ {\n        vm.Execute(fmt.Sprintf(\"INSERT INTO t VALUES (%d, %d)\", i, i%100))\n    }\n    \n    // Query with WHERE\n    start := time.Now()\n    rows := vm.Query(\"SELECT * FROM t WHERE value > 50\")\n    elapsed := time.Since(start)\n    \n    // Should filter approximately 4900 rows\n    assert.Greater(t, len(rows), 4000)\n    \n    // Per-row WHERE evaluation should be < 1μs\n    perRowTime := elapsed / time.Duration(10000)\n    assert.Less(t, perRowTime.Microseconds(), int64(1), \"WHERE eval should be < 1μs per row\")\n}\n\nfunc TestTableNotExist(t *testing.T) {\n    vm := createTestVM()\n    \n    err := vm.Execute(\"SELECT * FROM nonexistent\")\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"no such table\")\n    \n    err = vm.Execute(\"INSERT INTO nonexistent VALUES (1)\")\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"no such table\")\n}\n```\n\n---\n\n## Performance Targets\n\n| Operation | Target | How to Measure |\n|-----------|--------|----------------|\n| 10,000-row table scan | < 100ms | `go test -bench=BenchmarkScan10K` |\n| Single-row INSERT | < 1ms | `go test -bench=BenchmarkInsert` |\n| WHERE evaluation | < 1μs per row | `go test -bench=BenchmarkWhereEval` |\n| Column access (cached) | < 50ns | `go test -bench=BenchmarkColumnAccess` |\n| TVL comparison | < 100ns | `go test -bench=BenchmarkTVL` |\n| NULL handling overhead | < 10% vs non-NULL | Compare benchmarks with/without NULLs |\n\n---\n\n## Synced Criteria\n\n[[CRITERIA_JSON: {\"module_id\": \"build-sqlite-m6\", \"criteria\": [\"SELECT * returns all rows by iterating through the B-tree leaf sequence\", \"SELECT with column names correctly projects only the requested fields\", \"WHERE clause correctly filters rows using Three-Valued Logic (handling NULLs)\", \"INSERT adds a new row and updates the B-tree structure correctly\", \"UPDATE and DELETE modify/remove rows while maintaining B-tree integrity\", \"NOT NULL constraints reject invalid writes with a descriptive error\", \"Attempting to query a table not in the System Catalog returns an 'undefined table' error\"]}]\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-sqlite-m7 -->\n# Technical Design Specification: Secondary Indexes\n\n## Module Charter\n\nThe Secondary Indexes module implements B+tree indexes that map (column value, rowid) pairs to table rows, enabling O(log n) lookups instead of O(n) table scans. It provides CREATE INDEX construction from existing table data, automatic synchronous index maintenance on all DML operations (INSERT/UPDATE/DELETE), equality lookup via index seek, range scan via linked leaf traversal, UNIQUE constraint enforcement with duplicate detection, and the double-lookup pattern (index → rowid → table row). The module does NOT choose when to use indexes (that's the query planner), modify table data directly, or handle concurrent index creation—it maintains index structures in response to DML. Upstream dependencies: DML operations (INSERT/UPDATE/DELETE), CREATE INDEX statement. Downstream dependencies: B+tree page format (index leaf/internal pages), Buffer Pool (page caching), Query Planner (index selection). Invariants: index entries are always (column value, rowid) pairs; index leaf pages are linked for range scans; indexes are updated synchronously with table modifications; UNIQUE indexes reject duplicate column values.\n\n---\n\n## File Structure\n\n```\nindex/\n├── index.go              # (1) Index struct with metadata and root page reference\n├── index_leaf.go         # (2) Index B+tree leaf cell format (value, rowid)\n├── index_internal.go     # (3) Index B+tree internal page operations\n├── index_cursor.go       # (4) IndexCursor with leaf linking for range scans\n├── create_index.go       # (5) CREATE INDEX from existing table scan\n├── index_lookup.go       # (6) Equality lookup returning rowids\n├── index_range.go        # (7) Range scan via linked leaf traversal\n├── index_maintenance.go  # (8) INSERT/UPDATE/DELETE index update hooks\n├── unique_constraint.go  # (9) UNIQUE constraint checking\n├── index_test.go         # (10) Comprehensive test suite\n└── double_lookup.go      # (11) Index → table row fetch pattern\n```\n\n---\n\n## Complete Data Model\n\n### Index Structure\n\n```go\n// index.go\n\ntype Index struct {\n    Name        string    // Index name\n    TableName   string    // Table being indexed\n    ColumnName  string    // Column being indexed (single-column for now)\n    RootPageID  PageID    // Root page of the index B+tree\n    IsUnique    bool      // TRUE for UNIQUE indexes\n    BufferPool  *BufferPool\n}\n\n// Index entry stored in B+tree leaves\n// Format: (column_value, rowid) pair\n// The composite key ensures:\n// - Entries sorted by column value first\n// - Duplicate values sorted by rowid (important for non-unique indexes)\n// - Every entry unique even if column values aren't\ntype IndexEntry struct {\n    Value  Value    // Indexed column value\n    Rowid  int64    // Rowid of the table row\n}\n\n// WHY Index struct:\n// - Name/TableName/ColumnName: Schema metadata for lookups\n// - RootPageID: Entry point for B+tree operations\n// - IsUnique: Enables constraint checking on INSERT/UPDATE\n// - BufferPool: Required for page access during index operations\n\n// IndexManager tracks all indexes for a database\ntype IndexManager struct {\n    indexes     map[string]*Index  // index name -> Index\n    tableIndex  map[string][]string // table name -> index names\n    bufferPool  *BufferPool\n    catalog     *Catalog\n}\n\nfunc NewIndexManager(bufferPool *BufferPool, catalog *Catalog) *IndexManager {\n    return &IndexManager{\n        indexes:    make(map[string]*Index),\n        tableIndex: make(map[string][]string),\n        bufferPool: bufferPool,\n        catalog:    catalog,\n    }\n}\n\n// GetTableIndexes returns all indexes for a table\nfunc (im *IndexManager) GetTableIndexes(tableName string) []*Index {\n    names := im.tableIndex[tableName]\n    indexes := make([]*Index, 0, len(names))\n    for _, name := range names {\n        if idx, exists := im.indexes[name]; exists {\n            indexes = append(indexes, idx)\n        }\n    }\n    return indexes\n}\n```\n\n### Index B+tree Leaf Cell Format\n\n\n![Index Entry Format](./diagrams/tdd-diag-27.svg)\n\n\n```go\n// index_leaf.go\n\n// Index leaf cell format:\n// ┌─────────────┬────────────────┬───────────────────┬─────────────────┐\n// │ Payload Size│ Payload        │ Rowid             │ Right Sibling    │\n// │ (varint)    │ (serialized    │ (varint)          │ (4 bytes, in     │\n// │             │  column value) │                   │  page header)    │\n// └─────────────┴────────────────┴───────────────────┴─────────────────┘\n\n// The payload contains the serialized indexed column value.\n// For a TEXT column, payload = serial_type + text bytes\n// For an INTEGER column, payload = serial_type + integer bytes\n\n// ReadIndexLeafCell reads an index leaf cell at the given offset.\nfunc (p *Page) ReadIndexLeafCell(offset int) (payload []byte, rowid int64, consumed int, err error) {\n    pos := offset\n    \n    // Read payload size\n    payloadSize, n := ReadVarint(p.data, pos)\n    if n == 0 {\n        return nil, 0, 0, errors.New(\"invalid cell: cannot read payload size\")\n    }\n    pos += n\n    \n    // Read payload (serialized column value)\n    if pos+int(payloadSize) > PageSize {\n        return nil, 0, 0, fmt.Errorf(\"payload overflow: %d bytes\", payloadSize)\n    }\n    payload = make([]byte, payloadSize)\n    copy(payload, p.data[pos:pos+int(payloadSize)])\n    pos += int(payloadSize)\n    \n    // Read rowid (at the end for index cells, not part of sort key)\n    rowid, n = ReadVarint(p.data, pos)\n    if n == 0 {\n        return nil, 0, 0, errors.New(\"invalid cell: cannot read rowid\")\n    }\n    pos += n\n    \n    return payload, rowid, pos - offset, nil\n}\n\n// WriteIndexLeafCell writes an index leaf cell at the given offset.\nfunc (p *Page) WriteIndexLeafCell(offset int, payload []byte, rowid int64) (int, error) {\n    pos := offset\n    payloadSize := int64(len(payload))\n    \n    // Write payload size\n    n := WriteVarintTo(p.data, pos, payloadSize)\n    pos += n\n    \n    // Write payload\n    copy(p.data[pos:], payload)\n    pos += len(payload)\n    \n    // Write rowid\n    n = WriteVarintTo(p.data, pos, rowid)\n    pos += n\n    \n    p.isDirty = true\n    return pos - offset, nil\n}\n\n// IndexCellSize calculates the size needed for an index leaf cell.\nfunc IndexCellSize(payload []byte, rowid int64) int {\n    return VarintSize(int64(len(payload))) + len(payload) + VarintSize(rowid)\n}\n\n// RightSibling returns the right-sibling page number (leaf linking).\n// Stored in a special location for index leaf pages.\nfunc (p *Page) RightSibling() uint32 {\n    if p.Type() != PageTypeIndexLeaf {\n        return 0\n    }\n    // SQLite stores right-sibling at offset 8 in index leaf header\n    // (reusing space that would be RightMostPointer in internal pages)\n    return binary.BigEndian.Uint32(p.data[8:12])\n}\n\nfunc (p *Page) SetRightSibling(pageNum uint32) {\n    if p.Type() == PageTypeIndexLeaf {\n        binary.BigEndian.PutUint32(p.data[8:12], pageNum)\n        p.isDirty = true\n    }\n}\n\n// WHY right-sibling linking:\n// - Enables O(1) next-leaf access during range scans\n// - Without linking, range scan requires parent navigation per leaf\n// - B+tree design choice: trade page header space for scan performance\n```\n\n### Index B+tree Internal Cell Format\n\n```go\n// index_internal.go\n\n// Index internal cell format:\n// ┌─────────────┬────────────────┐\n// │ Left Child  │ Separator Key  │\n// │ (4 bytes)   │ (payload only) │\n// └─────────────┴────────────────┘\n// Note: Internal cells do NOT include rowid (only leaf cells do)\n\n// ReadIndexInternalCell reads an index internal cell.\nfunc (p *Page) ReadIndexInternalCell(offset int) (leftChild uint32, separatorPayload []byte, consumed int, err error) {\n    pos := offset\n    \n    // Read left child page number\n    if pos+4 > PageSize {\n        return 0, nil, 0, errors.New(\"invalid cell: truncated left child\")\n    }\n    leftChild = binary.BigEndian.Uint32(p.data[pos : pos+4])\n    pos += 4\n    \n    // Read payload size\n    payloadSize, n := ReadVarint(p.data, pos)\n    if n == 0 {\n        return 0, nil, 0, errors.New(\"invalid cell: cannot read payload size\")\n    }\n    pos += n\n    \n    // Read separator payload (no rowid in internal cells)\n    if pos+int(payloadSize) > PageSize {\n        return 0, nil, 0, fmt.Errorf(\"payload overflow: %d bytes\", payloadSize)\n    }\n    separatorPayload = make([]byte, payloadSize)\n    copy(separatorPayload, p.data[pos:pos+int(payloadSize)])\n    pos += int(payloadSize)\n    \n    return leftChild, separatorPayload, pos - offset, nil\n}\n\n// FindChildPage returns the child page for a given search key.\nfunc (p *Page) FindChildPageForIndex(searchPayload []byte) uint32 {\n    cellCount := int(p.CellCount())\n    \n    for i := 0; i < cellCount; i++ {\n        cellOffset := p.CellPointer(i)\n        _, separatorPayload, _, _ := p.ReadIndexInternalCell(int(cellOffset))\n        \n        // Compare search key to separator\n        cmp := CompareIndexPayloads(searchPayload, separatorPayload)\n        \n        if cmp < 0 {\n            // Search key < separator, go to left child\n            leftChild, _, _, _ := p.ReadIndexInternalCell(int(cellOffset))\n            return leftChild\n        }\n    }\n    \n    // Greater than or equal to all separators: use rightmost pointer\n    return p.RightMostPointer()\n}\n\n// CompareIndexPayloads compares two index payloads.\n// Returns -1, 0, or 1.\nfunc CompareIndexPayloads(a, b []byte) int {\n    // Deserialize both payloads to get the column values\n    valA := DeserializeIndexPayload(a)\n    valB := DeserializeIndexPayload(b)\n    \n    cmp := CompareValues(valA, valB)\n    switch cmp {\n    case CompareLess:\n        return -1\n    case CompareGreater:\n        return 1\n    default:\n        return 0\n    }\n}\n\n// DeserializeIndexPayload extracts the column value from an index payload.\nfunc DeserializeIndexPayload(payload []byte) Value {\n    if len(payload) == 0 {\n        return Value{Type: ValueNull}\n    }\n    \n    // Read serial type\n    serialType, n := ReadVarint(payload, 0)\n    if n == 0 {\n        return Value{Type: ValueNull}\n    }\n    \n    // Decode value\n    value, err := DecodeValue(SerialType(serialType), payload[n:])\n    if err != nil {\n        return Value{Type: ValueNull}\n    }\n    \n    // Convert to Value\n    switch v := value.(type) {\n    case nil:\n        return Value{Type: ValueNull}\n    case int64:\n        return Value{Type: ValueInteger, Int: v}\n    case float64:\n        return Value{Type: ValueReal, Float: v}\n    case string:\n        return Value{Type: ValueText, Str: v}\n    case []byte:\n        return Value{Type: ValueBlob, Bytes: v}\n    default:\n        return Value{Type: ValueNull}\n    }\n}\n\n// SerializeIndexPayload creates an index payload from a value.\nfunc SerializeIndexPayload(value Value) []byte {\n    var goValue interface{}\n    switch value.Type {\n    case ValueNull:\n        goValue = nil\n    case ValueInteger:\n        goValue = value.Int\n    case ValueReal:\n        goValue = value.Float\n    case ValueText:\n        goValue = value.Str\n    case ValueBlob:\n        goValue = value.Bytes\n    }\n    \n    serialType, body := EncodeSerialType(goValue)\n    \n    // Build payload: serial type + body\n    payload := make([]byte, 0)\n    payload = append(payload, WriteVarint(int64(serialType))...)\n    payload = append(payload, body...)\n    \n    return payload\n}\n```\n\n### Index Cursor with Leaf Linking\n\n```go\n// index_cursor.go\n\ntype IndexCursor struct {\n    Index       *Index\n    CurrentPage *Page\n    PageID      PageID\n    CellIndex   int\n    AtEnd       bool\n    \n    // Current entry (cached)\n    Payload     []byte\n    Rowid       int64\n    Value       Value  // Deserialized column value\n}\n\n// NewIndexCursor creates a cursor for index traversal.\nfunc (idx *Index) NewCursor() *IndexCursor {\n    return &IndexCursor{\n        Index: idx,\n    }\n}\n\n// First positions the cursor at the first index entry.\nfunc (c *IndexCursor) First() error {\n    pageID := c.Index.RootPageID\n    \n    // Navigate to leftmost leaf\n    for {\n        page, err := c.Index.BufferPool.FetchPage(pageID)\n        if err != nil {\n            return err\n        }\n        \n        if page.Type() == PageTypeIndexLeaf {\n            c.CurrentPage = page\n            c.PageID = pageID\n            c.CellIndex = 0\n            \n            if page.CellCount() == 0 {\n                c.AtEnd = true\n                page.Unpin(false)\n                return nil\n            }\n            \n            // Load first entry\n            offset := page.CellPointer(0)\n            c.Payload, c.Rowid, _, _ = page.ReadIndexLeafCell(int(offset))\n            c.Value = DeserializeIndexPayload(c.Payload)\n            c.AtEnd = false\n            return nil\n        }\n        \n        // Internal page: go to leftmost child\n        childPageNum := page.FindChildPageForIndex(nil) // nil = smallest\n        page.Unpin(false)\n        pageID = PageID{PageNum: int(childPageNum)}\n    }\n}\n\n// Next advances to the next index entry.\n// Uses leaf linking for efficient range scans.\nfunc (c *IndexCursor) Next() error {\n    if c.AtEnd {\n        return nil\n    }\n    \n    c.CellIndex++\n    \n    // Check if more cells in current leaf\n    if c.CellIndex < int(c.CurrentPage.CellCount()) {\n        offset := c.CurrentPage.CellPointer(c.CellIndex)\n        c.Payload, c.Rowid, _, _ = c.CurrentPage.ReadIndexLeafCell(int(offset))\n        c.Value = DeserializeIndexPayload(c.Payload)\n        return nil\n    }\n    \n    // Move to next leaf via right-sibling link\n    nextLeaf := c.CurrentPage.RightSibling()\n    c.CurrentPage.Unpin(false)\n    \n    if nextLeaf == 0 {\n        c.AtEnd = true\n        c.CurrentPage = nil\n        return nil\n    }\n    \n    // Load next leaf\n    page, err := c.Index.BufferPool.FetchPage(PageID{PageNum: int(nextLeaf)})\n    if err != nil {\n        return err\n    }\n    \n    c.CurrentPage = page\n    c.PageID = PageID{PageNum: int(nextLeaf)}\n    c.CellIndex = 0\n    \n    if page.CellCount() == 0 {\n        c.AtEnd = true\n        page.Unpin(false)\n        return nil\n    }\n    \n    offset := page.CellPointer(0)\n    c.Payload, c.Rowid, _, _ = page.ReadIndexLeafCell(int(offset))\n    c.Value = DeserializeIndexPayload(c.Payload)\n    \n    return nil\n}\n\n// Current returns the current index entry.\nfunc (c *IndexCursor) Current() (value Value, rowid int64) {\n    if c.AtEnd {\n        panic(\"cursor at end\")\n    }\n    return c.Value, c.Rowid\n}\n\n// Close releases cursor resources.\nfunc (c *IndexCursor) Close() {\n    if c.CurrentPage != nil {\n        c.CurrentPage.Unpin(false)\n        c.CurrentPage = nil\n    }\n}\n\n// WHY IndexCursor:\n// - Encapsulates index position state for VM\n// - Right-sibling linking enables O(1) leaf-to-leaf navigation\n// - Caches deserialized value to avoid repeated parsing\n// - Same pattern as table cursor for consistency\n```\n\n---\n\n## Interface Contracts\n\n### Index Creation\n\n```go\n// CreateIndex builds an index from existing table data.\n//\n// Parameters:\n//   - stmt: CREATE INDEX statement with name, table, column, unique flag\n//   - schema: Database schema for validation\n//\n// Returns:\n//   - *Index: Created index with root page\n//   - error: If table doesn't exist, column doesn't exist, or unique violation\n//\n// Pre-conditions:\n//   - Table must exist\n//   - Column must exist in table\n//   - Index name must be unique\n//\n// Post-conditions:\n//   - Index B+tree is populated with all existing rows\n//   - Index is registered in catalog\n//   - For UNIQUE index, no duplicate values exist\n//\n// Complexity: O(n log n) where n is table row count\nfunc (im *IndexManager) CreateIndex(stmt *CreateIndexStatement) (*Index, error)\n```\n\n### Index Lookup\n\n```go\n// FindEqual returns rowids matching an equality predicate.\n//\n// Parameters:\n//   - value: Column value to search for\n//\n// Returns:\n//   - []int64: Rowids of matching rows (may be multiple for non-unique)\n//   - error: If index seek fails\n//\n// Complexity: O(log n) for seek + O(k) for collecting matches\nfunc (idx *Index) FindEqual(value Value) ([]int64, error)\n\n// FindRange returns rowids within a value range.\n//\n// Parameters:\n//   - low: Lower bound (inclusive)\n//   - high: Upper bound (inclusive)\n//\n// Returns:\n//   - []int64: Rowids within range\n//   - error: If range scan fails\n//\n// Complexity: O(log n) for seek + O(m) for scan where m is result size\nfunc (idx *Index) FindRange(low, high Value) ([]int64, error)\n```\n\n### Index Maintenance\n\n```go\n// InsertEntry adds an entry to the index.\n// Called by INSERT operation after table row is inserted.\n//\n// Parameters:\n//   - value: Indexed column value\n//   - rowid: Rowid of the new table row\n//\n// Returns:\n//   - error: UNIQUE constraint violation for unique indexes\nfunc (idx *Index) InsertEntry(value Value, rowid int64) error\n\n// DeleteEntry removes an entry from the index.\n// Called by DELETE operation before table row is deleted.\n//\n// Parameters:\n//   - value: Indexed column value\n//   - rowid: Rowid of the row being deleted\nfunc (idx *Index) DeleteEntry(value Value, rowid int64) error\n\n// UpdateEntry updates an index entry.\n// Called by UPDATE when the indexed column changes.\n//\n// Parameters:\n//   - oldValue: Previous column value\n//   - newValue: New column value\n//   - rowid: Rowid of the updated row\n//\n// Returns:\n//   - error: UNIQUE constraint violation if new value conflicts\nfunc (idx *Index) UpdateEntry(oldValue, newValue Value, rowid int64) error\n```\n\n---\n\n## Algorithm Specification\n\n### CREATE INDEX from Table Scan\n\n\n![Double Lookup Pattern](./diagrams/tdd-diag-28.svg)\n\n\n```\nALGORITHM: CreateIndex\nINPUT: CreateIndexStatement (name, table, column, unique), Schema\nOUTPUT: Populated Index B+tree\n\n1. VALIDATE INPUT\n   a. Verify table exists in schema\n   b. Verify column exists in table\n   c. Verify index name is unique\n\n2. ALLOCATE ROOT PAGE\n   rootPageID := bufferPool.AllocatePage()\n   rootPage := bufferPool.FetchPage(rootPageID)\n   Initialize rootPage as empty index leaf (PageTypeIndexLeaf)\n   rootPage.Unpin(true)\n\n3. CREATE INDEX STRUCT\n   idx := &Index{\n     Name:       stmt.Name,\n     TableName:  stmt.TableName,\n     ColumnName: stmt.ColumnName,\n     RootPageID: rootPageID,\n     IsUnique:   stmt.Unique,\n   }\n\n4. SCAN TABLE AND POPULATE INDEX\n   tableTree := catalog.GetTableTree(stmt.TableName)\n   colIndex := schema.GetColumnIndex(stmt.TableName, stmt.ColumnName)\n   \n   cursor := tableTree.NewCursor()\n   cursor.First()\n   \n   WHILE NOT cursor.AtEnd:\n     a. rowid, record := cursor.Current()\n     \n     b. // Extract indexed column value\n        cache := NewColumnCache()\n        cache.SetRecord(record)\n        value, err := cache.GetColumn(colIndex)\n        IF err != nil:\n          RETURN nil, err\n     \n     c. // Check UNIQUE constraint\n        IF stmt.Unique:\n          existing, _ := idx.FindEqual(value)\n          IF len(existing) > 0:\n            RETURN nil, UniqueConstraintError{\n              Index:     stmt.Name,\n              Value:     value,\n              ExistingRowid: existing[0],\n            }\n     \n     d. // Insert into index B+tree\n        payload := SerializeIndexPayload(value)\n        err := idx.insertIntoBTree(payload, rowid)\n        IF err != nil:\n          RETURN nil, err\n     \n     e. cursor.Next()\n\n5. REGISTER INDEX\n   a. im.indexes[stmt.Name] = idx\n   b. im.tableIndex[stmt.TableName] = append(im.tableIndex[stmt.TableName], stmt.Name)\n   c. catalog.RecordIndex(stmt.Name, stmt.TableName, stmt.ColumnName, rootPageID)\n\n6. RETURN idx, nil\n\nCOMPLEXITY: O(n log n) for n table rows\nSPACE: O(n) index entries, ~1-2 pages per 100 rows depending on value size\n```\n\n### Index Equality Lookup\n\n\n![Index Range Scan via Leaf Links](./diagrams/tdd-diag-29.svg)\n\n\n```\nALGORITHM: Index.FindEqual\nINPUT: Value to search for\nOUTPUT: []int64 of matching rowids\n\n1. targetPayload := SerializeIndexPayload(value)\n   results := []int64{}\n\n2. // Navigate to leaf containing target\n   pageID := idx.RootPageID\n   \n   WHILE true:\n     a. page := bufferPool.FetchPage(pageID)\n     \n     b. IF page.Type() == PageTypeIndexLeaf:\n        // Found leaf - binary search for target\n        c.Cursor = &IndexCursor{Index: idx, CurrentPage: page, PageID: pageID}\n        found := c.seekToValue(value)\n        IF NOT found:\n          page.Unpin(false)\n          RETURN results, nil\n        BREAK\n     \n     c. // Internal page: find child\n        childPageNum := page.FindChildPageForIndex(targetPayload)\n        page.Unpin(false)\n        pageID = PageID{PageNum: int(childPageNum)}\n\n3. // Collect all matching entries (may span multiple cells)\n   WHILE NOT c.AtEnd:\n     a. currentValue, rowid := c.Current()\n     \n     b. // Compare values\n        cmp := CompareValues(currentValue, value)\n        IF cmp != 0:\n          BREAK  // Past matching range\n     \n     c. results = append(results, rowid)\n     d. c.Next()\n\n4. c.Close()\n   RETURN results, nil\n\nALGORITHM: IndexCursor.seekToValue\nINPUT: Target value\nOUTPUT: True if found, cursor positioned at first match\n\n1. // Binary search within leaf\n   cellCount := c.CurrentPage.CellCount()\n   low, high := 0, cellCount-1\n   \n   WHILE low <= high:\n     a. mid := (low + high) / 2\n     b. offset := c.CurrentPage.CellPointer(mid)\n     c. payload, rowid, _, _ := c.CurrentPage.ReadIndexLeafCell(int(offset))\n     d. midValue := DeserializeIndexPayload(payload)\n     \n     e. cmp := CompareValues(midValue, target)\n        IF cmp == 0:\n          // Found match - position cursor\n          c.CellIndex = mid\n          c.Payload = payload\n          c.Rowid = rowid\n          c.Value = midValue\n          RETURN true\n        ELSE IF cmp < 0:\n          low = mid + 1\n        ELSE:\n          high = mid - 1\n\n2. // Not found - position at insertion point\n   c.CellIndex = low\n   IF low < cellCount:\n     offset := c.CurrentPage.CellPointer(low)\n     c.Payload, c.Rowid, _, _ = c.CurrentPage.ReadIndexLeafCell(int(offset))\n     c.Value = DeserializeIndexPayload(c.Payload)\n   ELSE:\n     c.AtEnd = true\n   \n   RETURN false\n\nCOMPLEXITY: O(log n) for tree descent + O(log m) for leaf binary search\n           where n = total entries, m = entries per leaf\n```\n\n### Index Range Scan via Leaf Linking\n\n```\nALGORITHM: Index.FindRange\nINPUT: Low value (inclusive), High value (inclusive)\nOUTPUT: []int64 of rowids within range\n\n1. results := []int64{}\n   cursor := idx.NewCursor()\n\n2. // Seek to low value\n   found := cursor.seekToValue(low)\n   IF NOT found AND cursor.AtEnd:\n     RETURN results, nil  // Empty range\n\n3. // Scan forward until past high value\n   WHILE NOT cursor.AtEnd:\n     a. currentValue, rowid := cursor.Current()\n     \n     b. // Check if still in range\n        cmpHigh := CompareValues(currentValue, high)\n        IF cmpHigh > 0:\n          BREAK  // Past high end of range\n     \n     c. // Entry is in range\n        results = append(results, rowid)\n     \n     d. cursor.Next()\n\n4. cursor.Close()\n   RETURN results, nil\n\nCOMPLEXITY: O(log n) for seek + O(k) for scan where k = results\nKEY INSIGHT: Leaf linking enables sequential I/O for range scans\n            Each leaf transition is O(1), not O(log n)\n```\n\n### Index Maintenance on INSERT\n\n```go\n// index_maintenance.go\n\n// OnInsert is called after a row is inserted into the table.\n// Updates all indexes for the table.\nfunc (im *IndexManager) OnInsert(tableName string, values []interface{}, rowid int64) error {\n    indexes := im.GetTableIndexes(tableName)\n    schema := im.catalog.GetSchema(tableName)\n    \n    for _, idx := range indexes {\n        colIndex := schema.GetColumnIndex(idx.ColumnName)\n        value := values[colIndex]\n        \n        // Convert to Value type\n        val := interfaceToValue(value)\n        \n        // Check UNIQUE constraint\n        if idx.IsUnique {\n            existing, _ := idx.FindEqual(val)\n            if len(existing) > 0 {\n                return UniqueConstraintError{\n                    Table:  tableName,\n                    Column: idx.ColumnName,\n                    Value:  val,\n                }\n            }\n        }\n        \n        // Insert into index\n        if err := idx.InsertEntry(val, rowid); err != nil {\n            return err\n        }\n    }\n    \n    return nil\n}\n\n// InsertEntry adds an entry to the index B+tree.\nfunc (idx *Index) InsertEntry(value Value, rowid int64) error {\n    payload := SerializeIndexPayload(value)\n    return idx.insertIntoBTree(payload, rowid)\n}\n\nfunc (idx *Index) insertIntoBTree(payload []byte, rowid int64) error {\n    // Navigate to correct leaf\n    // Insert cell (payload, rowid)\n    // Handle split if necessary\n    // Similar to table B-tree insert but with index cell format\n    // ...\n}\n```\n\n### Index Maintenance on UPDATE\n\n```go\n// OnUpdate is called when a row is updated.\n// Only updates indexes for changed columns.\nfunc (im *IndexManager) OnUpdate(tableName string, oldValues, newValues []interface{}, rowid int64) error {\n    indexes := im.GetTableIndexes(tableName)\n    schema := im.catalog.GetSchema(tableName)\n    \n    for _, idx := range indexes {\n        colIndex := schema.GetColumnIndex(idx.ColumnName)\n        oldValue := interfaceToValue(oldValues[colIndex])\n        newValue := interfaceToValue(newValues[colIndex])\n        \n        // Skip if indexed column didn't change\n        if CompareValues(oldValue, newValue) == CompareEqual {\n            continue\n        }\n        \n        // Check UNIQUE constraint on new value\n        if idx.IsUnique {\n            existing, _ := idx.FindEqual(newValue)\n            if len(existing) > 0 && existing[0] != rowid {\n                return UniqueConstraintError{\n                    Table:  tableName,\n                    Column: idx.ColumnName,\n                    Value:  newValue,\n                }\n            }\n        }\n        \n        // Update index: delete old, insert new\n        if err := idx.DeleteEntry(oldValue, rowid); err != nil {\n            return err\n        }\n        if err := idx.InsertEntry(newValue, rowid); err != nil {\n            return err\n        }\n    }\n    \n    return nil\n}\n```\n\n### Index Maintenance on DELETE\n\n```go\n// OnDelete is called before a row is deleted from the table.\n// Removes entries from all indexes.\nfunc (im *IndexManager) OnDelete(tableName string, values []interface{}, rowid int64) error {\n    indexes := im.GetTableIndexes(tableName)\n    schema := im.catalog.GetSchema(tableName)\n    \n    for _, idx := range indexes {\n        colIndex := schema.GetColumnIndex(idx.ColumnName)\n        value := interfaceToValue(values[colIndex])\n        \n        if err := idx.DeleteEntry(value, rowid); err != nil {\n            return err\n        }\n    }\n    \n    return nil\n}\n\nfunc (idx *Index) DeleteEntry(value Value, rowid int64) error {\n    // Find the entry (value, rowid)\n    // Remove from B+tree\n    // Handle underflow if necessary (optional for initial implementation)\n    // ...\n}\n```\n\n### UNIQUE Constraint Enforcement\n\n```go\n// unique_constraint.go\n\ntype UniqueConstraintError struct {\n    Table   string\n    Column  string\n    Value   Value\n    Index   string  // For index-level errors\n    ExistingRowid int64\n}\n\nfunc (e UniqueConstraintError) Error() string {\n    if e.Index != \"\" {\n        return fmt.Sprintf(\"UNIQUE constraint failed: index %s, value %v\", e.Index, e.Value)\n    }\n    return fmt.Sprintf(\"UNIQUE constraint failed: %s.%s\", e.Table, e.Column)\n}\n\n// CheckUnique verifies no duplicate exists before insert.\nfunc (idx *Index) CheckUnique(value Value) (int64, bool) {\n    if !idx.IsUnique {\n        return 0, true  // Not a unique index, always OK\n    }\n    \n    existing, err := idx.FindEqual(value)\n    if err != nil {\n        return 0, false\n    }\n    \n    if len(existing) > 0 {\n        return existing[0], false  // Duplicate found\n    }\n    \n    return 0, true  // No duplicate\n}\n```\n\n### Double Lookup Pattern\n\n\n![Index Maintenance on DML](./diagrams/tdd-diag-30.svg)\n\n\n```go\n// double_lookup.go\n\n// DoubleLookup performs index lookup followed by table fetch.\n// This is the core pattern for index-driven queries.\ntype DoubleLookup struct {\n    IndexCursor  *IndexCursor\n    TableCursor  *Cursor\n    TableTree    *BTree\n}\n\n// NewDoubleLookup creates a double-lookup iterator.\nfunc NewDoubleLookup(idx *Index, tableTree *BTree) *DoubleLookup {\n    return &DoubleLookup{\n        IndexCursor: idx.NewCursor(),\n        TableTree:   tableTree,\n    }\n}\n\n// SeekEqual positions at rows matching an equality predicate.\nfunc (dl *DoubleLookup) SeekEqual(value Value) error {\n    found := dl.IndexCursor.seekToValue(value)\n    if !found {\n        dl.IndexCursor.AtEnd = true\n        return nil\n    }\n    return nil\n}\n\n// Next fetches the next matching row.\n// Returns (rowid, record, error).\nfunc (dl *DoubleLookup) Next() (int64, []byte, error) {\n    if dl.IndexCursor.AtEnd {\n        return 0, nil, io.EOF\n    }\n    \n    // Get rowid from index\n    _, rowid := dl.IndexCursor.Current()\n    \n    // Fetch row from table\n    dl.TableCursor = dl.TableTree.NewCursor()\n    found, err := dl.TableCursor.SeekRowid(rowid)\n    if err != nil {\n        return 0, nil, err\n    }\n    if !found {\n        // Row was deleted but index not updated - corruption\n        return 0, nil, fmt.Errorf(\"index corruption: rowid %d in index but not in table\", rowid)\n    }\n    \n    _, record := dl.TableCursor.Current()\n    dl.TableCursor.Close()\n    \n    // Advance index cursor\n    dl.IndexCursor.Next()\n    \n    return rowid, record, nil\n}\n\n// Close releases resources.\nfunc (dl *DoubleLookup) Close() {\n    dl.IndexCursor.Close()\n    if dl.TableCursor != nil {\n        dl.TableCursor.Close()\n    }\n}\n\n// WHY double lookup:\n// - Index gives O(log n) seek instead of O(n) scan\n// - Table fetch gets full row (index only has indexed column)\n// - Tradeoff: 2 B-tree traversals vs 1 full scan\n// - Break-even point: ~20% selectivity threshold\n// - Covering indexes avoid double lookup (future enhancement)\n```\n\n---\n\n## Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n|-------|-------------|----------|---------------|\n| UNIQUE constraint violation | `CheckUnique` before insert | Reject INSERT/UPDATE | Yes: \"UNIQUE constraint failed: {table}.{column}\" |\n| Table doesn't exist | `CreateIndex` validation | Return error immediately | Yes: \"no such table: {name}\" |\n| Column doesn't exist | `CreateIndex` validation | Return error immediately | Yes: \"no such column: {table}.{column}\" |\n| Index name conflict | `CreateIndex` validation | Return error immediately | Yes: \"index {name} already exists\" |\n| Index corruption (rowid in index but not table) | `DoubleLookup.Next` | Return error, suggest REINDEX | Yes: \"index corruption detected\" |\n| Page allocation failure | `insertIntoBTree` | Return error, rollback transaction | Yes: \"database or disk is full\" |\n\n---\n\n## Implementation Sequence with Checkpoints\n\n### Phase 1: Index B+tree Leaf and Internal Pages (2 hours)\n\n**Files to create**: `index_leaf.go`, `index_internal.go`\n\n**Implementation**:\n1. Implement `ReadIndexLeafCell` and `WriteIndexLeafCell`\n2. Implement `RightSibling`/`SetRightSibling` for leaf linking\n3. Implement `ReadIndexInternalCell`\n4. Implement `FindChildPageForIndex`\n5. Implement `SerializeIndexPayload` and `DeserializeIndexPayload`\n\n**Checkpoint**: At this point you should read/write index cells. Run:\n```bash\ngo test -run TestIndexCellFormat\n# Expected: PASS (index cell serialization works)\n```\n\n### Phase 2: CREATE INDEX from Table Scan (2 hours)\n\n**Files to create**: `create_index.go`, `index.go`\n\n**Implementation**:\n1. Implement `Index` struct and `IndexManager`\n2. Implement `CreateIndex` with table scan\n3. Implement index B-tree insertion\n4. Handle UNIQUE constraint during creation\n5. Register index in catalog\n\n**Checkpoint**: At this point you should create indexes. Run:\n```bash\ngo test -run TestCreateIndex\n# Expected: PASS (index created and populated from table)\n```\n\n### Phase 3: Index Equality and Range Lookup (1.5 hours)\n\n**Files to create**: `index_cursor.go`, `index_lookup.go`, `index_range.go`\n\n**Implementation**:\n1. Implement `IndexCursor` with leaf linking\n2. Implement `seekToValue` with binary search\n3. Implement `FindEqual` returning rowids\n4. Implement `FindRange` via leaf traversal\n5. Test cursor positioning\n\n**Checkpoint**: At this point you should look up values. Run:\n```bash\ngo test -run TestIndexLookup\n# Expected: PASS (equality and range lookups work)\n```\n\n### Phase 4: Index Maintenance on INSERT/UPDATE/DELETE (2 hours)\n\n**Files to create**: `index_maintenance.go`\n\n**Implementation**:\n1. Implement `OnInsert` hook for all table indexes\n2. Implement `OnUpdate` for changed columns only\n3. Implement `OnDelete` to remove index entries\n4. Integrate with DML execution layer\n5. Test consistency after operations\n\n**Checkpoint**: At this point indexes should stay consistent. Run:\n```bash\ngo test -run TestIndexMaintenance\n# Expected: PASS (indexes updated on DML)\n```\n\n### Phase 5: UNIQUE Constraint Enforcement (0.5 hours)\n\n**Files to create**: `unique_constraint.go`, `double_lookup.go`\n\n**Implementation**:\n1. Implement `CheckUnique` for constraint checking\n2. Implement `UniqueConstraintError`\n3. Implement `DoubleLookup` pattern\n4. Integrate UNIQUE check with INSERT/UPDATE\n5. Full test suite\n\n**Checkpoint**: At this point you should pass all tests. Run:\n```bash\ngo test -v ./index\n# Expected: All tests PASS\n# Verify: Index lookup faster than table scan for low selectivity\n# Verify: UNIQUE constraint rejects duplicates\n```\n\n---\n\n## Test Specification\n\n```go\n// index_test.go\n\nfunc TestCreateIndex(t *testing.T) {\n    // Create table with data\n    db := createTestDB()\n    db.Execute(\"CREATE TABLE users (id INTEGER, name TEXT, email TEXT)\")\n    for i := 0; i < 100; i++ {\n        db.Execute(fmt.Sprintf(\"INSERT INTO users VALUES (%d, 'user%d', 'user%d@example.com')\", i, i, i))\n    }\n    \n    // Create index\n    err := db.Execute(\"CREATE INDEX idx_email ON users(email)\")\n    assert.NoError(t, err)\n    \n    // Verify index exists\n    idx := db.IndexManager.GetIndex(\"idx_email\")\n    assert.NotNil(t, idx)\n    assert.Equal(t, \"users\", idx.TableName)\n    assert.Equal(t, \"email\", idx.ColumnName)\n}\n\nfunc TestIndexEqualityLookup(t *testing.T) {\n    db := createTestDBWithUsers(100)\n    db.Execute(\"CREATE INDEX idx_email ON users(email)\")\n    \n    idx := db.IndexManager.GetIndex(\"idx_email\")\n    \n    // Lookup existing value\n    rowids, err := idx.FindEqual(StringValue(\"user50@example.com\"))\n    assert.NoError(t, err)\n    assert.Len(t, rowids, 1)\n    assert.Equal(t, int64(50), rowids[0])\n    \n    // Lookup non-existent value\n    rowids, err = idx.FindEqual(StringValue(\"nonexistent@example.com\"))\n    assert.NoError(t, err)\n    assert.Len(t, rowids, 0)\n}\n\nfunc TestIndexRangeScan(t *testing.T) {\n    db := createTestDBWithUsers(100)\n    db.Execute(\"CREATE INDEX idx_id ON users(id)\")\n    \n    idx := db.IndexManager.GetIndex(\"idx_id\")\n    \n    // Range scan 20-30\n    rowids, err := idx.FindRange(IntegerValue(20), IntegerValue(30))\n    assert.NoError(t, err)\n    assert.Len(t, rowids, 11)  // 20 through 30 inclusive\n    \n    // Verify sorted order\n    for i := 0; i < len(rowids)-1; i++ {\n        assert.Less(t, rowids[i], rowids[i+1])\n    }\n}\n\nfunc TestIndexMaintenanceInsert(t *testing.T) {\n    db := createTestDBWithUsers(10)\n    db.Execute(\"CREATE INDEX idx_email ON users(email)\")\n    \n    // Insert new row\n    db.Execute(\"INSERT INTO users VALUES (100, 'newuser', 'new@example.com')\")\n    \n    idx := db.IndexManager.GetIndex(\"idx_email\")\n    \n    // Verify index updated\n    rowids, _ := idx.FindEqual(StringValue(\"new@example.com\"))\n    assert.Len(t, rowids, 1)\n    assert.Equal(t, int64(100), rowids[0])\n}\n\nfunc TestIndexMaintenanceUpdate(t *testing.T) {\n    db := createTestDBWithUsers(10)\n    db.Execute(\"CREATE INDEX idx_email ON users(email)\")\n    \n    // Update email\n    db.Execute(\"UPDATE users SET email = 'updated@example.com' WHERE id = 5\")\n    \n    idx := db.IndexManager.GetIndex(\"idx_email\")\n    \n    // Old value should not be in index\n    rowids, _ := idx.FindEqual(StringValue(\"user5@example.com\"))\n    assert.Len(t, rowids, 0)\n    \n    // New value should be in index\n    rowids, _ = idx.FindEqual(StringValue(\"updated@example.com\"))\n    assert.Len(t, rowids, 1)\n}\n\nfunc TestIndexMaintenanceDelete(t *testing.T) {\n    db := createTestDBWithUsers(10)\n    db.Execute(\"CREATE INDEX idx_email ON users(email)\")\n    \n    // Delete row\n    db.Execute(\"DELETE FROM users WHERE id = 5\")\n    \n    idx := db.IndexManager.GetIndex(\"idx_email\")\n    \n    // Deleted value should not be in index\n    rowids, _ := idx.FindEqual(StringValue(\"user5@example.com\"))\n    assert.Len(t, rowids, 0)\n}\n\nfunc TestUniqueConstraint(t *testing.T) {\n    db := createTestDB()\n    db.Execute(\"CREATE TABLE users (id INTEGER, email TEXT)\")\n    db.Execute(\"CREATE UNIQUE INDEX idx_unique_email ON users(email)\")\n    db.Execute(\"INSERT INTO users VALUES (1, 'alice@example.com')\")\n    \n    // Duplicate insert should fail\n    err := db.Execute(\"INSERT INTO users VALUES (2, 'alice@example.com')\")\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"UNIQUE constraint failed\")\n    \n    // Verify only one row exists\n    rows := db.Query(\"SELECT * FROM users\")\n    assert.Len(t, rows, 1)\n}\n\nfunc TestUniqueConstraintOnUpdate(t *testing.T) {\n    db := createTestDB()\n    db.Execute(\"CREATE TABLE users (id INTEGER, email TEXT)\")\n    db.Execute(\"CREATE UNIQUE INDEX idx_unique_email ON users(email)\")\n    db.Execute(\"INSERT INTO users VALUES (1, 'alice@example.com')\")\n    db.Execute(\"INSERT INTO users VALUES (2, 'bob@example.com')\")\n    \n    // Update to duplicate should fail\n    err := db.Execute(\"UPDATE users SET email = 'alice@example.com' WHERE id = 2\")\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"UNIQUE constraint failed\")\n}\n\nfunc TestDoubleLookup(t *testing.T) {\n    db := createTestDBWithUsers(100)\n    db.Execute(\"CREATE INDEX idx_email ON users(email)\")\n    \n    // Query using index\n    rows := db.Query(\"SELECT * FROM users WHERE email = 'user50@example.com'\")\n    assert.Len(t, rows, 1)\n    assert.Equal(t, int64(50), rows[0][0].Int)\n    assert.Equal(t, \"user50\", rows[0][1].Str)\n}\n\nfunc TestIndexPerformanceVsTableScan(t *testing.T) {\n    if testing.Short() {\n        t.Skip(\"Skipping performance test\")\n    }\n    \n    db := createTestDB()\n    db.Execute(\"CREATE TABLE users (id INTEGER, email TEXT)\")\n    for i := 0; i < 10000; i++ {\n        db.Execute(fmt.Sprintf(\"INSERT INTO users VALUES (%d, 'user%d@example.com')\", i, i))\n    }\n    db.Execute(\"CREATE INDEX idx_email ON users(email)\")\n    \n    // Measure table scan\n    db.ResetStats()\n    start := time.Now()\n    db.Query(\"SELECT * FROM users WHERE email = 'user9999@example.com'\")\n    scanTime := time.Since(start)\n    scanPages := db.Stats().PagesRead\n    \n    // Reset and measure index lookup\n    db.ResetStats()\n    start = time.Now()\n    // Query should use index (when planner is implemented)\n    // For now, manually test index lookup\n    idx := db.IndexManager.GetIndex(\"idx_email\")\n    rowids, _ := idx.FindEqual(StringValue(\"user9999@example.com\"))\n    indexTime := time.Since(start)\n    indexPages := db.Stats().PagesRead\n    \n    // Index should be significantly faster\n    assert.Less(t, indexPages, scanPages/10, \"Index should read far fewer pages\")\n    assert.Less(t, indexTime, scanTime/5, \"Index should be significantly faster\")\n    \n    // Verify result\n    assert.Len(t, rowids, 1)\n    assert.Equal(t, int64(9999), rowids[0])\n}\n\nfunc TestIndexOnNullValues(t *testing.T) {\n    db := createTestDB()\n    db.Execute(\"CREATE TABLE users (id INTEGER, email TEXT)\")\n    db.Execute(\"INSERT INTO users VALUES (1, 'alice@example.com')\")\n    db.Execute(\"INSERT INTO users VALUES (2, NULL)\")\n    db.Execute(\"INSERT INTO users VALUES (3, NULL)\")\n    \n    // Create index (should succeed with NULLs)\n    err := db.Execute(\"CREATE INDEX idx_email ON users(email)\")\n    assert.NoError(t, err)\n    \n    // NULL lookups\n    idx := db.IndexManager.GetIndex(\"idx_email\")\n    rowids, _ := idx.FindEqual(Value{Type: ValueNull})\n    assert.Len(t, rowids, 2)  // Both NULL rows\n}\n\nfunc TestUniqueIndexWithNulls(t *testing.T) {\n    db := createTestDB()\n    db.Execute(\"CREATE TABLE users (id INTEGER, email TEXT)\")\n    db.Execute(\"INSERT INTO users VALUES (1, NULL)\")\n    \n    // SQLite allows multiple NULLs in UNIQUE index\n    err := db.Execute(\"CREATE UNIQUE INDEX idx_email ON users(email)\")\n    assert.NoError(t, err)\n    \n    // Second NULL should be allowed (SQLite behavior)\n    err = db.Execute(\"INSERT INTO users VALUES (2, NULL)\")\n    assert.NoError(t, err)  // NULLs are distinct in UNIQUE index\n}\n```\n\n---\n\n## Performance Targets\n\n| Operation | Target | How to Measure |\n|-----------|--------|----------------|\n| Index equality lookup | O(log n) + 2 page reads | `go test -bench=BenchmarkIndexLookup` |\n| Index range scan | O(log n) + O(k) pages | `go test -bench=BenchmarkRangeScan` |\n| Index maintenance on INSERT | +50-200% vs no index | Compare INSERT with/without indexes |\n| Index maintenance on UPDATE | +50-200% if indexed column changes | Compare UPDATE on indexed vs non-indexed column |\n| CREATE INDEX on 10K rows | < 500ms | `go test -bench=BenchmarkCreateIndex` |\n| Double lookup vs table scan | < 10% of scan for 1% selectivity | `go test -bench=BenchmarkSelectivity` |\n\n---\n\n## Synced Criteria\n\n[[CRITERIA_JSON: {\"module_id\": \"build-sqlite-m7\", \"criteria\": [\"CREATE INDEX builds a B+tree mapping column values to rowids\", \"INSERT/UPDATE/DELETE operations maintain all associated indexes synchronously\", \"Index lookup (equality) avoids full table scan and visits significantly fewer pages\", \"Index range scan (BETWEEN or < >) traverses linked leaf pages\", \"UNIQUE index correctly rejects duplicate value insertions\", \"Bytecode VM can perform a 'Double Lookup' from index cursor to table cursor\"]}]\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-sqlite-m8 -->\n# Technical Design Specification: Query Planner & Statistics\n\n## Module Charter\n\nThe Query Planner transforms a parsed SELECT AST into an execution plan by estimating the cost of alternative access paths and selecting the cheapest. It implements ANALYZE to collect table statistics (row counts, distinct value counts per column), selectivity estimation for predicates, a cost model comparing sequential I/O (table scan) vs random I/O (index scan), and greedy join order optimization for multi-table queries. The planner does NOT execute queries, modify data, or guarantee optimal plans—it makes best-effort decisions with available statistics. Upstream dependencies: Parser (provides AST), Index Manager (provides index metadata), Storage (provides row counts). Downstream dependencies: Bytecode Compiler (receives QueryPlan). Invariants: all plans are executable (valid table/index references); cost estimates are non-negative; selectivity is always between 0 and 1; planner never modifies database state.\n\n---\n\n## File Structure\n\n```\nplanner/\n├── statistics.go         # (1) Statistics struct, storage, ANALYZE command\n├── stat_storage.go       # (2) sqlite_stat1 table persistence\n├── selectivity.go        # (3) Predicate selectivity estimation\n├── cost_model.go         # (4) Cost model for table scan vs index scan\n├── planner.go            # (5) Planner struct and PlanSelect entry point\n├── access_path.go        # (6) AccessPath interface and implementations\n├── query_plan.go         # (7) QueryPlan with cost and row estimates\n├── table_scan_path.go    # (8) TableScanPath implementation\n├── index_scan_path.go    # (9) IndexScanPath implementation\n├── join_planner.go       # (10) Join order optimization (greedy)\n├── explain.go            # (11) EXPLAIN output formatter\n├── planner_test.go       # (12) Comprehensive test suite\n└── defaults.go           # (13) Default assumptions without statistics\n```\n\n---\n\n## Complete Data Model\n\n### Statistics Structure\n\n```go\n// statistics.go\n\n// TableStatistics holds collected statistics for a single table.\ntype TableStatistics struct {\n    TableName     string\n    RowCount      int64                    // Total rows in table\n    PageCount     int64                    // Total pages (calculated from rows)\n    ColumnStats   map[string]*ColumnStats  // Column name -> statistics\n    LastAnalyzed  time.Time                // When ANALYZE was run\n}\n\n// ColumnStats holds statistics for a single column.\ntype ColumnStats struct {\n    ColumnName    string\n    DistinctCount int64    // Number of distinct values\n    NullCount     int64    // Number of NULL values\n    MinValue      Value    // Minimum value (for range estimation)\n    MaxValue      Value    // Maximum value (for range estimation)\n    \n    // Histogram buckets (optional, for advanced selectivity)\n    // Histogram     []HistogramBucket\n}\n\n// StatisticsManager manages statistics for all tables.\ntype StatisticsManager struct {\n    stats      map[string]*TableStatistics  // table name -> stats\n    storage    StatStorage\n    catalog    *Catalog\n}\n\nfunc NewStatisticsManager(storage StatStorage, catalog *Catalog) *StatisticsManager {\n    return &StatisticsManager{\n        stats:   make(map[string]*TableStatistics),\n        storage: storage,\n        catalog: catalog,\n    }\n}\n\n// GetTableStats returns statistics for a table, or default estimates.\nfunc (sm *StatisticsManager) GetTableStats(tableName string) *TableStatistics {\n    if stats, exists := sm.stats[tableName]; exists {\n        return stats\n    }\n    \n    // Try to load from storage\n    stats, err := sm.storage.Load(tableName)\n    if err == nil {\n        sm.stats[tableName] = stats\n        return stats\n    }\n    \n    // Return default estimates\n    return sm.defaultStats(tableName)\n}\n\n// defaultStats returns conservative default statistics.\nfunc (sm *StatisticsManager) defaultStats(tableName string) *TableStatistics {\n    return &TableStatistics{\n        TableName: tableName,\n        RowCount:  DefaultRowCount,      // 1000 rows\n        PageCount: DefaultPageCount,     // 50 pages\n        ColumnStats: make(map[string]*ColumnStats),\n    }\n}\n\n// WHY Statistics:\n// - RowCount: Base for all selectivity calculations\n// - DistinctCount: Enables equality predicate selectivity (1/distinct)\n// - PageCount: Drives I/O cost estimation\n// - Defaults: Enable planning even without ANALYZE\n```\n\n### Stat Storage (sqlite_stat1)\n\n```go\n// stat_storage.go\n\n// StatStorage persists statistics to sqlite_stat1 table.\ntype StatStorage interface {\n    Save(stats *TableStatistics) error\n    Load(tableName string) (*TableStatistics, error)\n    Delete(tableName string) error\n}\n\n// SQLiteStat1Storage implements StatStorage using sqlite_stat1 table.\ntype SQLiteStat1Storage struct {\n    db *Database\n}\n\n// sqlite_stat1 schema:\n// CREATE TABLE sqlite_stat1 (\n//     tbl TEXT,     -- Table name\n//     idx TEXT,     -- Index name (NULL for table stats)\n//     stat TEXT     -- Space-separated: \"rows distinct1 distinct2 ...\"\n// );\n\nfunc (s *SQLiteStat1Storage) Save(stats *TableStatistics) error {\n    // Build stat string: \"rowcount\"\n    statStr := fmt.Sprintf(\"%d\", stats.RowCount)\n    \n    // Delete existing entry\n    s.db.Execute(\"DELETE FROM sqlite_stat1 WHERE tbl = ? AND idx IS NULL\", stats.TableName)\n    \n    // Insert new entry\n    return s.db.Execute(\n        \"INSERT INTO sqlite_stat1 (tbl, idx, stat) VALUES (?, NULL, ?)\",\n        stats.TableName, statStr,\n    )\n}\n\nfunc (s *SQLiteStat1Storage) SaveIndexStats(tableName, indexName string, rowCount, distinctCount int64) error {\n    statStr := fmt.Sprintf(\"%d %d\", rowCount, distinctCount)\n    \n    s.db.Execute(\"DELETE FROM sqlite_stat1 WHERE tbl = ? AND idx = ?\", tableName, indexName)\n    \n    return s.db.Execute(\n        \"INSERT INTO sqlite_stat1 (tbl, idx, stat) VALUES (?, ?, ?)\",\n        tableName, indexName, statStr,\n    )\n}\n\nfunc (s *SQLiteStat1Storage) Load(tableName string) (*TableStatistics, error) {\n    rows, err := s.db.Query(\n        \"SELECT idx, stat FROM sqlite_stat1 WHERE tbl = ?\",\n        tableName,\n    )\n    if err != nil {\n        return nil, err\n    }\n    \n    stats := &TableStatistics{\n        TableName:   tableName,\n        ColumnStats: make(map[string]*ColumnStats),\n    }\n    \n    for _, row := range rows {\n        idxName := row[0].Str\n        statStr := row[1].Str\n        \n        parts := strings.Split(statStr, \" \")\n        if len(parts) < 1 {\n            continue\n        }\n        \n        rowCount, _ := strconv.ParseInt(parts[0], 10, 64)\n        stats.RowCount = rowCount\n        \n        if idxName == \"\" {\n            // Table-level stats\n            stats.PageCount = (rowCount + RowsPerPage - 1) / RowsPerPage\n        } else {\n            // Index stats\n            if len(parts) >= 2 {\n                distinctCount, _ := strconv.ParseInt(parts[1], 10, 64)\n                // Store in column stats (index maps to column)\n                stats.ColumnStats[idxName] = &ColumnStats{\n                    DistinctCount: distinctCount,\n                }\n            }\n        }\n    }\n    \n    if stats.RowCount == 0 {\n        return nil, errors.New(\"no statistics found\")\n    }\n    \n    return stats, nil\n}\n```\n\n### Selectivity Estimation\n\n```go\n// selectivity.go\n\n// SelectivityEstimator estimates predicate selectivity.\ntype SelectivityEstimator struct {\n    stats *StatisticsManager\n}\n\n// EstimateSelectivity returns the fraction of rows matching a predicate.\n// Returns a value between 0.0 and 1.0.\nfunc (se *SelectivityEstimator) EstimateSelectivity(\n    tableName string,\n    predicate Expression,\n) float64 {\n    if predicate == nil {\n        return 1.0  // No filter = all rows\n    }\n    \n    return se.estimateExpression(tableName, predicate)\n}\n\nfunc (se *SelectivityEstimator) estimateExpression(\n    tableName string,\n    expr Expression,\n) float64 {\n    switch e := expr.(type) {\n    case *BinaryExpression:\n        return se.estimateBinary(tableName, e)\n    \n    case *UnaryExpression:\n        if e.Operator == \"NOT\" {\n            // NOT flips selectivity\n            sel := se.estimateExpression(tableName, e.Operand)\n            return 1.0 - sel\n        }\n        return DefaultSelectivity\n    \n    case *ParenExpression:\n        return se.estimateExpression(tableName, e.Expression)\n    \n    case *InExpression:\n        // IN (a, b, c) selectivity = count / distinct\n        return se.estimateIn(tableName, e)\n    \n    case *BetweenExpression:\n        // BETWEEN selectivity: assume uniform distribution\n        return se.estimateBetween(tableName, e)\n    \n    case *IsNullExpression:\n        // IS NULL selectivity = null_count / row_count\n        return se.estimateIsNull(tableName, e)\n    \n    case *LikeExpression:\n        // LIKE selectivity: hard to estimate, use default\n        return DefaultLikeSelectivity\n    \n    default:\n        return DefaultSelectivity\n    }\n}\n\nfunc (se *SelectivityEstimator) estimateBinary(\n    tableName string,\n    expr *BinaryExpression,\n) float64 {\n    switch expr.Operator {\n    case \"AND\":\n        left := se.estimateExpression(tableName, expr.Left)\n        right := se.estimateExpression(tableName, expr.Right)\n        // Assume independence (may over/underestimate)\n        return left * right\n    \n    case \"OR\":\n        left := se.estimateExpression(tableName, expr.Left)\n        right := se.estimateExpression(tableName, expr.Right)\n        // P(A OR B) = P(A) + P(B) - P(A AND B)\n        return left + right - left*right\n    \n    case \"=\":\n        return se.estimateEquality(tableName, expr)\n    \n    case \"<>\", \"!=\":\n        // Not equal: 1 - equality selectivity\n        eqSel := se.estimateEquality(tableName, expr)\n        return 1.0 - eqSel\n    \n    case \"<\", \">\", \"<=\", \">=\":\n        return se.estimateRange(tableName, expr)\n    \n    default:\n        return DefaultSelectivity\n    }\n}\n\nfunc (se *SelectivityEstimator) estimateEquality(\n    tableName string,\n    expr *BinaryExpression,\n) float64 {\n    // Extract column name from left side\n    colName := extractColumnName(expr.Left)\n    if colName == \"\" {\n        return DefaultEqualitySelectivity\n    }\n    \n    stats := se.stats.GetTableStats(tableName)\n    colStats := stats.ColumnStats[colName]\n    \n    if colStats != nil && colStats.DistinctCount > 0 {\n        // Selectivity = 1 / distinct values\n        return 1.0 / float64(colStats.DistinctCount)\n    }\n    \n    // No statistics: use default\n    return DefaultEqualitySelectivity\n}\n\nfunc (se *SelectivityEstimator) estimateRange(\n    tableName string,\n    expr *BinaryExpression,\n) float64 {\n    // Range selectivity: assume 1/3 of rows\n    // Better: use histogram if available\n    return DefaultRangeSelectivity\n}\n\nfunc (se *SelectivityEstimator) estimateIn(\n    tableName string,\n    expr *InExpression,\n) float64 {\n    // IN (a, b, c) selectivity = min(count / distinct, 1.0)\n    count := len(expr.Values)\n    \n    colName := extractColumnName(expr.Expression)\n    if colName == \"\" {\n        return min(float64(count)*DefaultEqualitySelectivity, 1.0)\n    }\n    \n    stats := se.stats.GetTableStats(tableName)\n    colStats := stats.ColumnStats[colName]\n    \n    if colStats != nil && colStats.DistinctCount > 0 {\n        return min(float64(count)/float64(colStats.DistinctCount), 1.0)\n    }\n    \n    return min(float64(count)*DefaultEqualitySelectivity, 1.0)\n}\n\nfunc (se *SelectivityEstimator) estimateBetween(\n    tableName string,\n    expr *BetweenExpression,\n) float64 {\n    // BETWEEN a AND b: estimate fraction of range\n    // Without histograms, assume 10% selectivity\n    return DefaultRangeSelectivity\n}\n\nfunc (se *SelectivityEstimator) estimateIsNull(\n    tableName string,\n    expr *IsNullExpression,\n) float64 {\n    colName := extractColumnName(expr.Expression)\n    if colName == \"\" {\n        return DefaultNullSelectivity\n    }\n    \n    stats := se.stats.GetTableStats(tableName)\n    colStats := stats.ColumnStats[colName]\n    \n    if colStats != nil && stats.RowCount > 0 {\n        return float64(colStats.NullCount) / float64(stats.RowCount)\n    }\n    \n    return DefaultNullSelectivity\n}\n\n// Default selectivity constants\nconst (\n    DefaultSelectivity        = 0.1   // 10% for unknown predicates\n    DefaultEqualitySelectivity = 0.1  // 10% for = without stats\n    DefaultRangeSelectivity   = 0.33  // 33% for range predicates\n    DefaultLikeSelectivity    = 0.1   // 10% for LIKE\n    DefaultNullSelectivity    = 0.1   // 10% for IS NULL\n)\n\n// WHY selectivity estimation:\n// - Drives index vs table scan decision\n// - Equality: 1/distinct is the key insight\n// - AND/OR: independence assumption (may be wrong but workable)\n// - Defaults: Conservative estimates prevent catastrophically bad plans\n```\n\n### Cost Model\n\n```go\n// cost_model.go\n\n// CostModel estimates the I/O cost of different access paths.\ntype CostModel struct {\n    SequentialIOCost float64  // Cost per page for sequential read\n    RandomIOCost     float64  // Cost per page for random read\n    CPUCostPerRow    float64  // CPU cost per row processed\n}\n\nfunc NewDefaultCostModel() *CostModel {\n    return &CostModel{\n        SequentialIOCost: 1.0,   // Baseline\n        RandomIOCost:     10.0,  // Random I/O is ~10x slower\n        CPUCostPerRow:    0.01,  // Small CPU overhead per row\n    }\n}\n\n// TableScanCost estimates cost of full table scan.\nfunc (cm *CostModel) TableScanCost(tableStats *TableStatistics) float64 {\n    // Table scan reads all pages sequentially\n    ioCost := float64(tableStats.PageCount) * cm.SequentialIOCost\n    cpuCost := float64(tableStats.RowCount) * cm.CPUCostPerRow\n    return ioCost + cpuCost\n}\n\n// IndexScanCost estimates cost of index lookup + table fetch.\nfunc (cm *CostModel) IndexScanCost(\n    tableStats *TableStatistics,\n    selectivity float64,\n) float64 {\n    matchingRows := float64(tableStats.RowCount) * selectivity\n    \n    // Index traversal: log_f(n) pages (usually 3-4 for any size)\n    indexTraversalCost := 4.0 * cm.RandomIOCost\n    \n    // Table fetches: one random I/O per matching row\n    // But rows may cluster, so assume rowsPerPage rows per fetch\n    pagesRead := matchingRows / RowsPerPage\n    tableFetchCost := pagesRead * cm.RandomIOCost\n    \n    cpuCost := matchingRows * cm.CPUCostPerRow\n    \n    return indexTraversalCost + tableFetchCost + cpuCost\n}\n\n// WHY cost model:\n// - Sequential I/O (table scan) is much faster than random I/O\n// - Index scan trades fewer rows for random access pattern\n// - Break-even point: ~20% selectivity (configurable)\n// - Simple model captures the essential tradeoff\n```\n\n### Access Path and Query Plan\n\n```go\n// access_path.go\n\n// AccessPath represents a way to access table data.\ntype AccessPath interface {\n    PlanType() string\n    EstimatedRows() int64\n    EstimatedCost() float64\n}\n\n// TableScanPath represents a full table scan.\ntype TableScanPath struct {\n    TableName     string\n    EstimatedRows int64\n    Cost          float64\n}\n\nfunc (p *TableScanPath) PlanType() string    { return \"TABLE SCAN\" }\nfunc (p *TableScanPath) EstimatedRows() int64 { return p.EstimatedRows }\nfunc (p *TableScanPath) EstimatedCost() float64 { return p.Cost }\n\n// IndexScanPath represents an index-driven scan.\ntype IndexScanPath struct {\n    TableName     string\n    IndexName     string\n    Predicate     Expression  // Original predicate for index\n    Selectivity   float64\n    EstimatedRows int64\n    Cost          float64\n}\n\nfunc (p *IndexScanPath) PlanType() string    { return \"INDEX SCAN\" }\nfunc (p *IndexScanPath) EstimatedRows() int64 { return p.EstimatedRows }\nfunc (p *IndexScanPath) EstimatedCost() float64 { return p.Cost }\n\n// NestedLoopJoinPath represents a nested loop join.\ntype NestedLoopJoinPath struct {\n    Left          AccessPath\n    Right         AccessPath\n    JoinCondition Expression\n    EstimatedRows int64\n    Cost          float64\n}\n\nfunc (p *NestedLoopJoinPath) PlanType() string    { return \"NESTED LOOP JOIN\" }\nfunc (p *NestedLoopJoinPath) EstimatedRows() int64 { return p.EstimatedRows }\nfunc (p *NestedLoopJoinPath) EstimatedCost() float64 { return p.Cost }\n\n// query_plan.go\n\n// QueryPlan represents a complete execution plan.\ntype QueryPlan struct {\n    AccessPath     AccessPath\n    Projection     []string    // Columns to output\n    OrderBy        []OrderBySpec\n    Limit          *int\n    Offset         *int\n    EstimatedCost  float64\n    EstimatedRows  int64\n}\n\ntype OrderBySpec struct {\n    Column     string\n    Descending bool\n}\n```\n\n### Planner\n\n```go\n// planner.go\n\n// SelectivityThreshold for choosing index vs table scan.\nconst IndexSelectivityThreshold = 0.2  // 20%\n\n// Planner creates execution plans from SELECT ASTs.\ntype Planner struct {\n    stats         *StatisticsManager\n    costModel     *CostModel\n    catalog       *Catalog\n    indexManager  *IndexManager\n    selectivity   *SelectivityEstimator\n}\n\nfunc NewPlanner(\n    stats *StatisticsManager,\n    catalog *Catalog,\n    indexManager *IndexManager,\n) *Planner {\n    return &Planner{\n        stats:        stats,\n        costModel:    NewDefaultCostModel(),\n        catalog:      catalog,\n        indexManager: indexManager,\n        selectivity:  &SelectivityEstimator{stats: stats},\n    }\n}\n\n// PlanSelect creates an execution plan for a SELECT statement.\nfunc (p *Planner) PlanSelect(stmt *SelectStatement) (*QueryPlan, error) {\n    // Validate table exists\n    tableSchema := p.catalog.GetSchema(stmt.FromTable)\n    if tableSchema == nil {\n        return nil, fmt.Errorf(\"no such table: %s\", stmt.FromTable)\n    }\n    \n    // Get table statistics\n    tableStats := p.stats.GetTableStats(stmt.FromTable)\n    \n    // Calculate selectivity of WHERE clause\n    selectivity := p.selectivity.EstimateSelectivity(stmt.FromTable, stmt.Where)\n    \n    // Choose access path\n    accessPath := p.chooseAccessPath(stmt.FromTable, stmt.Where, selectivity, tableStats)\n    \n    // Build projection list\n    projection := p.buildProjection(stmt.Columns, tableSchema)\n    \n    // Estimate result rows\n    estimatedRows := int64(float64(tableStats.RowCount) * selectivity)\n    \n    return &QueryPlan{\n        AccessPath:    accessPath,\n        Projection:    projection,\n        OrderBy:       p.buildOrderBy(stmt.OrderBy),\n        Limit:         stmt.Limit,\n        Offset:        stmt.Offset,\n        EstimatedCost: accessPath.EstimatedCost(),\n        EstimatedRows: estimatedRows,\n    }, nil\n}\n\n// chooseAccessPath selects between table scan and index scan.\nfunc (p *Planner) chooseAccessPath(\n    tableName string,\n    where Expression,\n    selectivity float64,\n    tableStats *TableStatistics,\n) AccessPath {\n    // Calculate table scan cost\n    tableScanCost := p.costModel.TableScanCost(tableStats)\n    \n    // Find usable indexes\n    indexes := p.indexManager.GetTableIndexes(tableName)\n    var bestIndex *Index\n    var bestIndexCost float64 = math.MaxFloat64\n    \n    for _, idx := range indexes {\n        // Check if index is usable for this query\n        if !p.isIndexUsable(idx, where) {\n            continue\n        }\n        \n        indexCost := p.costModel.IndexScanCost(tableStats, selectivity)\n        \n        if indexCost < bestIndexCost {\n            bestIndexCost = indexCost\n            bestIndex = idx\n        }\n    }\n    \n    // Decision: use index if selectivity is below threshold AND cost is lower\n    if bestIndex != nil && selectivity < IndexSelectivityThreshold && bestIndexCost < tableScanCost {\n        return &IndexScanPath{\n            TableName:     tableName,\n            IndexName:     bestIndex.Name,\n            Predicate:     where,\n            Selectivity:   selectivity,\n            EstimatedRows: int64(float64(tableStats.RowCount) * selectivity),\n            Cost:          bestIndexCost,\n        }\n    }\n    \n    // Default: table scan\n    return &TableScanPath{\n        TableName:     tableName,\n        EstimatedRows: int64(float64(tableStats.RowCount) * selectivity),\n        Cost:          tableScanCost,\n    }\n}\n\n// isIndexUsable checks if an index can serve the WHERE clause.\nfunc (p *Planner) isIndexUsable(idx *Index, where Expression) bool {\n    if where == nil {\n        return false  // No filter, index not useful\n    }\n    \n    // Extract columns referenced in WHERE\n    referencedCols := extractReferencedColumns(where)\n    \n    // Check if indexed column is referenced\n    for _, col := range referencedCols {\n        if col == idx.ColumnName {\n            return true\n        }\n    }\n    \n    return false\n}\n\nfunc (p *Planner) buildProjection(columns []ColumnSelection, schema *Schema) []string {\n    if len(columns) == 1 {\n        if _, isStar := columns[0].Expression.(*StarExpression); isStar {\n            // SELECT * - include all columns\n            result := make([]string, len(schema.Columns))\n            for i, col := range schema.Columns {\n                result[i] = col.Name\n            }\n            return result\n        }\n    }\n    \n    result := make([]string, len(columns))\n    for i, col := range columns {\n        if id, ok := col.Expression.(*IdentifierExpression); ok {\n            result[i] = id.Name\n        }\n    }\n    return result\n}\n\nfunc (p *Planner) buildOrderBy(orderBy []OrderByColumn) []OrderBySpec {\n    result := make([]OrderBySpec, len(orderBy))\n    for i, col := range orderBy {\n        if id, ok := col.Expression.(*IdentifierExpression); ok {\n            result[i] = OrderBySpec{\n                Column:     id.Name,\n                Descending: col.Descending,\n            }\n        }\n    }\n    return result\n}\n\n// WHY planner:\n// - Central decision point for query execution\n// - Cost-based: uses statistics and I/O model\n// - Selectivity threshold prevents index overuse\n// - Extensible: can add more access paths (hash join, etc.)\n```\n\n### Join Order Optimization\n\n\n![Selectivity Estimation Algorithm](./diagrams/tdd-diag-32.svg)\n\n\n```go\n// join_planner.go\n\n// JoinPlanner optimizes join order for multi-table queries.\ntype JoinPlanner struct {\n    stats       *StatisticsManager\n    costModel   *CostModel\n    selectivity *SelectivityEstimator\n}\n\n// PlanJoin creates a plan for a multi-table join.\n// Uses greedy algorithm: start with smallest table, join in order of increasing cost.\nfunc (jp *JoinPlanner) PlanJoin(\n    tables []string,\n    joinConditions []Expression,\n    whereClause Expression,\n) (AccessPath, error) {\n    if len(tables) == 1 {\n        // Single table - not a join\n        return nil, errors.New(\"single table, not a join\")\n    }\n    \n    // Get statistics for all tables\n    tableStats := make(map[string]*TableStatistics)\n    for _, t := range tables {\n        tableStats[t] = jp.stats.GetTableStats(t)\n    }\n    \n    // Greedy: start with smallest table\n    remaining := make([]string, len(tables))\n    copy(remaining, tables)\n    \n    // Sort by row count (ascending)\n    sort.Slice(remaining, func(i, j int) bool {\n        return tableStats[remaining[i]].RowCount < tableStats[remaining[j]].RowCount\n    })\n    \n    // Build plan by joining one table at a time\n    var currentPlan AccessPath\n    \n    // First table\n    firstTable := remaining[0]\n    selectivity := jp.selectivity.EstimateSelectivity(firstTable, \n        extractPredicatesForTable(whereClause, firstTable))\n    \n    currentPlan = &TableScanPath{\n        TableName:     firstTable,\n        EstimatedRows: int64(float64(tableStats[firstTable].RowCount) * selectivity),\n        Cost:          jp.costModel.TableScanCost(tableStats[firstTable]),\n    }\n    \n    remaining = remaining[1:]\n    \n    // Join remaining tables\n    for len(remaining) > 0 {\n        // Find best next table to join\n        bestIdx := 0\n        bestCost := math.MaxFloat64\n        var bestPlan *NestedLoopJoinPath\n        \n        for i, nextTable := range remaining {\n            // Estimate join cost\n            nextStats := tableStats[nextTable]\n            nextSelectivity := jp.selectivity.EstimateSelectivity(nextTable,\n                extractPredicatesForTable(whereClause, nextTable))\n            \n            nextRows := int64(float64(nextStats.RowCount) * nextSelectivity)\n            \n            // Join cardinality: assume independence, apply join selectivity\n            joinSelectivity := jp.estimateJoinSelectivity(\n                currentPlan.EstimatedRows(),\n                nextRows,\n                joinConditions,\n            )\n            resultRows := int64(float64(currentPlan.EstimatedRows()) * float64(nextRows) * joinSelectivity)\n            \n            // Cost: scan outer + inner for each outer row\n            cost := currentPlan.EstimatedCost() + \n                    float64(currentPlan.EstimatedRows()) * jp.costModel.TableScanCost(nextStats)\n            \n            if cost < bestCost {\n                bestCost = cost\n                bestIdx = i\n                bestPlan = &NestedLoopJoinPath{\n                    Left:          currentPlan,\n                    Right:         &TableScanPath{TableName: nextTable, EstimatedRows: nextRows},\n                    JoinCondition: findJoinCondition(currentPlan, nextTable, joinConditions),\n                    EstimatedRows: resultRows,\n                    Cost:          cost,\n                }\n            }\n        }\n        \n        currentPlan = bestPlan\n        remaining = append(remaining[:bestIdx], remaining[bestIdx+1:]...)\n    }\n    \n    return currentPlan, nil\n}\n\n// estimateJoinSelectivity estimates the fraction of rows that survive a join.\nfunc (jp *JoinPlanner) estimateJoinSelectivity(\n    leftRows, rightRows int64,\n    conditions []Expression,\n) float64 {\n    // Simplified: assume 1/distinct for equality joins\n    // For a.id = b.id, selectivity ~ 1/max(distinct_left, distinct_right)\n    return DefaultJoinSelectivity\n}\n\nconst DefaultJoinSelectivity = 0.01  // 1% of cartesian product\n\n// WHY greedy join order:\n// - NP-hard problem in general\n// - Greedy is simple and often good enough\n// - Start with smallest table minimizes intermediate results\n// - Can extend to dynamic programming for better plans\n```\n\n### ANALYZE Command\n\n```go\n// statistics.go (continued)\n\n// Analyze collects statistics for a table.\nfunc (sm *StatisticsManager) Analyze(tableName string) error {\n    // Get table B-tree\n    tree := sm.catalog.GetTableTree(tableName)\n    if tree == nil {\n        return fmt.Errorf(\"no such table: %s\", tableName)\n    }\n    \n    // Scan all rows\n    stats := &TableStatistics{\n        TableName:   tableName,\n        ColumnStats: make(map[string]*ColumnStats),\n    }\n    \n    schema := sm.catalog.GetSchema(tableName)\n    distinctValues := make(map[string]map[interface{}]bool)\n    nullCounts := make(map[string]int64)\n    \n    // Initialize tracking\n    for _, col := range schema.Columns {\n        distinctValues[col.Name] = make(map[interface{}]bool)\n        nullCounts[col.Name] = 0\n    }\n    \n    // Scan table\n    cursor := tree.NewCursor()\n    cursor.First()\n    \n    for !cursor.AtEnd() {\n        _, record := cursor.Current()\n        values, _ := DeserializeRow(record)\n        \n        stats.RowCount++\n        \n        for i, col := range schema.Columns {\n            val := values[i]\n            if val == nil {\n                nullCounts[col.Name]++\n            } else {\n                distinctValues[col.Name][val] = true\n            }\n        }\n        \n        cursor.Next()\n    }\n    \n    // Calculate page count\n    stats.PageCount = (stats.RowCount + RowsPerPage - 1) / RowsPerPage\n    \n    // Store column statistics\n    for _, col := range schema.Columns {\n        stats.ColumnStats[col.Name] = &ColumnStats{\n            ColumnName:    col.Name,\n            DistinctCount: int64(len(distinctValues[col.Name])),\n            NullCount:     nullCounts[col.Name],\n        }\n    }\n    \n    stats.LastAnalyzed = time.Now()\n    \n    // Save to storage\n    if err := sm.storage.Save(stats); err != nil {\n        return err\n    }\n    \n    // Update in-memory cache\n    sm.stats[tableName] = stats\n    \n    // Analyze indexes too\n    return sm.analyzeIndexes(tableName)\n}\n\nfunc (sm *StatisticsManager) analyzeIndexes(tableName string) error {\n    indexes := sm.catalog.GetTableIndexes(tableName)\n    \n    for _, idx := range indexes {\n        // Count distinct values in index\n        distinctCount := sm.countDistinctInIndex(idx)\n        \n        // Get table row count\n        tableStats := sm.stats[tableName]\n        \n        // Save index stats\n        sm.storage.SaveIndexStats(tableName, idx.Name, \n            tableStats.RowCount, distinctCount)\n    }\n    \n    return nil\n}\n\nfunc (sm *StatisticsManager) countDistinctInIndex(idx *Index) int64 {\n    cursor := idx.NewCursor()\n    cursor.First()\n    \n    var count int64\n    var lastValue Value\n    \n    for !cursor.AtEnd {\n        value, _ := cursor.Current()\n        \n        if count == 0 || CompareValues(value, lastValue) != 0 {\n            count++\n            lastValue = value\n        }\n        \n        cursor.Next()\n    }\n    \n    return count\n}\n\nconst RowsPerPage = 50  // Approximate rows per 4KB page\n```\n\n### EXPLAIN Output\n\n```go\n// explain.go\n\n// Explain formats a query plan for display.\nfunc Explain(plan *QueryPlan) string {\n    var buf strings.Builder\n    \n    // Access path\n    explainAccessPath(&buf, plan.AccessPath, 0)\n    \n    buf.WriteString(fmt.Sprintf(\"\\n  Estimated rows: %d\", plan.EstimatedRows))\n    buf.WriteString(fmt.Sprintf(\"\\n  Estimated cost: %.2f\", plan.EstimatedCost))\n    \n    if len(plan.Projection) > 0 {\n        buf.WriteString(fmt.Sprintf(\"\\n  Projection: %s\", strings.Join(plan.Projection, \", \")))\n    }\n    \n    if len(plan.OrderBy) > 0 {\n        buf.WriteString(\"\\n  Order By: \")\n        for i, ob := range plan.OrderBy {\n            if i > 0 {\n                buf.WriteString(\", \")\n            }\n            buf.WriteString(ob.Column)\n            if ob.Descending {\n                buf.WriteString(\" DESC\")\n            }\n        }\n    }\n    \n    if plan.Limit != nil {\n        buf.WriteString(fmt.Sprintf(\"\\n  Limit: %d\", *plan.Limit))\n    }\n    \n    return buf.String()\n}\n\nfunc explainAccessPath(buf *strings.Builder, path AccessPath, indent int) {\n    prefix := strings.Repeat(\"  \", indent)\n    \n    switch p := path.(type) {\n    case *TableScanPath:\n        buf.WriteString(fmt.Sprintf(\"%sTABLE SCAN %s\", prefix, p.TableName))\n    \n    case *IndexScanPath:\n        buf.WriteString(fmt.Sprintf(\"%sINDEX SCAN %s VIA %s\", prefix, p.TableName, p.IndexName))\n        buf.WriteString(fmt.Sprintf(\" (selectivity=%.2f%%)\", p.Selectivity*100))\n    \n    case *NestedLoopJoinPath:\n        buf.WriteString(fmt.Sprintf(\"%sNESTED LOOP JOIN\\n\", prefix))\n        explainAccessPath(buf, p.Left, indent+1)\n        buf.WriteString(\"\\n\")\n        explainAccessPath(buf, p.Right, indent+1)\n    }\n}\n```\n\n---\n\n## Interface Contracts\n\n### Planner Entry Point\n\n```go\n// PlanSelect creates an execution plan for a SELECT statement.\n//\n// Parameters:\n//   - stmt: Parsed SELECT AST\n//\n// Returns:\n//   - *QueryPlan: Complete execution plan with access path and cost\n//   - error: If table doesn't exist or planning fails\n//\n// Pre-conditions:\n//   - stmt is non-nil and valid\n//   - All referenced tables exist in catalog\n//\n// Post-conditions:\n//   - Plan is executable (valid table/index references)\n//   - Cost and row estimates are non-negative\n//   - Access path is chosen based on available statistics\nfunc (p *Planner) PlanSelect(stmt *SelectStatement) (*QueryPlan, error)\n```\n\n### Statistics Management\n\n```go\n// Analyze collects statistics for a table by scanning all rows.\n//\n// Parameters:\n//   - tableName: Table to analyze\n//\n// Returns:\n//   - error: If table doesn't exist or scan fails\n//\n// Post-conditions:\n//   - Statistics are stored in sqlite_stat1\n//   - In-memory cache is updated\n//   - Index statistics are also collected\n//\n// Complexity: O(n) where n is table row count\nfunc (sm *StatisticsManager) Analyze(tableName string) error\n\n// GetTableStats returns statistics for a table.\n// Returns default estimates if ANALYZE hasn't been run.\nfunc (sm *StatisticsManager) GetTableStats(tableName string) *TableStatistics\n```\n\n---\n\n## Algorithm Specification\n\n### Cost-Based Access Path Selection\n\n{{DIAGRAM:tdd-diag-31}}\n\n```\nALGORITHM: chooseAccessPath\nINPUT: tableName, WHERE clause, selectivity, table statistics\nOUTPUT: AccessPath (TableScanPath or IndexScanPath)\n\n1. CALCULATE TABLE SCAN COST\n   tableScanCost := costModel.TableScanCost(tableStats)\n   // = pageCount * sequentialIOCost + rowCount * cpuCost\n\n2. FIND USABLE INDEXES\n   indexes := indexManager.GetTableIndexes(tableName)\n   bestIndex := nil\n   bestIndexCost := infinity\n\n3. FOR each index in indexes:\n     a. IF NOT isIndexUsable(index, whereClause):\n          CONTINUE\n     \n     b. indexCost := costModel.IndexScanCost(tableStats, selectivity)\n        // = indexTraversalCost + (matchingRows/rowsPerPage) * randomIOCost + cpuCost\n     \n     c. IF indexCost < bestIndexCost:\n          bestIndexCost = indexCost\n          bestIndex = index\n\n4. DECISION\n   IF bestIndex != nil \n      AND selectivity < IndexSelectivityThreshold (20%)\n      AND bestIndexCost < tableScanCost:\n     RETURN IndexScanPath{tableName, bestIndex.Name, selectivity, bestIndexCost}\n   \n   ELSE:\n     RETURN TableScanPath{tableName, selectivity, tableScanCost}\n\nKEY INSIGHT: \n  - Low selectivity (< 20%) favors index (fewer rows to fetch)\n  - High selectivity favors table scan (sequential I/O wins)\n  - Cost model captures the essential tradeoff\n```\n\n### Selectivity Estimation\n\n```\nALGORITHM: EstimateSelectivity\nINPUT: tableName, predicate expression\nOUTPUT: float64 (0.0 to 1.0)\n\n1. IF predicate == nil:\n     RETURN 1.0  // No filter\n\n2. SWITCH on expression type:\n\n   CASE BinaryExpression with \"=\":\n     a. colName := extractColumnName(expr.Left)\n     b. colStats := stats.GetColumnStats(tableName, colName)\n     c. IF colStats != nil AND colStats.DistinctCount > 0:\n          RETURN 1.0 / colStats.DistinctCount\n     d. ELSE:\n          RETURN DefaultEqualitySelectivity (0.1)\n\n   CASE BinaryExpression with \"AND\":\n     left := EstimateSelectivity(tableName, expr.Left)\n     right := EstimateSelectivity(tableName, expr.Right)\n     RETURN left * right  // Independence assumption\n\n   CASE BinaryExpression with \"OR\":\n     left := EstimateSelectivity(tableName, expr.Left)\n     right := EstimateSelectivity(tableName, expr.Right)\n     RETURN left + right - left*right  // P(A or B) formula\n\n   CASE BinaryExpression with \"<\", \">\", etc.:\n     RETURN DefaultRangeSelectivity (0.33)\n\n   DEFAULT:\n     RETURN DefaultSelectivity (0.1)\n\nASSUMPTIONS:\n  - Column values are uniformly distributed (no histograms)\n  - Predicates are independent (AND selectivity = product)\n  - Without statistics, use conservative defaults\n```\n\n### Greedy Join Order\n\n\n![Cost Model Comparison](./diagrams/tdd-diag-33.svg)\n\n\n```\nALGORITHM: PlanJoin (Greedy)\nINPUT: List of tables, join conditions, WHERE clause\nOUTPUT: AccessPath representing join tree\n\n1. COLLECT STATISTICS\n   FOR each table:\n     tableStats[table] = stats.GetTableStats(table)\n\n2. SORT TABLES BY SIZE (ascending)\n   sorted := sort tables by tableStats.RowCount\n\n3. INITIALIZE\n   currentPlan := TableScanPath{sorted[0]}\n   remaining := sorted[1:]\n\n4. WHILE remaining is not empty:\n     a. bestCost := infinity\n        bestIdx := -1\n        bestPlan := nil\n     \n     b. FOR i, nextTable in remaining:\n          // Cost = outer scan + (outer rows * inner scan)\n          cost := currentPlan.Cost + \n                  currentPlan.EstimatedRows * tableScanCost(nextTable)\n          \n          IF cost < bestCost:\n            bestCost = cost\n            bestIdx = i\n            bestPlan = NestedLoopJoinPath{\n              Left: currentPlan,\n              Right: TableScanPath{nextTable},\n              EstimatedRows: estimateJoinCardinality(...),\n              Cost: cost,\n            }\n     \n     c. currentPlan = bestPlan\n        remaining = remove remaining[bestIdx]\n\n5. RETURN currentPlan\n\nCOMPLEXITY: O(n^2) for n tables\nWHY GREEDY: \n  - NP-hard to find optimal join order\n  - Greedy is simple and often good\n  - Starting with smallest table minimizes intermediate results\n```\n\n---\n\n## Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n|-------|-------------|----------|---------------|\n| Table doesn't exist | `PlanSelect` table lookup | Return error immediately | Yes: \"no such table: {name}\" |\n| No statistics available | `GetTableStats` | Use default estimates | No: defaults enable planning |\n| Stale statistics | Periodic ANALYZE check | Log warning, use available stats | No: query still executes |\n| Complex predicate (unknown selectivity) | `EstimateSelectivity` | Use DefaultSelectivity | No: conservative estimate |\n| Index doesn't exist | `GetTableIndexes` | Fall back to table scan | No: automatic fallback |\n| Circular join (no join condition) | `PlanJoin` | Treat as cartesian product | No: but result may be large |\n\n---\n\n## Implementation Sequence with Checkpoints\n\n### Phase 1: Statistics Collection (ANALYZE) (2 hours)\n\n**Files to create**: `statistics.go`, `stat_storage.go`, `defaults.go`\n\n**Implementation**:\n1. Define `TableStatistics` and `ColumnStats` structs\n2. Implement `StatisticsManager` with cache\n3. Implement `Analyze` command with table scan\n4. Implement `StatStorage` for sqlite_stat1\n5. Implement default statistics\n\n**Checkpoint**: At this point you should collect and store statistics. Run:\n```bash\ngo test -run TestAnalyze\n# Expected: PASS (ANALYZE creates statistics)\n```\n\n### Phase 2: Selectivity Estimation (2 hours)\n\n**Files to create**: `selectivity.go`\n\n**Implementation**:\n1. Implement `SelectivityEstimator`\n2. Implement equality selectivity (1/distinct)\n3. Implement AND/OR selectivity\n4. Implement range and IN selectivity\n5. Implement default fallbacks\n\n**Checkpoint**: At this point you should estimate predicate selectivity. Run:\n```bash\ngo test -run TestSelectivity\n# Expected: PASS (selectivity estimates are reasonable)\n```\n\n### Phase 3: Cost Model (2 hours)\n\n**Files to create**: `cost_model.go`\n\n**Implementation**:\n1. Implement `CostModel` with I/O costs\n2. Implement `TableScanCost`\n3. Implement `IndexScanCost`\n4. Configure sequential vs random I/O ratio\n5. Test cost calculations\n\n**Checkpoint**: At this point you should compare access path costs. Run:\n```bash\ngo test -run TestCostModel\n# Expected: PASS (cost model chooses correctly for known cases)\n```\n\n### Phase 4: Plan Selection and EXPLAIN (2 hours)\n\n**Files to create**: `planner.go`, `access_path.go`, `query_plan.go`, `explain.go`\n\n**Implementation**:\n1. Implement `AccessPath` interface\n2. Implement `Planner.PlanSelect`\n3. Implement `chooseAccessPath` with threshold\n4. Implement `Explain` formatter\n5. Integrate with compiler\n\n**Checkpoint**: At this point you should create complete plans. Run:\n```bash\ngo test -run TestPlanSelect\n# Expected: PASS (plans are correct, EXPLAIN works)\n```\n\n### Phase 5: Join Order Optimization (2 hours)\n\n**Files to create**: `join_planner.go`\n\n**Implementation**:\n1. Implement `JoinPlanner`\n2. Implement greedy join ordering\n3. Implement join cardinality estimation\n4. Handle multi-table WHERE clauses\n5. Full test suite\n\n**Checkpoint**: At this point you should pass all tests. Run:\n```bash\ngo test -v ./planner\n# Expected: All tests PASS\n# Verify: Plan simple query in < 100μs\n# Verify: Choose index when selectivity < 20%\n```\n\n---\n\n## Test Specification\n\n```go\n// planner_test.go\n\nfunc TestAnalyze(t *testing.T) {\n    db := createTestDB()\n    db.Execute(\"CREATE TABLE users (id INTEGER, name TEXT, status TEXT)\")\n    \n    // Insert 1000 rows\n    for i := 0; i < 1000; i++ {\n        status := \"active\"\n        if i%10 == 0 {\n            status = \"inactive\"\n        }\n        db.Execute(fmt.Sprintf(\"INSERT INTO users VALUES (%d, 'user%d', '%s')\", i, i, status))\n    }\n    \n    // Run ANALYZE\n    err := db.Execute(\"ANALYZE users\")\n    assert.NoError(t, err)\n    \n    // Verify statistics\n    stats := db.Planner.Stats.GetTableStats(\"users\")\n    assert.Equal(t, int64(1000), stats.RowCount)\n    assert.Equal(t, int64(100), stats.ColumnStats[\"status\"].DistinctCount)\n}\n\nfunc TestSelectivityEquality(t *testing.T) {\n    se := &SelectivityEstimator{stats: testStats}\n    \n    // With statistics: selectivity = 1/distinct\n    sel := se.EstimateSelectivity(\"users\", parseExpr(\"status = 'active'\"))\n    assert.Equal(t, 1.0/100.0, sel)  // 100 distinct status values\n    \n    // Without statistics: default\n    sel = se.EstimateSelectivity(\"no_stats_table\", parseExpr(\"col = 1\"))\n    assert.Equal(t, DefaultEqualitySelectivity, sel)\n}\n\nfunc TestSelectivityAnd(t *testing.T) {\n    se := &SelectivityEstimator{stats: testStats}\n    \n    // AND: selectivity = left * right\n    sel := se.EstimateSelectivity(\"users\", \n        parseExpr(\"status = 'active' AND id = 5\"))\n    \n    // Should be product of individual selectivities\n    expectedSel := (1.0/100.0) * (1.0/1000.0)\n    assert.InDelta(t, expectedSel, sel, 0.0001)\n}\n\nfunc TestSelectivityOr(t *testing.T) {\n    se := &SelectivityEstimator{stats: testStats}\n    \n    // OR: selectivity = left + right - left*right\n    sel := se.EstimateSelectivity(\"users\",\n        parseExpr(\"status = 'active' OR status = 'inactive'\"))\n    \n    // Two status values out of 100\n    expectedSel := 2.0/100.0\n    assert.InDelta(t, expectedSel, sel, 0.01)\n}\n\nfunc TestCostModel(t *testing.T) {\n    cm := NewDefaultCostModel()\n    stats := &TableStatistics{RowCount: 10000, PageCount: 200}\n    \n    // Table scan: sequential I/O\n    tableScanCost := cm.TableScanCost(stats)\n    assert.Greater(t, tableScanCost, 0.0)\n    \n    // Index scan with low selectivity (1%)\n    indexScanCost := cm.IndexScanCost(stats, 0.01)\n    \n    // Low selectivity: index should be cheaper\n    assert.Less(t, indexScanCost, tableScanCost)\n    \n    // Index scan with high selectivity (50%)\n    indexScanCostHigh := cm.IndexScanCost(stats, 0.5)\n    \n    // High selectivity: table scan should be cheaper\n    assert.Less(t, tableScanCost, indexScanCostHigh)\n}\n\nfunc TestPlanSelectTableScan(t *testing.T) {\n    db := createTestDBWithStats()\n    db.Execute(\"CREATE INDEX idx_status ON users(status)\")\n    \n    // High selectivity query (90% match)\n    plan, err := db.Planner.PlanSelect(parseSQL(\"SELECT * FROM users WHERE id > 100\"))\n    assert.NoError(t, err)\n    \n    // Should choose table scan (selectivity > 20%)\n    _, isTableScan := plan.AccessPath.(*TableScanPath)\n    assert.True(t, isTableScan, \"Should choose table scan for high selectivity\")\n}\n\nfunc TestPlanSelectIndexScan(t *testing.T) {\n    db := createTestDBWithStats()\n    db.Execute(\"CREATE INDEX idx_email ON users(email)\")\n    \n    // Low selectivity query (0.1% match - 1 row)\n    plan, err := db.Planner.PlanSelect(\n        parseSQL(\"SELECT * FROM users WHERE email = 'user50@example.com'\"))\n    assert.NoError(t, err)\n    \n    // Should choose index scan (selectivity < 20%)\n    indexScan, isIndexScan := plan.AccessPath.(*IndexScanPath)\n    assert.True(t, isIndexScan, \"Should choose index scan for low selectivity\")\n    assert.Equal(t, \"idx_email\", indexScan.IndexName)\n}\n\nfunc TestExplain(t *testing.T) {\n    db := createTestDBWithStats()\n    db.Execute(\"CREATE INDEX idx_email ON users(email)\")\n    \n    plan, _ := db.Planner.PlanSelect(\n        parseSQL(\"SELECT name FROM users WHERE email = 'test@example.com'\"))\n    \n    explain := Explain(plan)\n    \n    assert.Contains(t, explain, \"INDEX SCAN\")\n    assert.Contains(t, explain, \"idx_email\")\n    assert.Contains(t, explain, \"Estimated rows\")\n    assert.Contains(t, explain, \"Estimated cost\")\n}\n\nfunc TestJoinOrder(t *testing.T) {\n    db := createTestDB()\n    \n    // Create tables with different sizes\n    db.Execute(\"CREATE TABLE small (id INTEGER)\")\n    for i := 0; i < 10; i++ {\n        db.Execute(fmt.Sprintf(\"INSERT INTO small VALUES (%d)\", i))\n    }\n    \n    db.Execute(\"CREATE TABLE large (id INTEGER, small_id INTEGER)\")\n    for i := 0; i < 10000; i++ {\n        db.Execute(fmt.Sprintf(\"INSERT INTO large VALUES (%d, %d)\", i, i%10))\n    }\n    \n    db.Execute(\"ANALYZE small\")\n    db.Execute(\"ANALYZE large\")\n    \n    // Plan join\n    plan, err := db.Planner.PlanJoin(\n        []string{\"small\", \"large\"},\n        []Expression{parseExpr(\"small.id = large.small_id\")},\n        nil,\n    )\n    assert.NoError(t, err)\n    \n    // Should start with small table\n    join := plan.(*NestedLoopJoinPath)\n    leftTable := extractTableName(join.Left)\n    assert.Equal(t, \"small\", leftTable, \"Should start with smaller table\")\n}\n\nfunc TestPlanPerformance(t *testing.T) {\n    if testing.Short() {\n        t.Skip(\"Skipping performance test\")\n    }\n    \n    db := createTestDBWithStats()\n    \n    // Plan 1000 simple queries\n    start := time.Now()\n    for i := 0; i < 1000; i++ {\n        db.Planner.PlanSelect(\n            parseSQL(fmt.Sprintf(\"SELECT * FROM users WHERE id = %d\", i)))\n    }\n    elapsed := time.Since(start)\n    \n    avgTime := elapsed / 1000\n    assert.Less(t, avgTime.Microseconds(), int64(100), \n        \"Plan should complete in < 100μs\")\n}\n\nfunc TestSelectivityThreshold(t *testing.T) {\n    db := createTestDBWithStats()\n    db.Execute(\"CREATE INDEX idx_status ON users(status)\")\n    \n    // At exactly 20% selectivity\n    // With 3 distinct status values, each has ~33% selectivity\n    // Should choose table scan\n    \n    plan, _ := db.Planner.PlanSelect(\n        parseSQL(\"SELECT * FROM users WHERE status = 'active'\"))\n    \n    // Status has 3 values, selectivity = 33% > 20%\n    _, isTableScan := plan.AccessPath.(*TableScanPath)\n    assert.True(t, isTableScan, \"Should use table scan when selectivity > 20%\")\n}\n\nfunc TestNoStatisticsFallback(t *testing.T) {\n    db := createTestDB()  // No ANALYZE\n    \n    db.Execute(\"CREATE TABLE test (id INTEGER)\")\n    db.Execute(\"INSERT INTO test VALUES (1)\")\n    \n    // Should still produce a valid plan\n    plan, err := db.Planner.PlanSelect(parseSQL(\"SELECT * FROM test WHERE id = 1\"))\n    assert.NoError(t, err)\n    assert.NotNil(t, plan)\n    \n    // Should use default statistics\n    stats := db.Planner.Stats.GetTableStats(\"test\")\n    assert.Equal(t, DefaultRowCount, stats.RowCount)\n}\n```\n\n---\n\n## Performance Targets\n\n| Operation | Target | How to Measure |\n|-----------|--------|----------------|\n| Plan simple query | < 100μs | `go test -bench=BenchmarkPlanSimple` |\n| ANALYZE on 10K rows | < 500ms | `go test -bench=BenchmarkAnalyze` |\n| Index selection accuracy | 95%+ for selectivity < 5% | Test index chosen when appropriate |\n| Table scan selection accuracy | 95%+ for selectivity > 30% | Test table scan chosen when appropriate |\n| Join order quality | Within 2x of optimal | Compare greedy vs brute force |\n\n---\n\n## Synced Criteria\n\n[[CRITERIA_JSON: {\"module_id\": \"build-sqlite-m8\", \"criteria\": [\"ANALYZE command collects table and index statistics\", \"Cost model estimates I/O for table scan vs index scan\", \"Plan selection chooses cheapest access path per table\", \"EXPLAIN command displays chosen plan with cost estimates\", \"Join order optimization for multi-table queries\", \"Planner falls back to table scan when no suitable index exists or selectivity is too low\"]}]\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-sqlite-m9 -->\nI'll continue with creating the Full Technical Design Specification for build-sqlite-m9: Transactions (Rollback Journal). Let me first check the existing architecture documentation and previous TDD specs to ensure consistency.\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-sqlite-m10 -->\nI'll continue creating the Full Technical Design Specification for Module 10: WAL Mode. Let me first read the existing file to see what's already there.\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-sqlite-m11 -->\nI'll continue by writing the Full Technical Design Specification for Module 11: Aggregate Functions & JOIN. Let me first read the current state of the file to see where I need to add this specification.\n<!-- END_TDD_MOD -->\n\n\nI'll help you create a \"Further Reading\" document for this SQLite implementation project. Let me analyze the content and curate high-quality resources for each major concept."}