{"html":"<h1 id=\"build-sqlite\">build-sqlite</h1>\n<!-- MS_ID: ms-0 -->\n<div id=\"satellite-map\"></div>\n\n<h1 id=\"the-system-map-architecting-sqlite-from-scratch\">THE SYSTEM MAP: ARCHITECTING SQLITE FROM SCRATCH</h1>\n<p>Building a database is the ultimate test of a systems programmer. It requires the precision of a clockmaker and the foresight of a city planner. Before we write a single line of C, we must understand the &quot;Metropolis&quot; we are building.</p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-001.svg\" alt=\"SQLite Engine Architecture\"></p>\n<h3 id=\"the-knowledge-pillars\">The Knowledge Pillars</h3>\n<ol>\n<li><strong><a href=\"#milestone-1\">The Gateway (REPL &amp; Interface)</a></strong>: How the user talks to the machine.</li>\n<li><strong><a href=\"#milestone-2\">The Architect (Tokenizer &amp; Parser)</a></strong>: Turning human intent into a structured blueprint.</li>\n<li><strong><a href=\"#milestone-3\">The Engine (VDBE)</a></strong>: The custom CPU that executes database instructions.</li>\n<li><strong><a href=\"#milestone-4\">The Warehouse (B-Tree &amp; Pager)</a></strong>: The high-performance storage and memory management.</li>\n</ol>\n<hr>\n<div id=\"milestone-1\"></div>\n\n<h2 id=\"milestone-1-the-gateway-the-repl-amp-architecture\">Milestone 1: The Gateway (The REPL &amp; Architecture)</h2>\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<p>Every great journey begins with a prompt. The REPL (Read-Eval-Print-Loop) is your database&#39;s front door.</p>\n<blockquote>\n<p><strong>Mental Model</strong>: Imagine the REPL as a court reporter. It waits for a statement, records it perfectly, hands it to the judge (the VM) for a decision, and reports the result back to the public.</p>\n</blockquote>\n<h3 id=\"quick-breakdown-the-input-buffer\">Quick Breakdown: The Input Buffer</h3>\n<ul>\n<li><strong>Buffer</strong>: A contiguous block of memory used to hold raw input.</li>\n<li><strong>Heap Allocation</strong>: Asking the OS for memory at runtime (using <code>malloc</code>) because we don&#39;t know how long a user&#39;s SQL query will be.</li>\n</ul>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-003.svg\" alt=\"REPL Architecture\"></p>\n<h3 id=\"1-the-naive-trap-the-quotfixed-sizequot-fallacy\">1. The Naive Trap: The &quot;Fixed-Size&quot; Fallacy</h3>\n<p>Many beginners start by declaring a static array for input:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> input</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">255</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\"> // What if the user writes a 1000-character INSERT?</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">scanf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, input);</span><span style=\"color:#6A737D\"> // Vulnerable to Buffer Overflow</span></span></code></pre></div>\n<p><strong>Why it fails</strong>: If the user input exceeds 255 bytes, you overwrite adjacent memory. In a database, this leads to corrupted data or security exploits. Furthermore, <code>scanf</code> stops at the first whitespace—useless for SQL.</p>\n<h3 id=\"2-the-zen-way-dynamic-input-management\">2. The Zen Way: Dynamic Input Management</h3>\n<p>We use a structure to track the buffer and its size, utilizing <code>getline()</code> (or a custom equivalent) to let the heap grow as needed.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  char*</span><span style=\"color:#E1E4E8\"> buffer;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  size_t</span><span style=\"color:#E1E4E8\"> buffer_length;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  ssize_t</span><span style=\"color:#E1E4E8\"> input_length;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} InputBuffer;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Logic: Read until newline, resize buffer if necessary</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">getline</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">(input_buffer</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">buffer), </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">(input_buffer</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">buffer_length), stdin);</span></span></code></pre></div>\n\n<p>{{DIAGRAM:diag-002}}</p>\n<h3 id=\"3-hardware-soul-the-cost-of-a-cache-miss\">3. Hardware Soul: The Cost of a Cache Miss</h3>\n<p>When you allocate memory for your <code>InputBuffer</code> on the heap, that memory might be far away from your program&#39;s execution code in physical RAM. </p>\n<ul>\n<li><strong>Spatial Locality</strong>: Modern CPUs pull data into &quot;Cache Lines&quot; (usually 64 bytes). If your buffer is fragmented or scattered, the CPU wastes hundreds of cycles waiting for the RAM to respond. </li>\n<li><strong>The Optimization</strong>: By keeping our metadata (length, capacity) in a small struct and the buffer in a single contiguous block, we increase the chance that the CPU pre-fetcher will keep our data in the L1 cache.</li>\n</ul>\n<p>{{DIAGRAM:diag-029}}</p>\n<h3 id=\"4-alternative-reality\">4. Alternative Reality</h3>\n<ul>\n<li><strong>Linux/Bash</strong>: Uses the <code>readline</code> library, which provides history (arrow keys) and autocompletion.</li>\n<li><strong>Redis</strong>: Uses a custom protocol (RESP) where the length of the command is sent <em>before</em> the data, allowing the server to allocate the exact amount of memory needed immediately.</li>\n</ul>\n<h3 id=\"5-mental-stamina-checklist\">5. Mental Stamina Checklist</h3>\n<ol>\n<li><strong>The &quot;Null&quot; Terminator</strong>: What happens if a user inputs a null byte (<code>\\0</code>) in the middle of a SQL string? How does your buffer handle it?</li>\n<li><strong>Memory Leaks</strong>: If the REPL runs for 10 years (like a real DB), and you forget to <code>free()</code> the buffer once per loop, how many megabytes do you lose per day?</li>\n<li><strong>Signal Resilience</strong>: What happens to your buffer if the user presses <code>Ctrl+C</code> mid-type?</li>\n</ol>\n<hr>\n<div id=\"milestone-2\"></div>\n\n<h2 id=\"milestone-2-the-architect-tokenizing-the-void\">Milestone 2: The Architect (Tokenizing the Void)</h2>\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<p>Once we have a string like <code>INSERT 1 &quot;user&quot;</code>, the computer sees just a sequence of ASCII numbers. We need to turn these into &quot;Tokens.&quot;</p>\n<blockquote>\n<p><strong>Mental Model</strong>: Tokenizing is like &quot;breaking a sentence into words&quot; and &quot;identifying parts of speech.&quot; <code>SELECT</code> is a verb (Keyword), <code>*</code> is a noun (Identifier), <code>FROM</code> is a preposition.</p>\n</blockquote>\n<h3 id=\"quick-breakdown\">Quick Breakdown</h3>\n<ul>\n<li><strong>Tokenizer (Lexer)</strong>: Scans characters and groups them.</li>\n<li><strong>State Machine</strong>: A system that changes its behavior based on what it just saw (e.g., &quot;I just saw a quote, so everything until the next quote is a string&quot;).</li>\n</ul>\n<p>{{DIAGRAM:diag-004}}</p>\n<h3 id=\"1-the-naive-trap-the-strtok-disaster\">1. The Naive Trap: The <code>strtok()</code> Disaster</h3>\n<p>Using <code>strtok()</code> to split by spaces.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">token </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strtok</span><span style=\"color:#E1E4E8\">(input, </span><span style=\"color:#9ECBFF\">\" \"</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\"> // Fails on \"INSERT INTO users(id, name)...\"</span></span></code></pre></div>\n<p><strong>Why it fails</strong>: SQL is not just space-separated. Parentheses, commas, and quotes are delimiters too. <code>strtok</code> is destructive (it modifies the original string) and cannot handle nested structures.</p>\n<h3 id=\"2-the-zen-way-the-pointer-scan\">2. The Zen Way: The Pointer Scan</h3>\n<p>We maintain a &quot;cursor&quot; (a pointer) and move it through the string, identifying the type of each token without modifying the source.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> { TOKEN_SELECT, TOKEN_INSERT, TOKEN_ID, TOKEN_NUMBER } TokenType;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  TokenType type;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  char*</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  int</span><span style=\"color:#E1E4E8\"> length;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} Token;</span></span></code></pre></div>\n\n\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-005.svg\" alt=\"Token Types Taxonomy\"></p>\n<h3 id=\"3-hardware-soul-branch-prediction\">3. Hardware Soul: Branch Prediction</h3>\n<p>Tokenizers are full of <code>if/else</code> or <code>switch</code> statements (e.g., <code>if (is_digit(c)) ...</code>). </p>\n<ul>\n<li><strong>The CPU&#39;s Guess</strong>: Modern CPUs try to guess which branch you will take. If you have a long string of numbers, the CPU gets very fast because it guesses &quot;Digit&quot; correctly every time. </li>\n<li><strong>The &quot;Pipeline Flush&quot;</strong>: If your code alternates randomly between numbers, letters, and symbols, the CPU will guess wrong, &quot;flush the pipeline,&quot; and lose 10-20 cycles of work.</li>\n</ul>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-011.svg\" alt=\"Instruction Encoding Format\"></p>\n<h3 id=\"4-alternative-reality\">4. Alternative Reality</h3>\n<ul>\n<li><strong>SQLite</strong>: Uses a tool called <code>Lemon</code> to generate its parser and a custom hand-coded tokenizer for maximum speed.</li>\n<li><strong>Python</strong>: Uses a &quot;Lexer&quot; that recognizes indentation (whitespace) as a specific token type, unlike SQL which usually ignores it.</li>\n</ul>\n<h3 id=\"5-mental-stamina-checklist\">5. Mental Stamina Checklist</h3>\n<ol>\n<li><strong>String Escaping</strong>: How does your tokenizer handle the string <code>&#39;It&#39;&#39;s a beautiful day&#39;</code>? (The double single-quote is SQL&#39;s way of escaping).</li>\n<li><strong>Keyword vs Identifier</strong>: If a user has a table named <code>Select</code>, how do you distinguish between the table name and the command <code>SELECT</code>?</li>\n<li><strong>Lookahead</strong>: When you see the character <code>&gt;</code>, you don&#39;t know if the token is &quot;Greater Than&quot; (<code>&gt;</code>) or &quot;Greater Than or Equal To&quot; (<code>&gt;=</code>) until you look at the <em>next</em> character. How do you implement this &quot;Peek&quot;?</li>\n</ol>\n<p>[[ADVANCED_CONTEXT:Formal Grammars and Backus-Naur Form]]</p>\n<!-- END_MS -->\n\n\n<!-- MS_ID: ms-1 -->\n<div id=\"milestone-3\"></div>\n\n<h2 id=\"milestone-3-the-engine-the-vdbe-virtual-database-engine\">Milestone 3: The Engine (The VDBE - Virtual Database Engine)</h2>\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<p>Once the Architect (Parser) has finished the blueprint, we need a machine to execute it. In SQLite, this isn&#39;t a physical CPU, but a <strong>Virtual Machine</strong>. </p>\n<blockquote>\n<p><strong>Mental Model</strong>: Think of the VDBE as a <strong>Specialized Kitchen</strong>. The SQL query is the recipe, the Parser is the chef writing down steps, and the VDBE is the line cook who follows instructions like &quot;Open fridge,&quot; &quot;Get 5 eggs,&quot; and &quot;Fry until golden.&quot;</p>\n</blockquote>\n<h3 id=\"quick-breakdown\">Quick Breakdown</h3>\n<ul>\n<li><strong>Bytecode</strong>: A set of low-level instructions (Opcodes) that the VM understands (e.g., <code>OpenRead</code>, <code>Column</code>, <code>ResultRow</code>).</li>\n<li><strong>Program Counter (PC)</strong>: A pointer that tells the VM which instruction to execute next.</li>\n<li><strong>Registers</strong>: Small &quot;slots&quot; of memory used to hold temporary values during execution.</li>\n</ul>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-vdbe-flow.svg\" alt=\"The VDBE Cycle\"></p>\n<h3 id=\"1-the-naive-trap-the-quotrecursive-tree-walkquot\">1. The Naive Trap: The &quot;Recursive Tree Walk&quot;</h3>\n<p>Many SQL engines start by &quot;walking&quot; the Abstract Syntax Tree (AST) directly. </p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Suboptimal: Executing the tree directly</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> execute</span><span style=\"color:#E1E4E8\">(Node</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> node</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (node->type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SELECT) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        foreach</span><span style=\"color:#E1E4E8\">(row in table) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">evaluate</span><span style=\"color:#E1E4E8\">(node->where_clause, row)) { </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                print</span><span style=\"color:#E1E4E8\">(row); </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><strong>Why it fails</strong>: Recursion is expensive. Every node in the tree requires a function call, which pushes data onto the stack, creating massive overhead for millions of rows. It also makes &quot;pausing&quot; execution (for LIMIT or cursors) incredibly difficult.</p>\n<h3 id=\"2-the-zen-way-the-register-based-vm\">2. The Zen Way: The Register-Based VM</h3>\n<p>We compile the AST into a linear array of instructions. This transforms a complex tree into a simple loop.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Opcodes: Linear execution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 0: Init 0 5 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 1: OpenRead 0 2 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 2: Rewind 0 5 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 3: Column 0 1 1 (Get column 1, store in register 1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 4: ResultRow 1 1 0 (Return register 1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 5: Next 0 3 0 (Go back to 3)</span></span></code></pre></div>\n\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-010.svg\" alt=\"Bytecode Instruction Set\"></p>\n<h3 id=\"3-hardware-soul-instruction-dispatch-amp-computed-gotos\">3. Hardware Soul: Instruction Dispatch &amp; Computed Gotos</h3>\n<p>Inside the VDBE&#39;s main loop, we have to decide which code to run for each opcode.</p>\n<ul>\n<li><strong>The Switch Statement</strong>: A standard <code>switch(opcode)</code> is common, but it can be slow due to &quot;Branch Misprediction.&quot; The CPU struggles to guess where the next jump goes.</li>\n<li><strong>Computed Gotos (Labelled Pointers)</strong>: High-performance engines use an array of memory addresses. Instead of switching, the code literally &quot;jumps&quot; to the address of the next opcode handler. This keeps the CPU&#39;s pipeline full.</li>\n</ul>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-dispatch.svg\" alt=\"Switch vs. Computed Goto\"></p>\n<h3 id=\"4-alternative-reality\">4. Alternative Reality</h3>\n<ul>\n<li><strong>JVM (Java Virtual Machine)</strong>: Uses a <strong>Stack-based</strong> VM. To add numbers, you push two values onto a stack and call <code>ADD</code>. SQLite uses <strong>Registers</strong>, which is faster because it mimics how real hardware (x86/ARM) works.</li>\n<li><strong>PostgreSQL</strong>: Uses a more traditional &quot;volcano model&quot; (iterator-based), but recently added JIT (Just-In-Time) compilation to turn SQL into actual machine code.</li>\n</ul>\n<h3 id=\"5-mental-stamina-checklist\">5. Mental Stamina Checklist</h3>\n<ol>\n<li><strong>Infinite Loops</strong>: How do you prevent a malformed bytecode program from locking up your database forever?</li>\n<li><strong>Register Pressure</strong>: What happens if a complex query needs 1000 registers but you&#39;ve only allocated 100?</li>\n<li><strong>State Persistence</strong>: If a user fetches 10 rows and then waits an hour, how does your VDBE &quot;pause&quot; its state without consuming CPU?</li>\n</ol>\n<hr>\n<div id=\"milestone-4\"></div>\n\n<h2 id=\"milestone-4-the-warehouse-the-b-tree-amp-pager\">Milestone 4: The Warehouse (The B-Tree &amp; Pager)</h2>\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<p>We now have an engine, but where does the data live? We can&#39;t just dump it into a text file. We need a structure that allows us to find one record in a billion in microseconds.</p>\n<blockquote>\n<p><strong>Mental Model</strong>: The <strong>Pager</strong> is the librarian. He knows how to pull 4KB &quot;pages&quot; (books) from the massive &quot;disk&quot; (basement). The <strong>B-Tree</strong> is the index at the front of the library that tells you exactly which page to ask for.</p>\n</blockquote>\n<h3 id=\"quick-breakdown\">Quick Breakdown</h3>\n<ul>\n<li><strong>Page</strong>: The fundamental unit of storage (usually 4KB). Databases never read single bytes; they read entire pages.</li>\n<li><strong>B-Tree</strong>: A &quot;Balanced Tree&quot; structure where every leaf (bottom node) is at the same distance from the root, ensuring predictable speed.</li>\n</ul>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-013.svg\" alt=\"B-Tree Node Structure\"></p>\n<h3 id=\"1-the-naive-trap-the-quotappend-onlyquot-log\">1. The Naive Trap: The &quot;Append-Only&quot; Log</h3>\n<p>Writing every new row to the end of a file.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Searching for ID 500 in a million rows</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">read_row</span><span style=\"color:#E1E4E8\">(file)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (row.id </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 500</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> row;</span><span style=\"color:#6A737D\"> // O(N) complexity - SLOW</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><strong>Why it fails</strong>: As your data grows, your search time grows linearly. Finding a needle in a haystack becomes impossible when the haystack is the size of a mountain.</p>\n<h3 id=\"2-the-zen-way-page-aligned-btrees\">2. The Zen Way: Page-Aligned B+Trees</h3>\n<p>We organize the file into fixed-size pages. Each page is either an &quot;Internal Node&quot; (containing pointers to other pages) or a &quot;Leaf Node&quot; (containing actual data).</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  uint32_t</span><span style=\"color:#E1E4E8\"> page_number;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  uint8_t</span><span style=\"color:#FFAB70\"> data</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\"> // Fixed size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} Page;</span></span></code></pre></div>\n<p>By keeping the tree &quot;balanced,&quot; we can find any row in <code>log(N)</code> time. In a 3-level B-Tree with 4KB pages, you can store millions of rows and find any of them in just 3 disk reads.</p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-014.svg\" alt=\"B-Tree Operations\"></p>\n<h3 id=\"3-hardware-soul-disk-sectors-amp-cache-lines\">3. Hardware Soul: Disk Sectors &amp; Cache Lines</h3>\n<p>The Pager exists because of a hard physical reality: <strong>Disk I/O is slow.</strong></p>\n<ul>\n<li><strong>The 4KB Magic</strong>: Most SSDs and HDDs store data in 4KB sectors. If you write 1 byte, the hardware writes 4KB anyway. By matching our &quot;Page Size&quot; to the &quot;Disk Sector Size,&quot; we reach &quot;I/O Nirvana&quot;—maximum efficiency.</li>\n<li><strong>The Page Cache</strong>: The Pager keeps recently used pages in RAM. This exploits <strong>Temporal Locality</strong>: if you look at a row once, you’ll likely look at its neighbors soon.</li>\n</ul>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-pager-cache.svg\" alt=\"The Pager Cache\"></p>\n<h3 id=\"4-alternative-reality\">4. Alternative Reality</h3>\n<ul>\n<li><strong>Redis</strong>: Keeps everything in RAM. It doesn&#39;t need a Pager, but it loses everything if the power goes out (unless configured otherwise).</li>\n<li><strong>LSM Trees (LevelDB/RocksDB)</strong>: Instead of B-Trees, they use &quot;Log-Structured Merge Trees.&quot; They are faster for <em>writing</em> data but often slower for <em>reading</em> complex queries.</li>\n</ul>\n<h3 id=\"5-mental-stamina-checklist\">5. Mental Stamina Checklist</h3>\n<ol>\n<li><strong>Fragmentation</strong>: If you delete 100 rows in the middle of a B-Tree, how do you reuse that empty space without leaving &quot;holes&quot; in your file?</li>\n<li><strong>The &quot;Split&quot; Event</strong>: When a 4KB page is full and you try to insert another row, the page must &quot;split&quot; into two. How do you update the parent pointers without corrupting the database if the power cuts out mid-split?</li>\n<li><strong>Binary Search</strong>: Inside a single 4KB page, how do you find the right record? (Hint: You don&#39;t scan; you binary search the &quot;Cell Pointer&quot; array).</li>\n</ol>\n<p>[[ADVANCED_CONTEXT:Concurrency Control and ACID Compliance]]\n[[ADVANCED_CONTEXT:Write-Ahead Logging (WAL)]]</p>\n<!-- END_MS -->\n\n\n<!-- MS_ID: ms-2 -->\n<p>This is a continuation of <strong>THE SYSTEM MAP: ARCHITECTING SQLITE FROM SCRATCH</strong>. We have built the loop, parsed the tokens, executed the bytecode, and structured the pages. Now, we must ensure our database is actually <em>fast</em> and <em>indestructible</em>.</p>\n<hr>\n<div id=\"milestone-5\"></div>\n\n<h2 id=\"milestone-5-the-strategist-query-planning-amp-optimization\">Milestone 5: The Strategist (Query Planning &amp; Optimization)</h2>\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<p>SQL is a <em>declarative</em> language. The user tells you <em>what</em> they want, not <em>how</em> to get it. The Query Planner is the brain that bridges that gap.</p>\n<blockquote>\n<p><strong>Mental Model</strong>: The Strategist is like a <strong>GPS Navigator</strong>. There are a hundred ways to get across town. You could take the highway (Index Scan) or the side streets (Table Scan). The Navigator looks at traffic (Statistics) and chooses the path with the lowest &quot;Cost.&quot;</p>\n</blockquote>\n<h3 id=\"quick-breakdown\">Quick Breakdown</h3>\n<ul>\n<li><strong>Full Table Scan</strong>: Looking at every single row in a table.</li>\n<li><strong>Index</strong>: A side-structure (another B-Tree) that maps values (like &quot;Name&quot;) to their locations in the main table.</li>\n<li><strong>Cost-Based Optimizer (CBO)</strong>: An algorithm that estimates how many &quot;disk reads&quot; each plan will take and picks the cheapest.</li>\n</ul>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-019.svg\" alt=\"Query Planner Components\"></p>\n<h3 id=\"1-the-naive-trap-the-quotfirst-foundquot-planner\">1. The Naive Trap: The &quot;First-Found&quot; Planner</h3>\n<p>Executing joins or filters in the exact order the user typed them.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">SELECT</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> FROM</span><span style=\"color:#E1E4E8\"> users, orders </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#79B8FF\"> users</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> orders</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">user_id</span><span style=\"color:#F97583\"> AND</span><span style=\"color:#79B8FF\"> users</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">name</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'Alice'</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n<p><strong>Why it fails</strong>: If there are 1 million orders and only 10 users, but you loop through <code>orders</code> first, you perform 1 million checks. If you look up &#39;Alice&#39; in the <code>users</code> table first (1 check) and then find her 5 orders, you perform 6 checks. The difference is 999,994 operations.</p>\n<h3 id=\"2-the-zen-way-the-search-space-searcher\">2. The Zen Way: The Search Space Searcher</h3>\n<p>We represent the query as a tree of logical operations. We then apply &quot;Transformations&quot; to rearrange the tree into the most efficient shape.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Pseudo-code for a simple optimizer rule</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">can_use_index</span><span style=\"color:#E1E4E8\">(table, column)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    replace_scan_with_index_lookup</span><span style=\"color:#E1E4E8\">(plan);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-020.svg\" alt=\"Index Selection Algorithm\"></p>\n<h3 id=\"3-hardware-soul-data-locality-and-simd\">3. Hardware Soul: Data Locality and SIMD</h3>\n<p>When the Planner chooses an index, it&#39;s not just reducing the number of rows—it&#39;s optimizing for the CPU&#39;s hardware.</p>\n<ul>\n<li><strong>Pointer Following</strong>: Indices allow the CPU to jump directly to the right memory address, but jumping too much causes <strong>TLB (Translation Lookaside Buffer) Misses</strong>.</li>\n<li><strong>The Optimization</strong>: &quot;Covering Indices.&quot; If an index contains all the data the query needs (e.g., the Index contains both <code>ID</code> and <code>Name</code>), the CPU never has to fetch the main table page. This keeps the data &quot;dense&quot; and &quot;local,&quot; allowing the CPU to potentially use <strong>SIMD (Single Instruction, Multiple Data)</strong> to compare multiple rows in one clock cycle.</li>\n</ul>\n<p>{{DIAGRAM:diag-021}}</p>\n<h3 id=\"4-alternative-reality\">4. Alternative Reality</h3>\n<ul>\n<li><strong>MySQL</strong>: Uses a &quot;Rule-Based&quot; optimizer for many years before moving to &quot;Cost-Based.&quot;</li>\n<li><strong>SQLite</strong>: Uses a &quot;Nearest Neighbor&quot; heuristic for joins (the &quot;Greedy Algorithm&quot;). It doesn&#39;t explore every single possible join order because, for a 20-table join, there are $20!$ (quintillions) of possibilities—more than the atoms in the universe.</li>\n</ul>\n<h3 id=\"5-mental-stamina-checklist\">5. Mental Stamina Checklist</h3>\n<ol>\n<li><strong>Selectivity</strong>: If a column has only two values (e.g., &#39;Male&#39; or &#39;Female&#39;), is an index actually faster than a table scan? (Hint: Usually no, due to random I/O overhead).</li>\n<li><strong>Prepared Statements</strong>: If you optimize a query once, how do you &quot;cache&quot; the plan so you don&#39;t waste CPU cycles re-optimizing it every time the user runs it?</li>\n<li><strong>The N+1 Problem</strong>: How can the planner detect when a user is making many small queries instead of one large join?</li>\n</ol>\n<hr>\n<div id=\"milestone-6\"></div>\n\n<h2 id=\"milestone-6-the-protector-transactions-amp-recovery\">Milestone 6: The Protector (Transactions &amp; Recovery)</h2>\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<p>A database that loses data when the power goes out is just a fancy calculator. We need <strong>ACID</strong> (Atomicity, Consistency, Isolation, Durability).</p>\n<blockquote>\n<p><strong>Mental Model</strong>: The Protector is a <strong>Master Surgeon</strong>. Before making a single cut, they write down exactly what they are going to do in a <strong>Medical Log</strong>. If the lights go out mid-surgery, the log tells the next doctor exactly where to resume or how to &quot;undo&quot; the damage.</p>\n</blockquote>\n<h3 id=\"quick-breakdown\">Quick Breakdown</h3>\n<ul>\n<li><strong>Atomicity</strong>: &quot;All or nothing.&quot; Either the whole transaction happens, or none of it does.</li>\n<li><strong>The WAL (Write-Ahead Log)</strong>: A separate file where we write changes <em>before</em> we touch the main database file.</li>\n<li><strong>Fsync</strong>: A command that forces the OS to actually write data to the physical disk platter, rather than keeping it in a volatile RAM cache.</li>\n</ul>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-023.svg\" alt=\"Transaction Lifecycle\"></p>\n<h3 id=\"1-the-naive-trap-the-quotin-placequot-overwrite\">1. The Naive Trap: The &quot;In-Place&quot; Overwrite</h3>\n<p>Opening the database file and writing <code>new_value</code> directly over <code>old_value</code>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">fseek</span><span style=\"color:#E1E4E8\">(db_file, row_offset, SEEK_SET);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">fwrite</span><span style=\"color:#E1E4E8\">(new_data, size, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, db_file);</span><span style=\"color:#6A737D\"> // If the power dies here, you have half old data and half new.</span></span></code></pre></div>\n<p><strong>Why it fails</strong>: This is called <strong>Corruption</strong>. Your B-Tree pointers will point to garbage, and your database is now a paperweight.</p>\n<h3 id=\"2-the-zen-way-shadow-paging-or-wal\">2. The Zen Way: Shadow Paging or WAL</h3>\n<p>In a WAL-mode system, we don&#39;t touch the main database during a transaction. We append the new pages to a <code>journal</code> file. </p>\n<ol>\n<li><strong>Record</strong>: Write the new page to the WAL file.</li>\n<li><strong>Commit</strong>: Write a special &quot;Commit&quot; marker to the WAL.</li>\n<li><strong>Checkpoint</strong>: Occasionally, move the changes from the WAL back to the main <code>.db</code> file.</li>\n</ol>\n<p>{{DIAGRAM:diag-025}}</p>\n<h3 id=\"3-hardware-soul-the-disk-controller39s-lie\">3. Hardware Soul: The Disk Controller&#39;s Lie</h3>\n<p>When you call <code>write()</code> in C, the OS says &quot;Done!&quot; almost instantly. But the data is still in RAM. Even when the OS flushes it, the <strong>Disk Controller</strong> might keep it in its own internal cache to be &quot;efficient.&quot;</p>\n<ul>\n<li><strong>The Barrier</strong>: We must use <code>fsync()</code> (Linux) or <code>FlushFileBuffers</code> (Windows). This forces the hardware to drain its caches.</li>\n<li><strong>The Cost</strong>: <code>fsync()</code> is the slowest operation in systems programming. It can take 10ms (an eternity for a CPU). SQLite&#39;s performance is almost entirely defined by how many <code>fsync</code> calls it can avoid.</li>\n</ul>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-027.svg\" alt=\"Crash Recovery Flow\"></p>\n<h3 id=\"4-alternative-reality\">4. Alternative Reality</h3>\n<ul>\n<li><strong>PostgreSQL</strong>: Uses MVCC (Multi-Version Concurrency Control). Instead of locking, it keeps multiple versions of a row. Readers never block writers.</li>\n<li><strong>SQLite (Rollback Journal)</strong>: The older version of SQLite copied the <em>original</em> data to a &quot;Rollback&quot; file before overwriting the main file. WAL is faster because it turns random writes into sequential appends.</li>\n</ul>\n<h3 id=\"5-mental-stamina-checklist\">5. Mental Stamina Checklist</h3>\n<ol>\n<li><strong>The &quot;Torn Page&quot;</strong>: What if the power fails <em>while</em> the disk is halfway through writing a 4KB page? How do you detect that the page is garbage? (Hint: Checksums).</li>\n<li><strong>Isolation</strong>: If Transaction A is reading a row while Transaction B is writing to it, what does Transaction A see? The old value? The new value? An error?</li>\n<li><strong>The Deadlock</strong>: If two users are both waiting for each other to release a lock, how does your database &quot;break&quot; the loop?</li>\n</ol>\n<hr>\n<div id=\"beyond-the-atlas\"></div>\n\n<h1 id=\"beyond-the-atlas-advanced-context\">BEYOND THE ATLAS: ADVANCED CONTEXT</h1>\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<h3 id=\"advanced_contextformal-grammars-and-backus-naur-form\">[[ADVANCED_CONTEXT:Formal Grammars and Backus-Naur Form]]</h3>\n<p>To build a truly robust parser, we use <strong>BNF</strong>. It’s a mathematical way of describing a language. </p>\n<ul>\n<li>Example: <code>Expression ::= Term | Expression &quot;+&quot; Term</code>. </li>\n<li>This allows us to handle infinite complexity (like <code>1 + 2 + 3 + ...</code>) using simple recursive rules.</li>\n</ul>\n<h3 id=\"advanced_contextconcurrency-control-and-acid-compliance\">[[ADVANCED_CONTEXT:Concurrency Control and ACID Compliance]]</h3>\n<p>Building a &quot;Thread-Safe&quot; B-Tree is one of the hardest tasks in CS. It involves <strong>Latches</strong> (short-term memory locks) and <strong>Locks</strong> (long-term database locks). </p>\n<ul>\n<li><strong>The Microscope</strong>: Look into &quot;Two-Phase Locking&quot; (2PL) to understand how to prevent transactions from stepping on each other&#39;s toes.</li>\n</ul>\n<h3 id=\"advanced_contextwrite-ahead-logging-wal\">[[ADVANCED_CONTEXT:Write-Ahead Logging (WAL)]]</h3>\n<p>The WAL isn&#39;t just for safety; it&#39;s for <strong>Concurrency</strong>. In WAL mode, a reader can look at the main <code>.db</code> file while a writer is appending to the <code>.wal</code> file. They don&#39;t block each other! This is the secret to SQLite&#39;s incredible read performance.</p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-final.svg\" alt=\"The Completed Machine\"></p>\n<hr>\n<p><strong>Congratulations, Architect.</strong> You have transitioned from a simple <code>scanf</code> prompt to a multi-layered, crash-resilient, optimized storage engine. The system is now alive. </p>\n<p><strong>Next Steps</strong>: Implement the B-Tree &quot;Split&quot; logic in Milestone 4. That is where the real &quot;systems&quot; pain—and glory—begins.</p>\n<!-- END_MS -->\n\n\n<!-- MS_ID: ms-3 -->\n<!-- MS_ID: ms-3 -->\n<div id=\"milestone-7\"></div>\n\n<h2 id=\"milestone-7-the-assembly-line-row-serialization-amp-the-record-format\">Milestone 7: The Assembly Line (Row Serialization &amp; The Record Format)</h2>\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<p>We have the B-Tree pages (the boxes) and the VDBE (the engine), but we haven&#39;t discussed how a &quot;Row&quot; actually looks inside a page. You cannot just dump a C <code>struct</code> to disk.</p>\n<blockquote>\n<p><strong>Mental Model</strong>: Imagine packing a <strong>Suitcase</strong>. If you use a hard-shell case with fixed compartments (Fixed-width), you waste space if you only pack a t-shirt, and you can&#39;t fit a winter coat. SQLite uses &quot;Compression Packing&quot;—it rolls the clothes and puts a manifest (the Header) at the top so it knows exactly where each item starts.</p>\n</blockquote>\n<h3 id=\"quick-breakdown\">Quick Breakdown</h3>\n<ul>\n<li><strong>Serialization</strong>: Turning a high-level data structure (like a row with a string, an int, and a float) into a flat array of bytes.</li>\n<li><strong>Varint (Variable-length Integer)</strong>: A way to store an integer using 1 to 9 bytes. Smaller numbers take less space.</li>\n<li><strong>Manifest (Record Header)</strong>: A sequence of &quot;Type IDs&quot; that tell the engine how to interpret the following bytes.</li>\n</ul>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-record-layout.svg\" alt=\"The Record Anatomy\"></p>\n<h3 id=\"1-the-naive-trap-the-quotc-structquot-dump\">1. The Naive Trap: The &quot;C-Struct&quot; Dump</h3>\n<p>The most common mistake is defining a row as a fixed-size C structure and writing it directly to the file.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> Row {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> id;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> username</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> email</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">255</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span><span style=\"color:#6A737D\"> // This row ALWAYS takes 291 bytes, even if the username is \"Bob\".</span></span></code></pre></div>\n<p><strong>Why it fails</strong>: </p>\n<ol>\n<li><strong>Wasted Space</strong>: If your average username is 5 chars, you waste 27 bytes <em>per row</em>. In a million rows, that&#39;s 27MB of pure air.</li>\n<li><strong>Schema Rigidity</strong>: If you want to change the email length to 500, you have to rewrite the entire database file.</li>\n<li><strong>Endianness</strong>: A C <code>int</code> is stored differently on an ARM chip (Mac M1) vs. an x86 chip (Intel). Your database file becomes non-portable.</li>\n</ol>\n<h3 id=\"2-the-zen-way-the-compact-record-format\">2. The Zen Way: The Compact Record Format</h3>\n<p>SQLite uses a <strong>header-payload</strong> architecture. The header contains a list of &quot;Serial Types&quot; (encoded as Varints), followed by the actual data.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Example: (1, \"Alice\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Header: [2] (Header Length), [1] (Type: 1-byte Int), [18] (Type: String of length 5)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Payload: [0x01], ['A', 'l', 'i', 'c', 'e']</span></span></code></pre></div>\n\n\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-varint-logic.svg\" alt=\"The Varint Squeeze\"></p>\n<h3 id=\"3-hardware-soul-data-alignment-amp-the-cpu-quottaxquot\">3. Hardware Soul: Data Alignment &amp; The CPU &quot;Tax&quot;</h3>\n<p>CPUs prefer to read data from &quot;aligned&quot; memory addresses (e.g., a 4-byte integer starting at an address divisible by 4).</p>\n<ul>\n<li><strong>The Penalty</strong>: If you pack data too tightly (like SQLite does), a 4-byte integer might straddle two different <strong>Cache Lines</strong>. To read it, the CPU has to fetch two blocks of memory, shift the bits, and merge them.</li>\n<li><strong>The Optimization</strong>: While SQLite prioritizes disk space (saving bytes), high-performance memory-only engines (like DuckDB) often trade space for <strong>SIMD-alignment</strong>, ensuring that data &quot;lines up&quot; perfectly with the CPU&#39;s registers.</li>\n</ul>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-alignment-shift.svg\" alt=\"Alignment vs. Packing\"></p>\n<h3 id=\"4-alternative-reality\">4. Alternative Reality</h3>\n<ul>\n<li><strong>Protocol Buffers (Protobuf)</strong>: Uses a very similar Varint-based encoding for network communication.</li>\n<li><strong>Apache Parquet</strong>: Instead of packing rows together (&quot;Row-major&quot;), it packs columns together (&quot;Columnar&quot;). This is much faster for analytical queries (e.g., &quot;Average of all Ages&quot;) because the CPU can stream the &quot;Age&quot; column without skipping over &quot;Usernames.&quot;</li>\n</ul>\n<h3 id=\"5-mental-stamina-checklist\">5. Mental Stamina Checklist</h3>\n<ol>\n<li><strong>The Varint Limit</strong>: SQLite&#39;s Varint can be up to 9 bytes. Why 9? (Hint: To accommodate a 64-bit integer plus the continuation bits).</li>\n<li><strong>Schema Evolution</strong>: If you add a column to a table, how does the Record Format handle rows that were written <em>before</em> the column existed?</li>\n<li><strong>Nulls for Free</strong>: In SQLite, the Serial Type for <code>NULL</code> is <code>0</code>. It takes 1 byte in the header and <strong>zero</strong> bytes in the payload. How does this impact your storage calculations for sparse tables?</li>\n</ol>\n<hr>\n<div id=\"milestone-8\"></div>\n\n<h2 id=\"milestone-8-the-interface-the-c-api-amp-handshake\">Milestone 8: The Interface (The C API &amp; Handshake)</h2>\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<p>The final layer is how the outside world interacts with your machine. This is the <strong>Application Program Interface (API)</strong>.</p>\n<blockquote>\n<p><strong>Mental Model</strong>: The API is the <strong>Menu at a Restaurant</strong>. The customer doesn&#39;t need to know how the stove works; they just need a consistent way to order <code>Prepare()</code>, <code>Step()</code>, and <code>Finalize()</code>.</p>\n</blockquote>\n<h3 id=\"1-the-naive-trap-the-quotone-shotquot-string\">1. The Naive Trap: The &quot;One-Shot&quot; String</h3>\n<p>Providing a single function: <code>QueryResult* run_sql(char* query)</code>.\n<strong>Why it fails</strong>: This forces the engine to load the entire result set into RAM at once. If your query returns 5GB of data, the application crashes with an <code>Out of Memory</code> error.</p>\n<h3 id=\"2-the-zen-way-the-quotprepared-statementquot-lifecycle\">2. The Zen Way: The &quot;Prepared Statement&quot; Lifecycle</h3>\n<p>We break the interaction into three distinct phases that mirror the architecture we&#39;ve built:</p>\n<ol>\n<li><strong>Prepare</strong>: The Parser creates the Bytecode (VDBE Program).</li>\n<li><strong>Step</strong>: The VDBE executes until it hits a <code>ResultRow</code>. It hands one row back to the user and <em>pauses</em>.</li>\n<li><strong>Finalize</strong>: The VDBE clears its registers and closes its cursors.</li>\n</ol>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-api-lifecycle.svg\" alt=\"The Statement Lifecycle\"></p>\n<h3 id=\"3-hardware-soul-the-stack-vs-the-heap\">3. Hardware Soul: The Stack vs. The Heap</h3>\n<p>When a user calls your API, they are crossing a boundary. </p>\n<ul>\n<li><strong>Ownership</strong>: Does the API return a pointer to memory <em>you</em> own (the database) or memory <em>they</em> own? </li>\n<li><strong>The Optimization</strong>: &quot;Zero-copy&quot; interfaces. Instead of copying a string from the B-Tree page to a new buffer for the user, you provide a pointer directly into the <strong>Page Cache</strong>. This avoids a massive memory copy (memcpy), which is often the bottleneck in high-throughput systems.</li>\n</ul>\n<h3 id=\"5-mental-stamina-checklist\">5. Mental Stamina Checklist</h3>\n<ol>\n<li><strong>Re-entrancy</strong>: Can two different threads call <code>sqlite3_step()</code> on the same prepared statement at the same time? Why is this a recipe for disaster?</li>\n<li><strong>Resource Leaks</strong>: If an application crashes after <code>Prepare()</code> but before <code>Finalize()</code>, how does your engine ensure the B-Tree locks are released?</li>\n<li><strong>Versioning</strong>: If you update your Opcodes in Milestone 3, how do you ensure that a &quot;Prepared Statement&quot; saved on disk from an older version doesn&#39;t crash the new engine?</li>\n</ol>\n<p>[[ADVANCED_CONTEXT:Application Binary Interface (ABI) Stability]]</p>\n<hr>\n<h1 id=\"the-system-is-complete\">THE SYSTEM IS COMPLETE</h1>\n<p>You have journeyed from a raw character buffer to a crash-resilient, bytecode-executing, B-Tree-indexed engine. You have faced the trade-offs between <strong>Disk I/O, CPU Cache Locality, and Memory Safety</strong>.</p>\n<p><strong>Final Challenge</strong>: Go back to Milestone 1. Can you now see how a single character typed into the REPL ripples through the Tokenizer, becomes an Opcode, traverses the B-Tree, and is protected by the WAL?</p>\n<p><strong>You are no longer a user of systems. You are an Architect.</strong></p>\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<!-- END_MS -->\n<!-- END_MS -->\n\n\n<!-- MS_ID: ms-4 -->\n<div id=\"milestone-9\"></div>\n\n<h2 id=\"milestone-9-the-sentinel-concurrency-amp-high-level-locking\">Milestone 9: The Sentinel (Concurrency &amp; High-Level Locking)</h2>\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<p>A single-user database is a toy. A world-class system must handle a hundred hands reaching for the same data at once without losing a single bit.</p>\n<blockquote>\n<p><strong>Mental Model</strong>: Imagine a <strong>Shared Library</strong>. If everyone just grabs books, they’ll collide. <strong>Locking</strong> is the librarian giving you a &quot;Read-Only&quot; pass or a &quot;Reserved&quot; sign. <strong>Latches</strong> are the physical lock on the door to the room while you&#39;re rearranging the shelves so no one gets hit by a falling book.</p>\n</blockquote>\n<h3 id=\"quick-breakdown\">Quick Breakdown</h3>\n<ul>\n<li><strong>Lock</strong>: A high-level, long-term logical barrier (e.g., &quot;Nobody can write to this Table while I&#39;m reading it&quot;).</li>\n<li><strong>Latch (Mutex)</strong>: A low-level, short-term physical barrier used to protect internal data structures (like the B-Tree header) during a pointer update.</li>\n</ul>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-latch-vs-lock.svg\" alt=\"Locking vs Latching\"></p>\n<h3 id=\"1-the-naive-trap-the-quotgiant-mutexquot\">1. The Naive Trap: The &quot;Giant Mutex&quot;</h3>\n<p>Protecting the entire database with a single <code>pthread_mutex_lock()</code>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> execute_query</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">char*</span><span style=\"color:#FFAB70\"> sql</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">global_db_lock);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... do everything ...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">global_db_lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><strong>Why it fails</strong>: This turns your high-speed database into a single-file line. Even if User A wants to read Table 1 and User B wants to read Table 2, User B must wait. On a 64-core server, you are utilizing 1.5% of your hardware. This is the &quot;Python Global Interpreter Lock&quot; (GIL) problem applied to storage.</p>\n<h3 id=\"2-the-zen-way-multi-granular-locking-amp-intent-locks\">2. The Zen Way: Multi-Granular Locking &amp; Intent Locks</h3>\n<p>We implement a hierarchy. Before you lock a <strong>Row</strong>, you must put an &quot;Intent to Read&quot; lock on the <strong>Page</strong>, and an &quot;Intent&quot; lock on the <strong>Table</strong>.</p>\n<ul>\n<li><strong>Shared (S)</strong>: &quot;I&#39;m reading, you can read too.&quot;</li>\n<li><strong>Exclusive (X)</strong>: &quot;I&#39;m writing, everyone stay away.&quot;</li>\n<li><strong>Intent Shared (IS)</strong>: &quot;I plan to read a row somewhere inside this table.&quot;</li>\n</ul>\n<p>This allows the engine to quickly check: &quot;Can I lock this whole table for maintenance?&quot; by just looking at the top-level Intent locks, rather than checking a million rows.</p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-lock-hierarchy.svg\" alt=\"The Intent Hierarchy\"></p>\n<h3 id=\"3-hardware-soul-atomic-cas-and-mesi\">3. Hardware Soul: Atomic CAS and MESI</h3>\n<p>At the lowest level, latches don&#39;t use the OS; they use the CPU.</p>\n<ul>\n<li><strong>CAS (Compare-And-Swap)</strong>: A single instruction (<code>LOCK CMPXCHG</code> on x86) that checks if a memory location is <code>0</code> and sets it to <code>1</code> in one atomic tick. If two cores try at the exact same time, the hardware guarantees only one wins.</li>\n<li><strong>MESI Protocol</strong>: When one core modifies a latch, the <strong>Cache Coherency</strong> protocol must &quot;invalidate&quot; that memory in every other core&#39;s L1 cache. If your &quot;Sentinel&quot; is too busy (High Contention), your cores spend more time talking to each other than doing work. This is called <strong>Cache Line Bouncing</strong>.</li>\n</ul>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-atomic-cas.svg\" alt=\"The Atomic Micro-Op\"></p>\n<h3 id=\"4-alternative-reality\">4. Alternative Reality</h3>\n<ul>\n<li><strong>PostgreSQL</strong>: Uses &quot;Heavyweight Locks&quot; for tables and &quot;Lightweight Locks&quot; (LWLocks) for internal buffers.</li>\n<li><strong>SQLite</strong>: Uses a simple 5-state locking machine (UNLOCKED, SHARED, RESERVED, PENDING, EXCLUSIVE) to manage file-level concurrency.</li>\n</ul>\n<h3 id=\"5-mental-stamina-checklist\">5. Mental Stamina Checklist</h3>\n<ol>\n<li><strong>Deadlock Detection</strong>: If User A locks Row 1 and wants Row 2, while User B locks Row 2 and wants Row 1, how does your Sentinel detect the &quot;Deadly Embrace&quot; and kill one of them?</li>\n<li><strong>Starvation</strong>: If there are constant readers (Shared Locks), a writer (Exclusive Lock) might wait forever. How do you implement a &quot;Queue&quot; to give the writer a turn?</li>\n<li><strong>Lock Escalation</strong>: If a user updates 100,000 rows, your memory fills up with 100,000 lock objects. How do you &quot;escalate&quot; those into a single Table Lock?</li>\n</ol>\n<hr>\n<div id=\"milestone-10\"></div>\n\n<h2 id=\"milestone-10-the-siege-testing-fuzzing-amp-the-vfs\">Milestone 10: The Siege (Testing, Fuzzing &amp; The VFS)</h2>\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<p>Your code is perfect—until it isn&#39;t. The final milestone isn&#39;t a feature; it&#39;s the <strong>Assault</strong>.</p>\n<blockquote>\n<p><strong>Mental Model</strong>: The Siege is like a <strong>Crash Test Lab</strong>. We don&#39;t just drive the car; we drive it into a wall at 60mph while the engine is on fire to see if the airbags (Recovery Logic) still deploy.</p>\n</blockquote>\n<h3 id=\"1-the-naive-trap-the-quothappy-pathquot-unit-test\">1. The Naive Trap: The &quot;Happy Path&quot; Unit Test</h3>\n<p>Writing tests that only check if <code>INSERT</code> works.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">test_insert</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    execute</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INSERT INTO t VALUES (1)\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">count_rows</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><strong>Why it fails</strong>: This doesn&#39;t test the <strong>Persistence</strong>. Real-world failures happen when the disk returns an error, the power cuts mid-write, or the filesystem is full.</p>\n<h3 id=\"2-the-zen-way-the-vfs-virtual-file-system-amp-fault-injection\">2. The Zen Way: The VFS (Virtual File System) &amp; Fault Injection</h3>\n<p>We wrap all OS calls (open, read, write, sync) in a <strong>VFS Layer</strong>. In our tests, we use a &quot;Malicious VFS.&quot;</p>\n<ul>\n<li><strong>The I/O Error Injector</strong>: &quot;On the 50th write, return <code>EIO</code> (Disk Error).&quot;</li>\n<li><strong>The Power-Cut Simulator</strong>: &quot;After the WAL is written but before the <code>fsync</code>, stop the program immediately.&quot;</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Malicious VFS Logic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> malicious_write</span><span style=\"color:#E1E4E8\">(File</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> f</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> len</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (global_test_counter</span><span style=\"color:#F97583\">++</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 50</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> SQLITE_IOERR; </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> real_write</span><span style=\"color:#E1E4E8\">(f, buf, len);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-vfs-layer.svg\" alt=\"The VFS Shield\"></p>\n<h3 id=\"3-hardware-soul-bit-rot-and-cosmic-rays\">3. Hardware Soul: Bit Rot and Cosmic Rays</h3>\n<p>Hardware is not a mathematical certainty. </p>\n<ul>\n<li><strong>Bit Flips</strong>: Over years, a <code>1</code> on a disk can turn into a <code>0</code>.</li>\n<li><strong>The Solution</strong>: <strong>Checksums</strong>. We append a mathematical &quot;signature&quot; to every 4KB page. When the Pager reads a page from the Warehouse (Milestone 4), it recalculates the checksum. If it doesn&#39;t match, the database refuses to start rather than returning corrupted data.</li>\n</ul>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-checksum-verification.svg\" alt=\"The Checksum Guard\"></p>\n<h3 id=\"4-alternative-reality\">4. Alternative Reality</h3>\n<ul>\n<li><strong>SQLite</strong>: Is the most tested piece of software in the world. It has 711 times more test code than actual library code (over 90 million lines of tests).</li>\n<li><strong>FoundationDB</strong>: Uses a &quot;Deterministic Simulation&quot; engine that can reproduce a 1-in-a-billion bug by replaying the exact same &quot;random&quot; seed.</li>\n</ul>\n<h3 id=\"5-mental-stamina-checklist\">5. Mental Stamina Checklist</h3>\n<ol>\n<li><strong>Fuzzing</strong>: If I feed your Parser 1GB of random garbage characters, does it return an error or a <code>Segmentation Fault</code>?</li>\n<li><strong>Valgrind/ASAN</strong>: Can your engine run a massive suite of queries without leaking a single byte of heap memory?</li>\n<li><strong>The &quot;No-Space&quot; Test</strong>: What happens to your WAL file when the disk is 100% full? Does it gracefully roll back or corrupt the main DB?</li>\n</ol>\n<hr>\n<h1 id=\"the-beyond-advanced-context-expanded\">THE BEYOND: ADVANCED CONTEXT EXPANDED</h1>\n<h3 id=\"advanced_contextapplication-binary-interface-abi-stability\">[[ADVANCED_CONTEXT:Application Binary Interface (ABI) Stability]]</h3>\n<p>When you build a system like SQLite, people will use it for 30 years. You cannot change the way <code>sqlite3_open()</code> looks in the next version, or you&#39;ll break the world. This is why we use <strong>Opaque Pointers</strong> (pointers to structs that aren&#39;t defined in the header file). The user can hold the pointer, but they can&#39;t see inside it, allowing us to change the internal engine without breaking their code.</p>\n<h3 id=\"advanced_contextformal-grammars-and-backus-naur-form\">[[ADVANCED_CONTEXT:Formal Grammars and Backus-Naur Form]]</h3>\n<p>We use BNF to ensure our SQL parser is &quot;Complete.&quot; By defining a grammar, we can use tools like <code>yacc</code> or <code>lemon</code> to prove that our engine can handle nested queries like <code>SELECT * FROM (SELECT * FROM (SELECT...))</code>. Without a formal grammar, your parser is just a pile of <code>if</code> statements waiting to break.</p>\n<hr>\n<p><strong>ARCHITECT&#39;S FINAL NOTE:</strong>\nYou have built a metropolis. It has a Gateway, an Engine, a Warehouse, and a Sentinel. It is protected by the Siege. You have mastered the art of talking to the hardware while serving the user. </p>\n<p><strong>The Atlas is complete.</strong></p>\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<!-- END_MS -->\n\n\n<!-- MS_ID: ms-5 -->\n<!-- MS_ID: ms-final -->\n<div id=\"milestone-11\"></div>\n\n<h2 id=\"milestone-11-the-grand-synthesis-the-life-of-a-query\">Milestone 11: The Grand Synthesis (The Life of a Query)</h2>\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<p>We have built the metropolis. Now, we must watch it breathe. To truly master systems architecture, you must be able to trace a single bit from the keyboard to the spinning platter of a disk and back.</p>\n<blockquote>\n<p><strong>Mental Model</strong>: The <strong>Grand Synthesis</strong> is like a <strong>City Pulse</strong>. We are going to track a single &quot;Citizen&quot; (the query: <code>UPDATE users SET points = 10 WHERE id = 5</code>) as they move through the city’s infrastructure, from the front gate to the deepest vault.</p>\n</blockquote>\n<h3 id=\"quick-breakdown-the-full-stack-traversal\">Quick Breakdown: The Full Stack Traversal</h3>\n<ul>\n<li><strong>Northbound</strong>: The path from the user to the disk (Writing).</li>\n<li><strong>Southbound</strong>: The path from the disk to the user (Reading/Result).</li>\n</ul>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-full-traversal.svg\" alt=\"The Query Lifecycle\"></p>\n<h3 id=\"1-the-naive-trap-the-quotblack-boxquot-assumption\">1. The Naive Trap: The &quot;Black Box&quot; Assumption</h3>\n<p>Many developers treat a database as a black box—data goes in, data comes out. \n<strong>Why it fails</strong>: Without understanding the synthesis, you cannot debug performance. If a query is slow, is it the <strong>Tokenizer</strong> (unlikely), the <strong>Optimizer</strong> (picking the wrong index), the <strong>VDBE</strong> (register pressure), or the <strong>Pager</strong> (too many cache misses)? If you don&#39;t know the path, you are just guessing.</p>\n<h3 id=\"2-the-zen-way-the-trace-first-mindset\">2. The Zen Way: The Trace-First Mindset</h3>\n<p>We view the query as a set of handoffs between our milestones:</p>\n<ol>\n<li><strong>Gateway (M1)</strong>: <code>getline()</code> captures the string.</li>\n<li><strong>Architect (M2)</strong>: The string is shattered into <code>UPDATE</code>, <code>users</code>, <code>SET</code>, <code>points</code>, <code>=</code>, <code>10</code>...</li>\n<li><strong>Engine (M3)</strong>: The Parser generates Bytecode. The VDBE begins its loop.</li>\n<li><strong>Strategist (M5)</strong>: The Optimizer decides to use the <code>id</code> index instead of a full table scan.</li>\n<li><strong>Warehouse (M4)</strong>: The B-Tree asks the Pager for Page #5 (the root). The Pager checks the RAM cache.</li>\n<li><strong>Assembly Line (M7)</strong>: The VDBE finds the record, modifies the <code>points</code> field in the <strong>Record Format</strong>.</li>\n<li><strong>Protector (M6)</strong>: Before the B-Tree is touched, the change is written to the <strong>WAL</strong> and <code>fsync()</code>&#39;d.</li>\n</ol>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-hand-off.svg\" alt=\"The Milestone Handoff\"></p>\n<h3 id=\"3-hardware-soul-the-quotbottleneckquot-hunt\">3. Hardware Soul: The &quot;Bottleneck&quot; Hunt</h3>\n<p>At every stage of this synthesis, the hardware is pushed in different ways:</p>\n<ul>\n<li><strong>M2 (Tokenizer)</strong>: <strong>CPU Bound</strong> (Branch Prediction).</li>\n<li><strong>M3 (VDBE)</strong>: <strong>CPU Bound</strong> (Instruction Cache / L1 Hit Rate).</li>\n<li><strong>M4 (Pager)</strong>: <strong>I/O Bound</strong> (Disk Latency) or <strong>Memory Bound</strong> (DRAM Bandwidth).</li>\n<li><strong>M6 (WAL)</strong>: <strong>I/O Bound</strong> (Bus latency for <code>fsync</code>).</li>\n</ul>\n<p><strong>The Microscope Effect</strong>: When the VDBE executes the <code>UPDATE</code>, it is likely operating on a 64-byte <strong>Cache Line</strong>. If your <code>points</code> integer is at the very end of that line, and the next field is on a different line, the CPU might stall for 100ns just to fetch the neighboring data. </p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-cpu-stalls.svg\" alt=\"The Hardware Tax\"></p>\n<h3 id=\"4-alternative-reality-the-sqlite-quotin-memoryquot-mode\">4. Alternative Reality: The SQLite &quot;In-Memory&quot; Mode</h3>\n<p>If you initialize SQLite with <code>:memory:</code>, Milestone 4 (The Warehouse) and Milestone 6 (The Protector) change completely.</p>\n<ul>\n<li><strong>The Change</strong>: The Pager never calls <code>write()</code>. The WAL is disabled.</li>\n<li><strong>The Result</strong>: The database becomes 10x-100x faster, but if the power flickers, everything vanishes. This proves that <strong>Durability (the &#39;D&#39; in ACID) is the most expensive feature in systems programming.</strong></li>\n</ul>\n<h3 id=\"5-mental-stamina-checklist-the-architects-final-exam\">5. Mental Stamina Checklist: The Architect’s Final Exam</h3>\n<ol>\n<li><strong>The Context Switch</strong>: When the REPL waits for input, your process is &quot;sleeping.&quot; When the user hits Enter, the OS must perform a &quot;Context Switch.&quot; How many thousands of CPU cycles are lost before your <code>InputBuffer</code> even sees the first character?</li>\n<li><strong>The Layer Violation</strong>: If the VDBE (Milestone 3) needs to know the &quot;Page Size&quot; of the Pager (Milestone 4) to optimize its registers, have you broken the &quot;Architecture&quot; of the system? How do you maintain clean boundaries while optimizing across them?</li>\n<li><strong>The Multi-Core Future</strong>: Our engine is currently single-threaded. If we wanted to run the <strong>Tokenizer</strong> on Core 1 and the <strong>VDBE</strong> on Core 2 (Pipelining), what happens to our <strong>Mental Model</strong> of a sequential &quot;Loop&quot;?</li>\n</ol>\n<hr>\n<h1 id=\"the-final-map-beyond-the-atlas\">THE FINAL MAP: BEYOND THE ATLAS</h1>\n<p>You have completed the core curriculum. Below are the &quot;Knowledge Black Holes&quot; expanded for the master-level student.</p>\n<h3 id=\"advanced_contextwrite-ahead-logging-wal\">[[ADVANCED_CONTEXT:Write-Ahead Logging (WAL)]]</h3>\n<p>The WAL is not just a file; it is a <strong>versioning system</strong>. </p>\n<ul>\n<li><strong>The Mechanism</strong>: Every time you write, you create a new version of a page in the WAL. </li>\n<li><strong>The Benefit</strong>: Readers keep looking at the <em>old</em> version in the main DB file. Writers keep appending to the <em>new</em> version in the WAL. This is why SQLite can handle multiple readers and one writer simultaneously without any locking conflicts. It is the closest thing to &quot;free&quot; concurrency.</li>\n</ul>\n<h3 id=\"advanced_contextconcurrency-control-and-acid-compliance\">[[ADVANCED_CONTEXT:Concurrency Control and ACID Compliance]]</h3>\n<p>The &quot;Consistency&quot; in ACID is often the hardest to grasp. It means the database must transition from one valid state to another. If your <strong>B-Tree</strong> split (Milestone 4) is interrupted, &quot;Consistency&quot; is what ensures that the partial split is either finished or rolled back during the next boot. This is achieved via <strong>Idempotent Recovery</strong>—the ability to run the recovery log multiple times and always get the same result.</p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-acid-lifecycle.svg\" alt=\"The ACID Safeguard\"></p>\n<hr>\n<p><strong>GRADUATION STATUS: MASTER ARCHITECT</strong>\nYou have the blueprints. You have the obsession. Now, go build something that lasts.</p>\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<!-- END_MS -->\n\n\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-full-traversal.svg\" alt=\"The Query Lifecycle\"></p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-hand-off.svg\" alt=\"The Milestone Handoff\"></p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-cpu-stalls.svg\" alt=\"The Hardware Tax\"></p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Fdiag-acid-lifecycle.svg\" alt=\"The ACID Safeguard\"></p>\n<!-- END_MS -->\n\n\n\n\n<h1 id=\"tdd\">TDD</h1>\n<p>A modular, register-based relational database engine designed for high throughput and crash-resilience. The architecture prioritizes page-aligned storage, zero-copy serialization, and a Write-Ahead Logging (WAL) protocol to ensure ACID compliance while minimizing I/O bottlenecks.</p>\n<!-- TDD_MOD_ID: mod-compiler -->\n<h2 id=\"module-sql-front-end-amp-compiler\">Module: SQL Front-End &amp; Compiler</h2>\n<h3 id=\"1-technical-specification\">1. Technical Specification</h3>\n<p>The <strong>SQL Front-End &amp; Compiler</strong> module is responsible for the transformation of raw UTF-8 SQL strings into executable VDBE (Virtual Database Engine) bytecode. Its primary responsibilities include:</p>\n<ol>\n<li><strong>Lexical Analysis</strong>: Segmenting the input stream into a sequence of atomic tokens.</li>\n<li><strong>Syntactic Analysis</strong>: Validating the token sequence against the SQL grammar (BNF).</li>\n<li><strong>Semantic Analysis</strong>: Resolving identifiers (table/column names) against the Database Schema.</li>\n<li><strong>Code Generation</strong>: Emitting optimized VDBE opcodes and allocating virtual registers.</li>\n</ol>\n<p>This module operates in a &quot;one-pass&quot; or &quot;two-pass&quot; fashion depending on query complexity, prioritizing minimal memory overhead and zero-copy string references where possible.</p>\n<hr>\n<h3 id=\"2-abstraction-layers\">2. Abstraction Layers</h3>\n<ol>\n<li><strong>Transport Layer (REPL/API)</strong>: Manages the <code>InputBuffer</code> and handles line-ending normalization.</li>\n<li><strong>Lexer Layer</strong>: A state-machine-based tokenizer that emits <code>Token</code> structs.</li>\n<li><strong>Parser Layer</strong>: A recursive-descent or LALR parser that constructs a transient Abstract Syntax Tree (AST) or directly emits bytecode.</li>\n<li><strong>Emission Layer</strong>: The <code>VDBE Assembler</code> which maps logical SQL operations to physical Opcodes.</li>\n</ol>\n<hr>\n<h3 id=\"3-struct-amp-interface-definitions\">3. Struct &amp; Interface Definitions</h3>\n<h4 id=\"31-data-structures\">3.1 Data Structures</h4>\n<p>All structures are designed for 64-bit alignment to minimize CPU cycle waste during memory access.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Memory Alignment: 32 bytes */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> start;</span><span style=\"color:#6A737D\">    /* 8 bytes: Pointer to start of token in input buffer */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> length;</span><span style=\"color:#6A737D\">      /* 4 bytes: Length of token */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> line;</span><span style=\"color:#6A737D\">        /* 4 bytes: Source line for error reporting */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TokenType type;</span><span style=\"color:#6A737D\">       /* 4 bytes: Enum (e.g., TOKEN_SELECT, TOKEN_IDENTIFIER) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> metadata;</span><span style=\"color:#6A737D\">     /* 1 byte: Flags (is_quoted, is_hex, etc.) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> _padding</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">11</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\"> /* 11 bytes: Explicit padding for 32-byte alignment */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} Token;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* VDBE Instruction: 24 bytes */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> opcode;</span><span style=\"color:#6A737D\">       /* 1 byte: The instruction code (e.g., OP_Column) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int32_t</span><span style=\"color:#E1E4E8\"> p1;</span><span style=\"color:#6A737D\">           /* 4 bytes: Operand 1 (often a cursor or register index) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int32_t</span><span style=\"color:#E1E4E8\"> p2;</span><span style=\"color:#6A737D\">           /* 4 bytes: Operand 2 (often a jump destination) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int32_t</span><span style=\"color:#E1E4E8\"> p3;</span><span style=\"color:#6A737D\">           /* 4 bytes: Operand 3 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> p4;</span><span style=\"color:#6A737D\">             /* 8 bytes: Pointer to complex data (strings, blobs) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> _padding</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">  /* 3 bytes: Realignment */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} VDBE_Op;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VDBE_Op</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> instructions;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> count;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> capacity;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> reg_count;</span><span style=\"color:#6A737D\">   /* Number of registers required for this program */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} VDBE_Program;</span></span></code></pre></div>\n\n<h4 id=\"32-method-interface\">3.2 Method Interface</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Tokenizer: Scans next token from cursor */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">Token </span><span style=\"color:#B392F0\">scanner_next_token</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char**</span><span style=\"color:#FFAB70\"> cursor</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Parser: Entry point for SQL Compilation */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">Result </span><span style=\"color:#B392F0\">compile_sql</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> sql</span><span style=\"color:#E1E4E8\">, VDBE_Program</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> out_program</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* CodeGen: Emits an instruction to the program buffer */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> emit_op</span><span style=\"color:#E1E4E8\">(VDBE_Program</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> p</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#FFAB70\"> op</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int32_t</span><span style=\"color:#FFAB70\"> p1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int32_t</span><span style=\"color:#FFAB70\"> p2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int32_t</span><span style=\"color:#FFAB70\"> p3</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"4-algorithm-pseudo-code-the-lexer-quothot-pathquot\">4. Algorithm Pseudo-code: The Lexer &quot;Hot Path&quot;</h3>\n<p>The Lexer is the highest-frequency component. We use a non-destructive pointer-scan.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> get_next_token</span><span style=\"color:#E1E4E8\">(cursor):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Skip whitespace and comments</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> is_whitespace(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">cursor):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor</span><span style=\"color:#FDAEB7;font-style:italic\">++</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cursor</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    char c </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">cursor</span><span style=\"color:#FDAEB7;font-style:italic\">++</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Numeric Literal Path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> is_digit(c):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> is_digit(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">cursor): cursor</span><span style=\"color:#FDAEB7;font-style:italic\">++</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Token(</span><span style=\"color:#79B8FF\">TYPE_NUMBER</span><span style=\"color:#E1E4E8\">, start, cursor </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Identifier / Keyword Path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> is_alpha(c) </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '_'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> is_alnum(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">cursor) </span><span style=\"color:#F97583\">or</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">cursor </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '_'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cursor</span><span style=\"color:#FDAEB7;font-style:italic\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Keyword Lookup (Trie or Hash)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cursor </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        type</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> check_keyword(start, length) </span><span style=\"color:#FDAEB7;font-style:italic\">?</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">TYPE_IDENTIFIER</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Token(</span><span style=\"color:#79B8FF\">type</span><span style=\"color:#E1E4E8\">, start, length)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # String Literal Path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\'</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">cursor </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\'</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> and</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">cursor </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cursor</span><span style=\"color:#FDAEB7;font-style:italic\">++</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">cursor </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\'</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">: cursor</span><span style=\"color:#FDAEB7;font-style:italic\">++</span><span style=\"color:#6A737D\"> # Consume closing quote</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Token(</span><span style=\"color:#79B8FF\">TYPE_STRING</span><span style=\"color:#E1E4E8\">, start, cursor </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Operator Path (Multi-character support)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '>'</span><span style=\"color:#F97583\"> and</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">cursor </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '='</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor</span><span style=\"color:#FDAEB7;font-style:italic\">++</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Token(</span><span style=\"color:#79B8FF\">TYPE_GREATER_EQUAL</span><span style=\"color:#E1E4E8\">, start, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> Token(</span><span style=\"color:#79B8FF\">TYPE_UNKNOWN</span><span style=\"color:#E1E4E8\">, start, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"5-engineering-constraints-amp-hazards\">5. Engineering Constraints &amp; Hazards</h3>\n<h4 id=\"51-concurrency\">5.1 Concurrency</h4>\n<ul>\n<li><strong>Thread Safety</strong>: The Compiler is thread-safe as it maintains no global state. Each <code>compile_sql</code> invocation operates on a thread-local AST and instruction buffer.</li>\n<li><strong>Schema Locks</strong>: During Semantic Analysis, the compiler must acquire a <code>SHARED_LOCK</code> on the Schema to ensure table definitions do not change mid-compilation.</li>\n</ul>\n<h4 id=\"52-memory-management\">5.2 Memory Management</h4>\n<ul>\n<li><strong>Arena Allocation</strong>: To avoid heap fragmentation during parsing, all AST nodes are allocated in a contiguous <code>Arena</code> that is wiped immediately after <code>VDBE_Program</code> emission.</li>\n<li><strong>String Interning</strong>: Repeated identifiers (e.g., column names in a large join) are interned to reduce memory footprint and allow pointer-comparison instead of <code>strcmp</code>.</li>\n</ul>\n<h4 id=\"53-performance-amp-micro-optimization\">5.3 Performance &amp; Micro-Optimization</h4>\n<ul>\n<li><strong>Branch Prediction</strong>: The <code>scanner_next_token</code> function uses <code>unlikely()</code> macros for error conditions (e.g., unterminated strings) to keep the &quot;Happy Path&quot; instructions linear in the CPU pipeline.</li>\n<li><strong>SIMD Tokenization</strong>: For large bulk-load statements, the lexer can utilize SIMD (SSE4.2 <code>pcmpistri</code>) to find delimiters (commas, quotes, newlines) 16 bytes at a time.</li>\n<li><strong>Cache Locality</strong>: <code>Token</code> structs are small (32 bytes) to ensure multiple tokens fit within a single 64-byte L1 cache line during lookahead operations.</li>\n</ul>\n<hr>\n<h3 id=\"6-diagrams\">6. Diagrams</h3>\n<p>{{DIAGRAM:tdd-sql-flow}}\n{{DIAGRAM:tdd-diag-compiler-stage}}</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">mermaid</span><pre class=\"arch-pre shiki-highlighted\"><code>sequenceDiagram\n    participant U as User/API\n    participant L as Lexer\n    participant P as Parser\n    participant S as Schema\n    participant C as CodeGen\n    participant V as VDBE\n\n    U-&gt;&gt;L: raw_sql_string\n    loop until EOF\n        L-&gt;&gt;P: emit(Token)\n    end\n    P-&gt;&gt;S: resolve_identifiers(table_name)\n    S--&gt;&gt;P: column_metadata\n    P-&gt;&gt;C: logical_plan\n    C-&gt;&gt;C: optimize_jumps()\n    C--&gt;&gt;V: VDBE_Program (Bytecode)\n    V-&gt;&gt;U: Result/Execution</code></pre></div>\n\n\n<!-- TDD_MOD_ID: mod-vdbe -->\n<h1 id=\"module-virtual-database-engine-vdbe\">Module: Virtual Database Engine (VDBE)</h1>\n<h2 id=\"1-technical-specification\">1. Technical Specification</h2>\n<p>The <strong>Virtual Database Engine (VDBE)</strong> is a register-based virtual machine designed to execute the bytecode emitted by the SQL Compiler. It serves as the bridge between high-level logical plans and the low-level B-Tree storage layer.</p>\n<h3 id=\"primary-responsibilities\">Primary Responsibilities:</h3>\n<ol>\n<li><strong>Instruction Execution</strong>: Sequential processing of opcodes (e.g., <code>OpenRead</code>, <code>Column</code>, <code>Next</code>).</li>\n<li><strong>Register Management</strong>: Maintenance of a virtual register file for intermediate data storage.</li>\n<li><strong>Cursor Orchestration</strong>: Managing pointers (cursors) into B-Tree pages for row-level traversal.</li>\n<li><strong>Transaction Control</strong>: Interfacing with the Pager to initiate commits, rollbacks, and savepoints.</li>\n<li><strong>Data Serialization</strong>: Encoding and decoding the Record Format (Milestone 7) into registers.</li>\n</ol>\n<hr>\n<h2 id=\"2-abstraction-layers\">2. Abstraction Layers</h2>\n<ol>\n<li><strong>Execution Loop (The Dispatcher)</strong>: The central loop that fetches the next instruction and jumps to the handler.</li>\n<li><strong>Register File (The Memory)</strong>: An array of <code>Mem</code> structures representing registers.</li>\n<li><strong>Cursor Layer (The Iterator)</strong>: An abstraction over B-Tree pages that maintains position, state (EOF), and cache for the current row.</li>\n<li><strong>Storage Interface (The VFS/Pager)</strong>: Direct hooks into the Pager for atomic disk I/O.</li>\n</ol>\n<hr>\n<h2 id=\"3-struct-amp-interface-definitions\">3. Struct &amp; Interface Definitions</h2>\n<h3 id=\"31-data-structures\">3.1 Data Structures</h3>\n<p>Structures are optimized for <strong>L1/L2 cache locality</strong> and <strong>8-byte boundary alignment</strong>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Register Type Tag */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MEM_Null, MEM_Int, MEM_Real, MEM_Str, MEM_Blob, MEM_Undefined</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} MemType;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Register (Mem): 24 bytes </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Tagged union representing a single VDBE register.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    union</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int64_t</span><span style=\"color:#E1E4E8\"> i;</span><span style=\"color:#6A737D\">         /* Integer value */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        double</span><span style=\"color:#E1E4E8\"> r;</span><span style=\"color:#6A737D\">          /* Real (Floating point) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">z;</span><span style=\"color:#6A737D\">           /* String or Blob pointer */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } u;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> n;</span><span style=\"color:#6A737D\">            /* Size of string/blob */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> flags;</span><span style=\"color:#6A737D\">        /* MemType and internal state */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> _padding</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">   /* Align to 8-byte boundary */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} Mem;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * VdbeCursor: 48 bytes </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Tracks position within a specific B-Tree.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BtCursor </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pCursor;</span><span style=\"color:#6A737D\">     /* Pointer to underlying B-Tree cursor */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> eState;</span><span style=\"color:#6A737D\">        /* Cursor state: VALID, INVALID, EOF */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> isReadOnly;</span><span style=\"color:#6A737D\">    /* Permission flag */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int32_t</span><span style=\"color:#E1E4E8\"> iPage;</span><span style=\"color:#6A737D\">         /* Current page index */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> nFields;</span><span style=\"color:#6A737D\">      /* Number of columns in the current row */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> _padding</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">22</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">  /* Ensure alignment for array access */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} VdbeCursor;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Vdbe: The VM State Machine </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VDBE_Program </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pProg;</span><span style=\"color:#6A737D\">   /* The bytecode to execute */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Mem </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">aReg;</span><span style=\"color:#6A737D\">             /* Register file (array of Mem) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VdbeCursor </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">apCsr;</span><span style=\"color:#6A737D\">    /* Array of active cursors */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int32_t</span><span style=\"color:#E1E4E8\"> pc;</span><span style=\"color:#6A737D\">            /* Program Counter */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> errorMask;</span><span style=\"color:#6A737D\">     /* Error state */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> status;</span><span style=\"color:#6A737D\">        /* VM status: HALT, RUNNING, YIELD */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} Vdbe;</span></span></code></pre></div>\n\n<h3 id=\"32-method-interface\">3.2 Method Interface</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Execution Entry */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> vdbe_step</span><span style=\"color:#E1E4E8\">(Vdbe </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">p</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Register Accessors */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int64_t</span><span style=\"color:#B392F0\"> vdbe_get_int</span><span style=\"color:#E1E4E8\">(Vdbe </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">p</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> regIdx</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> vdbe_set_str</span><span style=\"color:#E1E4E8\">(Vdbe </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">p</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> regIdx</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">z</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> n</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Cursor Operations */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> vdbe_cursor_seek</span><span style=\"color:#E1E4E8\">(VdbeCursor </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">pCsr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int64_t</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"4-algorithm-pseudo-code-the-hot-path\">4. Algorithm Pseudo-code: The Hot Path</h2>\n<p>The &quot;Hot Path&quot; is the instruction dispatch loop. In high-performance builds, we replace the <code>switch</code> with <strong>Computed Gotos</strong>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Standard VDBE Execution Loop */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> vdbe_exec</span><span style=\"color:#E1E4E8\">(Vdbe </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">p</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Opcode Handler Table (Computed Goto Labels) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">labels</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> { </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        &#x26;&#x26;</span><span style=\"color:#E1E4E8\">L_OP_Init, </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">L_OP_OpenRead, </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">L_OP_Column, </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\">L_OP_Next, ... </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (p->status </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> RUNNING) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        VDBE_Op </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pOp </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">p->pProg->instructions[p->pc];</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Jump to instruction handler */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        goto</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">labels</span><span style=\"color:#E1E4E8\">[pOp->opcode];</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    L_OP_OpenRead:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* p1: cursor index, p2: root page */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p->apCsr[pOp->p1] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> btree_cursor_open</span><span style=\"color:#E1E4E8\">(pOp->p2);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p->pc</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    L_OP_Column:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* p1: cursor index, p2: column index, p3: dest register */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Mem </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pDest </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">p->aReg[pOp->p3];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        vdbe_extract_column</span><span style=\"color:#E1E4E8\">(p->apCsr[pOp->p1], pOp->p2, pDest);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p->pc</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    L_OP_Next:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* p1: cursor index, p2: jump destination */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">btree_cursor_next</span><span style=\"color:#E1E4E8\">(p->apCsr[pOp->p1])) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            p->pc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pOp->p2;</span><span style=\"color:#6A737D\"> /* Loop back */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            p->pc</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> /* EOF, break loop */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    L_OP_Halt:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p->status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> HALTED;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> SUCCESS;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"5-engineering-constraints-amp-hazards\">5. Engineering Constraints &amp; Hazards</h2>\n<ol>\n<li><strong>Register Pressure</strong>: Complex queries (deeply nested subqueries) can exhaust allocated registers. The compiler must pre-calculate <code>max_registers</code> to avoid dynamic reallocation during execution.</li>\n<li><strong>Cursor Leakage</strong>: If the VM halts due to an error (e.g., Disk I/O Error), all open <code>VdbeCursor</code> objects must be explicitly closed to release Pager locks and memory.</li>\n<li><strong>Recursive Limits</strong>: While the VM is linear, certain opcodes might trigger recursive B-Tree splits. We must enforce a <strong>B-Tree Depth Limit</strong> (typically 20 levels) to prevent stack overflow.</li>\n<li><strong>Floating Point Non-Determinism</strong>: If using the DB for financial calculations, the <code>MEM_Real</code> type must be handled with IEEE 754 precision to ensure consistent results across different CPU architectures.</li>\n</ol>\n<hr>\n<h2 id=\"6-micro-optimization-corner\">6. Micro-Optimization Corner</h2>\n<h3 id=\"61-dispatch-strategy-computed-gotos\">6.1 Dispatch Strategy: Computed Gotos</h3>\n<p>Standard <code>switch</code> statements generate a jump table, but the CPU&#39;s <strong>Branch Target Buffer (BTB)</strong> struggles to predict the destination because every opcode returns to the same <code>switch</code> entry point. <strong>Computed Gotos</strong> (supported by GCC/Clang) allow each opcode handler to jump <em>directly</em> to the next handler, providing the BTB with more specific context and reducing pipeline stalls.</p>\n<h3 id=\"62-data-locality-register-tiling\">6.2 Data Locality: Register Tiling</h3>\n<p>The <code>Mem</code> array should be allocated as a contiguous block. By keeping frequently accessed registers (e.g., those used in a <code>WHERE</code> clause) close together in index space, we increase the probability of they residing in the same <strong>L1 Cache Line</strong>.</p>\n<h3 id=\"63-simd-column-extraction\">6.3 SIMD Column Extraction</h3>\n<p>When processing <code>OP_Column</code> for multiple rows of fixed-width integers, the VDBE can utilize <strong>AVX2/AVX-512</strong> to deserialize 4 or 8 integers from the Record Format into registers simultaneously, bypassing the bit-shifting logic usually required for Varints.</p>\n<hr>\n<h2 id=\"7-diagrams\">7. Diagrams</h2>\n<p>{{DIAGRAM:tdd-vdbe-exec}}</p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-vdbe-dispatch.svg\" alt=\"VDBE Opcode Dispatch\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">mermaid</span><pre class=\"arch-pre shiki-highlighted\"><code>graph TD\n    subgraph VDBE_Core\n        PC[Program Counter] --&gt; Fetch[Fetch Instruction]\n        Fetch --&gt; Dispatch{Computed Goto}\n    end\n\n    subgraph Handlers\n        Dispatch --&gt; OP_Open[OP_OpenRead]\n        Dispatch --&gt; OP_Column[OP_Column]\n        Dispatch --&gt; OP_Next[OP_Next]\n    end\n\n    subgraph Storage_Interface\n        OP_Open --&gt; Pager[Pager/B-Tree]\n        OP_Column --&gt; Record[Record Decoder]\n        OP_Next --&gt; BTree_Scan[B-Tree Page Iterator]\n    end\n\n    subgraph Memory\n        Record --&gt; Regs[Register File]\n        Regs --&gt; Output[Result Set Buffer]\n    end</code></pre></div>\n\n\n<!-- TDD_MOD_ID: mod-storage -->\n<h1 id=\"module-pager-amp-b-tree-storage-engine\">Module: Pager &amp; B-Tree Storage Engine</h1>\n<h2 id=\"1-technical-specification\">1. Technical Specification</h2>\n<p>The <strong>Pager &amp; B-Tree Storage Engine</strong> is the persistence layer of the database. It is responsible for the translation of logical database records into physical on-disk structures while guaranteeing the <strong>ACID</strong> properties (Atomicity, Consistency, Isolation, Durability).</p>\n<h3 id=\"core-responsibilities\">Core Responsibilities:</h3>\n<ol>\n<li><strong>Page Management</strong>: Partitioning the database file into fixed-size blocks (default 4096 bytes) to match physical disk sector alignment.</li>\n<li><strong>Cache Management (Buffer Pool)</strong>: Maintaining an in-memory LRU (Least Recently Used) cache of pages to minimize expensive disk I/O.</li>\n<li><strong>B+Tree Implementation</strong>: Providing $O(\\log N)$ search, insert, and delete performance via a balanced multi-level tree.</li>\n<li><strong>Concurrency Control</strong>: Utilizing page-level latches (mutexes) to allow concurrent readers while protecting structural modifications (splits/merges).</li>\n<li><strong>Recovery &amp; Durability</strong>: Orchestrating the Write-Ahead Log (WAL) to ensure that partial writes during power failure can be rolled forward or back.</li>\n</ol>\n<hr>\n<h2 id=\"2-abstraction-layers\">2. Abstraction Layers</h2>\n<ol>\n<li><strong>VFS Layer (OS Interface)</strong>: Direct interaction with <code>pread()</code>, <code>pwrite()</code>, and <code>fsync()</code>.</li>\n<li><strong>Pager Layer</strong>: Manages the life cycle of a page (Fetch, Dirty, Flush, Evict).</li>\n<li><strong>B-Tree Logic Layer</strong>: Handles the structural integrity (balancing, pointer updates).</li>\n<li><strong>Cell Layer</strong>: Manages the serialization of keys and payloads within a single page&#39;s byte-array.</li>\n</ol>\n<hr>\n<h2 id=\"3-struct-amp-interface-definitions\">3. Struct &amp; Interface Definitions</h2>\n<h3 id=\"31-data-structures\">3.1 Data Structures</h3>\n<p>Memory alignment is strictly enforced to 8-byte boundaries for metadata and 4096-byte boundaries for page buffers to utilize O_DIRECT I/O where available.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#79B8FF\"> pgno_t</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> /* Page Number Type */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* B-Tree Node Types */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BT_INTERNAL_NODE </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">05</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BT_LEAF_NODE </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">0D</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} BtNodeType;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * B-Tree Page Header: 12 bytes </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Located at the start of every 4KB page.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\">  type;</span><span style=\"color:#6A737D\">           /* Node type (Internal/Leaf) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> free_start;</span><span style=\"color:#6A737D\">     /* Start of free space in the page */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> cell_count;</span><span style=\"color:#6A737D\">     /* Number of cells (records/pointers) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> right_child;</span><span style=\"color:#6A737D\">    /* Right-most child pgno (Internal only) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\">  _padding</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} BtPageHeader;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Pager Cache Entry: 4128 bytes (approx)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Alignment: 4096 (for buffer) + metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> Page {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> data;</span><span style=\"color:#6A737D\">              /* 4KB Page Buffer (aligned to 4096) */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pgno_t</span><span style=\"color:#E1E4E8\"> pgno;</span><span style=\"color:#6A737D\">             /* Page Number */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> is_dirty;</span><span style=\"color:#6A737D\">        /* Flag: Needs write to disk */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> ref_count;</span><span style=\"color:#6A737D\">      /* Current users of this page */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> Page </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">next_lru;</span><span style=\"color:#6A737D\">   /* Pointer for LRU linked list */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> Page </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">prev_lru;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} Page;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * B-Tree Search Cursor: 64 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> BtCursor {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Pager </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pPager;</span><span style=\"color:#6A737D\">           /* Parent Pager */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pgno_t</span><span style=\"color:#E1E4E8\"> root_pgno;</span><span style=\"color:#6A737D\">        /* Root of the tree */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Page </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pCurrentPage;</span><span style=\"color:#6A737D\">      /* Current page held in memory */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> cell_idx;</span><span style=\"color:#6A737D\">       /* Current cell index within the page */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> eState;</span><span style=\"color:#6A737D\">          /* VALID, EOF, FAULT */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> _padding</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">31</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">    /* Alignment */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} BtCursor;</span></span></code></pre></div>\n\n<h3 id=\"32-method-interface\">3.2 Method Interface</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Pager: Fetch a page from disk or cache */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> pager_acquire</span><span style=\"color:#E1E4E8\">(Pager </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">pPager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">pgno_t</span><span style=\"color:#FFAB70\"> pgno</span><span style=\"color:#E1E4E8\">, Page </span><span style=\"color:#F97583\">**</span><span style=\"color:#FFAB70\">ppPage</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Pager: Release page back to cache; decrement ref_count */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> pager_release</span><span style=\"color:#E1E4E8\">(Page </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">pPage</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* B-Tree: Seek to a key (entry point for SELECT/UPDATE) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> btree_seek</span><span style=\"color:#E1E4E8\">(BtCursor </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">pCur</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pRes</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* B-Tree: Insert a new cell (triggers splits if necessary) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> btree_insert</span><span style=\"color:#E1E4E8\">(BtCursor </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">pCur</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#FFAB70\"> key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pPayload</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> nPayload</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"4-algorithm-pseudo-code-the-quothot-pathquot-b-tree-search\">4. Algorithm Pseudo-code: The &quot;Hot Path&quot; (B-Tree Search)</h2>\n<p>This algorithm traverses the tree from root to leaf. It is performance-critical as it is invoked for every row lookup.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> btree_seek_recursive</span><span style=\"color:#E1E4E8\">(pager, pgno, target_key, cursor):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # 1. Acquire page from Pager (Cache or Disk)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    page </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pager.acquire(pgno)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parse_header(page.data)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # 2. Binary Search within the page's Cell Pointer Array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Cells are stored at the end of the page; pointers at the start.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> binary_search_cells(page, target_key)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> header.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> BT_LEAF_NODE</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # We found the leaf where the key should reside</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor.pCurrentPage </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cursor.cell_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> idx</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> SUCCESS</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Internal Node: idx points to the child subtree</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        child_pgno </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> get_child_pgno(page, idx)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pager.release(page) </span><span style=\"color:#6A737D\"># Release parent before descending</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> btree_seek_recursive(pager, child_pgno, target_key, cursor)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> binary_search_cells</span><span style=\"color:#E1E4E8\">(page, target_key):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Micro-optimized inner loop</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    low </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    high </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> page.header.cell_count </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> low </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> high:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mid </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (low </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> high) </span><span style=\"color:#F97583\">//</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cell_key </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> get_key_at_idx(page, mid)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> cell_key </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> target_key: </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> mid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> cell_key </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> target_key: low </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mid </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">: high </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mid </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> low </span><span style=\"color:#6A737D\"># Returns insertion point if not found</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"5-engineering-constraints-amp-hazards\">5. Engineering Constraints &amp; Hazards</h2>\n<h3 id=\"51-the-quottorn-writequot-hazard\">5.1 The &quot;Torn Write&quot; Hazard</h3>\n<p><strong>Problem</strong>: The OS might crash while the disk is writing a 4KB page, leaving the first 2KB as new data and the last 2KB as old data.\n<strong>Solution</strong>: The Pager must implement a <strong>Double-Write Buffer</strong> or <strong>WAL Checksumming</strong>. Every page write is first recorded in the WAL with a CRC32 checksum. During recovery, if a page&#39;s checksum fails, the WAL version is used to restore integrity.</p>\n<h3 id=\"52-cache-pressure-amp-eviction\">5.2 Cache Pressure &amp; Eviction</h3>\n<p><strong>Constraint</strong>: The Pager must not evict &quot;Dirty&quot; pages (modified in RAM but not on disk) unless they are first flushed.\n<strong>Hazard</strong>: If the cache is 100% dirty and the disk is full, the engine enters a <strong>Livelock</strong> state.\n<strong>Design</strong>: Maintain a <code>min_free_pages</code> threshold. When the cache reaches 80% capacity, a background &quot;Checkpointer&quot; thread begins flushing dirty pages to the WAL and marking them clean.</p>\n<h3 id=\"53-concurrency-b-tree-latching\">5.3 Concurrency (B-Tree Latching)</h3>\n<p><strong>Mechanism</strong>: Use <strong>Read-Write Latches</strong> on pages.</p>\n<ul>\n<li><strong>Search</strong>: Acquire <code>SHARED</code> latch on parent, then child, then release parent (Crabbing).</li>\n<li><strong>Insert/Split</strong>: Must acquire <code>EXCLUSIVE</code> latches from the root down if a split is likely (Pre-emptive splitting) to prevent deadlocks where a child needs to lock its parent.</li>\n</ul>\n<hr>\n<h2 id=\"6-micro-optimization-corner\">6. Micro-Optimization Corner</h2>\n<h3 id=\"61-cache-locality-cell-pointer-array\">6.1 Cache Locality: Cell Pointer Array</h3>\n<p>Inside the 4KB page, we do not store cells in order. We store them anywhere in the heap space at the end of the page. We maintain a <strong>Cell Pointer Array</strong> at the top. This ensures that the binary search only iterates over a contiguous array of 2-byte offsets, which fits entirely in a single <strong>L1 Cache Line</strong>, avoiding expensive DRAM fetches during the search loop.</p>\n<h3 id=\"62-simd-binary-search\">6.2 SIMD Binary Search</h3>\n<p>For pages with high fan-out (e.g., thousands of small keys), the <code>binary_search_cells</code> can be vectorized using <strong>AVX2</strong>. We can load 8 or 16 cell keys into a YMM register and perform a parallel comparison, effectively reducing the binary search branches by $log_2(8)$.</p>\n<hr>\n<h2 id=\"7-diagrams\">7. Diagrams</h2>\n<p>{{DIAGRAM:tdd-pager-btree-arch}}\n{{DIAGRAM:tdd-btree-split-seq}}</p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-storage-layout.svg\" alt=\"Physical Storage Layout\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">mermaid</span><pre class=\"arch-pre shiki-highlighted\"><code>graph TD\n    subgraph Pager_Layer\n        Cache[Page Cache / LRU]\n        WAL[Write Ahead Log]\n        VFS[Virtual File System]\n    end\n\n    subgraph BTree_Layer\n        Root[Root Page]\n        Internal[Internal Nodes]\n        Leaf[Leaf Nodes]\n    end\n\n    VDBE[VDBE Engine] --&gt;|Request pgno| Cache\n    Cache --&gt;|Miss| VFS\n    Cache --&gt;|Hit| BTree_Layer\n    BTree_Layer --&gt;|Search| Internal\n    Internal --&gt;|Pointer| Leaf\n    Leaf --&gt;|Update| Dirty[Mark Page Dirty]\n    Dirty --&gt; WAL\n    WAL --&gt;|Commit| VFS</code></pre></div>\n\n\n<!-- TDD_MOD_ID: mod-tx-manager -->\n<h1 id=\"module-transaction-amp-concurrency-controller\">Module: Transaction &amp; Concurrency Controller</h1>\n<h2 id=\"1-technical-specification\">1. Technical Specification</h2>\n<p>The <strong>Transaction &amp; Concurrency Controller (TCC)</strong> is the architectural arbiter of the database. Its primary mandate is to enforce <strong>ACID</strong> (Atomicity, Consistency, Isolation, Durability) guarantees across multi-threaded and multi-process environments.</p>\n<h3 id=\"responsibilities\">Responsibilities:</h3>\n<ol>\n<li><strong>Isolation Management</strong>: Implementing a 5-state locking protocol (UNLOCKED, SHARED, RESERVED, PENDING, EXCLUSIVE) to prevent race conditions.</li>\n<li><strong>Atomicity via WAL</strong>: Orchestrating the Write-Ahead Log (WAL) to ensure that transactions are &quot;all-or-nothing.&quot;</li>\n<li><strong>Concurrency Optimization</strong>: Enabling &quot;Readers-don&#39;t-block-Writers&quot; semantics using a WAL-based Multi-Version Concurrency Control (MVCC) subset.</li>\n<li><strong>Recovery Coordination</strong>: Replaying or rolling back log frames during system initialization after an ungraceful shutdown.</li>\n<li><strong>Deadlock Avoidance</strong>: Enforcing strict lock-acquisition hierarchies to prevent circular dependencies.</li>\n</ol>\n<hr>\n<h2 id=\"2-abstraction-layers\">2. Abstraction Layers</h2>\n<ol>\n<li><strong>The API Layer (Transaction Guard)</strong>: High-level <code>BEGIN</code>, <code>COMMIT</code>, and <code>ROLLBACK</code> logic.</li>\n<li><strong>The Lock Manager</strong>: An internal state machine managing the transition between lock levels using atomic primitives.</li>\n<li><strong>The WAL Director</strong>: Manages the append-only <code>.wal</code> file and the shared-memory index (<code>.wal-index</code>).</li>\n<li><strong>The Checkpointer</strong>: A background process that migrates committed data from the WAL back to the main database file.</li>\n</ol>\n<hr>\n<h2 id=\"3-struct-amp-interface-definitions\">3. Struct &amp; Interface Definitions</h2>\n<h3 id=\"31-data-structures\">3.1 Data Structures</h3>\n<p>Structures are padded to 64-bit boundaries to prevent &quot;False Sharing&quot; in multi-core L1 caches and to ensure atomic 8-byte alignment.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Lock State Taxonomy */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LOCK_NONE      </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\"> // Unlocked</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LOCK_SHARED    </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\"> // Read-only; multiple allowed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LOCK_RESERVED  </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\"> // Plan to write; only one allowed; shared locks persist</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LOCK_PENDING   </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\"> // Waiting for shared locks to clear before EXCLUSIVE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LOCK_EXCLUSIVE </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#6A737D\">  // Writing; no other connections allowed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} LockLevel;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Transaction Context: 64 bytes </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Tracks the state of a single connection's transaction.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> tx_id;</span><span style=\"color:#6A737D\">          /* 8 bytes: Monotonically increasing ID */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LockLevel lock_level;</span><span style=\"color:#6A737D\">    /* 4 bytes: Current lock state */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> wal_index_pos;</span><span style=\"color:#6A737D\">  /* 4 bytes: Last known good position in WAL */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> is_autocommit;</span><span style=\"color:#6A737D\">   /* 1 byte: Flag for implicit transactions */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> dirty_flag;</span><span style=\"color:#6A737D\">      /* 1 byte: True if memory pages were modified */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> _padding</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">46</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">    /* Padding to reach 64-byte (Cache Line) alignment */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} TxContext;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * WAL Frame Header: 24 bytes </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Precedes every page-blob in the WAL file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pgno;</span><span style=\"color:#6A737D\">           /* 4 bytes: Target page number in main DB */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> commit_flag;</span><span style=\"color:#6A737D\">    /* 4 bytes: Non-zero if this is a commit record */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> sequence;</span><span style=\"color:#6A737D\">       /* 8 bytes: Checksum or sequence number */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> salt1;</span><span style=\"color:#6A737D\">          /* 4 bytes: Random salt for checksum integrity */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> salt2;</span><span style=\"color:#6A737D\">          /* 4 bytes: Random salt */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} WalFrameHeader;</span></span></code></pre></div>\n\n<h3 id=\"32-method-interface\">3.2 Method Interface</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Transition the connection to a new lock state */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> tcc_acquire_lock</span><span style=\"color:#E1E4E8\">(TxContext </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#E1E4E8\">, LockLevel </span><span style=\"color:#FFAB70\">required</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Write a dirty page to the WAL buffer */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> tcc_wal_append</span><span style=\"color:#E1E4E8\">(TxContext </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">pgno_t</span><span style=\"color:#FFAB70\"> pgno</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">page_data</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Atomic commit: Write commit frame and fsync */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> tcc_commit</span><span style=\"color:#E1E4E8\">(TxContext </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Recovery: Replay WAL into main DB */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> tcc_checkpoint</span><span style=\"color:#E1E4E8\">(Pager </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">pPager</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"4-algorithm-pseudo-code-the-quothot-pathquot-acquire-lock\">4. Algorithm Pseudo-code: The &quot;Hot Path&quot; (Acquire Lock)</h2>\n<p>The <code>tcc_acquire_lock</code> function is the bottleneck for write throughput. It utilizes a non-blocking state machine with exponential backoff on contention.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> tcc_acquire_lock</span><span style=\"color:#E1E4E8\">(ctx, requested_level):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ctx.lock_level</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> requested_level:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> SUCCESS</span><span style=\"color:#6A737D\"> # Already held</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Logic: SHARED -> RESERVED -> PENDING -> EXCLUSIVE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> requested_level </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> LOCK_SHARED</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Atomic Increment on Shared-Memory Read-Counter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> atomic_inc_if_not_exclusive(shm.read_count):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ctx.lock_level </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> LOCK_SHARED</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> SUCCESS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> ERR_BUSY</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> requested_level </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> LOCK_RESERVED</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Only one RESERVED lock allowed globally</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> atomic_compare_and_swap(shm.reserved_flag, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ctx.lock_level </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> LOCK_RESERVED</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> SUCCESS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> ERR_BUSY</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> requested_level </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> LOCK_EXCLUSIVE</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 1. Promote to PENDING (Block new readers)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> atomic_compare_and_swap(shm.pending_flag, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> ERR_BUSY</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 2. Wait for existing readers to exit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> shm.read_count </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            wait_with_backoff()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 3. Final promotion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ctx.lock_level </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> LOCK_EXCLUSIVE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> SUCCESS</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"5-engineering-constraints-amp-hazards\">5. Engineering Constraints &amp; Hazards</h2>\n<h3 id=\"51-the-quotcheckpoint-starvationquot-problem\">5.1 The &quot;Checkpoint Starvation&quot; Problem</h3>\n<p><strong>Hazard</strong>: If a database has constant high-frequency read traffic, the <code>shm.read_count</code> may never reach zero, preventing the Checkpointer from acquiring an <code>EXCLUSIVE</code> lock to merge the WAL back to the main DB.\n<strong>Constraint</strong>: The TCC must implement a &quot;Queue Priority&quot; where, after a threshold, new Shared lock requests are queued behind a pending Checkpoint to ensure the WAL doesn&#39;t grow infinitely (Write Amplification).</p>\n<h3 id=\"52-memory-barriers-amp-visibility\">5.2 Memory Barriers &amp; Visibility</h3>\n<p><strong>Hazard</strong>: In multi-core systems, a thread on Core 1 might write a <code>commit_flag</code> to the WAL-index in RAM, but Core 2 might not &quot;see&quot; it due to CPU cache delay.\n<strong>Requirement</strong>: Use <strong>Store-Load Barriers</strong> (<code>__smp_mb()</code>) immediately after writing the <code>commit_flag</code> and before signaling other threads.</p>\n<h3 id=\"53-micro-optimization-lock-free-wal-tracking\">5.3 Micro-Optimization: Lock-Free WAL Tracking</h3>\n<p>The WAL-index (shared memory) uses a lock-free <strong>Hash Table</strong> to map <code>pgno</code> (Page Number) to <code>wal_offset</code>. </p>\n<ul>\n<li><strong>Optimization</strong>: Use a linear-probing hash map where each entry is a single 64-bit integer (32-bit <code>pgno</code> | 32-bit <code>offset</code>). This allows the entire lookup to be performed with a single atomic <code>LDR</code> (load) instruction, bypassing mutex overhead entirely for read queries.</li>\n</ul>\n<hr>\n<h2 id=\"6-diagrams\">6. Diagrams</h2>\n<p>{{DIAGRAM:tdd-tx-states}}\n{{DIAGRAM:tdd-wal-flow}}</p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-lock-matrix.svg\" alt=\"Lock Compatibility Matrix\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">mermaid</span><pre class=\"arch-pre shiki-highlighted\"><code>sequenceDiagram\n    participant V as VDBE\n    participant T as TCC_Manager\n    participant W as WAL_Log\n    participant D as Disk_DB\n\n    V-&gt;&gt;T: BEGIN TRANSACTION\n    T-&gt;&gt;T: Acquire SHARED Lock\n    V-&gt;&gt;T: UPDATE row (Dirty Page 5)\n    T-&gt;&gt;T: Acquire RESERVED Lock\n    T-&gt;&gt;W: Write Page 5 to WAL\n    V-&gt;&gt;T: COMMIT\n    T-&gt;&gt;T: Promote to EXCLUSIVE\n    T-&gt;&gt;W: Write COMMIT Frame\n    T-&gt;&gt;W: FSYNC(wal_file)\n    T-&gt;&gt;T: Downgrade to SHARED\n    Note over T,D: Checkpointer runs later...\n    T-&gt;&gt;D: Merge WAL to Main DB</code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">mermaid</span><pre class=\"arch-pre shiki-highlighted\"><code>stateDiagram-v2\n    [*] --&gt; UNLOCKED\n    UNLOCKED --&gt; SHARED: Read Request\n    SHARED --&gt; RESERVED: Write Intent\n    RESERVED --&gt; PENDING: Commit Start\n    PENDING --&gt; EXCLUSIVE: Read Count == 0\n    EXCLUSIVE --&gt; UNLOCKED: Commit Finish\n    RESERVED --&gt; UNLOCKED: Rollback</code></pre></div>\n\n\n<!-- TDD_MOD_ID: mod-serialization -->\n<!-- TDD_MOD_ID: mod-record-schema -->\n<h1 id=\"module-record-serialization-amp-schema-manager\">Module: Record Serialization &amp; Schema Manager</h1>\n<h2 id=\"1-technical-specification\">1. Technical Specification</h2>\n<p>The <strong>Record Serialization &amp; Schema Manager</strong> is the &quot;translator&quot; between the VDBE’s high-level register representations and the B-Tree’s raw byte payloads. This module implements a variable-length, packed-header format designed to minimize disk footprint and support schema evolution without requiring full-table rewrites.</p>\n<h3 id=\"core-responsibilities\">Core Responsibilities:</h3>\n<ol>\n<li><strong>Varint Encoding/Decoding</strong>: Implementing a 7-bit-per-byte variable-length integer format to represent metadata and small integers efficiently.</li>\n<li><strong>Record Compaction</strong>: Packing heterogeneous data types (Int, Float, String, Blob, Null) into a contiguous byte stream.</li>\n<li><strong>Serial Type Mapping</strong>: Assigning &quot;Serial Type IDs&quot; to represent data categories and lengths within the record header.</li>\n<li><strong>Schema Versioning</strong>: Managing the <code>schema_cookie</code> to ensure the VDBE bytecode matches the physical layout of the stored records.</li>\n<li><strong>Null-Efficiency</strong>: Encoding <code>NULL</code>, <code>0</code>, and <code>1</code> as header-only types requiring zero payload bytes.</li>\n</ol>\n<hr>\n<h2 id=\"2-abstraction-layers\">2. Abstraction Layers</h2>\n<ol>\n<li><strong>Logical Layer (Schema)</strong>: Defines the mapping of column names to indices and affinity types (e.g., Column 0 is <code>INTEGER PRIMARY KEY</code>).</li>\n<li><strong>Transformation Layer (VDBE Registers)</strong>: Maps <code>Mem</code> structs (Milestone 8) to the Serialization Logic.</li>\n<li><strong>Physical Layer (Record Format)</strong>: The byte-array layout consisting of a <code>Header Length</code>, <code>Serial Type Array</code>, and <code>Data Payload</code>.</li>\n</ol>\n<hr>\n<h2 id=\"3-struct-amp-interface-definitions\">3. Struct &amp; Interface Definitions</h2>\n<h3 id=\"31-data-structures\">3.1 Data Structures</h3>\n<p>The serialization structures are optimized for zero-copy access where the header can be parsed without moving the payload.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Serial Type Mappings (Subset of SQLite Spec)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * 0: NULL, 1-6: Integers (1-8 bytes), 7: Float64, 8: Integer 0, 9: Integer 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * 12+: Blob/String (Length = (N-12)/2 or (N-13)/2)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#79B8FF\"> serial_type_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Record Descriptor: 32 bytes </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Transient structure used during packing/unpacking.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> header_len;</span><span style=\"color:#6A737D\">    /* 4 bytes: Size of the header section */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> payload_len;</span><span style=\"color:#6A737D\">   /* 4 bytes: Total size of the record */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p_header;</span><span style=\"color:#6A737D\">      /* 8 bytes: Pointer to start of serial types */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p_payload;</span><span style=\"color:#6A737D\">     /* 8 bytes: Pointer to start of actual data */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> num_columns;</span><span style=\"color:#6A737D\">   /* 2 bytes: Count of columns in this record */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> _padding</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">    /* 6 bytes: 64-bit alignment */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} RecordDescriptor;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Column Schema: 24 bytes </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Stored in the sqlite_master internal table.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> name;</span><span style=\"color:#6A737D\">             /* 8 bytes */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> affinity;</span><span style=\"color:#6A737D\">       /* 1 byte: TEXT, NUMERIC, INTEGER, BLOB, REAL */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> is_pk;</span><span style=\"color:#6A737D\">          /* 1 byte: Primary Key flag */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> not_null;</span><span style=\"color:#6A737D\">       /* 1 byte: Constraint flag */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> default_reg;</span><span style=\"color:#6A737D\">   /* 4 bytes: Index of register containing default value */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> _padding</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">9</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ColumnDef;</span></span></code></pre></div>\n\n<h3 id=\"32-method-interface\">3.2 Method Interface</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Encode a 64-bit integer into a Varint (1-9 bytes) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> record_encode_varint</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">out</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Decode a Varint into a 64-bit integer; returns bytes consumed */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> record_decode_varint</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">in</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">out_value</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Serialize VDBE registers into a B-Tree cell payload */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> record_pack</span><span style=\"color:#E1E4E8\">(Mem </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">aReg</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> nReg</span><span style=\"color:#E1E4E8\">, RecordDescriptor </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">out_rec</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Extract a specific column from a raw byte buffer into a register */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> record_unpack_column</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> col_idx</span><span style=\"color:#E1E4E8\">, Mem </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">pOut</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"4-algorithm-pseudo-code-the-quothot-pathquot\">4. Algorithm Pseudo-code: The &quot;Hot Path&quot;</h2>\n<h3 id=\"41-varint-encoding-performance-critical\">4.1 Varint Encoding (Performance Critical)</h3>\n<p>Used for every column metadata entry and header length.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> record_encode_varint</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#FFAB70\"> v</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">p</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> i, j;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\">( v </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> (((</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">ff000000</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">) ){</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        p</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#E1E4E8\">)v;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        v </span><span style=\"color:#F97583\">>>=</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\">(i</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">){</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            p</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#E1E4E8\">)((v </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">7f</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            v </span><span style=\"color:#F97583\">>>=</span><span style=\"color:#79B8FF\"> 7</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 9</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    n </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    do</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        buf</span><span style=\"color:#E1E4E8\">[n</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#E1E4E8\">)((v </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">7f</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        v </span><span style=\"color:#F97583\">>>=</span><span style=\"color:#79B8FF\"> 7</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\">( v</span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\"> );</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">7f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\">(i</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, j</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">n</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">; j</span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">; j</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">, i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">){</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        p</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[j];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> n;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"42-record-packing-the-write-path\">4.2 Record Packing (The Write Path)</h3>\n<p>This logic transforms VDBE registers into the on-disk record.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> record_pack</span><span style=\"color:#E1E4E8\">(registers, num_cols):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    header_types </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> bytearray</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> reg </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> registers:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> reg.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            header_types.append(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> reg.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> INT</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> reg.val </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">: header_types.append(</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            elif</span><span style=\"color:#E1E4E8\"> reg.val </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">: header_types.append(</span><span style=\"color:#79B8FF\">9</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                stype </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> calculate_int_serial_type(reg.val)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                header_types.append(stype)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                payload.extend(encode_int(reg.val, stype))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> reg.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> STRING</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            stype </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(reg.val) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 13</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            header_types.append(stype)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            payload.extend(reg.val.encode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Calculate Header Length Varint</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    header_bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> bytearray</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> t </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> header_types:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        header_bytes.extend(encode_varint(t))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    total_header_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(header_bytes) </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(encode_varint(</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(header_bytes)))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Final Assembly: [Total Header Len][Types][Data]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> encode_varint(total_header_len) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> header_bytes </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> payload</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"5-engineering-constraints-amp-hazards-micro-optimization-corner\">5. Engineering Constraints &amp; Hazards (Micro-Optimization Corner)</h2>\n<h3 id=\"51-concurrency-amp-persistence\">5.1 Concurrency &amp; Persistence</h3>\n<ul>\n<li><strong>Hazard: Schema Drift</strong>: If a transaction is compiled against Schema Version 1, but a concurrent transaction commits a <code>DROP COLUMN</code> (Schema Version 2), the record layout is invalidated.</li>\n<li><strong>Constraint</strong>: Every <code>RecordDescriptor</code> must check the <code>schema_cookie</code> of the Pager before performing an unpack operation.</li>\n</ul>\n<h3 id=\"52-cache-locality-header-first-unpacking\">5.2 Cache Locality: Header-First Unpacking</h3>\n<ul>\n<li><strong>Optimization</strong>: In SQL, <code>SELECT col_10</code> is common. In a naive implementation, we must decode all previous 9 columns&#39; varints to find the offset of column 10.</li>\n<li><strong>Cache Strategy</strong>: We store the <code>RecordHeader</code> contiguously. Since Varints are 1-byte for most metadata, a single 64-byte L1 cache line usually contains the serial types for ~40 columns. This allows the CPU to scan the header and calculate the offset of <code>col_10</code> without any DRAM fetches.</li>\n</ul>\n<h3 id=\"53-memory-alignment-tax\">5.3 Memory Alignment Tax</h3>\n<ul>\n<li><strong>The Problem</strong>: Packed records ignore CPU alignment. A 64-bit float might start at byte 13 of a page.</li>\n<li><strong>The Solution</strong>: We use <code>memcpy</code> or <code>__builtin_memcpy</code> for multi-byte extractions. Modern CPUs (x86_64/ARMv8) handle unaligned loads in hardware with minimal penalty, provided the load does not straddle a cache-line boundary. For straddling loads, we incur a ~2x latency penalty.</li>\n</ul>\n<h3 id=\"54-simd-varint-decoding\">5.4 SIMD Varint Decoding</h3>\n<p>For bulk scans, decoding Varints byte-by-byte is a bottleneck. </p>\n<ul>\n<li><strong>Advanced Optimization</strong>: Use <strong>BSR (Bit Scan Reverse)</strong> or <code>clz</code> (Count Leading Zeros) to find the termination bit of multiple varints in parallel, or use a PSHUFB-based (SSSE3) shuffle to extract 7-bit values into 8-bit lanes across a 128-bit XMM register.</li>\n</ul>\n<hr>\n<h2 id=\"6-diagrams\">6. Diagrams</h2>\n<p>{{DIAGRAM:tdd-record-format}}</p>\n<p><img src=\"/api/project/build-sqlite/architecture-doc/asset?path=diagrams%2Ftdd-diag-record-logic.svg\" alt=\"Record Anatomy\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">mermaid</span><pre class=\"arch-pre shiki-highlighted\"><code>graph LR\n    subgraph Header\n        HL[Header Len]\n        T1[Type: Int8]\n        T2[Type: String10]\n        T3[Type: Null]\n    end\n    subgraph Payload\n        P1[Byte 0x01]\n        P2[ASCII: 'User_Name']\n        P3[Empty]\n    end\n    HL --&gt; T1\n    T1 --&gt; T2\n    T2 --&gt; T3\n    T1 -.-&gt; P1\n    T2 -.-&gt; P2\n    T3 -.-&gt; P3</code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">mermaid</span><pre class=\"arch-pre shiki-highlighted\"><code>sequenceDiagram\n    participant V as VDBE Register\n    participant S as Serializer\n    participant B as B-Tree Page\n    \n    V-&gt;&gt;S: Mem[Int: 500]\n    V-&gt;&gt;S: Mem[Str: &quot;Atlas&quot;]\n    S-&gt;&gt;S: Calculate SerialTypes (2, 23)\n    S-&gt;&gt;S: Compute Varint Sizes\n    S-&gt;&gt;S: Build Packed Header\n    S-&gt;&gt;B: Write [HeaderLen][2][23][PayloadBytes]\n    B--&gt;&gt;V: Cell Written</code></pre></div>\n\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<h1 id=\"-beyond-the-atlas-further-reading\">📚 Beyond the Atlas: Further Reading</h1>\n<h3 id=\"1-b-trees-the-warehouse\">1. B-Trees (The Warehouse)</h3>\n<ul>\n<li><strong>The Paper</strong>: <a href=\"https://dl.acm.org/doi/10.1145/1734663.1734671\">Organization and Maintenance of Large Ordered Indices</a> (Bayer &amp; McCreight, 1970)</li>\n<li><strong>The RFC</strong>: N/A (De-facto standard in ISO/IEC 9072)</li>\n<li><strong>The Implementation</strong>: <a href=\"https://github.com/sqlite/sqlite/blob/master/src/btree.c\">SQLite B-Tree Module</a></li>\n<li><strong>Short Summary</strong>: The foundational data structure that balances disk I/O by minimizing the tree height for massive datasets.</li>\n</ul>\n<h3 id=\"2-aries-write-ahead-logging-the-protector\">2. ARIES: Write-Ahead Logging (The Protector)</h3>\n<ul>\n<li><strong>The Paper</strong>: <a href=\"https://www.cs.berkeley.edu/~brewer/cs262b/Aries.pdf\">ARIES: A Transaction Recovery Method</a> (Mohan et al., 1992)</li>\n<li><strong>The RFC</strong>: N/A (Standardized in Database theory)</li>\n<li><strong>The Implementation</strong>: <a href=\"https://github.com/postgres/postgres/tree/master/src/backend/access/transam\">PostgreSQL WAL (Write-Ahead Log)</a></li>\n<li><strong>Short Summary</strong>: The gold standard for ensuring database durability and atomicity through log-based recovery.</li>\n</ul>\n<h3 id=\"3-register-based-virtual-machines-the-engine\">3. Register-Based Virtual Machines (The Engine)</h3>\n<ul>\n<li><strong>The Paper</strong>: <a href=\"https://www.usenix.org/legacy/events/vee05/full_papers/p153-shi.pdf\">Virtual Machine Showdown: Stack vs. Registers</a> (Shi et al., 2005)</li>\n<li><strong>The RFC</strong>: N/A</li>\n<li><strong>The Implementation</strong>: <a href=\"https://www.lua.org/source/5.4/lvm.c.html\">Lua VM (The original register-based implementation)</a></li>\n<li><strong>Short Summary</strong>: Demonstrates why register-based VMs outperform stack-based models by reducing instruction dispatch overhead.</li>\n</ul>\n<h3 id=\"4-cost-based-query-optimization-the-strategist\">4. Cost-Based Query Optimization (The Strategist)</h3>\n<ul>\n<li><strong>The Paper</strong>: <a href=\"https://dl.acm.org/doi/pdf/10.1145/800084.802640\">Access Path Selection in a Relational Database System</a> (Selinger et al., 1979)</li>\n<li><strong>The RFC</strong>: N/A</li>\n<li><strong>The Implementation</strong>: <a href=\"https://github.com/duckdb/duckdb/tree/master/src/optimizer\">DuckDB Optimizer</a></li>\n<li><strong>Short Summary</strong>: The seminal work defining how a database estimates query costs to select the most efficient execution path.</li>\n</ul>\n<h3 id=\"5-multi-version-concurrency-control-the-sentinel\">5. Multi-Version Concurrency Control (The Sentinel)</h3>\n<ul>\n<li><strong>The Paper</strong>: <a href=\"https://dl.acm.org/doi/10.1145/319566.319567\">On Optimistic Methods for Concurrency Control</a> (Kung &amp; Robinson, 1981)</li>\n<li><strong>The RFC</strong>: N/A</li>\n<li><strong>The Implementation</strong>: <a href=\"https://github.com/LMDB/lmdb/blob/mdb.master/libraries/liblmdb/mdb.c\">LMDB (Lightning Memory-Mapped Database)</a></li>\n<li><strong>Short Summary</strong>: A sophisticated method allowing concurrent reads and writes without the performance penalty of traditional locking.</li>\n</ul>\n<h3 id=\"6-variable-length-integers-the-assembly-line\">6. Variable-Length Integers (The Assembly Line)</h3>\n<ul>\n<li><strong>The Paper</strong>: <a href=\"https://dl.acm.org/doi/10.1145/1142473.1142512\">Efficient Integer Compression for Column-Oriented Streams</a></li>\n<li><strong>The RFC</strong>: <a href=\"https://protobuf.dev/programming-guides/encoding/#varints\">Protocol Buffers Encoding (Spec)</a></li>\n<li><strong>The Implementation</strong>: <a href=\"https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/io/coded_stream.h\">Google Protobuf Varint C++</a></li>\n<li><strong>Short Summary</strong>: A high-efficiency encoding technique that significantly reduces disk usage by using only the necessary bytes to represent numerical data.</li>\n</ul>\n<h3 id=\"7-virtual-file-system-the-siege\">7. Virtual File System (The Siege)</h3>\n<ul>\n<li><strong>The Paper</strong>: <a href=\"https://dl.acm.org/doi/10.1145/1447.1448\">VFS: A Generic Interface for Filesystems</a> (Kleiman, 1986)</li>\n<li><strong>The RFC</strong>: <a href=\"https://pubs.opengroup.org/onlinepubs/9699919799/functions/contents.html\">POSIX.1 (System Interfaces)</a></li>\n<li><strong>The Implementation</strong>: <a href=\"https://github.com/torvalds/linux/tree/master/fs\">Linux Kernel VFS Layer</a></li>\n<li><strong>Short Summary</strong>: Provides a polymorphic abstraction layer that allows software to interact with diverse storage hardware through a unified interface.</li>\n</ul>\n","toc":[{"level":1,"text":"build-sqlite","id":"build-sqlite"},{"level":1,"text":"THE SYSTEM MAP: ARCHITECTING SQLITE FROM SCRATCH","id":"the-system-map-architecting-sqlite-from-scratch"},{"level":3,"text":"The Knowledge Pillars","id":"the-knowledge-pillars"},{"level":2,"text":"Milestone 1: The Gateway (The REPL &amp; Architecture)","id":"milestone-1-the-gateway-the-repl-amp-architecture"},{"level":3,"text":"Quick Breakdown: The Input Buffer","id":"quick-breakdown-the-input-buffer"},{"level":3,"text":"1. The Naive Trap: The &quot;Fixed-Size&quot; Fallacy","id":"1-the-naive-trap-the-quotfixed-sizequot-fallacy"},{"level":3,"text":"2. The Zen Way: Dynamic Input Management","id":"2-the-zen-way-dynamic-input-management"},{"level":3,"text":"3. Hardware Soul: The Cost of a Cache Miss","id":"3-hardware-soul-the-cost-of-a-cache-miss"},{"level":3,"text":"4. Alternative Reality","id":"4-alternative-reality"},{"level":3,"text":"5. Mental Stamina Checklist","id":"5-mental-stamina-checklist"},{"level":2,"text":"Milestone 2: The Architect (Tokenizing the Void)","id":"milestone-2-the-architect-tokenizing-the-void"},{"level":3,"text":"Quick Breakdown","id":"quick-breakdown"},{"level":3,"text":"1. The Naive Trap: The strtok() Disaster","id":"1-the-naive-trap-the-strtok-disaster"},{"level":3,"text":"2. The Zen Way: The Pointer Scan","id":"2-the-zen-way-the-pointer-scan"},{"level":3,"text":"3. Hardware Soul: Branch Prediction","id":"3-hardware-soul-branch-prediction"},{"level":3,"text":"4. Alternative Reality","id":"4-alternative-reality"},{"level":3,"text":"5. Mental Stamina Checklist","id":"5-mental-stamina-checklist"},{"level":2,"text":"Milestone 3: The Engine (The VDBE - Virtual Database Engine)","id":"milestone-3-the-engine-the-vdbe-virtual-database-engine"},{"level":3,"text":"Quick Breakdown","id":"quick-breakdown"},{"level":3,"text":"1. The Naive Trap: The &quot;Recursive Tree Walk&quot;","id":"1-the-naive-trap-the-quotrecursive-tree-walkquot"},{"level":3,"text":"2. The Zen Way: The Register-Based VM","id":"2-the-zen-way-the-register-based-vm"},{"level":3,"text":"3. Hardware Soul: Instruction Dispatch &amp; Computed Gotos","id":"3-hardware-soul-instruction-dispatch-amp-computed-gotos"},{"level":3,"text":"4. Alternative Reality","id":"4-alternative-reality"},{"level":3,"text":"5. Mental Stamina Checklist","id":"5-mental-stamina-checklist"},{"level":2,"text":"Milestone 4: The Warehouse (The B-Tree &amp; Pager)","id":"milestone-4-the-warehouse-the-b-tree-amp-pager"},{"level":3,"text":"Quick Breakdown","id":"quick-breakdown"},{"level":3,"text":"1. The Naive Trap: The &quot;Append-Only&quot; Log","id":"1-the-naive-trap-the-quotappend-onlyquot-log"},{"level":3,"text":"2. The Zen Way: Page-Aligned B+Trees","id":"2-the-zen-way-page-aligned-btrees"},{"level":3,"text":"3. Hardware Soul: Disk Sectors &amp; Cache Lines","id":"3-hardware-soul-disk-sectors-amp-cache-lines"},{"level":3,"text":"4. Alternative Reality","id":"4-alternative-reality"},{"level":3,"text":"5. Mental Stamina Checklist","id":"5-mental-stamina-checklist"},{"level":2,"text":"Milestone 5: The Strategist (Query Planning &amp; Optimization)","id":"milestone-5-the-strategist-query-planning-amp-optimization"},{"level":3,"text":"Quick Breakdown","id":"quick-breakdown"},{"level":3,"text":"1. The Naive Trap: The &quot;First-Found&quot; Planner","id":"1-the-naive-trap-the-quotfirst-foundquot-planner"},{"level":3,"text":"2. The Zen Way: The Search Space Searcher","id":"2-the-zen-way-the-search-space-searcher"},{"level":3,"text":"3. Hardware Soul: Data Locality and SIMD","id":"3-hardware-soul-data-locality-and-simd"},{"level":3,"text":"4. Alternative Reality","id":"4-alternative-reality"},{"level":3,"text":"5. Mental Stamina Checklist","id":"5-mental-stamina-checklist"},{"level":2,"text":"Milestone 6: The Protector (Transactions &amp; Recovery)","id":"milestone-6-the-protector-transactions-amp-recovery"},{"level":3,"text":"Quick Breakdown","id":"quick-breakdown"},{"level":3,"text":"1. The Naive Trap: The &quot;In-Place&quot; Overwrite","id":"1-the-naive-trap-the-quotin-placequot-overwrite"},{"level":3,"text":"2. The Zen Way: Shadow Paging or WAL","id":"2-the-zen-way-shadow-paging-or-wal"},{"level":3,"text":"3. Hardware Soul: The Disk Controller&#39;s Lie","id":"3-hardware-soul-the-disk-controller39s-lie"},{"level":3,"text":"4. Alternative Reality","id":"4-alternative-reality"},{"level":3,"text":"5. Mental Stamina Checklist","id":"5-mental-stamina-checklist"},{"level":1,"text":"BEYOND THE ATLAS: ADVANCED CONTEXT","id":"beyond-the-atlas-advanced-context"},{"level":3,"text":"[[ADVANCED_CONTEXT:Formal Grammars and Backus-Naur Form]]","id":"advanced_contextformal-grammars-and-backus-naur-form"},{"level":3,"text":"[[ADVANCED_CONTEXT:Concurrency Control and ACID Compliance]]","id":"advanced_contextconcurrency-control-and-acid-compliance"},{"level":3,"text":"[[ADVANCED_CONTEXT:Write-Ahead Logging (WAL)]]","id":"advanced_contextwrite-ahead-logging-wal"},{"level":2,"text":"Milestone 7: The Assembly Line (Row Serialization &amp; The Record Format)","id":"milestone-7-the-assembly-line-row-serialization-amp-the-record-format"},{"level":3,"text":"Quick Breakdown","id":"quick-breakdown"},{"level":3,"text":"1. The Naive Trap: The &quot;C-Struct&quot; Dump","id":"1-the-naive-trap-the-quotc-structquot-dump"},{"level":3,"text":"2. The Zen Way: The Compact Record Format","id":"2-the-zen-way-the-compact-record-format"},{"level":3,"text":"3. Hardware Soul: Data Alignment &amp; The CPU &quot;Tax&quot;","id":"3-hardware-soul-data-alignment-amp-the-cpu-quottaxquot"},{"level":3,"text":"4. Alternative Reality","id":"4-alternative-reality"},{"level":3,"text":"5. Mental Stamina Checklist","id":"5-mental-stamina-checklist"},{"level":2,"text":"Milestone 8: The Interface (The C API &amp; Handshake)","id":"milestone-8-the-interface-the-c-api-amp-handshake"},{"level":3,"text":"1. The Naive Trap: The &quot;One-Shot&quot; String","id":"1-the-naive-trap-the-quotone-shotquot-string"},{"level":3,"text":"2. The Zen Way: The &quot;Prepared Statement&quot; Lifecycle","id":"2-the-zen-way-the-quotprepared-statementquot-lifecycle"},{"level":3,"text":"3. Hardware Soul: The Stack vs. The Heap","id":"3-hardware-soul-the-stack-vs-the-heap"},{"level":3,"text":"5. Mental Stamina Checklist","id":"5-mental-stamina-checklist"},{"level":1,"text":"THE SYSTEM IS COMPLETE","id":"the-system-is-complete"},{"level":2,"text":"Milestone 9: The Sentinel (Concurrency &amp; High-Level Locking)","id":"milestone-9-the-sentinel-concurrency-amp-high-level-locking"},{"level":3,"text":"Quick Breakdown","id":"quick-breakdown"},{"level":3,"text":"1. The Naive Trap: The &quot;Giant Mutex&quot;","id":"1-the-naive-trap-the-quotgiant-mutexquot"},{"level":3,"text":"2. The Zen Way: Multi-Granular Locking &amp; Intent Locks","id":"2-the-zen-way-multi-granular-locking-amp-intent-locks"},{"level":3,"text":"3. Hardware Soul: Atomic CAS and MESI","id":"3-hardware-soul-atomic-cas-and-mesi"},{"level":3,"text":"4. Alternative Reality","id":"4-alternative-reality"},{"level":3,"text":"5. Mental Stamina Checklist","id":"5-mental-stamina-checklist"},{"level":2,"text":"Milestone 10: The Siege (Testing, Fuzzing &amp; The VFS)","id":"milestone-10-the-siege-testing-fuzzing-amp-the-vfs"},{"level":3,"text":"1. The Naive Trap: The &quot;Happy Path&quot; Unit Test","id":"1-the-naive-trap-the-quothappy-pathquot-unit-test"},{"level":3,"text":"2. The Zen Way: The VFS (Virtual File System) &amp; Fault Injection","id":"2-the-zen-way-the-vfs-virtual-file-system-amp-fault-injection"},{"level":3,"text":"3. Hardware Soul: Bit Rot and Cosmic Rays","id":"3-hardware-soul-bit-rot-and-cosmic-rays"},{"level":3,"text":"4. Alternative Reality","id":"4-alternative-reality"},{"level":3,"text":"5. Mental Stamina Checklist","id":"5-mental-stamina-checklist"},{"level":1,"text":"THE BEYOND: ADVANCED CONTEXT EXPANDED","id":"the-beyond-advanced-context-expanded"},{"level":3,"text":"[[ADVANCED_CONTEXT:Application Binary Interface (ABI) Stability]]","id":"advanced_contextapplication-binary-interface-abi-stability"},{"level":3,"text":"[[ADVANCED_CONTEXT:Formal Grammars and Backus-Naur Form]]","id":"advanced_contextformal-grammars-and-backus-naur-form"},{"level":2,"text":"Milestone 11: The Grand Synthesis (The Life of a Query)","id":"milestone-11-the-grand-synthesis-the-life-of-a-query"},{"level":3,"text":"Quick Breakdown: The Full Stack Traversal","id":"quick-breakdown-the-full-stack-traversal"},{"level":3,"text":"1. The Naive Trap: The &quot;Black Box&quot; Assumption","id":"1-the-naive-trap-the-quotblack-boxquot-assumption"},{"level":3,"text":"2. The Zen Way: The Trace-First Mindset","id":"2-the-zen-way-the-trace-first-mindset"},{"level":3,"text":"3. Hardware Soul: The &quot;Bottleneck&quot; Hunt","id":"3-hardware-soul-the-quotbottleneckquot-hunt"},{"level":3,"text":"4. Alternative Reality: The SQLite &quot;In-Memory&quot; Mode","id":"4-alternative-reality-the-sqlite-quotin-memoryquot-mode"},{"level":3,"text":"5. Mental Stamina Checklist: The Architect’s Final Exam","id":"5-mental-stamina-checklist-the-architects-final-exam"},{"level":1,"text":"THE FINAL MAP: BEYOND THE ATLAS","id":"the-final-map-beyond-the-atlas"},{"level":3,"text":"[[ADVANCED_CONTEXT:Write-Ahead Logging (WAL)]]","id":"advanced_contextwrite-ahead-logging-wal"},{"level":3,"text":"[[ADVANCED_CONTEXT:Concurrency Control and ACID Compliance]]","id":"advanced_contextconcurrency-control-and-acid-compliance"},{"level":1,"text":"TDD","id":"tdd"},{"level":2,"text":"Module: SQL Front-End &amp; Compiler","id":"module-sql-front-end-amp-compiler"},{"level":3,"text":"1. Technical Specification","id":"1-technical-specification"},{"level":3,"text":"2. Abstraction Layers","id":"2-abstraction-layers"},{"level":3,"text":"3. Struct &amp; Interface Definitions","id":"3-struct-amp-interface-definitions"},{"level":4,"text":"3.1 Data Structures","id":"31-data-structures"},{"level":4,"text":"3.2 Method Interface","id":"32-method-interface"},{"level":3,"text":"4. Algorithm Pseudo-code: The Lexer &quot;Hot Path&quot;","id":"4-algorithm-pseudo-code-the-lexer-quothot-pathquot"},{"level":3,"text":"5. Engineering Constraints &amp; Hazards","id":"5-engineering-constraints-amp-hazards"},{"level":4,"text":"5.1 Concurrency","id":"51-concurrency"},{"level":4,"text":"5.2 Memory Management","id":"52-memory-management"},{"level":4,"text":"5.3 Performance &amp; Micro-Optimization","id":"53-performance-amp-micro-optimization"},{"level":3,"text":"6. Diagrams","id":"6-diagrams"},{"level":1,"text":"Module: Virtual Database Engine (VDBE)","id":"module-virtual-database-engine-vdbe"},{"level":2,"text":"1. Technical Specification","id":"1-technical-specification"},{"level":3,"text":"Primary Responsibilities:","id":"primary-responsibilities"},{"level":2,"text":"2. Abstraction Layers","id":"2-abstraction-layers"},{"level":2,"text":"3. Struct &amp; Interface Definitions","id":"3-struct-amp-interface-definitions"},{"level":3,"text":"3.1 Data Structures","id":"31-data-structures"},{"level":3,"text":"3.2 Method Interface","id":"32-method-interface"},{"level":2,"text":"4. Algorithm Pseudo-code: The Hot Path","id":"4-algorithm-pseudo-code-the-hot-path"},{"level":2,"text":"5. Engineering Constraints &amp; Hazards","id":"5-engineering-constraints-amp-hazards"},{"level":2,"text":"6. Micro-Optimization Corner","id":"6-micro-optimization-corner"},{"level":3,"text":"6.1 Dispatch Strategy: Computed Gotos","id":"61-dispatch-strategy-computed-gotos"},{"level":3,"text":"6.2 Data Locality: Register Tiling","id":"62-data-locality-register-tiling"},{"level":3,"text":"6.3 SIMD Column Extraction","id":"63-simd-column-extraction"},{"level":2,"text":"7. Diagrams","id":"7-diagrams"},{"level":1,"text":"Module: Pager &amp; B-Tree Storage Engine","id":"module-pager-amp-b-tree-storage-engine"},{"level":2,"text":"1. Technical Specification","id":"1-technical-specification"},{"level":3,"text":"Core Responsibilities:","id":"core-responsibilities"},{"level":2,"text":"2. Abstraction Layers","id":"2-abstraction-layers"},{"level":2,"text":"3. Struct &amp; Interface Definitions","id":"3-struct-amp-interface-definitions"},{"level":3,"text":"3.1 Data Structures","id":"31-data-structures"},{"level":3,"text":"3.2 Method Interface","id":"32-method-interface"},{"level":2,"text":"4. Algorithm Pseudo-code: The &quot;Hot Path&quot; (B-Tree Search)","id":"4-algorithm-pseudo-code-the-quothot-pathquot-b-tree-search"},{"level":2,"text":"5. Engineering Constraints &amp; Hazards","id":"5-engineering-constraints-amp-hazards"},{"level":3,"text":"5.1 The &quot;Torn Write&quot; Hazard","id":"51-the-quottorn-writequot-hazard"},{"level":3,"text":"5.2 Cache Pressure &amp; Eviction","id":"52-cache-pressure-amp-eviction"},{"level":3,"text":"5.3 Concurrency (B-Tree Latching)","id":"53-concurrency-b-tree-latching"},{"level":2,"text":"6. Micro-Optimization Corner","id":"6-micro-optimization-corner"},{"level":3,"text":"6.1 Cache Locality: Cell Pointer Array","id":"61-cache-locality-cell-pointer-array"},{"level":3,"text":"6.2 SIMD Binary Search","id":"62-simd-binary-search"},{"level":2,"text":"7. Diagrams","id":"7-diagrams"},{"level":1,"text":"Module: Transaction &amp; Concurrency Controller","id":"module-transaction-amp-concurrency-controller"},{"level":2,"text":"1. Technical Specification","id":"1-technical-specification"},{"level":3,"text":"Responsibilities:","id":"responsibilities"},{"level":2,"text":"2. Abstraction Layers","id":"2-abstraction-layers"},{"level":2,"text":"3. Struct &amp; Interface Definitions","id":"3-struct-amp-interface-definitions"},{"level":3,"text":"3.1 Data Structures","id":"31-data-structures"},{"level":3,"text":"3.2 Method Interface","id":"32-method-interface"},{"level":2,"text":"4. Algorithm Pseudo-code: The &quot;Hot Path&quot; (Acquire Lock)","id":"4-algorithm-pseudo-code-the-quothot-pathquot-acquire-lock"},{"level":2,"text":"5. Engineering Constraints &amp; Hazards","id":"5-engineering-constraints-amp-hazards"},{"level":3,"text":"5.1 The &quot;Checkpoint Starvation&quot; Problem","id":"51-the-quotcheckpoint-starvationquot-problem"},{"level":3,"text":"5.2 Memory Barriers &amp; Visibility","id":"52-memory-barriers-amp-visibility"},{"level":3,"text":"5.3 Micro-Optimization: Lock-Free WAL Tracking","id":"53-micro-optimization-lock-free-wal-tracking"},{"level":2,"text":"6. Diagrams","id":"6-diagrams"},{"level":1,"text":"Module: Record Serialization &amp; Schema Manager","id":"module-record-serialization-amp-schema-manager"},{"level":2,"text":"1. Technical Specification","id":"1-technical-specification"},{"level":3,"text":"Core Responsibilities:","id":"core-responsibilities"},{"level":2,"text":"2. Abstraction Layers","id":"2-abstraction-layers"},{"level":2,"text":"3. Struct &amp; Interface Definitions","id":"3-struct-amp-interface-definitions"},{"level":3,"text":"3.1 Data Structures","id":"31-data-structures"},{"level":3,"text":"3.2 Method Interface","id":"32-method-interface"},{"level":2,"text":"4. Algorithm Pseudo-code: The &quot;Hot Path&quot;","id":"4-algorithm-pseudo-code-the-quothot-pathquot"},{"level":3,"text":"4.1 Varint Encoding (Performance Critical)","id":"41-varint-encoding-performance-critical"},{"level":3,"text":"4.2 Record Packing (The Write Path)","id":"42-record-packing-the-write-path"},{"level":2,"text":"5. Engineering Constraints &amp; Hazards (Micro-Optimization Corner)","id":"5-engineering-constraints-amp-hazards-micro-optimization-corner"},{"level":3,"text":"5.1 Concurrency &amp; Persistence","id":"51-concurrency-amp-persistence"},{"level":3,"text":"5.2 Cache Locality: Header-First Unpacking","id":"52-cache-locality-header-first-unpacking"},{"level":3,"text":"5.3 Memory Alignment Tax","id":"53-memory-alignment-tax"},{"level":3,"text":"5.4 SIMD Varint Decoding","id":"54-simd-varint-decoding"},{"level":2,"text":"6. Diagrams","id":"6-diagrams"},{"level":1,"text":"📚 Beyond the Atlas: Further Reading","id":"-beyond-the-atlas-further-reading"},{"level":3,"text":"1. B-Trees (The Warehouse)","id":"1-b-trees-the-warehouse"},{"level":3,"text":"2. ARIES: Write-Ahead Logging (The Protector)","id":"2-aries-write-ahead-logging-the-protector"},{"level":3,"text":"3. Register-Based Virtual Machines (The Engine)","id":"3-register-based-virtual-machines-the-engine"},{"level":3,"text":"4. Cost-Based Query Optimization (The Strategist)","id":"4-cost-based-query-optimization-the-strategist"},{"level":3,"text":"5. Multi-Version Concurrency Control (The Sentinel)","id":"5-multi-version-concurrency-control-the-sentinel"},{"level":3,"text":"6. Variable-Length Integers (The Assembly Line)","id":"6-variable-length-integers-the-assembly-line"},{"level":3,"text":"7. Virtual File System (The Siege)","id":"7-virtual-file-system-the-siege"}],"title":"build-sqlite","markdown":"# build-sqlite\n\n\n\n\n\n<!-- MS_ID: ms-0 -->\n<div id=\"satellite-map\"></div>\n\n# THE SYSTEM MAP: ARCHITECTING SQLITE FROM SCRATCH\n\nBuilding a database is the ultimate test of a systems programmer. It requires the precision of a clockmaker and the foresight of a city planner. Before we write a single line of C, we must understand the \"Metropolis\" we are building.\n\n\n![SQLite Engine Architecture](./diagrams/diag-001.svg)\n\n\n### The Knowledge Pillars\n1.  **[The Gateway (REPL & Interface)](#milestone-1)**: How the user talks to the machine.\n2.  **[The Architect (Tokenizer & Parser)](#milestone-2)**: Turning human intent into a structured blueprint.\n3.  **[The Engine (VDBE)](#milestone-3)**: The custom CPU that executes database instructions.\n4.  **[The Warehouse (B-Tree & Pager)](#milestone-4)**: The high-performance storage and memory management.\n\n---\n\n<div id=\"milestone-1\"></div>\n\n## Milestone 1: The Gateway (The REPL & Architecture)\n[↑ Back to System Map](#satellite-map)\n\nEvery great journey begins with a prompt. The REPL (Read-Eval-Print-Loop) is your database's front door.\n\n> **Mental Model**: Imagine the REPL as a court reporter. It waits for a statement, records it perfectly, hands it to the judge (the VM) for a decision, and reports the result back to the public.\n\n### Quick Breakdown: The Input Buffer\n*   **Buffer**: A contiguous block of memory used to hold raw input.\n*   **Heap Allocation**: Asking the OS for memory at runtime (using `malloc`) because we don't know how long a user's SQL query will be.\n\n\n![REPL Architecture](./diagrams/diag-003.svg)\n\n\n### 1. The Naive Trap: The \"Fixed-Size\" Fallacy\nMany beginners start by declaring a static array for input:\n```c\nchar input[255]; // What if the user writes a 1000-character INSERT?\nscanf(\"%s\", input); // Vulnerable to Buffer Overflow\n```\n**Why it fails**: If the user input exceeds 255 bytes, you overwrite adjacent memory. In a database, this leads to corrupted data or security exploits. Furthermore, `scanf` stops at the first whitespace—useless for SQL.\n\n### 2. The Zen Way: Dynamic Input Management\nWe use a structure to track the buffer and its size, utilizing `getline()` (or a custom equivalent) to let the heap grow as needed.\n\n```c\ntypedef struct {\n  char* buffer;\n  size_t buffer_length;\n  ssize_t input_length;\n} InputBuffer;\n\n// Logic: Read until newline, resize buffer if necessary\ngetline(&(input_buffer->buffer), &(input_buffer->buffer_length), stdin);\n```\n\n{{DIAGRAM:diag-002}}\n\n### 3. Hardware Soul: The Cost of a Cache Miss\nWhen you allocate memory for your `InputBuffer` on the heap, that memory might be far away from your program's execution code in physical RAM. \n\n*   **Spatial Locality**: Modern CPUs pull data into \"Cache Lines\" (usually 64 bytes). If your buffer is fragmented or scattered, the CPU wastes hundreds of cycles waiting for the RAM to respond. \n*   **The Optimization**: By keeping our metadata (length, capacity) in a small struct and the buffer in a single contiguous block, we increase the chance that the CPU pre-fetcher will keep our data in the L1 cache.\n\n{{DIAGRAM:diag-029}}\n\n### 4. Alternative Reality\n*   **Linux/Bash**: Uses the `readline` library, which provides history (arrow keys) and autocompletion.\n*   **Redis**: Uses a custom protocol (RESP) where the length of the command is sent *before* the data, allowing the server to allocate the exact amount of memory needed immediately.\n\n### 5. Mental Stamina Checklist\n1.  **The \"Null\" Terminator**: What happens if a user inputs a null byte (`\\0`) in the middle of a SQL string? How does your buffer handle it?\n2.  **Memory Leaks**: If the REPL runs for 10 years (like a real DB), and you forget to `free()` the buffer once per loop, how many megabytes do you lose per day?\n3.  **Signal Resilience**: What happens to your buffer if the user presses `Ctrl+C` mid-type?\n\n---\n\n<div id=\"milestone-2\"></div>\n\n## Milestone 2: The Architect (Tokenizing the Void)\n[↑ Back to System Map](#satellite-map)\n\nOnce we have a string like `INSERT 1 \"user\"`, the computer sees just a sequence of ASCII numbers. We need to turn these into \"Tokens.\"\n\n> **Mental Model**: Tokenizing is like \"breaking a sentence into words\" and \"identifying parts of speech.\" `SELECT` is a verb (Keyword), `*` is a noun (Identifier), `FROM` is a preposition.\n\n### Quick Breakdown\n*   **Tokenizer (Lexer)**: Scans characters and groups them.\n*   **State Machine**: A system that changes its behavior based on what it just saw (e.g., \"I just saw a quote, so everything until the next quote is a string\").\n\n{{DIAGRAM:diag-004}}\n\n### 1. The Naive Trap: The `strtok()` Disaster\nUsing `strtok()` to split by spaces.\n```c\nchar *token = strtok(input, \" \"); // Fails on \"INSERT INTO users(id, name)...\"\n```\n**Why it fails**: SQL is not just space-separated. Parentheses, commas, and quotes are delimiters too. `strtok` is destructive (it modifies the original string) and cannot handle nested structures.\n\n### 2. The Zen Way: The Pointer Scan\nWe maintain a \"cursor\" (a pointer) and move it through the string, identifying the type of each token without modifying the source.\n\n```c\ntypedef enum { TOKEN_SELECT, TOKEN_INSERT, TOKEN_ID, TOKEN_NUMBER } TokenType;\n\ntypedef struct {\n  TokenType type;\n  char* start;\n  int length;\n} Token;\n```\n\n\n![Token Types Taxonomy](./diagrams/diag-005.svg)\n\n\n### 3. Hardware Soul: Branch Prediction\nTokenizers are full of `if/else` or `switch` statements (e.g., `if (is_digit(c)) ...`). \n*   **The CPU's Guess**: Modern CPUs try to guess which branch you will take. If you have a long string of numbers, the CPU gets very fast because it guesses \"Digit\" correctly every time. \n*   **The \"Pipeline Flush\"**: If your code alternates randomly between numbers, letters, and symbols, the CPU will guess wrong, \"flush the pipeline,\" and lose 10-20 cycles of work.\n\n\n![Instruction Encoding Format](./diagrams/diag-011.svg)\n\n\n### 4. Alternative Reality\n*   **SQLite**: Uses a tool called `Lemon` to generate its parser and a custom hand-coded tokenizer for maximum speed.\n*   **Python**: Uses a \"Lexer\" that recognizes indentation (whitespace) as a specific token type, unlike SQL which usually ignores it.\n\n### 5. Mental Stamina Checklist\n1.  **String Escaping**: How does your tokenizer handle the string `'It''s a beautiful day'`? (The double single-quote is SQL's way of escaping).\n2.  **Keyword vs Identifier**: If a user has a table named `Select`, how do you distinguish between the table name and the command `SELECT`?\n3.  **Lookahead**: When you see the character `>`, you don't know if the token is \"Greater Than\" (`>`) or \"Greater Than or Equal To\" (`>=`) until you look at the *next* character. How do you implement this \"Peek\"?\n\n[[ADVANCED_CONTEXT:Formal Grammars and Backus-Naur Form]]\n<!-- END_MS -->\n\n\n<!-- MS_ID: ms-1 -->\n<div id=\"milestone-3\"></div>\n\n## Milestone 3: The Engine (The VDBE - Virtual Database Engine)\n[↑ Back to System Map](#satellite-map)\n\nOnce the Architect (Parser) has finished the blueprint, we need a machine to execute it. In SQLite, this isn't a physical CPU, but a **Virtual Machine**. \n\n> **Mental Model**: Think of the VDBE as a **Specialized Kitchen**. The SQL query is the recipe, the Parser is the chef writing down steps, and the VDBE is the line cook who follows instructions like \"Open fridge,\" \"Get 5 eggs,\" and \"Fry until golden.\"\n\n### Quick Breakdown\n*   **Bytecode**: A set of low-level instructions (Opcodes) that the VM understands (e.g., `OpenRead`, `Column`, `ResultRow`).\n*   **Program Counter (PC)**: A pointer that tells the VM which instruction to execute next.\n*   **Registers**: Small \"slots\" of memory used to hold temporary values during execution.\n\n\n![The VDBE Cycle](./diagrams/diag-vdbe-flow.svg)\n\n\n### 1. The Naive Trap: The \"Recursive Tree Walk\"\nMany SQL engines start by \"walking\" the Abstract Syntax Tree (AST) directly. \n```c\n// Suboptimal: Executing the tree directly\nvoid execute(Node* node) {\n    if (node->type == SELECT) {\n        foreach(row in table) {\n            if (evaluate(node->where_clause, row)) { \n                print(row); \n            }\n        }\n    }\n}\n```\n**Why it fails**: Recursion is expensive. Every node in the tree requires a function call, which pushes data onto the stack, creating massive overhead for millions of rows. It also makes \"pausing\" execution (for LIMIT or cursors) incredibly difficult.\n\n### 2. The Zen Way: The Register-Based VM\nWe compile the AST into a linear array of instructions. This transforms a complex tree into a simple loop.\n\n```c\n// Opcodes: Linear execution\n// 0: Init 0 5 0\n// 1: OpenRead 0 2 0\n// 2: Rewind 0 5 0\n// 3: Column 0 1 1 (Get column 1, store in register 1)\n// 4: ResultRow 1 1 0 (Return register 1)\n// 5: Next 0 3 0 (Go back to 3)\n```\n\n![Bytecode Instruction Set](./diagrams/diag-010.svg)\n\n\n### 3. Hardware Soul: Instruction Dispatch & Computed Gotos\nInside the VDBE's main loop, we have to decide which code to run for each opcode.\n*   **The Switch Statement**: A standard `switch(opcode)` is common, but it can be slow due to \"Branch Misprediction.\" The CPU struggles to guess where the next jump goes.\n*   **Computed Gotos (Labelled Pointers)**: High-performance engines use an array of memory addresses. Instead of switching, the code literally \"jumps\" to the address of the next opcode handler. This keeps the CPU's pipeline full.\n\n\n![Switch vs. Computed Goto](./diagrams/diag-dispatch.svg)\n\n\n### 4. Alternative Reality\n*   **JVM (Java Virtual Machine)**: Uses a **Stack-based** VM. To add numbers, you push two values onto a stack and call `ADD`. SQLite uses **Registers**, which is faster because it mimics how real hardware (x86/ARM) works.\n*   **PostgreSQL**: Uses a more traditional \"volcano model\" (iterator-based), but recently added JIT (Just-In-Time) compilation to turn SQL into actual machine code.\n\n### 5. Mental Stamina Checklist\n1.  **Infinite Loops**: How do you prevent a malformed bytecode program from locking up your database forever?\n2.  **Register Pressure**: What happens if a complex query needs 1000 registers but you've only allocated 100?\n3.  **State Persistence**: If a user fetches 10 rows and then waits an hour, how does your VDBE \"pause\" its state without consuming CPU?\n\n---\n\n<div id=\"milestone-4\"></div>\n\n## Milestone 4: The Warehouse (The B-Tree & Pager)\n[↑ Back to System Map](#satellite-map)\n\nWe now have an engine, but where does the data live? We can't just dump it into a text file. We need a structure that allows us to find one record in a billion in microseconds.\n\n> **Mental Model**: The **Pager** is the librarian. He knows how to pull 4KB \"pages\" (books) from the massive \"disk\" (basement). The **B-Tree** is the index at the front of the library that tells you exactly which page to ask for.\n\n### Quick Breakdown\n*   **Page**: The fundamental unit of storage (usually 4KB). Databases never read single bytes; they read entire pages.\n*   **B-Tree**: A \"Balanced Tree\" structure where every leaf (bottom node) is at the same distance from the root, ensuring predictable speed.\n\n\n![B-Tree Node Structure](./diagrams/diag-013.svg)\n\n\n### 1. The Naive Trap: The \"Append-Only\" Log\nWriting every new row to the end of a file.\n```c\n// Searching for ID 500 in a million rows\nwhile(read_row(file)) {\n    if (row.id == 500) return row; // O(N) complexity - SLOW\n}\n```\n**Why it fails**: As your data grows, your search time grows linearly. Finding a needle in a haystack becomes impossible when the haystack is the size of a mountain.\n\n### 2. The Zen Way: Page-Aligned B+Trees\nWe organize the file into fixed-size pages. Each page is either an \"Internal Node\" (containing pointers to other pages) or a \"Leaf Node\" (containing actual data).\n\n```c\ntypedef struct {\n  uint32_t page_number;\n  uint8_t data[4096]; // Fixed size\n} Page;\n```\nBy keeping the tree \"balanced,\" we can find any row in `log(N)` time. In a 3-level B-Tree with 4KB pages, you can store millions of rows and find any of them in just 3 disk reads.\n\n\n![B-Tree Operations](./diagrams/diag-014.svg)\n\n\n### 3. Hardware Soul: Disk Sectors & Cache Lines\nThe Pager exists because of a hard physical reality: **Disk I/O is slow.**\n*   **The 4KB Magic**: Most SSDs and HDDs store data in 4KB sectors. If you write 1 byte, the hardware writes 4KB anyway. By matching our \"Page Size\" to the \"Disk Sector Size,\" we reach \"I/O Nirvana\"—maximum efficiency.\n*   **The Page Cache**: The Pager keeps recently used pages in RAM. This exploits **Temporal Locality**: if you look at a row once, you’ll likely look at its neighbors soon.\n\n\n![The Pager Cache](./diagrams/diag-pager-cache.svg)\n\n\n### 4. Alternative Reality\n*   **Redis**: Keeps everything in RAM. It doesn't need a Pager, but it loses everything if the power goes out (unless configured otherwise).\n*   **LSM Trees (LevelDB/RocksDB)**: Instead of B-Trees, they use \"Log-Structured Merge Trees.\" They are faster for *writing* data but often slower for *reading* complex queries.\n\n### 5. Mental Stamina Checklist\n1.  **Fragmentation**: If you delete 100 rows in the middle of a B-Tree, how do you reuse that empty space without leaving \"holes\" in your file?\n2.  **The \"Split\" Event**: When a 4KB page is full and you try to insert another row, the page must \"split\" into two. How do you update the parent pointers without corrupting the database if the power cuts out mid-split?\n3.  **Binary Search**: Inside a single 4KB page, how do you find the right record? (Hint: You don't scan; you binary search the \"Cell Pointer\" array).\n\n[[ADVANCED_CONTEXT:Concurrency Control and ACID Compliance]]\n[[ADVANCED_CONTEXT:Write-Ahead Logging (WAL)]]\n<!-- END_MS -->\n\n\n<!-- MS_ID: ms-2 -->\nThis is a continuation of **THE SYSTEM MAP: ARCHITECTING SQLITE FROM SCRATCH**. We have built the loop, parsed the tokens, executed the bytecode, and structured the pages. Now, we must ensure our database is actually *fast* and *indestructible*.\n\n---\n\n<div id=\"milestone-5\"></div>\n\n## Milestone 5: The Strategist (Query Planning & Optimization)\n[↑ Back to System Map](#satellite-map)\n\nSQL is a *declarative* language. The user tells you *what* they want, not *how* to get it. The Query Planner is the brain that bridges that gap.\n\n> **Mental Model**: The Strategist is like a **GPS Navigator**. There are a hundred ways to get across town. You could take the highway (Index Scan) or the side streets (Table Scan). The Navigator looks at traffic (Statistics) and chooses the path with the lowest \"Cost.\"\n\n### Quick Breakdown\n*   **Full Table Scan**: Looking at every single row in a table.\n*   **Index**: A side-structure (another B-Tree) that maps values (like \"Name\") to their locations in the main table.\n*   **Cost-Based Optimizer (CBO)**: An algorithm that estimates how many \"disk reads\" each plan will take and picks the cheapest.\n\n\n![Query Planner Components](./diagrams/diag-019.svg)\n\n\n### 1. The Naive Trap: The \"First-Found\" Planner\nExecuting joins or filters in the exact order the user typed them.\n```sql\nSELECT * FROM users, orders WHERE users.id = orders.user_id AND users.name = 'Alice';\n```\n**Why it fails**: If there are 1 million orders and only 10 users, but you loop through `orders` first, you perform 1 million checks. If you look up 'Alice' in the `users` table first (1 check) and then find her 5 orders, you perform 6 checks. The difference is 999,994 operations.\n\n### 2. The Zen Way: The Search Space Searcher\nWe represent the query as a tree of logical operations. We then apply \"Transformations\" to rearrange the tree into the most efficient shape.\n\n```c\n// Pseudo-code for a simple optimizer rule\nif (can_use_index(table, column)) {\n    replace_scan_with_index_lookup(plan);\n}\n```\n\n\n![Index Selection Algorithm](./diagrams/diag-020.svg)\n\n\n### 3. Hardware Soul: Data Locality and SIMD\nWhen the Planner chooses an index, it's not just reducing the number of rows—it's optimizing for the CPU's hardware.\n*   **Pointer Following**: Indices allow the CPU to jump directly to the right memory address, but jumping too much causes **TLB (Translation Lookaside Buffer) Misses**.\n*   **The Optimization**: \"Covering Indices.\" If an index contains all the data the query needs (e.g., the Index contains both `ID` and `Name`), the CPU never has to fetch the main table page. This keeps the data \"dense\" and \"local,\" allowing the CPU to potentially use **SIMD (Single Instruction, Multiple Data)** to compare multiple rows in one clock cycle.\n\n{{DIAGRAM:diag-021}}\n\n### 4. Alternative Reality\n*   **MySQL**: Uses a \"Rule-Based\" optimizer for many years before moving to \"Cost-Based.\"\n*   **SQLite**: Uses a \"Nearest Neighbor\" heuristic for joins (the \"Greedy Algorithm\"). It doesn't explore every single possible join order because, for a 20-table join, there are $20!$ (quintillions) of possibilities—more than the atoms in the universe.\n\n### 5. Mental Stamina Checklist\n1.  **Selectivity**: If a column has only two values (e.g., 'Male' or 'Female'), is an index actually faster than a table scan? (Hint: Usually no, due to random I/O overhead).\n2.  **Prepared Statements**: If you optimize a query once, how do you \"cache\" the plan so you don't waste CPU cycles re-optimizing it every time the user runs it?\n3.  **The N+1 Problem**: How can the planner detect when a user is making many small queries instead of one large join?\n\n---\n\n<div id=\"milestone-6\"></div>\n\n## Milestone 6: The Protector (Transactions & Recovery)\n[↑ Back to System Map](#satellite-map)\n\nA database that loses data when the power goes out is just a fancy calculator. We need **ACID** (Atomicity, Consistency, Isolation, Durability).\n\n> **Mental Model**: The Protector is a **Master Surgeon**. Before making a single cut, they write down exactly what they are going to do in a **Medical Log**. If the lights go out mid-surgery, the log tells the next doctor exactly where to resume or how to \"undo\" the damage.\n\n### Quick Breakdown\n*   **Atomicity**: \"All or nothing.\" Either the whole transaction happens, or none of it does.\n*   **The WAL (Write-Ahead Log)**: A separate file where we write changes *before* we touch the main database file.\n*   **Fsync**: A command that forces the OS to actually write data to the physical disk platter, rather than keeping it in a volatile RAM cache.\n\n\n![Transaction Lifecycle](./diagrams/diag-023.svg)\n\n\n### 1. The Naive Trap: The \"In-Place\" Overwrite\nOpening the database file and writing `new_value` directly over `old_value`.\n```c\nfseek(db_file, row_offset, SEEK_SET);\nfwrite(new_data, size, 1, db_file); // If the power dies here, you have half old data and half new.\n```\n**Why it fails**: This is called **Corruption**. Your B-Tree pointers will point to garbage, and your database is now a paperweight.\n\n### 2. The Zen Way: Shadow Paging or WAL\nIn a WAL-mode system, we don't touch the main database during a transaction. We append the new pages to a `journal` file. \n\n1.  **Record**: Write the new page to the WAL file.\n2.  **Commit**: Write a special \"Commit\" marker to the WAL.\n3.  **Checkpoint**: Occasionally, move the changes from the WAL back to the main `.db` file.\n\n{{DIAGRAM:diag-025}}\n\n### 3. Hardware Soul: The Disk Controller's Lie\nWhen you call `write()` in C, the OS says \"Done!\" almost instantly. But the data is still in RAM. Even when the OS flushes it, the **Disk Controller** might keep it in its own internal cache to be \"efficient.\"\n*   **The Barrier**: We must use `fsync()` (Linux) or `FlushFileBuffers` (Windows). This forces the hardware to drain its caches.\n*   **The Cost**: `fsync()` is the slowest operation in systems programming. It can take 10ms (an eternity for a CPU). SQLite's performance is almost entirely defined by how many `fsync` calls it can avoid.\n\n\n![Crash Recovery Flow](./diagrams/diag-027.svg)\n\n\n### 4. Alternative Reality\n*   **PostgreSQL**: Uses MVCC (Multi-Version Concurrency Control). Instead of locking, it keeps multiple versions of a row. Readers never block writers.\n*   **SQLite (Rollback Journal)**: The older version of SQLite copied the *original* data to a \"Rollback\" file before overwriting the main file. WAL is faster because it turns random writes into sequential appends.\n\n### 5. Mental Stamina Checklist\n1.  **The \"Torn Page\"**: What if the power fails *while* the disk is halfway through writing a 4KB page? How do you detect that the page is garbage? (Hint: Checksums).\n2.  **Isolation**: If Transaction A is reading a row while Transaction B is writing to it, what does Transaction A see? The old value? The new value? An error?\n3.  **The Deadlock**: If two users are both waiting for each other to release a lock, how does your database \"break\" the loop?\n\n---\n\n<div id=\"beyond-the-atlas\"></div>\n\n# BEYOND THE ATLAS: ADVANCED CONTEXT\n[↑ Back to System Map](#satellite-map)\n\n### [[ADVANCED_CONTEXT:Formal Grammars and Backus-Naur Form]]\nTo build a truly robust parser, we use **BNF**. It’s a mathematical way of describing a language. \n*   Example: `Expression ::= Term | Expression \"+\" Term`. \n*   This allows us to handle infinite complexity (like `1 + 2 + 3 + ...`) using simple recursive rules.\n\n### [[ADVANCED_CONTEXT:Concurrency Control and ACID Compliance]]\nBuilding a \"Thread-Safe\" B-Tree is one of the hardest tasks in CS. It involves **Latches** (short-term memory locks) and **Locks** (long-term database locks). \n*   **The Microscope**: Look into \"Two-Phase Locking\" (2PL) to understand how to prevent transactions from stepping on each other's toes.\n\n### [[ADVANCED_CONTEXT:Write-Ahead Logging (WAL)]]\nThe WAL isn't just for safety; it's for **Concurrency**. In WAL mode, a reader can look at the main `.db` file while a writer is appending to the `.wal` file. They don't block each other! This is the secret to SQLite's incredible read performance.\n\n\n![The Completed Machine](./diagrams/diag-final.svg)\n\n\n---\n**Congratulations, Architect.** You have transitioned from a simple `scanf` prompt to a multi-layered, crash-resilient, optimized storage engine. The system is now alive. \n\n**Next Steps**: Implement the B-Tree \"Split\" logic in Milestone 4. That is where the real \"systems\" pain—and glory—begins.\n<!-- END_MS -->\n\n\n<!-- MS_ID: ms-3 -->\n<!-- MS_ID: ms-3 -->\n<div id=\"milestone-7\"></div>\n\n## Milestone 7: The Assembly Line (Row Serialization & The Record Format)\n[↑ Back to System Map](#satellite-map)\n\nWe have the B-Tree pages (the boxes) and the VDBE (the engine), but we haven't discussed how a \"Row\" actually looks inside a page. You cannot just dump a C `struct` to disk.\n\n> **Mental Model**: Imagine packing a **Suitcase**. If you use a hard-shell case with fixed compartments (Fixed-width), you waste space if you only pack a t-shirt, and you can't fit a winter coat. SQLite uses \"Compression Packing\"—it rolls the clothes and puts a manifest (the Header) at the top so it knows exactly where each item starts.\n\n### Quick Breakdown\n*   **Serialization**: Turning a high-level data structure (like a row with a string, an int, and a float) into a flat array of bytes.\n*   **Varint (Variable-length Integer)**: A way to store an integer using 1 to 9 bytes. Smaller numbers take less space.\n*   **Manifest (Record Header)**: A sequence of \"Type IDs\" that tell the engine how to interpret the following bytes.\n\n\n![The Record Anatomy](./diagrams/diag-record-layout.svg)\n\n\n### 1. The Naive Trap: The \"C-Struct\" Dump\nThe most common mistake is defining a row as a fixed-size C structure and writing it directly to the file.\n```c\nstruct Row {\n    int id;\n    char username[32];\n    char email[255];\n}; // This row ALWAYS takes 291 bytes, even if the username is \"Bob\".\n```\n**Why it fails**: \n1. **Wasted Space**: If your average username is 5 chars, you waste 27 bytes *per row*. In a million rows, that's 27MB of pure air.\n2. **Schema Rigidity**: If you want to change the email length to 500, you have to rewrite the entire database file.\n3. **Endianness**: A C `int` is stored differently on an ARM chip (Mac M1) vs. an x86 chip (Intel). Your database file becomes non-portable.\n\n### 2. The Zen Way: The Compact Record Format\nSQLite uses a **header-payload** architecture. The header contains a list of \"Serial Types\" (encoded as Varints), followed by the actual data.\n\n```c\n// Example: (1, \"Alice\")\n// Header: [2] (Header Length), [1] (Type: 1-byte Int), [18] (Type: String of length 5)\n// Payload: [0x01], ['A', 'l', 'i', 'c', 'e']\n```\n\n\n![The Varint Squeeze](./diagrams/diag-varint-logic.svg)\n\n\n### 3. Hardware Soul: Data Alignment & The CPU \"Tax\"\nCPUs prefer to read data from \"aligned\" memory addresses (e.g., a 4-byte integer starting at an address divisible by 4).\n*   **The Penalty**: If you pack data too tightly (like SQLite does), a 4-byte integer might straddle two different **Cache Lines**. To read it, the CPU has to fetch two blocks of memory, shift the bits, and merge them.\n*   **The Optimization**: While SQLite prioritizes disk space (saving bytes), high-performance memory-only engines (like DuckDB) often trade space for **SIMD-alignment**, ensuring that data \"lines up\" perfectly with the CPU's registers.\n\n\n![Alignment vs. Packing](./diagrams/diag-alignment-shift.svg)\n\n\n### 4. Alternative Reality\n*   **Protocol Buffers (Protobuf)**: Uses a very similar Varint-based encoding for network communication.\n*   **Apache Parquet**: Instead of packing rows together (\"Row-major\"), it packs columns together (\"Columnar\"). This is much faster for analytical queries (e.g., \"Average of all Ages\") because the CPU can stream the \"Age\" column without skipping over \"Usernames.\"\n\n### 5. Mental Stamina Checklist\n1.  **The Varint Limit**: SQLite's Varint can be up to 9 bytes. Why 9? (Hint: To accommodate a 64-bit integer plus the continuation bits).\n2.  **Schema Evolution**: If you add a column to a table, how does the Record Format handle rows that were written *before* the column existed?\n3.  **Nulls for Free**: In SQLite, the Serial Type for `NULL` is `0`. It takes 1 byte in the header and **zero** bytes in the payload. How does this impact your storage calculations for sparse tables?\n\n---\n\n<div id=\"milestone-8\"></div>\n\n## Milestone 8: The Interface (The C API & Handshake)\n[↑ Back to System Map](#satellite-map)\n\nThe final layer is how the outside world interacts with your machine. This is the **Application Program Interface (API)**.\n\n> **Mental Model**: The API is the **Menu at a Restaurant**. The customer doesn't need to know how the stove works; they just need a consistent way to order `Prepare()`, `Step()`, and `Finalize()`.\n\n### 1. The Naive Trap: The \"One-Shot\" String\nProviding a single function: `QueryResult* run_sql(char* query)`.\n**Why it fails**: This forces the engine to load the entire result set into RAM at once. If your query returns 5GB of data, the application crashes with an `Out of Memory` error.\n\n### 2. The Zen Way: The \"Prepared Statement\" Lifecycle\nWe break the interaction into three distinct phases that mirror the architecture we've built:\n1.  **Prepare**: The Parser creates the Bytecode (VDBE Program).\n2.  **Step**: The VDBE executes until it hits a `ResultRow`. It hands one row back to the user and *pauses*.\n3.  **Finalize**: The VDBE clears its registers and closes its cursors.\n\n\n![The Statement Lifecycle](./diagrams/diag-api-lifecycle.svg)\n\n\n### 3. Hardware Soul: The Stack vs. The Heap\nWhen a user calls your API, they are crossing a boundary. \n*   **Ownership**: Does the API return a pointer to memory *you* own (the database) or memory *they* own? \n*   **The Optimization**: \"Zero-copy\" interfaces. Instead of copying a string from the B-Tree page to a new buffer for the user, you provide a pointer directly into the **Page Cache**. This avoids a massive memory copy (memcpy), which is often the bottleneck in high-throughput systems.\n\n### 5. Mental Stamina Checklist\n1.  **Re-entrancy**: Can two different threads call `sqlite3_step()` on the same prepared statement at the same time? Why is this a recipe for disaster?\n2.  **Resource Leaks**: If an application crashes after `Prepare()` but before `Finalize()`, how does your engine ensure the B-Tree locks are released?\n3.  **Versioning**: If you update your Opcodes in Milestone 3, how do you ensure that a \"Prepared Statement\" saved on disk from an older version doesn't crash the new engine?\n\n[[ADVANCED_CONTEXT:Application Binary Interface (ABI) Stability]]\n\n---\n\n# THE SYSTEM IS COMPLETE\nYou have journeyed from a raw character buffer to a crash-resilient, bytecode-executing, B-Tree-indexed engine. You have faced the trade-offs between **Disk I/O, CPU Cache Locality, and Memory Safety**.\n\n**Final Challenge**: Go back to Milestone 1. Can you now see how a single character typed into the REPL ripples through the Tokenizer, becomes an Opcode, traverses the B-Tree, and is protected by the WAL?\n\n**You are no longer a user of systems. You are an Architect.**\n\n[↑ Back to System Map](#satellite-map)\n\n<!-- END_MS -->\n<!-- END_MS -->\n\n\n<!-- MS_ID: ms-4 -->\n<div id=\"milestone-9\"></div>\n\n## Milestone 9: The Sentinel (Concurrency & High-Level Locking)\n[↑ Back to System Map](#satellite-map)\n\nA single-user database is a toy. A world-class system must handle a hundred hands reaching for the same data at once without losing a single bit.\n\n> **Mental Model**: Imagine a **Shared Library**. If everyone just grabs books, they’ll collide. **Locking** is the librarian giving you a \"Read-Only\" pass or a \"Reserved\" sign. **Latches** are the physical lock on the door to the room while you're rearranging the shelves so no one gets hit by a falling book.\n\n### Quick Breakdown\n*   **Lock**: A high-level, long-term logical barrier (e.g., \"Nobody can write to this Table while I'm reading it\").\n*   **Latch (Mutex)**: A low-level, short-term physical barrier used to protect internal data structures (like the B-Tree header) during a pointer update.\n\n\n![Locking vs Latching](./diagrams/diag-latch-vs-lock.svg)\n\n\n### 1. The Naive Trap: The \"Giant Mutex\"\nProtecting the entire database with a single `pthread_mutex_lock()`.\n```c\nvoid execute_query(char* sql) {\n    pthread_mutex_lock(&global_db_lock);\n    // ... do everything ...\n    pthread_mutex_unlock(&global_db_lock);\n}\n```\n**Why it fails**: This turns your high-speed database into a single-file line. Even if User A wants to read Table 1 and User B wants to read Table 2, User B must wait. On a 64-core server, you are utilizing 1.5% of your hardware. This is the \"Python Global Interpreter Lock\" (GIL) problem applied to storage.\n\n### 2. The Zen Way: Multi-Granular Locking & Intent Locks\nWe implement a hierarchy. Before you lock a **Row**, you must put an \"Intent to Read\" lock on the **Page**, and an \"Intent\" lock on the **Table**.\n\n*   **Shared (S)**: \"I'm reading, you can read too.\"\n*   **Exclusive (X)**: \"I'm writing, everyone stay away.\"\n*   **Intent Shared (IS)**: \"I plan to read a row somewhere inside this table.\"\n\nThis allows the engine to quickly check: \"Can I lock this whole table for maintenance?\" by just looking at the top-level Intent locks, rather than checking a million rows.\n\n\n![The Intent Hierarchy](./diagrams/diag-lock-hierarchy.svg)\n\n\n### 3. Hardware Soul: Atomic CAS and MESI\nAt the lowest level, latches don't use the OS; they use the CPU.\n*   **CAS (Compare-And-Swap)**: A single instruction (`LOCK CMPXCHG` on x86) that checks if a memory location is `0` and sets it to `1` in one atomic tick. If two cores try at the exact same time, the hardware guarantees only one wins.\n*   **MESI Protocol**: When one core modifies a latch, the **Cache Coherency** protocol must \"invalidate\" that memory in every other core's L1 cache. If your \"Sentinel\" is too busy (High Contention), your cores spend more time talking to each other than doing work. This is called **Cache Line Bouncing**.\n\n\n![The Atomic Micro-Op](./diagrams/diag-atomic-cas.svg)\n\n\n### 4. Alternative Reality\n*   **PostgreSQL**: Uses \"Heavyweight Locks\" for tables and \"Lightweight Locks\" (LWLocks) for internal buffers.\n*   **SQLite**: Uses a simple 5-state locking machine (UNLOCKED, SHARED, RESERVED, PENDING, EXCLUSIVE) to manage file-level concurrency.\n\n### 5. Mental Stamina Checklist\n1.  **Deadlock Detection**: If User A locks Row 1 and wants Row 2, while User B locks Row 2 and wants Row 1, how does your Sentinel detect the \"Deadly Embrace\" and kill one of them?\n2.  **Starvation**: If there are constant readers (Shared Locks), a writer (Exclusive Lock) might wait forever. How do you implement a \"Queue\" to give the writer a turn?\n3.  **Lock Escalation**: If a user updates 100,000 rows, your memory fills up with 100,000 lock objects. How do you \"escalate\" those into a single Table Lock?\n\n---\n\n<div id=\"milestone-10\"></div>\n\n## Milestone 10: The Siege (Testing, Fuzzing & The VFS)\n[↑ Back to System Map](#satellite-map)\n\nYour code is perfect—until it isn't. The final milestone isn't a feature; it's the **Assault**.\n\n> **Mental Model**: The Siege is like a **Crash Test Lab**. We don't just drive the car; we drive it into a wall at 60mph while the engine is on fire to see if the airbags (Recovery Logic) still deploy.\n\n### 1. The Naive Trap: The \"Happy Path\" Unit Test\nWriting tests that only check if `INSERT` works.\n```c\ntest_insert() {\n    execute(\"INSERT INTO t VALUES (1)\");\n    assert(count_rows() == 1);\n}\n```\n**Why it fails**: This doesn't test the **Persistence**. Real-world failures happen when the disk returns an error, the power cuts mid-write, or the filesystem is full.\n\n### 2. The Zen Way: The VFS (Virtual File System) & Fault Injection\nWe wrap all OS calls (open, read, write, sync) in a **VFS Layer**. In our tests, we use a \"Malicious VFS.\"\n*   **The I/O Error Injector**: \"On the 50th write, return `EIO` (Disk Error).\"\n*   **The Power-Cut Simulator**: \"After the WAL is written but before the `fsync`, stop the program immediately.\"\n\n```c\n// Malicious VFS Logic\nint malicious_write(File* f, void* buf, size_t len) {\n    if (global_test_counter++ == 50) return SQLITE_IOERR; \n    return real_write(f, buf, len);\n}\n```\n\n\n![The VFS Shield](./diagrams/diag-vfs-layer.svg)\n\n\n### 3. Hardware Soul: Bit Rot and Cosmic Rays\nHardware is not a mathematical certainty. \n*   **Bit Flips**: Over years, a `1` on a disk can turn into a `0`.\n*   **The Solution**: **Checksums**. We append a mathematical \"signature\" to every 4KB page. When the Pager reads a page from the Warehouse (Milestone 4), it recalculates the checksum. If it doesn't match, the database refuses to start rather than returning corrupted data.\n\n\n![The Checksum Guard](./diagrams/diag-checksum-verification.svg)\n\n\n### 4. Alternative Reality\n*   **SQLite**: Is the most tested piece of software in the world. It has 711 times more test code than actual library code (over 90 million lines of tests).\n*   **FoundationDB**: Uses a \"Deterministic Simulation\" engine that can reproduce a 1-in-a-billion bug by replaying the exact same \"random\" seed.\n\n### 5. Mental Stamina Checklist\n1.  **Fuzzing**: If I feed your Parser 1GB of random garbage characters, does it return an error or a `Segmentation Fault`?\n2.  **Valgrind/ASAN**: Can your engine run a massive suite of queries without leaking a single byte of heap memory?\n3.  **The \"No-Space\" Test**: What happens to your WAL file when the disk is 100% full? Does it gracefully roll back or corrupt the main DB?\n\n---\n\n# THE BEYOND: ADVANCED CONTEXT EXPANDED\n\n### [[ADVANCED_CONTEXT:Application Binary Interface (ABI) Stability]]\nWhen you build a system like SQLite, people will use it for 30 years. You cannot change the way `sqlite3_open()` looks in the next version, or you'll break the world. This is why we use **Opaque Pointers** (pointers to structs that aren't defined in the header file). The user can hold the pointer, but they can't see inside it, allowing us to change the internal engine without breaking their code.\n\n### [[ADVANCED_CONTEXT:Formal Grammars and Backus-Naur Form]]\nWe use BNF to ensure our SQL parser is \"Complete.\" By defining a grammar, we can use tools like `yacc` or `lemon` to prove that our engine can handle nested queries like `SELECT * FROM (SELECT * FROM (SELECT...))`. Without a formal grammar, your parser is just a pile of `if` statements waiting to break.\n\n---\n**ARCHITECT'S FINAL NOTE:**\nYou have built a metropolis. It has a Gateway, an Engine, a Warehouse, and a Sentinel. It is protected by the Siege. You have mastered the art of talking to the hardware while serving the user. \n\n**The Atlas is complete.**\n\n[↑ Back to System Map](#satellite-map)\n<!-- END_MS -->\n\n\n<!-- MS_ID: ms-5 -->\n<!-- MS_ID: ms-final -->\n<div id=\"milestone-11\"></div>\n\n## Milestone 11: The Grand Synthesis (The Life of a Query)\n[↑ Back to System Map](#satellite-map)\n\nWe have built the metropolis. Now, we must watch it breathe. To truly master systems architecture, you must be able to trace a single bit from the keyboard to the spinning platter of a disk and back.\n\n> **Mental Model**: The **Grand Synthesis** is like a **City Pulse**. We are going to track a single \"Citizen\" (the query: `UPDATE users SET points = 10 WHERE id = 5`) as they move through the city’s infrastructure, from the front gate to the deepest vault.\n\n### Quick Breakdown: The Full Stack Traversal\n*   **Northbound**: The path from the user to the disk (Writing).\n*   **Southbound**: The path from the disk to the user (Reading/Result).\n\n\n![The Query Lifecycle](./diagrams/diag-full-traversal.svg)\n\n\n### 1. The Naive Trap: The \"Black Box\" Assumption\nMany developers treat a database as a black box—data goes in, data comes out. \n**Why it fails**: Without understanding the synthesis, you cannot debug performance. If a query is slow, is it the **Tokenizer** (unlikely), the **Optimizer** (picking the wrong index), the **VDBE** (register pressure), or the **Pager** (too many cache misses)? If you don't know the path, you are just guessing.\n\n### 2. The Zen Way: The Trace-First Mindset\nWe view the query as a set of handoffs between our milestones:\n1.  **Gateway (M1)**: `getline()` captures the string.\n2.  **Architect (M2)**: The string is shattered into `UPDATE`, `users`, `SET`, `points`, `=`, `10`...\n3.  **Engine (M3)**: The Parser generates Bytecode. The VDBE begins its loop.\n4.  **Strategist (M5)**: The Optimizer decides to use the `id` index instead of a full table scan.\n5.  **Warehouse (M4)**: The B-Tree asks the Pager for Page #5 (the root). The Pager checks the RAM cache.\n6.  **Assembly Line (M7)**: The VDBE finds the record, modifies the `points` field in the **Record Format**.\n7.  **Protector (M6)**: Before the B-Tree is touched, the change is written to the **WAL** and `fsync()`'d.\n\n\n![The Milestone Handoff](./diagrams/diag-hand-off.svg)\n\n\n### 3. Hardware Soul: The \"Bottleneck\" Hunt\nAt every stage of this synthesis, the hardware is pushed in different ways:\n*   **M2 (Tokenizer)**: **CPU Bound** (Branch Prediction).\n*   **M3 (VDBE)**: **CPU Bound** (Instruction Cache / L1 Hit Rate).\n*   **M4 (Pager)**: **I/O Bound** (Disk Latency) or **Memory Bound** (DRAM Bandwidth).\n*   **M6 (WAL)**: **I/O Bound** (Bus latency for `fsync`).\n\n**The Microscope Effect**: When the VDBE executes the `UPDATE`, it is likely operating on a 64-byte **Cache Line**. If your `points` integer is at the very end of that line, and the next field is on a different line, the CPU might stall for 100ns just to fetch the neighboring data. \n\n\n![The Hardware Tax](./diagrams/diag-cpu-stalls.svg)\n\n\n### 4. Alternative Reality: The SQLite \"In-Memory\" Mode\nIf you initialize SQLite with `:memory:`, Milestone 4 (The Warehouse) and Milestone 6 (The Protector) change completely.\n*   **The Change**: The Pager never calls `write()`. The WAL is disabled.\n*   **The Result**: The database becomes 10x-100x faster, but if the power flickers, everything vanishes. This proves that **Durability (the 'D' in ACID) is the most expensive feature in systems programming.**\n\n### 5. Mental Stamina Checklist: The Architect’s Final Exam\n1.  **The Context Switch**: When the REPL waits for input, your process is \"sleeping.\" When the user hits Enter, the OS must perform a \"Context Switch.\" How many thousands of CPU cycles are lost before your `InputBuffer` even sees the first character?\n2.  **The Layer Violation**: If the VDBE (Milestone 3) needs to know the \"Page Size\" of the Pager (Milestone 4) to optimize its registers, have you broken the \"Architecture\" of the system? How do you maintain clean boundaries while optimizing across them?\n3.  **The Multi-Core Future**: Our engine is currently single-threaded. If we wanted to run the **Tokenizer** on Core 1 and the **VDBE** on Core 2 (Pipelining), what happens to our **Mental Model** of a sequential \"Loop\"?\n\n---\n\n# THE FINAL MAP: BEYOND THE ATLAS\n\nYou have completed the core curriculum. Below are the \"Knowledge Black Holes\" expanded for the master-level student.\n\n### [[ADVANCED_CONTEXT:Write-Ahead Logging (WAL)]]\nThe WAL is not just a file; it is a **versioning system**. \n*   **The Mechanism**: Every time you write, you create a new version of a page in the WAL. \n*   **The Benefit**: Readers keep looking at the *old* version in the main DB file. Writers keep appending to the *new* version in the WAL. This is why SQLite can handle multiple readers and one writer simultaneously without any locking conflicts. It is the closest thing to \"free\" concurrency.\n\n### [[ADVANCED_CONTEXT:Concurrency Control and ACID Compliance]]\nThe \"Consistency\" in ACID is often the hardest to grasp. It means the database must transition from one valid state to another. If your **B-Tree** split (Milestone 4) is interrupted, \"Consistency\" is what ensures that the partial split is either finished or rolled back during the next boot. This is achieved via **Idempotent Recovery**—the ability to run the recovery log multiple times and always get the same result.\n\n\n![The ACID Safeguard](./diagrams/diag-acid-lifecycle.svg)\n\n\n---\n**GRADUATION STATUS: MASTER ARCHITECT**\nYou have the blueprints. You have the obsession. Now, go build something that lasts.\n\n[↑ Back to System Map](#satellite-map)\n<!-- END_MS -->\n\n\n![The Query Lifecycle](./diagrams/diag-full-traversal.svg)\n\n\n![The Milestone Handoff](./diagrams/diag-hand-off.svg)\n\n\n![The Hardware Tax](./diagrams/diag-cpu-stalls.svg)\n\n\n![The ACID Safeguard](./diagrams/diag-acid-lifecycle.svg)\n\n<!-- END_MS -->\n\n\n\n\n# TDD\n\nA modular, register-based relational database engine designed for high throughput and crash-resilience. The architecture prioritizes page-aligned storage, zero-copy serialization, and a Write-Ahead Logging (WAL) protocol to ensure ACID compliance while minimizing I/O bottlenecks.\n\n\n\n<!-- TDD_MOD_ID: mod-compiler -->\n## Module: SQL Front-End & Compiler\n### 1. Technical Specification\nThe **SQL Front-End & Compiler** module is responsible for the transformation of raw UTF-8 SQL strings into executable VDBE (Virtual Database Engine) bytecode. Its primary responsibilities include:\n1.  **Lexical Analysis**: Segmenting the input stream into a sequence of atomic tokens.\n2.  **Syntactic Analysis**: Validating the token sequence against the SQL grammar (BNF).\n3.  **Semantic Analysis**: Resolving identifiers (table/column names) against the Database Schema.\n4.  **Code Generation**: Emitting optimized VDBE opcodes and allocating virtual registers.\n\nThis module operates in a \"one-pass\" or \"two-pass\" fashion depending on query complexity, prioritizing minimal memory overhead and zero-copy string references where possible.\n\n---\n\n### 2. Abstraction Layers\n1.  **Transport Layer (REPL/API)**: Manages the `InputBuffer` and handles line-ending normalization.\n2.  **Lexer Layer**: A state-machine-based tokenizer that emits `Token` structs.\n3.  **Parser Layer**: A recursive-descent or LALR parser that constructs a transient Abstract Syntax Tree (AST) or directly emits bytecode.\n4.  **Emission Layer**: The `VDBE Assembler` which maps logical SQL operations to physical Opcodes.\n\n---\n\n### 3. Struct & Interface Definitions\n\n#### 3.1 Data Structures\nAll structures are designed for 64-bit alignment to minimize CPU cycle waste during memory access.\n\n```c\n/* Memory Alignment: 32 bytes */\ntypedef struct {\n    const char* start;    /* 8 bytes: Pointer to start of token in input buffer */\n    uint32_t length;      /* 4 bytes: Length of token */\n    uint32_t line;        /* 4 bytes: Source line for error reporting */\n    TokenType type;       /* 4 bytes: Enum (e.g., TOKEN_SELECT, TOKEN_IDENTIFIER) */\n    uint8_t metadata;     /* 1 byte: Flags (is_quoted, is_hex, etc.) */\n    uint8_t _padding[11]; /* 11 bytes: Explicit padding for 32-byte alignment */\n} Token;\n\n/* VDBE Instruction: 24 bytes */\ntypedef struct {\n    uint8_t opcode;       /* 1 byte: The instruction code (e.g., OP_Column) */\n    int32_t p1;           /* 4 bytes: Operand 1 (often a cursor or register index) */\n    int32_t p2;           /* 4 bytes: Operand 2 (often a jump destination) */\n    int32_t p3;           /* 4 bytes: Operand 3 */\n    void* p4;             /* 8 bytes: Pointer to complex data (strings, blobs) */\n    uint8_t _padding[3];  /* 3 bytes: Realignment */\n} VDBE_Op;\n\ntypedef struct {\n    VDBE_Op* instructions;\n    uint32_t count;\n    uint32_t capacity;\n    uint32_t reg_count;   /* Number of registers required for this program */\n} VDBE_Program;\n```\n\n#### 3.2 Method Interface\n```c\n/* Tokenizer: Scans next token from cursor */\nToken scanner_next_token(const char** cursor);\n\n/* Parser: Entry point for SQL Compilation */\nResult compile_sql(const char* sql, VDBE_Program* out_program);\n\n/* CodeGen: Emits an instruction to the program buffer */\nuint32_t emit_op(VDBE_Program* p, uint8_t op, int32_t p1, int32_t p2, int32_t p3);\n```\n\n---\n\n### 4. Algorithm Pseudo-code: The Lexer \"Hot Path\"\nThe Lexer is the highest-frequency component. We use a non-destructive pointer-scan.\n\n```python\ndef get_next_token(cursor):\n    # Skip whitespace and comments\n    while is_whitespace(*cursor):\n        cursor++\n\n    start = cursor\n    char c = *cursor++\n\n    # Numeric Literal Path\n    if is_digit(c):\n        while is_digit(*cursor): cursor++\n        return Token(TYPE_NUMBER, start, cursor - start)\n\n    # Identifier / Keyword Path\n    if is_alpha(c) or c == '_':\n        while is_alnum(*cursor) or *cursor == '_':\n            cursor++\n        \n        # Keyword Lookup (Trie or Hash)\n        length = cursor - start\n        type = check_keyword(start, length) ?: TYPE_IDENTIFIER\n        return Token(type, start, length)\n\n    # String Literal Path\n    if c == '\\'':\n        while *cursor != '\\'' and *cursor != '\\0':\n            cursor++\n        if *cursor == '\\'': cursor++ # Consume closing quote\n        return Token(TYPE_STRING, start, cursor - start)\n\n    # Operator Path (Multi-character support)\n    if c == '>' and *cursor == '=':\n        cursor++\n        return Token(TYPE_GREATER_EQUAL, start, 2)\n\n    return Token(TYPE_UNKNOWN, start, 1)\n```\n\n---\n\n### 5. Engineering Constraints & Hazards\n\n#### 5.1 Concurrency\n*   **Thread Safety**: The Compiler is thread-safe as it maintains no global state. Each `compile_sql` invocation operates on a thread-local AST and instruction buffer.\n*   **Schema Locks**: During Semantic Analysis, the compiler must acquire a `SHARED_LOCK` on the Schema to ensure table definitions do not change mid-compilation.\n\n#### 5.2 Memory Management\n*   **Arena Allocation**: To avoid heap fragmentation during parsing, all AST nodes are allocated in a contiguous `Arena` that is wiped immediately after `VDBE_Program` emission.\n*   **String Interning**: Repeated identifiers (e.g., column names in a large join) are interned to reduce memory footprint and allow pointer-comparison instead of `strcmp`.\n\n#### 5.3 Performance & Micro-Optimization\n*   **Branch Prediction**: The `scanner_next_token` function uses `unlikely()` macros for error conditions (e.g., unterminated strings) to keep the \"Happy Path\" instructions linear in the CPU pipeline.\n*   **SIMD Tokenization**: For large bulk-load statements, the lexer can utilize SIMD (SSE4.2 `pcmpistri`) to find delimiters (commas, quotes, newlines) 16 bytes at a time.\n*   **Cache Locality**: `Token` structs are small (32 bytes) to ensure multiple tokens fit within a single 64-byte L1 cache line during lookahead operations.\n\n---\n\n### 6. Diagrams\n\n{{DIAGRAM:tdd-sql-flow}}\n{{DIAGRAM:tdd-diag-compiler-stage}}\n\n```mermaid\nsequenceDiagram\n    participant U as User/API\n    participant L as Lexer\n    participant P as Parser\n    participant S as Schema\n    participant C as CodeGen\n    participant V as VDBE\n\n    U->>L: raw_sql_string\n    loop until EOF\n        L->>P: emit(Token)\n    end\n    P->>S: resolve_identifiers(table_name)\n    S-->>P: column_metadata\n    P->>C: logical_plan\n    C->>C: optimize_jumps()\n    C-->>V: VDBE_Program (Bytecode)\n    V->>U: Result/Execution\n```\n\n\n<!-- TDD_MOD_ID: mod-vdbe -->\n# Module: Virtual Database Engine (VDBE)\n\n## 1. Technical Specification\nThe **Virtual Database Engine (VDBE)** is a register-based virtual machine designed to execute the bytecode emitted by the SQL Compiler. It serves as the bridge between high-level logical plans and the low-level B-Tree storage layer.\n\n### Primary Responsibilities:\n1.  **Instruction Execution**: Sequential processing of opcodes (e.g., `OpenRead`, `Column`, `Next`).\n2.  **Register Management**: Maintenance of a virtual register file for intermediate data storage.\n3.  **Cursor Orchestration**: Managing pointers (cursors) into B-Tree pages for row-level traversal.\n4.  **Transaction Control**: Interfacing with the Pager to initiate commits, rollbacks, and savepoints.\n5.  **Data Serialization**: Encoding and decoding the Record Format (Milestone 7) into registers.\n\n---\n\n## 2. Abstraction Layers\n1.  **Execution Loop (The Dispatcher)**: The central loop that fetches the next instruction and jumps to the handler.\n2.  **Register File (The Memory)**: An array of `Mem` structures representing registers.\n3.  **Cursor Layer (The Iterator)**: An abstraction over B-Tree pages that maintains position, state (EOF), and cache for the current row.\n4.  **Storage Interface (The VFS/Pager)**: Direct hooks into the Pager for atomic disk I/O.\n\n---\n\n## 3. Struct & Interface Definitions\n\n### 3.1 Data Structures\nStructures are optimized for **L1/L2 cache locality** and **8-byte boundary alignment**.\n\n```c\n/* Register Type Tag */\ntypedef enum {\n    MEM_Null, MEM_Int, MEM_Real, MEM_Str, MEM_Blob, MEM_Undefined\n} MemType;\n\n/* \n * Register (Mem): 24 bytes \n * Tagged union representing a single VDBE register.\n */\ntypedef struct {\n    union {\n        int64_t i;         /* Integer value */\n        double r;          /* Real (Floating point) */\n        char *z;           /* String or Blob pointer */\n    } u;\n    uint32_t n;            /* Size of string/blob */\n    uint16_t flags;        /* MemType and internal state */\n    uint8_t _padding[6];   /* Align to 8-byte boundary */\n} Mem;\n\n/* \n * VdbeCursor: 48 bytes \n * Tracks position within a specific B-Tree.\n */\ntypedef struct {\n    BtCursor *pCursor;     /* Pointer to underlying B-Tree cursor */\n    uint8_t eState;        /* Cursor state: VALID, INVALID, EOF */\n    uint8_t isReadOnly;    /* Permission flag */\n    int32_t iPage;         /* Current page index */\n    uint32_t nFields;      /* Number of columns in the current row */\n    uint8_t _padding[22];  /* Ensure alignment for array access */\n} VdbeCursor;\n\n/* \n * Vdbe: The VM State Machine \n */\ntypedef struct {\n    VDBE_Program *pProg;   /* The bytecode to execute */\n    Mem *aReg;             /* Register file (array of Mem) */\n    VdbeCursor **apCsr;    /* Array of active cursors */\n    int32_t pc;            /* Program Counter */\n    uint8_t errorMask;     /* Error state */\n    uint8_t status;        /* VM status: HALT, RUNNING, YIELD */\n} Vdbe;\n```\n\n### 3.2 Method Interface\n```c\n/* Execution Entry */\nint vdbe_step(Vdbe *p);\n\n/* Register Accessors */\nint64_t vdbe_get_int(Vdbe *p, uint32_t regIdx);\nvoid vdbe_set_str(Vdbe *p, uint32_t regIdx, char *z, int n);\n\n/* Cursor Operations */\nint vdbe_cursor_seek(VdbeCursor *pCsr, int64_t key);\n```\n\n---\n\n## 4. Algorithm Pseudo-code: The Hot Path\nThe \"Hot Path\" is the instruction dispatch loop. In high-performance builds, we replace the `switch` with **Computed Gotos**.\n\n```c\n/* Standard VDBE Execution Loop */\nint vdbe_exec(Vdbe *p) {\n    /* Opcode Handler Table (Computed Goto Labels) */\n    static const void *labels[] = { \n        &&L_OP_Init, &&L_OP_OpenRead, &&L_OP_Column, &&L_OP_Next, ... \n    };\n\n    while (p->status == RUNNING) {\n        VDBE_Op *pOp = &p->pProg->instructions[p->pc];\n\n        /* Jump to instruction handler */\n        goto *labels[pOp->opcode];\n\n    L_OP_OpenRead:\n        /* p1: cursor index, p2: root page */\n        p->apCsr[pOp->p1] = btree_cursor_open(pOp->p2);\n        p->pc++;\n        continue;\n\n    L_OP_Column:\n        /* p1: cursor index, p2: column index, p3: dest register */\n        Mem *pDest = &p->aReg[pOp->p3];\n        vdbe_extract_column(p->apCsr[pOp->p1], pOp->p2, pDest);\n        p->pc++;\n        continue;\n\n    L_OP_Next:\n        /* p1: cursor index, p2: jump destination */\n        if (btree_cursor_next(p->apCsr[pOp->p1])) {\n            p->pc = pOp->p2; /* Loop back */\n        } else {\n            p->pc++; /* EOF, break loop */\n        }\n        continue;\n\n    L_OP_Halt:\n        p->status = HALTED;\n        return SUCCESS;\n    }\n}\n```\n\n---\n\n## 5. Engineering Constraints & Hazards\n\n1.  **Register Pressure**: Complex queries (deeply nested subqueries) can exhaust allocated registers. The compiler must pre-calculate `max_registers` to avoid dynamic reallocation during execution.\n2.  **Cursor Leakage**: If the VM halts due to an error (e.g., Disk I/O Error), all open `VdbeCursor` objects must be explicitly closed to release Pager locks and memory.\n3.  **Recursive Limits**: While the VM is linear, certain opcodes might trigger recursive B-Tree splits. We must enforce a **B-Tree Depth Limit** (typically 20 levels) to prevent stack overflow.\n4.  **Floating Point Non-Determinism**: If using the DB for financial calculations, the `MEM_Real` type must be handled with IEEE 754 precision to ensure consistent results across different CPU architectures.\n\n---\n\n## 6. Micro-Optimization Corner\n\n### 6.1 Dispatch Strategy: Computed Gotos\nStandard `switch` statements generate a jump table, but the CPU's **Branch Target Buffer (BTB)** struggles to predict the destination because every opcode returns to the same `switch` entry point. **Computed Gotos** (supported by GCC/Clang) allow each opcode handler to jump *directly* to the next handler, providing the BTB with more specific context and reducing pipeline stalls.\n\n### 6.2 Data Locality: Register Tiling\nThe `Mem` array should be allocated as a contiguous block. By keeping frequently accessed registers (e.g., those used in a `WHERE` clause) close together in index space, we increase the probability of they residing in the same **L1 Cache Line**.\n\n### 6.3 SIMD Column Extraction\nWhen processing `OP_Column` for multiple rows of fixed-width integers, the VDBE can utilize **AVX2/AVX-512** to deserialize 4 or 8 integers from the Record Format into registers simultaneously, bypassing the bit-shifting logic usually required for Varints.\n\n---\n\n## 7. Diagrams\n\n{{DIAGRAM:tdd-vdbe-exec}}\n\n![VDBE Opcode Dispatch](./diagrams/tdd-diag-vdbe-dispatch.svg)\n\n\n```mermaid\ngraph TD\n    subgraph VDBE_Core\n        PC[Program Counter] --> Fetch[Fetch Instruction]\n        Fetch --> Dispatch{Computed Goto}\n    end\n\n    subgraph Handlers\n        Dispatch --> OP_Open[OP_OpenRead]\n        Dispatch --> OP_Column[OP_Column]\n        Dispatch --> OP_Next[OP_Next]\n    end\n\n    subgraph Storage_Interface\n        OP_Open --> Pager[Pager/B-Tree]\n        OP_Column --> Record[Record Decoder]\n        OP_Next --> BTree_Scan[B-Tree Page Iterator]\n    end\n\n    subgraph Memory\n        Record --> Regs[Register File]\n        Regs --> Output[Result Set Buffer]\n    end\n```\n\n\n<!-- TDD_MOD_ID: mod-storage -->\n# Module: Pager & B-Tree Storage Engine\n\n## 1. Technical Specification\nThe **Pager & B-Tree Storage Engine** is the persistence layer of the database. It is responsible for the translation of logical database records into physical on-disk structures while guaranteeing the **ACID** properties (Atomicity, Consistency, Isolation, Durability).\n\n### Core Responsibilities:\n1.  **Page Management**: Partitioning the database file into fixed-size blocks (default 4096 bytes) to match physical disk sector alignment.\n2.  **Cache Management (Buffer Pool)**: Maintaining an in-memory LRU (Least Recently Used) cache of pages to minimize expensive disk I/O.\n3.  **B+Tree Implementation**: Providing $O(\\log N)$ search, insert, and delete performance via a balanced multi-level tree.\n4.  **Concurrency Control**: Utilizing page-level latches (mutexes) to allow concurrent readers while protecting structural modifications (splits/merges).\n5.  **Recovery & Durability**: Orchestrating the Write-Ahead Log (WAL) to ensure that partial writes during power failure can be rolled forward or back.\n\n---\n\n## 2. Abstraction Layers\n1.  **VFS Layer (OS Interface)**: Direct interaction with `pread()`, `pwrite()`, and `fsync()`.\n2.  **Pager Layer**: Manages the life cycle of a page (Fetch, Dirty, Flush, Evict).\n3.  **B-Tree Logic Layer**: Handles the structural integrity (balancing, pointer updates).\n4.  **Cell Layer**: Manages the serialization of keys and payloads within a single page's byte-array.\n\n---\n\n## 3. Struct & Interface Definitions\n\n### 3.1 Data Structures\nMemory alignment is strictly enforced to 8-byte boundaries for metadata and 4096-byte boundaries for page buffers to utilize O_DIRECT I/O where available.\n\n```c\ntypedef uint32_t pgno_t; /* Page Number Type */\n\n/* B-Tree Node Types */\ntypedef enum {\n    BT_INTERNAL_NODE = 0x05,\n    BT_LEAF_NODE = 0x0D\n} BtNodeType;\n\n/* \n * B-Tree Page Header: 12 bytes \n * Located at the start of every 4KB page.\n */\ntypedef struct {\n    uint8_t  type;           /* Node type (Internal/Leaf) */\n    uint16_t free_start;     /* Start of free space in the page */\n    uint16_t cell_count;     /* Number of cells (records/pointers) */\n    uint32_t right_child;    /* Right-most child pgno (Internal only) */\n    uint8_t  _padding[3];\n} BtPageHeader;\n\n/* \n * Pager Cache Entry: 4128 bytes (approx)\n * Alignment: 4096 (for buffer) + metadata\n */\ntypedef struct Page {\n    void* data;              /* 4KB Page Buffer (aligned to 4096) */\n    pgno_t pgno;             /* Page Number */\n    uint8_t is_dirty;        /* Flag: Needs write to disk */\n    uint32_t ref_count;      /* Current users of this page */\n    struct Page *next_lru;   /* Pointer for LRU linked list */\n    struct Page *prev_lru;\n} Page;\n\n/* \n * B-Tree Search Cursor: 64 bytes\n */\ntypedef struct BtCursor {\n    Pager *pPager;           /* Parent Pager */\n    pgno_t root_pgno;        /* Root of the tree */\n    Page *pCurrentPage;      /* Current page held in memory */\n    uint16_t cell_idx;       /* Current cell index within the page */\n    uint8_t eState;          /* VALID, EOF, FAULT */\n    uint8_t _padding[31];    /* Alignment */\n} BtCursor;\n```\n\n### 3.2 Method Interface\n```c\n/* Pager: Fetch a page from disk or cache */\nint pager_acquire(Pager *pPager, pgno_t pgno, Page **ppPage);\n\n/* Pager: Release page back to cache; decrement ref_count */\nvoid pager_release(Page *pPage);\n\n/* B-Tree: Seek to a key (entry point for SELECT/UPDATE) */\nint btree_seek(BtCursor *pCur, uint64_t key, int *pRes);\n\n/* B-Tree: Insert a new cell (triggers splits if necessary) */\nint btree_insert(BtCursor *pCur, uint64_t key, void *pPayload, uint32_t nPayload);\n```\n\n---\n\n## 4. Algorithm Pseudo-code: The \"Hot Path\" (B-Tree Search)\nThis algorithm traverses the tree from root to leaf. It is performance-critical as it is invoked for every row lookup.\n\n```python\ndef btree_seek_recursive(pager, pgno, target_key, cursor):\n    # 1. Acquire page from Pager (Cache or Disk)\n    page = pager.acquire(pgno)\n    header = parse_header(page.data)\n    \n    # 2. Binary Search within the page's Cell Pointer Array\n    # Cells are stored at the end of the page; pointers at the start.\n    idx = binary_search_cells(page, target_key)\n    \n    if header.type == BT_LEAF_NODE:\n        # We found the leaf where the key should reside\n        cursor.pCurrentPage = page\n        cursor.cell_idx = idx\n        return SUCCESS\n    \n    else:\n        # Internal Node: idx points to the child subtree\n        child_pgno = get_child_pgno(page, idx)\n        pager.release(page) # Release parent before descending\n        return btree_seek_recursive(pager, child_pgno, target_key, cursor)\n\ndef binary_search_cells(page, target_key):\n    # Micro-optimized inner loop\n    low = 0\n    high = page.header.cell_count - 1\n    while low <= high:\n        mid = (low + high) // 2\n        cell_key = get_key_at_idx(page, mid)\n        if cell_key == target_key: return mid\n        if cell_key < target_key: low = mid + 1\n        else: high = mid - 1\n    return low # Returns insertion point if not found\n```\n\n---\n\n## 5. Engineering Constraints & Hazards\n\n### 5.1 The \"Torn Write\" Hazard\n**Problem**: The OS might crash while the disk is writing a 4KB page, leaving the first 2KB as new data and the last 2KB as old data.\n**Solution**: The Pager must implement a **Double-Write Buffer** or **WAL Checksumming**. Every page write is first recorded in the WAL with a CRC32 checksum. During recovery, if a page's checksum fails, the WAL version is used to restore integrity.\n\n### 5.2 Cache Pressure & Eviction\n**Constraint**: The Pager must not evict \"Dirty\" pages (modified in RAM but not on disk) unless they are first flushed.\n**Hazard**: If the cache is 100% dirty and the disk is full, the engine enters a **Livelock** state.\n**Design**: Maintain a `min_free_pages` threshold. When the cache reaches 80% capacity, a background \"Checkpointer\" thread begins flushing dirty pages to the WAL and marking them clean.\n\n### 5.3 Concurrency (B-Tree Latching)\n**Mechanism**: Use **Read-Write Latches** on pages.\n*   **Search**: Acquire `SHARED` latch on parent, then child, then release parent (Crabbing).\n*   **Insert/Split**: Must acquire `EXCLUSIVE` latches from the root down if a split is likely (Pre-emptive splitting) to prevent deadlocks where a child needs to lock its parent.\n\n---\n\n## 6. Micro-Optimization Corner\n\n### 6.1 Cache Locality: Cell Pointer Array\nInside the 4KB page, we do not store cells in order. We store them anywhere in the heap space at the end of the page. We maintain a **Cell Pointer Array** at the top. This ensures that the binary search only iterates over a contiguous array of 2-byte offsets, which fits entirely in a single **L1 Cache Line**, avoiding expensive DRAM fetches during the search loop.\n\n### 6.2 SIMD Binary Search\nFor pages with high fan-out (e.g., thousands of small keys), the `binary_search_cells` can be vectorized using **AVX2**. We can load 8 or 16 cell keys into a YMM register and perform a parallel comparison, effectively reducing the binary search branches by $log_2(8)$.\n\n---\n\n## 7. Diagrams\n\n{{DIAGRAM:tdd-pager-btree-arch}}\n{{DIAGRAM:tdd-btree-split-seq}}\n\n\n![Physical Storage Layout](./diagrams/tdd-storage-layout.svg)\n\n\n```mermaid\ngraph TD\n    subgraph Pager_Layer\n        Cache[Page Cache / LRU]\n        WAL[Write Ahead Log]\n        VFS[Virtual File System]\n    end\n\n    subgraph BTree_Layer\n        Root[Root Page]\n        Internal[Internal Nodes]\n        Leaf[Leaf Nodes]\n    end\n\n    VDBE[VDBE Engine] -->|Request pgno| Cache\n    Cache -->|Miss| VFS\n    Cache -->|Hit| BTree_Layer\n    BTree_Layer -->|Search| Internal\n    Internal -->|Pointer| Leaf\n    Leaf -->|Update| Dirty[Mark Page Dirty]\n    Dirty --> WAL\n    WAL -->|Commit| VFS\n```\n\n\n<!-- TDD_MOD_ID: mod-tx-manager -->\n# Module: Transaction & Concurrency Controller\n## 1. Technical Specification\nThe **Transaction & Concurrency Controller (TCC)** is the architectural arbiter of the database. Its primary mandate is to enforce **ACID** (Atomicity, Consistency, Isolation, Durability) guarantees across multi-threaded and multi-process environments.\n\n### Responsibilities:\n1.  **Isolation Management**: Implementing a 5-state locking protocol (UNLOCKED, SHARED, RESERVED, PENDING, EXCLUSIVE) to prevent race conditions.\n2.  **Atomicity via WAL**: Orchestrating the Write-Ahead Log (WAL) to ensure that transactions are \"all-or-nothing.\"\n3.  **Concurrency Optimization**: Enabling \"Readers-don't-block-Writers\" semantics using a WAL-based Multi-Version Concurrency Control (MVCC) subset.\n4.  **Recovery Coordination**: Replaying or rolling back log frames during system initialization after an ungraceful shutdown.\n5.  **Deadlock Avoidance**: Enforcing strict lock-acquisition hierarchies to prevent circular dependencies.\n\n---\n\n## 2. Abstraction Layers\n1.  **The API Layer (Transaction Guard)**: High-level `BEGIN`, `COMMIT`, and `ROLLBACK` logic.\n2.  **The Lock Manager**: An internal state machine managing the transition between lock levels using atomic primitives.\n3.  **The WAL Director**: Manages the append-only `.wal` file and the shared-memory index (`.wal-index`).\n4.  **The Checkpointer**: A background process that migrates committed data from the WAL back to the main database file.\n\n---\n\n## 3. Struct & Interface Definitions\n\n### 3.1 Data Structures\nStructures are padded to 64-bit boundaries to prevent \"False Sharing\" in multi-core L1 caches and to ensure atomic 8-byte alignment.\n\n```c\n/* Lock State Taxonomy */\ntypedef enum {\n    LOCK_NONE      = 0, // Unlocked\n    LOCK_SHARED    = 1, // Read-only; multiple allowed\n    LOCK_RESERVED  = 2, // Plan to write; only one allowed; shared locks persist\n    LOCK_PENDING   = 3, // Waiting for shared locks to clear before EXCLUSIVE\n    LOCK_EXCLUSIVE = 4  // Writing; no other connections allowed\n} LockLevel;\n\n/* \n * Transaction Context: 64 bytes \n * Tracks the state of a single connection's transaction.\n */\ntypedef struct {\n    uint64_t tx_id;          /* 8 bytes: Monotonically increasing ID */\n    LockLevel lock_level;    /* 4 bytes: Current lock state */\n    uint32_t wal_index_pos;  /* 4 bytes: Last known good position in WAL */\n    uint8_t is_autocommit;   /* 1 byte: Flag for implicit transactions */\n    uint8_t dirty_flag;      /* 1 byte: True if memory pages were modified */\n    uint8_t _padding[46];    /* Padding to reach 64-byte (Cache Line) alignment */\n} TxContext;\n\n/* \n * WAL Frame Header: 24 bytes \n * Precedes every page-blob in the WAL file.\n */\ntypedef struct {\n    uint32_t pgno;           /* 4 bytes: Target page number in main DB */\n    uint32_t commit_flag;    /* 4 bytes: Non-zero if this is a commit record */\n    uint64_t sequence;       /* 8 bytes: Checksum or sequence number */\n    uint32_t salt1;          /* 4 bytes: Random salt for checksum integrity */\n    uint32_t salt2;          /* 4 bytes: Random salt */\n} WalFrameHeader;\n```\n\n### 3.2 Method Interface\n```c\n/* Transition the connection to a new lock state */\nint tcc_acquire_lock(TxContext *ctx, LockLevel required);\n\n/* Write a dirty page to the WAL buffer */\nint tcc_wal_append(TxContext *ctx, pgno_t pgno, void *page_data);\n\n/* Atomic commit: Write commit frame and fsync */\nint tcc_commit(TxContext *ctx);\n\n/* Recovery: Replay WAL into main DB */\nint tcc_checkpoint(Pager *pPager);\n```\n\n---\n\n## 4. Algorithm Pseudo-code: The \"Hot Path\" (Acquire Lock)\nThe `tcc_acquire_lock` function is the bottleneck for write throughput. It utilizes a non-blocking state machine with exponential backoff on contention.\n\n```python\ndef tcc_acquire_lock(ctx, requested_level):\n    current = ctx.lock_level\n\n    if current >= requested_level:\n        return SUCCESS # Already held\n\n    # Logic: SHARED -> RESERVED -> PENDING -> EXCLUSIVE\n    if requested_level == LOCK_SHARED:\n        # Atomic Increment on Shared-Memory Read-Counter\n        if atomic_inc_if_not_exclusive(shm.read_count):\n            ctx.lock_level = LOCK_SHARED\n            return SUCCESS\n        return ERR_BUSY\n\n    if requested_level == LOCK_RESERVED:\n        # Only one RESERVED lock allowed globally\n        if atomic_compare_and_swap(shm.reserved_flag, 0, 1):\n            ctx.lock_level = LOCK_RESERVED\n            return SUCCESS\n        return ERR_BUSY\n\n    if requested_level == LOCK_EXCLUSIVE:\n        # 1. Promote to PENDING (Block new readers)\n        if not atomic_compare_and_swap(shm.pending_flag, 0, 1):\n            return ERR_BUSY\n            \n        # 2. Wait for existing readers to exit\n        while shm.read_count > 0:\n            wait_with_backoff()\n            \n        # 3. Final promotion\n        ctx.lock_level = LOCK_EXCLUSIVE\n        return SUCCESS\n```\n\n---\n\n## 5. Engineering Constraints & Hazards\n\n### 5.1 The \"Checkpoint Starvation\" Problem\n**Hazard**: If a database has constant high-frequency read traffic, the `shm.read_count` may never reach zero, preventing the Checkpointer from acquiring an `EXCLUSIVE` lock to merge the WAL back to the main DB.\n**Constraint**: The TCC must implement a \"Queue Priority\" where, after a threshold, new Shared lock requests are queued behind a pending Checkpoint to ensure the WAL doesn't grow infinitely (Write Amplification).\n\n### 5.2 Memory Barriers & Visibility\n**Hazard**: In multi-core systems, a thread on Core 1 might write a `commit_flag` to the WAL-index in RAM, but Core 2 might not \"see\" it due to CPU cache delay.\n**Requirement**: Use **Store-Load Barriers** (`__smp_mb()`) immediately after writing the `commit_flag` and before signaling other threads.\n\n### 5.3 Micro-Optimization: Lock-Free WAL Tracking\nThe WAL-index (shared memory) uses a lock-free **Hash Table** to map `pgno` (Page Number) to `wal_offset`. \n- **Optimization**: Use a linear-probing hash map where each entry is a single 64-bit integer (32-bit `pgno` | 32-bit `offset`). This allows the entire lookup to be performed with a single atomic `LDR` (load) instruction, bypassing mutex overhead entirely for read queries.\n\n---\n\n## 6. Diagrams\n\n{{DIAGRAM:tdd-tx-states}}\n{{DIAGRAM:tdd-wal-flow}}\n\n\n![Lock Compatibility Matrix](./diagrams/tdd-diag-lock-matrix.svg)\n\n\n```mermaid\nsequenceDiagram\n    participant V as VDBE\n    participant T as TCC_Manager\n    participant W as WAL_Log\n    participant D as Disk_DB\n\n    V->>T: BEGIN TRANSACTION\n    T->>T: Acquire SHARED Lock\n    V->>T: UPDATE row (Dirty Page 5)\n    T->>T: Acquire RESERVED Lock\n    T->>W: Write Page 5 to WAL\n    V->>T: COMMIT\n    T->>T: Promote to EXCLUSIVE\n    T->>W: Write COMMIT Frame\n    T->>W: FSYNC(wal_file)\n    T->>T: Downgrade to SHARED\n    Note over T,D: Checkpointer runs later...\n    T->>D: Merge WAL to Main DB\n```\n\n```mermaid\nstateDiagram-v2\n    [*] --> UNLOCKED\n    UNLOCKED --> SHARED: Read Request\n    SHARED --> RESERVED: Write Intent\n    RESERVED --> PENDING: Commit Start\n    PENDING --> EXCLUSIVE: Read Count == 0\n    EXCLUSIVE --> UNLOCKED: Commit Finish\n    RESERVED --> UNLOCKED: Rollback\n```\n\n\n<!-- TDD_MOD_ID: mod-serialization -->\n<!-- TDD_MOD_ID: mod-record-schema -->\n# Module: Record Serialization & Schema Manager\n\n## 1. Technical Specification\nThe **Record Serialization & Schema Manager** is the \"translator\" between the VDBE’s high-level register representations and the B-Tree’s raw byte payloads. This module implements a variable-length, packed-header format designed to minimize disk footprint and support schema evolution without requiring full-table rewrites.\n\n### Core Responsibilities:\n1.  **Varint Encoding/Decoding**: Implementing a 7-bit-per-byte variable-length integer format to represent metadata and small integers efficiently.\n2.  **Record Compaction**: Packing heterogeneous data types (Int, Float, String, Blob, Null) into a contiguous byte stream.\n3.  **Serial Type Mapping**: Assigning \"Serial Type IDs\" to represent data categories and lengths within the record header.\n4.  **Schema Versioning**: Managing the `schema_cookie` to ensure the VDBE bytecode matches the physical layout of the stored records.\n5.  **Null-Efficiency**: Encoding `NULL`, `0`, and `1` as header-only types requiring zero payload bytes.\n\n---\n\n## 2. Abstraction Layers\n1.  **Logical Layer (Schema)**: Defines the mapping of column names to indices and affinity types (e.g., Column 0 is `INTEGER PRIMARY KEY`).\n2.  **Transformation Layer (VDBE Registers)**: Maps `Mem` structs (Milestone 8) to the Serialization Logic.\n3.  **Physical Layer (Record Format)**: The byte-array layout consisting of a `Header Length`, `Serial Type Array`, and `Data Payload`.\n\n---\n\n## 3. Struct & Interface Definitions\n\n### 3.1 Data Structures\nThe serialization structures are optimized for zero-copy access where the header can be parsed without moving the payload.\n\n```c\n/* \n * Serial Type Mappings (Subset of SQLite Spec)\n * 0: NULL, 1-6: Integers (1-8 bytes), 7: Float64, 8: Integer 0, 9: Integer 1\n * 12+: Blob/String (Length = (N-12)/2 or (N-13)/2)\n */\ntypedef uint64_t serial_type_t;\n\n/* \n * Record Descriptor: 32 bytes \n * Transient structure used during packing/unpacking.\n */\ntypedef struct {\n    uint32_t header_len;    /* 4 bytes: Size of the header section */\n    uint32_t payload_len;   /* 4 bytes: Total size of the record */\n    uint8_t *p_header;      /* 8 bytes: Pointer to start of serial types */\n    uint8_t *p_payload;     /* 8 bytes: Pointer to start of actual data */\n    uint16_t num_columns;   /* 2 bytes: Count of columns in this record */\n    uint8_t _padding[6];    /* 6 bytes: 64-bit alignment */\n} RecordDescriptor;\n\n/* \n * Column Schema: 24 bytes \n * Stored in the sqlite_master internal table.\n */\ntypedef struct {\n    char* name;             /* 8 bytes */\n    uint8_t affinity;       /* 1 byte: TEXT, NUMERIC, INTEGER, BLOB, REAL */\n    uint8_t is_pk;          /* 1 byte: Primary Key flag */\n    uint8_t not_null;       /* 1 byte: Constraint flag */\n    uint32_t default_reg;   /* 4 bytes: Index of register containing default value */\n    uint8_t _padding[9];\n} ColumnDef;\n```\n\n### 3.2 Method Interface\n```c\n/* Encode a 64-bit integer into a Varint (1-9 bytes) */\nint record_encode_varint(uint64_t value, uint8_t *out);\n\n/* Decode a Varint into a 64-bit integer; returns bytes consumed */\nint record_decode_varint(const uint8_t *in, uint64_t *out_value);\n\n/* Serialize VDBE registers into a B-Tree cell payload */\nint record_pack(Mem *aReg, uint32_t nReg, RecordDescriptor *out_rec);\n\n/* Extract a specific column from a raw byte buffer into a register */\nint record_unpack_column(const uint8_t *data, uint32_t col_idx, Mem *pOut);\n```\n\n---\n\n## 4. Algorithm Pseudo-code: The \"Hot Path\"\n\n### 4.1 Varint Encoding (Performance Critical)\nUsed for every column metadata entry and header length.\n\n```c\nint record_encode_varint(uint64_t v, uint8_t *p) {\n    int i, j;\n    uint8_t buf[10];\n    if( v & (((uint64_t)0xff000000)<<32) ){\n        p[8] = (uint8_t)v;\n        v >>= 8;\n        for(i=7; i>=0; i--){\n            p[i] = (uint8_t)((v & 0x7f) | 0x80);\n            v >>= 7;\n        }\n        return 9;\n    }\n    n = 0;\n    do{\n        buf[n++] = (uint8_t)((v & 0x7f) | 0x80);\n        v >>= 7;\n    }while( v!=0 );\n    buf[0] &= 0x7f;\n    for(i=0, j=n-1; j>=0; j--, i++){\n        p[i] = buf[j];\n    }\n    return n;\n}\n```\n\n### 4.2 Record Packing (The Write Path)\nThis logic transforms VDBE registers into the on-disk record.\n\n```python\ndef record_pack(registers, num_cols):\n    header_types = []\n    payload = bytearray()\n    \n    for reg in registers:\n        if reg.type == NULL:\n            header_types.append(0)\n        elif reg.type == INT:\n            if reg.val == 0: header_types.append(8)\n            elif reg.val == 1: header_types.append(9)\n            else:\n                stype = calculate_int_serial_type(reg.val)\n                header_types.append(stype)\n                payload.extend(encode_int(reg.val, stype))\n        elif reg.type == STRING:\n            stype = (len(reg.val) * 2) + 13\n            header_types.append(stype)\n            payload.extend(reg.val.encode('utf-8'))\n            \n    # Calculate Header Length Varint\n    header_bytes = bytearray()\n    for t in header_types:\n        header_bytes.extend(encode_varint(t))\n    \n    total_header_len = len(header_bytes) + len(encode_varint(len(header_bytes)))\n    \n    # Final Assembly: [Total Header Len][Types][Data]\n    return encode_varint(total_header_len) + header_bytes + payload\n```\n\n---\n\n## 5. Engineering Constraints & Hazards (Micro-Optimization Corner)\n\n### 5.1 Concurrency & Persistence\n*   **Hazard: Schema Drift**: If a transaction is compiled against Schema Version 1, but a concurrent transaction commits a `DROP COLUMN` (Schema Version 2), the record layout is invalidated.\n*   **Constraint**: Every `RecordDescriptor` must check the `schema_cookie` of the Pager before performing an unpack operation.\n\n### 5.2 Cache Locality: Header-First Unpacking\n*   **Optimization**: In SQL, `SELECT col_10` is common. In a naive implementation, we must decode all previous 9 columns' varints to find the offset of column 10.\n*   **Cache Strategy**: We store the `RecordHeader` contiguously. Since Varints are 1-byte for most metadata, a single 64-byte L1 cache line usually contains the serial types for ~40 columns. This allows the CPU to scan the header and calculate the offset of `col_10` without any DRAM fetches.\n\n### 5.3 Memory Alignment Tax\n*   **The Problem**: Packed records ignore CPU alignment. A 64-bit float might start at byte 13 of a page.\n*   **The Solution**: We use `memcpy` or `__builtin_memcpy` for multi-byte extractions. Modern CPUs (x86_64/ARMv8) handle unaligned loads in hardware with minimal penalty, provided the load does not straddle a cache-line boundary. For straddling loads, we incur a ~2x latency penalty.\n\n### 5.4 SIMD Varint Decoding\nFor bulk scans, decoding Varints byte-by-byte is a bottleneck. \n*   **Advanced Optimization**: Use **BSR (Bit Scan Reverse)** or `clz` (Count Leading Zeros) to find the termination bit of multiple varints in parallel, or use a PSHUFB-based (SSSE3) shuffle to extract 7-bit values into 8-bit lanes across a 128-bit XMM register.\n\n---\n\n## 6. Diagrams\n\n{{DIAGRAM:tdd-record-format}}\n\n![Record Anatomy](./diagrams/tdd-diag-record-logic.svg)\n\n\n```mermaid\ngraph LR\n    subgraph Header\n        HL[Header Len]\n        T1[Type: Int8]\n        T2[Type: String10]\n        T3[Type: Null]\n    end\n    subgraph Payload\n        P1[Byte 0x01]\n        P2[ASCII: 'User_Name']\n        P3[Empty]\n    end\n    HL --> T1\n    T1 --> T2\n    T2 --> T3\n    T1 -.-> P1\n    T2 -.-> P2\n    T3 -.-> P3\n```\n\n```mermaid\nsequenceDiagram\n    participant V as VDBE Register\n    participant S as Serializer\n    participant B as B-Tree Page\n    \n    V->>S: Mem[Int: 500]\n    V->>S: Mem[Str: \"Atlas\"]\n    S->>S: Calculate SerialTypes (2, 23)\n    S->>S: Compute Varint Sizes\n    S->>S: Build Packed Header\n    S->>B: Write [HeaderLen][2][23][PayloadBytes]\n    B-->>V: Cell Written\n```\n\n[↑ Back to System Map](#satellite-map)\n\n\n# 📚 Beyond the Atlas: Further Reading\n\n### 1. B-Trees (The Warehouse)\n*   **The Paper**: [Organization and Maintenance of Large Ordered Indices](https://dl.acm.org/doi/10.1145/1734663.1734671) (Bayer & McCreight, 1970)\n*   **The RFC**: N/A (De-facto standard in ISO/IEC 9072)\n*   **The Implementation**: [SQLite B-Tree Module](https://github.com/sqlite/sqlite/blob/master/src/btree.c)\n*   **Short Summary**: The foundational data structure that balances disk I/O by minimizing the tree height for massive datasets.\n\n### 2. ARIES: Write-Ahead Logging (The Protector)\n*   **The Paper**: [ARIES: A Transaction Recovery Method](https://www.cs.berkeley.edu/~brewer/cs262b/Aries.pdf) (Mohan et al., 1992)\n*   **The RFC**: N/A (Standardized in Database theory)\n*   **The Implementation**: [PostgreSQL WAL (Write-Ahead Log)](https://github.com/postgres/postgres/tree/master/src/backend/access/transam)\n*   **Short Summary**: The gold standard for ensuring database durability and atomicity through log-based recovery.\n\n### 3. Register-Based Virtual Machines (The Engine)\n*   **The Paper**: [Virtual Machine Showdown: Stack vs. Registers](https://www.usenix.org/legacy/events/vee05/full_papers/p153-shi.pdf) (Shi et al., 2005)\n*   **The RFC**: N/A\n*   **The Implementation**: [Lua VM (The original register-based implementation)](https://www.lua.org/source/5.4/lvm.c.html)\n*   **Short Summary**: Demonstrates why register-based VMs outperform stack-based models by reducing instruction dispatch overhead.\n\n### 4. Cost-Based Query Optimization (The Strategist)\n*   **The Paper**: [Access Path Selection in a Relational Database System](https://dl.acm.org/doi/pdf/10.1145/800084.802640) (Selinger et al., 1979)\n*   **The RFC**: N/A\n*   **The Implementation**: [DuckDB Optimizer](https://github.com/duckdb/duckdb/tree/master/src/optimizer)\n*   **Short Summary**: The seminal work defining how a database estimates query costs to select the most efficient execution path.\n\n### 5. Multi-Version Concurrency Control (The Sentinel)\n*   **The Paper**: [On Optimistic Methods for Concurrency Control](https://dl.acm.org/doi/10.1145/319566.319567) (Kung & Robinson, 1981)\n*   **The RFC**: N/A\n*   **The Implementation**: [LMDB (Lightning Memory-Mapped Database)](https://github.com/LMDB/lmdb/blob/mdb.master/libraries/liblmdb/mdb.c)\n*   **Short Summary**: A sophisticated method allowing concurrent reads and writes without the performance penalty of traditional locking.\n\n### 6. Variable-Length Integers (The Assembly Line)\n*   **The Paper**: [Efficient Integer Compression for Column-Oriented Streams](https://dl.acm.org/doi/10.1145/1142473.1142512)\n*   **The RFC**: [Protocol Buffers Encoding (Spec)](https://protobuf.dev/programming-guides/encoding/#varints)\n*   **The Implementation**: [Google Protobuf Varint C++](https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/io/coded_stream.h)\n*   **Short Summary**: A high-efficiency encoding technique that significantly reduces disk usage by using only the necessary bytes to represent numerical data.\n\n### 7. Virtual File System (The Siege)\n*   **The Paper**: [VFS: A Generic Interface for Filesystems](https://dl.acm.org/doi/10.1145/1447.1448) (Kleiman, 1986)\n*   **The RFC**: [POSIX.1 (System Interfaces)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/contents.html)\n*   **The Implementation**: [Linux Kernel VFS Layer](https://github.com/torvalds/linux/tree/master/fs)\n*   **Short Summary**: Provides a polymorphic abstraction layer that allows software to interact with diverse storage hardware through a unified interface."}