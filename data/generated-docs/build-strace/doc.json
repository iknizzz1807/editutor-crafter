{"html":"<h1 id=\"-project-charter-system-call-tracer-strace-clone\">ðŸŽ¯ Project Charter: System Call Tracer (strace clone)</h1>\n<h2 id=\"what-you-are-building\">What You Are Building</h2>\n<p>A functional clone of the Linux <code>strace</code> utility that intercepts, decodes, and reports every system call made by a target process on x86_64 Linux. You will build a low-level diagnostic tool that halts a tracee at the kernel boundary, extracts its register state, dereferences string arguments from its private address space, and follows its execution across multi-process <code>fork</code> and <code>exec</code> boundaries.</p>\n<h2 id=\"why-this-project-exists\">Why This Project Exists</h2>\n<p>System calls are the narrow gateway through which every program interacts with the world, yet they are usually treated as a hidden black box by high-level languages. Building a tracer from scratch exposes the &quot;register dance&quot; of the x86_64 ABI and the mechanics of virtual memory isolation. You will learn exactly how debuggers and sandboxes control other processes at the hardware level.</p>\n<h2 id=\"what-you-will-be-able-to-do-when-done\">What You Will Be Able to Do When Done</h2>\n<ul>\n<li><strong>Intercept Kernel Transitions</strong>: Use the <code>ptrace</code> API to pause and resume processes at syscall entry and exit.</li>\n<li><strong>Read Remote Memory</strong>: Implement a word-by-word reader to extract null-terminated strings from a tracee&#39;s memory space using <code>PTRACE_PEEKDATA</code>.</li>\n<li><strong>Manage Process Trees</strong>: Build a state machine to track multiple processes and threads as they are created via <code>fork</code>, <code>vfork</code>, and <code>clone</code>.</li>\n<li><strong>Decode Binary ABIs</strong>: Translate raw register values into human-readable flags (e.g., <code>O_RDONLY | O_CREAT</code>) and symbolic syscall names.</li>\n<li><strong>Profile System Performance</strong>: Calculate high-resolution timing statistics using <code>CLOCK_MONOTONIC</code> to identify syscall bottlenecks.</li>\n</ul>\n<h2 id=\"final-deliverable\">Final Deliverable</h2>\n<p>A standalone CLI utility (approximately 1,500 lines of C or Rust) that can trace complex programs like <code>bash</code> or <code>ls</code>. The tool will support PID attachment, syscall name filtering, and summary statistics output that matches the style of the professional <code>strace</code> tool.</p>\n<h2 id=\"is-this-project-for-you\">Is This Project For You?</h2>\n<p><strong>You should start this if you:</strong></p>\n<ul>\n<li>Are comfortable with C or Rust and understand pointers/memory addresses.</li>\n<li>Want to understand the boundary between userspace code and the Linux kernel.</li>\n<li>Are curious about how debuggers like GDB actually work under the hood.</li>\n</ul>\n<p><strong>Come back after you&#39;ve learned:</strong></p>\n<ul>\n<li>Basic Linux process control (<code>fork</code>, <code>exec</code>, <code>waitpid</code>).</li>\n<li>The fundamentals of x86_64 registers.</li>\n<li><a href=\"https://linuxjourney.com/\">How to use the Linux Command Line</a>.</li>\n</ul>\n<h2 id=\"estimated-effort\">Estimated Effort</h2>\n<table>\n<thead>\n<tr>\n<th>Phase</th>\n<th>Time</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Basic ptrace Interception (M1)</td>\n<td>~5-8 hours</td>\n</tr>\n<tr>\n<td>Argument Decoding &amp; Remote Memory (M2)</td>\n<td>~6-8 hours</td>\n</tr>\n<tr>\n<td>Multi-Process &amp; Fork Following (M3)</td>\n<td>~5-8 hours</td>\n</tr>\n<tr>\n<td>Filtering, Statistics &amp; Attachment (M4)</td>\n<td>~6-10 hours</td>\n</tr>\n<tr>\n<td><strong>Total</strong></td>\n<td><strong>~22-34 hours</strong></td>\n</tr>\n</tbody></table>\n<h2 id=\"definition-of-done\">Definition of Done</h2>\n<p>The project is complete when:</p>\n<ul>\n<li>The tracer prints human-readable syscall names and return values (e.g., <code>open(...) = 3</code>).</li>\n<li>Path strings are successfully read from the tracee and displayed in quotes.</li>\n<li>The tracer successfully follows a shell pipeline (e.g., <code>echo hello | cat</code>) across multiple PIDs.</li>\n<li>The <code>-c</code> flag generates a sorted summary table of call counts, errors, and timing.</li>\n<li>The tracer can attach to an existing process by PID and detach cleanly on <code>SIGINT</code> (Ctrl+C).</li>\n</ul>\n<hr>\n<h1 id=\"system-call-tracer-strace-clone\">System Call Tracer (strace clone)</h1>\n<p>This project builds a fully functional strace clone from scratch â€” a ptrace-based system call tracer that intercepts, decodes, and reports every syscall a target process makes on x86_64 Linux. You will start by forking a child, attaching via ptrace, and toggling between syscall entry and exit stops. Then you&#39;ll decode arguments by reading registers, dereference string pointers word-by-word from the tracee&#39;s address space, follow fork/exec across process boundaries, and finally add filtering and statistical profiling.</p>\n<p>The project is a window into the kernel-userspace boundary. Every syscall is a precisely choreographed register dance: the application loads arguments into rdi, rsi, rdx, r10, r8, r9, puts the syscall number in rax, and executes the <code>syscall</code> instruction. The kernel saves state, dispatches, and returns a result in rax. Your tracer sits in between, mediated by ptrace, observing this dance twice per call â€” once on entry, once on exit. Understanding this mechanism is foundational to debuggers (GDB), sandboxes (seccomp), profilers (perf), and container runtimes.</p>\n<p>By the end, you&#39;ll have a tool that can attach to any process, print decoded syscall traces with arguments, follow multi-process workloads, filter by syscall name, and produce timing statistics â€” the core functionality of the real strace.</p>\n<!-- MS_ID: build-strace-m1 -->\n<h1 id=\"milestone-1-basic-ptrace-syscall-intercept\">Milestone 1: Basic ptrace Syscall Intercept</h1>\n<h2 id=\"where-you-are-in-the-system\">Where You Are in the System</h2>\n<p>Before writing a single line of code, orient yourself. Your strace clone has one job at its core: sit between a running process and the kernel, observe every syscall that crosses that boundary, and report what it sees. This milestone builds that core â€” the bare minimum tracer that intercepts syscalls and prints their numbers and return values.\nBy the end of this milestone you&#39;ll have a working tracer that can attach to any program, stop it at every syscall boundary, and print output like:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>syscall(12) = 94367748206592\nsyscall(21) = 0\nsyscall(9) = 94367748206592\nsyscall(1) = -1 EBADF</code></pre></div>\n<p>Not pretty yet â€” that&#39;s Milestone 2. But correct. And correctness here is harder than it looks, because ptrace has a behavior that trips up almost everyone the first time.</p>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-satellite-map.svg\" alt=\"System Call Tracer â€” Satellite Architecture Map\"></p>\n<hr>\n<h2 id=\"the-core-revelation-ptrace-stops-twice\">The Core Revelation: ptrace Stops Twice</h2>\n<p>Here&#39;s the assumption that will break your first implementation:</p>\n<blockquote>\n<p><em>You call PTRACE_SYSCALL, the child runs the syscall, stops, and you read the result.</em>\nThis feels right. It mirrors how you think about function interception: intercept the call, get the result. One stop, one event.\n<strong>It&#39;s wrong.</strong> ptrace stops the tracee <em>twice</em> per syscall â€” once at syscall entry (before the kernel executes anything) and once at syscall exit (after the kernel has completed the call and written the return value). Both stops look identical to <code>waitpid</code>. Neither stop says &quot;I&#39;m the entry stop&quot; or &quot;I&#39;m the exit stop.&quot; Your tracer receives a SIGTRAP both times and must maintain its own toggle flag to know which one it&#39;s seeing.\nThis isn&#39;t a quirk or an implementation detail. It&#39;s fundamental to ptrace&#39;s design â€” and it&#39;s the source of more bugs in ptrace-based tools than anything else.\nWhy does this matter practically? On entry, the return value register (<code>rax</code>) contains <strong>garbage</strong> â€” specifically, the return value from the <em>previous</em> syscall. On exit, the argument registers still contain the call&#39;s arguments, but they may have been modified by the kernel. If you try to read the syscall number on exit, you can â€” <code>orig_rax</code> preserves it â€” but if you try to read <code>rax</code> on entry thinking it&#39;s the return value, you&#39;ll get stale data and produce completely wrong output.\nThe double-stop model is also what makes syscall <em>injection</em> possible: between entry and exit, the kernel is executing your syscall. If you wake up at entry and modify the registers before continuing, you can change which syscall runs or what arguments it receives. If you wake up at exit and modify <code>rax</code>, you can lie about what the syscall returned. This is how <code>strace -e inject=</code> works, and how seccomp-based sandboxes intercept and redirect syscalls. You&#39;re building the foundation for all of that right now.</p>\n</blockquote>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m1-entry-exit-toggle.svg\" alt=\"Syscall Entry/Exit Toggle State Machine\"></p>\n<hr>\n<h2 id=\"the-ptrace-lifecycle\">The ptrace Lifecycle</h2>\n<p>Before the toggle flag makes sense, you need to understand the full sequence from process creation to your first intercepted syscall. Let&#39;s walk through it.</p>\n<h3 id=\"step-1-fork-and-traceme\">Step 1: Fork and TRACEME</h3>\n<p>Your tracer starts with <code>fork()</code>. The child process needs to tell the kernel &quot;I want to be traced.&quot; It does this with <code>ptrace(PTRACE_TRACEME, 0, NULL, NULL)</code>.\n<code>PTRACE_TRACEME</code> is the only ptrace request that&#39;s made by the <em>tracee</em> (the process being traced) rather than the <em>tracer</em>. It tells the kernel: &quot;Whenever I make a syscall, deliver a SIGTRAP to pause me and wake up my parent.&quot; You call it in the child, before <code>exec()</code>.\nAfter <code>PTRACE_TRACEME</code>, the child calls <code>exec()</code> to become the target program. Here&#39;s a subtlety: after a successful <code>exec()</code> in a traced process, the kernel automatically delivers <strong>SIGTRAP</strong> to the tracee. This is a one-time stop that happens right at the start of the new program&#39;s execution, before any instructions run. Your parent must handle this initial stop â€” it&#39;s not a syscall stop, it&#39;s the post-exec notification.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/ptrace.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/types.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/wait.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#F97583\">[]</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (argc </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Usage: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> &#x3C;program> [args...]</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fork</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (child </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Child: request tracing, then become the target program */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_TRACEME, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        execvp</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* If execvp returns, something went wrong */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"execvp\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Parent: wait for the initial SIGTRAP from exec */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    waitpid</span><span style=\"color:#E1E4E8\">(child, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* status now indicates the post-exec SIGTRAP stop */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ... tracing loop goes here ... */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Notice the call sequence in the child: <code>PTRACE_TRACEME</code> first, then <code>execvp</code>. Order matters. If you reverse them, the new program won&#39;t be traced because the tracing flag wasn&#39;t set when <code>exec</code> ran.</p>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m1-ptrace-lifecycle.svg\" alt=\"ptrace Tracing Lifecycle: Fork â†’ TRACEME â†’ Exec â†’ SYSCALL Loop\"></p>\n<h3 id=\"step-2-the-ptrace_syscall-waitpid-loop\">Step 2: The PTRACE_SYSCALL + waitpid Loop</h3>\n<p>Once you&#39;ve caught the initial stop, the tracing loop begins. It follows a simple rhythm:</p>\n<ol>\n<li>Call <code>ptrace(PTRACE_SYSCALL, child, NULL, NULL)</code> â€” this tells the kernel &quot;resume the tracee, but stop it at the next syscall boundary.&quot;</li>\n<li>Call <code>waitpid(child, &amp;status, 0)</code> â€” block until something happens to the tracee.</li>\n<li>Check <code>status</code> to figure out what happened.</li>\n<li>If it&#39;s a syscall stop: inspect registers, print output, go to step 1.</li>\n<li>If it&#39;s a signal stop: re-inject the signal, go to step 1.</li>\n<li>If the process exited: clean up and exit the tracer.\nThe <code>PTRACE_SYSCALL</code> request is key. It means &quot;stop at the next syscall entry OR exit.&quot; The kernel doesn&#39;t distinguish between them for you â€” you get one stop notification for each boundary. Your toggle flag tracks which boundary you&#39;re at.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">    /* Start the tracing loop */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Toggle: 0 = not in syscall (entry), 1 = in syscall (exit) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Resume tracee, stop at next syscall boundary */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Wait for the next stop */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        waitpid</span><span style=\"color:#E1E4E8\">(child, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Check what happened */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFEXITED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Process exited with status </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">WEXITSTATUS</span><span style=\"color:#E1E4E8\">(status));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFSIGNALED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Process killed by signal </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">WTERMSIG</span><span style=\"color:#E1E4E8\">(status));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFSTOPPED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Handle the stop */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* ... */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span></code></pre></div>\n<h2 id=\"let39s-unpack-those-waitpid-status-macros-they39re-not-optional-knowledge-they39re-your-primary-tool-for-understanding-what-happened-to-the-tracee\">Let&#39;s unpack those <code>waitpid</code> status macros â€” they&#39;re not optional knowledge, they&#39;re your primary tool for understanding what happened to the tracee.</h2>\n<h2 id=\"understanding-waitpid-status\">Understanding waitpid Status</h2>\n<p><code>waitpid()</code> returns a 32-bit integer called the <em>wait status</em>. This integer is not a simple exit code â€” it encodes several different kinds of events in a bit-packed format, and you decode it with a set of macros.\n{{DIAGRAM:diag-m1-waitpid-status-decode}}\nHere&#39;s what each macro checks and returns:\n<strong><code>WIFEXITED(status)</code></strong> â€” Returns true if the child terminated normally by calling <code>exit()</code> or returning from <code>main()</code>. When true, <code>WEXITSTATUS(status)</code> extracts the exit code (the argument passed to <code>exit()</code>).\n<strong><code>WIFSIGNALED(status)</code></strong> â€” Returns true if the child was killed by a signal (like <code>SIGKILL</code> or <code>SIGSEGV</code>). When true, <code>WTERMSIG(status)</code> extracts the signal number that killed it.\n<strong><code>WIFSTOPPED(status)</code></strong> â€” Returns true if the child was <em>stopped</em> (paused) rather than terminated. This is the case for both syscall stops and signal delivery stops in a ptrace-traced process. When true, <code>WSTOPSIG(status)</code> extracts the signal number that caused the stop. For syscall stops, this will be <code>SIGTRAP</code> (signal 5).\n<strong><code>WIFCONTINUED(status)</code></strong> â€” Returns true if a stopped child was resumed with <code>SIGCONT</code>. You won&#39;t need this for basic tracing.\nFor your tracer, the most important distinction is between:</p>\n<ul>\n<li><code>WIFEXITED</code> / <code>WIFSIGNALED</code> â†’ the tracee is gone, stop tracing</li>\n<li><code>WIFSTOPPED</code> â†’ the tracee is paused, inspect it and decide what to do</li>\n</ul>\n<hr>\n<h2 id=\"x86_64-syscall-register-conventions\">x86_64 Syscall Register Conventions</h2>\n<p>Now you need to know <em>what</em> to read when the tracee stops. Syscalls on x86_64 follow a strict register convention baked into the Linux ABI (Application Binary Interface â€” the contract between userspace and kernel that specifies exactly which registers carry which values).\nWhen a program executes the <code>syscall</code> instruction on x86_64:</p>\n<ul>\n<li><strong><code>rax</code></strong> â€” holds the syscall number before the call</li>\n<li><strong><code>rdi</code></strong> â€” holds argument 1</li>\n<li><strong><code>rsi</code></strong> â€” holds argument 2</li>\n<li><strong><code>rdx</code></strong> â€” holds argument 3</li>\n<li><strong><code>r10</code></strong> â€” holds argument 4 (note: this is <code>r10</code>, not <code>rcx</code> as in the normal calling convention â€” the <code>syscall</code> instruction uses <code>rcx</code> internally to save the return address)</li>\n<li><strong><code>r8</code></strong> â€” holds argument 5</li>\n<li><strong><code>r9</code></strong> â€” holds argument 6\nAfter the kernel completes the syscall, <strong><code>rax</code></strong> holds the return value.\nHere&#39;s the critical problem: the kernel may use <code>rax</code> for its own purposes during dispatch. If you read <code>rax</code> on entry, you&#39;ll get the syscall number â€” but the kernel might overwrite <code>rax</code> before giving you control on exit, destroying it. So the kernel saves the original <code>rax</code> value into a special field called <code>orig_rax</code> <em>before</em> doing anything else.\nThis means:</li>\n<li><strong>On entry</strong>: Read <code>orig_rax</code> for the syscall number. (Reading <code>rax</code> on entry gives the syscall number too, but <code>orig_rax</code> is the authoritative source.)</li>\n<li><strong>On exit</strong>: Read <code>rax</code> for the return value. Read <code>orig_rax</code> if you need the syscall number again.\nTo read these registers, you use <code>ptrace(PTRACE_GETREGS, pid, NULL, &amp;regs)</code> where <code>regs</code> is a <code>struct user_regs_struct</code> defined in <code>&lt;sys/user.h&gt;</code>.</li>\n</ul>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m1-x86-registers.svg\" alt=\"x86_64 Syscall Register Convention â€” struct user_regs_struct Layout\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/user.h></span><span style=\"color:#6A737D\">  /* struct user_regs_struct */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> user_regs_struct regs;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_GETREGS, child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* On syscall entry: */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\"> syscall_number </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> regs.orig_rax;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* On syscall exit: */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\"> return_value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> regs.rax;</span></span></code></pre></div>\n<p>The <code>struct user_regs_struct</code> contains fields for all general-purpose registers. The ones you&#39;ll use most in this milestone:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> user_regs_struct {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ... many fields ... */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> orig_rax;</span><span style=\"color:#6A737D\">  /* Saved rax (syscall number) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> rax;</span><span style=\"color:#6A737D\">       /* Return value (on exit) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> rdi;</span><span style=\"color:#6A737D\">       /* Argument 1 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> rsi;</span><span style=\"color:#6A737D\">       /* Argument 2 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> rdx;</span><span style=\"color:#6A737D\">       /* Argument 3 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> r10;</span><span style=\"color:#6A737D\">       /* Argument 4 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> r8;</span><span style=\"color:#6A737D\">        /* Argument 5 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> r9;</span><span style=\"color:#6A737D\">        /* Argument 6 */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ... more fields ... */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n<hr>\n<h2 id=\"three-level-view-what-happens-during-a-syscall\">Three-Level View: What Happens During a Syscall</h2>\n<p>Understanding the entry/exit stops requires seeing what happens at all three levels.</p>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m1-three-level-view.svg\" alt=\"Three-Level View: Application â†’ Kernel â†’ Hardware for a Syscall\"></p>\n<p><strong>Level 1 â€” Application (Tracee)</strong>\nThe program calls <code>write(1, &quot;hello&quot;, 5)</code>. The compiler has already translated this into: load 1 into <code>rdi</code>, load the string pointer into <code>rsi</code>, load 5 into <code>rdx</code>, load 1 (the syscall number for <code>write</code>) into <code>rax</code>, execute the <code>syscall</code> instruction.\n<strong>Level 2 â€” Kernel</strong>\nWhen <code>syscall</code> executes:</p>\n<ol>\n<li>The CPU switches to ring 0 (kernel mode) and jumps to the syscall entry point (<code>entry_SYSCALL_64</code>).</li>\n<li>The kernel checks if this process is being traced (the <code>PT_TRACED</code> flag is set on the task).</li>\n<li>If traced: before doing anything else, save <code>rax</code> to <code>orig_rax</code>, then signal the tracer with SIGTRAP. The tracee is now paused. This is the <strong>entry stop</strong>.</li>\n<li>The tracer wakes up, inspects registers, then calls <code>PTRACE_SYSCALL</code> to resume.</li>\n<li>The kernel executes the actual syscall (calls <code>sys_write</code>).</li>\n<li>The return value is placed in <code>rax</code>.</li>\n<li>The kernel signals the tracer again with SIGTRAP. The tracee is paused again. This is the <strong>exit stop</strong>.</li>\n<li>The tracer wakes up, reads the return value from <code>rax</code>, then calls <code>PTRACE_SYSCALL</code> to resume.</li>\n<li>The <code>syscall</code> instruction completes in userspace. Execution continues.\n<strong>Level 3 â€” Hardware</strong>\nThe <code>syscall</code> instruction does specific things at the hardware level:</li>\n</ol>\n<ul>\n<li>Saves the return address (next instruction&#39;s <code>RIP</code>) into <code>RCX</code>.</li>\n<li>Saves <code>RFLAGS</code> into <code>R11</code>.</li>\n<li>Loads the kernel&#39;s code segment (<code>CS</code>) and stack pointer.</li>\n<li>Jumps to the address stored in <code>IA32_LSTAR</code> MSR (Model-Specific Register) â€” the kernel entry point.\nThis is why <code>rcx</code> and <code>r11</code> are clobbered by the <code>syscall</code> instruction: they&#39;re used by the hardware to save state. The kernel calling convention for syscalls explicitly uses <code>r10</code> instead of <code>rcx</code> for argument 4 to avoid this conflict.\nThe <code>orig_rax</code> field exists because of step 3 above â€” the kernel overwrites <code>rax</code> during its own internal dispatch, so it first saves the original value.</li>\n</ul>\n<hr>\n<h2 id=\"the-toggle-flag-in-practice\">The Toggle Flag in Practice</h2>\n<p>Now you have everything to implement the full entry/exit logic:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/ptrace.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/types.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/wait.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/user.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#F97583\">[]</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (argc </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Usage: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> &#x3C;program> [args...]</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fork</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (child </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Child: enable tracing and exec the target */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_TRACEME, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        execvp</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"execvp\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Parent: catch the post-exec SIGTRAP */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    waitpid</span><span style=\"color:#E1E4E8\">(child, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">WIFSTOPPED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Unexpected initial status</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* The tracing loop */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Toggle: 0 = next stop is entry, 1 = next stop is exit */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Resume tracee, asking kernel to stop at next syscall boundary */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ptrace PTRACE_SYSCALL\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Block until the tracee stops again */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        waitpid</span><span style=\"color:#E1E4E8\">(child, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Tracee has exited â€” stop tracing */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFEXITED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"+++ exited with </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> +++</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">WEXITSTATUS</span><span style=\"color:#E1E4E8\">(status));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Tracee was killed by a signal â€” stop tracing */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFSIGNALED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"+++ killed by signal </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> +++</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">WTERMSIG</span><span style=\"color:#E1E4E8\">(status));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Tracee has stopped â€” inspect why */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFSTOPPED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            int</span><span style=\"color:#E1E4E8\"> sig </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> WSTOPSIG</span><span style=\"color:#E1E4E8\">(status);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (sig </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SIGTRAP) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* This is a syscall stop (or the initial post-exec stop) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                struct</span><span style=\"color:#E1E4E8\"> user_regs_struct regs;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_GETREGS, child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">regs);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">in_syscall) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    /* Entry: syscall is about to execute */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    /* Just record that we're entering; we'll print on exit */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    /* Exit: syscall has completed */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    long</span><span style=\"color:#E1E4E8\"> syscall_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)regs.orig_rax;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    long</span><span style=\"color:#E1E4E8\"> return_val  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)regs.rax;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    /* Detect error returns */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> (return_val </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> return_val </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        int</span><span style=\"color:#E1E4E8\"> err_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">return_val);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"syscall(</span><span style=\"color:#79B8FF\">%ld</span><span style=\"color:#9ECBFF\">) = -1 </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                               syscall_num, </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(err_num));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"syscall(</span><span style=\"color:#79B8FF\">%ld</span><span style=\"color:#9ECBFF\">) = </span><span style=\"color:#79B8FF\">%ld\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                               syscall_num, return_val);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* Signal-delivery stop: a real signal for the tracee */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* Re-inject it â€” do NOT pass 0 or you'll swallow the signal */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)sig);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Skip the PTRACE_SYSCALL at top of loop */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"read-through-this-carefully-notice-the-subtle-continuation-in-the-signal-delivery-case-when-you-handle-a-signal-stop-you-call-ptrace_syscall-with-the-signal-number-immediately-in-the-handler-and-continue-to-skip-the-ptrace_syscall-at-the-top-of-the-loop-otherwise-you39d-call-it-twice-and-lose-an-event\">Read through this carefully. Notice the subtle continuation in the signal-delivery case: when you handle a signal stop, you call <code>PTRACE_SYSCALL</code> with the signal number immediately in the handler and <code>continue</code> to skip the <code>PTRACE_SYSCALL</code> at the top of the loop â€” otherwise you&#39;d call it twice and lose an event.</h2>\n<h2 id=\"signal-stops-vs-syscall-stops\">Signal Stops vs Syscall Stops</h2>\n<p>The code above has a subtle problem. We&#39;re distinguishing signal-delivery stops from syscall stops by checking if the stop signal is <code>SIGTRAP</code>. But <code>SIGTRAP</code> <em>is</em> the signal for both types of stops. How do you actually tell them apart?</p>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m1-signal-vs-syscall-stop.svg\" alt=\"Signal-Delivery Stop vs Syscall Stop â€” Decision Tree\"></p>\n<p>There are two approaches:</p>\n<h3 id=\"approach-1-ptrace_o_tracesysgood-recommended\">Approach 1: PTRACE_O_TRACESYSGOOD (Recommended)</h3>\n<p>If you set the option <code>PTRACE_O_TRACESYSGOOD</code> on the tracee, the kernel will set bit 7 of the stop signal number for syscall stops. That is, instead of delivering <code>SIGTRAP</code> (signal 5) for syscall stops, it delivers <code>SIGTRAP | 0x80</code> = <code>0x85</code>. Signal-delivery stops still use plain <code>SIGTRAP</code> (5).\nYou set options with:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SETOPTIONS, child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, PTRACE_O_TRACESYSGOOD);</span></span></code></pre></div>\n<p>Call this right after the initial <code>waitpid</code> that catches the post-exec stop.\nThen your stop handling becomes:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFSTOPPED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> sig </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> WSTOPSIG</span><span style=\"color:#E1E4E8\">(status);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (sig </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (SIGTRAP </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Syscall stop â€” handle entry/exit toggle */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* sig &#x26; 0x7F == SIGTRAP, bit 7 is the TRACESYSGOOD indicator */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* ... */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (sig </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SIGTRAP) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Plain SIGTRAP â€” could be post-exec stop, breakpoint, or other ptrace event */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* For now, just resume */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Genuine signal delivery stop â€” re-inject the signal */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)sig);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"approach-2-check-orig_rax\">Approach 2: Check orig_rax</h3>\n<p>Another approach: on every SIGTRAP stop, call <code>PTRACE_GETREGS</code> and check <code>orig_rax</code>. If <code>orig_rax</code> is a valid syscall number (0 through ~450 on Linux), it&#39;s likely a syscall stop. But this is fragile â€” <code>orig_rax</code> can contain valid-looking values in edge cases.\n<strong>Use <code>PTRACE_O_TRACESYSGOOD</code>.</strong> It&#39;s the correct approach, used by real strace. The bit-7 trick was invented precisely to solve this disambiguation problem.\nHere&#39;s the updated initialization:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">    /* Catch post-exec stop */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    waitpid</span><span style=\"color:#E1E4E8\">(child, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">status</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Set options: use TRACESYSGOOD to mark syscall stops */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SETOPTIONS, child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, PTRACE_O_TRACESYSGOOD);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Now enter the tracing loop */</span></span></code></pre></div>\n<hr>\n<h2 id=\"error-detection-on-x86_64\">Error Detection on x86_64</h2>\n<p>When a syscall fails, the kernel doesn&#39;t return a positive number and set <code>errno</code>. Instead, it returns a negative number in the range <code>[-4096, -1]</code>. The C library wrapper (in glibc) detects this range, negates the value, stores it in <code>errno</code>, and returns <code>-1</code> to your program.\nFor example, if you call <code>open(&quot;nonexistent&quot;, O_RDONLY)</code>, the kernel returns <code>-2</code> (which is <code>-ENOENT</code>). glibc sees <code>-2</code>, sets <code>errno = 2</code> (ENOENT), and returns <code>-1</code>.\nIn your tracer, you see the <em>raw kernel return value</em> â€” not the glibc-processed one. So you need to do the same detection:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* On x86_64, kernel error returns are in the range [-4096, -1] */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* This range covers all possible errno values (the largest is ~4095) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\"> return_val </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)regs.rax;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (return_val </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#F97583\">L</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> return_val </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">L</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Error return */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> err_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">return_val);</span><span style=\"color:#6A737D\">  /* Negate to get the errno value */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"syscall(</span><span style=\"color:#79B8FF\">%ld</span><span style=\"color:#9ECBFF\">) = -1 </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, syscall_num, </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(err_num));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Success return */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"syscall(</span><span style=\"color:#79B8FF\">%ld</span><span style=\"color:#9ECBFF\">) = </span><span style=\"color:#79B8FF\">%ld\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, syscall_num, return_val);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Why the range <code>[-4096, -1]</code>? The Linux kernel reserves 4096 values for error codes. The actual defined errno values top out around 133 (<code>EHWPOISON</code>), but the kernel reserves the full 4096 range to be safe for future additions.</p>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m1-error-detection.svg\" alt=\"x86_64 Syscall Return Value Error Detection\"></p>\n<h2 id=\"the-cast-longregsrax-matters-regsrax-is-unsigned-long-long-if-a-syscall-returns-2-the-bit-pattern-in-rax-is-0xfffffffffffffffe-which-as-an-unsigned-64-bit-integer-is-a-very-large-positive-number-by-casting-to-long-signed-you-restore-the-correct-negative-interpretation-always-cast-rax-to-long-before-comparing\">The cast <code>(long)regs.rax</code> matters. <code>regs.rax</code> is <code>unsigned long long</code>. If a syscall returns <code>-2</code>, the bit pattern in <code>rax</code> is <code>0xFFFFFFFFFFFFFFFE</code> â€” which as an unsigned 64-bit integer is a very large positive number. By casting to <code>long</code> (signed), you restore the correct negative interpretation. Always cast <code>rax</code> to <code>long</code> before comparing.</h2>\n<h2 id=\"putting-it-together-complete-working-tracer\">Putting It Together: Complete Working Tracer</h2>\n<p>Here is the complete, correct implementation for Milestone 1. Every concept from this chapter is present:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/ptrace.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/types.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/wait.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/user.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;signal.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#F97583\">[]</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (argc </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Usage: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> &#x3C;program> [args...]</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fork</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (child </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"fork\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (child </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * CHILD PROCESS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * 1. Tell the kernel we want to be traced.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * 2. exec the target program.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * After exec succeeds, the kernel delivers SIGTRAP and pauses us.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_TRACEME, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ptrace TRACEME\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        execvp</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* execvp only returns on error */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"execvp\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * PARENT (TRACER) PROCESS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 1: Catch the initial SIGTRAP delivered after exec */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">waitpid</span><span style=\"color:#E1E4E8\">(child, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"waitpid (initial)\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">WIFSTOPPED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Unexpected: child did not stop after exec</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Step 2: Set TRACESYSGOOD so syscall stops set bit 7 of the signal */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SETOPTIONS, child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)PTRACE_O_TRACESYSGOOD) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ptrace SETOPTIONS\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Step 3: The tracing loop.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Toggle state:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *   in_syscall == 0: next syscall stop will be an ENTRY stop</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *   in_syscall == 1: next syscall stop will be an EXIT stop</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (;;) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Resume tracee; stop at next syscall entry or exit */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Tracee may have exited between our waitpid and this call */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ESRCH) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ptrace PTRACE_SYSCALL\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Block until the tracee changes state */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pid_t</span><span style=\"color:#E1E4E8\"> stopped </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> waitpid</span><span style=\"color:#E1E4E8\">(child, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (stopped </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"waitpid\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* The tracee exited normally */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFEXITED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"+++ exited with </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> +++</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">WEXITSTATUS</span><span style=\"color:#E1E4E8\">(status));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* The tracee was killed by a signal */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFSIGNALED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"+++ killed by signal </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">) +++</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                   WTERMSIG</span><span style=\"color:#E1E4E8\">(status), </span><span style=\"color:#B392F0\">strsignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">WTERMSIG</span><span style=\"color:#E1E4E8\">(status)));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* The tracee stopped */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFSTOPPED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            int</span><span style=\"color:#E1E4E8\"> sig </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> WSTOPSIG</span><span style=\"color:#E1E4E8\">(status);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (sig </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (SIGTRAP </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                 * SYSCALL STOP (entry or exit, distinguished by toggle)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                 * Bit 7 is set because we used PTRACE_O_TRACESYSGOOD.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                struct</span><span style=\"color:#E1E4E8\"> user_regs_struct regs;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_GETREGS, child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">regs) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ptrace GETREGS\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (in_syscall </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                     * ENTRY STOP</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                     * The syscall is about to execute. orig_rax has the</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                     * syscall number. We note it and flip the toggle.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                     * (We don't print yet â€” we print on exit when we have</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                     * both the syscall number AND the return value.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    /* Syscall number: regs.orig_rax â€” saved for exit print */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                     * EXIT STOP</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                     * The syscall has completed. rax has the return value.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                     * orig_rax still has the syscall number.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    long</span><span style=\"color:#E1E4E8\"> syscall_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)regs.orig_rax;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    long</span><span style=\"color:#E1E4E8\"> return_val  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)regs.rax;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> (return_val </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#F97583\">L</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> return_val </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">L</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        int</span><span style=\"color:#E1E4E8\"> err_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">return_val);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"syscall(</span><span style=\"color:#79B8FF\">%ld</span><span style=\"color:#9ECBFF\">) = -1 </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                               syscall_num, </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(err_num));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"syscall(</span><span style=\"color:#79B8FF\">%ld</span><span style=\"color:#9ECBFF\">) = </span><span style=\"color:#79B8FF\">%ld\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                               syscall_num, return_val);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (sig </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SIGTRAP) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                 * Plain SIGTRAP without bit 7 â€” this is the post-exec stop</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                 * or some other ptrace event. Just resume with no signal.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                 * (The toggle stays at 0; we haven't entered a syscall.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                 */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                 * SIGNAL-DELIVERY STOP</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                 * A real signal (SIGTERM, SIGPIPE, SIGHUP, etc.) was</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                 * delivered to the tracee. We must re-inject it by passing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                 * the signal number as the 4th argument to PTRACE_SYSCALL.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                 * Passing 0 would suppress the signal, which would break</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                 * the traced program's signal-handling logic.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                           (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)sig) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ESRCH) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ptrace PTRACE_SYSCALL (signal re-inject)\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* Note: we re-injected via PTRACE_SYSCALL above; skip the</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                 * PTRACE_SYSCALL call at the top of the loop. */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"building-and-testing\">Building and Testing</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">makefile</span><pre class=\"arch-pre shiki-highlighted\"><code># Makefile\nCC = gcc\nCFLAGS = -Wall -Wextra -g\nstrace_clone: strace_clone.c\n\t$(CC) $(CFLAGS) -o strace_clone strace_clone.c\nclean:\n\trm -f strace_clone</code></pre></div>\n<p>Test it:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">make</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./strace_clone</span><span style=\"color:#9ECBFF\"> /bin/ls</span><span style=\"color:#9ECBFF\"> /tmp</span></span></code></pre></div>\n<h2 id=\"you-should-see-a-stream-of-syscalln-m-lines-followed-by-exited-with-0-the-syscall-numbers-will-be-x86_64-numbers-59-is-execve-12-is-brk-9-is-mmap-you39ll-decode-these-in-milestone-2\">You should see a stream of <code>syscall(N) = M</code> lines, followed by <code>+++ exited with 0 +++</code>. The syscall numbers will be x86_64 numbers â€” <code>59</code> is <code>execve</code>, <code>12</code> is <code>brk</code>, <code>9</code> is <code>mmap</code>. You&#39;ll decode these in Milestone 2.</h2>\n<h2 id=\"common-bugs-and-how-to-avoid-them\">Common Bugs and How to Avoid Them</h2>\n<h3 id=\"bug-1-reading-rax-on-entry\">Bug 1: Reading rax on Entry</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG: rax on entry is garbage (previous syscall's return value) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">in_syscall) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\"> return_val </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)regs.rax;</span><span style=\"color:#6A737D\">  /* â† This is wrong! */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"syscall(</span><span style=\"color:#79B8FF\">%ld</span><span style=\"color:#9ECBFF\">) = </span><span style=\"color:#79B8FF\">%ld\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, regs.orig_rax, return_val);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>The fix is to not print the return value on entry. Print on exit when <code>rax</code> is valid.</p>\n<h3 id=\"bug-2-not-re-injecting-signals\">Bug 2: Not Re-Injecting Signals</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG: passing 0 suppresses the signal */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  /* suppresses the signal! */</span></span></code></pre></div>\n<p>If a program receives <code>SIGPIPE</code> (write to a closed pipe) and you suppress it by passing 0, the program won&#39;t get the signal. It will continue writing to a closed pipe and produce corrupt behavior. Always re-inject real signals.</p>\n<h3 id=\"bug-3-forgetting-the-toggle\">Bug 3: Forgetting the Toggle</h3>\n<p>If your toggle flag is wrong â€” say, you initialize it to 1 instead of 0, or you increment instead of toggling â€” you&#39;ll be one stop off on every syscall. Entry reads will look like exits and vice versa. The output will look plausible but be completely wrong. The numbers will be garbage. Initialize <code>in_syscall = 0</code> and toggle it cleanly.</p>\n<h3 id=\"bug-4-missing-ptrace_traceme-before-exec\">Bug 4: Missing PTRACE_TRACEME Before exec</h3>\n<h2 id=\"if-the-child-calls-exec-before-ptrace_traceme-the-new-program-is-not-traced-the-parent39s-waitpid-will-block-forever-or-until-the-child-exits-always-ptrace_traceme-first\">If the child calls <code>exec</code> before <code>PTRACE_TRACEME</code>, the new program is not traced. The parent&#39;s <code>waitpid</code> will block forever (or until the child exits). Always <code>PTRACE_TRACEME</code> first.</h2>\n<h2 id=\"hardware-soul-what-the-cpu-does\">Hardware Soul: What the CPU Does</h2>\n<h2 id=\"when-your-tracer-intercepts-a-syscall-what39s-happening-in-the-hardware-cache-behavior-the-syscall-instruction-causes-a-cpu-privilege-level-transition-the-kernel-entry-code-lives-in-a-different-cache-region-than-userspace-this-is-an-l1-instruction-cache-miss-cold-path-on-the-first-syscall-of-a-program-then-typically-hot-for-subsequent-calls-the-struct-user_regs_struct-you-read-with-ptrace_getregs-is-a-216-byte-structure-it-fits-in-approximately-4-cache-lines-64-bytes-each-each-ptrace_getregs-call-copies-this-structure-across-process-boundaries-touching-4-cache-lines-tlb-behavior-the-waitpid-call-that-blocks-your-tracer-is-a-full-context-switch-the-cpu-flushes-tlb-entries-on-context-switch-or-invalidates-them-on-architectures-with-asid-support-when-your-tracer-resumes-to-inspect-registers-the-kernel-maps-the-tracee39s-register-state-into-your-address-space-no-tlb-miss-for-the-register-copy-but-your-tracer39s-own-tlb-state-must-be-reconstructed-branch-prediction-the-wifstoppedwifexitedwifsignaled-macros-are-simple-bit-operations-they39re-essentially-free-the-branch-predictor-will-correctly-predict-quotalmost-always-wifstoppedquot-after-the-first-few-iterations-syscall-overhead-each-ptraceptrace_syscall-is-itself-a-syscall-each-waitpid-is-a-syscall-so-intercepting-one-syscall-in-the-tracee-costs-two-syscalls-in-the-tracer-plus-the-context-switch-overhead-and-cache-effects-this-is-why-ptrace-based-tracing-has-significant-overhead-strace-can-slow-a-program-by-2-10x-depending-on-syscall-frequency\"><em>When your tracer intercepts a syscall, what&#39;s happening in the hardware?</em>\n<strong>Cache behavior</strong>: The <code>syscall</code> instruction causes a CPU privilege level transition. The kernel entry code lives in a different cache region than userspace. This is an L1 instruction cache miss (cold path) on the first syscall of a program, then typically hot for subsequent calls. The <code>struct user_regs_struct</code> you read with <code>PTRACE_GETREGS</code> is a 216-byte structure â€” it fits in approximately 4 cache lines (64 bytes each). Each <code>PTRACE_GETREGS</code> call copies this structure across process boundaries, touching 4 cache lines.\n<strong>TLB behavior</strong>: The <code>waitpid</code> call that blocks your tracer is a full context switch. The CPU flushes TLB entries on context switch (or invalidates them on architectures with ASID support). When your tracer resumes to inspect registers, the kernel maps the tracee&#39;s register state into your address space â€” no TLB miss for the register copy, but your tracer&#39;s own TLB state must be reconstructed.\n<strong>Branch prediction</strong>: The <code>WIFSTOPPED</code>/<code>WIFEXITED</code>/<code>WIFSIGNALED</code> macros are simple bit operations. They&#39;re essentially free. The branch predictor will correctly predict &quot;almost always WIFSTOPPED&quot; after the first few iterations.\n<strong>Syscall overhead</strong>: Each <code>ptrace(PTRACE_SYSCALL, ...)</code> is itself a syscall. Each <code>waitpid</code> is a syscall. So intercepting <em>one</em> syscall in the tracee costs <em>two</em> syscalls in the tracer (plus the context switch overhead and cache effects). This is why ptrace-based tracing has significant overhead â€” strace can slow a program by 2-10x depending on syscall frequency.</h2>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<p>You&#39;ve just implemented the core mechanism of one of Linux&#39;s most powerful diagnostic tools. That toggle flag and SIGTRAP stop aren&#39;t isolated ideas â€” they connect to a wide web of systems knowledge.</p>\n<h3 id=\"1-gdb-uses-the-same-mechanism-just-with-ptrace_singlestep\">1. GDB Uses the Same Mechanism (Just With PTRACE_SINGLESTEP)</h3>\n<p>GDB&#39;s breakpoints work by inserting an <code>INT 3</code> instruction (opcode <code>0xCC</code>) at a target address, which generates a SIGTRAP when executed. But GDB also uses <code>PTRACE_SINGLESTEP</code> to step one instruction at a time â€” this is the same double-stop model. When GDB says &quot;hit breakpoint, stopped at line 42,&quot; it has just received a SIGTRAP via <code>waitpid</code>, read the register state, and displayed it to you. The mechanism you built today is the foundation of every debugger on Linux.\n<strong>The connection to your toggle</strong>: When you understand entry/exit stops, you understand why GDB can modify syscall arguments <em>in flight</em> â€” it wakes up at entry, modifies registers before resuming, and the kernel executes the modified syscall. Fault injection (breaking programs deliberately to test error handling) is built on exactly this mechanism.</p>\n<h3 id=\"2-seccomp-bpf-filters-only-at-entry\">2. seccomp-BPF Filters Only at Entry</h3>\n<p>seccomp (Secure Computing Mode) is a Linux kernel feature that lets you install a BPF (Berkeley Packet Filter) program to filter syscalls. Here&#39;s the critical connection: <strong>seccomp filters run at syscall entry only, not exit</strong>. They can allow or deny a call, but they cannot inspect the return value. Now you know <em>why</em> â€” the entry/exit model means the filter runs at the first SIGTRAP (entry stop), before the kernel has executed the syscall. Return values don&#39;t exist yet. seccomp can block <code>open()</code> but can&#39;t block <code>open()</code> that returns a file descriptor pointing to a sensitive file â€” it has to make that decision based on arguments alone.\nContainer runtimes like runc use seccomp profiles to restrict what syscalls containers can make. When you run <code>docker run --security-opt seccomp=profile.json</code>, that profile is compiled into a BPF program loaded via <code>prctl(PR_SET_SECCOMP, ...)</code>. The ptrace entry stop is where this filter executes.</p>\n<h3 id=\"3-strace-e-inject-modifying-syscalls-in-flight\">3. strace -e inject: Modifying Syscalls In Flight</h3>\n<p>Real strace has a feature called <code>strace -e inject=open:retval=-1:error=ENOENT</code> that makes <code>open()</code> always fail with ENOENT. How does it work? On the entry stop, strace notes the syscall. On the exit stop, it modifies <code>rax</code> to <code>-2</code> (which is <code>-ENOENT</code>) using <code>PTRACE_SETREGS</code>. The program&#39;s glibc library sees <code>-2</code>, sets <code>errno = ENOENT</code>, and returns <code>-1</code> to the program. The actual <code>open()</code> ran and succeeded â€” strace lied about the result. This is fault injection: a technique for testing that programs handle errors correctly.\nYou now understand the two stops well enough to implement this yourself: read on entry, modify <code>rax</code> on exit.</p>\n<h3 id=\"4-the-x86_64-syscall-abi-vs-the-c-calling-convention\">4. The x86_64 syscall ABI vs. the C Calling Convention</h3>\n<p>You&#39;ve learned that syscalls use <code>rdi, rsi, rdx, r10, r8, r9</code> for arguments. The normal C function calling convention uses <code>rdi, rsi, rdx, rcx, r8, r9</code>. The difference is argument 4: <code>r10</code> for syscalls vs. <code>rcx</code> for function calls. This exists because the <code>syscall</code> instruction hardware-saves the return address in <code>RCX</code> â€” so <code>rcx</code> is clobbered by the mechanism itself. The ABI designers shifted argument 4 to <code>r10</code> to avoid the conflict. Now when you see <code>r10</code> in a Linux syscall table, you know exactly why.</p>\n<h3 id=\"5-the-performance-cost-of-observability\">5. The Performance Cost of Observability</h3>\n<p>Every syscall interception costs approximately:</p>\n<ul>\n<li>2 context switches (tracer â†’ tracee â†’ tracer)</li>\n<li>2 additional syscalls by the tracer (PTRACE_SYSCALL + waitpid)</li>\n<li>4 cache line reads (PTRACE_GETREGS for the register struct)</li>\n<li>~5,000-10,000 CPU cycles of overhead per intercepted syscall\nThis is why you don&#39;t use ptrace in production â€” it&#39;s too slow. Production observability tools (like <code>perf</code>, <code>eBPF</code> probes, or <code>ftrace</code>) use kernel-side hooks that avoid the full context switch. They sample in the kernel and only surface data to userspace periodically. What you&#39;re building is the <em>right tool</em> for debugging and learning, not for production profiling. Knowing this cost precisely is what lets you make the right tool choice.</li>\n</ul>\n<hr>\n<h2 id=\"summary-what-you39ve-built\">Summary: What You&#39;ve Built</h2>\n<p>Your tracer now:</p>\n<ul>\n<li>Forks a child, has it request tracing, and execs the target program</li>\n<li>Catches the post-exec SIGTRAP and configures <code>PTRACE_O_TRACESYSGOOD</code></li>\n<li>Runs a <code>PTRACE_SYSCALL + waitpid</code> loop indefinitely</li>\n<li>Toggles an <code>in_syscall</code> flag to distinguish entry from exit</li>\n<li>On exit: reads <code>orig_rax</code> for the syscall number and <code>rax</code> for the return value</li>\n<li>Detects error returns using the <code>[-4096, -1]</code> range and prints errno names</li>\n<li>Re-injects real signals to the tracee rather than suppressing them</li>\n<li>Detects <code>WIFEXITED</code> / <code>WIFSIGNALED</code> to stop the tracing loop cleanly\nThe output isn&#39;t human-readable yet â€” syscall numbers instead of names, raw integers instead of decoded arguments. Milestone 2 fixes that. But the machinery underneath â€” the toggle, the register reads, the signal handling â€” is complete and correct. Everything in the remaining milestones builds on exactly what you&#39;ve built here.</li>\n</ul>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-strace-m2 -->\n<!-- MS_ID: build-strace-m2 -->\n<h1 id=\"milestone-2-argument-decoding\">Milestone 2: Argument Decoding</h1>\n<h2 id=\"where-you-are-now\">Where You Are Now</h2>\n<p>Your Milestone 1 tracer produces output like this:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>syscall(59) = 0\nsyscall(12) = 94412374278144\nsyscall(21) = -1 ENOENT\nsyscall(9) = 94412374278144\nsyscall(1) = 5</code></pre></div>\n<p>This is <em>correct</em>. The toggle works. The error detection is right. The signal handling is right. But it&#39;s completely unreadable to a human being. Syscall 59 is <code>execve</code>. Syscall 12 is <code>brk</code>. Syscall 21 is <code>access</code>. Without names, you have numbers. Without arguments, you have calls in a vacuum.\nReal strace shows you this instead:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>execve(&quot;/bin/ls&quot;, [&quot;/bin/ls&quot;, &quot;/tmp&quot;], 0x7ffd3b2a8120 /* 23 vars */) = 0\nbrk(NULL) = 0x55f1a3c06000\naccess(&quot;/etc/ld.so.preload&quot;, R_OK) = -1 ENOENT (No such file or directory)\nmmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f...\nwrite(1, &quot;file1.txt  file2.txt\\n&quot;, 21)  = 21</code></pre></div>\n<h2 id=\"this-milestone-builds-everything-that-transforms-the-first-form-into-the-second-you39ll-build-a-syscall-name-table-extract-arguments-from-the-six-x86_64-argument-registers-read-string-arguments-word-by-word-from-the-tracee39s-memory-decode-bitmask-flags-into-human-readable-names-and-format-output-in-strace-style-there39s-one-concept-at-the-center-of-this-milestone-that-is-genuinely-surprising-the-first-time-you-encounter-it-let39s-start-there\">This milestone builds everything that transforms the first form into the second. You&#39;ll build a syscall name table, extract arguments from the six x86_64 argument registers, read string arguments word-by-word from the tracee&#39;s memory, decode bitmask flags into human-readable names, and format output in strace style.\nThere&#39;s one concept at the center of this milestone that is genuinely surprising the first time you encounter it. Let&#39;s start there.</h2>\n<h2 id=\"the-core-revelation-address-spaces-are-not-shared\">The Core Revelation: Address Spaces Are Not Shared</h2>\n<p>Here&#39;s what feels obvious: the tracee passed a string pointer to the kernel as a syscall argument. You have that pointer. The pointer is just a number â€” a virtual address like <code>0x7ffd1234abcd</code>. Surely you can just dereference it?</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* What you want to do: */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> user_regs_struct regs;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_GETREGS, child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">path </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)regs.rdi;</span><span style=\"color:#6A737D\">  /* rdi = first argument */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"open(</span><span style=\"color:#79B8FF\">\\\"%s\\\"</span><span style=\"color:#9ECBFF\">, ...)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, path);</span><span style=\"color:#6A737D\">  /* â† SEGFAULT or garbage */</span></span></code></pre></div>\n<p>This feels completely reasonable. The pointer exists. It points to memory. Print the memory.\n<strong>It crashes or prints garbage.</strong> Here is why.</p>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m2-address-space-isolation.svg\" alt=\"Virtual Address Space Isolation: Why PEEKDATA Exists\"></p>\n<p>Every process on Linux has its own <em>virtual address space</em> â€” a private, independent mapping of virtual addresses to physical memory pages. The virtual address <code>0x7ffd1234abcd</code> in the tracee&#39;s address space maps to one set of physical pages. That same virtual address in <em>your tracer&#39;s</em> address space maps to something completely different â€” your tracer&#39;s own stack, or unmapped memory that will segfault if you dereference it, or (in rare cases where the addresses happen to coincide) a completely unrelated region.\nThe CPU&#39;s Memory Management Unit (MMU) enforces this separation at the hardware level. Every process has a pointer to its own page table stored in the <code>CR3</code> register. When a context switch happens, the kernel loads the new process&#39;s page table address into <code>CR3</code>. From that moment, all virtual addresses resolve through <em>that process&#39;s</em> page tables. Virtual address isolation isn&#39;t a software policy â€” it&#39;s physics. The hardware translates addresses differently depending on which <code>CR3</code> is loaded.\nThis is the foundation of process isolation. It&#39;s why one buggy process can&#39;t corrupt another&#39;s memory. It&#39;s also exactly why you can&#39;t just dereference a pointer from the tracee: your tracer&#39;s <code>CR3</code> is loaded, not the tracee&#39;s.</p>\n<blockquote>\n<p><strong>The key insight</strong>: A pointer is not data. A pointer is a <em>key</em> that only makes sense within the address space that owns it. To read what a tracee pointer <em>points to</em>, you need the kernel to do the translation on your behalf, using the tracee&#39;s page tables.\n<code>PTRACE_PEEKDATA</code> is exactly that: a kernel-mediated, cross-address-space read. You ask the kernel: &quot;In process <code>pid</code>&#39;s address space, at virtual address <code>addr</code>, what are the 8 bytes?&quot; The kernel temporarily maps the tracee&#39;s page tables, reads the data, and returns it to you. One word at a time.</p>\n</blockquote>\n<hr>\n<h2 id=\"ptrace_peekdata-the-word-by-word-bridge\">PTRACE_PEEKDATA: The Word-by-Word Bridge</h2>\n<p><code>PTRACE_PEEKDATA</code> has this signature:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">long</span><span style=\"color:#B392F0\"> ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_PEEKDATA, </span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> pid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">addr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<ul>\n<li><code>pid</code> â€” the tracee&#39;s PID</li>\n<li><code>addr</code> â€” the virtual address in the tracee&#39;s address space to read from</li>\n<li><code>data</code> â€” ignored for PEEKDATA (the return value carries the data)</li>\n<li><strong>Return value</strong> â€” the 8 bytes at that address, returned as a <code>long</code>\nOn x86_64, one <code>PTRACE_PEEKDATA</code> call reads exactly <strong>8 bytes</strong> (one machine word). If you want to read a string, you must call it repeatedly, advancing the address by 8 each time, until you find a null byte.</li>\n</ul>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m2-peekdata-word-walk.svg\" alt=\"PTRACE_PEEKDATA Word-by-Word String Extraction\"></p>\n<h3 id=\"the-errno-ambiguity-a-critical-trap\">The errno Ambiguity â€” A Critical Trap</h3>\n<p>Here&#39;s the trap that breaks naive implementations:\n<code>PTRACE_PEEKDATA</code> returns its data via the return value. On error, it returns <code>-1</code>. But <code>-1</code> is <code>0xFFFFFFFFFFFFFFFF</code> as an 8-byte word â€” which is <em>valid data</em> that could legitimately appear in the tracee&#39;s memory. So how do you know if <code>-1</code> means &quot;error&quot; or means &quot;I read 8 bytes of 0xFF&quot;?\nYou can&#39;t tell from the return value alone. The POSIX solution: <code>errno</code>.\nWhen <code>PTRACE_PEEKDATA</code> succeeds, it does <strong>not</strong> modify <code>errno</code>. When it fails, it sets <code>errno</code> to indicate the error (e.g., <code>EIO</code> if the address is unmapped, <code>ESRCH</code> if the PID is gone). So the pattern is:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">errno </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">                                      /* Clear before the call */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\"> word </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_PEEKDATA, pid, addr, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (word </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Genuine error */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PTRACE_PEEKDATA\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* word is valid data â€” may be -1, that's fine */</span></span></code></pre></div>\n\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m2-peekdata-errno-ambiguity.svg\" alt=\"PEEKDATA's -1 Ambiguity: Error vs Valid Data\"></p>\n<p>This is not optional. If you skip the <code>errno = 0</code> pre-clear, you may have stale <code>errno</code> from a previous call polluting your error check. Always zero <code>errno</code> before calling <code>PTRACE_PEEKDATA</code>.</p>\n<h3 id=\"reading-a-string-word-by-word\">Reading a String Word by Word</h3>\n<p>With this in mind, here&#39;s the algorithm for reading a null-terminated string from the tracee:</p>\n<ol>\n<li>Start at the pointer address.</li>\n<li>Read one 8-byte word with <code>PTRACE_PEEKDATA</code>.</li>\n<li>Scan the 8 bytes, one byte at a time, for a null byte (<code>&#39;\\0&#39;</code>).</li>\n<li>Append non-null bytes to your output buffer.</li>\n<li>If a null byte is found: done.</li>\n<li>If no null byte in this word: advance address by 8, go to step 2.</li>\n<li>Stop if you&#39;ve read more than your max-length limit.\nThe byte ordering matters. On x86_64 (which is little-endian), the first byte of a word stored at address <code>A</code> is the least-significant byte of the <code>long</code> returned by <code>PTRACE_PEEKDATA</code>. That is, if the memory at address <code>A</code> contains the bytes <code>[&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\\0&#39;, ?, ?]</code>, then <code>PTRACE_PEEKDATA</code> returns a <code>long</code> whose byte 0 (least-significant) is <code>&#39;h&#39;</code>, byte 1 is <code>&#39;e&#39;</code>, and so on.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_STRING_LEN</span><span style=\"color:#79B8FF\"> 32</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Read a string from tracee memory at virtual address 'addr'.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Fills 'buf' (at most 'maxlen' bytes + NUL).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns 1 if truncated, 0 if complete, -1 on error. */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> read_tracee_string</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> pid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> addr</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                       char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> maxlen</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">truncated</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">truncated </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> maxlen) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        errno </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        long</span><span style=\"color:#E1E4E8\"> word </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_PEEKDATA, pid, (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)addr, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (word </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   /* Error on first read: nothing retrieved */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">                    /* Error mid-string: return what we have */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Scan the 8 bytes of this word */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        unsigned</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">word;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; b </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">; b</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bytes</span><span style=\"color:#E1E4E8\">[b] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                buf</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Complete string found */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> maxlen) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                buf</span><span style=\"color:#E1E4E8\">[i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">bytes</span><span style=\"color:#E1E4E8\">[b];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                buf</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                *</span><span style=\"color:#E1E4E8\">truncated </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Truncated */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        addr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Advance to next word */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    buf</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">truncated </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> maxlen);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Use it like this:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">[MAX_STRING_LEN </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> truncated;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_tracee_string</span><span style=\"color:#E1E4E8\">(child, regs.rdi, path, MAX_STRING_LEN, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">truncated</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\\"%s%s\\\"</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, path, truncated </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"...\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\\"</span><span style=\"color:#9ECBFF\">&#x3C;unreadable></span><span style=\"color:#79B8FF\">\\\"</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"null-pointer-check-don39t-peek-at-null\">Null Pointer Check â€” Don&#39;t Peek at NULL</h3>\n<p>Before calling <code>PTRACE_PEEKDATA</code>, always check that the pointer is not NULL. Many syscalls accept NULL for optional arguments â€” for example, <code>execve(path, argv, NULL)</code> with a NULL environment pointer. Attempting <code>PTRACE_PEEKDATA</code> on address 0 will fail with <code>EIO</code> because address 0 is unmapped in every normal process. Print <code>NULL</code> (strace&#39;s convention) instead:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (regs.rdi </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"NULL\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* read_tracee_string(...) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"building-the-syscall-name-table\">Building the Syscall Name Table</h2>\n<p>To print <code>open</code> instead of <code>2</code> (or <code>openat</code> instead of <code>257</code>), you need a lookup table mapping syscall numbers to their names. On x86_64 Linux, syscall numbers are dense integers starting from 0 â€” a perfect candidate for a simple array.</p>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m2-syscall-table-design.svg\" alt=\"Syscall Table Structure: Number â†’ Name â†’ Argument Schema\"></p>\n<h3 id=\"table-design\">Table Design</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* syscall_table.h */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_SYSCALL_NUM</span><span style=\"color:#79B8FF\"> 335</span><span style=\"color:#6A737D\">  /* Highest syscall number on modern Linux x86_64 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">syscall_names</span><span style=\"color:#E1E4E8\">[MAX_SYSCALL_NUM </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">syscall_name</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">long</span><span style=\"color:#FFAB70\"> num</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (num </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> num </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> MAX_SYSCALL_NUM) </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> \"unknown\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">name </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> syscall_names</span><span style=\"color:#E1E4E8\">[num];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">:</span><span style=\"color:#9ECBFF\"> \"unknown\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* syscall_table.c â€” excerpt showing the structure */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">syscall_names</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]   </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"read\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]   </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"write\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">]   </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"open\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">]   </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"close\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">]   </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"stat\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">]   </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"fstat\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">]   </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"lstat\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">]   </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"poll\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">]   </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"lseek\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">9</span><span style=\"color:#E1E4E8\">]   </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"mmap\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"mprotect\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">11</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"munmap\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"brk\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">13</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"rt_sigaction\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">14</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"rt_sigprocmask\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">15</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"rt_sigreturn\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"ioctl\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">17</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"pread64\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">18</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"pwrite64\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">19</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"readv\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"writev\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">21</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"access\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">22</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"pipe\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">23</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"select\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">24</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"sched_yield\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">25</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"mremap\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">26</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"msync\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">27</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"mincore\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">28</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"madvise\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">29</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"shmget\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">30</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"shmat\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">31</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"shmctl\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"dup\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">33</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"dup2\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">34</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"pause\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">35</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"nanosleep\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">36</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"getitimer\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">37</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"alarm\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">38</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"setitimer\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">39</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"getpid\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">40</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"sendfile\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">41</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"socket\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">42</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"connect\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">43</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"accept\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">44</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"sendto\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">45</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"recvfrom\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">46</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"sendmsg\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">47</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"recvmsg\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">48</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"shutdown\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">49</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"bind\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">50</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"listen\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">51</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"getsockname\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">52</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"getpeername\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">53</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"socketpair\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">54</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"setsockopt\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">55</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"getsockopt\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">56</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"clone\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">57</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"fork\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">58</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"vfork\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">59</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"execve\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">60</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"exit\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">61</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"wait4\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">62</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"kill\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">63</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"uname\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">72</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"fcntl\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">74</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"fsync\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">78</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"getdents\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">79</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"getcwd\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"chdir\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">82</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"rename\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">83</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"mkdir\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">84</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"rmdir\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">85</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"creat\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">86</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"link\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">87</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"unlink\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">88</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"symlink\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">89</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"readlink\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">90</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"chmod\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">91</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"fchmod\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">99</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"sysinfo\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">102</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"getuid\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">104</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"getgid\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">107</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"geteuid\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">108</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"getegid\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">110</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"getppid\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">111</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"getpgrp\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">112</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"setsid\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">158</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"arch_prctl\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">186</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"gettid\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">202</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"futex\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">218</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"set_tid_address\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">228</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"clock_gettime\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">231</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"exit_group\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">257</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"openat\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">262</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"newfstatat\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">269</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"faccessat\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">281</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"epoll_pwait\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">302</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"prlimit64\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Sparse entries return NULL â†’ syscall_name() returns \"unknown\" */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n<p>The C99 designated initializer syntax (<code>[n] = &quot;name&quot;</code>) lets you define a sparse array cleanly. Entries you don&#39;t define are initialized to NULL by default, and your <code>syscall_name()</code> function handles that with the <code>&quot;unknown&quot;</code> fallback.</p>\n<blockquote>\n<p>ðŸ”­ <strong>Deep Dive</strong>: The authoritative x86_64 syscall table lives in the Linux kernel source at <code>arch/x86/entry/syscalls/syscall_64.tbl</code>. It&#39;s generated during kernel build into header files. For the definitive current list, see <a href=\"https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/\">Ryan Chapman&#39;s syscall table</a> or the kernel source directly.</p>\n</blockquote>\n<hr>\n<h2 id=\"extracting-arguments-from-registers\">Extracting Arguments from Registers</h2>\n<p>With Milestone 1, you already know how to get a <code>struct user_regs_struct</code>. Now you need to map the six argument registers to the six argument positions of each syscall.</p>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m2-argument-register-mapping.svg\" alt=\"Syscall Argument Register Mapping with Examples\"></p>\n<p>The x86_64 Linux syscall ABI assigns arguments in this fixed order:</p>\n<table>\n<thead>\n<tr>\n<th>Argument #</th>\n<th>Register</th>\n<th><code>user_regs_struct</code> field</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td><code>rdi</code></td>\n<td><code>regs.rdi</code></td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>rsi</code></td>\n<td><code>regs.rsi</code></td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>rdx</code></td>\n<td><code>regs.rdx</code></td>\n</tr>\n<tr>\n<td>4</td>\n<td><code>r10</code></td>\n<td><code>regs.r10</code></td>\n</tr>\n<tr>\n<td>5</td>\n<td><code>r8</code></td>\n<td><code>regs.r8</code></td>\n</tr>\n<tr>\n<td>6</td>\n<td><code>r9</code></td>\n<td><code>regs.r9</code></td>\n</tr>\n<tr>\n<td>It helps to put these into an array at the start of your argument-decoding code, so you can index them generically:</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> args</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    regs.rdi,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    regs.rsi,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    regs.rdx,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    regs.r10,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    regs.r8,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    regs.r9</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n<h2 id=\"now-args0-is-always-argument-1-args1-is-always-argument-2-and-so-on-you-can-build-a-dispatch-table-keyed-on-syscall-number-that-says-quotfor-syscall-n-argument-0-is-a-string-argument-1-is-an-integer-flags-field-argument-2-is-a-modequot\">Now <code>args[0]</code> is always argument 1, <code>args[1]</code> is always argument 2, and so on. You can build a dispatch table keyed on syscall number that says &quot;for syscall N, argument 0 is a string, argument 1 is an integer flags field, argument 2 is a mode.&quot;</h2>\n<h2 id=\"the-argument-schema-knowing-what-type-each-argument-is\">The Argument Schema: Knowing What Type Each Argument Is</h2>\n<p>Different syscalls have different argument types. <code>open(path, flags, mode)</code> has a string, flags bitmask, and integer. <code>read(fd, buf, count)</code> has an integer, a pointer (usually printed as a hex address), and an integer. You need a way to describe each syscall&#39;s argument signature so your decoder can format each argument correctly.\nDefine an argument type enum and a syscall descriptor struct:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* arg_type.h */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ARG_INT,</span><span style=\"color:#6A737D\">      /* Print as signed decimal integer */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ARG_UINT,</span><span style=\"color:#6A737D\">     /* Print as unsigned decimal integer */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ARG_HEX,</span><span style=\"color:#6A737D\">      /* Print as hexadecimal (addresses, pointers) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ARG_STR,</span><span style=\"color:#6A737D\">      /* Read from tracee memory as a null-terminated string */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ARG_PTR,</span><span style=\"color:#6A737D\">      /* Pointer: print as hex if non-NULL, else \"NULL\" */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ARG_OPEN_FLAGS,</span><span style=\"color:#6A737D\">  /* Bitmask: O_RDONLY | O_CREAT | ... */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ARG_MMAP_PROT,</span><span style=\"color:#6A737D\">   /* Bitmask: PROT_READ | PROT_WRITE | ... */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ARG_MMAP_FLAGS,</span><span style=\"color:#6A737D\">  /* Bitmask: MAP_SHARED | MAP_PRIVATE | MAP_ANONYMOUS | ... */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ARG_IGNORE,</span><span style=\"color:#6A737D\">   /* Don't print (e.g., padding args, high args for simple calls) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ArgType;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">         num_args;</span><span style=\"color:#6A737D\">     /* How many arguments to display */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ArgType     </span><span style=\"color:#FFAB70\">arg_types</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\"> /* Type for each argument position */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} SyscallDesc;</span></span></code></pre></div>\n<p>Then build a table mapping syscall numbers to their descriptors:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* syscall_desc.c â€” partial */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#E1E4E8\"> SyscallDesc desc_table</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, { ARG_INT, ARG_PTR,  ARG_UINT } },</span><span style=\"color:#6A737D\">         /* read(fd, buf, count) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, { ARG_INT, ARG_STR,  ARG_UINT } },</span><span style=\"color:#6A737D\">         /* write(fd, buf, count) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, { ARG_STR, ARG_OPEN_FLAGS, ARG_UINT } },</span><span style=\"color:#6A737D\">   /* open(path, flags, mode) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, { ARG_INT } },</span><span style=\"color:#6A737D\">                              /* close(fd) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, { ARG_STR, ARG_PTR  } },</span><span style=\"color:#6A737D\">                   /* stat(path, statbuf) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, { ARG_INT, ARG_PTR  } },</span><span style=\"color:#6A737D\">                   /* fstat(fd, statbuf) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">9</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">, { ARG_PTR, ARG_UINT, ARG_MMAP_PROT,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  ARG_MMAP_FLAGS, ARG_INT, ARG_UINT } },</span><span style=\"color:#6A737D\">    /* mmap(...) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">11</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, { ARG_PTR, ARG_UINT } },</span><span style=\"color:#6A737D\">                   /* munmap(addr, len) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">21</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, { ARG_STR, ARG_INT  } },</span><span style=\"color:#6A737D\">                   /* access(path, mode) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">39</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, { </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\"> } },</span><span style=\"color:#6A737D\">                                    /* getpid() */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">57</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, { </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\"> } },</span><span style=\"color:#6A737D\">                                    /* fork() */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">59</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, { ARG_STR, ARG_PTR, ARG_PTR } },</span><span style=\"color:#6A737D\">           /* execve(path, argv, envp) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">60</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, { ARG_INT } },</span><span style=\"color:#6A737D\">                              /* exit(code) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">257</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, { ARG_INT, ARG_STR, ARG_OPEN_FLAGS,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  ARG_UINT } },</span><span style=\"color:#6A737D\">                             /* openat(dfd, path, flags, mode) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ... more entries ... */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> DESC_TABLE_SIZE</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(desc_table) </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">desc_table</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> SyscallDesc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">get_syscall_desc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">long</span><span style=\"color:#FFAB70\"> num</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (num </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)num </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> DESC_TABLE_SIZE) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Zero-initialized entries have num_args = 0 â€” that's fine, prints no args */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#FFAB70\">desc_table</span><span style=\"color:#E1E4E8\">[num];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>Note on write(fd, buf, count)</strong>: For <code>write</code>, argument 1 (<code>buf</code>) is technically a string in memory, but we mark it as <code>ARG_STR</code> rather than <code>ARG_PTR</code>. This lets us peek at the buffer and print its content (up to the truncation limit), which is exactly what strace does. It&#39;s intentional â€” showing what was written is the useful thing.</p>\n</blockquote>\n<hr>\n<h2 id=\"bitmask-flag-decoding\">Bitmask Flag Decoding</h2>\n<p>When you call <code>open(&quot;/etc/passwd&quot;, O_RDONLY | O_CLOEXEC, 0)</code>, the flags argument is <code>0x80000</code> (O_CLOEXEC = 0x80000, O_RDONLY = 0). Printing <code>0x80000</code> is correct but useless to a reader. Printing <code>O_CLOEXEC</code> is immediately meaningful.</p>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m2-flag-bitmask-decode.svg\" alt=\"Bitmask Flag Decoding: open() Flags Example\"></p>\n<p>The approach: define a table of <code>(bit_value, name)</code> pairs for each flag set, then iterate through the table building a string of names joined by <code>|</code>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> value;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\">   *</span><span style=\"color:#E1E4E8\">name;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} FlagEntry;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* open() flags â€” from &#x3C;fcntl.h>, matched to actual numeric values */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#E1E4E8\"> FlagEntry open_flags</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Access mode â€” these are special: only bits 0-1 */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_RDONLY,   </span><span style=\"color:#9ECBFF\">\"O_RDONLY\"</span><span style=\"color:#E1E4E8\">   },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_WRONLY,   </span><span style=\"color:#9ECBFF\">\"O_WRONLY\"</span><span style=\"color:#E1E4E8\">   },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_RDWR,     </span><span style=\"color:#9ECBFF\">\"O_RDWR\"</span><span style=\"color:#E1E4E8\">    },</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Single-bit flags */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_CREAT,    </span><span style=\"color:#9ECBFF\">\"O_CREAT\"</span><span style=\"color:#E1E4E8\">   },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_EXCL,     </span><span style=\"color:#9ECBFF\">\"O_EXCL\"</span><span style=\"color:#E1E4E8\">    },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_NOCTTY,   </span><span style=\"color:#9ECBFF\">\"O_NOCTTY\"</span><span style=\"color:#E1E4E8\">  },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_TRUNC,    </span><span style=\"color:#9ECBFF\">\"O_TRUNC\"</span><span style=\"color:#E1E4E8\">   },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_APPEND,   </span><span style=\"color:#9ECBFF\">\"O_APPEND\"</span><span style=\"color:#E1E4E8\">  },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_NONBLOCK, </span><span style=\"color:#9ECBFF\">\"O_NONBLOCK\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_DSYNC,    </span><span style=\"color:#9ECBFF\">\"O_DSYNC\"</span><span style=\"color:#E1E4E8\">   },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_SYNC,     </span><span style=\"color:#9ECBFF\">\"O_SYNC\"</span><span style=\"color:#E1E4E8\">    },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_CLOEXEC,  </span><span style=\"color:#9ECBFF\">\"O_CLOEXEC\"</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_TMPFILE,  </span><span style=\"color:#9ECBFF\">\"O_TMPFILE\"</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_DIRECTORY,</span><span style=\"color:#9ECBFF\">\"O_DIRECTORY\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_NOFOLLOW, </span><span style=\"color:#9ECBFF\">\"O_NOFOLLOW\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_PATH,     </span><span style=\"color:#9ECBFF\">\"O_PATH\"</span><span style=\"color:#E1E4E8\">    },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\"> }</span><span style=\"color:#6A737D\">   /* sentinel */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* mmap() prot flags â€” from &#x3C;sys/mman.h> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#E1E4E8\"> FlagEntry mmap_prot_flags</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { PROT_NONE,  </span><span style=\"color:#9ECBFF\">\"PROT_NONE\"</span><span style=\"color:#E1E4E8\">  },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { PROT_READ,  </span><span style=\"color:#9ECBFF\">\"PROT_READ\"</span><span style=\"color:#E1E4E8\">  },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { PROT_WRITE, </span><span style=\"color:#9ECBFF\">\"PROT_WRITE\"</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { PROT_EXEC,  </span><span style=\"color:#9ECBFF\">\"PROT_EXEC\"</span><span style=\"color:#E1E4E8\">  },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* mmap() map flags */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#E1E4E8\"> FlagEntry mmap_map_flags</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { MAP_SHARED,     </span><span style=\"color:#9ECBFF\">\"MAP_SHARED\"</span><span style=\"color:#E1E4E8\">     },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { MAP_PRIVATE,    </span><span style=\"color:#9ECBFF\">\"MAP_PRIVATE\"</span><span style=\"color:#E1E4E8\">    },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { MAP_FIXED,      </span><span style=\"color:#9ECBFF\">\"MAP_FIXED\"</span><span style=\"color:#E1E4E8\">      },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { MAP_ANONYMOUS,  </span><span style=\"color:#9ECBFF\">\"MAP_ANONYMOUS\"</span><span style=\"color:#E1E4E8\">  },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { MAP_GROWSDOWN,  </span><span style=\"color:#9ECBFF\">\"MAP_GROWSDOWN\"</span><span style=\"color:#E1E4E8\">  },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { MAP_DENYWRITE,  </span><span style=\"color:#9ECBFF\">\"MAP_DENYWRITE\"</span><span style=\"color:#E1E4E8\">  },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { MAP_EXECUTABLE, </span><span style=\"color:#9ECBFF\">\"MAP_EXECUTABLE\"</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { MAP_LOCKED,     </span><span style=\"color:#9ECBFF\">\"MAP_LOCKED\"</span><span style=\"color:#E1E4E8\">     },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { MAP_NORESERVE,  </span><span style=\"color:#9ECBFF\">\"MAP_NORESERVE\"</span><span style=\"color:#E1E4E8\">  },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { MAP_POPULATE,   </span><span style=\"color:#9ECBFF\">\"MAP_POPULATE\"</span><span style=\"color:#E1E4E8\">   },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { MAP_HUGETLB,    </span><span style=\"color:#9ECBFF\">\"MAP_HUGETLB\"</span><span style=\"color:#E1E4E8\">    },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n<p>The decoding function:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Decode a bitmask flags value into a \"|\"-separated string.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Special case: O_RDONLY = 0, which needs explicit handling.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns number of bytes written to buf. */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> decode_flags</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> FlagEntry </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">table</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                 char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> bufsize</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> written </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> first </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Special case: if value is 0 and the first entry is 0, print its name */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (value </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#FFAB70\"> table</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].value </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#FFAB70\"> table</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].name </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> snprintf</span><span style=\"color:#E1E4E8\">(buf, bufsize, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">table</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].name);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#FFAB70\">table</span><span style=\"color:#E1E4E8\">[i].name </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">table</span><span style=\"color:#E1E4E8\">[i].value </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Skip the zero-value entry in loop */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> ((value </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> table</span><span style=\"color:#E1E4E8\">[i].value) </span><span style=\"color:#F97583\">==</span><span style=\"color:#FFAB70\"> table</span><span style=\"color:#E1E4E8\">[i].value) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            int</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> snprintf</span><span style=\"color:#E1E4E8\">(buf </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> written, bufsize </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> written,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                             \"</span><span style=\"color:#79B8FF\">%s%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                             first </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"|\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                             table</span><span style=\"color:#E1E4E8\">[i].name);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            written </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            first </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            value </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#FFAB70\">table</span><span style=\"color:#E1E4E8\">[i].value;</span><span style=\"color:#6A737D\">  /* Clear matched bits */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* If there are remaining unrecognized bits, print them as hex */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (value </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> snprintf</span><span style=\"color:#E1E4E8\">(buf </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> written, bufsize </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> written,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                         \"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">0x</span><span style=\"color:#79B8FF\">%lx</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, first </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"|\"</span><span style=\"color:#E1E4E8\">, value);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        written </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> n;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* If nothing matched at all, print the raw value */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (first) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        written </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> snprintf</span><span style=\"color:#E1E4E8\">(buf, bufsize, </span><span style=\"color:#9ECBFF\">\"0x</span><span style=\"color:#79B8FF\">%lx</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, value);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> written;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"the-o_rdonly-edge-case-is-important-o_rdonly-is-defined-as-0-in-the-linux-headers-a-bitwise-and-with-zero-always-produces-zero-so-you-can39t-detect-o_rdonly-by-masking-the-special-case-handles-this-if-the-entire-value-is-0-and-the-first-table-entry-covers-0-print-it-directly-similarly-prot_none-is-0-for-mmap-the-same-logic-applies\">The O_RDONLY edge case is important. <code>O_RDONLY</code> is defined as <code>0</code> in the Linux headers. A bitwise <code>AND</code> with zero always produces zero â€” so you can&#39;t detect <code>O_RDONLY</code> by masking. The special case handles this: if the entire value is 0 and the first table entry covers 0, print it directly.\nSimilarly, <code>PROT_NONE</code> is 0 for mmap. The same logic applies.</h2>\n<h2 id=\"three-level-view-what-happens-when-you-print-an-argument\">Three-Level View: What Happens When You Print an Argument</h2>\n<p>Let&#39;s trace through all three levels for the specific case of <code>open(&quot;/etc/passwd&quot;, O_RDONLY)</code> being printed by your tracer.\n<strong>Level 1 â€” Application (Tracee)</strong>\nThe tracee&#39;s code (inside glibc or your test program) calls:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/etc/passwd\"</span><span style=\"color:#E1E4E8\">, O_RDONLY);</span></span></code></pre></div>\n<p>glibc&#39;s wrapper places <code>/etc/passwd</code>&#39;s address in <code>rdi</code>, <code>O_RDONLY</code> (which is 0) in <code>rsi</code>, and syscall number 2 in <code>rax</code>, then executes the <code>syscall</code> instruction. The string <code>&quot;/etc/passwd&quot;</code> lives somewhere in the tracee&#39;s memory â€” perhaps on its stack at address <code>0x7ffd3a2c1000</code>.\n<strong>Level 2 â€” Your Tracer (Kernel-mediated)</strong>\nYour tracer wakes up on the entry stop, reads <code>orig_rax = 2</code> (open), reads <code>rdi = 0x7ffd3a2c1000</code>. It looks up syscall 2 in the descriptor table: first argument is <code>ARG_STR</code>. So it calls <code>PTRACE_PEEKDATA(child, 0x7ffd3a2c1000)</code>.\nThe kernel handles this PEEKDATA request:</p>\n<ol>\n<li>Finds the tracee&#39;s page table (its <code>mm_struct</code>).</li>\n<li>Walks the page table to find which physical page backs <code>0x7ffd3a2c1000</code>.</li>\n<li>Maps that physical page into kernel address space temporarily.</li>\n<li>Copies 8 bytes from that page to the return value.</li>\n<li>Returns to your tracer.\nYour tracer receives, say, <code>0x7361702f6374652f</code> â€” which as bytes (little-endian) is <code>/</code>, <code>e</code>, <code>t</code>, <code>c</code>, <code>/</code>, <code>p</code>, <code>a</code>, <code>s</code>. No null terminator yet. Advance address by 8 to <code>0x7ffd3a2c1008</code>. Call <code>PTRACE_PEEKDATA</code> again. Receive <code>0x0064777773</code>, which bytes are <code>s</code>, <code>w</code>, <code>d</code>, <code>\\0</code>. Null terminator found. The string is <code>/etc/passwd</code>.\n<strong>Level 3 â€” Hardware</strong>\nWhen the <code>ptrace(PTRACE_PEEKDATA, ...)</code> syscall executes:</li>\n</ol>\n<ul>\n<li>The CPU is running your tracer&#39;s code. The MMU is using your tracer&#39;s page table (<code>CR3</code> points to your tracer&#39;s <code>mm_struct</code>).</li>\n<li>The kernel syscall handler switches context: it uses the tracee&#39;s <code>mm_struct</code> to do the virtualâ†’physical translation for <code>0x7ffd3a2c1000</code>.</li>\n<li>This translation involves a 4-level page table walk on x86_64 (PGD â†’ P4D â†’ PUD â†’ PMD â†’ PTE). If the tracee&#39;s TLB has the address cached, the walk is short. If not, it&#39;s a full 4-level walk.</li>\n<li>The physical page is accessed via the kernel&#39;s direct mapping of physical memory (the kernel maps all physical memory starting at a fixed virtual address). No TLB miss for the kernel&#39;s own access.</li>\n<li>The 8 bytes are copied into the <code>long</code> return value.</li>\n<li>The context switches back to your tracer.\nThe cost per <code>PTRACE_PEEKDATA</code> call: roughly 1,000-3,000 CPU cycles (one full context switch into the kernel, a page table walk, and a context switch back). For a 32-byte string, you need 4 calls: <strong>4,000â€“12,000 CPU cycles just to read a path argument</strong>. This is why strace is slow. A program that makes 10,000 <code>open()</code> calls would have your tracer spend ~100M cycles just reading the path arguments.</li>\n</ul>\n<hr>\n<h2 id=\"formatting-output-in-strace-style\">Formatting Output in strace Style</h2>\n<p>Now you have all the pieces. The output format strace uses is:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>syscall_name(arg1, arg2, ...) = return_value</code></pre></div>\n<p>For errors:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>syscall_name(arg1, arg2, ...) = -1 ERRNO (error message)</code></pre></div>\n<p>Let&#39;s build the <code>print_syscall</code> function that assembles this output. It&#39;s called on the <strong>exit stop</strong>, when you have both the entry registers (saved from the entry stop) and the return value in <code>rax</code>.</p>\n<blockquote>\n<p><strong>Important</strong>: To print arguments, you need the register state from <strong>entry</strong>, not exit. Argument registers (<code>rdi</code>, <code>rsi</code>, etc.) may have been modified by the kernel during the syscall. But the crucial field <code>orig_rax</code> persists. For arguments, you need to save the entry registers. Add a <code>struct user_regs_struct entry_regs</code> to your per-process state and populate it on entry.</p>\n</blockquote>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m2-full-trace-example.svg\" alt=\"Complete Trace of open() â€” From Registers to Formatted Output\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* print one argument of a given type */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> print_arg</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> pid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">, ArgType </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[MAX_STRING_LEN </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">  /* +4 for \"...\" + NUL */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> flags_buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> truncated;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> (type) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ARG_INT:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%lld</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ARG_UINT:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%llu</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ARG_HEX:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"0x</span><span style=\"color:#79B8FF\">%llx</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ARG_STR:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (value </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"NULL\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read_tracee_string</span><span style=\"color:#E1E4E8\">(pid, (</span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\">)value,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                   buf, MAX_STRING_LEN, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">truncated) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\\"%s%s\\\"</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, buf, truncated </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"...\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\\"</span><span style=\"color:#9ECBFF\">&#x3C;unreadable></span><span style=\"color:#79B8FF\">\\\"</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ARG_PTR:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (value </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"NULL\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"0x</span><span style=\"color:#79B8FF\">%llx</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ARG_OPEN_FLAGS:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        decode_flags</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">, open_flags, flags_buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(flags_buf));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, flags_buf);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ARG_MMAP_PROT:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        decode_flags</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">, mmap_prot_flags, flags_buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(flags_buf));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, flags_buf);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ARG_MMAP_FLAGS:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        decode_flags</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">, mmap_map_flags, flags_buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(flags_buf));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, flags_buf);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ARG_IGNORE:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> print_syscall</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> pid</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                   struct</span><span style=\"color:#E1E4E8\"> user_regs_struct </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">entry_regs</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                   long</span><span style=\"color:#FFAB70\"> return_val</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\"> syscall_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)entry_regs->orig_rax;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">name </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> syscall_name</span><span style=\"color:#E1E4E8\">(syscall_num);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#E1E4E8\"> SyscallDesc </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">desc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_syscall_desc</span><span style=\"color:#E1E4E8\">(syscall_num);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> args</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entry_regs->rdi, entry_regs->rsi, entry_regs->rdx,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entry_regs->r10, entry_regs->r8,  entry_regs->r9</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">(\"</span><span style=\"color:#E1E4E8\">, name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (desc </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> desc->num_args </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> desc->num_args; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\", \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            print_arg</span><span style=\"color:#E1E4E8\">(pid, </span><span style=\"color:#FFAB70\">args</span><span style=\"color:#E1E4E8\">[i], desc->arg_types[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\") = \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Print return value */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (return_val </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#F97583\">L</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> return_val </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">L</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> err_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">return_val);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"-1 </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">strerrorname_np</span><span style=\"color:#E1E4E8\">(err_num), </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(err_num));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Note: strerrorname_np is glibc >= 2.32; fallback below */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%ld\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, return_val);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>Portable errno name</strong>: <code>strerrorname_np</code> (non-portable glibc extension since 2.32) returns just the name like <code>&quot;ENOENT&quot;</code>. If your system doesn&#39;t have it, build a small table mapping errno values to their symbolic names:</p>\n<pre><code class=\"language-c\">static const char *errno_names[] = {\n    [EPERM]   = &quot;EPERM&quot;,\n    [ENOENT]  = &quot;ENOENT&quot;,\n    [ESRCH]   = &quot;ESRCH&quot;,\n    [EINTR]   = &quot;EINTR&quot;,\n    [EIO]     = &quot;EIO&quot;,\n    [ENXIO]   = &quot;ENXIO&quot;,\n    [E2BIG]   = &quot;E2BIG&quot;,\n    /* ... */\n    [EBADF]   = &quot;EBADF&quot;,\n    [ECHILD]  = &quot;ECHILD&quot;,\n    [EAGAIN]  = &quot;EAGAIN&quot;,\n    [ENOMEM]  = &quot;ENOMEM&quot;,\n    [EACCES]  = &quot;EACCES&quot;,\n    [EFAULT]  = &quot;EFAULT&quot;,\n    /* ... */\n};\n</code></pre>\n</blockquote>\n<hr>\n<h2 id=\"integrating-with-the-milestone-1-loop\">Integrating with the Milestone 1 Loop</h2>\n<p>In Milestone 1, you had a single toggle flag and a <code>struct user_regs_struct</code> read on exit. Now you need to save the entry registers. Modify the state:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Per-process state â€” will grow significantly in Milestone 3 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">                    in_syscall;</span><span style=\"color:#6A737D\">   /* Toggle: 0=entry, 1=exit */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> user_regs_struct entry_regs;</span><span style=\"color:#6A737D\">  /* Registers saved at entry stop */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ProcessState;</span></span></code></pre></div>\n<p>And update the tracing loop:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">ProcessState state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { .in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Inside the WIFSTOPPED / (sig == (SIGTRAP | 0x80)) branch: */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> user_regs_struct regs;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_GETREGS, child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ptrace GETREGS\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (state.in_syscall </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ENTRY: save registers, flip toggle */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state.entry_regs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> regs;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state.in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* EXIT: print with saved entry registers + current return value */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\"> return_val </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)regs.rax;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    print_syscall</span><span style=\"color:#E1E4E8\">(child, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">state.entry_regs, return_val);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state.in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"that39s-it-the-entry-state-saves-the-register-snapshot-the-exit-state-uses-both-the-saved-entry-registers-for-arguments-and-syscall-number-and-the-current-rax-for-the-return-value\">That&#39;s it. The entry state saves the register snapshot. The exit state uses both the saved entry registers (for arguments and syscall number) and the current <code>rax</code> (for the return value).</h2>\n<h2 id=\"what-real-traces-look-like\">What Real Traces Look Like</h2>\n<p>After this milestone, running <code>./strace_clone /bin/ls /tmp</code> produces something like:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>execve(&quot;/bin/ls&quot;, [&quot;/bin/ls&quot;, &quot;/tmp&quot;], 0x7ffd3b2c1200) = 0\nbrk(NULL) = 0x562a1a3c0000\narch_prctl(0x3001, 0x7ffd13e26250) = -1 EINVAL (Invalid argument)\naccess(&quot;/etc/ld.so.preload&quot;, R_OK) = -1 ENOENT (No such file or directory)\nopenat(AT_FDCWD, &quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3\nfstat(3, 0x7ffd13e265d0) = 0\nmmap(NULL, 25673, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f12ab312000\nclose(3) = 0\nopenat(AT_FDCWD, &quot;/lib/x86_64-linux-gnu/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3\nread(3, &quot;\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0&gt;...&quot;, 832) = 832\n...\nwrite(1, &quot;file1.txt  file2.txt\\n&quot;, 21)  = 21\n+++ exited with 0 +++</code></pre></div>\n<h2 id=\"this-matches-real-strace-output-notice-o_rdonlyo_cloexec-for-the-flags-prot_read-for-mmap-hex-address-for-the-statbuf-pointer-and-the-elf-magic-bytes-peeked-out-of-the-read-buffer\">This matches real strace output. Notice <code>O_RDONLY|O_CLOEXEC</code> for the flags, <code>PROT_READ</code> for mmap, hex address for the statbuf pointer, and the ELF magic bytes peeked out of the read buffer.</h2>\n<h2 id=\"common-bugs-in-this-milestone\">Common Bugs in This Milestone</h2>\n<h3 id=\"bug-1-using-exit-registers-for-argument-printing\">Bug 1: Using exit registers for argument printing</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG: reading argument registers on exit */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (state.in_syscall </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* regs is from GETREGS on EXIT STOP */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"arg1 = </span><span style=\"color:#79B8FF\">%llu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, regs.rdi);</span><span style=\"color:#6A737D\">  /* rdi may have been modified! */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Some syscalls modify their argument registers as part of execution (rare, but it happens with some kernel internals). More importantly, you may have an architecture guarantee that arguments are preserved, but it&#39;s safer and more correct to save them at entry. Always save entry registers.</p>\n<h3 id=\"bug-2-forgetting-errno-0-before-peekdata\">Bug 2: Forgetting <code>errno = 0</code> before PEEKDATA</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG: no errno pre-clear */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\"> word </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_PEEKDATA, pid, addr, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (word </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Bug: errno might be non-zero from a previous failed call,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * making valid data look like an error */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Even if your PEEKDATA succeeds, a stale non-zero <code>errno</code> from an earlier operation (like a failed <code>printf</code> call, or a prior PEEKDATA that genuinely failed) will make <code>word == -1</code> look like an error when it&#39;s actually valid data. Always <code>errno = 0</code> first.</p>\n<h3 id=\"bug-3-infinite-loop-on-non-null-terminated-strings\">Bug 3: Infinite loop on non-null-terminated strings</h3>\n<p>If you trace a program writing to a pipe or socket, the <code>buf</code> argument to <code>write()</code> may not be null-terminated â€” it&#39;s a binary buffer, not a C string. Your string reader <em>must</em> stop at <code>maxlen</code> bytes regardless of whether it found <code>&#39;\\0&#39;</code>. The loop bound is essential:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> maxlen) {</span><span style=\"color:#6A737D\">   /* â† This bound is load-bearing. Never remove it. */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* PEEKDATA + scan ... */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"bug-4-wrong-byte-order-when-scanning-a-peekdata-word\">Bug 4: Wrong byte order when scanning a PEEKDATA word</h3>\n<p>On x86_64 (little-endian), the first byte of a word at address <code>A</code> is the <em>least significant byte</em> of the returned <code>long</code>. This means:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">word;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* bytes[0] is the byte at address A     (LSB of the long) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* bytes[1] is the byte at address A+1   */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* bytes[7] is the byte at address A+7   (MSB of the long) */</span></span></code></pre></div>\n<p>If you extract bytes as <code>(word &gt;&gt; 0) &amp; 0xFF</code>, <code>(word &gt;&gt; 8) &amp; 0xFF</code>, etc., you get the same result. Either approach works as long as you start from the least significant end. Getting this wrong means reading strings in the wrong byte order â€” the test is simple: if <code>/etc/ld.so.cache</code> reads as <code>cte/ld.so.cache/</code> you have an endianness bug.</p>\n<h3 id=\"bug-5-decoding-flags-when-o_rdonly-0-is-not-explicitly-flagged\">Bug 5: Decoding flags when O_RDONLY (0) is not explicitly flagged</h3>\n<h2 id=\"if-you-open-a-file-with-o_rdonly-the-flags-argument-is-0-iterating-through-your-flags-table-with-value-amp-flag-flag-will-never-match-any-entry-since-0-amp-anything-0-result-decode_flags-returns-an-empty-string-or-prints-nothing-handle-the-value-0-case-explicitly-by-printing-the-name-of-the-first-table-entry-which-should-be-o_rdonlyprot_none\">If you open a file with <code>O_RDONLY</code>, the flags argument is 0. Iterating through your flags table with <code>value &amp; flag == flag</code> will never match any entry (since <code>0 &amp; anything = 0</code>). Result: decode_flags returns an empty string or prints nothing. Handle the <code>value == 0</code> case explicitly by printing the name of the first table entry (which should be <code>O_RDONLY</code>/<code>PROT_NONE</code>).</h2>\n<h2 id=\"hardware-soul-the-memory-cost-of-argument-decoding\">Hardware Soul: The Memory Cost of Argument Decoding</h2>\n<h2 id=\"when-your-tracer-reads-a-string-argument-what39s-happening-at-the-hardware-level-cache-lines-the-tracee39s-string-data-lives-in-the-tracee39s-cache-when-the-tracer-calls-ptrace_peekdata-the-kernel-reads-the-physical-page-if-the-tracee-recently-accessed-this-string-it-just-put-it-in-rdi-before-syscall-the-data-is-likely-in-l1-or-l2-cache-the-kernel-can-satisfy-the-peekdata-from-the-cpu-cache-no-dram-access-needed-this-is-one-reason-peekdata-is-quotonlyquot-1000-3000-cycles-rather-than-10000-cycles-tlb-the-tracee39s-page-table-mapping-for-the-string-address-is-likely-still-in-the-tlb-the-tracee-just-accessed-it-but-your-tracer-is-running-with-a-different-cr3-its-tlb-entries-don39t-include-the-tracee39s-virtual-addresses-the-kernel-uses-its-own-tlb-tags-or-temporarily-switches-page-tables-to-perform-the-access-modern-x86_64-cpus-use-pcid-process-context-ids-to-avoid-full-tlb-flushes-on-context-switches-but-cross-process-memory-access-still-has-tlb-overhead-context-switch-cost-every-ptrace-call-is-a-userspacekerneluserspace-round-trip-that39s-a-minimum-of-200500-cycles-just-for-the-mode-switch-plus-the-actual-work-for-a-64-byte-path-name-8-peekdata-calls-8-1500-cycles-12000-cycles-at-3-ghz-that39s-4-microseconds-just-to-read-one-filename-a-program-that-opens-10000-files-takes-40ms-of-pure-tracing-overhead-reading-filenames-before-any-other-tracing-work-this-is-why-strace-is-slow-it39s-not-the-toggle-logic-or-the-flag-decoding-it39s-the-peekdata-loop-the-real-strace-codebase-addresses-this-with-multiple-optimizations-we39ll-discuss-in-the-knowledge-cascade\">When your tracer reads a string argument, what&#39;s happening at the hardware level?\n<strong>Cache lines</strong>: The tracee&#39;s string data lives in the tracee&#39;s cache. When the tracer calls <code>PTRACE_PEEKDATA</code>, the kernel reads the physical page. If the tracee recently accessed this string (it just put it in <code>rdi</code> before <code>syscall</code>), the data is likely in L1 or L2 cache. The kernel can satisfy the PEEKDATA from the CPU cache â€” no DRAM access needed. This is one reason PEEKDATA is &quot;only&quot; ~1,000-3,000 cycles rather than 10,000+ cycles.\n<strong>TLB</strong>: The tracee&#39;s page table mapping for the string address is likely still in the TLB (the tracee just accessed it). But your tracer is running with a different <code>CR3</code> â€” its TLB entries don&#39;t include the tracee&#39;s virtual addresses. The kernel uses its own TLB tags (or temporarily switches page tables) to perform the access. Modern x86_64 CPUs use PCID (Process Context IDs) to avoid full TLB flushes on context switches, but cross-process memory access still has TLB overhead.\n<strong>Context switch cost</strong>: Every <code>ptrace()</code> call is a userspaceâ†’kernelâ†’userspace round trip. That&#39;s a minimum of ~200â€“500 cycles just for the mode switch, plus the actual work. For a 64-byte path name (8 PEEKDATA calls): 8 Ã— 1,500 cycles â‰ˆ 12,000 cycles. At 3 GHz, that&#39;s 4 microseconds <em>just to read one filename</em>. A program that opens 10,000 files takes 40ms of pure tracing overhead reading filenames â€” before any other tracing work.\n<strong>This is why strace is slow</strong>. It&#39;s not the toggle logic or the flag decoding. It&#39;s the PEEKDATA loop. The real strace codebase addresses this with multiple optimizations we&#39;ll discuss in the Knowledge Cascade.</h2>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<h3 id=\"1-procpidmem-amortizing-peekdata-overhead\">1. /proc/PID/mem â€” Amortizing PEEKDATA Overhead</h3>\n<p><code>/proc/PID/mem</code> is a special file that represents the tracee&#39;s entire address space as a file. Open it, <code>lseek</code> to the desired virtual address, and call <code>read()</code> to get data. The key advantage: you can read <em>arbitrary lengths</em> in one <code>read()</code> call, not just 8 bytes.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Alternative to PTRACE_PEEKDATA for long strings */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> path_buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> memfd;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> mempath</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">snprintf</span><span style=\"color:#E1E4E8\">(mempath, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(mempath), </span><span style=\"color:#9ECBFF\">\"/proc/</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">/mem\"</span><span style=\"color:#E1E4E8\">, pid);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">memfd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(mempath, O_RDONLY);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pread</span><span style=\"color:#E1E4E8\">(memfd, path_buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(path_buf), (</span><span style=\"color:#F97583\">off_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">addr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">close</span><span style=\"color:#E1E4E8\">(memfd);</span></span></code></pre></div>\n<p>Modern strace (versions â‰¥ 4.14) uses <code>/proc/PID/mem</code> for string reads, falling back to PEEKDATA only when the file isn&#39;t accessible. A 256-byte path string costs 1 <code>pread()</code> call instead of 32 <code>PTRACE_PEEKDATA</code> calls â€” a 32Ã— reduction in syscall overhead for that read. The catch: <code>/proc/PID/mem</code> requires the tracee to be stopped (which ptrace ensures) and requires appropriate permissions (which you have, since you&#39;re the tracer).</p>\n<h3 id=\"2-process_vm_readv-the-modern-cross-address-space-copy\">2. process_vm_readv â€” The Modern Cross-Address-Space Copy</h3>\n<p>Linux 3.2 introduced <code>process_vm_readv(2)</code>, a syscall designed specifically for this problem:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/uio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">ssize_t</span><span style=\"color:#B392F0\"> process_vm_readv</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> pid</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> iovec </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">local_iov</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> liovcnt</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> iovec </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">remote_iov</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> riovcnt</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> flags</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<p>You describe a list of source regions in the <em>remote</em> (tracee) address space and a list of destination buffers in your <em>local</em> address space. The kernel copies all of them in a single syscall, without the per-word overhead of PEEKDATA. This is 10-100Ã— faster than a PEEKDATA loop for multi-word copies.\n<code>process_vm_readv</code> doesn&#39;t require the tracee to be stopped â€” it works on running processes. This makes it ideal for profiling tools that want to sample the tracee&#39;s memory without full ptrace overhead. The tradeoff: less precision (the target may have moved on while you&#39;re reading), and it requires <code>PTRACE_MODE_ATTACH_REALCREDS</code> privileges if the target isn&#39;t your child.</p>\n<h3 id=\"3-virtual-memory-and-page-tables-why-address-spaces-are-isolated\">3. Virtual Memory and Page Tables â€” Why Address Spaces Are Isolated</h3>\n<p>The <code>CR3</code> register holds the physical address of the page directory (the top of the 4-level page table on x86_64). Every process has its own <code>CR3</code> value stored in its kernel-side task structure. During context switch, the kernel does <code>mov %cr3, &lt;new_value&gt;</code> â€” and from that moment, all virtual address translations go through the new process&#39;s page tables.\nThis hardware mechanism is why process isolation works and why PEEKDATA must exist. The MMU is not a software construct; it&#39;s silicon that enforces virtualâ†’physical translation on every single memory access the CPU makes. Bypassing it requires going through the kernel, which is exactly what PEEKDATA does.\nUnderstanding <code>CR3</code> and page tables is also the foundation for:</p>\n<ul>\n<li>Container runtimes (each container process has its own address space â€” no additional mechanism needed)</li>\n<li>VM introspection (hypervisors reading guest VM memory use the same &quot;cross-address-space read&quot; concept but at the VM level)</li>\n<li>Kernel Samepage Merging (KSM) â€” the kernel scans different processes&#39; physical pages looking for duplicates to merge<blockquote>\n<p>ðŸ”­ <strong>Deep Dive</strong>: For a thorough treatment of x86_64 virtual memory and page table structure, see the Intel Software Developer&#39;s Manual Volume 3A, Section 4 (&quot;Paging&quot;), or for a more accessible treatment, Bovet &amp; Cesati&#39;s <em>Understanding the Linux Kernel</em> (3rd edition), Chapter 2.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"4-gdb39s-x-command-the-same-mechanism\">4. GDB&#39;s <code>x</code> Command â€” The Same Mechanism</h3>\n<p>When you use GDB&#39;s <code>x/s $rdi</code> to examine a string at the address in <code>rdi</code>, GDB is doing exactly what you&#39;ve just built: calling <code>PTRACE_PEEKDATA</code> in a loop, scanning for null bytes, and printing the result. This is why examining 1MB of memory in GDB can take several seconds â€” it&#39;s thousands of PEEKDATA calls, each costing a kernel round trip.\nGDB also uses <code>/proc/PID/mem</code> as an optimization (since GDB 7.12, approximately). You can verify this with <code>strace -p $(pgrep gdb)</code> â€” you&#39;ll see <code>pread64</code> calls on the <code>/proc/...mem</code> file descriptor, interspersed with the usual ptrace calls.\nNow you understand not just <em>that</em> GDB is slow at memory examination, but <em>exactly why</em> and <em>what the limit is</em>. A PEEKDATA word costs ~1,500 cycles. At 1 GHz effective throughput (accounting for kernel overhead), examining 1MB via PEEKDATA would take ~190,000 calls Ã— 1,500 cycles = 285,000,000 cycles â‰ˆ 95ms. Via <code>/proc/PID/mem</code>, it&#39;s one <code>pread()</code> â‰ˆ 5ms.</p>\n<h3 id=\"5-elf-string-tables-the-same-index-structure\">5. ELF String Tables â€” The Same Index Structure</h3>\n<h2 id=\"the-syscall-name-table-you-built-a-fixed-array-indexed-by-number-containing-string-pointers-mirrors-the-structure-elf-binaries-use-to-store-symbol-names-an-elf-file-contains-a-strtab-section-a-flat-array-of-null-terminated-strings-packed-end-to-end-and-a-symtab-section-an-array-of-symbol-entries-each-containing-an-offset-into-strtab-to-find-a-symbol39s-name-you-index-symtab-by-symbol-number-read-the-st_name-offset-then-index-into-strtab-at-that-offset-your-table-is-the-same-pattern-array-index-syscall-number-value-pointer-to-name-string-elf-just-flattens-the-strings-into-one-big-buffer-and-uses-offsets-instead-of-pointers-this-is-a-common-pattern-in-systems-software-quotindex-offset-null-terminated-string-in-a-flat-bufferquot-you39ll-see-it-in-font-files-debug-information-dwarf-and-network-protocol-tables\">The syscall name table you built â€” a fixed array indexed by number, containing string pointers â€” mirrors the structure ELF binaries use to store symbol names. An ELF file contains a <code>.strtab</code> section (a flat array of null-terminated strings packed end-to-end) and a <code>.symtab</code> section (an array of symbol entries, each containing an offset into <code>.strtab</code>). To find a symbol&#39;s name, you index <code>.symtab</code> by symbol number, read the <code>st_name</code> offset, then index into <code>.strtab</code> at that offset.\nYour table is the same pattern: array index = syscall number, value = pointer to name string. ELF just flattens the strings into one big buffer and uses offsets instead of pointers. This is a common pattern in systems software: &quot;index â†’ offset â†’ null-terminated string in a flat buffer.&quot; You&#39;ll see it in font files, debug information (DWARF), and network protocol tables.</h2>\n<h2 id=\"summary-what-you39ve-built\">Summary: What You&#39;ve Built</h2>\n<p>Your tracer now:</p>\n<ul>\n<li>Looks up syscall numbers in a name table and prints human-readable names like <code>open</code>, <code>mmap</code>, <code>write</code></li>\n<li>Saves register state at entry and uses it on exit to print argument values</li>\n<li>Extracts integer, pointer, and string arguments from the six x86_64 syscall argument registers (<code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>r10</code>, <code>r8</code>, <code>r9</code>)</li>\n<li>Reads string arguments from the tracee&#39;s memory word-by-word via <code>PTRACE_PEEKDATA</code>, correctly handling the <code>errno</code>-vs-<code>-1</code> ambiguity</li>\n<li>Truncates strings at a configurable maximum (default 32 bytes) with a <code>...</code> suffix</li>\n<li>Decodes bitmask flag arguments for <code>open()</code>, <code>mmap()</code> prot, and <code>mmap()</code> flags into <code>O_RDONLY|O_CLOEXEC</code>-style strings</li>\n<li>Handles edge cases: NULL pointers (prints <code>NULL</code>), unrecognized syscalls (<code>unknown</code>), unknown flags (prints remaining bits as hex)</li>\n<li>Formats output in strace style: <code>syscall_name(arg1, arg2) = return_value</code>\nThe output of your tracer is now human-readable. Milestone 3 will make it multi-process-aware: following <code>fork()</code>, <code>vfork()</code>, and <code>clone()</code> across process boundaries, tagging every line with the PID that made the call, and maintaining per-PID state to keep the entry/exit toggle correct across interleaved events.</li>\n</ul>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-strace-m3 -->\n<h1 id=\"milestone-3-multi-process-and-fork-following\">Milestone 3: Multi-Process and Fork Following</h1>\n<h2 id=\"where-you-are-now\">Where You Are Now</h2>\n<p>Your Milestone 2 tracer produces beautifully formatted output for a single process:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>execve(&quot;/bin/ls&quot;, [&quot;/bin/ls&quot;, &quot;/tmp&quot;], 0x7ffd3b2c1200) = 0\nbrk(NULL) = 0x562a1a3c0000\naccess(&quot;/etc/ld.so.preload&quot;, R_OK) = -1 ENOENT (No such file or directory)\nopenat(AT_FDCWD, &quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3\nwrite(1, &quot;file1.txt  file2.txt\\n&quot;, 21) = 21\n+++ exited with 0 +++</code></pre></div>\n<p>Now run your tracer against something that calls <code>fork()</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">./strace_clone</span><span style=\"color:#9ECBFF\"> bash</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"echo hello | cat\"</span></span></code></pre></div>\n<p>What happens? Your tracer prints the bash startup syscalls faithfully. Then bash calls <code>fork()</code> to spawn a subshell, and <code>fork()</code> again to run <code>echo</code>, and <code>fork()</code> again to run <code>cat</code>. The forked children run entirely unobserved. Your tracer is watching bash&#39;s side of the story â€” everything the children do is invisible. The <code>echo</code> and <code>cat</code> processes run, write to the pipe, exit, and you never saw a single syscall from them.\nThis isn&#39;t just an annoyance. It&#39;s a fundamental limitation that makes your tracer incorrect for any non-trivial workload. Shell scripts, Python programs, web servers, databases â€” they all fork. The real strace traces the <em>entire process tree</em>, and that&#39;s what you&#39;ll build in this milestone.\nBy the end, your tracer will produce output like this:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[pid 12345] execve(&quot;/bin/bash&quot;, [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello | cat&quot;], ...) = 0\n[pid 12345] pipe([3, 4]) = 0\n[pid 12345] clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|...) = 12346\n[pid 12346] execve(&quot;/bin/echo&quot;, [&quot;/bin/echo&quot;, &quot;hello&quot;], ...) = 0\n[pid 12346] write(1, &quot;hello\\n&quot;, 6) = 6\n[pid 12346] exit_group(0) = ?\n[pid 12345] wait4(-1, [{WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 0}], ...) = 12346\n+++ exited with 0 +++</code></pre></div>\n<p>Every process. Every syscall. Correctly interleaved. That&#39;s what this milestone delivers.</p>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m3-multi-process-output.svg\" alt=\"Interleaved Multi-Process Output Example\"></p>\n<hr>\n<h2 id=\"the-core-revelation-tracing-is-not-inherited\">The Core Revelation: Tracing Is Not Inherited</h2>\n<p>Here is the assumption that will break your first attempt at multi-process tracing:</p>\n<blockquote>\n<p><em>The child process inherits everything from its parent â€” file descriptors, memory mappings, signal handlers. Surely it inherits the ptrace relationship too?</em>\nThis feels completely reasonable. After all, if ptrace is about observation, and the child is a copy of the parent, shouldn&#39;t the kernel observe the child too? The child even shares the parent&#39;s executable code until copy-on-write kicks in. Why would the tracing relationship be different?\n<strong>It isn&#39;t inherited. Not at all.</strong> When a traced process calls <code>fork()</code>, the child process starts life <em>completely untraced</em>. It runs at full speed, unobserved, making syscalls your tracer never sees. By the time you even learn that a fork happened â€” via the <code>PTRACE_SYSCALL</code> event that fires in the parent â€” the child may have already run thousands of syscalls and possibly exited.\nThis is not an oversight in the kernel design. There&#39;s a deep reason: ptrace is a relationship between <em>specific processes</em>. The kernel tracks a tracer PID for each tracee. When a fork creates a new PID, that new PID has no tracer until one is explicitly designated. The kernel won&#39;t automatically assign your tracer as the observer of a process it didn&#39;t ask to observe. Automatic inheritance would be a security hole â€” imagine a traced sandbox program forking an untraced helper that escapes the sandbox&#39;s policy.\nThe solution is to opt in <em>before</em> the fork happens, using <code>PTRACE_SETOPTIONS</code>. When you set <code>PTRACE_O_TRACEFORK</code>, <code>PTRACE_O_TRACEVFORK</code>, and <code>PTRACE_O_TRACECLONE</code> on a tracee, you&#39;re telling the kernel: &quot;When this process calls <code>fork()</code>, <code>vfork()</code>, or <code>clone()</code>, automatically attach to the new child on my behalf, and deliver a special event stop to tell me about it.&quot; The kernel does this atomically â€” there is no window where the child runs untraced. The child starts in a stopped state, waiting for your tracer to give it the first <code>PTRACE_SYSCALL</code> command.</p>\n</blockquote>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m3-fork-event-sequence.svg\" alt=\"Fork Event Sequence: Parent Forks, Kernel Notifies Tracer\"></p>\n<p>This atomicity is the key property. Let&#39;s understand why it matters.</p>\n<h3 id=\"the-race-condition-that-doesn39t-exist-because-you-set-the-option\">The Race Condition That Doesn&#39;t Exist (Because You Set the Option)</h3>\n<h2 id=\"imagine-an-alternative-design-you-receive-a-fork-exit-event-child-pid-12346-then-you-call-ptraceptrace_attach-12346-to-start-tracing-the-new-child-what39s-the-problem-there39s-a-window-between-the-moment-fork-completes-in-the-tracee-and-the-moment-your-tracer39s-ptrace_attach-syscall-executes-the-child-is-running-freely-for-a-fast-child-one-that-does-minimal-work-and-exits-quickly-it-may-finish-entirely-within-this-window-you39d-get-esrch-no-such-process-from-ptrace_attach-because-the-process-no-longer-exists-or-worse-the-child-might-spawn-its-own-children-before-you-attach-which-are-also-untraced-this-is-a-classic-time-of-check-to-time-of-use-toctou-race-condition-the-quotcheckquot-is-fork-returning-a-pid-and-the-quotusequot-is-attaching-to-that-pid-but-the-pid39s-lifetime-is-unconstrained-between-those-two-events-ptrace_o_tracefork-eliminates-the-race-entirely-the-kernel-performs-the-attachment-inside-the-fork-syscall-handler-before-the-child-process-ever-gets-scheduled-the-child-begins-its-life-in-a-ptrace-stop-state-by-the-time-you-learn-a-fork-happened-the-child-is-already-frozen-waiting-for-you-no-race-no-window-atomic-guarantee\">Imagine an alternative design: you receive a <code>fork()</code> exit event (child PID = 12346), then you call <code>ptrace(PTRACE_ATTACH, 12346, ...)</code> to start tracing the new child. What&#39;s the problem?\nThere&#39;s a window. Between the moment <code>fork()</code> completes in the tracee and the moment your tracer&#39;s <code>PTRACE_ATTACH</code> syscall executes, the child is running freely. For a fast child â€” one that does minimal work and exits quickly â€” it may finish entirely within this window. You&#39;d get <code>ESRCH</code> (no such process) from <code>PTRACE_ATTACH</code> because the process no longer exists. Or worse, the child might spawn <em>its own</em> children before you attach, which are also untraced.\nThis is a classic Time-of-Check-to-Time-of-Use (TOCTOU) race condition. The &quot;check&quot; is <code>fork()</code> returning a PID, and the &quot;use&quot; is attaching to that PID â€” but the PID&#39;s lifetime is unconstrained between those two events.\n<code>PTRACE_O_TRACEFORK</code> eliminates the race entirely. The kernel performs the attachment <em>inside the <code>fork()</code> syscall handler</em>, before the child process ever gets scheduled. The child begins its life in a ptrace stop state. By the time you learn a fork happened, the child is already frozen, waiting for you. No race. No window. Atomic guarantee.</h2>\n<h2 id=\"setting-the-options-before-the-fork-happens\">Setting the Options: Before the Fork Happens</h2>\n<p>You already know how to set ptrace options â€” you used <code>PTRACE_SETOPTIONS</code> in Milestone 1 to set <code>PTRACE_O_TRACESYSGOOD</code>. Now you add the fork-following options to the same call:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* After the initial post-exec waitpid, set ALL options at once */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\"> opts </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PTRACE_O_TRACESYSGOOD</span><span style=\"color:#6A737D\">   /* Bit 7 on syscall stops          */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           |</span><span style=\"color:#E1E4E8\"> PTRACE_O_TRACEFORK</span><span style=\"color:#6A737D\">     /* Catch fork() in tracee          */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           |</span><span style=\"color:#E1E4E8\"> PTRACE_O_TRACEVFORK</span><span style=\"color:#6A737D\">    /* Catch vfork() in tracee         */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           |</span><span style=\"color:#E1E4E8\"> PTRACE_O_TRACECLONE</span><span style=\"color:#6A737D\">    /* Catch clone() in tracee         */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           |</span><span style=\"color:#E1E4E8\"> PTRACE_O_TRACEEXEC;</span><span style=\"color:#6A737D\">    /* Catch execve() in tracee        */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SETOPTIONS, child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">opts</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ptrace SETOPTIONS\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>A crucial detail: <strong>these options are set on the parent tracee, not on future children</strong>. When a child is created with <code>PTRACE_O_TRACEFORK</code> active, the new child <em>automatically inherits the same options</em>. So if the child later forks grandchildren, those grandchildren are also automatically traced and get the same option set. Your single <code>PTRACE_SETOPTIONS</code> call propagates down the entire process tree indefinitely.\nLet&#39;s clarify what each option does:\n<strong><code>PTRACE_O_TRACEFORK</code></strong> â€” Intercepts calls to <code>fork()</code>. On x86_64, <code>fork()</code> is syscall 57. When a traced process calls <code>fork()</code>, the kernel delivers a <code>PTRACE_EVENT_FORK</code> stop to your tracer at the exit of the <code>fork()</code> syscall.\n<strong><code>PTRACE_O_TRACEVFORK</code></strong> â€” Intercepts <code>vfork()</code> (syscall 58). <code>vfork()</code> is a variant of <code>fork()</code> where the parent <em>suspends</em> until the child calls <code>exec()</code> or <code>_exit()</code>. The child borrows the parent&#39;s address space without copying it. The event is <code>PTRACE_EVENT_VFORK</code>.\n<strong><code>PTRACE_O_TRACECLONE</code></strong> â€” Intercepts <code>clone()</code> (syscall 56). <code>clone()</code> is the general-purpose process/thread creation syscall on Linux. Both <code>fork()</code> and <code>vfork()</code> are implemented as thin wrappers around <code>clone()</code> in glibc. Threads are also created via <code>clone()</code> with different flags. The event is <code>PTRACE_EVENT_CLONE</code>.\n<strong><code>PTRACE_O_TRACEEXEC</code></strong> â€” Intercepts <code>execve()</code>. When a traced process successfully replaces its image with a new program, the kernel delivers <code>PTRACE_EVENT_EXEC</code>. This is essential for handling address space replacement, which we&#39;ll cover later in this milestone.</p>\n<blockquote>\n<p><strong>Why trace clone for threads?</strong> When a program creates a thread using <code>pthread_create()</code>, glibc calls <code>clone()</code> with <code>CLONE_VM | CLONE_THREAD | ...</code> flags. The resulting thread shares the address space with the parent (it&#39;s not a separate process). By setting <code>PTRACE_O_TRACECLONE</code>, you trace threads too. Whether you <em>want</em> to trace every thread is a design choice â€” real strace traces all threads by default. For this milestone, we&#39;ll trace them all.</p>\n</blockquote>\n<hr>\n<h2 id=\"switching-to-waitpid-1-catching-any-child\">Switching to waitpid(-1): Catching Any Child</h2>\n<p>With Milestones 1 and 2, your <code>waitpid</code> call looked like this:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">waitpid</span><span style=\"color:#E1E4E8\">(child, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">status</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  /* Wait for ONE specific PID */</span></span></code></pre></div>\n<p>This is no longer sufficient. You might now be tracing 5, 10, or 50 PIDs simultaneously. You don&#39;t know which one will stop next â€” it depends on scheduler timing, I/O, signals, and factors completely outside your control. If you call <code>waitpid(12345, ...)</code> while PID 12346 has just stopped and is waiting for you, you&#39;ll deadlock: 12346 is frozen waiting for your <code>PTRACE_SYSCALL</code>, and you&#39;re blocked waiting for 12345.\nThe fix is simple and powerful: use <code>-1</code> as the PID argument to <code>waitpid</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">pid_t</span><span style=\"color:#E1E4E8\"> stopped_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> waitpid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">status</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<p>When the PID argument is <code>-1</code>, <code>waitpid</code> returns the status of <em>any</em> child that changes state. It picks whoever stopped first. The return value is the PID of the process that stopped â€” this is essential, because now you need to know <em>which</em> process triggered the event to dispatch to the correct per-PID state.\nThe tracing loop structure changes from this:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Milestone 2: single-process */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    waitpid</span><span style=\"color:#E1E4E8\">(child, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ... handle status ... */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>To this:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Milestone 3: multi-process */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (active_process_count </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> stopped_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> waitpid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (stopped_pid </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Dispatch: find state for stopped_pid, handle the event */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ProcessState </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">state </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> find_state</span><span style=\"color:#E1E4E8\">(stopped_pid);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    handle_event</span><span style=\"color:#E1E4E8\">(stopped_pid, state, status);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Notice the loop condition changed too. You no longer loop until a single process exits â€” you loop until <em>all</em> traced processes have exited.</p>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m3-waitpid-dispatch-flowchart.svg\" alt=\"waitpid(-1) Event Dispatch: Multi-PID Decision Tree\"></p>\n<hr>\n<h2 id=\"decoding-ptrace-events-the-statusgtgt16-trick\">Decoding ptrace Events: The status&gt;&gt;16 Trick</h2>\n<p>When <code>PTRACE_O_TRACEFORK</code> and friends are set, the kernel delivers special &quot;ptrace event&quot; stops to your tracer. These events come through the same <code>waitpid</code> status word you&#39;ve been using, but they&#39;re encoded in the <em>high 16 bits</em> of the status â€” a region you haven&#39;t used yet.\nHere&#39;s the status word layout for a ptrace event stop:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Bits 31-24: 0\nBits 23-16: PTRACE_EVENT_* constant (the event type)\nBits  15-8: SIGTRAP (signal 5)\nBits   7-0: 0x7f (stopped, not exited)</code></pre></div>\n<p>The <code>WIFSTOPPED(status)</code> macro is true. <code>WSTOPSIG(status)</code> returns <code>SIGTRAP</code> (not <code>SIGTRAP | 0x80</code> â€” event stops don&#39;t set bit 7 even with <code>TRACESYSGOOD</code>). The event type sits in <code>status &gt;&gt; 16</code>.\nThe defined event constants in <code>&lt;sys/ptrace.h&gt;</code>:</p>\n<table>\n<thead>\n<tr>\n<th>Constant</th>\n<th>Value</th>\n<th>Triggered By</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>PTRACE_EVENT_FORK</code></td>\n<td>1</td>\n<td><code>fork()</code> in tracee</td>\n</tr>\n<tr>\n<td><code>PTRACE_EVENT_VFORK</code></td>\n<td>2</td>\n<td><code>vfork()</code> in tracee</td>\n</tr>\n<tr>\n<td><code>PTRACE_EVENT_CLONE</code></td>\n<td>3</td>\n<td><code>clone()</code> in tracee</td>\n</tr>\n<tr>\n<td><code>PTRACE_EVENT_EXEC</code></td>\n<td>4</td>\n<td>successful <code>execve()</code> in tracee</td>\n</tr>\n<tr>\n<td><code>PTRACE_EVENT_VFORK_DONE</code></td>\n<td>5</td>\n<td>vfork child called exec/exit, parent resumes</td>\n</tr>\n<tr>\n<td><code>PTRACE_EVENT_EXIT</code></td>\n<td>6</td>\n<td>tracee is about to exit (not yet dead)</td>\n</tr>\n<tr>\n<td>To extract the event type:</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> event </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (status </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">ff</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n<p>Or use the macro if your headers define it:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Some systems define this, some don't â€” define it yourself to be safe */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTRACE_EVENT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">status</span><span style=\"color:#E1E4E8\">) ((status) </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n<p>A complete stop classification now looks like this:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFEXITED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Tracee exited â€” remove from state map */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFSIGNALED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Tracee killed by signal â€” remove from state map */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFSTOPPED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> sig </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> WSTOPSIG</span><span style=\"color:#E1E4E8\">(status);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> event </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (status </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">ff</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (event </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* ptrace event stop â€” handle fork/exec/etc. */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        handle_ptrace_event</span><span style=\"color:#E1E4E8\">(stopped_pid, event, status);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (sig </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (SIGTRAP </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Syscall stop (TRACESYSGOOD) */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        handle_syscall_stop</span><span style=\"color:#E1E4E8\">(stopped_pid, state);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (sig </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SIGTRAP) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Plain SIGTRAP â€” post-exec stop or breakpoint */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Just resume */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, stopped_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Signal-delivery stop â€” re-inject */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, stopped_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)sig);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"retrieving-the-new-child-pid-with-ptrace_geteventmsg\">Retrieving the New Child PID with PTRACE_GETEVENTMSG</h2>\n<p>When you receive a <code>PTRACE_EVENT_FORK</code>, <code>PTRACE_EVENT_VFORK</code>, or <code>PTRACE_EVENT_CLONE</code> stop on process P, you know P forked. But what&#39;s the child&#39;s PID?\n<code>PTRACE_GETEVENTMSG</code> retrieves the message associated with the most recent ptrace event:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> new_child_pid;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_GETEVENTMSG, stopped_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">new_child_pid</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PTRACE_GETEVENTMSG\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Handle error */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* new_child_pid is the new process's PID */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[pid </span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\">] forked</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, new_child_pid);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Create state for new_child_pid in your state map */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    init_process_state</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#E1E4E8\">)new_child_pid);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Resume the new child (it's currently stopped, waiting for us) */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, (</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#E1E4E8\">)new_child_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Two things to understand here:\n<strong>First</strong>: When <code>PTRACE_GETEVENTMSG</code> is called after a fork event, the returned value is the new child&#39;s PID. When called after an exec event, it returns the old PID (before exec replaced the process image) â€” useful if PIDs change, though on Linux exec doesn&#39;t change the PID.\n<strong>Second</strong>: At the moment your tracer receives the fork event, <strong>the new child is already stopped</strong>. It hasn&#39;t run a single instruction. You must call <code>ptrace(PTRACE_SYSCALL, new_child_pid, ...)</code> to let it start executing. If you forget this, the child is frozen forever, and your loop will never get an exit event for it â€” you&#39;ll hang.\nHere&#39;s the complete fork event handler:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> handle_fork_event</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> parent_pid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> event</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> child_pid_ul;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_GETEVENTMSG, parent_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">child_pid_ul) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PTRACE_GETEVENTMSG\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Resume parent anyway */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, parent_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> child_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#E1E4E8\">)child_pid_ul;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">fork_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (event </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PTRACE_EVENT_FORK)  </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"fork\"</span><span style=\"color:#F97583\">  :</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                            (event </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PTRACE_EVENT_VFORK) </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"vfork\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"clone\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[pid </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">] </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">() = </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, parent_pid, fork_type, child_pid);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Create state for the new child */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ProcessState </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">child_state </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> state_map_insert</span><span style=\"color:#E1E4E8\">(child_pid);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    child_state->in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Child starts fresh â€” not mid-syscall */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    active_process_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Release the child so it can start executing */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, child_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Child may have already exited â€” that's OK */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> ESRCH) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ptrace PTRACE_SYSCALL (new child)\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Resume the parent too */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, parent_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"per-pid-state-the-hash-map\">Per-PID State: The Hash Map</h2>\n<p>In Milestone 2, your per-process state was a single struct for a single process:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">                     in_syscall;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> user_regs_struct entry_regs;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ProcessState;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ProcessState state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { .in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> };</span></span></code></pre></div>\n<p>Now you need this for potentially dozens of PIDs simultaneously. You need a data structure that:</p>\n<ol>\n<li>Inserts a new PID â†’ state mapping when a child is born</li>\n<li>Looks up state by PID on every <code>waitpid</code> event (hot path â€” called for <em>every</em> syscall)</li>\n<li>Removes a PID when the process exits</li>\n<li>Handles whatever maximum number of simultaneous processes your workload generates\nOn Linux, PIDs are integers in the range <code>[1, 4194304]</code> (by default, configurable via <code>/proc/sys/kernel/pid_max</code>). A direct array of size 4M would be wasteful but possible. A hash map is more appropriate for general use.</li>\n</ol>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m3-per-pid-state-map.svg\" alt=\"Per-PID State Hash Map â€” Structure and Lookup\"></p>\n<h3 id=\"designing-the-state-struct\">Designing the State Struct</h3>\n<p>Before building the map, expand <code>ProcessState</code> to include everything per-PID you&#39;ll need:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/user.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/ptrace.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\">                   pid;</span><span style=\"color:#6A737D\">         /* Which process this entry belongs to */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">                     in_syscall;</span><span style=\"color:#6A737D\">  /* Toggle: 0=entry next, 1=exit next */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> user_regs_struct entry_regs;</span><span style=\"color:#6A737D\">  /* Register snapshot from entry stop */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">                     valid;</span><span style=\"color:#6A737D\">       /* Is this slot occupied? (for open addressing) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ProcessState;</span></span></code></pre></div>\n<p>The memory layout of this struct matters. Let&#39;s account for it:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Size</th>\n<th>Offset</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>pid</code></td>\n<td><code>pid_t</code> (int)</td>\n<td>4 bytes</td>\n<td>0</td>\n</tr>\n<tr>\n<td><code>in_syscall</code></td>\n<td><code>int</code></td>\n<td>4 bytes</td>\n<td>4</td>\n</tr>\n<tr>\n<td><code>entry_regs</code></td>\n<td><code>struct user_regs_struct</code></td>\n<td>216 bytes</td>\n<td>8</td>\n</tr>\n<tr>\n<td><code>valid</code></td>\n<td><code>int</code></td>\n<td>4 bytes</td>\n<td>224</td>\n</tr>\n<tr>\n<td>(padding)</td>\n<td>â€”</td>\n<td>4 bytes</td>\n<td>228</td>\n</tr>\n<tr>\n<td><strong>Total</strong></td>\n<td></td>\n<td><strong>232 bytes</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>At 232 bytes per entry, a table with 256 slots costs 59 KB â€” fits comfortably in L2 cache (typically 256 KBâ€“1 MB). The <code>entry_regs</code> struct alone is 216 bytes (27 64-bit registers), spanning approximately 4 cache lines (64 bytes each). Every <code>PTRACE_GETREGS</code> call writes all 216 bytes into your state.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"a-simple-open-addressing-hash-map\">A Simple Open-Addressing Hash Map</h3>\n<p>For a systems project at this level, a simple open-addressing hash map with linear probing is correct and efficient. PIDs are small integers â€” they hash well with a simple modulo. Here&#39;s a minimal implementation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> STATE_MAP_SIZE</span><span style=\"color:#79B8FF\"> 256</span><span style=\"color:#6A737D\">   /* Must be a power of 2 for mask trick */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> STATE_MAP_MASK</span><span style=\"color:#E1E4E8\"> (STATE_MAP_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#E1E4E8\"> ProcessState </span><span style=\"color:#FFAB70\">state_map</span><span style=\"color:#E1E4E8\">[STATE_MAP_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Initialize the map â€” all entries start invalid */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> state_map_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(state_map, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(state_map));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> STATE_MAP_SIZE; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        state_map</span><span style=\"color:#E1E4E8\">[i].valid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Hash function: PID modulo table size (PIDs are already somewhat random) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> hash_pid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> pid</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)(pid </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> STATE_MAP_MASK);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Insert a new PID entry; returns pointer to the state, NULL on error */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ProcessState </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">state_map_insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> pid</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> hash_pid</span><span style=\"color:#E1E4E8\">(pid);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> STATE_MAP_SIZE; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> slot </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (idx </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> i) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> STATE_MAP_MASK;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#FFAB70\">state_map</span><span style=\"color:#E1E4E8\">[slot].valid) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            state_map</span><span style=\"color:#E1E4E8\">[slot].pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pid;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            state_map</span><span style=\"color:#E1E4E8\">[slot].in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            state_map</span><span style=\"color:#E1E4E8\">[slot].valid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">state_map</span><span style=\"color:#E1E4E8\">[slot].entry_regs, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                   sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">state_map</span><span style=\"color:#E1E4E8\">[slot].entry_regs));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#FFAB70\">state_map</span><span style=\"color:#E1E4E8\">[slot];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Table full */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Look up state for a PID; returns NULL if not found */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ProcessState </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">state_map_find</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> pid</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> hash_pid</span><span style=\"color:#E1E4E8\">(pid);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> STATE_MAP_SIZE; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> slot </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (idx </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> i) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> STATE_MAP_MASK;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#FFAB70\">state_map</span><span style=\"color:#E1E4E8\">[slot].valid) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Empty slot: not present */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">state_map</span><span style=\"color:#E1E4E8\">[slot].pid </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> pid) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#FFAB70\">state_map</span><span style=\"color:#E1E4E8\">[slot];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Remove a PID entry */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> state_map_remove</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> pid</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> hash_pid</span><span style=\"color:#E1E4E8\">(pid);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> STATE_MAP_SIZE; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> slot </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (idx </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> i) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> STATE_MAP_MASK;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#FFAB70\">state_map</span><span style=\"color:#E1E4E8\">[slot].valid) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Not found */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">state_map</span><span style=\"color:#E1E4E8\">[slot].pid </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> pid) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            state_map</span><span style=\"color:#E1E4E8\">[slot].valid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Note: open addressing with linear probing requires tombstones</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * or rehashing on removal to preserve lookup correctness.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * For simplicity here, we zero the slot and accept that</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * lookups may stop at empty slots. For a small table with</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * low load factor this is fine. */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>Design Decision: Open Addressing vs. Chaining</strong></p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Used By</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Open addressing (this code) âœ“</strong></td>\n<td>Cache-friendly (sequential probing), no allocations</td>\n<td>Deletion is tricky (tombstones needed), degrades at high load</td>\n<td>Real strace (similar approach)</td>\n</tr>\n<tr>\n<td>Chaining (linked list per bucket)</td>\n<td>Simple deletion, no clustering</td>\n<td>Pointer chasing, allocations, cache misses</td>\n<td>HashMap in many languages</td>\n</tr>\n<tr>\n<td>Direct array (4M entries)</td>\n<td>O(1) guaranteed, zero collisions</td>\n<td>4M Ã— 232B = ~928 MB (!), wasteful</td>\n<td>Not appropriate here</td>\n</tr>\n</tbody></table>\n<p>With a 256-slot table and a maximum of ~50 simultaneously traced processes (realistic for most workloads), the load factor stays below 0.2 â€” collision chains will be very short.\n<strong>Tombstone Note</strong>: The removal code above has a subtle bug: open addressing with linear probing requires that you don&#39;t simply clear removed slots, or else lookups will incorrectly terminate at those empty slots and miss entries that were probed past them. For production code, use a tombstone marker (<code>valid = -1</code>) that lookup skips but insert can reuse. For this milestone, with a large table and low load factor, the practical impact is negligible, but be aware of it.</p>\n</blockquote>\n<hr>\n<h2 id=\"pid-tagged-output\">PID-Tagged Output</h2>\n<p>When multiple processes are active, output lines must identify which process made each syscall. Real strace uses the format <code>[pid NNNN]</code> as a prefix on every line when tracing more than one process.\nModify your <code>print_syscall</code> function from Milestone 2 to accept the PID and a flag indicating whether to show it:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> print_syscall</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> pid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> show_pid</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                   struct</span><span style=\"color:#E1E4E8\"> user_regs_struct </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">entry_regs</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                   long</span><span style=\"color:#FFAB70\"> return_val</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (show_pid) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[pid </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">] \"</span><span style=\"color:#E1E4E8\">, pid);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\"> syscall_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)entry_regs->orig_rax;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">name </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> syscall_name</span><span style=\"color:#E1E4E8\">(syscall_num);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ... rest of formatting as in Milestone 2 ... */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Alternatively â€” and this is cleaner â€” always print the PID prefix. Real strace only suppresses it when tracing a single process, but showing it always is simpler and always correct. The cost is a few extra characters per line.\nFor the fork/exec events themselves (not syscall stops), print them as strace does:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[pid 12345] clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|SIGCHLD) = 12346</code></pre></div>\n<h2 id=\"this-means-printing-the-fork-type-syscall-result-in-the-parent39s-context-when-the-fork-event-fires-the-parent39s-orig_rax-contains-the-clonefork-syscall-number-and-the-new-child39s-pid-is-the-return-value-you-print-it-at-the-fork-event-stop-which-fires-at-the-exit-of-the-fork-syscall-in-the-parent-so-you-have-both-the-syscall-name-and-the-child-pid\">This means printing the fork-type syscall result <em>in the parent&#39;s context</em> when the fork event fires. The parent&#39;s <code>orig_rax</code> contains the clone/fork syscall number, and the new child&#39;s PID is the return value. You print it at the fork event stop, which fires at the <em>exit</em> of the fork syscall in the parent â€” so you have both the syscall name and the child PID.</h2>\n<h2 id=\"handling-ptrace_event_exec-address-space-replacement\">Handling PTRACE_EVENT_EXEC: Address Space Replacement</h2>\n<p><code>exec()</code> is the most dramatic thing a process can do short of dying. When <code>execve()</code> succeeds, the kernel throws away everything about the process&#39;s current state:</p>\n<ul>\n<li>The entire text (code) segment is replaced</li>\n<li>The heap is destroyed and rebuilt</li>\n<li>The stack is replaced with a fresh one</li>\n<li>All memory-mapped regions are unmapped and replaced</li>\n<li>File descriptors marked <code>O_CLOEXEC</code> are closed\nWhat doesn&#39;t change:</li>\n<li>The PID</li>\n<li>The PPID (parent PID)</li>\n<li>The ptrace attachment (the process stays traced)</li>\n</ul>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m3-exec-state-reset.svg\" alt=\"PTRACE_EVENT_EXEC: Address Space Replacement\"></p>\n<p>For your tracer, this means: <strong>any pointer you cached from before the exec is now dangling</strong>. The string <code>&quot;/bin/old_program&quot;</code> that used to be at address <code>0x7ffd12340000</code> in the tracee&#39;s address space no longer exists at that address. The address space has been completely replaced.\nWhat does this mean practically for your per-PID state?\nThe <code>entry_regs</code> you saved at a syscall entry stop is invalidated if exec happens before the exit stop. Fortunately, <code>exec()</code> fires <code>PTRACE_EVENT_EXEC</code> <em>at the exit of the execve syscall</em>, which means the previous syscall (if any) has already completed. The entry/exit toggle should be in the &quot;entry&quot; state (waiting for the next entry) at the point exec fires. But to be safe, you should reset the toggle:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> handle_exec_event</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> pid</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ProcessState </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">state </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> state_map_find</span><span style=\"color:#E1E4E8\">(pid);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (state </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Exec from a previously unknown PID â€” this can happen if TRACEME</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * is used and the initial stop triggers an exec event.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Insert new state. */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        state </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> state_map_insert</span><span style=\"color:#E1E4E8\">(pid);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (state </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"State map full</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Reset per-PID state: address space is now entirely different */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state->in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">state->entry_regs, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(state->entry_regs));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* The PTRACE_EVENT_EXEC stop fires at the exit of execve.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * The execve return value will be 0 (success) in rax.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * We could print execve(...) = 0 here, but we already printed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * the execve entry. Alternatively, handle it as a special case. */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[pid </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">] &#x3C;... execve resumed> = 0</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, pid);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Resume the process */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>The exec entry/exit problem</strong>: With <code>PTRACE_EVENT_EXEC</code> set, execve stops are slightly unusual. The entry stop fires normally (you see it as a syscall entry, read <code>orig_rax = 59</code> for execve). Then, if exec succeeds, instead of a plain syscall exit stop, you get a <code>PTRACE_EVENT_EXEC</code> stop. Your toggle will be in the &quot;in_syscall&quot; state (waiting for exit). The exec event handler should reset it to 0. If exec <em>fails</em> (returns -1 ENOENT etc.), you get a normal syscall exit stop instead â€” no exec event. Handle both cases.</p>\n</blockquote>\n<hr>\n<h2 id=\"tracking-active-processes-the-exit-count\">Tracking Active Processes: The Exit Count</h2>\n<p>Your loop must know when all traced processes have exited so it can stop. Maintain a counter:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> active_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Number of currently-traced, live processes */</span></span></code></pre></div>\n<ul>\n<li>Increment when you create a new state (on fork events and at startup for the initial child).</li>\n<li>Decrement when <code>WIFEXITED(status)</code> or <code>WIFSIGNALED(status)</code> is true for any PID.</li>\n<li>Loop condition: <code>while (active_count &gt; 0)</code>.\nBe careful with the ordering: remove the PID&#39;s state from the map <em>and</em> decrement the counter when you see the exit event. Don&#39;t decrement twice.</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFEXITED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> code </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> WEXITSTATUS</span><span style=\"color:#E1E4E8\">(status);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[pid </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">] +++ exited with </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> +++</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, stopped_pid, code);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    state_map_remove</span><span style=\"color:#E1E4E8\">(stopped_pid);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    active_count</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFSIGNALED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> sig </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> WTERMSIG</span><span style=\"color:#E1E4E8\">(status);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[pid </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">] +++ killed by signal </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">) +++</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            stopped_pid, sig, </span><span style=\"color:#B392F0\">strsignal</span><span style=\"color:#E1E4E8\">(sig));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    state_map_remove</span><span style=\"color:#E1E4E8\">(stopped_pid);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    active_count</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"putting-it-all-together-the-complete-multi-process-loop\">Putting It All Together: The Complete Multi-Process Loop</h2>\n<p>Here is the full tracing loop for Milestone 3. This replaces the single-process loop from Milestone 2:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/ptrace.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/types.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/wait.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/user.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;signal.h></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* ... (ProcessState, state_map_*, print_syscall, etc. from earlier sections) ... */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#F97583\">[]</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (argc </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Usage: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> &#x3C;program> [args...]</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    state_map_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fork</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (child </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"fork\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (child </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Child: request tracing */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_TRACEME, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        execvp</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"execvp\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Catch initial post-exec SIGTRAP */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    waitpid</span><span style=\"color:#E1E4E8\">(child, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">WIFSTOPPED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Unexpected initial status</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Set all options: syscall marking + fork following + exec events */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\"> opts </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PTRACE_O_TRACESYSGOOD</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               |</span><span style=\"color:#E1E4E8\"> PTRACE_O_TRACEFORK</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               |</span><span style=\"color:#E1E4E8\"> PTRACE_O_TRACEVFORK</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               |</span><span style=\"color:#E1E4E8\"> PTRACE_O_TRACECLONE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               |</span><span style=\"color:#E1E4E8\"> PTRACE_O_TRACEEXEC;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SETOPTIONS, child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)opts) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ptrace SETOPTIONS\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Initialize state for the first child */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ProcessState </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">init_state </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> state_map_insert</span><span style=\"color:#E1E4E8\">(child);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    init_state->in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> active_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Resume the initial child */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* â”€â”€ MAIN TRACING LOOP â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (active_count </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Wait for ANY traced process to change state */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pid_t</span><span style=\"color:#E1E4E8\"> stopped_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> waitpid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (stopped_pid </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ECHILD) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* No more children */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"waitpid\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* â”€â”€ PROCESS EXITED OR KILLED â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFEXITED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[pid </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">] +++ exited with </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> +++</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    stopped_pid, </span><span style=\"color:#B392F0\">WEXITSTATUS</span><span style=\"color:#E1E4E8\">(status));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            state_map_remove</span><span style=\"color:#E1E4E8\">(stopped_pid);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            active_count</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFSIGNALED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[pid </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">] +++ killed by signal </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">) +++</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    stopped_pid, </span><span style=\"color:#B392F0\">WTERMSIG</span><span style=\"color:#E1E4E8\">(status), </span><span style=\"color:#B392F0\">strsignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">WTERMSIG</span><span style=\"color:#E1E4E8\">(status)));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            state_map_remove</span><span style=\"color:#E1E4E8\">(stopped_pid);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            active_count</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* â”€â”€ PROCESS STOPPED â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">WIFSTOPPED</span><span style=\"color:#E1E4E8\">(status)) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> sig   </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> WSTOPSIG</span><span style=\"color:#E1E4E8\">(status);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> event </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (status </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">ff</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ProcessState </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">state </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> state_map_find</span><span style=\"color:#E1E4E8\">(stopped_pid);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (state </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Unknown PID â€” this can happen for the grandchild of a clone</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * if our state_map_insert in the fork handler raced with the</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">             * grandchild's first stop. Insert it now. */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            state </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> state_map_insert</span><span style=\"color:#E1E4E8\">(stopped_pid);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (state </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"State map full â€” resuming unknown PID </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        stopped_pid);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, stopped_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            active_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* â”€â”€ PTRACE EVENT STOPS (fork, exec, etc.) â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (event </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            switch</span><span style=\"color:#E1E4E8\"> (event) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> PTRACE_EVENT_FORK:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> PTRACE_EVENT_VFORK:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> PTRACE_EVENT_CLONE: {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> new_pid_ul;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_GETEVENTMSG, stopped_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">new_pid_ul);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                pid_t</span><span style=\"color:#E1E4E8\"> new_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#E1E4E8\">)new_pid_ul;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">kind </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (event </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PTRACE_EVENT_FORK)  </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"fork\"</span><span style=\"color:#F97583\">  :</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                   (event </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PTRACE_EVENT_VFORK) </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"vfork\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"clone\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[pid </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">] </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">() = </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        stopped_pid, kind, new_pid);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* Create state for the new child */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                ProcessState </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">child_state </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> state_map_insert</span><span style=\"color:#E1E4E8\">(new_pid);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (child_state </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    child_state->in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    active_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* Start the new child's tracing */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, new_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> ESRCH) </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ptrace new child\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> PTRACE_EVENT_EXEC:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* Address space replaced â€” reset cached state */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                state->in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">state</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">entry_regs</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(state</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">entry_regs));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[pid </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">] &#x3C;execve resumed> = 0</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, stopped_pid);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> PTRACE_EVENT_EXIT:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* Process is about to exit â€” we'll get WIFEXITED soon */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Resume after any event stop */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, stopped_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* â”€â”€ SYSCALL STOP (TRACESYSGOOD: bit 7 set) â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (sig </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (SIGTRAP </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            struct</span><span style=\"color:#E1E4E8\"> user_regs_struct regs;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_GETREGS, stopped_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">regs) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ESRCH) { </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ptrace GETREGS\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, stopped_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (state->in_syscall </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* ENTRY: save register snapshot, flip toggle */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                state->entry_regs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> regs;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                state->in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* EXIT: print using saved entry registers + current rax */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                long</span><span style=\"color:#E1E4E8\"> return_val </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)regs.rax;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                print_syscall</span><span style=\"color:#E1E4E8\">(stopped_pid,</span><span style=\"color:#6A737D\"> /*show_pid=*/</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                              &#x26;</span><span style=\"color:#E1E4E8\">state->entry_regs, return_val);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                state->in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, stopped_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* â”€â”€ PLAIN SIGTRAP (post-exec stop or other) â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (sig </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SIGTRAP) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, stopped_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* â”€â”€ SIGNAL-DELIVERY STOP: re-inject the signal â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, stopped_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)sig);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"three-level-view-what-happens-when-fork-is-intercepted\">Three-Level View: What Happens When fork() Is Intercepted</h2>\n<p>Let&#39;s trace through what happens at all three levels when a traced process calls <code>fork()</code>.\n<strong>Level 1 â€” Application (Tracee)</strong>\nThe process calls <code>fork()</code>. glibc&#39;s <code>fork()</code> wrapper is, on Linux, a thin wrapper around <code>clone()</code> with <code>SIGCHLD</code> flag. The actual syscall number is 57 (<code>fork</code>) or 56 (<code>clone</code>), depending on the glibc version and architecture. The <code>syscall</code> instruction fires.\n<strong>Level 2 â€” Kernel</strong></p>\n<ol>\n<li>The entry stop fires. Your tracer wakes up, reads <code>orig_rax = 57</code>, saves entry registers, flips toggle to <code>in_syscall = 1</code>. Calls <code>PTRACE_SYSCALL</code> to resume.</li>\n<li>The kernel performs <code>do_fork()</code>: allocates a new <code>task_struct</code>, copies the parent&#39;s address space (copy-on-write), assigns a new PID, sets up the child&#39;s kernel stack.</li>\n<li><strong>Because <code>PTRACE_O_TRACEFORK</code> is set</strong>: the kernel checks the tracee&#39;s <code>PT_TRACED</code> flag and the options. It sets <code>PT_TRACED</code> on the new child&#39;s <code>task_struct</code>. It puts the new child into <code>TASK_STOPPED</code> state before it ever runs. It adds the child to the tracer&#39;s list of traced processes.</li>\n<li>The kernel delivers <code>PTRACE_EVENT_FORK</code> to the tracer: it sets <code>status = (PTRACE_EVENT_FORK &lt;&lt; 16) | (SIGTRAP &lt;&lt; 8) | 0x7f</code> and wakes up the tracer&#39;s <code>waitpid</code>.</li>\n<li>Both parent and child are now stopped. The parent is waiting for your <code>PTRACE_SYSCALL</code> to resume it past the exit stop. The child is waiting for your <code>PTRACE_SYSCALL</code> to start it.\n<strong>Level 3 â€” Hardware</strong>\n<code>clone()</code>/<code>fork()</code> is one of the most expensive syscalls. Creating a new process involves:</li>\n</ol>\n<ul>\n<li>Allocating a new <code>task_struct</code> (~4 KB kernel allocation)</li>\n<li>Duplicating the page table (each level of the 4-level page table must be copied â€” at minimum, the top-level PGD, which is 4 KB)</li>\n<li>For copy-on-write: marking all writable pages as read-only in both parent&#39;s and child&#39;s page tables, requiring TLB invalidation</li>\n<li>A TLB shootdown: sending IPIs (Inter-Processor Interrupts) to all other CPU cores to flush their TLB entries for the parent&#39;s pages\nThe TLB shootdown is significant on multi-core systems. If your traced process was running on 8 cores before the fork, the kernel must interrupt all 8 cores to invalidate their TLB entries. This is on the order of 1â€“10 microseconds per fork â€” expensive enough that fork-heavy programs benefit from <code>posix_spawn()</code> or <code>vfork()</code> optimizations.\nFrom your tracer&#39;s perspective: the <code>waitpid</code> that returns the <code>PTRACE_EVENT_FORK</code> event typically arrives 50â€“200 microseconds after the fork syscall entry, depending on system load and the cost of the page table operations.</li>\n</ul>\n<hr>\n<h2 id=\"the-tricky-cases-what-can-go-wrong\">The Tricky Cases: What Can Go Wrong</h2>\n<h3 id=\"race-new-child39s-first-stop-arrives-before-fork-event\">Race: New Child&#39;s First Stop Arrives Before Fork Event</h3>\n<p>The kernel guarantees that the <code>PTRACE_EVENT_FORK</code> stop on the parent fires before the child is scheduled. But your <code>waitpid(-1)</code> loop doesn&#39;t care about ordering â€” both events are queued. In practice, the fork event arrives first because the parent&#39;s event is queued before the child is even runnable. But defensively, handle the case where <code>state_map_find(stopped_pid)</code> returns NULL by inserting a new entry. The code above does this.</p>\n<h3 id=\"clone-flags-and-thread-vs-process\">Clone Flags and Thread vs. Process</h3>\n<p>When <code>clone()</code> is called with <code>CLONE_VM</code> (shared memory map) and <code>CLONE_THREAD</code> (same thread group), it creates a thread rather than a separate process. From ptrace&#39;s perspective, threads are treated like processes: they get their own PID (actually a TID, Thread ID), and each thread gets its own entry/exit toggle. Your state map handles this naturally â€” each TID is an independent key.\nThe practical complication: when a multi-threaded program exits, all threads receive an exit event. Your <code>active_count</code> must be decremented for each TID, not just for the main process&#39;s PID. The code above already handles this because it decrements on every <code>WIFEXITED</code> event from <code>waitpid(-1)</code>.</p>\n<h3 id=\"exec-mid-trace-the-toggle-confusion\">Exec Mid-Trace: The Toggle Confusion</h3>\n<p>If a process is in the <code>in_syscall = 1</code> state (you saw the entry stop, you&#39;re waiting for the exit stop) and then calls <code>execve()</code>, you&#39;ll see the execve entry stop, flip to <code>in_syscall = 1</code> (already 1... wait, no). Let&#39;s think through this carefully:</p>\n<ol>\n<li>Process calls <code>read()</code>: entry stop fires, toggle â†’ 1.</li>\n<li>Process returns from <code>read()</code>: exit stop fires, toggle â†’ 0. Print <code>read(...) = N</code>.</li>\n<li>Process calls <code>execve()</code>: entry stop fires, toggle â†’ 1. You save entry_regs (with <code>orig_rax = 59</code>).</li>\n<li>Exec succeeds: instead of exit stop, you get <code>PTRACE_EVENT_EXEC</code>. Your toggle is at 1.</li>\n<li>You must reset toggle to 0 and clear entry_regs.\nThis is exactly what the exec event handler does. Without it, the <em>next</em> syscall in the new program would be treated as an exit (because toggle is still 1), and you&#39;d read garbage from the entry_regs that belonged to the old address space.</li>\n</ol>\n<h3 id=\"vfork-parent-waits-for-child\">vfork: Parent Waits for Child</h3>\n<p><code>vfork()</code> is special: the parent is suspended in the kernel until the child calls <code>exec()</code> or <code>_exit()</code>. From your tracer&#39;s perspective, after the <code>PTRACE_EVENT_VFORK</code> stop fires:</p>\n<ul>\n<li>Resume both parent and child with <code>PTRACE_SYSCALL</code>.</li>\n<li>The parent won&#39;t produce any events until the child execs or exits (because it&#39;s suspended in the kernel).</li>\n<li>The child will produce a stream of events.</li>\n<li>When the child execs, you&#39;ll see <code>PTRACE_EVENT_VFORK_DONE</code> on the parent.\nYour code handles this correctly already â€” <code>waitpid(-1)</code> will naturally pick up the child&#39;s events while the parent produces none. When the parent eventually unsuspends, it&#39;ll start producing events again.</li>\n</ul>\n<hr>\n<h2 id=\"hardware-soul-the-cost-of-multi-process-tracing\">Hardware Soul: The Cost of Multi-Process Tracing</h2>\n<h2 id=\"when-you39re-tracing-10-simultaneous-processes-what39s-the-hardware-doing-cache-thrashing-from-context-switches-each-waitpid-return-potentially-represents-a-context-switch-to-a-different-process-a-context-switch-replaces-the-cpu39s-register-file-flushes-the-l1-instruction-tlb-if-no-pcid-and-may-invalidate-l1-data-cache-lines-that-belonged-to-the-previous-process-with-10-processes-interleaving-you39re-generating-20-context-switches-per-syscall-enter-tracee-tracer-inspect-tracer-tracee-exit-tracee-tracer-inspect-tracer-next-tracee-each-context-switch-costs-10005000-cycles-on-modern-hardware-state-map-lookup-on-hot-path-every-waitpid-event-requires-a-state-map-lookup-with-a-256-slot-open-addressing-table-and-load-factor-01-the-average-lookup-is-o1-with-essentially-zero-collision-probing-the-entire-table-59-kb-fits-in-l2-cache-once-the-trace-starts-the-table-stays-hot-a-lookup-costs-roughly-515-cycles-for-the-hash-computation-and-1-2-cache-hits-struct-user_regs_struct-size-at-216-bytes-saving-entry_regs-requires-writing-4-cache-lines-at-64-bytes-per-cache-line-that39s-4-cache-line-writes-per-entry-stop-with-the-state-map-in-l2-cache-hot-this-costs-approximately-4-5-cycles-20-cycles-for-the-memory-write-negligible-compared-to-the-context-switch-overhead-the-tlb-picture-your-tracer-runs-in-its-own-address-space-every-ptrace_getregs-and-ptrace_peekdata-call-is-a-syscall-into-the-kernel-the-kernel-access-to-tracee-memory-uses-the-kernel39s-own-mapping-of-physical-memory-which-doesn39t-require-switching-cr3-so-the-tlb-concern-for-your-tracer39s-own-address-space-is-limited-to-the-syscall-entryexit-mechanism-itself-not-per-peekdata\">When you&#39;re tracing 10 simultaneous processes, what&#39;s the hardware doing?\n<strong>Cache thrashing from context switches</strong>: Each <code>waitpid</code> return potentially represents a context switch to a different process. A context switch replaces the CPU&#39;s register file, flushes the L1 instruction TLB (if no PCID), and may invalidate L1 data cache lines that belonged to the previous process. With 10 processes interleaving, you&#39;re generating 20 context switches per syscall (enter tracee â†’ tracer, inspect, tracer â†’ tracee, exit tracee â†’ tracer, inspect, tracer â†’ next tracee...). Each context switch costs 1,000â€“5,000 cycles on modern hardware.\n<strong>State map lookup on hot path</strong>: Every <code>waitpid</code> event requires a state map lookup. With a 256-slot open-addressing table and load factor 0.1, the average lookup is O(1) with essentially zero collision probing. The entire table (59 KB) fits in L2 cache. Once the trace starts, the table stays hot. A lookup costs roughly 5â€“15 cycles for the hash computation and 1-2 cache hits.\n<strong><code>struct user_regs_struct</code> size</strong>: At 216 bytes, saving entry_regs requires writing ~4 cache lines. At 64 bytes per cache line, that&#39;s 4 cache line writes per entry stop. With the state map in L2 cache (hot), this costs approximately 4 Ã— 5 cycles = 20 cycles for the memory write â€” negligible compared to the context switch overhead.\n<strong>The TLB picture</strong>: Your tracer runs in its own address space. Every <code>PTRACE_GETREGS</code> and <code>PTRACE_PEEKDATA</code> call is a syscall into the kernel. The kernel access to tracee memory uses the kernel&#39;s own mapping of physical memory (which doesn&#39;t require switching <code>CR3</code>) â€” so the TLB concern for your tracer&#39;s own address space is limited to the syscall entry/exit mechanism itself, not per-PEEKDATA.</h2>\n<h2 id=\"common-bugs-in-this-milestone\">Common Bugs in This Milestone</h2>\n<h3 id=\"bug-1-not-resuming-the-new-child\">Bug 1: Not Resuming the New Child</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG: forget to resume the new child */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">case PTRACE_EVENT_FORK: {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> new_pid;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_GETEVENTMSG, stopped_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">new_pid);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Create state... */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* â† MISSING: ptrace(PTRACE_SYSCALL, new_pid, NULL, NULL) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>The new child sits frozen forever. Your <code>active_count</code> is incremented but the child never produces an exit event. The loop hangs.</p>\n<h3 id=\"bug-2-using-waitpidoriginal_pid-instead-of-waitpid-1\">Bug 2: Using waitpid(original_pid) instead of waitpid(-1)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG: still using the original child PID */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">waitpid</span><span style=\"color:#E1E4E8\">(child, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">status</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  /* Misses events from all other PIDs */</span></span></code></pre></div>\n<p>Events from forked children are never seen. Those children are frozen, waiting for your <code>PTRACE_SYSCALL</code>. The loop deadlocks when the original process waits for a child that your tracer never resumed.</p>\n<h3 id=\"bug-3-not-checking-for-null-from-state_map_find\">Bug 3: Not Checking for NULL from state_map_find</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG: crashing if state not found */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ProcessState </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">state </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> state_map_find</span><span style=\"color:#E1E4E8\">(stopped_pid);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">state</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* SEGFAULT if state is NULL */</span></span></code></pre></div>\n<p>Always null-check. If the state map returns NULL, a PID showed up that you didn&#39;t expect â€” insert it defensively.</p>\n<h3 id=\"bug-4-misidentifying-event-stops-as-syscall-stops\">Bug 4: Misidentifying Event Stops as Syscall Stops</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG: checking bit 7 first, before checking event */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (sig </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (SIGTRAP </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* handle as syscall stop */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>If <code>event != 0</code>, it&#39;s a ptrace event stop, not a syscall stop, even if some bit patterns coincide. Always check <code>event</code> first, then <code>sig</code>.</p>\n<h3 id=\"bug-5-double-decrementing-active_count\">Bug 5: Double-Decrementing active_count</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG: decrementing twice for one process exit */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFEXITED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    active_count</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">        /* Decrement 1 */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    state_map_remove</span><span style=\"color:#E1E4E8\">(stopped_pid);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">state_map_find</span><span style=\"color:#E1E4E8\">(stopped_pid) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    active_count</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">        /* Decrement 2 â€” same process! */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"the-loop-exits-prematurely-or-goes-negative-decrement-exactly-once-per-pid-exit-event\">The loop exits prematurely or goes negative. Decrement exactly once per PID exit event.</h2>\n<h2 id=\"testing-multi-process-tracing\">Testing Multi-Process Tracing</h2>\n<p>Test progressively:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Simple fork: bash -c runs a subshell</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./strace_clone</span><span style=\"color:#9ECBFF\"> bash</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"ls /tmp\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Multiple children: pipeline creates two children</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./strace_clone</span><span style=\"color:#9ECBFF\"> bash</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"echo hello | cat\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># exec after fork: demonstrates PTRACE_EVENT_EXEC</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./strace_clone</span><span style=\"color:#9ECBFF\"> bash</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"exec ls /tmp\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Many forks: make -j4 forks multiple compilers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./strace_clone</span><span style=\"color:#9ECBFF\"> make</span><span style=\"color:#79B8FF\"> -j4</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Thread creation via clone: any threaded program</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./strace_clone</span><span style=\"color:#9ECBFF\"> python3</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"import threading; threading.Thread(target=lambda: None).start()\"</span></span></code></pre></div>\n<p>Expected output for the pipeline test:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[pid 12345] execve(&quot;/bin/bash&quot;, [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello | cat&quot;], ...) = 0\n[pid 12345] pipe([3, 4]) = 0\n[pid 12345] clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|...) = 12346\n[pid 12346] execve(&quot;/bin/echo&quot;, ...) = 0\n[pid 12346] write(1, &quot;hello\\n&quot;, 6) = 6\n[pid 12346] exit_group(0) = ?\n[pid 12345] wait4(-1, ...) = 12346\n[pid 12345] clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|...) = 12347\n[pid 12347] execve(&quot;/bin/cat&quot;, ...) = 0\n...\n[pid 12345] +++ exited with 0 +++\n[pid 12347] +++ exited with 0 +++</code></pre></div>\n<h2 id=\"the-interleaving-order-depends-on-scheduler-timing-and-may-vary-between-runs-that39s-expected\">The interleaving order depends on scheduler timing and may vary between runs â€” that&#39;s expected.</h2>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<h3 id=\"1-container-runtimes-the-entire-process-tree-must-be-observed\">1. Container Runtimes â€” The Entire Process Tree Must Be Observed</h3>\n<p>When Docker, Podman, or runc starts a container, it must enforce that <em>every</em> process inside the container operates within the container&#39;s namespaces and cgroup limits. The container runtime can&#39;t just trace the initial process â€” it needs to follow every <code>fork()</code>, <code>vfork()</code>, and <code>clone()</code> the container makes, exactly as you&#39;ve just built.\nContainer runtimes use <code>PTRACE_O_TRACEFORK</code> (or its equivalent in seccomp-BPF notification mode) to catch process creation. If a container process tries to <code>unshare()</code> its namespaces to escape containment, the seccomp filter catches it. If it forks a child that tries to access forbidden resources, the child is also observed because of the fork-following options. The atomicity guarantee â€” no window between fork and ptrace attachment â€” is what makes containers secure against fork-based escape attempts.\nThe <code>PTRACE_O_TRACEFORK</code> mechanism you just implemented is the same mechanism that makes Linux containers work at a fundamental level. You&#39;ve just built the observation layer that container security depends on.</p>\n<h3 id=\"2-pid-namespaces-and-why-waitpid-1-works\">2. PID Namespaces and Why waitpid(-1) Works</h3>\n<p>Linux supports <em>PID namespaces</em>: a process in a container sees PIDs starting from 1, even though the host kernel assigns them much larger PIDs. From inside the container, PID 1 is the container&#39;s init process. From outside, it might be PID 73412.\nYour tracer runs outside any container namespace, so it sees the <em>host PIDs</em>. <code>waitpid(-1)</code> collects events from all direct child PIDs in your tracer&#39;s PID namespace â€” which includes all the traced processes, since they&#39;re children (or descendants) of your tracer process.\nWhen you build a container runtime that uses ptrace for enforcement, you need to understand which PID namespace your <code>waitpid(-1)</code> operates in. Events from processes in nested PID namespaces still arrive with their host PID, not their namespace-local PID. The <code>/proc/PID/status</code> file shows both <code>Pid:</code> (host PID) and <code>NSpid:</code> (namespace-local PIDs) â€” relevant if you&#39;re building tooling that needs to correlate traces across namespace boundaries.</p>\n<h3 id=\"3-race-conditions-in-tracing-the-toctou-window\">3. Race Conditions in Tracing â€” The TOCTOU Window</h3>\n<p>Before <code>PTRACE_O_TRACEFORK</code> existed, the only way to trace fork children was:</p>\n<ol>\n<li>Receive fork exit event (child PID in rax).</li>\n<li>Call <code>PTRACE_ATTACH(child_pid)</code>.</li>\n<li><code>waitpid(child_pid)</code> for the SIGSTOP.\nSteps 1â†’2 involve a window. The child process is running. It might:</li>\n</ol>\n<ul>\n<li>Open a file your policy forbids</li>\n<li>Spawn its own children (which are also untraced)</li>\n<li>Complete entirely and exit\nThis is a Time-of-Check-to-Time-of-Use (TOCTOU) race. The &quot;check&quot; (learning the child PID) is temporally separated from the &quot;use&quot; (attaching). In security contexts, an adversarial program can deliberately exploit this window â€” calling fork, doing the forbidden thing in the child immediately, and exiting before the tracer attaches.\n<code>PTRACE_O_TRACEFORK</code> eliminates this by making the attachment happen <em>inside the kernel, inside the fork syscall handler</em>. The child is placed into a stopped state before it is ever scheduled. There is no window. The attachment and the fork are atomic with respect to the child&#39;s execution. This is the correct pattern for secure tracing: <strong>push the attachment into the kernel where it&#39;s atomic</strong>, rather than doing it from userspace where races exist.\nThis principle â€” pushing critical operations into the kernel to eliminate races â€” generalizes. <code>signalfd()</code> eliminates the signal/accept race. <code>epoll()</code> with edge triggering eliminates the epoll/read race. <code>O_CREAT|O_EXCL</code> eliminates the exists/create race. Atomicity at the kernel boundary is the pattern.</li>\n</ul>\n<h3 id=\"4-hash-map-design-at-the-system-level\">4. Hash Map Design at the System Level</h3>\n<p>Your per-PID state hash map is a microcosm of a general systems programming problem: <strong>fast lookup keyed by process ID for a hot-path operation</strong>. Let&#39;s compare how production systems solve this:\nThe Linux kernel itself uses a hash table for its process table (<code>struct pid_hash</code>). It uses a hash of the PID value, with chaining for collision resolution. The key operations are <code>find_task_by_vpid()</code> and <code>find_task_by_pid_ns()</code> â€” called thousands of times per second on a busy system. The kernel&#39;s hash is sized to approximately the square root of <code>pid_max</code>, giving O(1) average lookup even with many processes.\nReal strace uses a simpler structure: a sorted array of <code>struct tcb</code> (traced control block) pointers, binary-searched by PID. With fewer than <del>100 traced processes (typical), binary search over a sorted 100-element array is cache-friendly and fast. The <code>struct tcb</code> in strace is large (</del>500 bytes) and lives in a flat array â€” no pointer chasing, good locality.\nFor your implementation, the flat open-addressing table with 256 slots is optimal for the common case (&lt; 50 traced processes). If you need to handle 1000+ simultaneously traced processes (tracing a large build system, for example), consider increasing the table size or switching to chaining.</p>\n<h3 id=\"5-exec-and-address-space-replacement-why-pointers-die\">5. exec and Address Space Replacement â€” Why Pointers Die</h3>\n<h2 id=\"exec-is-the-most-radical-operation-in-unix-process-management-the-kernel-discards-the-old-address-space-and-installs-a-new-one-in-a-single-atomic-operation-from-the-process39s-perspective-for-your-tracer-this-creates-a-fundamental-discontinuity-any-memory-address-you-read-from-the-tracee-before-exec-is-now-meaningless-this-is-the-same-concept-that-makes-certain-security-vulnerabilities-dangerous-return-oriented-programming-rop-attacks-chain-together-existing-code-fragments-quotgadgetsquot-in-the-target-process39s-memory-if-the-target-calls-exec-all-those-gadgets-are-gone-the-rop-chain-is-broken-address-space-layout-randomization-aslr-randomizes-where-libraries-and-stack-are-placed-on-every-exec-making-it-impossible-to-predict-gadget-addresses-across-exec-boundaries-for-database-engines-that-implement-process-based-connection-isolation-postgresql39s-postmasterbackend-model-exec-after-fork-is-how-each-connection-gets-a-clean-state-the-postmaster-forks-a-child-which-optionally-execs-a-fresh-backend-binary-the-backend-has-a-fresh-address-space-with-no-inherited-heap-fragments-memory-leaks-or-leftover-state-from-other-connections-your-ptrace_event_exec-handler-clearing-cached-state-when-exec-fires-is-the-minimal-correct-response-to-this-reality-the-next-time-you-build-anything-that-persists-state-across-exec-boundaries-a-container-runtime-a-process-supervisor-a-debugging-framework-you39ll-know-exactly-which-state-survives-exec-pid-file-descriptors-without-o_cloexec-certain-kernel-state-and-which-does-not-everything-in-the-address-space\"><code>exec()</code> is the most radical operation in Unix process management. The kernel discards the old address space and installs a new one in a single atomic operation from the process&#39;s perspective. For your tracer, this creates a fundamental discontinuity: any memory address you read from the tracee before exec is now meaningless.\nThis is the same concept that makes certain security vulnerabilities dangerous. Return-oriented programming (ROP) attacks chain together existing code fragments (&quot;gadgets&quot;) in the target process&#39;s memory. If the target calls <code>exec()</code>, all those gadgets are gone â€” the ROP chain is broken. Address Space Layout Randomization (ASLR) randomizes where libraries and stack are placed on every exec, making it impossible to predict gadget addresses across exec boundaries.\nFor database engines that implement process-based connection isolation (PostgreSQL&#39;s <code>postmaster</code>/<code>backend</code> model), exec after fork is how each connection gets a clean state. The postmaster forks a child, which optionally execs a fresh backend binary. The backend has a fresh address space with no inherited heap fragments, memory leaks, or leftover state from other connections.\nYour <code>PTRACE_EVENT_EXEC</code> handler â€” clearing cached state when exec fires â€” is the minimal correct response to this reality. The next time you build anything that persists state across exec boundaries (a container runtime, a process supervisor, a debugging framework), you&#39;ll know exactly which state survives exec (PID, file descriptors without O_CLOEXEC, certain kernel state) and which does not (everything in the address space).</h2>\n<h2 id=\"summary-what-you39ve-built\">Summary: What You&#39;ve Built</h2>\n<p>Your tracer now:</p>\n<ul>\n<li>Sets <code>PTRACE_O_TRACEFORK</code>, <code>PTRACE_O_TRACEVFORK</code>, <code>PTRACE_O_TRACECLONE</code>, and <code>PTRACE_O_TRACEEXEC</code> options so the kernel atomically attaches to every child process, with no race window</li>\n<li>Uses <code>waitpid(-1)</code> to receive events from <em>any</em> traced process, with the returned PID identifying which process stopped</li>\n<li>Decodes the <code>status &gt;&gt; 16</code> bits to distinguish fork, exec, and other ptrace event stops from normal syscall stops</li>\n<li>Calls <code>PTRACE_GETEVENTMSG</code> on fork events to retrieve the new child PID, inserts it into the per-PID state map, and starts the child tracing with an initial <code>PTRACE_SYSCALL</code></li>\n<li>Maintains a hash map (open addressing, 256 slots) of <code>ProcessState</code> structs keyed by PID, each holding the entry/exit toggle and the saved entry register snapshot</li>\n<li>Tags every output line with <code>[pid NNNN]</code> to identify which process made each syscall</li>\n<li>Resets per-PID cached state (toggle, entry_regs) when <code>PTRACE_EVENT_EXEC</code> fires, because the address space has been entirely replaced</li>\n<li>Tracks an <code>active_count</code> and exits the main loop when all traced processes have exited\nMilestone 4 will add the final layer: syscall filtering by name (<code>-e trace=open,read</code>), wall-clock timing with <code>CLOCK_MONOTONIC</code>, summary statistics tables, file output redirection, and <code>PTRACE_ATTACH</code> for tracing already-running processes.</li>\n</ul>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-strace-m4 -->\n<h1 id=\"milestone-4-filtering-and-statistics\">Milestone 4: Filtering and Statistics</h1>\n<h2 id=\"where-you-are-now\">Where You Are Now</h2>\n<p>Your Milestone 3 tracer follows entire process trees, producing beautifully tagged output across every forked child and exec&#39;d program:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[pid 12345] execve(&quot;/bin/bash&quot;, [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;make -j4&quot;], ...) = 0\n[pid 12345] clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|SIGCHLD) = 12346\n[pid 12346] execve(&quot;/usr/bin/gcc&quot;, [&quot;/usr/bin/gcc&quot;, &quot;-O2&quot;, &quot;main.c&quot;, &quot;-o&quot;, &quot;main&quot;], ...) = 0\n[pid 12346] openat(AT_FDCWD, &quot;/usr/include/stdio.h&quot;, O_RDONLY|O_CLOEXEC) = 3\n[pid 12346] read(3, &quot;...&quot;, 4096) = 4096\n... (thousands more lines) ...\n[pid 12345] +++ exited with 0 +++</code></pre></div>\n<p>This works. But it has two practical problems that you&#39;ll hit immediately when using it on real workloads.\n<strong>First</strong>: volume. Running <code>make -j4</code> on a moderate codebase generates tens of thousands of syscall lines. You&#39;re debugging a file-not-found error â€” you care about <code>openat</code> calls, not the thousands of <code>mmap</code>, <code>brk</code>, and <code>futex</code> calls surrounding them. You need to filter.\n<strong>Second</strong>: insight. After your trace runs, you want to know: which syscall took the most time? Which one failed most often? Is this program spending 80% of its time in <code>read</code> or <code>write</code>? The raw trace is a log â€” what you need is a <em>summary</em>. Real strace&#39;s <code>-c</code> flag prints exactly this, and it&#39;s one of the most useful diagnostics tools in production systems work.\nBy the end of this milestone, your tracer will support:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">./strace_clone</span><span style=\"color:#79B8FF\"> -e</span><span style=\"color:#9ECBFF\"> trace=openat,read,write</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> trace.log</span><span style=\"color:#9ECBFF\"> ./target_program</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./strace_clone</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> ./target_program</span><span style=\"color:#6A737D\">          # summary mode: count + time per syscall</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./strace_clone</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#79B8FF\"> 8492</span><span style=\"color:#6A737D\">                     # attach to running process</span></span></code></pre></div>\n<p>And produce, on exit, a summary like:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>% time     seconds  usecs/call     calls    errors  syscall\n------ ----------- ----------- --------- --------- ----------------\n 64.32    0.031423          12      2619         0  read\n 21.17    0.010342          41       252         3  openat\n 10.44    0.005103           4      1277         0  write\n  4.07    0.001989          88        22        18  connect\n  ...\n------ ----------- ----------- --------- --------- ----------------\n100.00    0.048857                  4170        21  total</code></pre></div>\n<p>There are two deceptions hiding in this milestone â€” one about time, one about attachment â€” that almost every first implementation gets wrong. Let&#39;s find them.</p>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m4-timing-overhead.svg\" alt=\"Syscall Timing: What You're Actually Measuring\"></p>\n<hr>\n<h2 id=\"the-core-revelation-you39re-not-timing-the-syscall\">The Core Revelation: You&#39;re Not Timing the Syscall</h2>\n<p>Here is what seems obvious: call <code>clock_gettime()</code> when you receive the entry stop, call it again when you receive the exit stop, subtract. The difference is how long the syscall took.\nThis feels exactly right. Entry stop = syscall starts. Exit stop = syscall ends. Delta = syscall duration.\n<strong>It&#39;s wrong.</strong> Not wrong in a subtle, edge-case way â€” wrong in a fundamental way that makes your measurements 10x to 100x too large for fast syscalls.\nThink through what actually happens between your entry <code>clock_gettime()</code> and your exit <code>clock_gettime()</code>:</p>\n<ol>\n<li>The kernel delivers the entry stop. Your tracer&#39;s <code>waitpid</code> returns.</li>\n<li><strong>Your tracer calls <code>clock_gettime()</code> â€” entry timestamp recorded.</strong></li>\n<li>Your tracer calls <code>PTRACE_GETREGS</code> (one syscall into the kernel).</li>\n<li>Your tracer formats and prints the line (string operations, <code>fprintf</code>).</li>\n<li>Your tracer calls <code>ptrace(PTRACE_SYSCALL, ...)</code> to resume the tracee (another syscall).</li>\n<li>The kernel schedules the tracee. The tracee runs until the next syscall boundary.</li>\n<li>The tracee actually executes the syscall (say, <code>getpid</code> â€” about 100 nanoseconds).</li>\n<li>The kernel stops the tracee at the exit boundary. The tracer&#39;s <code>waitpid</code> returns.</li>\n<li>Your tracer calls <code>PTRACE_GETREGS</code> again (another syscall into the kernel).</li>\n<li><strong>Your tracer calls <code>clock_gettime()</code> â€” exit timestamp recorded.</strong>\nThe delta between steps 2 and 10 includes: <code>PTRACE_GETREGS</code>, formatting, <code>fprintf</code>, <code>PTRACE_SYSCALL</code>, kernel scheduling, the actual syscall, another kernel wake-up, another <code>PTRACE_GETREGS</code>. That&#39;s easily 10â€“50 microseconds of overhead wrapping a <code>getpid</code> call that takes ~100 nanoseconds.\nYour measurement: 10â€“50Âµs. Actual syscall: 0.1Âµs. <strong>Error factor: 100â€“500Ã—.</strong><blockquote>\n<p><strong>What you&#39;re actually measuring</strong>: wall-clock time from &quot;tracer noticed entry&quot; to &quot;tracer noticed exit&quot; â€” which is dominated by ptrace overhead, not by the syscall itself.\nReal strace knows this and says so. Look at the bottom of its <code>-c</code> output:</p>\n</blockquote>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>% time     seconds  usecs/call  ...</code></pre></div>\n<p>It says &quot;seconds,&quot; not &quot;CPU time.&quot; In <code>strace(1)</code> man page: <em>&quot;the values in &#39;seconds&#39; column may be much larger than actual time spent executing system calls since the wall-clock time includes the time spent waiting for the tracer to handle events.&quot;</em>\nThis isn&#39;t a bug in your implementation â€” it&#39;s an inherent property of the ptrace observation model. The act of observing adds overhead. Your summary table is still <em>useful</em>: relative percentages tell you which syscalls dominate <em>even accounting for overhead</em>, and call counts are always accurate. Just don&#39;t mistake your timing for true syscall latency.\nThe lesson: <strong>build the timing correctly, understand what it measures, and communicate it honestly in your output.</strong>\nNow, the second deception: which clock to use.</p>\n<h3 id=\"clock_monotonic-vs-clock_realtime\">CLOCK_MONOTONIC vs CLOCK_REALTIME</h3>\n<p><code>clock_gettime()</code> accepts a clock ID that selects which clock source to read. Two are relevant here:\n<strong><code>CLOCK_REALTIME</code></strong> â€” The system&#39;s wall clock. This matches what you&#39;d see on a clock on the wall. It can be adjusted: Network Time Protocol (NTP) can step the clock forward or backward to synchronize it with time servers. If NTP steps the clock backward by 100ms between your entry and exit timestamps, you get a negative duration. If NTP steps it forward, you get an inflated duration. Real-time adjustments happen routinely on any server running <code>ntpd</code> or <code>chronyd</code>.\n<strong><code>CLOCK_MONOTONIC</code></strong> â€” A clock that only ever goes forward, monotonically. It has no epoch (it doesn&#39;t represent &quot;time since 1970&quot;) â€” it&#39;s just a counter that increases at a stable rate. NTP cannot adjust it backward. It may be slewed (gradually sped up or slowed down) to stay close to real time, but it never jumps. For measuring durations, this is the correct choice.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> timespec ts;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">clock_gettime</span><span style=\"color:#E1E4E8\">(CLOCK_MONOTONIC, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">ts</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* ts.tv_sec is seconds, ts.tv_nsec is nanoseconds [0, 999999999] */</span></span></code></pre></div>\n<p>To compute a duration in nanoseconds:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Compute elapsed nanoseconds between two timespec values */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#B392F0\"> timespec_diff_ns</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> timespec </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">start</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                  const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> timespec </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">end</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\">)(end->tv_sec  </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start->tv_sec)  </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1000000000</span><span style=\"color:#F97583\">LL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">         +</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\">)(end->tv_nsec </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start->tv_nsec);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"always-use-clock_monotonic-for-measuring-durations-between-two-events-always-use-clock_realtime-only-when-you-need-the-actual-calendar-time\"><strong>Always use <code>CLOCK_MONOTONIC</code> for measuring durations between two events. Always use <code>CLOCK_REALTIME</code> only when you need the actual calendar time.</strong></h2>\n<h2 id=\"extending-per-pid-state-for-timing\">Extending Per-PID State for Timing</h2>\n<p>To record timing, you need to store the entry timestamp alongside the entry registers in your per-PID state struct. Add a <code>timespec</code> field:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\">                   pid;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">                     in_syscall;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> user_regs_struct entry_regs;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> timespec         entry_time;</span><span style=\"color:#6A737D\">   /* CLOCK_MONOTONIC timestamp at entry */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">                     valid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ProcessState;</span></span></code></pre></div>\n<p>Memory layout update (from Milestone 3&#39;s 232-byte struct):</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Size</th>\n<th>Offset</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>pid</code></td>\n<td><code>pid_t</code> (int)</td>\n<td>4 bytes</td>\n<td>0</td>\n</tr>\n<tr>\n<td><code>in_syscall</code></td>\n<td><code>int</code></td>\n<td>4 bytes</td>\n<td>4</td>\n</tr>\n<tr>\n<td><code>entry_regs</code></td>\n<td><code>struct user_regs_struct</code></td>\n<td>216 bytes</td>\n<td>8</td>\n</tr>\n<tr>\n<td><code>entry_time</code></td>\n<td><code>struct timespec</code></td>\n<td>16 bytes</td>\n<td>224</td>\n</tr>\n<tr>\n<td><code>valid</code></td>\n<td><code>int</code></td>\n<td>4 bytes</td>\n<td>240</td>\n</tr>\n<tr>\n<td>(padding)</td>\n<td>â€”</td>\n<td>4 bytes</td>\n<td>244</td>\n</tr>\n<tr>\n<td><strong>Total</strong></td>\n<td></td>\n<td><strong>248 bytes</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>On entry stop, record the timestamp immediately after <code>PTRACE_GETREGS</code> returns:</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (state</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">in_syscall </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Entry stop */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state->entry_regs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> regs;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    clock_gettime</span><span style=\"color:#E1E4E8\">(CLOCK_MONOTONIC, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">state->entry_time);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state->in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>On exit stop, compute the duration and pass it to the statistics accumulator:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Exit stop */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> timespec exit_time;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    clock_gettime</span><span style=\"color:#E1E4E8\">(CLOCK_MONOTONIC, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">exit_time);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> elapsed_ns </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> timespec_diff_ns</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">state->entry_time, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">exit_time);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\"> syscall_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)state->entry_regs.orig_rax;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\"> return_val  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)regs.rax;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">  is_error    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (return_val </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#F97583\">L</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> return_val </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">L</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    stats_record</span><span style=\"color:#E1E4E8\">(syscall_num, elapsed_ns, is_error);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    print_syscall</span><span style=\"color:#E1E4E8\">(stopped_pid,</span><span style=\"color:#6A737D\"> /*show_pid=*/</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">state->entry_regs, return_val);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state->in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"building-the-statistics-accumulator\">Building the Statistics Accumulator</h2>\n<p>The statistics table needs to track, per syscall number:</p>\n<ul>\n<li>Total call count</li>\n<li>Error count</li>\n<li>Cumulative time (nanoseconds)\nAt the end of the trace, you sort by cumulative time descending and print the table.\n{{DIAGRAM:diag-m4-statistics-table}}\nDefine the accumulator structure:</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_SYSCALL_NUM</span><span style=\"color:#79B8FF\"> 335</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> total_ns;</span><span style=\"color:#6A737D\">    /* Cumulative nanoseconds (measured, overhead-inclusive) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\">      call_count;</span><span style=\"color:#6A737D\">  /* Total invocations */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\">      error_count;</span><span style=\"color:#6A737D\"> /* Invocations that returned error ([-4096, -1]) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} SyscallStats;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#E1E4E8\"> SyscallStats </span><span style=\"color:#FFAB70\">stats</span><span style=\"color:#E1E4E8\">[MAX_SYSCALL_NUM </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> stats_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(stats, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(stats));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> stats_record</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">long</span><span style=\"color:#FFAB70\"> syscall_num</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> elapsed_ns</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> is_error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (syscall_num </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> syscall_num </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> MAX_SYSCALL_NUM) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    stats</span><span style=\"color:#E1E4E8\">[syscall_num].total_ns   </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> elapsed_ns;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    stats</span><span style=\"color:#E1E4E8\">[syscall_num].call_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (is_error) </span><span style=\"color:#FFAB70\">stats</span><span style=\"color:#E1E4E8\">[syscall_num].error_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>The accumulator is an array indexed by syscall number â€” O(1) update per syscall, no allocation, perfect cache behavior. The entire array is <code>336 Ã— (8 + 8 + 8) = 8,064 bytes</code> â€” fits in L1 cache (typically 32 KB). Every <code>stats_record</code> call touches exactly one 64-byte cache line within this array (the <code>SyscallStats</code> for that syscall number), and the hot syscalls stay permanently warm.</p>\n<h3 id=\"printing-the-summary-table\">Printing the Summary Table</h3>\n<p>When tracing ends, sort by <code>total_ns</code> descending and print. Because you&#39;re sorting a fixed-size array of 336 elements, even an O(nÂ²) sort is instantaneous. Use <code>qsort</code> with a custom comparator on an index array:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> stats_print</span><span style=\"color:#E1E4E8\">(FILE </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">out</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Build index array of syscalls that had at least one call */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#FFAB70\"> indices</span><span style=\"color:#E1E4E8\">[MAX_SYSCALL_NUM </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> grand_total_ns </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\"> grand_calls </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\"> grand_errors </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> MAX_SYSCALL_NUM; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">stats</span><span style=\"color:#E1E4E8\">[i].call_count </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            indices</span><span style=\"color:#E1E4E8\">[count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            grand_total_ns </span><span style=\"color:#F97583\">+=</span><span style=\"color:#FFAB70\"> stats</span><span style=\"color:#E1E4E8\">[i].total_ns;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            grand_calls    </span><span style=\"color:#F97583\">+=</span><span style=\"color:#FFAB70\"> stats</span><span style=\"color:#E1E4E8\">[i].call_count;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            grand_errors   </span><span style=\"color:#F97583\">+=</span><span style=\"color:#FFAB70\"> stats</span><span style=\"color:#E1E4E8\">[i].error_count;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Sort by total_ns descending using qsort with a comparator */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* comparator captures stats[] via global â€” acceptable here */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    qsort</span><span style=\"color:#E1E4E8\">(indices, count, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">), compare_by_total_ns);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Print header */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(out, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%%</span><span style=\"color:#9ECBFF\"> time     seconds  usecs/call     calls    errors  syscall</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(out, </span><span style=\"color:#9ECBFF\">\"------ ----------- ----------- --------- --------- ----------------</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Print each row */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> count; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> indices</span><span style=\"color:#E1E4E8\">[i];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        double</span><span style=\"color:#E1E4E8\"> pct      </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (grand_total_ns </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                          ?</span><span style=\"color:#79B8FF\"> 100.0</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\"> stats</span><span style=\"color:#E1E4E8\">[n].total_ns </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> grand_total_ns</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                          :</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        double</span><span style=\"color:#E1E4E8\"> secs     </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> stats</span><span style=\"color:#E1E4E8\">[n].total_ns </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">e</span><span style=\"color:#79B8FF\">9</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        long</span><span style=\"color:#E1E4E8\">   usecs_pc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">stats</span><span style=\"color:#E1E4E8\">[n].call_count </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                          ?</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#FFAB70\">stats</span><span style=\"color:#E1E4E8\">[n].total_ns </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#F97583\"> /</span><span style=\"color:#FFAB70\"> stats</span><span style=\"color:#E1E4E8\">[n].call_count)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                          :</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(out, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%6.2f</span><span style=\"color:#79B8FF\"> %11.6f</span><span style=\"color:#79B8FF\"> %11ld</span><span style=\"color:#79B8FF\"> %9ld</span><span style=\"color:#79B8FF\"> %9ld</span><span style=\"color:#79B8FF\">  %s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                pct, secs, usecs_pc,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                stats</span><span style=\"color:#E1E4E8\">[n].call_count, </span><span style=\"color:#FFAB70\">stats</span><span style=\"color:#E1E4E8\">[n].error_count,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                syscall_name</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)n));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Print footer */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(out, </span><span style=\"color:#9ECBFF\">\"------ ----------- ----------- --------- --------- ----------------</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(out, </span><span style=\"color:#9ECBFF\">\"100.00 </span><span style=\"color:#79B8FF\">%11.6f</span><span style=\"color:#79B8FF\">           %9ld</span><span style=\"color:#79B8FF\"> %9ld</span><span style=\"color:#9ECBFF\">  total</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            grand_total_ns </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">e</span><span style=\"color:#79B8FF\">9</span><span style=\"color:#E1E4E8\">, grand_calls, grand_errors);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* qsort comparator: sort indices by total_ns descending */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> compare_by_total_ns</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ia </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> int</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)a;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ib </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> int</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)b;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">stats</span><span style=\"color:#E1E4E8\">[ib].total_ns </span><span style=\"color:#F97583\">></span><span style=\"color:#FFAB70\"> stats</span><span style=\"color:#E1E4E8\">[ia].total_ns) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\">  1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">stats</span><span style=\"color:#E1E4E8\">[ib].total_ns </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#FFAB70\"> stats</span><span style=\"color:#E1E4E8\">[ia].total_ns) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"note-that-the-summary-is-printed-to-stderr-by-default-or-to-the-o-file-if-specified-we39ll-set-that-up-shortly-when-you-print-the-normal-trace-output-to-stderr-and-the-summary-also-to-stderr-you-can-redirect-them-independently\">Note that the summary is printed to <code>stderr</code> by default (or to the <code>-o</code> file if specified â€” we&#39;ll set that up shortly). When you print the normal trace output to <code>stderr</code> and the summary also to <code>stderr</code>, you can redirect them independently.</h2>\n<h2 id=\"syscall-filtering-with-e-trace\">Syscall Filtering with -e trace=</h2>\n<p>The <code>-e trace=</code> flag tells your tracer which syscalls to <em>print</em>. Crucially, you still trace everything (all syscalls still trigger stops, the toggle still fires, statistics still accumulate) â€” you just skip the print step for syscalls not in the filter set.</p>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m4-filter-architecture.svg\" alt=\"Syscall Filter: Trace Everything, Print Selectively\"></p>\n<p>This distinction matters enormously. If you tried to <em>not trace</em> certain syscalls, you&#39;d need to implement selective PTRACE_SYSCALL behavior, which doesn&#39;t exist at the ptrace API level â€” ptrace gives you all-or-nothing interception. More importantly, even if you skip printing <code>mmap</code>, you still need to count it for the statistics table. The filter is purely a <em>display</em> filter, not a tracing filter.</p>\n<h3 id=\"parsing-the-filter-string\">Parsing the Filter String</h3>\n<p>The flag syntax is <code>-e trace=open,read,write</code>. Parse it at startup:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_FILTER_SYSCALLS</span><span style=\"color:#79B8FF\"> 64</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">     enabled;</span><span style=\"color:#6A737D\">                          /* 1 if filter is active */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">     count;</span><span style=\"color:#6A737D\">                            /* Number of names in filter */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\">    names</span><span style=\"color:#E1E4E8\">[MAX_FILTER_SYSCALLS][</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">   /* Syscall names to show */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#FFAB70\">     nums</span><span style=\"color:#E1E4E8\">[MAX_FILTER_SYSCALLS];</span><span style=\"color:#6A737D\">        /* Corresponding syscall numbers (-1 if unknown) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} SyscallFilter;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#E1E4E8\"> SyscallFilter filter </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { .enabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Parse \"-e trace=open,read,write\" into the filter struct.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * 'spec' points to the string after \"trace=\" */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> filter_parse</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">spec</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filter.enabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filter.count   </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strncpy</span><span style=\"color:#E1E4E8\">(buf, spec, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(buf) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(buf) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">tok </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strtok</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#9ECBFF\">\",\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (tok </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> filter.count </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> MAX_FILTER_SYSCALLS) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        strncpy</span><span style=\"color:#E1E4E8\">(filter.names[filter.count], tok, </span><span style=\"color:#79B8FF\">31</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        filter.names[filter.count][</span><span style=\"color:#79B8FF\">31</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Try to resolve name to number at parse time for O(1) lookup */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        filter.nums[filter.count] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> syscall_num_by_name</span><span style=\"color:#E1E4E8\">(tok);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        filter.count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tok </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strtok</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\",\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Returns 1 if syscall_num passes the filter (should be printed), 0 if not */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> filter_passes</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">long</span><span style=\"color:#FFAB70\"> syscall_num</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">filter.enabled) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* No filter: print everything */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> filter.count; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (filter.nums[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)syscall_num) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><code>syscall_num_by_name()</code> requires a reverse lookup: name â†’ number. The simplest implementation is a linear scan of your <code>syscall_names[]</code> array from Milestone 2:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> syscall_num_by_name</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> MAX_SYSCALL_NUM; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">syscall_names</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#B392F0\"> strcmp</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">syscall_names</span><span style=\"color:#E1E4E8\">[i], name) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Unknown name */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>This is O(n) and runs once at startup â€” completely acceptable. If an unknown name is given, <code>filter.nums[i] = -1</code>, which will never match a real syscall number (syscall numbers are â‰¥ 0), so the filter silently ignores unrecognized names. You could warn the user; real strace does.</p>\n<h3 id=\"applying-the-filter\">Applying the Filter</h3>\n<p>In <code>print_syscall()</code>, add the filter check before formatting output:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> print_syscall</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> pid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> show_pid</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                   struct</span><span style=\"color:#E1E4E8\"> user_regs_struct </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">entry_regs</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                   long</span><span style=\"color:#FFAB70\"> return_val</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                   FILE </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">out</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\"> syscall_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)entry_regs->orig_rax;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Filter check: only print if this syscall passes the display filter */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">filter_passes</span><span style=\"color:#E1E4E8\">(syscall_num)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ... rest of formatting ... */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"note-stats_record-is-called-before-print_syscall-in-the-exit-handler-so-statistics-always-accumulate-regardless-of-the-filter-the-filter-only-gates-printing\">Note: <code>stats_record()</code> is called <em>before</em> <code>print_syscall()</code> in the exit handler, so statistics always accumulate regardless of the filter. The filter only gates printing.</h2>\n<h2 id=\"file-output-with-o\">File Output with -o</h2>\n<p>The <code>-o filename</code> flag redirects trace output from <code>stderr</code> to a file. The design decision here is how to handle the file handle throughout the codebase.\nThe cleanest approach: a global <code>FILE *trace_out</code> that defaults to <code>stderr</code> and is set to the opened file if <code>-o</code> is given. Every print call uses <code>trace_out</code> instead of <code>stderr</code>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#E1E4E8\"> FILE </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">trace_out </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Set in main() */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tracer_init_output</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">filename</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (filename </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        trace_out </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fopen</span><span style=\"color:#E1E4E8\">(filename, </span><span style=\"color:#9ECBFF\">\"w\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (trace_out </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"fopen output file\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        trace_out </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> stderr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>For multi-process traces, multiple processes may have syscalls completing in the same <code>waitpid</code> batch. Since you process one event at a time (your loop is single-threaded), there&#39;s no concurrent write issue â€” each <code>fprintf(trace_out, ...)</code> call is fully sequential. If you were using threads, you&#39;d need a mutex around writes. With your single-threaded event loop, the sequential guarantee is free.\nClean up on exit:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tracer_close_output</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (trace_out </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> trace_out </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> stderr) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fclose</span><span style=\"color:#E1E4E8\">(trace_out);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"the-summary-table-stats_print-should-write-to-the-same-trace_out-file-if-o-is-active-if-no-o-flag-is-used-write-the-summary-to-stderr-so-it-appears-in-the-terminal-even-when-the-trace-is-piped-elsewhere\">The summary table (<code>stats_print</code>) should write to the same <code>trace_out</code> file if <code>-o</code> is active. If no <code>-o</code> flag is used, write the summary to <code>stderr</code> (so it appears in the terminal even when the trace is piped elsewhere).</h2>\n<h2 id=\"command-line-argument-parsing\">Command-Line Argument Parsing</h2>\n<p>Now that you have <code>-e</code>, <code>-o</code>, <code>-p</code>, and <code>-c</code> flags, you need structured argument parsing. <code>getopt()</code> is the POSIX standard:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;getopt.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">output_file;</span><span style=\"color:#6A737D\">    /* -o filename, or NULL */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">filter_spec;</span><span style=\"color:#6A737D\">    /* -e trace=..., or NULL */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\">       attach_pid;</span><span style=\"color:#6A737D\">     /* -p PID, or 0 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">         summary_mode;</span><span style=\"color:#6A737D\">   /* -c flag */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* argv for the program to run (after options), or NULL if -p */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\">      **</span><span style=\"color:#E1E4E8\">target_argv;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} TracerOptions;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">TracerOptions </span><span style=\"color:#B392F0\">parse_options</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#F97583\">[]</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TracerOptions opts </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> opt;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> ((opt </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> getopt</span><span style=\"color:#E1E4E8\">(argc, argv, </span><span style=\"color:#9ECBFF\">\"o:e:p:c\"</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        switch</span><span style=\"color:#E1E4E8\"> (opt) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> 'o'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            opts.output_file </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> optarg;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> 'e'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Expect \"trace=name,name,...\" */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strncmp</span><span style=\"color:#E1E4E8\">(optarg, </span><span style=\"color:#9ECBFF\">\"trace=\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                opts.filter_spec </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> optarg </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Unknown -e option: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, optarg);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> 'p'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            opts.attach_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">atoi</span><span style=\"color:#E1E4E8\">(optarg);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (opts.attach_pid </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Invalid PID: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, optarg);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> 'c'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            opts.summary_mode </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Usage: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> [-o file] [-e trace=...] [-c] \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                            \"[-p pid | program [args...]]</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (opts.attach_pid </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (optind </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> argc) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Need -p PID or a program to run</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        opts.target_argv </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[optind];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> opts;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"getopt-is-posix-standard-and-available-on-any-linux-system-optarg-is-a-global-pointer-to-the-current-option39s-argument-optind-is-the-index-of-the-first-non-option-argument-after-processing-pointing-at-your-target-program39s-argv\"><code>getopt()</code> is POSIX-standard and available on any Linux system. <code>optarg</code> is a global pointer to the current option&#39;s argument. <code>optind</code> is the index of the first non-option argument after processing â€” pointing at your target program&#39;s <code>argv</code>.</h2>\n<h2 id=\"ptrace_attach-tracing-a-running-process\">PTRACE_ATTACH: Tracing a Running Process</h2>\n<p>Everything you&#39;ve built so far assumes you start the tracee yourself: fork, PTRACE_TRACEME, exec. But one of strace&#39;s most powerful features is <code>-p PID</code>: attach to an <em>already-running</em> process without restarting it. This requires a completely different entry point into the ptrace lifecycle.</p>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m4-attach-vs-fork.svg\" alt=\"PTRACE_ATTACH vs Fork+TRACEME: Two Entry Points\"></p>\n<h3 id=\"how-ptrace_attach-works\">How PTRACE_ATTACH Works</h3>\n<p><code>ptrace(PTRACE_ATTACH, pid, NULL, NULL)</code> tells the kernel: &quot;I want to become the tracer for process <code>pid</code>.&quot; The kernel:</p>\n<ol>\n<li>Checks that you have permission (you must be the process owner, or have <code>CAP_SYS_PTRACE</code> capability).</li>\n<li>Sets the <code>PT_TRACED</code> flag on the target process&#39;s <code>task_struct</code>.</li>\n<li><strong>Sends <code>SIGSTOP</code> to the target process.</strong> This stops it so you can set up the tracing relationship cleanly.</li>\n<li>Returns 0 to your tracer.\nThe <code>SIGSTOP</code> is critical â€” and it&#39;s also a source of disruption. The target process was running happily; you&#39;ve now injected a <code>SIGSTOP</code> into it. Any signal handlers the target has for <code>SIGSTOP</code> will fire. The process is visibly paused. If it was in the middle of a critical section, holding a mutex, or doing time-sensitive I/O, the <code>SIGSTOP</code> interrupts that.\nThis is why a newer API exists â€” but let&#39;s first implement <code>PTRACE_ATTACH</code> correctly, then discuss the alternative.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> attach_to_process</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> pid</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_ATTACH, pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ptrace PTRACE_ATTACH\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EPERM) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Permission denied. Try running as root, or:</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"  echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Wait for the SIGSTOP that PTRACE_ATTACH sends */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> stopped </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> waitpid</span><span style=\"color:#E1E4E8\">(pid, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (stopped </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"waitpid after PTRACE_ATTACH\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">WIFSTOPPED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Process </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> did not stop after PTRACE_ATTACH</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, pid);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* The stop signal should be SIGSTOP (or occasionally SIGTRAP).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Either way, we don't re-inject it â€” it was our attachment signal. */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Set the same options as in the fork case */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\"> opts </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PTRACE_O_TRACESYSGOOD</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               |</span><span style=\"color:#E1E4E8\"> PTRACE_O_TRACEFORK</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               |</span><span style=\"color:#E1E4E8\"> PTRACE_O_TRACEVFORK</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               |</span><span style=\"color:#E1E4E8\"> PTRACE_O_TRACECLONE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               |</span><span style=\"color:#E1E4E8\"> PTRACE_O_TRACEEXEC;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SETOPTIONS, pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)opts) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ptrace SETOPTIONS after ATTACH\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Create state for this PID and start tracing */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ProcessState </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">state </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> state_map_insert</span><span style=\"color:#E1E4E8\">(pid);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state->in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    active_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Resume the process â€” it will now be traced */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ptrace PTRACE_SYSCALL after ATTACH\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"the-ptrace_scope-permission-wall\">The ptrace_scope Permission Wall</h3>\n<p>Modern Linux kernels restrict which processes can trace which other processes, controlled by <code>/proc/sys/kernel/yama/ptrace_scope</code>:</p>\n<table>\n<thead>\n<tr>\n<th>Value</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>Permissive: any process can trace any other process it owns</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Restricted: can only trace children or processes that called <code>prctl(PR_SET_PTRACER, tracer_pid)</code></td>\n</tr>\n<tr>\n<td>2</td>\n<td>Admin-only: only processes with <code>CAP_SYS_PTRACE</code> can trace</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Completely disabled</td>\n</tr>\n<tr>\n<td>Most desktop Linux distributions default to 1. This means <code>PTRACE_ATTACH</code> on an arbitrary process will fail with <code>EPERM</code> unless you&#39;re root or the target has explicitly allowed it. Your code already handles this with the helpful error message. For development, running as root or temporarily setting <code>ptrace_scope</code> to 0 is the pragmatic approach.</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"key-difference-from-forktraceme\">Key Difference from Fork+TRACEME</h3>\n<h2 id=\"with-forktraceme-the-tracee-starts-in-a-controlled-state-it-requested-tracing-exec39d-the-target-program-and-paused-at-the-post-exec-sigtrap-the-toggle-starts-at-0-not-mid-syscall-the-address-space-is-fresh-with-ptrace_attach-the-target-process-might-be-anywhere-in-its-execution-inside-a-syscall-having-executed-the-syscall-instruction-but-not-yet-returned-between-syscalls-in-a-signal-handler-you-cannot-know-the-toggle-must-conservatively-start-at-0-assume-you39re-at-an-entry-boundary-and-the-first-stop-after-ptrace_syscall-will-tell-you-more-if-the-process-was-stopped-mid-syscall-you39ll-get-an-exit-stop-first-which-with-toggle-at-0-you39d-misidentify-as-an-entry-stop-this-produces-one-garbage-print-then-the-trace-self-corrects-real-strace-handles-this-edge-case-by-checking-orig_rax-on-the-first-stop-to-determine-whether-it-looks-like-an-entry-or-exit-for-this-milestone-the-conservative-approach-start-at-0-is-acceptable\">With fork+TRACEME, the tracee starts in a controlled state: it requested tracing, exec&#39;d the target program, and paused at the post-exec SIGTRAP. The toggle starts at 0 (not mid-syscall). The address space is fresh.\nWith PTRACE_ATTACH, the target process might be <em>anywhere</em> in its execution: inside a syscall (having executed the <code>syscall</code> instruction but not yet returned), between syscalls, in a signal handler. You cannot know. The toggle must conservatively start at 0 (assume you&#39;re at an entry boundary), and the first stop after <code>PTRACE_SYSCALL</code> will tell you more. If the process was stopped mid-syscall, you&#39;ll get an exit stop first â€” which, with toggle at 0, you&#39;d misidentify as an entry stop. This produces one garbage print, then the trace self-corrects. Real strace handles this edge case by checking <code>orig_rax</code> on the first stop to determine whether it looks like an entry or exit. For this milestone, the conservative approach (start at 0) is acceptable.</h2>\n<h2 id=\"clean-detach-the-sigint-handler\">Clean Detach: The SIGINT Handler</h2>\n<p>When your tracer receives <code>SIGINT</code> (Ctrl+C), it must not simply <code>exit()</code>. If the tracee is ptrace-traced and the tracer exits without detaching, the kernel sends <code>SIGHUP</code> to the tracee, which typically kills it. That&#39;s not what users expect from &quot;press Ctrl+C to stop tracing&quot; â€” they expect the traced process to continue running normally.\nThe correct sequence on tracer exit when using <code>PTRACE_ATTACH</code>:</p>\n<ol>\n<li>The tracee must be in a <strong>stopped state</strong> for <code>PTRACE_DETACH</code> to succeed.</li>\n<li>If the tracee is running (between stops), you must send it <code>SIGSTOP</code> and wait for it to stop.</li>\n<li>Call <code>ptrace(PTRACE_DETACH, pid, NULL, NULL)</code>.</li>\n<li>The tracee resumes as if it was never traced.</li>\n</ol>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Fdiag-m4-clean-detach.svg\" alt=\"Clean Detach Sequence on SIGINT\"></p>\n<p>If you forked the tracee yourself (not PTRACE_ATTACH mode), the user probably wants to kill it when they Ctrl+C. In that case, you can let the default SIGINT behavior kill both tracer and tracee via the terminal&#39;s process group signal delivery.\nThe tricky part: your <code>SIGINT</code> handler runs <em>asynchronously</em>, while your main loop might be anywhere. Signal safety rules restrict what you can call from a signal handler â€” you cannot call <code>ptrace()</code> or <code>waitpid()</code> from a signal handler, because they may allocate memory or modify global state in non-reentrant ways.\nThe correct pattern: use a flag and handle detach in the main loop.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;signal.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#79B8FF\"> sig_atomic_t</span><span style=\"color:#E1E4E8\"> g_interrupted </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> pid_t</span><span style=\"color:#E1E4E8\"> g_attached_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Set if we used PTRACE_ATTACH */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> sigint_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> sig</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)sig;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    g_interrupted </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> install_sigint_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> sigaction sa;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sa, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(sa));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sa.sa_handler </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sigint_handler;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sigemptyset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sa.sa_mask);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sa.sa_flags </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* No SA_RESTART: let syscalls (waitpid) be interrupted */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sigaction</span><span style=\"color:#E1E4E8\">(SIGINT, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sa, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>In the main loop, check <code>g_interrupted</code> after each <code>waitpid</code> return:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (active_count </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> stopped_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> waitpid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (stopped_pid </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EINTR) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* waitpid was interrupted â€” could be SIGINT */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (g_interrupted) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                handle_interrupt</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ECHILD) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"waitpid\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ... normal event handling ... */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Check interrupt flag between events */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (g_interrupted) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        handle_interrupt</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>The detach sequence, called from the main loop context (safe to call ptrace here):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> handle_interrupt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (g_attached_pid </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* We attached to a running process â€” detach cleanly */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* The process may or may not be stopped right now.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * PTRACE_DETACH requires the tracee to be stopped.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Send SIGSTOP and wait for it. */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kill</span><span style=\"color:#E1E4E8\">(g_attached_pid, SIGSTOP);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        waitpid</span><span style=\"color:#E1E4E8\">(g_attached_pid, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Detach, allowing the process to continue */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_DETACH, g_attached_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Detached from process </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, g_attached_pid);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* We forked the tracee â€” let it die naturally or kill it */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* The traced children will be killed when the tracer exits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * because they're in the same process group */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Interrupted</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Print summary if in summary mode */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (summary_mode) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        stats_print</span><span style=\"color:#E1E4E8\">(stderr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>Why SA_RESTART is not set</strong>: The <code>waitpid()</code> syscall is a blocking wait. When <code>SIGINT</code> arrives, the kernel interrupts <code>waitpid</code> and returns <code>-1</code> with <code>errno == EINTR</code>. Without <code>SA_RESTART</code>, this interruption surfaces to your code so you can check <code>g_interrupted</code>. With <code>SA_RESTART</code>, the kernel would automatically restart <code>waitpid</code>, and you might not notice the signal for a long time (until the next child event). For responsiveness, you want <code>EINTR</code> to propagate.</p>\n</blockquote>\n<hr>\n<h2 id=\"three-level-view-what-ptrace_detach-does\">Three-Level View: What PTRACE_DETACH Does</h2>\n<p>Let&#39;s see detach at all three levels for clarity.\n<strong>Level 1 â€” Application (Tracer)</strong>\nYou call <code>ptrace(PTRACE_DETACH, pid, NULL, NULL)</code>. The function returns 0 on success. The target process starts running again.\n<strong>Level 2 â€” Kernel</strong>\nThe kernel&#39;s <code>ptrace_detach()</code> function:</p>\n<ol>\n<li>Clears the <code>PT_TRACED</code> flag on the target&#39;s <code>task_struct</code>.</li>\n<li>Sets the target&#39;s parent back to its real parent (before you attached, it had been reparented to your tracer for <code>waitpid</code> purposes).</li>\n<li>Removes the target from your tracer&#39;s list of traced children.</li>\n<li>Sends <code>SIGCONT</code> to the target if it was stopped, waking it up.</li>\n<li>Wakes the target&#39;s scheduler entry so it can run.\nThe target process resumes as if <code>ptrace</code> had never happened. Any pending signals that were suppressed during tracing are delivered. Any partial syscall state is intact.\n<strong>Level 3 â€” Hardware</strong>\nFrom the CPU&#39;s perspective, the target process was in <code>TASK_STOPPED</code> state â€” its scheduler entry was removed from the run queue. <code>PTRACE_DETACH</code> re-adds it to the run queue. The next time the scheduler runs (at the next timer interrupt, or immediately if a CPU is idle), the target&#39;s thread is scheduled and its saved <code>RIP</code> register picks up execution exactly where it stopped.\nThe <code>PT_TRACED</code> flag in the kernel&#39;s <code>task_struct</code> is what causes the entry/exit stops to fire. Clearing it stops all future tracing overhead. From that moment, the target process runs at full speed with zero ptrace overhead.</li>\n</ol>\n<hr>\n<h2 id=\"hardware-soul-the-observer-effect-in-practice\">Hardware Soul: The Observer Effect in Practice</h2>\n<p>Your tracer imposes real overhead on the traced process. Let&#39;s quantify it.\n<strong>Per-syscall overhead breakdown</strong> (approximate, 3 GHz x86_64):</p>\n<ul>\n<li>Tracer <code>waitpid</code> returns: ~100 cycles (kernel wake-up)</li>\n<li><code>PTRACE_GETREGS</code>: ~500 cycles (kernel boundary + register copy)</li>\n<li><code>clock_gettime(CLOCK_MONOTONIC)</code>: ~30 cycles (VDSO fast path)</li>\n<li>Filter check (<code>filter_passes</code>): ~10 cycles</li>\n<li><code>fprintf</code> to print line (with format + string ops): ~500â€“5,000 cycles</li>\n<li><code>ptrace(PTRACE_SYSCALL, ...)</code>: ~300 cycles (kernel boundary)</li>\n<li>Context switch tracer â†’ tracee: <del>1,000â€“3,000 cycles\n<strong>Total overhead per traced syscall</strong>: ~3,000â€“10,000 cycles â‰ˆ <strong>1â€“3 microseconds at 3 GHz</strong>.\nFor a syscall like <code>gettimeofday</code> (</del>100 ns = 300 cycles), you&#39;re adding 10â€“30Ã— overhead. For <code>read()</code> on a local SSD (~50â€“100 Âµs), the overhead is negligible (2%).\n<strong>Cache behavior</strong>: Your <code>stats[]</code> array (8 KB) fits entirely in L1 data cache (typically 32 KB). After the first few dozen syscalls, all hot entries are permanently cached. <code>stats_record()</code> is essentially:</li>\n<li>1 bounds check (branch predicted correctly)</li>\n<li>1 L1 cache read + increment + write (Ã—3 fields)</li>\n<li>Total: ~5â€“10 cycles\n<strong>The observer effect on real programs</strong>: If you trace a lock-contention benchmark (many threads fighting over a mutex), the ptrace overhead between syscall entry and exit extends the critical section window. Threads that would have been in and out of the kernel quickly now spend 10â€“50Ã— longer stopped, allowing more contention. Your trace may show <code>futex</code> calls dominating â€” but some of that dominance is <em>caused by</em> the tracing itself. The observed system is not the unobserved system. Keep this in mind when interpreting timing results.</li>\n</ul>\n<hr>\n<h2 id=\"complete-main-function-wiring-everything-together\">Complete Main Function: Wiring Everything Together</h2>\n<p>Here&#39;s how all the new components wire together in <code>main()</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#F97583\">[]</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TracerOptions opts </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> parse_options</span><span style=\"color:#E1E4E8\">(argc, argv);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Initialize subsystems */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    state_map_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    stats_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    tracer_init_output</span><span style=\"color:#E1E4E8\">(opts.output_file);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    install_sigint_handler</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (opts.filter_spec </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        filter_parse</span><span style=\"color:#E1E4E8\">(opts.filter_spec);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (opts.attach_pid </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Attach to running process */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        g_attached_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> opts.attach_pid;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        attach_to_process</span><span style=\"color:#E1E4E8\">(opts.attach_pid);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* active_count set to 1 inside attach_to_process */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Fork and exec the target program */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pid_t</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fork</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (child </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"fork\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (child </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_TRACEME, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            execvp</span><span style=\"color:#E1E4E8\">(opts.target_argv[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], opts.target_argv);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"execvp\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Catch post-exec SIGTRAP */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        waitpid</span><span style=\"color:#E1E4E8\">(child, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">WIFSTOPPED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Unexpected initial status</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        long</span><span style=\"color:#E1E4E8\"> tracer_opts </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PTRACE_O_TRACESYSGOOD</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         |</span><span style=\"color:#E1E4E8\"> PTRACE_O_TRACEFORK</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         |</span><span style=\"color:#E1E4E8\"> PTRACE_O_TRACEVFORK</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         |</span><span style=\"color:#E1E4E8\"> PTRACE_O_TRACECLONE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         |</span><span style=\"color:#E1E4E8\"> PTRACE_O_TRACEEXEC;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SETOPTIONS, child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)tracer_opts);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ProcessState </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">init_state </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> state_map_insert</span><span style=\"color:#E1E4E8\">(child);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        init_state->in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        active_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* â”€â”€ MAIN TRACING LOOP (same structure as Milestone 3) â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (active_count </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pid_t</span><span style=\"color:#E1E4E8\"> stopped_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> waitpid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (stopped_pid </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EINTR </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> g_interrupted) { </span><span style=\"color:#B392F0\">handle_interrupt</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ECHILD) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"waitpid\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (g_interrupted) { </span><span style=\"color:#B392F0\">handle_interrupt</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFEXITED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">opts.summary_mode </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> filter.enabled </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                fprintf</span><span style=\"color:#E1E4E8\">(trace_out, </span><span style=\"color:#9ECBFF\">\"[pid </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">] +++ exited with </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> +++</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        stopped_pid, </span><span style=\"color:#B392F0\">WEXITSTATUS</span><span style=\"color:#E1E4E8\">(status));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            state_map_remove</span><span style=\"color:#E1E4E8\">(stopped_pid);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            active_count</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFSIGNALED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(trace_out, </span><span style=\"color:#9ECBFF\">\"[pid </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">] +++ killed by signal </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">) +++</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    stopped_pid, </span><span style=\"color:#B392F0\">WTERMSIG</span><span style=\"color:#E1E4E8\">(status), </span><span style=\"color:#B392F0\">strsignal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">WTERMSIG</span><span style=\"color:#E1E4E8\">(status)));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            state_map_remove</span><span style=\"color:#E1E4E8\">(stopped_pid);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            active_count</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">WIFSTOPPED</span><span style=\"color:#E1E4E8\">(status)) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> sig   </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> WSTOPSIG</span><span style=\"color:#E1E4E8\">(status);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> event </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (status </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">ff</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ProcessState </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">state </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> state_map_find</span><span style=\"color:#E1E4E8\">(stopped_pid);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (state </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            state </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> state_map_insert</span><span style=\"color:#E1E4E8\">(stopped_pid);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (state </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, stopped_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            active_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (event </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            handle_ptrace_event</span><span style=\"color:#E1E4E8\">(stopped_pid, state, event);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, stopped_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (sig </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (SIGTRAP </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">80</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            struct</span><span style=\"color:#E1E4E8\"> user_regs_struct regs;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_GETREGS, stopped_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">regs) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, stopped_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (state->in_syscall </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* Entry: save regs + timestamp */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                state->entry_regs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> regs;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                clock_gettime</span><span style=\"color:#E1E4E8\">(CLOCK_MONOTONIC, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">state->entry_time);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                state->in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* Exit: compute duration, record stats, maybe print */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                struct</span><span style=\"color:#E1E4E8\"> timespec exit_time;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                clock_gettime</span><span style=\"color:#E1E4E8\">(CLOCK_MONOTONIC, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">exit_time);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> elapsed_ns </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> timespec_diff_ns</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">state->entry_time,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                                        &#x26;</span><span style=\"color:#E1E4E8\">exit_time);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                long</span><span style=\"color:#E1E4E8\"> syscall_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)state->entry_regs.orig_rax;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                long</span><span style=\"color:#E1E4E8\"> return_val  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)regs.rax;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                int</span><span style=\"color:#E1E4E8\">  is_error    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (return_val </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#F97583\">L</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> return_val </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">L</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                stats_record</span><span style=\"color:#E1E4E8\">(syscall_num, elapsed_ns, is_error);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">opts.summary_mode) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    /* Print the syscall line (filtered inside print_syscall) */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    print_syscall</span><span style=\"color:#E1E4E8\">(stopped_pid,</span><span style=\"color:#6A737D\"> /*show_pid=*/</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                  &#x26;</span><span style=\"color:#E1E4E8\">state->entry_regs, return_val, trace_out);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                state->in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, stopped_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (sig </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> SIGTRAP) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, stopped_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Signal-delivery stop: re-inject */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SYSCALL, stopped_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)sig);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Print summary if requested */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (opts.summary_mode) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        stats_print</span><span style=\"color:#E1E4E8\">(stderr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    tracer_close_output</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"common-bugs-in-this-milestone\">Common Bugs in This Milestone</h2>\n<h3 id=\"bug-1-timing-across-the-print\">Bug 1: Timing Across the Print</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG: clock_gettime after fprintf includes I/O time in the measurement */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (state</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">in_syscall </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    clock_gettime</span><span style=\"color:#E1E4E8\">(CLOCK_MONOTONIC, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">state->entry_time);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* ... save regs ... */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(trace_out, </span><span style=\"color:#9ECBFF\">\"entering syscall...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   /* 500â€“5000 cycles of I/O */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state->in_syscall </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>If you print at entry, the I/O time is included between entry and exit timestamps, making the timing wildly inaccurate. Take the <code>clock_gettime</code> immediately after <code>PTRACE_GETREGS</code>, before any I/O. Similarly, take the exit <code>clock_gettime</code> immediately â€” before printing.</p>\n<h3 id=\"bug-2-clock_realtime-for-duration\">Bug 2: CLOCK_REALTIME for Duration</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG: REALTIME can go backwards */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">clock_gettime</span><span style=\"color:#E1E4E8\">(CLOCK_REALTIME, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">state</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">entry_time</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<p>If NTP slews or steps the clock between entry and exit, you get a negative <code>elapsed_ns</code>. Then you add it to <code>stats[n].total_ns</code>, producing a cumulative time that decreases. The summary table shows negative seconds for that syscall. Use <code>CLOCK_MONOTONIC</code>.</p>\n<h3 id=\"bug-3-forgetting-to-wait-for-sigstop-after-ptrace_attach\">Bug 3: Forgetting to Wait for SIGSTOP After PTRACE_ATTACH</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG: skip the waitpid after PTRACE_ATTACH */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_ATTACH, pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SETOPTIONS, pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, opts);</span><span style=\"color:#6A737D\">  /* ESRCH or EIO: process not yet stopped */</span></span></code></pre></div>\n<p><code>PTRACE_ATTACH</code> is asynchronous â€” the kernel sends <code>SIGSTOP</code> to the target, but that signal may not have been delivered and processed by the time your next <code>ptrace</code> call runs. You must <code>waitpid(pid, ...)</code> to confirm the process has stopped before calling any other ptrace request on it.</p>\n<h3 id=\"bug-4-not-filtering-but-still-suppressing-stats\">Bug 4: Not Filtering But Still Suppressing Stats</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG: returning early before stats_record */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> handle_exit_stop</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> pid</span><span style=\"color:#E1E4E8\">, ProcessState </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">state</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                      struct</span><span style=\"color:#E1E4E8\"> user_regs_struct </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">regs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\"> syscall_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)state->entry_regs.orig_rax;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">filter_passes</span><span style=\"color:#E1E4E8\">(syscall_num)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* â† Skips stats! */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\"> return_val </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)regs->rax;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    stats_record</span><span style=\"color:#E1E4E8\">(syscall_num, elapsed_ns, is_error);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    print_syscall</span><span style=\"color:#E1E4E8\">(pid, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">state->entry_regs, return_val, trace_out);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>The filter controls <em>printing</em>, not <em>recording</em>. Call <code>stats_record</code> unconditionally, then conditionally print.</p>\n<h3 id=\"bug-5-ptrace_detach-without-stopping-the-tracee-first\">Bug 5: PTRACE_DETACH Without Stopping the Tracee First</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* WRONG: detaching from a running tracee */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_DETACH, pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  /* May return EIO or corrupt state */</span></span></code></pre></div>\n<p><code>PTRACE_DETACH</code> requires the tracee to be in a ptrace stop. If the tracee is running (between stops), <code>PTRACE_DETACH</code> fails with <code>EIO</code>. You must stop the process first (send <code>SIGSTOP</code>, then <code>waitpid</code>) before detaching.</p>\n<h3 id=\"bug-6-o_rdonly-0-in-stats-vs-quotnot-calledquot\">Bug 6: O_RDONLY = 0 in Stats vs. &quot;Not Called&quot;</h3>\n<h2 id=\"the-stats-array-is-zero-initialized-statsncall_count-0-means-quotnever-calledquot-but-your-accumulation-uses-statsntotal_ns-elapsed_ns-what-if-elapsed_ns-is-0-that39s-fine-it39s-still-a-valid-count-the-danger-is-if-you-mistakenly-print-entries-with-call_count-0-in-the-summary-the-filter-if-statsicall_count-gt-0-before-adding-to-the-print-index-prevents-this\">The <code>stats[]</code> array is zero-initialized. <code>stats[n].call_count == 0</code> means &quot;never called.&quot; But your accumulation uses <code>stats[n].total_ns += elapsed_ns</code> â€” what if <code>elapsed_ns</code> is 0? That&#39;s fine, it&#39;s still a valid count. The danger is if you mistakenly print entries with <code>call_count == 0</code> in the summary. The filter <code>if (stats[i].call_count &gt; 0)</code> before adding to the print index prevents this.</h2>\n<h2 id=\"testing-your-complete-tracer\">Testing Your Complete Tracer</h2>\n<p>Build and test progressively:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Basic filtering: only show file operations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./strace_clone</span><span style=\"color:#79B8FF\"> -e</span><span style=\"color:#9ECBFF\"> trace=openat,read,write,close</span><span style=\"color:#9ECBFF\"> /bin/ls</span><span style=\"color:#9ECBFF\"> /tmp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Count mode: summary statistics only</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./strace_clone</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> /bin/ls</span><span style=\"color:#9ECBFF\"> /tmp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Output to file: trace goes to trace.log, summary to stderr</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./strace_clone</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> trace.log</span><span style=\"color:#9ECBFF\"> /bin/ls</span><span style=\"color:#9ECBFF\"> /tmp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Attach to a running process (find a long-running process first)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 60</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./strace_clone</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#79B8FF\"> $!</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Attach and filter: only network syscalls on a running server</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./strace_clone</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">pgrep</span><span style=\"color:#9ECBFF\"> nginx</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> head</span><span style=\"color:#79B8FF\"> -1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">-e</span><span style=\"color:#9ECBFF\"> trace=accept,read,write,close</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Filter + count: who's calling mmap most?</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./strace_clone</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#79B8FF\"> -e</span><span style=\"color:#9ECBFF\"> trace=mmap,munmap,brk</span><span style=\"color:#9ECBFF\"> /bin/python3</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"import numpy\"</span></span></code></pre></div>\n<p>Expected summary output for a simple <code>ls /tmp</code>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>% time     seconds  usecs/call     calls    errors  syscall\n------ ----------- ----------- --------- --------- ----------------\n 42.18    0.001853         231         8         0  read\n 28.44    0.001249         178         7         0  mmap\n 15.21    0.000668         111         6         0  openat\n  8.02    0.000352          58         6         0  close\n  3.11    0.000136          17         8         0  fstat\n  2.14    0.000094          31         3         3  access\n  0.90    0.000039          19         2         0  getdents64\n...\n------ ----------- ----------- --------- --------- ----------------\n100.00    0.004391                    74         3  total</code></pre></div>\n<hr>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<h3 id=\"1-perf-and-ebpf-moving-beyond-ptrace39s-overhead\">1. perf and eBPF â€” Moving Beyond ptrace&#39;s Overhead</h3>\n<p>The fundamental problem with ptrace-based profiling is the cost you&#39;ve now measured: thousands of cycles per intercepted syscall. For profiling, this is unacceptable â€” the overhead changes the program&#39;s behavior.\nModern Linux solved this with eBPF (extended Berkeley Packet Filter). An eBPF program is a small, JIT-compiled bytecode program that runs <em>inside the kernel</em> â€” attached directly to a syscall tracepoint, kprobe, or perf event. When the attached event fires, the eBPF program runs in-kernel, records timing data into a shared map structure, and returns. The profiling data accumulates in kernel memory; your userspace tool reads it periodically.\nThe critical difference: <strong>no context switch per event</strong>. The eBPF program runs in the same kernel context as the syscall itself. For a <code>getpid</code> call, the overhead is a few dozen nanoseconds â€” not microseconds. <code>bpftrace -e &#39;tracepoint:syscalls:sys_enter_openat { @[comm] = count(); }&#39;</code> counts <code>openat</code> calls by process name with essentially zero impact on the traced system.\nThis is why production performance engineering has moved from <code>strace</code> to <code>bpftrace</code>/<code>bcc</code>/<code>perf</code> for high-frequency measurement. Your tracer is the right tool for <em>correctness debugging</em> (what exactly did this program call?). For <em>performance profiling</em> (how often, how long?), eBPF gives you accurate data at production fidelity.</p>\n<h3 id=\"2-ptrace_seize-the-evolution-of-attachment\">2. PTRACE_SEIZE â€” The Evolution of Attachment</h3>\n<p>You used <code>PTRACE_ATTACH</code>, which sends <code>SIGSTOP</code> to the target. Linux 3.4 introduced <code>PTRACE_SEIZE</code> as a cleaner alternative:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_SEIZE, pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, opts);</span></span></code></pre></div>\n<p><code>PTRACE_SEIZE</code> attaches without sending <code>SIGSTOP</code>. The process continues running normally. Instead, you receive a notification at the next natural stop (syscall boundary, signal delivery, etc.). This is much less disruptive â€” the target doesn&#39;t experience an unexpected pause, signal handlers don&#39;t fire for <code>SIGSTOP</code>, and time-sensitive code doesn&#39;t get disrupted.\nWith <code>PTRACE_SEIZE</code>, you use <code>PTRACE_INTERRUPT</code> (instead of <code>SIGSTOP</code>) when you want to force the target to stop:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">ptrace</span><span style=\"color:#E1E4E8\">(PTRACE_INTERRUPT, pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<p>And <code>PTRACE_LISTEN</code> replaces <code>PTRACE_CONT</code> for passively waiting for the next stop. The attach-then-detach workflow is much cleaner and safer.\nReal strace uses <code>PTRACE_SEIZE</code> since version 4.9 (2013). The <code>PTRACE_ATTACH</code> path remains for compatibility with older kernels. The evolution from <code>PTRACE_ATTACH</code> to <code>PTRACE_SEIZE</code> reflects a general principle in Linux API design: when the original API has unavoidable side effects (the <code>SIGSTOP</code>), a new API is introduced that achieves the same goal without the disruption.</p>\n<h3 id=\"3-the-observer-effect-profiling-as-a-physics-problem\">3. The Observer Effect â€” Profiling as a Physics Problem</h3>\n<p>Your tracer slows the traced program by 10â€“100Ã—. This is the observer effect in systems programming: the measurement apparatus changes what it measures.\nThis isn&#39;t unique to ptrace. Every instrumentation technique has a cost:</p>\n<table>\n<thead>\n<tr>\n<th>Technique</th>\n<th>Overhead per event</th>\n<th>Production-safe?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ptrace (your tracer)</td>\n<td>~2â€“10 Âµs</td>\n<td>No</td>\n</tr>\n<tr>\n<td><code>strace -c</code></td>\n<td>~1â€“5 Âµs</td>\n<td>No</td>\n</tr>\n<tr>\n<td>eBPF tracepoint</td>\n<td>~50â€“200 ns</td>\n<td>Yes (low frequency)</td>\n</tr>\n<tr>\n<td>Linux perf (sampling)</td>\n<td>&lt; 5 Âµs per sample</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Hardware PMU counters</td>\n<td>~1 ns</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Sampling profilers (like <code>perf record</code>) sidestep the problem: instead of intercepting every event, they use a timer interrupt to sample the program counter every N milliseconds. The overhead is proportional to <em>sample rate</em>, not event rate. A program making 1,000,000 syscalls/second with a 1ms sample interval gives you ~1000 samples â€” 1000 interrupts, not 1,000,000. The cost is roughly 0.1% instead of 100Ã—.</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>The observer effect is especially severe for concurrent programs. Lock contention benchmarks are profoundly affected by tracing: if thread A is inside a 500ns critical section and your tracer adds 5Âµs of overhead, thread B waiting for the lock experiences an apparent 10Ã— increase in contention. The trace shows &quot;lots of <code>futex</code> time&quot; â€” but the futex time is <em>caused by the trace</em>. This is why production performance investigation uses sampling or eBPF, not ptrace.</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"4-statistical-aggregation-the-pattern-behind-monitoring-systems\">4. Statistical Aggregation â€” The Pattern Behind Monitoring Systems</h3>\n<p>The <code>SyscallStats</code> accumulator you built is the simplest form of a <em>streaming aggregation</em> pattern:</p>\n<ul>\n<li><strong>Prometheus</strong> (CNCF metrics) maintains exactly this structure: a counter per label combination, incremented on each event, queried periodically.</li>\n<li><strong>statsd</strong> (Etsy, now industry standard) accumulates counts and timings in-memory, then flushes aggregates to a time-series database every 10 seconds.</li>\n<li><strong>Kernel perf events</strong> use ring buffers and mmap&#39;d memory to give userspace programs running totals without system calls.\nThe design choice you made â€” <code>total_ns += elapsed_ns</code> per syscall â€” is exactly how Prometheus&#39;s <code>histogram_observe</code> works for timing data. The &quot;sorted by cumulative time&quot; output is how <code>perf report</code> ranks hot functions. The percentage calculation (<code>total_ns / grand_total_ns Ã— 100</code>) is how profilers identify bottlenecks.\nThe difference between your accumulator and a production monitoring system is primarily the <em>output path</em>. Your system prints at the end. Prometheus exposes an HTTP endpoint. statsd sends UDP packets. But the core â€” iterate events, increment counters, accumulate totals â€” is identical.</li>\n</ul>\n<h3 id=\"5-signal-safety-and-the-sigint-handler-pattern\">5. Signal Safety and the SIGINT Handler Pattern</h3>\n<p>Your <code>g_interrupted = 1</code> signal handler pattern is the canonical solution to a fundamental problem in Unix systems programming: signal handlers run asynchronously, interrupting the main thread at any point, but most interesting operations (<code>ptrace</code>, <code>waitpid</code>, <code>malloc</code>) are not <em>async-signal-safe</em> â€” they may be in the middle of modifying shared state when the signal arrives.\nThe POSIX specification defines a small set of async-signal-safe functions you can call from signal handlers (see <code>signal-safety(7)</code>): <code>write()</code>, <code>_exit()</code>, <code>kill()</code>, <code>sigprocmask()</code>, and about 70 others. Notably absent: <code>printf</code>, <code>malloc</code>, <code>ptrace</code>, <code>waitpid</code>.\nThe safe pattern: signal handler sets a flag (<code>volatile sig_atomic_t</code>), main loop checks the flag after each blocking operation. The main loop can then safely call whatever it needs, because it&#39;s not inside a signal handler.\nThis pattern generalizes everywhere:</p>\n<ul>\n<li>Database systems use it for <code>SIGTERM</code> shutdown (flush WAL, checkpoint, close files)</li>\n<li>Web servers use it for graceful reload (<code>SIGHUP</code> â†’ set flag â†’ drain connections â†’ reload config)</li>\n<li>Container runtimes use it for clean pod termination (<code>SIGTERM</code> â†’ flag â†’ stop all traced processes â†’ report)\nYour SIGINT handler is a microcosm of production-quality signal handling. The <code>SA_RESTART</code> decision (not set, so <code>waitpid</code> returns <code>EINTR</code>) is the same decision any production daemon makes: &quot;do I want blocking calls to automatically restart, or do I want them to be interrupted so I can notice signals quickly?&quot; For a signal-responsive system, <code>EINTR</code> propagation is the right choice.</li>\n</ul>\n<hr>\n<h2 id=\"a-note-on-what-your-measurements-mean\">A Note on What Your Measurements Mean</h2>\n<h2 id=\"before-you-interpret-your-first-summary-table-internalize-this-the-percentages-are-meaningful-if-read-shows-64-of-your-trace-time-it39s-genuinely-the-dominant-syscall-even-accounting-for-overhead-other-syscalls-would-show-similar-relative-overhead-so-the-relative-ranking-is-trustworthy-the-absolute-times-are-not-meaningful-for-comparing-to-production-a-read-that-takes-100s-in-your-trace-may-take-5s-untraced-what-you39re-measuring-is-quothow-much-time-the-tracer-noticed-this-syscall-consumingquot-not-quothow-long-this-syscall-actually-runsquot-the-call-counts-are-exact-they39re-not-subject-to-timing-distortion-if-you-see-2619-read-calls-the-program-made-exactly-2619-read-calls-the-error-counts-are-exact-18-failed-connect-calls-means-18-real-failures-real-strace39s-output-header-says-time-not-cpu-time-for-precisely-this-reason-your-output-should-say-the-same-accuracy-in-communicating-what-you-measure-is-a-form-of-engineering-integrity\">Before you interpret your first summary table, internalize this:\nThe percentages are meaningful. If <code>read</code> shows 64% of your trace time, it&#39;s genuinely the dominant syscall â€” even accounting for overhead, other syscalls would show similar relative overhead, so the <em>relative</em> ranking is trustworthy.\nThe absolute times are not meaningful for comparing to production. A <code>read()</code> that takes 100Âµs in your trace may take 5Âµs untraced. What you&#39;re measuring is &quot;how much time the tracer noticed this syscall consuming,&quot; not &quot;how long this syscall actually runs.&quot;\nThe call counts are exact. They&#39;re not subject to timing distortion. If you see 2,619 <code>read</code> calls, the program made exactly 2,619 <code>read</code> calls.\nThe error counts are exact. 18 failed <code>connect</code> calls means 18 real failures.\nReal strace&#39;s output header says <code>% time</code> not <code>% CPU time</code> for precisely this reason. Your output should say the same. Accuracy in communicating what you measure is a form of engineering integrity.</h2>\n<h2 id=\"summary-what-you39ve-built\">Summary: What You&#39;ve Built</h2>\n<p>Your tracer now has the complete feature set of the core strace functionality:</p>\n<ul>\n<li>Parses <code>-e trace=name,name,...</code> to build a display filter; unmatched syscalls accumulate statistics but don&#39;t print, preserving the accurate count/timing picture</li>\n<li>Records <code>CLOCK_MONOTONIC</code> timestamps at entry and exit to compute elapsed nanoseconds per syscall, correctly understanding that this measures &quot;ptrace-observed wall time&quot; not true syscall CPU time</li>\n<li>Maintains a zero-allocation, L1-cache-resident <code>SyscallStats[336]</code> array accumulating call count, error count, and total nanoseconds per syscall number</li>\n<li>Sorts and prints a <code>strace -c</code>-style summary table (by cumulative time descending) with percentage, seconds, microseconds-per-call, total calls, error count, and syscall name</li>\n<li>Opens a file on <code>-o filename</code> and directs all trace output there; summary always goes to <code>stderr</code></li>\n<li>Attaches to a running process with <code>PTRACE_ATTACH</code>, waits for the <code>SIGSTOP</code> acknowledgment, sets full options, and enters the same event loop as the fork case</li>\n<li>Installs a signal-safe <code>SIGINT</code> handler using <code>volatile sig_atomic_t</code> and <code>SA_RESTART=0</code>; on interrupt, stops the attached tracee with <code>SIGSTOP</code>, waits for it to stop, calls <code>PTRACE_DETACH</code>, prints the summary, and exits without killing the traced process</li>\n</ul>\n<hr>\n<!-- END_MS -->\n\n\n\n\n<h1 id=\"tdd\">TDD</h1>\n<p>A ptrace-based syscall tracer for x86_64 Linux built in four progressive milestones. Each milestone is a self-contained, testable layer: the toggle-based intercept engine, the cross-address-space argument decoder, the multi-process state machine, and the filtering/statistics aggregator. Every design decision is grounded in hardware constraints: the x86_64 syscall ABI register layout, virtual address space isolation enforced by CR3/MMU, cache line boundaries for hot structs, and the observable observer-effect overhead of ptrace itself.</p>\n<!-- TDD_MOD_ID: build-strace-m1 -->\n<h1 id=\"technical-design-specification-basic-ptrace-syscall-intercept-build-strace-m1\">TECHNICAL DESIGN SPECIFICATION: Basic ptrace Syscall Intercept (build-strace-m1)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>This module implements the core &quot;heartbeat&quot; of the system call tracer. It establishes the master-slave relationship between the tracer (parent) and the tracee (child) using the Linux <code>ptrace(2)</code> API. Its primary responsibility is to intercept every transition across the kernel-userspace boundary on x86_64. </p>\n<p><strong>Core Objectives:</strong></p>\n<ul>\n<li>Orchestrate the <code>fork</code> -&gt; <code>PTRACE_TRACEME</code> -&gt; <code>execvp</code> sequence to initiate tracing.</li>\n<li>Implement a synchronous event loop using <code>waitpid</code> and <code>PTRACE_SYSCALL</code>.</li>\n<li>Maintain a stateful toggle to disambiguate between syscall <strong>entry</strong> (pre-execution) and <strong>exit</strong> (post-execution).</li>\n<li>Extract raw machine state from x86_64 registers (<code>orig_rax</code> and <code>rax</code>).</li>\n<li>Ensure transparent execution of the tracee by correctly re-injecting signals.</li>\n</ul>\n<p><strong>Non-Goals:</strong></p>\n<ul>\n<li>Decoding syscall arguments (Milestone 2).</li>\n<li>Handling multiple processes/threads (Milestone 3).</li>\n<li>Symbolic name resolution or timing (Milestone 4).</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>The tracer must never suppress a signal intended for the tracee unless explicitly instructed (not in this milestone).</li>\n<li>The toggle flag must remain synchronized with the kernel&#39;s stop sequence; a single missed stop desynchronizes all subsequent output.</li>\n</ul>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>The implementation follows a monolithic structure for the core loop to minimize context-switching overhead in the tracer code itself.</p>\n<ol>\n<li><code>main.c</code>: Entry point, command-line parsing, fork logic, and the primary tracing loop.</li>\n<li><code>common.h</code>: Shared type definitions and constants for x86_64 register offsets.</li>\n<li><code>Makefile</code>: Build instructions with <code>-Wall -Wextra -O2</code>.</li>\n</ol>\n<h2 id=\"3-data-model\">3. Data Model</h2>\n<h3 id=\"31-process-state-mapping\">3.1 Process State Mapping</h3>\n<p>Even though this milestone handles a single process, the state must be encapsulated in a structure that respects cache line boundaries (64 bytes) to prepare for multi-process expansion.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Size</th>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>pid</code></td>\n<td align=\"left\"><code>pid_t</code></td>\n<td align=\"left\">4B</td>\n<td align=\"left\">0x00</td>\n<td align=\"left\">Tracee process ID</td>\n</tr>\n<tr>\n<td align=\"left\"><code>in_syscall</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">4B</td>\n<td align=\"left\">0x04</td>\n<td align=\"left\">Toggle: 0 = Next stop is entry, 1 = Next stop is exit</td>\n</tr>\n<tr>\n<td align=\"left\"><code>regs</code></td>\n<td align=\"left\"><code>struct user_regs_struct</code></td>\n<td align=\"left\">216B</td>\n<td align=\"left\">0x08</td>\n<td align=\"left\">Copy of tracee registers from last stop</td>\n</tr>\n<tr>\n<td align=\"left\"><code>padding</code></td>\n<td align=\"left\"><code>uint8_t[32]</code></td>\n<td align=\"left\">32B</td>\n<td align=\"left\">0xE0</td>\n<td align=\"left\">Padding to align to 256 bytes (4 cache lines)</td>\n</tr>\n</tbody></table>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/user.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/types.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> pid;</span><span style=\"color:#6A737D\">                      // Offset 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> in_syscall;</span><span style=\"color:#6A737D\">                 // Offset 4</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> user_regs_struct regs;</span><span style=\"color:#6A737D\">   // Offset 8 (Size 216)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Total used: 224 bytes. </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Aligns to 3.5 cache lines.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ProcessState;</span></span></code></pre></div>\n\n<h3 id=\"32-register-layout-x86_64-abi\">3.2 Register Layout (x86_64 ABI)</h3>\n<p>We focus on the <code>struct user_regs_struct</code> defined in <code>&lt;sys/user.h&gt;</code>. On x86_64, the kernel saves the original syscall number in a specific slot that is not overwritten by the return value.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Register</th>\n<th align=\"left\">Struct Field</th>\n<th align=\"left\">Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>orig_rax</code></td>\n<td align=\"left\"><code>regs.orig_rax</code></td>\n<td align=\"left\">Syscall number (Persistent across entry/exit)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>rax</code></td>\n<td align=\"left\"><code>regs.rax</code></td>\n<td align=\"left\">Return value (Only valid on Exit stop)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>rdi</code></td>\n<td align=\"left\"><code>regs.rdi</code></td>\n<td align=\"left\">Argument 1</td>\n</tr>\n<tr>\n<td align=\"left\"><code>rsi</code></td>\n<td align=\"left\"><code>regs.rsi</code></td>\n<td align=\"left\">Argument 2</td>\n</tr>\n<tr>\n<td align=\"left\"><code>rdx</code></td>\n<td align=\"left\"><code>regs.rdx</code></td>\n<td align=\"left\">Argument 3</td>\n</tr>\n</tbody></table>\n<p><strong>Hardware Soul Note:</strong> Reading registers via <code>PTRACE_GETREGS</code> triggers a kernel-mode copy from the tracee&#39;s <code>task_struct-&gt;thread_struct</code> into the tracer&#39;s memory. This touches 4 cache lines in the tracer&#39;s address space.</p>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-int-mainint-argc-char-argv\">4.1 <code>int main(int argc, char *argv[])</code></h3>\n<ul>\n<li><strong>Role</strong>: Entry point for the tracer.</li>\n<li><strong>Input</strong>: <code>argv[1]</code> is the path to the executable; <code>argv[2...]</code> are arguments for that executable.</li>\n<li><strong>Edge Case</strong>: If <code>argc &lt; 2</code>, print usage and exit with 1.</li>\n</ul>\n<h3 id=\"42-static-void-handle_syscallpid_t-pid-processstate-state\">4.2 <code>static void handle_syscall(pid_t pid, ProcessState *state)</code></h3>\n<ul>\n<li><strong>Role</strong>: Dispatches the syscall stop based on the toggle flag.</li>\n<li><strong>Logic</strong>:<ol>\n<li>Call <code>ptrace(PTRACE_GETREGS, pid, 0, &amp;state-&gt;regs)</code>.</li>\n<li>If <code>state-&gt;in_syscall == 0</code>:<ul>\n<li>Log: <code>[Entry] syscall(regs.orig_rax)</code> (Internal state tracking).</li>\n<li>Set <code>state-&gt;in_syscall = 1</code>.</li>\n</ul>\n</li>\n<li>Else (<code>state-&gt;in_syscall == 1</code>):<ul>\n<li>Retrieve <code>result = (long)state-&gt;regs.rax</code>.</li>\n<li>Detect error: <code>if (result &gt;= -4096 &amp;&amp; result &lt;= -1)</code>.</li>\n<li>Log: <code>syscall(regs.orig_rax) = result</code>.</li>\n<li>Set <code>state-&gt;in_syscall = 0</code>.</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"43-static-int-wait_for_eventpid_t-pid-int-status\">4.3 <code>static int wait_for_event(pid_t pid, int *status)</code></h3>\n<ul>\n<li><strong>Role</strong>: Wrapper around <code>waitpid</code>.</li>\n<li><strong>Return</strong>: 0 on normal stop, 1 on exit, -1 on error.</li>\n<li><strong>Recovery</strong>: On <code>EINTR</code>, retry the call.</li>\n</ul>\n<h2 id=\"5-algorithm-specification-the-tracing-lifecycle\">5. Algorithm Specification: The Tracing Lifecycle</h2>\n<h3 id=\"51-initialization-forkexec\">5.1 Initialization (Fork/Exec)</h3>\n<ol>\n<li><strong>Tracer</strong>: Calls <code>fork()</code>.</li>\n<li><strong>Child</strong>: <ul>\n<li>Calls <code>ptrace(PTRACE_TRACEME, 0, NULL, NULL)</code>.</li>\n<li>Calls <code>raise(SIGSTOP)</code> (Optional but recommended to ensure parent is ready).</li>\n<li>Calls <code>execvp(prog, args)</code>.</li>\n</ul>\n</li>\n<li><strong>Tracer</strong>:<ul>\n<li>Calls <code>waitpid(child_pid, &amp;status, 0)</code>.</li>\n<li>Verifies <code>WIFSTOPPED(status)</code>.</li>\n<li>Calls <code>ptrace(PTRACE_SETOPTIONS, child_pid, NULL, PTRACE_O_TRACESYSGOOD)</code>.</li>\n<li><strong>Reason</strong>: This ensures syscall stops are reported as <code>SIGTRAP | 0x80</code> (0x85), allowing us to distinguish them from standard <code>SIGTRAP</code> (0x05) generated by breakpoints or <code>exec</code>.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"52-the-main-intercept-loop\">5.2 The Main Intercept Loop</h3>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Ftdd-diag-1.svg\" alt=\"ptrace Lifecycle: Fork â†’ TRACEME â†’ Exec â†’ SYSCALL Loop\"></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[START LOOP]\n  1. ptrace(PTRACE_SYSCALL, pid, NULL, sig_to_inject)\n  2. waitpid(pid, &amp;status, 0)\n  3. IF WIFEXITED(status) OR WIFSIGNALED(status):\n       EXIT LOOP\n  4. IF WIFSTOPPED(status):\n       sig = WSTOPSIG(status)\n       IF sig == (SIGTRAP | 0x80):\n           // This is a syscall stop\n           handle_syscall(pid, state)\n           sig_to_inject = 0\n       ELSE IF sig == SIGTRAP:\n           // Trap from exec or other ptrace event\n           sig_to_inject = 0\n       ELSE:\n           // Real signal (e.g., SIGINT, SIGPIPE)\n           sig_to_inject = sig\n[GOTO START]</code></pre></div>\n\n<h3 id=\"53-error-detection-logic\">5.3 Error Detection Logic</h3>\n<p>On x86_64, the kernel returns errors as negative values in the range <code>[-4096, -1]</code>.</p>\n<ul>\n<li>Example: <code>-2</code> represents <code>-ENOENT</code>.</li>\n<li>Algorithm:<ol>\n<li>Cast <code>unsigned long rax</code> to <code>long signed_rax</code>.</li>\n<li>Check <code>if (signed_rax &lt; 0 &amp;&amp; signed_rax &gt;= -4096)</code>.</li>\n<li><code>errno_val = -signed_rax</code>.</li>\n<li>Print <code>strerror(errno_val)</code>.</li>\n</ol>\n</li>\n</ul>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Ftdd-diag-2.svg\" alt=\"Entry/Exit Toggle State Machine\">\n (Visualizes the <code>rax</code> register transition from entry to exit)</p>\n<h2 id=\"6-error-handling-matrix\">6. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery</th>\n<th align=\"left\">User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>fork() == -1</code></td>\n<td align=\"left\">Return value</td>\n<td align=\"left\">Exit tracer with <code>perror</code>.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>execvp() == -1</code></td>\n<td align=\"left\">Child continues</td>\n<td align=\"left\">Child calls <code>_exit(1)</code>. Parent sees <code>WIFEXITED</code>.</td>\n<td align=\"left\">Yes (via waitpid)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ESRCH</code></td>\n<td align=\"left\"><code>ptrace</code> call</td>\n<td align=\"left\">Tracee likely died; terminate tracing loop.</td>\n<td align=\"left\">No (clean exit)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EPERM</code></td>\n<td align=\"left\"><code>ptrace</code> call</td>\n<td align=\"left\">Tracer lacks permissions; exit with error.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>waitpid == -1</code></td>\n<td align=\"left\">Return value</td>\n<td align=\"left\">If <code>errno == EINTR</code>, loop; else exit.</td>\n<td align=\"left\">Yes</td>\n</tr>\n</tbody></table>\n<h2 id=\"7-implementation-sequence\">7. Implementation Sequence</h2>\n<h3 id=\"phase-1-the-spawner-2-hours\">Phase 1: The Spawner (2 Hours)</h3>\n<ul>\n<li>Implement <code>fork</code> logic.</li>\n<li>In child: <code>PTRACE_TRACEME</code> then <code>execvp</code>.</li>\n<li>In parent: <code>waitpid</code> for the initial stop.</li>\n<li><strong>Checkpoint</strong>: Run <code>./tracer /bin/ls</code>. The tracer should start, the child should execute <code>ls</code>, and the tracer should finish immediately after <code>ls</code> exits.</li>\n</ul>\n<h3 id=\"phase-2-the-syscall-loop-2-hours\">Phase 2: The SYSCALL Loop (2 Hours)</h3>\n<ul>\n<li>Implement the <code>while(1)</code> loop with <code>PTRACE_SYSCALL</code>.</li>\n<li>Add <code>WIFEXITED</code> check to break the loop.</li>\n<li>Print a generic &quot;Stop detected&quot; message for every stop.</li>\n<li><strong>Checkpoint</strong>: Run <code>./tracer /bin/ls</code>. You should see dozens of &quot;Stop detected&quot; messages before <code>ls</code> prints its output.</li>\n</ul>\n<h3 id=\"phase-3-the-toggle-amp-registers-2-hours\">Phase 3: The Toggle &amp; Registers (2 Hours)</h3>\n<ul>\n<li>Define <code>ProcessState</code> with <code>in_syscall</code>.</li>\n<li>Call <code>PTRACE_SETOPTIONS</code> with <code>PTRACE_O_TRACESYSGOOD</code>.</li>\n<li>In the loop, check for <code>(SIGTRAP | 0x80)</code>.</li>\n<li>Use <code>PTRACE_GETREGS</code> to read <code>orig_rax</code>.</li>\n<li><strong>Checkpoint</strong>: Output should look like <code>syscall(59)</code>, <code>syscall(12)</code>, etc. Note that each number should appear twice.</li>\n</ul>\n<h3 id=\"phase-4-output-refinement-2-hours\">Phase 4: Output Refinement (2 Hours)</h3>\n<ul>\n<li>Logic to only print on the <strong>exit</strong> stop (toggle == 1).</li>\n<li>Add <code>rax</code> reading and error range check.</li>\n<li>Implement signal re-injection (passing <code>sig</code> to <code>PTRACE_SYSCALL</code>).</li>\n<li><strong>Checkpoint</strong>: <code>./tracer /bin/ls</code> should print <code>syscall(59) = 0</code>, <code>syscall(12) = 0x...</code>.</li>\n</ul>\n<h2 id=\"8-test-specification\">8. Test Specification</h2>\n<h3 id=\"81-happy-path-truefalse\">8.1 Happy Path: True/False</h3>\n<ul>\n<li><strong>Command</strong>: <code>./tracer /bin/true</code></li>\n<li><strong>Expectation</strong>: <ul>\n<li>Output contains <code>syscall(231) = 0</code> (exit_group) or similar termination.</li>\n<li>Exit banner <code>+++ exited with 0 +++</code>.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"82-failure-case-missing-file\">8.2 Failure Case: Missing File</h3>\n<ul>\n<li><strong>Command</strong>: <code>./tracer /bin/ls /nonexistent_file_999</code></li>\n<li><strong>Expectation</strong>:<ul>\n<li>Find the <code>openat</code> syscall (257).</li>\n<li>Output: <code>syscall(257) = -1 ENOENT (No such file or directory)</code>.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"83-signal-injection-sigint\">8.3 Signal Injection: SIGINT</h3>\n<ul>\n<li><strong>Command</strong>: <code>./tracer /bin/sleep 100</code> (then hit Ctrl+C)</li>\n<li><strong>Expectation</strong>:<ul>\n<li>Tracer detects <code>WIFSIGNALED</code> or <code>WIFSTOPPED</code> with <code>SIGINT</code>.</li>\n<li>The <code>sleep</code> process terminates correctly rather than hanging.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"9-performance-targets\">9. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Interception Latency</strong></td>\n<td align=\"left\">&lt; 10Âµs per stop</td>\n<td align=\"left\"><code>clock_gettime</code> before/after <code>waitpid</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Memory usage</strong></td>\n<td align=\"left\">&lt; 1MB RSS</td>\n<td align=\"left\"><code>ps -o rss</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Context Switch Count</strong></td>\n<td align=\"left\">4 per syscall</td>\n<td align=\"left\"><code>vmstat 1</code> during trace.</td>\n</tr>\n</tbody></table>\n<h2 id=\"10-hardware-soul-amp-alternative-realities\">10. Hardware Soul &amp; Alternative Realities</h2>\n<p><strong>Hardware Soul (The LSTAR MSR):</strong>\nOn x86_64, when the tracee executes <code>syscall</code>, the CPU doesn&#39;t look at the IDT (Interrupt Descriptor Table). It looks at the <code>IA32_LSTAR</code> Model-Specific Register. The kernel has pre-loaded this MSR with the address of <code>entry_SYSCALL_64</code>. When your tracer stops the child, the child&#39;s <code>RIP</code> (Instruction Pointer) is actually pointing to the instruction <em>immediately following</em> the <code>syscall</code> opcode, but the kernel has rolled back the registers to allow ptrace to see the pre-execution state.</p>\n<p><strong>Alternative Reality (Linux vs. FreeBSD):</strong>\nOn Linux, we use <code>orig_rax</code> to get the syscall number because <code>rax</code> gets overwritten. On FreeBSD, <code>ptrace</code> provides a <code>PT_GET_SC_INFO</code> request that explicitly returns a <code>struct ptrace_sc_info</code> containing the syscall number and arguments, removing the need for architecture-specific register-scraping. Your C code for Linux is &quot;architecture-entangled&quot; by design.</p>\n<p><strong>Byte-Level Wait Status Layout:</strong>\nThe <code>status</code> integer from <code>waitpid</code> is not an opaque ID. For a stop:</p>\n<ul>\n<li><code>status &amp; 0xFF</code> must be <code>0x7F</code>.</li>\n<li><code>(status &gt;&gt; 8) &amp; 0xFF</code> is the signal number.</li>\n<li>If <code>PTRACE_O_TRACESYSGOOD</code> is set, the signal number is <code>0x85</code> (5 | 0x80).</li>\n</ul>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-strace-m2 -->\n<h1 id=\"technical-design-specification-argument-decoding-build-strace-m2\">TECHNICAL DESIGN SPECIFICATION: Argument Decoding (build-strace-m2)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>This module transforms the raw syscall numbers and register values captured in Milestone 1 into human-readable, semantic traces. It acts as the &quot;interpreter&quot; layer between the x86_64 hardware state and the user.</p>\n<p><strong>Core Objectives:</strong></p>\n<ul>\n<li>Map x86_64 syscall numbers (0â€“450+) to symbolic names (e.g., <code>2</code> $\\rightarrow$ <code>open</code>).</li>\n<li>Extract syscall arguments from the specific registers designated by the x86_64 System V ABI.</li>\n<li>Implement a robust remote memory reader to extract null-terminated strings from the tracee&#39;s address space.</li>\n<li>Decode complex bitmask flags for common syscalls (<code>open</code>, <code>mmap</code>) into piping-separated strings (e.g., <code>O_RDONLY|O_CREAT</code>).</li>\n<li>Handle the fundamental isolation of virtual address spaces using <code>PTRACE_PEEKDATA</code>.</li>\n</ul>\n<p><strong>Non-Goals:</strong></p>\n<ul>\n<li>Tracing across <code>fork()</code> or <code>clone()</code> boundaries (Milestone 3).</li>\n<li>High-resolution timing or summary statistics (Milestone 4).</li>\n<li>Decoding complex pointer-to-struct arguments (e.g., <code>struct stat</code>) beyond basic address printing.</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li><code>PTRACE_PEEKDATA</code> calls must always be preceded by an <code>errno = 0</code> assignment to disambiguate valid <code>-1</code> data from error returns.</li>\n<li>String reads must be capped at <code>MAX_STRING_LEN</code> to prevent infinite loops in cases of corrupted tracee memory.</li>\n</ul>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>Implementation follows a logical separation between data tables (names/signatures) and logic (memory reading/formatting).</p>\n<ol>\n<li><code>syscall_data.h</code>: Declarations for the name and signature tables.</li>\n<li><code>syscall_data.c</code>: The actual sparse arrays for syscall names and <code>SyscallDesc</code> metadata.</li>\n<li><code>mem_reader.c</code>: Logic for word-aligned <code>PTRACE_PEEKDATA</code> reads and string marshalling.</li>\n<li><code>formatter.c</code>: Flag decoding logic and the primary <code>print_syscall</code> formatting engine.</li>\n<li><code>main.c</code>: Updated loop from M1 to include entry-state register saving and decoding calls.</li>\n</ol>\n<h2 id=\"3-data-model\">3. Data Model</h2>\n<h3 id=\"31-syscall-metadata-types\">3.1 Syscall Metadata Types</h3>\n<p>We define an abstraction to describe the &quot;signature&quot; of a syscall. This allows the formatter to know how many arguments to print and how to interpret each register.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ARG_INT,</span><span style=\"color:#6A737D\">          // Print as %lld</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ARG_UINT,</span><span style=\"color:#6A737D\">         // Print as %llu</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ARG_HEX,</span><span style=\"color:#6A737D\">          // Print as 0x%llx</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ARG_STR,</span><span style=\"color:#6A737D\">          // String in tracee memory (PEEKDATA)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ARG_PTR,</span><span style=\"color:#6A737D\">          // Pointer: print hex address or \"NULL\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ARG_OPEN_FLAGS,</span><span style=\"color:#6A737D\">   // Bitmask for open()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ARG_MMAP_PROT,</span><span style=\"color:#6A737D\">    // Bitmask for mmap() PROT</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ARG_MMAP_FLAGS,</span><span style=\"color:#6A737D\">   // Bitmask for mmap() FLAGS</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ARG_IGNORE</span><span style=\"color:#6A737D\">        // Skip this argument</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ArgType;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">name;</span><span style=\"color:#6A737D\">      // Syscall name</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> num_args;</span><span style=\"color:#6A737D\">          // 0 to 6</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ArgType </span><span style=\"color:#FFAB70\">arg_types</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">  // Type per argument slot</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} SyscallDesc;</span></span></code></pre></div>\n\n<h3 id=\"32-flag-decoding-table\">3.2 Flag Decoding Table</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> value;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">name;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} FlagEntry;</span></span></code></pre></div>\n\n<h3 id=\"33-extended-process-state\">3.3 Extended Process State</h3>\n<p>The <code>ProcessState</code> from M1 must be extended to store a snapshot of registers taken at <strong>entry</strong>. On the <strong>exit</strong> stop, the argument registers (rdi, rsi, etc.) may be clobbered by the kernel; the tracer must rely on the saved entry state.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Size</th>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>pid</code></td>\n<td align=\"left\"><code>pid_t</code></td>\n<td align=\"left\">4B</td>\n<td align=\"left\">0x00</td>\n<td align=\"left\">Process ID</td>\n</tr>\n<tr>\n<td align=\"left\"><code>in_syscall</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">4B</td>\n<td align=\"left\">0x04</td>\n<td align=\"left\">Toggle flag</td>\n</tr>\n<tr>\n<td align=\"left\"><code>entry_regs</code></td>\n<td align=\"left\"><code>struct user_regs_struct</code></td>\n<td align=\"left\">216B</td>\n<td align=\"left\">0x08</td>\n<td align=\"left\">Saved snapshot from ENTRY stop</td>\n</tr>\n</tbody></table>\n<p><strong>Hardware Soul Note:</strong> A <code>struct user_regs_struct</code> snapshot (216B) is slightly over 3 cache lines (64B each). Saving this snapshot involves a synchronous copy from the kernel&#39;s task structure to your tracer&#39;s heap/stack, adding ~2000 cycles of latency.</p>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Ftdd-diag-8.svg\" alt=\"Virtual Address Space Isolation: Why PTRACE_PEEKDATA Exists\"></p>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-char-read_remote_stringpid_t-pid-unsigned-long-addr\">4.1 <code>char* read_remote_string(pid_t pid, unsigned long addr)</code></h3>\n<ul>\n<li><strong>Role</strong>: Extracts a string from the tracee&#39;s address space.</li>\n<li><strong>Input</strong>: <code>addr</code> is the virtual address in the tracee&#39;s memory.</li>\n<li><strong>Output</strong>: A heap-allocated or static-buffer string.</li>\n<li><strong>Constraint</strong>: Must read in 8-byte increments (word size on x86_64).</li>\n<li><strong>Error</strong>: Returns <code>&quot;&lt;unreadable&gt;&quot;</code> if PEEKDATA fails; handles NULL by returning <code>&quot;NULL&quot;</code>.</li>\n</ul>\n<h3 id=\"42-void-decode_flagsunsigned-long-val-const-flagentry-table-char-out_buf\">4.2 <code>void decode_flags(unsigned long val, const FlagEntry *table, char *out_buf)</code></h3>\n<ul>\n<li><strong>Role</strong>: Converts a bitmask (e.g., <code>0x80002</code>) into a string (e.g., <code>O_RDWR|O_CLOEXEC</code>).</li>\n<li><strong>Edge Case</strong>: <code>O_RDONLY</code> is <code>0x0</code>. The logic must check <code>if (val == 0)</code> before entering the bitwise loop.</li>\n</ul>\n<h3 id=\"43-void-print_syscallpid_t-pid-processstate-state-long-exit_code\">4.3 <code>void print_syscall(pid_t pid, ProcessState *state, long exit_code)</code></h3>\n<ul>\n<li><strong>Role</strong>: Orchestrates the output of one trace line.</li>\n<li><strong>Logic</strong>:<ol>\n<li>Lookup <code>SyscallDesc</code> using <code>state-&gt;entry_regs.orig_rax</code>.</li>\n<li>Extract 6 registers into a local array: <code>rdi, rsi, rdx, r10, r8, r9</code>.</li>\n<li>Iterate <code>i &lt; desc.num_args</code>, calling specific formatters based on <code>desc.arg_types[i]</code>.</li>\n<li>Print the syscall name, arguments, and finally the <code>exit_code</code>.</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"5-algorithm-specification-string-extraction-via-word-walking\">5. Algorithm Specification: String Extraction via Word-Walking</h2>\n<p><code>PTRACE_PEEKDATA</code> on x86_64 returns one 64-bit word. Since strings are not word-aligned, we must scan each word for the null terminator.</p>\n<h3 id=\"algorithm-extract_string_loop\">Algorithm <code>extract_string_loop</code>:</h3>\n<ol>\n<li>Initialize <code>bytes_read = 0</code>, <code>buffer</code> of size <code>MAX_STRING_LEN</code>.</li>\n<li>While <code>bytes_read &lt; MAX_STRING_LEN</code>:<ul>\n<li><code>errno = 0</code>.</li>\n<li><code>word = ptrace(PTRACE_PEEKDATA, pid, addr + bytes_read, NULL)</code>.</li>\n<li>If <code>word == -1 &amp;&amp; errno != 0</code>:<ul>\n<li>Terminate and return current buffer (partial read).</li>\n</ul>\n</li>\n<li>Cast <code>word</code> to <code>unsigned char[8]</code>.</li>\n<li>For <code>j = 0</code> to <code>7</code>:<ul>\n<li><code>c = byte_array[j]</code>.</li>\n<li>If <code>c == &#39;\\0&#39;</code>: return buffer.</li>\n<li><code>buffer[bytes_read++] = c</code>.</li>\n<li>If <code>bytes_read == MAX_STRING_LEN</code>: break and return buffer with <code>...</code> suffix.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Return buffer.</li>\n</ol>\n<p><strong>Visualizing Word-Walking:</strong>\nTracee memory at <code>0x1000</code>: <code>[&#39;/&#39;,&#39;u&#39;,&#39;s&#39;,&#39;r&#39;,&#39;/&#39;,&#39;b&#39;,&#39;i&#39;,&#39;n&#39;,&#39;/&#39;,&#39;l&#39;,&#39;s&#39;,&#39;\\0&#39;, ...]</code></p>\n<ol>\n<li>Read <code>0x1000</code> $\\rightarrow$ <code>word1</code> contains <code>/usr/bin</code>.</li>\n<li>Scan <code>word1</code>: no <code>\\0</code>. Append to buffer.</li>\n<li>Read <code>0x1008</code> $\\rightarrow$ <code>word2</code> contains <code>/ls\\0</code>.</li>\n<li>Scan <code>word2</code>: find <code>\\0</code> at index 3.</li>\n<li>Final result: <code>/usr/bin/ls</code>.</li>\n</ol>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Ftdd-diag-9.svg\" alt=\"PTRACE_PEEKDATA Word-by-Word String Extraction Algorithm\"></p>\n<h2 id=\"6-error-handling-matrix\">6. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery</th>\n<th align=\"left\">User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>PTRACE_PEEKDATA</code> fails</td>\n<td align=\"left\"><code>errno != 0</code></td>\n<td align=\"left\">Stop reading, return <code>&quot;&lt;unreadable&gt;&quot;</code></td>\n<td align=\"left\">Yes (in output)</td>\n</tr>\n<tr>\n<td align=\"left\">Invalid Syscall Num</td>\n<td align=\"left\"><code>num &gt; 335</code></td>\n<td align=\"left\">Use <code>&quot;unknown&quot;</code> as name</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\">NULL pointer</td>\n<td align=\"left\"><code>arg == 0</code></td>\n<td align=\"left\">Print <code>&quot;NULL&quot;</code>, skip PEEKDATA</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\">Buffer Overrun</td>\n<td align=\"left\"><code>bytes_read &gt;= 1024</code></td>\n<td align=\"left\">Truncate and add <code>&quot;...&quot;</code></td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\">Missing <code>SyscallDesc</code></td>\n<td align=\"left\"><code>desc == NULL</code></td>\n<td align=\"left\">Print args as raw hex</td>\n<td align=\"left\">Yes</td>\n</tr>\n</tbody></table>\n<h2 id=\"7-implementation-sequence\">7. Implementation Sequence</h2>\n<h3 id=\"phase-1-the-table-2-hours\">Phase 1: The Table (2 Hours)</h3>\n<ul>\n<li>Create <code>syscall_data.c</code> with at least 50 common names (read, write, open, close, mmap, brk, etc.).</li>\n<li>Verify by printing <code>syscall_name(regs.orig_rax)</code> in the M1 exit loop.</li>\n<li><strong>Checkpoint</strong>: Running <code>./tracer /bin/ls</code> shows names like <code>openat</code> and <code>fstat</code> instead of <code>257</code> and <code>5</code>.</li>\n</ul>\n<h3 id=\"phase-2-remote-memory-logic-3-hours\">Phase 2: Remote Memory Logic (3 Hours)</h3>\n<ul>\n<li>Implement <code>read_remote_string</code> with the word-walking algorithm.</li>\n<li>Handle the <code>errno</code> disambiguation.</li>\n<li>Add the <code>MAX_STRING_LEN</code> (32 or 64 bytes) truncation logic.</li>\n<li><strong>Checkpoint</strong>: Hardcode a check for syscall <code>execve</code> (59) and print the first argument using this function. You should see <code>execve(&quot;/bin/ls&quot;, ...)</code> in your output.</li>\n</ul>\n<h3 id=\"phase-3-the-dispatcher-3-hours\">Phase 3: The Dispatcher (3 Hours)</h3>\n<ul>\n<li>Populate <code>SyscallDesc</code> for the top 20 syscalls.</li>\n<li>Implement <code>print_syscall</code> which iterates through <code>num_args</code>.</li>\n<li>Implement <code>print_arg</code> as a large switch-case over <code>ArgType</code>.</li>\n<li><strong>Checkpoint</strong>: Basic integer and string arguments work. <code>openat(3, &quot;/etc/passwd&quot;, ...)</code> starts to look real.</li>\n</ul>\n<h3 id=\"phase-4-flag-decoding-2-hours\">Phase 4: Flag Decoding (2 Hours)</h3>\n<ul>\n<li>Define <code>open_flags</code> and <code>mmap_prot</code> tables.</li>\n<li>Implement <code>decode_flags</code> with the logic to handle bitwise concatenation.</li>\n<li>Fix the <code>O_RDONLY</code> (0) bug by checking <code>if (val == 0)</code> first.</li>\n<li><strong>Checkpoint</strong>: <code>openat(..., O_RDONLY|O_CLOEXEC) = 3</code>.</li>\n</ul>\n<h2 id=\"8-test-specification\">8. Test Specification</h2>\n<h3 id=\"81-string-reading-ls\">8.1 String Reading: <code>ls</code></h3>\n<ul>\n<li><strong>Command</strong>: <code>./tracer /bin/ls /var/log</code></li>\n<li><strong>Test</strong>: Search for <code>openat</code> or <code>stat</code>.</li>\n<li><strong>Expectation</strong>: The path <code>&quot;/var/log&quot;</code> is visible and quoted.</li>\n</ul>\n<h3 id=\"82-null-pointer-execve\">8.2 NULL Pointer: <code>execve</code></h3>\n<ul>\n<li><strong>Command</strong>: <code>./tracer /bin/ls</code></li>\n<li><strong>Test</strong>: Look at <code>execve</code> arguments (arg 2 or 3).</li>\n<li><strong>Expectation</strong>: If a pointer is 0, it should print <code>NULL</code> and NOT crash.</li>\n</ul>\n<h3 id=\"83-bitmask-mmap\">8.3 Bitmask: <code>mmap</code></h3>\n<ul>\n<li><strong>Command</strong>: <code>./tracer /bin/ls</code></li>\n<li><strong>Test</strong>: Find <code>mmap</code> calls.</li>\n<li><strong>Expectation</strong>: Output shows <code>PROT_READ</code>, <code>MAP_PRIVATE</code>, etc., instead of raw hex.</li>\n</ul>\n<h3 id=\"84-long-string-truncation\">8.4 Long String Truncation</h3>\n<ul>\n<li><strong>Command</strong>: Create a test C program that opens a very long path (&gt; 128 chars).</li>\n<li><strong>Expectation</strong>: The output shows the first 32/64 chars followed by <code>...</code>.</li>\n</ul>\n<h2 id=\"9-performance-targets\">9. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Name Lookup</strong></td>\n<td align=\"left\">O(1)</td>\n<td align=\"left\">Array index in <code>syscall_names</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>String Read</strong></td>\n<td align=\"left\">~1.5Âµs / word</td>\n<td align=\"left\"><code>clock_gettime</code> around <code>read_remote_string</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Formatting Overhead</strong></td>\n<td align=\"left\">&lt; 50Âµs</td>\n<td align=\"left\">Total time in <code>print_syscall</code>.</td>\n</tr>\n</tbody></table>\n<p><strong>Hardware Soul Note (The TLB):</strong> <code>PTRACE_PEEKDATA</code> is significantly slower than local memory access because it requires the kernel to temporarily switch the CPU&#39;s <code>CR3</code> register (or use a global kernel mapping) to resolve the tracee&#39;s virtual address through the tracee&#39;s page tables. This often results in a TLB miss for the tracer.</p>\n<h2 id=\"10-flag-tables-sample-for-implementation\">10. Flag Tables (Sample for Implementation)</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#E1E4E8\"> FlagEntry open_flags</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_WRONLY,   </span><span style=\"color:#9ECBFF\">\"O_WRONLY\"</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_RDWR,     </span><span style=\"color:#9ECBFF\">\"O_RDWR\"</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_CREAT,    </span><span style=\"color:#9ECBFF\">\"O_CREAT\"</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_EXCL,     </span><span style=\"color:#9ECBFF\">\"O_EXCL\"</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_TRUNC,    </span><span style=\"color:#9ECBFF\">\"O_TRUNC\"</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_APPEND,   </span><span style=\"color:#9ECBFF\">\"O_APPEND\"</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_DIRECTORY,</span><span style=\"color:#9ECBFF\">\"O_DIRECTORY\"</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { O_CLOEXEC,  </span><span style=\"color:#9ECBFF\">\"O_CLOEXEC\"</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    { </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Logic Note:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Since O_RDONLY is usually 0, your loop should be:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (val </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"O_RDONLY\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // iterate flags and print with |</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Ftdd-diag-10.svg\" alt=\"PTRACE_PEEKDATA -1 Ambiguity: Error vs Valid Data\">\n (Visualizes the bitmask decoding flow)</p>\n<hr>\n<p><strong>END OF SPECIFICATION</strong></p>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-strace-m3 -->\n<h1 id=\"technical-design-specification-multi-process-and-fork-following-build-strace-m3\">TECHNICAL DESIGN SPECIFICATION: Multi-Process and Fork Following (build-strace-m3)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>This module extends the tracer from a single-process observer to a full process-tree supervisor. It implements the logic required to transparently follow children created via <code>fork()</code>, <code>vfork()</code>, and <code>clone()</code>, as well as handling the complete address space replacement during <code>execve()</code>. Its primary responsibility is the orchestration of the ptrace multi-process state machine, ensuring that new processes are atomically attached before they can execute a single instruction. It manages a centralized per-PID state repository using an open-addressing hash map optimized for cache-line alignment.</p>\n<p><strong>Core Objectives:</strong></p>\n<ul>\n<li>Configure ptrace options (<code>PTRACE_O_TRACEFORK</code>, etc.) to enable automatic kernel-mediated attachment to child processes.</li>\n<li>Transition the event loop to a non-blocking/any-child model using <code>waitpid(-1)</code>.</li>\n<li>Implement an O(1) lookup mechanism for per-process metadata (registers, toggle state).</li>\n<li>Correctly handle <code>PTRACE_EVENT_EXEC</code> to reset stale process state when a new image is loaded.</li>\n<li>Maintain a global <code>active_count</code> to ensure the tracer exits only when the entire process tree has terminated.</li>\n</ul>\n<p><strong>Non-Goals:</strong></p>\n<ul>\n<li>Implementing syscall name filtering (Milestone 4).</li>\n<li>High-resolution wall-clock timing or statistical aggregation (Milestone 4).</li>\n<li>Modifying syscall arguments or return values (fault injection).</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>Every process returned by <code>waitpid(-1)</code> must have a corresponding entry in the <code>state_map</code> before its registers are accessed.</li>\n<li>The <code>active_count</code> must exactly match the number of live, traced processes; any mismatch will result in either a hang or premature tracer exit.</li>\n</ul>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>The implementation sequence requires files to be created/modified in this order:</p>\n<ol>\n<li><code>state_map.h</code>: Definition of the <code>ProcessState</code> struct and hash map interface.</li>\n<li><code>state_map.c</code>: Implementation of the open-addressing hash map (insert, find, remove).</li>\n<li><code>events.h</code>: Constants for ptrace event decoding (status bit-shifts).</li>\n<li><code>events.c</code>: Handlers for <code>PTRACE_EVENT_FORK</code>, <code>PTRACE_EVENT_CLONE</code>, and <code>PTRACE_EVENT_EXEC</code>.</li>\n<li><code>main.c</code>: Integration of the <code>waitpid(-1)</code> loop and PID-tagged output.</li>\n</ol>\n<h2 id=\"3-complete-data-model\">3. Complete Data Model</h2>\n<h3 id=\"31-processstate-struct-byte-level-layout\">3.1 ProcessState Struct (Byte-Level Layout)</h3>\n<p>To ensure high performance during the hot path (lookup on every syscall entry/exit), the <code>ProcessState</code> is designed to be cache-friendly. Each entry is padded to exactly 256 bytes (4 cache lines on x86_64).</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Size</th>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>pid</code></td>\n<td align=\"left\"><code>pid_t</code></td>\n<td align=\"left\">4B</td>\n<td align=\"left\">0x00</td>\n<td align=\"left\">Process ID (Key)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>in_syscall</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">4B</td>\n<td align=\"left\">0x04</td>\n<td align=\"left\">Toggle: 0=Entry, 1=Exit</td>\n</tr>\n<tr>\n<td align=\"left\"><code>entry_regs</code></td>\n<td align=\"left\"><code>struct user_regs_struct</code></td>\n<td align=\"left\">216B</td>\n<td align=\"left\">0x08</td>\n<td align=\"left\">Registers captured at entry stop</td>\n</tr>\n<tr>\n<td align=\"left\"><code>valid</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">4B</td>\n<td align=\"left\">0xE0</td>\n<td align=\"left\">Status: 0=Empty, 1=Active, -1=Tombstone</td>\n</tr>\n<tr>\n<td align=\"left\"><code>padding</code></td>\n<td align=\"left\"><code>uint8_t[12]</code></td>\n<td align=\"left\">12B</td>\n<td align=\"left\">0xE4</td>\n<td align=\"left\">Alignment padding to 256B</td>\n</tr>\n</tbody></table>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/user.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/types.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> pid;</span><span style=\"color:#6A737D\">                          // 0x00</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> in_syscall;</span><span style=\"color:#6A737D\">                     // 0x04</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> user_regs_struct entry_regs;</span><span style=\"color:#6A737D\"> // 0x08</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> valid;</span><span style=\"color:#6A737D\">                          // 0xE0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> padding</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">                // 0xE4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ProcessState;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> STATE_MAP_SIZE</span><span style=\"color:#79B8FF\"> 256</span><span style=\"color:#6A737D\">              // Must be power of 2</span></span></code></pre></div>\n\n<h3 id=\"32-global-state-control\">3.2 Global State Control</h3>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Variable</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>state_map</code></td>\n<td align=\"left\"><code>ProcessState[256]</code></td>\n<td align=\"left\">The flat hash table. Total size: 64 KB (Fits in L2).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>active_count</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">Number of live processes currently being traced.</td>\n</tr>\n</tbody></table>\n<p><strong>Hardware Soul Section:</strong> \nThe <code>state_map</code> occupies exactly 64KB. This is significant because it fits entirely within the L2 cache of modern x86_64 CPUs (typically 256KB-1MB). Because the <code>waitpid(-1)</code> loop is single-threaded, the <code>state_map</code> will remain &quot;warm&quot; in the cache, ensuring that the <code>state_map_find</code> operation (which uses a simple modulo hash) typically resolves in ~10-15 cycles, effectively hiding the cost of the ptrace bookkeeping.</p>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Ftdd-diag-15.svg\" alt=\"PTRACE_O_TRACEFORK Atomicity: No Race Window\"></p>\n<p><em>Diagram: Memory Layout of the state_map highlighting cache line boundaries (64B segments).</em></p>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-hash-map-interface-state_mapc\">4.1 Hash Map Interface (<code>state_map.c</code>)</h3>\n<p><strong><code>ProcessState* state_map_find(pid_t pid)</code></strong></p>\n<ul>\n<li><strong>Role</strong>: Lookup state for a PID.</li>\n<li><strong>Algorithm</strong>: Linear probing starting at <code>pid % 256</code>.</li>\n<li><strong>Returns</strong>: Pointer to the state or <code>NULL</code> if not found.</li>\n</ul>\n<p><strong><code>ProcessState* state_map_insert(pid_t pid)</code></strong></p>\n<ul>\n<li><strong>Role</strong>: Allocate a slot for a new process.</li>\n<li><strong>Error</strong>: Returns <code>NULL</code> if table is full (load factor &gt; 1).</li>\n</ul>\n<p><strong><code>void state_map_remove(pid_t pid)</code></strong></p>\n<ul>\n<li><strong>Role</strong>: Mark a slot as a tombstone (<code>valid = -1</code>) to maintain probing chains.</li>\n</ul>\n<h3 id=\"42-event-handling-eventsc\">4.2 Event Handling (<code>events.c</code>)</h3>\n<p><strong><code>void handle_ptrace_event(pid_t pid, int status, ProcessState *state)</code></strong></p>\n<ul>\n<li><strong>Input</strong>: <code>status</code> from <code>waitpid</code>.</li>\n<li><strong>Logic</strong>:<ol>\n<li><code>int event = (status &gt;&gt; 16) &amp; 0xff;</code></li>\n<li>If <code>event</code> is <code>FORK</code>, <code>VFORK</code>, or <code>CLONE</code>:<ul>\n<li><code>ptrace(PTRACE_GETEVENTMSG, pid, NULL, &amp;new_pid);</code></li>\n<li><code>state_map_insert(new_pid);</code></li>\n<li><code>active_count++;</code></li>\n<li><code>ptrace(PTRACE_SYSCALL, new_pid, NULL, NULL);</code> // CRITICAL: Start the child.</li>\n</ul>\n</li>\n<li>If <code>event</code> is <code>EXEC</code>:<ul>\n<li><code>state-&gt;in_syscall = 0;</code> // Reset toggle.</li>\n<li><code>memset(&amp;state-&gt;entry_regs, 0, sizeof(entry_regs));</code></li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"5-algorithm-specification-the-multi-process-dispatcher\">5. Algorithm Specification: The Multi-Process Dispatcher</h2>\n<p>The core loop must now handle interleaved events. A single <code>waitpid</code> might return a syscall exit for PID A, followed immediately by a syscall entry for PID B.</p>\n<h3 id=\"algorithm-tracing_loop_v3\">Algorithm: <code>Tracing_Loop_v3</code></h3>\n<ol>\n<li><strong>Wait</strong>: <code>pid_t current = waitpid(-1, &amp;status, 0)</code>.</li>\n<li><strong>Verify</strong>: If <code>current == -1</code>, check <code>errno</code>. If <code>ECHILD</code>, exit loop (all dead).</li>\n<li><strong>Dispatch</strong>:<ul>\n<li><strong>Exit/Signal</strong>: <ul>\n<li>If <code>WIFEXITED(status)</code> or <code>WIFSIGNALED(status)</code>:<ul>\n<li>Print: <code>[pid current] +++ exited with ... +++</code></li>\n<li><code>state_map_remove(current)</code>.</li>\n<li><code>active_count--</code>.</li>\n<li>Continue loop.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>ptrace Stop</strong>:<ul>\n<li><code>int sig = WSTOPSIG(status)</code>.</li>\n<li><code>int event = (status &gt;&gt; 16) &amp; 0xff</code>.</li>\n<li>Find <code>ProcessState *s = state_map_find(current)</code>. </li>\n<li><strong>Defensive Guard</strong>: If <code>s == NULL</code>, <code>s = state_map_insert(current); active_count++;</code>.</li>\n<li><strong>Branch by Event</strong>:<ul>\n<li>If <code>event != 0</code>: Call <code>handle_ptrace_event(current, status, s)</code>.</li>\n<li>Else if <code>sig == (SIGTRAP | 0x80)</code>:<ul>\n<li>Call <code>PTRACE_GETREGS</code>.</li>\n<li>Toggle <code>s-&gt;in_syscall</code>.</li>\n<li>If <code>s-&gt;in_syscall == 1</code>: Save <code>entry_regs</code>.</li>\n<li>Else: <code>print_syscall(current, s, regs.rax)</code>.</li>\n</ul>\n</li>\n<li>Else: Re-inject <code>sig</code> via <code>PTRACE_SYSCALL(current, sig)</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Resume</strong>: Unless handled in event branch, <code>ptrace(PTRACE_SYSCALL, current, NULL, NULL)</code>.</li>\n</ol>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Ftdd-diag-16.svg\" alt=\"Per-PID State Hash Map: Structure, Probing, and Collision\"></p>\n<p><em>Diagram: Sequence diagram of Fork Interception. Parent ptrace(PTRACE_SYSCALL) -&gt; Child born (Stopped) -&gt; Tracer receives PTRACE_EVENT_FORK -&gt; Tracer resumes child.</em></p>\n<h2 id=\"6-error-handling-matrix\">6. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery</th>\n<th align=\"left\">User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>state_map</code> Full</td>\n<td align=\"left\"><code>state_map_insert</code> returns <code>NULL</code></td>\n<td align=\"left\">Log error to stderr, <code>PTRACE_DETACH</code> unknown PID.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>GETEVENTMSG</code> fail</td>\n<td align=\"left\">Return value -1</td>\n<td align=\"left\">Log warning; the child might have exited instantly.</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ESRCH</code> on Resume</td>\n<td align=\"left\"><code>ptrace</code> returns -1</td>\n<td align=\"left\">Process died between wait and resume; cleanup state.</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\"><code>PTRACE_EVENT_EXEC</code></td>\n<td align=\"left\"><code>status &gt;&gt; 16 == 4</code></td>\n<td align=\"left\">Reset <code>in_syscall</code> toggle to prevent stale reg reads.</td>\n<td align=\"left\">Yes (output tagged)</td>\n</tr>\n<tr>\n<td align=\"left\">Interleaved Syscalls</td>\n<td align=\"left\">Loop Logic</td>\n<td align=\"left\">Hash map lookups ensure PID A state never bleeds into PID B.</td>\n<td align=\"left\">No</td>\n</tr>\n</tbody></table>\n<h2 id=\"7-implementation-sequence-with-checkpoints\">7. Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-state-map-amp-hash-table-2-hours\">Phase 1: State Map &amp; Hash Table (2 Hours)</h3>\n<ul>\n<li>Implement <code>state_map.c</code> with linear probing.</li>\n<li>Unit test: Insert 10 PIDs, verify <code>find</code> returns correct pointers, <code>remove</code> one, verify <code>find</code> handles the gap.</li>\n<li><strong>Checkpoint</strong>: <code>test_hash_map</code> executable passes all lookups.</li>\n</ul>\n<h3 id=\"phase-2-waitpid-1-transition-2-hours\">Phase 2: waitpid(-1) Transition (2 Hours)</h3>\n<ul>\n<li>Modify <code>main.c</code> from M2. Replace specific PID in <code>waitpid</code> with <code>-1</code>.</li>\n<li>Use the <code>state_map_find</code> to fetch the toggle flag.</li>\n<li>Add the <code>[pid N]</code> prefix to all <code>printf</code> calls.</li>\n<li><strong>Checkpoint</strong>: Run <code>./tracer /bin/ls</code>. Output should be identical to M2 but prefixed with <code>[pid &lt;n&gt;]</code>.</li>\n</ul>\n<h3 id=\"phase-3-fork-interception-3-hours\">Phase 3: Fork Interception (3 Hours)</h3>\n<ul>\n<li>Set <code>PTRACE_SETOPTIONS</code> with <code>PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORK | PTRACE_O_TRACECLONE</code>.</li>\n<li>Implement <code>PTRACE_GETEVENTMSG</code> logic.</li>\n<li>Ensure <code>active_count</code> increments and the child is resumed.</li>\n<li><strong>Checkpoint</strong>: Run <code>./tracer bash -c &quot;ls&quot;</code>. You should now see syscalls from <em>both</em> <code>bash</code> and <code>ls</code>.</li>\n</ul>\n<h3 id=\"phase-4-exec-amp-exit-synchronization-2-hours\">Phase 4: Exec &amp; Exit Synchronization (2 Hours)</h3>\n<ul>\n<li>Implement <code>PTRACE_O_TRACEEXEC</code> handler.</li>\n<li>Add logic to decrement <code>active_count</code> and remove from map on <code>WIFEXITED</code>.</li>\n<li>Ensure the tracer only exits when <code>active_count == 0</code>.</li>\n<li><strong>Checkpoint</strong>: Run <code>./tracer bash -c &quot;echo hello | cat&quot;</code>. The tracer should stay alive until both children and the shell exit.</li>\n</ul>\n<h2 id=\"8-test-specification\">8. Test Specification</h2>\n<h3 id=\"81-multi-process-pipeline\">8.1 Multi-Process Pipeline</h3>\n<ul>\n<li><strong>Command</strong>: <code>./tracer bash -c &quot;echo test | grep test&quot;</code></li>\n<li><strong>Expectation</strong>: <ul>\n<li>Trace shows <code>pipe()</code>, then two <code>clone()</code> calls.</li>\n<li>Trace shows <code>execve()</code> for <code>echo</code> and <code>grep</code> under different PIDs.</li>\n<li>Trace correctly identifies <code>write()</code> from one PID and <code>read()</code> from the other.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"82-vfork-suspension\">8.2 vfork Suspension</h3>\n<ul>\n<li><strong>Command</strong>: A test C program using <code>vfork()</code>.</li>\n<li><strong>Expectation</strong>: Parent PID produces no syscall events between the <code>vfork</code> entry and the child&#39;s <code>exec</code> or <code>exit</code>.</li>\n</ul>\n<h3 id=\"83-state-map-stress\">8.3 State Map Stress</h3>\n<ul>\n<li><strong>Command</strong>: A test program that spawns 100 short-lived threads.</li>\n<li><strong>Expectation</strong>: No &quot;State map full&quot; errors. <code>active_count</code> returns to 0.</li>\n</ul>\n<h2 id=\"9-performance-targets\">9. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Hash Lookup</strong></td>\n<td align=\"left\">&lt; 50 ns</td>\n<td align=\"left\"><code>clock_gettime</code> around <code>state_map_find</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Memory Footprint</strong></td>\n<td align=\"left\">~128 KB</td>\n<td align=\"left\"><code>valgrind --tool=massif</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Max Capacity</strong></td>\n<td align=\"left\">256 PIDs</td>\n<td align=\"left\">Hard-coded limit; verify rejection at 257.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Fork Latency</strong></td>\n<td align=\"left\">&lt; 500Âµs</td>\n<td align=\"left\">Time from parent <code>fork</code> entry to child first syscall.</td>\n</tr>\n</tbody></table>\n<h2 id=\"10-concurrency-specification\">10. Concurrency Specification</h2>\n<p><strong>Single-Threaded Ownership:</strong>\nThe tracer utilizes a single-threaded event loop. This design choice is intentional:</p>\n<ol>\n<li><strong>Atomicity</strong>: <code>waitpid(-1)</code> is a blocking call that returns exactly one event from the kernel&#39;s queue.</li>\n<li><strong>No Locking</strong>: Since only one thread accesses the <code>state_map</code>, no mutexes or atomics are required, eliminating lock contention.</li>\n<li><strong>Serialization</strong>: The kernel serializes syscall events per-CPU. By processing them in a single loop, the tracer maintains a deterministic view of the process tree&#39;s execution.</li>\n</ol>\n<p><strong>Wait Status Byte Layout (Hardware Soul):</strong>\nFor <code>PTRACE_EVENT</code> stops:</p>\n<ul>\n<li><code>status &amp; 0xFF == 0x7F</code> (Stopped)</li>\n<li><code>(status &gt;&gt; 8) &amp; 0xFF == SIGTRAP</code> (Stop Signal)</li>\n<li><code>(status &gt;&gt; 16) &amp; 0xFF == EVENT_CODE</code> (1=FORK, 2=VFORK, 3=CLONE, 4=EXEC)</li>\n</ul>\n<p><strong>END OF SPECIFICATION</strong></p>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-strace-m4 -->\n<h1 id=\"technical-design-specification-filtering-and-statistics-build-strace-m4\">TECHNICAL DESIGN SPECIFICATION: Filtering and Statistics (build-strace-m4)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>This module provides the final layer of utility and analytical power to the system call tracer. It implements selective observation, high-resolution performance profiling, and lifecycle management for external process attachment.</p>\n<p><strong>Core Objectives:</strong></p>\n<ul>\n<li>Implement a <strong>Syscall Filter</strong> to manage display volume, allowing users to isolate specific kernel interactions (e.g., <code>-e trace=open,read</code>).</li>\n<li>Establish <strong>Performance Instrumentation</strong> using <code>CLOCK_MONOTONIC</code> to measure wall-clock duration of syscalls with nanosecond precision.</li>\n<li>Construct a <strong>Statistics Engine</strong> to aggregate frequency, error rates, and cumulative latency into a summary table (<code>-c</code> mode).</li>\n<li>Enable <strong>Live Process Attachment</strong> (<code>-p</code> PID), moving the tracer from a spawner to a diagnostic tool for production workloads.</li>\n<li>Ensure <strong>Clean Session Termination</strong> via <code>SIGINT</code> (Ctrl+C) handling, implementing a safe <code>PTRACE_DETACH</code> sequence that leaves the tracee in a running state.</li>\n</ul>\n<p><strong>Non-Goals:</strong></p>\n<ul>\n<li>Implementing kernel-side eBPF filtering (this remains a userspace ptrace filter).</li>\n<li>Supporting multi-architecture (i386) syscall translation.</li>\n<li>Providing real-time graphical profiling (CLI summary only).</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>Statistics must be recorded for <strong>all</strong> intercepted syscalls, regardless of whether the display filter suppresses the line.</li>\n<li>Attachment to a running process must always wait for the <code>SIGSTOP</code> acknowledgment before applying ptrace options.</li>\n<li>Clock sources must never be <code>CLOCK_REALTIME</code> to avoid desynchronization during NTP adjustments.</li>\n</ul>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>The milestone follows a modular creation order, extending the base established in Milestone 3:</p>\n<ol>\n<li><code>options.h / options.c</code>: CLI parsing via <code>getopt</code> and the <code>TracerOptions</code> global configuration.</li>\n<li><code>filter.h / filter.c</code>: Syscall name-to-number resolution and the <code>filter_passes</code> predicate.</li>\n<li><code>stats.h / stats.c</code>: The <code>SyscallStats</code> array, sorting logic, and summary table formatter.</li>\n<li><code>signals.h / signals.c</code>: Async-signal-safe <code>SIGINT</code> handler and the interrupt flag.</li>\n<li><code>attach.c</code>: Logic for <code>PTRACE_ATTACH</code> and <code>PTRACE_DETACH</code> sequences.</li>\n<li><code>main.c</code>: Final integration of the event loop with timing hooks and filtered output.</li>\n</ol>\n<h2 id=\"3-complete-data-model\">3. Complete Data Model</h2>\n<h3 id=\"31-traceroptions-configuration\">3.1 TracerOptions (Configuration)</h3>\n<p>This structure holds the parsed CLI state and dictates the behavior of the main event loop.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Size</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>output_file</code></td>\n<td align=\"left\"><code>const char*</code></td>\n<td align=\"left\">8B</td>\n<td align=\"left\">Path to redirect trace output (or NULL for stderr).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>filter_spec</code></td>\n<td align=\"left\"><code>const char*</code></td>\n<td align=\"left\">8B</td>\n<td align=\"left\">Raw string from <code>-e trace=...</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>attach_pid</code></td>\n<td align=\"left\"><code>pid_t</code></td>\n<td align=\"left\">4B</td>\n<td align=\"left\">Target PID if in attach mode, else 0.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>summary_mode</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">4B</td>\n<td align=\"left\">Boolean flag for <code>-c</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>target_argv</code></td>\n<td align=\"left\"><code>char**</code></td>\n<td align=\"left\">8B</td>\n<td align=\"left\">Argument vector for forked child.</td>\n</tr>\n</tbody></table>\n<h3 id=\"32-syscallstats-accumulator\">3.2 SyscallStats (Accumulator)</h3>\n<p>A fixed-size array of 336 entries (the x86_64 syscall count) is used to store statistics. This allows O(1) updates during the tracing hot-path.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Size</th>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>total_ns</code></td>\n<td align=\"left\"><code>int64_t</code></td>\n<td align=\"left\">8B</td>\n<td align=\"left\">0x00</td>\n<td align=\"left\">Cumulative nanoseconds spent in call.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>call_count</code></td>\n<td align=\"left\"><code>long</code></td>\n<td align=\"left\">8B</td>\n<td align=\"left\">0x08</td>\n<td align=\"left\">Total number of invocations.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>error_count</code></td>\n<td align=\"left\"><code>long</code></td>\n<td align=\"left\">8B</td>\n<td align=\"left\">0x10</td>\n<td align=\"left\">Invocations returning <code>[-4096, -1]</code>.</td>\n</tr>\n</tbody></table>\n<p><strong>Hardware Soul (L1 Cache Alignment):</strong>\nThe <code>SyscallStats</code> struct is exactly 24 bytes. An array of 336 entries takes <strong>8,064 bytes</strong>. Modern x86_64 L1 data caches are typically <strong>32KB</strong>. This allows the entire statistics table to reside in L1, ensuring that the <code>stats_record()</code> operation (called twice per syscall) never results in a DRAM access.</p>\n<h3 id=\"33-updated-processstate-milestone-3-extension\">3.3 Updated ProcessState (Milestone 3 Extension)</h3>\n<p>We extend the <code>ProcessState</code> from Milestone 3 to include the entry timestamp.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> pid;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> in_syscall;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> user_regs_struct entry_regs;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> timespec entry_time;</span><span style=\"color:#6A737D\">  // NEW: Recorded at syscall entry stop</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> valid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ProcessState;</span></span></code></pre></div>\n\n\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Ftdd-diag-22.svg\" alt=\"What Syscall Timing Actually Measures: Observer Effect Breakdown\"></p>\n<p><em>Diagram: Memory Layout of the updated ProcessState. total size 248 bytes, aligned to cache lines.</em></p>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-statistics-interface-statsh\">4.1 Statistics Interface (<code>stats.h</code>)</h3>\n<p><strong><code>void stats_record(long syscall_num, long long duration_ns, int is_error)</code></strong></p>\n<ul>\n<li><strong>Input</strong>: Syscall index, calculated delta, and error boolean.</li>\n<li><strong>Logic</strong>: Increments <code>call_count</code>, adds <code>duration_ns</code> to <code>total_ns</code>, and increments <code>error_count</code> if <code>is_error</code> is true.</li>\n</ul>\n<p><strong><code>void stats_print(FILE *out)</code></strong></p>\n<ul>\n<li><strong>Role</strong>: Formats the final table.</li>\n<li><strong>Logic</strong>:<ol>\n<li>Create an index array of syscalls where <code>call_count &gt; 0</code>.</li>\n<li><code>qsort</code> index array by <code>total_ns</code> descending.</li>\n<li>Iterate and print formatted columns (percentage, seconds, usecs/call).</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"42-filtering-interface-filterh\">4.2 Filtering Interface (<code>filter.h</code>)</h3>\n<p><strong><code>void filter_parse(const char *spec)</code></strong></p>\n<ul>\n<li><strong>Input</strong>: String like <code>&quot;open,read,write&quot;</code>.</li>\n<li><strong>Logic</strong>: Tokens are resolved via <code>syscall_num_by_name()</code>. Numbers are stored in a bitmask or dense array <code>nums[]</code>.</li>\n</ul>\n<p><strong><code>int filter_passes(long syscall_num)</code></strong></p>\n<ul>\n<li><strong>Return</strong>: <code>1</code> if the syscall should be displayed, <code>0</code> otherwise. Note: if no filter is provided, it always returns <code>1</code>.</li>\n</ul>\n<h3 id=\"43-attachment-interface-attachh\">4.3 Attachment Interface (<code>attach.h</code>)</h3>\n<p><strong><code>void attach_to_process(pid_t pid)</code></strong></p>\n<ul>\n<li><strong>Sequence</strong>:<ol>\n<li><code>ptrace(PTRACE_ATTACH, pid, NULL, NULL)</code>.</li>\n<li><code>waitpid(pid, &amp;status, 0)</code>.</li>\n<li><code>ptrace(PTRACE_SETOPTIONS, pid, NULL, opts)</code>.</li>\n</ol>\n</li>\n<li><strong>Error</strong>: If <code>EPERM</code>, print instructions on disabling <code>yama/ptrace_scope</code>.</li>\n</ul>\n<h2 id=\"5-algorithm-specification\">5. Algorithm Specification</h2>\n<h3 id=\"51-high-resolution-timing-algorithm\">5.1 High-Resolution Timing Algorithm</h3>\n<p>The tracer must calculate duration across the kernel boundary while minimizing overhead from the measurement itself.</p>\n<ol>\n<li><strong>Syscall Entry Stop</strong>:<ul>\n<li>Call <code>ptrace(PTRACE_GETREGS)</code>.</li>\n<li>Call <code>clock_gettime(CLOCK_MONOTONIC, &amp;state-&gt;entry_time)</code>. <strong>Crucial</strong>: Perform this immediately after the ptrace stop to exclude tracer processing time.</li>\n</ul>\n</li>\n<li><strong>Syscall Exit Stop</strong>:<ul>\n<li>Call <code>clock_gettime(CLOCK_MONOTONIC, &amp;exit_time)</code>.</li>\n<li><code>delta_ns = (exit_time.tv_sec - entry_time.tv_sec) * 1e9 + (exit_time.tv_nsec - entry_time.tv_nsec)</code>.</li>\n<li>Record <code>delta_ns</code> into <code>SyscallStats[orig_rax]</code>.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"52-clean-detach-algorithm-sigint\">5.2 Clean Detach Algorithm (SIGINT)</h3>\n<p>To avoid killing the tracee when the tracer is interrupted, a specific handshake is required.</p>\n<ol>\n<li><strong>Signal Handler</strong>:<ul>\n<li>Set global <code>volatile sig_atomic_t g_interrupted = 1</code>.</li>\n</ul>\n</li>\n<li><strong>Event Loop</strong>:<ul>\n<li><code>waitpid</code> returns <code>EINTR</code> or loop checks <code>g_interrupted</code>.</li>\n<li>For every PID in <code>state_map</code>:<ul>\n<li>Send <code>SIGSTOP</code> if not currently stopped (to ensure ptrace responsiveness).</li>\n<li><code>waitpid(pid, &amp;status, 0)</code> to acknowledge stop.</li>\n<li><code>ptrace(PTRACE_DETACH, pid, NULL, NULL)</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Finalize</strong>:<ul>\n<li>Call <code>stats_print()</code> if <code>-c</code> was active.</li>\n<li><code>exit(0)</code>.</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Ftdd-diag-23.svg\" alt=\"CLOCK_MONOTONIC vs CLOCK_REALTIME: Why Monotonic is Mandatory\"></p>\n<p><em>Diagram: Flowchart of the SIGINT Detach sequence ensuring process continuity.</em></p>\n<h2 id=\"6-error-handling-matrix\">6. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery</th>\n<th align=\"left\">User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>PTRACE_ATTACH EPERM</code></td>\n<td align=\"left\"><code>errno</code> after call</td>\n<td align=\"left\">Print <code>ptrace_scope</code> help and exit.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>PTRACE_ATTACH ESRCH</code></td>\n<td align=\"left\"><code>errno</code> after call</td>\n<td align=\"left\">Target PID disappeared; exit.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>fopen(-o file)</code> Fail</td>\n<td align=\"left\">Return NULL</td>\n<td align=\"left\">Print error, exit.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>waitpid EINTR</code></td>\n<td align=\"left\"><code>errno == EINTR</code></td>\n<td align=\"left\">Check <code>g_interrupted</code>. If set, detach; else retry wait.</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\">Negative <code>delta_ns</code></td>\n<td align=\"left\">Comparison</td>\n<td align=\"left\">Log error; indicates <code>CLOCK_REALTIME</code> usage bug.</td>\n<td align=\"left\">Yes (Internal debug)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-e trace=bad_name</code></td>\n<td align=\"left\">Name lookup fail</td>\n<td align=\"left\">Warn user that <code>bad_name</code> is unknown; ignore it.</td>\n<td align=\"left\">Yes</td>\n</tr>\n</tbody></table>\n<h2 id=\"7-implementation-sequence-with-checkpoints\">7. Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-cli-amp-filtering-2-hours\">Phase 1: CLI &amp; Filtering (2 Hours)</h3>\n<ul>\n<li>Implement <code>getopt</code> parsing in <code>options.c</code>.</li>\n<li>Implement <code>filter_parse</code> and <code>filter_passes</code>.</li>\n<li><strong>Checkpoint</strong>: Running <code>./tracer -e trace=open,close /bin/ls</code> should suppress all lines except <code>open</code> and <code>close</code>.</li>\n</ul>\n<h3 id=\"phase-2-timing-amp-accumulation-3-hours\">Phase 2: Timing &amp; Accumulation (3 Hours)</h3>\n<ul>\n<li>Add <code>entry_time</code> to <code>ProcessState</code>.</li>\n<li>Implement <code>stats_record</code> and the <code>SyscallStats</code> array.</li>\n<li>Compute <code>delta_ns</code> at every exit stop.</li>\n<li><strong>Checkpoint</strong>: Internal verification: the tracer can now calculate that a <code>read</code> took 12,500ns.</li>\n</ul>\n<h3 id=\"phase-3-the-summary-table-2-hours\">Phase 3: The Summary Table (2 Hours)</h3>\n<ul>\n<li>Implement <code>stats_print</code> with <code>qsort</code>.</li>\n<li>Handle column formatting and total calculations.</li>\n<li><strong>Checkpoint</strong>: Running <code>./tracer -c /bin/ls</code> produces a table similar to <code>strace -c</code> on exit.</li>\n</ul>\n<h3 id=\"phase-4-attachment-amp-detach-3-hours\">Phase 4: Attachment &amp; Detach (3 Hours)</h3>\n<ul>\n<li>Implement <code>attach_to_process</code>.</li>\n<li>Install <code>SIGINT</code> handler.</li>\n<li>Implement the <code>PTRACE_DETACH</code> loop.</li>\n<li><strong>Checkpoint</strong>: <code>./tracer -p &lt;PID&gt;</code> attaches to a running shell. Hitting Ctrl+C detaches the tracer but the shell remains responsive.</li>\n</ul>\n<h2 id=\"8-test-specification\">8. Test Specification</h2>\n<h3 id=\"81-filter-accuracy\">8.1 Filter Accuracy</h3>\n<ul>\n<li><strong>Test</strong>: <code>./tracer -e trace=write /bin/echo &quot;hello&quot;</code></li>\n<li><strong>Expectation</strong>: Output contains <code>write(...)</code> and <code>execve(...)</code> (initial), but NO <code>brk</code>, <code>mmap</code>, or <code>close</code>.</li>\n</ul>\n<h3 id=\"82-statistics-precision\">8.2 Statistics Precision</h3>\n<ul>\n<li><strong>Test</strong>: <code>./tracer -c /bin/ls</code></li>\n<li><strong>Expectation</strong>: Percentage column totals 100%. <code>calls</code> count matches manual count from non-stats mode.</li>\n</ul>\n<h3 id=\"83-detach-verification\">8.3 Detach Verification</h3>\n<ul>\n<li><strong>Test</strong>: <code>sleep 100 &amp;</code> then <code>./tracer -p $!</code>. Hit Ctrl+C.</li>\n<li><strong>Expectation</strong>: <code>ps -p $!</code> still shows the sleep process in <code>S</code> (sleeping) or <code>R</code> (running) state, NOT <code>T</code> (stopped) or <code>&lt;defunct&gt;</code>.</li>\n</ul>\n<h2 id=\"9-performance-targets\">9. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Clock Sampling</strong></td>\n<td align=\"left\">&lt; 100ns</td>\n<td align=\"left\"><code>clock_gettime</code> VDSO overhead test.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Stats Record</strong></td>\n<td align=\"left\">&lt; 20ns</td>\n<td align=\"left\">O(1) array update measurement.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Memory usage</strong></td>\n<td align=\"left\">&lt; 256KB RSS</td>\n<td align=\"left\"><code>ps -o rss</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Attach Latency</strong></td>\n<td align=\"left\">&lt; 1ms</td>\n<td align=\"left\">Time from command execution to first syscall capture.</td>\n</tr>\n</tbody></table>\n<h2 id=\"10-concurrency-specification\">10. Concurrency Specification</h2>\n<p><strong>Signal Safety (Async-Signal-Safe Pattern):</strong>\nThe <code>SIGINT</code> handler <strong>MUST NOT</strong> call <code>printf</code>, <code>malloc</code>, or <code>ptrace</code>. </p>\n<ol>\n<li><strong>Handler</strong>: Only sets <code>g_interrupted = 1</code>.</li>\n<li><strong>Main Loop</strong>: Checks <code>g_interrupted</code>.</li>\n<li><strong>SA_RESTART</strong>: Must be <strong>unset</strong> (<code>sa_flags = 0</code>). This ensures that the blocking <code>waitpid</code> syscall is interrupted and returns <code>EINTR</code>, allowing the loop to immediately respond to the user&#39;s Ctrl+C.</li>\n</ol>\n<p><strong>File Synchronization:</strong>\nSince the tracer is single-threaded, <code>fprintf(trace_out, ...)</code> is implicitly serialized. No mutex is required for the <code>-o</code> file handle.</p>\n<p><img src=\"/api/project/build-strace/architecture-doc/asset?path=diagrams%2Ftdd-diag-24.svg\" alt=\"SyscallStats Array Memory Layout and Cache Behavior\"></p>\n<p><em>Diagram: Trace output redirection logic using a shared FILE</em> pointer.*</p>\n<hr>\n<p><strong>END OF SPECIFICATION</strong></p>\n<!-- END_TDD_MOD -->\n\n\n<h1 id=\"project-structure-system-call-tracer-strace-clone\">Project Structure: System Call Tracer (strace clone)</h1>\n<h2 id=\"directory-tree\">Directory Tree</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>strace-clone/\nâ”œâ”€â”€ src/                    \nâ”‚   â”œâ”€â”€ main.c              # Main loop &amp; dispatch (M1-M4: Core orchestrator)\nâ”‚   â”œâ”€â”€ mem_reader.c        # PTRACE_PEEKDATA logic (M2: Word-walking strings)\nâ”‚   â”œâ”€â”€ formatter.c         # Syscall/Flag formatting (M2: Register-to-string logic)\nâ”‚   â”œâ”€â”€ syscall_data.c      # Name &amp; signature tables (M2: Syscall metadata)\nâ”‚   â”œâ”€â”€ state_map.c         # PID hash map (M3: Per-process state tracking)\nâ”‚   â”œâ”€â”€ events.c            # Ptrace event handling (M3: Fork/Exec/Clone logic)\nâ”‚   â”œâ”€â”€ options.c           # CLI argument parsing (M4: getopt implementation)\nâ”‚   â”œâ”€â”€ filter.c            # Syscall filtering (M4: Name-to-number predicate)\nâ”‚   â”œâ”€â”€ stats.c             # Statistics accumulator (M4: Timing &amp; summary table)\nâ”‚   â”œâ”€â”€ signals.c           # Signal handlers (M4: Async-safe SIGINT logic)\nâ”‚   â””â”€â”€ attach.c            # Process attachment (M4: PTRACE_ATTACH/DETACH)\nâ”œâ”€â”€ include/                \nâ”‚   â”œâ”€â”€ common.h            # Basic types &amp; macros (M1: Register offsets)\nâ”‚   â”œâ”€â”€ syscall_data.h      # Table declarations (M2: Signature definitions)\nâ”‚   â”œâ”€â”€ state_map.h         # Map interface (M3: ProcessState struct)\nâ”‚   â”œâ”€â”€ events.h            # Event constants (M3: Ptrace bit-shifts)\nâ”‚   â”œâ”€â”€ options.h           # Config structures (M4: TracerOptions global)\nâ”‚   â”œâ”€â”€ filter.h            # Filter interface (M4: Bitmask/Lookup logic)\nâ”‚   â”œâ”€â”€ stats.h             # Stats interface (M4: Accumulator types)\nâ”‚   â””â”€â”€ signals.h           # Signal interface (M4: Global interrupt flags)\nâ”œâ”€â”€ Makefile                # Build system (M1: CC/CFLAGS configuration)\nâ””â”€â”€ README.md               # Project guide</code></pre></div>\n\n<h2 id=\"creation-order\">Creation Order</h2>\n<ol>\n<li><p><strong>Foundation &amp; Skeleton</strong> (M1)</p>\n<ul>\n<li>Create <code>Makefile</code> and <code>include/common.h</code>.</li>\n<li>Implement <code>src/main.c</code> (Phase 1): Basic <code>fork()</code>, <code>PTRACE_TRACEME</code>, and <code>execvp</code>.</li>\n<li>Implement the <code>PTRACE_SYSCALL</code> loop and <code>in_syscall</code> toggle.</li>\n</ul>\n</li>\n<li><p><strong>Decoding Engine</strong> (M2)</p>\n<ul>\n<li>Create <code>include/syscall_data.h</code> and <code>src/syscall_data.c</code> (The syscall table).</li>\n<li>Implement <code>src/mem_reader.c</code> for <code>PTRACE_PEEKDATA</code> string extraction.</li>\n<li>Build <code>src/formatter.c</code> to decode registers and bitmask flags.</li>\n<li>Update <code>main.c</code> to save <code>entry_regs</code> and print decoded calls.</li>\n</ul>\n</li>\n<li><p><strong>Multi-Process Supervision</strong> (M3)</p>\n<ul>\n<li>Implement <code>include/state_map.h</code> and <code>src/state_map.c</code> (The PID hash map).</li>\n<li>Create <code>src/events.c</code> to handle <code>PTRACE_EVENT_FORK/EXEC</code>.</li>\n<li>Modify <code>main.c</code> to use <code>waitpid(-1)</code> and the state map lookup.</li>\n<li>Set <code>PTRACE_O_TRACEFORK</code> and related options in the initialization.</li>\n</ul>\n</li>\n<li><p><strong>Utility &amp; Profiling</strong> (M4)</p>\n<ul>\n<li>Implement <code>src/options.c</code> for CLI flag handling (<code>-e</code>, <code>-o</code>, <code>-c</code>, <code>-p</code>).</li>\n<li>Add <code>src/filter.c</code> to enable syscall suppression.</li>\n<li>Implement <code>src/stats.c</code> using <code>CLOCK_MONOTONIC</code> for the summary table.</li>\n<li>Add <code>src/attach.c</code> for <code>-p</code> functionality and <code>src/signals.c</code> for clean <code>SIGINT</code> detaching.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"file-count-summary\">File Count Summary</h2>\n<ul>\n<li><strong>Total Header Files (.h):</strong> 8</li>\n<li><strong>Total Source Files (.c):</strong> 11</li>\n<li><strong>Build/Doc Files:</strong> 2</li>\n<li><strong>Estimated Total Lines of Code:</strong> ~1,350 LOC</li>\n<li><strong>Key Hardware Dependencies:</strong> x86_64 Linux (sys/user.h register layout)</li>\n</ul>\n<h1 id=\"-beyond-the-atlas-further-reading\">ðŸ“š Beyond the Atlas: Further Reading</h1>\n<h2 id=\"the-intercept-engine-ptrace-amp-signals\">The Intercept Engine (ptrace &amp; Signals)</h2>\n<p><strong>Paper</strong>: <em>PTRACE - Process Trace</em> in &quot;The Design and Implementation of the 4.4BSD Operating System&quot; (McKusick, 1996). \n<strong>Code</strong>: <a href=\"https://github.com/strace/strace/blob/master/src/strace.c\">strace/strace.c</a> â€” The main event loop of the actual strace utility.\n<strong>Best Explanation</strong>: Eli Benderskyâ€™s <a href=\"https://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints\">How debuggers work: Part 2 - Breakpoints</a> (covers the <code>waitpid</code>/<code>SIGTRAP</code> dance).\n<strong>Why</strong>: This is the authoritative explanation of how <code>ptrace</code> and <code>SIGTRAP</code> interact to pause execution.\n<strong>Pedagogical Timing</strong>: Read <strong>BEFORE Milestone 1</strong>. It demystifies why the process stops and how the parent regains control, which is the foundation of the entire project.</p>\n<p><strong>Spec</strong>: <a href=\"https://man7.org/linux/man-pages/man2/ptrace.2.html\">Linux ptrace(2) Man Page</a>.\n<strong>Best Explanation</strong>: <a href=\"https://jvns.ca/blog/2014/02/17/how-does-strace-work/\">Julia Evans: How does strace work?</a> (Zine-style visual guide).\n<strong>Why</strong>: It provides a high-level mental model of the tracer/tracee relationship that makes the man page much easier to digest.\n<strong>Pedagogical Timing</strong>: Read <strong>during Milestone 1</strong> when the &quot;double-stop&quot; (entry/exit) behavior starts to feel confusing.</p>\n<hr>\n<h2 id=\"the-x86_64-syscall-abi\">The x86_64 Syscall ABI</h2>\n<p><strong>Spec</strong>: <a href=\"https://github.com/hjl-tools/x86-64-abi/releases\">System V Application Binary Interface (AMD64 Architecture Processor Supplement)</a> â€” Section 3.2.3 (Parameter Passing).\n<strong>Code</strong>: <a href=\"https://github.com/torvalds/linux/blob/master/arch/x86/entry/entry_64.S\">linux/arch/x86/entry/entry_64.S</a> â€” The kernelâ€™s assembly-level entry point for syscalls.\n<strong>Best Explanation</strong>: Ryan Chapmanâ€™s <a href=\"https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/\">Linux System Call Table for x86_64</a>.\n<strong>Why</strong>: It is the &quot;Rosetta Stone&quot; for mapping syscall numbers to registers and argument types.\n<strong>Pedagogical Timing</strong>: Reference <strong>during Milestone 2</strong>. You will need this constantly as you build the <code>SyscallDesc</code> table.</p>\n<hr>\n<h2 id=\"memory-amp-address-spaces\">Memory &amp; Address Spaces</h2>\n<p><strong>Best Explanation</strong>: <em>Understanding the Linux Kernel</em> (Bovet &amp; Cesati), <strong>Chapter 2: Memory Addressing</strong>.\n<strong>Code</strong>: <a href=\"https://github.com/torvalds/linux/blob/master/mm/memory.c\">linux/mm/memory.c</a> â€” See <code>access_process_vm</code>, the kernel&#39;s internal version of PEEKDATA.\n<strong>Why</strong>: It explains the Page Global Directory (PGD) and page table walks that occur every time you call <code>PTRACE_PEEKDATA</code>.\n<strong>Pedagogical Timing</strong>: Read <strong>before starting Milestone 2</strong>. It explains why you cannot simply dereference a tracee&#39;s pointer and why the &quot;word-walking&quot; algorithm is necessary.</p>\n<hr>\n<h2 id=\"process-lifecycle-fork-exec-clone\">Process Lifecycle (Fork, Exec, Clone)</h2>\n<p><strong>Paper</strong>: <a href=\"https://www.cs.cmu.edu/~rdriley/487/papers/Thompson_1984_ReflectionsonTrustingTrust.pdf\">Reflections on Trusting Trust</a> (Ken Thompson).\n<strong>Code</strong>: <a href=\"https://github.com/torvalds/linux/blob/master/kernel/fork.c\">linux/kernel/fork.c</a> â€” The <code>do_fork</code> (or <code>kernel_clone</code>) implementation.\n<strong>Best Explanation</strong>: <em>The Linux Programming Interface</em> (Michael Kerrisk), <strong>Chapter 24 (Process Creation)</strong> and <strong>Chapter 27 (Program Execution)</strong>.\n<strong>Why</strong>: Kerrisk is the gold standard for explaining how <code>execve</code> replaces the stack and heap, which is vital for understanding <code>PTRACE_EVENT_EXEC</code>.\n<strong>Pedagogical Timing</strong>: Read <strong>before Milestone 3</strong>. You must understand that <code>exec</code> creates a &quot;zombie&quot; relationship where the PID stays the same but the memory is fresh.</p>\n<hr>\n<h2 id=\"modern-observability-ebpf-amp-performance\">Modern Observability (eBPF &amp; Performance)</h2>\n<p><strong>Paper</strong>: <a href=\"https://www.tcpdump.org/papers/bpf-usenix93.pdf\">The BSD Packet Filter: A New Architecture for User-level Packet Capture</a> (McCanne &amp; Jacobson, 1993).\n<strong>Code</strong>: <a href=\"https://github.com/iovisor/bpftrace/blob/master/tools/syscount.bt\">bpftrace/tools/syscount.bt</a> â€” A 10-line script that does what your Milestone 4 statistics engine does, but 100x faster.\n<strong>Best Explanation</strong>: Brendan Greggâ€™s <a href=\"https://www.brendangregg.com/bpf-performance-tools-book.html\">BPF Performance Tools</a>, <strong>Chapter 1: Introduction</strong>.\n<strong>Why</strong>: It explains why &quot;the observer effect&quot; you measured in Milestone 4 is the reason the industry moved from ptrace to eBPF.\n<strong>Pedagogical Timing</strong>: Read <strong>AFTER completing the project</strong>. It provides the &quot;What&#39;s Next&quot; context for how these problems are solved in high-performance production environments.</p>\n<hr>\n<h2 id=\"technical-standards-signals\">Technical Standards (Signals)</h2>\n<p><strong>Spec</strong>: <a href=\"https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04\">POSIX.1-2008: Signal Concepts</a>.\n<strong>Best Explanation</strong>: <a href=\"https://cr.yp.to/docs/selfpipe.html\">The &quot;Self-Pipe Trick&quot;</a> by DJB.\n<strong>Why</strong>: It is the definitive argument for why signal handlers must be minimal and use the &quot;flag-setting&quot; pattern you implemented in Milestone 4.\n<strong>Pedagogical Timing</strong>: Read <strong>during Milestone 4</strong> when implementing the <code>SIGINT</code> handler and clean detach logic.</p>\n","toc":[{"level":1,"text":"ðŸŽ¯ Project Charter: System Call Tracer (strace clone)","id":"-project-charter-system-call-tracer-strace-clone"},{"level":2,"text":"What You Are Building","id":"what-you-are-building"},{"level":2,"text":"Why This Project Exists","id":"why-this-project-exists"},{"level":2,"text":"What You Will Be Able to Do When Done","id":"what-you-will-be-able-to-do-when-done"},{"level":2,"text":"Final Deliverable","id":"final-deliverable"},{"level":2,"text":"Is This Project For You?","id":"is-this-project-for-you"},{"level":2,"text":"Estimated Effort","id":"estimated-effort"},{"level":2,"text":"Definition of Done","id":"definition-of-done"},{"level":1,"text":"System Call Tracer (strace clone)","id":"system-call-tracer-strace-clone"},{"level":1,"text":"Milestone 1: Basic ptrace Syscall Intercept","id":"milestone-1-basic-ptrace-syscall-intercept"},{"level":2,"text":"Where You Are in the System","id":"where-you-are-in-the-system"},{"level":2,"text":"The Core Revelation: ptrace Stops Twice","id":"the-core-revelation-ptrace-stops-twice"},{"level":2,"text":"The ptrace Lifecycle","id":"the-ptrace-lifecycle"},{"level":3,"text":"Step 1: Fork and TRACEME","id":"step-1-fork-and-traceme"},{"level":3,"text":"Step 2: The PTRACE_SYSCALL + waitpid Loop","id":"step-2-the-ptrace_syscall-waitpid-loop"},{"level":2,"text":"Let&#39;s unpack those waitpid status macros â€” they&#39;re not optional knowledge, they&#39;re your primary tool for understanding what happened to the tracee.","id":"let39s-unpack-those-waitpid-status-macros-they39re-not-optional-knowledge-they39re-your-primary-tool-for-understanding-what-happened-to-the-tracee"},{"level":2,"text":"Understanding waitpid Status","id":"understanding-waitpid-status"},{"level":2,"text":"x86_64 Syscall Register Conventions","id":"x86_64-syscall-register-conventions"},{"level":2,"text":"Three-Level View: What Happens During a Syscall","id":"three-level-view-what-happens-during-a-syscall"},{"level":2,"text":"The Toggle Flag in Practice","id":"the-toggle-flag-in-practice"},{"level":2,"text":"Read through this carefully. Notice the subtle continuation in the signal-delivery case: when you handle a signal stop, you call PTRACE_SYSCALL with the signal number immediately in the handler and continue to skip the PTRACE_SYSCALL at the top of the loop â€” otherwise you&#39;d call it twice and lose an event.","id":"read-through-this-carefully-notice-the-subtle-continuation-in-the-signal-delivery-case-when-you-handle-a-signal-stop-you-call-ptrace_syscall-with-the-signal-number-immediately-in-the-handler-and-continue-to-skip-the-ptrace_syscall-at-the-top-of-the-loop-otherwise-you39d-call-it-twice-and-lose-an-event"},{"level":2,"text":"Signal Stops vs Syscall Stops","id":"signal-stops-vs-syscall-stops"},{"level":3,"text":"Approach 1: PTRACE_O_TRACESYSGOOD (Recommended)","id":"approach-1-ptrace_o_tracesysgood-recommended"},{"level":3,"text":"Approach 2: Check orig_rax","id":"approach-2-check-orig_rax"},{"level":2,"text":"Error Detection on x86_64","id":"error-detection-on-x86_64"},{"level":2,"text":"The cast (long)regs.rax matters. regs.rax is unsigned long long. If a syscall returns -2, the bit pattern in rax is 0xFFFFFFFFFFFFFFFE â€” which as an unsigned 64-bit integer is a very large positive number. By casting to long (signed), you restore the correct negative interpretation. Always cast rax to long before comparing.","id":"the-cast-longregsrax-matters-regsrax-is-unsigned-long-long-if-a-syscall-returns-2-the-bit-pattern-in-rax-is-0xfffffffffffffffe-which-as-an-unsigned-64-bit-integer-is-a-very-large-positive-number-by-casting-to-long-signed-you-restore-the-correct-negative-interpretation-always-cast-rax-to-long-before-comparing"},{"level":2,"text":"Putting It Together: Complete Working Tracer","id":"putting-it-together-complete-working-tracer"},{"level":3,"text":"Building and Testing","id":"building-and-testing"},{"level":2,"text":"You should see a stream of syscall(N) = M lines, followed by +++ exited with 0 +++. The syscall numbers will be x86_64 numbers â€” 59 is execve, 12 is brk, 9 is mmap. You&#39;ll decode these in Milestone 2.","id":"you-should-see-a-stream-of-syscalln-m-lines-followed-by-exited-with-0-the-syscall-numbers-will-be-x86_64-numbers-59-is-execve-12-is-brk-9-is-mmap-you39ll-decode-these-in-milestone-2"},{"level":2,"text":"Common Bugs and How to Avoid Them","id":"common-bugs-and-how-to-avoid-them"},{"level":3,"text":"Bug 1: Reading rax on Entry","id":"bug-1-reading-rax-on-entry"},{"level":3,"text":"Bug 2: Not Re-Injecting Signals","id":"bug-2-not-re-injecting-signals"},{"level":3,"text":"Bug 3: Forgetting the Toggle","id":"bug-3-forgetting-the-toggle"},{"level":3,"text":"Bug 4: Missing PTRACE_TRACEME Before exec","id":"bug-4-missing-ptrace_traceme-before-exec"},{"level":2,"text":"If the child calls exec before PTRACE_TRACEME, the new program is not traced. The parent&#39;s waitpid will block forever (or until the child exits). Always PTRACE_TRACEME first.","id":"if-the-child-calls-exec-before-ptrace_traceme-the-new-program-is-not-traced-the-parent39s-waitpid-will-block-forever-or-until-the-child-exits-always-ptrace_traceme-first"},{"level":2,"text":"Hardware Soul: What the CPU Does","id":"hardware-soul-what-the-cpu-does"},{"level":2,"text":"When your tracer intercepts a syscall, what&#39;s happening in the hardware?\nCache behavior: The syscall instruction causes a CPU privilege level transition. The kernel entry code lives in a different cache region than userspace. This is an L1 instruction cache miss (cold path) on the first syscall of a program, then typically hot for subsequent calls. The struct user_regs_struct you read with PTRACE_GETREGS is a 216-byte structure â€” it fits in approximately 4 cache lines (64 bytes each). Each PTRACE_GETREGS call copies this structure across process boundaries, touching 4 cache lines.\nTLB behavior: The waitpid call that blocks your tracer is a full context switch. The CPU flushes TLB entries on context switch (or invalidates them on architectures with ASID support). When your tracer resumes to inspect registers, the kernel maps the tracee&#39;s register state into your address space â€” no TLB miss for the register copy, but your tracer&#39;s own TLB state must be reconstructed.\nBranch prediction: The WIFSTOPPED/WIFEXITED/WIFSIGNALED macros are simple bit operations. They&#39;re essentially free. The branch predictor will correctly predict &quot;almost always WIFSTOPPED&quot; after the first few iterations.\nSyscall overhead: Each ptrace(PTRACE_SYSCALL, ...) is itself a syscall. Each waitpid is a syscall. So intercepting one syscall in the tracee costs two syscalls in the tracer (plus the context switch overhead and cache effects). This is why ptrace-based tracing has significant overhead â€” strace can slow a program by 2-10x depending on syscall frequency.","id":"when-your-tracer-intercepts-a-syscall-what39s-happening-in-the-hardware-cache-behavior-the-syscall-instruction-causes-a-cpu-privilege-level-transition-the-kernel-entry-code-lives-in-a-different-cache-region-than-userspace-this-is-an-l1-instruction-cache-miss-cold-path-on-the-first-syscall-of-a-program-then-typically-hot-for-subsequent-calls-the-struct-user_regs_struct-you-read-with-ptrace_getregs-is-a-216-byte-structure-it-fits-in-approximately-4-cache-lines-64-bytes-each-each-ptrace_getregs-call-copies-this-structure-across-process-boundaries-touching-4-cache-lines-tlb-behavior-the-waitpid-call-that-blocks-your-tracer-is-a-full-context-switch-the-cpu-flushes-tlb-entries-on-context-switch-or-invalidates-them-on-architectures-with-asid-support-when-your-tracer-resumes-to-inspect-registers-the-kernel-maps-the-tracee39s-register-state-into-your-address-space-no-tlb-miss-for-the-register-copy-but-your-tracer39s-own-tlb-state-must-be-reconstructed-branch-prediction-the-wifstoppedwifexitedwifsignaled-macros-are-simple-bit-operations-they39re-essentially-free-the-branch-predictor-will-correctly-predict-quotalmost-always-wifstoppedquot-after-the-first-few-iterations-syscall-overhead-each-ptraceptrace_syscall-is-itself-a-syscall-each-waitpid-is-a-syscall-so-intercepting-one-syscall-in-the-tracee-costs-two-syscalls-in-the-tracer-plus-the-context-switch-overhead-and-cache-effects-this-is-why-ptrace-based-tracing-has-significant-overhead-strace-can-slow-a-program-by-2-10x-depending-on-syscall-frequency"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":3,"text":"1. GDB Uses the Same Mechanism (Just With PTRACE_SINGLESTEP)","id":"1-gdb-uses-the-same-mechanism-just-with-ptrace_singlestep"},{"level":3,"text":"2. seccomp-BPF Filters Only at Entry","id":"2-seccomp-bpf-filters-only-at-entry"},{"level":3,"text":"3. strace -e inject: Modifying Syscalls In Flight","id":"3-strace-e-inject-modifying-syscalls-in-flight"},{"level":3,"text":"4. The x86_64 syscall ABI vs. the C Calling Convention","id":"4-the-x86_64-syscall-abi-vs-the-c-calling-convention"},{"level":3,"text":"5. The Performance Cost of Observability","id":"5-the-performance-cost-of-observability"},{"level":2,"text":"Summary: What You&#39;ve Built","id":"summary-what-you39ve-built"},{"level":1,"text":"Milestone 2: Argument Decoding","id":"milestone-2-argument-decoding"},{"level":2,"text":"Where You Are Now","id":"where-you-are-now"},{"level":2,"text":"This milestone builds everything that transforms the first form into the second. You&#39;ll build a syscall name table, extract arguments from the six x86_64 argument registers, read string arguments word-by-word from the tracee&#39;s memory, decode bitmask flags into human-readable names, and format output in strace style.\nThere&#39;s one concept at the center of this milestone that is genuinely surprising the first time you encounter it. Let&#39;s start there.","id":"this-milestone-builds-everything-that-transforms-the-first-form-into-the-second-you39ll-build-a-syscall-name-table-extract-arguments-from-the-six-x86_64-argument-registers-read-string-arguments-word-by-word-from-the-tracee39s-memory-decode-bitmask-flags-into-human-readable-names-and-format-output-in-strace-style-there39s-one-concept-at-the-center-of-this-milestone-that-is-genuinely-surprising-the-first-time-you-encounter-it-let39s-start-there"},{"level":2,"text":"The Core Revelation: Address Spaces Are Not Shared","id":"the-core-revelation-address-spaces-are-not-shared"},{"level":2,"text":"PTRACE_PEEKDATA: The Word-by-Word Bridge","id":"ptrace_peekdata-the-word-by-word-bridge"},{"level":3,"text":"The errno Ambiguity â€” A Critical Trap","id":"the-errno-ambiguity-a-critical-trap"},{"level":3,"text":"Reading a String Word by Word","id":"reading-a-string-word-by-word"},{"level":3,"text":"Null Pointer Check â€” Don&#39;t Peek at NULL","id":"null-pointer-check-don39t-peek-at-null"},{"level":2,"text":"Building the Syscall Name Table","id":"building-the-syscall-name-table"},{"level":3,"text":"Table Design","id":"table-design"},{"level":2,"text":"Extracting Arguments from Registers","id":"extracting-arguments-from-registers"},{"level":2,"text":"Now args[0] is always argument 1, args[1] is always argument 2, and so on. You can build a dispatch table keyed on syscall number that says &quot;for syscall N, argument 0 is a string, argument 1 is an integer flags field, argument 2 is a mode.&quot;","id":"now-args0-is-always-argument-1-args1-is-always-argument-2-and-so-on-you-can-build-a-dispatch-table-keyed-on-syscall-number-that-says-quotfor-syscall-n-argument-0-is-a-string-argument-1-is-an-integer-flags-field-argument-2-is-a-modequot"},{"level":2,"text":"The Argument Schema: Knowing What Type Each Argument Is","id":"the-argument-schema-knowing-what-type-each-argument-is"},{"level":2,"text":"Bitmask Flag Decoding","id":"bitmask-flag-decoding"},{"level":2,"text":"The O_RDONLY edge case is important. O_RDONLY is defined as 0 in the Linux headers. A bitwise AND with zero always produces zero â€” so you can&#39;t detect O_RDONLY by masking. The special case handles this: if the entire value is 0 and the first table entry covers 0, print it directly.\nSimilarly, PROT_NONE is 0 for mmap. The same logic applies.","id":"the-o_rdonly-edge-case-is-important-o_rdonly-is-defined-as-0-in-the-linux-headers-a-bitwise-and-with-zero-always-produces-zero-so-you-can39t-detect-o_rdonly-by-masking-the-special-case-handles-this-if-the-entire-value-is-0-and-the-first-table-entry-covers-0-print-it-directly-similarly-prot_none-is-0-for-mmap-the-same-logic-applies"},{"level":2,"text":"Three-Level View: What Happens When You Print an Argument","id":"three-level-view-what-happens-when-you-print-an-argument"},{"level":2,"text":"Formatting Output in strace Style","id":"formatting-output-in-strace-style"},{"level":2,"text":"Integrating with the Milestone 1 Loop","id":"integrating-with-the-milestone-1-loop"},{"level":2,"text":"That&#39;s it. The entry state saves the register snapshot. The exit state uses both the saved entry registers (for arguments and syscall number) and the current rax (for the return value).","id":"that39s-it-the-entry-state-saves-the-register-snapshot-the-exit-state-uses-both-the-saved-entry-registers-for-arguments-and-syscall-number-and-the-current-rax-for-the-return-value"},{"level":2,"text":"What Real Traces Look Like","id":"what-real-traces-look-like"},{"level":2,"text":"This matches real strace output. Notice O_RDONLY|O_CLOEXEC for the flags, PROT_READ for mmap, hex address for the statbuf pointer, and the ELF magic bytes peeked out of the read buffer.","id":"this-matches-real-strace-output-notice-o_rdonlyo_cloexec-for-the-flags-prot_read-for-mmap-hex-address-for-the-statbuf-pointer-and-the-elf-magic-bytes-peeked-out-of-the-read-buffer"},{"level":2,"text":"Common Bugs in This Milestone","id":"common-bugs-in-this-milestone"},{"level":3,"text":"Bug 1: Using exit registers for argument printing","id":"bug-1-using-exit-registers-for-argument-printing"},{"level":3,"text":"Bug 2: Forgetting errno = 0 before PEEKDATA","id":"bug-2-forgetting-errno-0-before-peekdata"},{"level":3,"text":"Bug 3: Infinite loop on non-null-terminated strings","id":"bug-3-infinite-loop-on-non-null-terminated-strings"},{"level":3,"text":"Bug 4: Wrong byte order when scanning a PEEKDATA word","id":"bug-4-wrong-byte-order-when-scanning-a-peekdata-word"},{"level":3,"text":"Bug 5: Decoding flags when O_RDONLY (0) is not explicitly flagged","id":"bug-5-decoding-flags-when-o_rdonly-0-is-not-explicitly-flagged"},{"level":2,"text":"If you open a file with O_RDONLY, the flags argument is 0. Iterating through your flags table with value &amp; flag == flag will never match any entry (since 0 &amp; anything = 0). Result: decode_flags returns an empty string or prints nothing. Handle the value == 0 case explicitly by printing the name of the first table entry (which should be O_RDONLY/PROT_NONE).","id":"if-you-open-a-file-with-o_rdonly-the-flags-argument-is-0-iterating-through-your-flags-table-with-value-amp-flag-flag-will-never-match-any-entry-since-0-amp-anything-0-result-decode_flags-returns-an-empty-string-or-prints-nothing-handle-the-value-0-case-explicitly-by-printing-the-name-of-the-first-table-entry-which-should-be-o_rdonlyprot_none"},{"level":2,"text":"Hardware Soul: The Memory Cost of Argument Decoding","id":"hardware-soul-the-memory-cost-of-argument-decoding"},{"level":2,"text":"When your tracer reads a string argument, what&#39;s happening at the hardware level?\nCache lines: The tracee&#39;s string data lives in the tracee&#39;s cache. When the tracer calls PTRACE_PEEKDATA, the kernel reads the physical page. If the tracee recently accessed this string (it just put it in rdi before syscall), the data is likely in L1 or L2 cache. The kernel can satisfy the PEEKDATA from the CPU cache â€” no DRAM access needed. This is one reason PEEKDATA is &quot;only&quot; ~1,000-3,000 cycles rather than 10,000+ cycles.\nTLB: The tracee&#39;s page table mapping for the string address is likely still in the TLB (the tracee just accessed it). But your tracer is running with a different CR3 â€” its TLB entries don&#39;t include the tracee&#39;s virtual addresses. The kernel uses its own TLB tags (or temporarily switches page tables) to perform the access. Modern x86_64 CPUs use PCID (Process Context IDs) to avoid full TLB flushes on context switches, but cross-process memory access still has TLB overhead.\nContext switch cost: Every ptrace() call is a userspaceâ†’kernelâ†’userspace round trip. That&#39;s a minimum of ~200â€“500 cycles just for the mode switch, plus the actual work. For a 64-byte path name (8 PEEKDATA calls): 8 Ã— 1,500 cycles â‰ˆ 12,000 cycles. At 3 GHz, that&#39;s 4 microseconds just to read one filename. A program that opens 10,000 files takes 40ms of pure tracing overhead reading filenames â€” before any other tracing work.\nThis is why strace is slow. It&#39;s not the toggle logic or the flag decoding. It&#39;s the PEEKDATA loop. The real strace codebase addresses this with multiple optimizations we&#39;ll discuss in the Knowledge Cascade.","id":"when-your-tracer-reads-a-string-argument-what39s-happening-at-the-hardware-level-cache-lines-the-tracee39s-string-data-lives-in-the-tracee39s-cache-when-the-tracer-calls-ptrace_peekdata-the-kernel-reads-the-physical-page-if-the-tracee-recently-accessed-this-string-it-just-put-it-in-rdi-before-syscall-the-data-is-likely-in-l1-or-l2-cache-the-kernel-can-satisfy-the-peekdata-from-the-cpu-cache-no-dram-access-needed-this-is-one-reason-peekdata-is-quotonlyquot-1000-3000-cycles-rather-than-10000-cycles-tlb-the-tracee39s-page-table-mapping-for-the-string-address-is-likely-still-in-the-tlb-the-tracee-just-accessed-it-but-your-tracer-is-running-with-a-different-cr3-its-tlb-entries-don39t-include-the-tracee39s-virtual-addresses-the-kernel-uses-its-own-tlb-tags-or-temporarily-switches-page-tables-to-perform-the-access-modern-x86_64-cpus-use-pcid-process-context-ids-to-avoid-full-tlb-flushes-on-context-switches-but-cross-process-memory-access-still-has-tlb-overhead-context-switch-cost-every-ptrace-call-is-a-userspacekerneluserspace-round-trip-that39s-a-minimum-of-200500-cycles-just-for-the-mode-switch-plus-the-actual-work-for-a-64-byte-path-name-8-peekdata-calls-8-1500-cycles-12000-cycles-at-3-ghz-that39s-4-microseconds-just-to-read-one-filename-a-program-that-opens-10000-files-takes-40ms-of-pure-tracing-overhead-reading-filenames-before-any-other-tracing-work-this-is-why-strace-is-slow-it39s-not-the-toggle-logic-or-the-flag-decoding-it39s-the-peekdata-loop-the-real-strace-codebase-addresses-this-with-multiple-optimizations-we39ll-discuss-in-the-knowledge-cascade"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":3,"text":"1. /proc/PID/mem â€” Amortizing PEEKDATA Overhead","id":"1-procpidmem-amortizing-peekdata-overhead"},{"level":3,"text":"2. process_vm_readv â€” The Modern Cross-Address-Space Copy","id":"2-process_vm_readv-the-modern-cross-address-space-copy"},{"level":3,"text":"3. Virtual Memory and Page Tables â€” Why Address Spaces Are Isolated","id":"3-virtual-memory-and-page-tables-why-address-spaces-are-isolated"},{"level":3,"text":"4. GDB&#39;s x Command â€” The Same Mechanism","id":"4-gdb39s-x-command-the-same-mechanism"},{"level":3,"text":"5. ELF String Tables â€” The Same Index Structure","id":"5-elf-string-tables-the-same-index-structure"},{"level":2,"text":"The syscall name table you built â€” a fixed array indexed by number, containing string pointers â€” mirrors the structure ELF binaries use to store symbol names. An ELF file contains a .strtab section (a flat array of null-terminated strings packed end-to-end) and a .symtab section (an array of symbol entries, each containing an offset into .strtab). To find a symbol&#39;s name, you index .symtab by symbol number, read the st_name offset, then index into .strtab at that offset.\nYour table is the same pattern: array index = syscall number, value = pointer to name string. ELF just flattens the strings into one big buffer and uses offsets instead of pointers. This is a common pattern in systems software: &quot;index â†’ offset â†’ null-terminated string in a flat buffer.&quot; You&#39;ll see it in font files, debug information (DWARF), and network protocol tables.","id":"the-syscall-name-table-you-built-a-fixed-array-indexed-by-number-containing-string-pointers-mirrors-the-structure-elf-binaries-use-to-store-symbol-names-an-elf-file-contains-a-strtab-section-a-flat-array-of-null-terminated-strings-packed-end-to-end-and-a-symtab-section-an-array-of-symbol-entries-each-containing-an-offset-into-strtab-to-find-a-symbol39s-name-you-index-symtab-by-symbol-number-read-the-st_name-offset-then-index-into-strtab-at-that-offset-your-table-is-the-same-pattern-array-index-syscall-number-value-pointer-to-name-string-elf-just-flattens-the-strings-into-one-big-buffer-and-uses-offsets-instead-of-pointers-this-is-a-common-pattern-in-systems-software-quotindex-offset-null-terminated-string-in-a-flat-bufferquot-you39ll-see-it-in-font-files-debug-information-dwarf-and-network-protocol-tables"},{"level":2,"text":"Summary: What You&#39;ve Built","id":"summary-what-you39ve-built"},{"level":1,"text":"Milestone 3: Multi-Process and Fork Following","id":"milestone-3-multi-process-and-fork-following"},{"level":2,"text":"Where You Are Now","id":"where-you-are-now"},{"level":2,"text":"The Core Revelation: Tracing Is Not Inherited","id":"the-core-revelation-tracing-is-not-inherited"},{"level":3,"text":"The Race Condition That Doesn&#39;t Exist (Because You Set the Option)","id":"the-race-condition-that-doesn39t-exist-because-you-set-the-option"},{"level":2,"text":"Imagine an alternative design: you receive a fork() exit event (child PID = 12346), then you call ptrace(PTRACE_ATTACH, 12346, ...) to start tracing the new child. What&#39;s the problem?\nThere&#39;s a window. Between the moment fork() completes in the tracee and the moment your tracer&#39;s PTRACE_ATTACH syscall executes, the child is running freely. For a fast child â€” one that does minimal work and exits quickly â€” it may finish entirely within this window. You&#39;d get ESRCH (no such process) from PTRACE_ATTACH because the process no longer exists. Or worse, the child might spawn its own children before you attach, which are also untraced.\nThis is a classic Time-of-Check-to-Time-of-Use (TOCTOU) race condition. The &quot;check&quot; is fork() returning a PID, and the &quot;use&quot; is attaching to that PID â€” but the PID&#39;s lifetime is unconstrained between those two events.\nPTRACE_O_TRACEFORK eliminates the race entirely. The kernel performs the attachment inside the fork() syscall handler, before the child process ever gets scheduled. The child begins its life in a ptrace stop state. By the time you learn a fork happened, the child is already frozen, waiting for you. No race. No window. Atomic guarantee.","id":"imagine-an-alternative-design-you-receive-a-fork-exit-event-child-pid-12346-then-you-call-ptraceptrace_attach-12346-to-start-tracing-the-new-child-what39s-the-problem-there39s-a-window-between-the-moment-fork-completes-in-the-tracee-and-the-moment-your-tracer39s-ptrace_attach-syscall-executes-the-child-is-running-freely-for-a-fast-child-one-that-does-minimal-work-and-exits-quickly-it-may-finish-entirely-within-this-window-you39d-get-esrch-no-such-process-from-ptrace_attach-because-the-process-no-longer-exists-or-worse-the-child-might-spawn-its-own-children-before-you-attach-which-are-also-untraced-this-is-a-classic-time-of-check-to-time-of-use-toctou-race-condition-the-quotcheckquot-is-fork-returning-a-pid-and-the-quotusequot-is-attaching-to-that-pid-but-the-pid39s-lifetime-is-unconstrained-between-those-two-events-ptrace_o_tracefork-eliminates-the-race-entirely-the-kernel-performs-the-attachment-inside-the-fork-syscall-handler-before-the-child-process-ever-gets-scheduled-the-child-begins-its-life-in-a-ptrace-stop-state-by-the-time-you-learn-a-fork-happened-the-child-is-already-frozen-waiting-for-you-no-race-no-window-atomic-guarantee"},{"level":2,"text":"Setting the Options: Before the Fork Happens","id":"setting-the-options-before-the-fork-happens"},{"level":2,"text":"Switching to waitpid(-1): Catching Any Child","id":"switching-to-waitpid-1-catching-any-child"},{"level":2,"text":"Decoding ptrace Events: The status&gt;&gt;16 Trick","id":"decoding-ptrace-events-the-statusgtgt16-trick"},{"level":2,"text":"Retrieving the New Child PID with PTRACE_GETEVENTMSG","id":"retrieving-the-new-child-pid-with-ptrace_geteventmsg"},{"level":2,"text":"Per-PID State: The Hash Map","id":"per-pid-state-the-hash-map"},{"level":3,"text":"Designing the State Struct","id":"designing-the-state-struct"},{"level":3,"text":"A Simple Open-Addressing Hash Map","id":"a-simple-open-addressing-hash-map"},{"level":2,"text":"PID-Tagged Output","id":"pid-tagged-output"},{"level":2,"text":"This means printing the fork-type syscall result in the parent&#39;s context when the fork event fires. The parent&#39;s orig_rax contains the clone/fork syscall number, and the new child&#39;s PID is the return value. You print it at the fork event stop, which fires at the exit of the fork syscall in the parent â€” so you have both the syscall name and the child PID.","id":"this-means-printing-the-fork-type-syscall-result-in-the-parent39s-context-when-the-fork-event-fires-the-parent39s-orig_rax-contains-the-clonefork-syscall-number-and-the-new-child39s-pid-is-the-return-value-you-print-it-at-the-fork-event-stop-which-fires-at-the-exit-of-the-fork-syscall-in-the-parent-so-you-have-both-the-syscall-name-and-the-child-pid"},{"level":2,"text":"Handling PTRACE_EVENT_EXEC: Address Space Replacement","id":"handling-ptrace_event_exec-address-space-replacement"},{"level":2,"text":"Tracking Active Processes: The Exit Count","id":"tracking-active-processes-the-exit-count"},{"level":2,"text":"Putting It All Together: The Complete Multi-Process Loop","id":"putting-it-all-together-the-complete-multi-process-loop"},{"level":2,"text":"Three-Level View: What Happens When fork() Is Intercepted","id":"three-level-view-what-happens-when-fork-is-intercepted"},{"level":2,"text":"The Tricky Cases: What Can Go Wrong","id":"the-tricky-cases-what-can-go-wrong"},{"level":3,"text":"Race: New Child&#39;s First Stop Arrives Before Fork Event","id":"race-new-child39s-first-stop-arrives-before-fork-event"},{"level":3,"text":"Clone Flags and Thread vs. Process","id":"clone-flags-and-thread-vs-process"},{"level":3,"text":"Exec Mid-Trace: The Toggle Confusion","id":"exec-mid-trace-the-toggle-confusion"},{"level":3,"text":"vfork: Parent Waits for Child","id":"vfork-parent-waits-for-child"},{"level":2,"text":"Hardware Soul: The Cost of Multi-Process Tracing","id":"hardware-soul-the-cost-of-multi-process-tracing"},{"level":2,"text":"When you&#39;re tracing 10 simultaneous processes, what&#39;s the hardware doing?\nCache thrashing from context switches: Each waitpid return potentially represents a context switch to a different process. A context switch replaces the CPU&#39;s register file, flushes the L1 instruction TLB (if no PCID), and may invalidate L1 data cache lines that belonged to the previous process. With 10 processes interleaving, you&#39;re generating 20 context switches per syscall (enter tracee â†’ tracer, inspect, tracer â†’ tracee, exit tracee â†’ tracer, inspect, tracer â†’ next tracee...). Each context switch costs 1,000â€“5,000 cycles on modern hardware.\nState map lookup on hot path: Every waitpid event requires a state map lookup. With a 256-slot open-addressing table and load factor 0.1, the average lookup is O(1) with essentially zero collision probing. The entire table (59 KB) fits in L2 cache. Once the trace starts, the table stays hot. A lookup costs roughly 5â€“15 cycles for the hash computation and 1-2 cache hits.\nstruct user_regs_struct size: At 216 bytes, saving entry_regs requires writing ~4 cache lines. At 64 bytes per cache line, that&#39;s 4 cache line writes per entry stop. With the state map in L2 cache (hot), this costs approximately 4 Ã— 5 cycles = 20 cycles for the memory write â€” negligible compared to the context switch overhead.\nThe TLB picture: Your tracer runs in its own address space. Every PTRACE_GETREGS and PTRACE_PEEKDATA call is a syscall into the kernel. The kernel access to tracee memory uses the kernel&#39;s own mapping of physical memory (which doesn&#39;t require switching CR3) â€” so the TLB concern for your tracer&#39;s own address space is limited to the syscall entry/exit mechanism itself, not per-PEEKDATA.","id":"when-you39re-tracing-10-simultaneous-processes-what39s-the-hardware-doing-cache-thrashing-from-context-switches-each-waitpid-return-potentially-represents-a-context-switch-to-a-different-process-a-context-switch-replaces-the-cpu39s-register-file-flushes-the-l1-instruction-tlb-if-no-pcid-and-may-invalidate-l1-data-cache-lines-that-belonged-to-the-previous-process-with-10-processes-interleaving-you39re-generating-20-context-switches-per-syscall-enter-tracee-tracer-inspect-tracer-tracee-exit-tracee-tracer-inspect-tracer-next-tracee-each-context-switch-costs-10005000-cycles-on-modern-hardware-state-map-lookup-on-hot-path-every-waitpid-event-requires-a-state-map-lookup-with-a-256-slot-open-addressing-table-and-load-factor-01-the-average-lookup-is-o1-with-essentially-zero-collision-probing-the-entire-table-59-kb-fits-in-l2-cache-once-the-trace-starts-the-table-stays-hot-a-lookup-costs-roughly-515-cycles-for-the-hash-computation-and-1-2-cache-hits-struct-user_regs_struct-size-at-216-bytes-saving-entry_regs-requires-writing-4-cache-lines-at-64-bytes-per-cache-line-that39s-4-cache-line-writes-per-entry-stop-with-the-state-map-in-l2-cache-hot-this-costs-approximately-4-5-cycles-20-cycles-for-the-memory-write-negligible-compared-to-the-context-switch-overhead-the-tlb-picture-your-tracer-runs-in-its-own-address-space-every-ptrace_getregs-and-ptrace_peekdata-call-is-a-syscall-into-the-kernel-the-kernel-access-to-tracee-memory-uses-the-kernel39s-own-mapping-of-physical-memory-which-doesn39t-require-switching-cr3-so-the-tlb-concern-for-your-tracer39s-own-address-space-is-limited-to-the-syscall-entryexit-mechanism-itself-not-per-peekdata"},{"level":2,"text":"Common Bugs in This Milestone","id":"common-bugs-in-this-milestone"},{"level":3,"text":"Bug 1: Not Resuming the New Child","id":"bug-1-not-resuming-the-new-child"},{"level":3,"text":"Bug 2: Using waitpid(original_pid) instead of waitpid(-1)","id":"bug-2-using-waitpidoriginal_pid-instead-of-waitpid-1"},{"level":3,"text":"Bug 3: Not Checking for NULL from state_map_find","id":"bug-3-not-checking-for-null-from-state_map_find"},{"level":3,"text":"Bug 4: Misidentifying Event Stops as Syscall Stops","id":"bug-4-misidentifying-event-stops-as-syscall-stops"},{"level":3,"text":"Bug 5: Double-Decrementing active_count","id":"bug-5-double-decrementing-active_count"},{"level":2,"text":"The loop exits prematurely or goes negative. Decrement exactly once per PID exit event.","id":"the-loop-exits-prematurely-or-goes-negative-decrement-exactly-once-per-pid-exit-event"},{"level":2,"text":"Testing Multi-Process Tracing","id":"testing-multi-process-tracing"},{"level":2,"text":"The interleaving order depends on scheduler timing and may vary between runs â€” that&#39;s expected.","id":"the-interleaving-order-depends-on-scheduler-timing-and-may-vary-between-runs-that39s-expected"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":3,"text":"1. Container Runtimes â€” The Entire Process Tree Must Be Observed","id":"1-container-runtimes-the-entire-process-tree-must-be-observed"},{"level":3,"text":"2. PID Namespaces and Why waitpid(-1) Works","id":"2-pid-namespaces-and-why-waitpid-1-works"},{"level":3,"text":"3. Race Conditions in Tracing â€” The TOCTOU Window","id":"3-race-conditions-in-tracing-the-toctou-window"},{"level":3,"text":"4. Hash Map Design at the System Level","id":"4-hash-map-design-at-the-system-level"},{"level":3,"text":"5. exec and Address Space Replacement â€” Why Pointers Die","id":"5-exec-and-address-space-replacement-why-pointers-die"},{"level":2,"text":"exec() is the most radical operation in Unix process management. The kernel discards the old address space and installs a new one in a single atomic operation from the process&#39;s perspective. For your tracer, this creates a fundamental discontinuity: any memory address you read from the tracee before exec is now meaningless.\nThis is the same concept that makes certain security vulnerabilities dangerous. Return-oriented programming (ROP) attacks chain together existing code fragments (&quot;gadgets&quot;) in the target process&#39;s memory. If the target calls exec(), all those gadgets are gone â€” the ROP chain is broken. Address Space Layout Randomization (ASLR) randomizes where libraries and stack are placed on every exec, making it impossible to predict gadget addresses across exec boundaries.\nFor database engines that implement process-based connection isolation (PostgreSQL&#39;s postmaster/backend model), exec after fork is how each connection gets a clean state. The postmaster forks a child, which optionally execs a fresh backend binary. The backend has a fresh address space with no inherited heap fragments, memory leaks, or leftover state from other connections.\nYour PTRACE_EVENT_EXEC handler â€” clearing cached state when exec fires â€” is the minimal correct response to this reality. The next time you build anything that persists state across exec boundaries (a container runtime, a process supervisor, a debugging framework), you&#39;ll know exactly which state survives exec (PID, file descriptors without O_CLOEXEC, certain kernel state) and which does not (everything in the address space).","id":"exec-is-the-most-radical-operation-in-unix-process-management-the-kernel-discards-the-old-address-space-and-installs-a-new-one-in-a-single-atomic-operation-from-the-process39s-perspective-for-your-tracer-this-creates-a-fundamental-discontinuity-any-memory-address-you-read-from-the-tracee-before-exec-is-now-meaningless-this-is-the-same-concept-that-makes-certain-security-vulnerabilities-dangerous-return-oriented-programming-rop-attacks-chain-together-existing-code-fragments-quotgadgetsquot-in-the-target-process39s-memory-if-the-target-calls-exec-all-those-gadgets-are-gone-the-rop-chain-is-broken-address-space-layout-randomization-aslr-randomizes-where-libraries-and-stack-are-placed-on-every-exec-making-it-impossible-to-predict-gadget-addresses-across-exec-boundaries-for-database-engines-that-implement-process-based-connection-isolation-postgresql39s-postmasterbackend-model-exec-after-fork-is-how-each-connection-gets-a-clean-state-the-postmaster-forks-a-child-which-optionally-execs-a-fresh-backend-binary-the-backend-has-a-fresh-address-space-with-no-inherited-heap-fragments-memory-leaks-or-leftover-state-from-other-connections-your-ptrace_event_exec-handler-clearing-cached-state-when-exec-fires-is-the-minimal-correct-response-to-this-reality-the-next-time-you-build-anything-that-persists-state-across-exec-boundaries-a-container-runtime-a-process-supervisor-a-debugging-framework-you39ll-know-exactly-which-state-survives-exec-pid-file-descriptors-without-o_cloexec-certain-kernel-state-and-which-does-not-everything-in-the-address-space"},{"level":2,"text":"Summary: What You&#39;ve Built","id":"summary-what-you39ve-built"},{"level":1,"text":"Milestone 4: Filtering and Statistics","id":"milestone-4-filtering-and-statistics"},{"level":2,"text":"Where You Are Now","id":"where-you-are-now"},{"level":2,"text":"The Core Revelation: You&#39;re Not Timing the Syscall","id":"the-core-revelation-you39re-not-timing-the-syscall"},{"level":3,"text":"CLOCK_MONOTONIC vs CLOCK_REALTIME","id":"clock_monotonic-vs-clock_realtime"},{"level":2,"text":"Always use CLOCK_MONOTONIC for measuring durations between two events. Always use CLOCK_REALTIME only when you need the actual calendar time.","id":"always-use-clock_monotonic-for-measuring-durations-between-two-events-always-use-clock_realtime-only-when-you-need-the-actual-calendar-time"},{"level":2,"text":"Extending Per-PID State for Timing","id":"extending-per-pid-state-for-timing"},{"level":2,"text":"Building the Statistics Accumulator","id":"building-the-statistics-accumulator"},{"level":3,"text":"Printing the Summary Table","id":"printing-the-summary-table"},{"level":2,"text":"Note that the summary is printed to stderr by default (or to the -o file if specified â€” we&#39;ll set that up shortly). When you print the normal trace output to stderr and the summary also to stderr, you can redirect them independently.","id":"note-that-the-summary-is-printed-to-stderr-by-default-or-to-the-o-file-if-specified-we39ll-set-that-up-shortly-when-you-print-the-normal-trace-output-to-stderr-and-the-summary-also-to-stderr-you-can-redirect-them-independently"},{"level":2,"text":"Syscall Filtering with -e trace=","id":"syscall-filtering-with-e-trace"},{"level":3,"text":"Parsing the Filter String","id":"parsing-the-filter-string"},{"level":3,"text":"Applying the Filter","id":"applying-the-filter"},{"level":2,"text":"Note: stats_record() is called before print_syscall() in the exit handler, so statistics always accumulate regardless of the filter. The filter only gates printing.","id":"note-stats_record-is-called-before-print_syscall-in-the-exit-handler-so-statistics-always-accumulate-regardless-of-the-filter-the-filter-only-gates-printing"},{"level":2,"text":"File Output with -o","id":"file-output-with-o"},{"level":2,"text":"The summary table (stats_print) should write to the same trace_out file if -o is active. If no -o flag is used, write the summary to stderr (so it appears in the terminal even when the trace is piped elsewhere).","id":"the-summary-table-stats_print-should-write-to-the-same-trace_out-file-if-o-is-active-if-no-o-flag-is-used-write-the-summary-to-stderr-so-it-appears-in-the-terminal-even-when-the-trace-is-piped-elsewhere"},{"level":2,"text":"Command-Line Argument Parsing","id":"command-line-argument-parsing"},{"level":2,"text":"getopt() is POSIX-standard and available on any Linux system. optarg is a global pointer to the current option&#39;s argument. optind is the index of the first non-option argument after processing â€” pointing at your target program&#39;s argv.","id":"getopt-is-posix-standard-and-available-on-any-linux-system-optarg-is-a-global-pointer-to-the-current-option39s-argument-optind-is-the-index-of-the-first-non-option-argument-after-processing-pointing-at-your-target-program39s-argv"},{"level":2,"text":"PTRACE_ATTACH: Tracing a Running Process","id":"ptrace_attach-tracing-a-running-process"},{"level":3,"text":"How PTRACE_ATTACH Works","id":"how-ptrace_attach-works"},{"level":3,"text":"The ptrace_scope Permission Wall","id":"the-ptrace_scope-permission-wall"},{"level":3,"text":"Key Difference from Fork+TRACEME","id":"key-difference-from-forktraceme"},{"level":2,"text":"With fork+TRACEME, the tracee starts in a controlled state: it requested tracing, exec&#39;d the target program, and paused at the post-exec SIGTRAP. The toggle starts at 0 (not mid-syscall). The address space is fresh.\nWith PTRACE_ATTACH, the target process might be anywhere in its execution: inside a syscall (having executed the syscall instruction but not yet returned), between syscalls, in a signal handler. You cannot know. The toggle must conservatively start at 0 (assume you&#39;re at an entry boundary), and the first stop after PTRACE_SYSCALL will tell you more. If the process was stopped mid-syscall, you&#39;ll get an exit stop first â€” which, with toggle at 0, you&#39;d misidentify as an entry stop. This produces one garbage print, then the trace self-corrects. Real strace handles this edge case by checking orig_rax on the first stop to determine whether it looks like an entry or exit. For this milestone, the conservative approach (start at 0) is acceptable.","id":"with-forktraceme-the-tracee-starts-in-a-controlled-state-it-requested-tracing-exec39d-the-target-program-and-paused-at-the-post-exec-sigtrap-the-toggle-starts-at-0-not-mid-syscall-the-address-space-is-fresh-with-ptrace_attach-the-target-process-might-be-anywhere-in-its-execution-inside-a-syscall-having-executed-the-syscall-instruction-but-not-yet-returned-between-syscalls-in-a-signal-handler-you-cannot-know-the-toggle-must-conservatively-start-at-0-assume-you39re-at-an-entry-boundary-and-the-first-stop-after-ptrace_syscall-will-tell-you-more-if-the-process-was-stopped-mid-syscall-you39ll-get-an-exit-stop-first-which-with-toggle-at-0-you39d-misidentify-as-an-entry-stop-this-produces-one-garbage-print-then-the-trace-self-corrects-real-strace-handles-this-edge-case-by-checking-orig_rax-on-the-first-stop-to-determine-whether-it-looks-like-an-entry-or-exit-for-this-milestone-the-conservative-approach-start-at-0-is-acceptable"},{"level":2,"text":"Clean Detach: The SIGINT Handler","id":"clean-detach-the-sigint-handler"},{"level":2,"text":"Three-Level View: What PTRACE_DETACH Does","id":"three-level-view-what-ptrace_detach-does"},{"level":2,"text":"Hardware Soul: The Observer Effect in Practice","id":"hardware-soul-the-observer-effect-in-practice"},{"level":2,"text":"Complete Main Function: Wiring Everything Together","id":"complete-main-function-wiring-everything-together"},{"level":2,"text":"Common Bugs in This Milestone","id":"common-bugs-in-this-milestone"},{"level":3,"text":"Bug 1: Timing Across the Print","id":"bug-1-timing-across-the-print"},{"level":3,"text":"Bug 2: CLOCK_REALTIME for Duration","id":"bug-2-clock_realtime-for-duration"},{"level":3,"text":"Bug 3: Forgetting to Wait for SIGSTOP After PTRACE_ATTACH","id":"bug-3-forgetting-to-wait-for-sigstop-after-ptrace_attach"},{"level":3,"text":"Bug 4: Not Filtering But Still Suppressing Stats","id":"bug-4-not-filtering-but-still-suppressing-stats"},{"level":3,"text":"Bug 5: PTRACE_DETACH Without Stopping the Tracee First","id":"bug-5-ptrace_detach-without-stopping-the-tracee-first"},{"level":3,"text":"Bug 6: O_RDONLY = 0 in Stats vs. &quot;Not Called&quot;","id":"bug-6-o_rdonly-0-in-stats-vs-quotnot-calledquot"},{"level":2,"text":"The stats[] array is zero-initialized. stats[n].call_count == 0 means &quot;never called.&quot; But your accumulation uses stats[n].total_ns += elapsed_ns â€” what if elapsed_ns is 0? That&#39;s fine, it&#39;s still a valid count. The danger is if you mistakenly print entries with call_count == 0 in the summary. The filter if (stats[i].call_count &gt; 0) before adding to the print index prevents this.","id":"the-stats-array-is-zero-initialized-statsncall_count-0-means-quotnever-calledquot-but-your-accumulation-uses-statsntotal_ns-elapsed_ns-what-if-elapsed_ns-is-0-that39s-fine-it39s-still-a-valid-count-the-danger-is-if-you-mistakenly-print-entries-with-call_count-0-in-the-summary-the-filter-if-statsicall_count-gt-0-before-adding-to-the-print-index-prevents-this"},{"level":2,"text":"Testing Your Complete Tracer","id":"testing-your-complete-tracer"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":3,"text":"1. perf and eBPF â€” Moving Beyond ptrace&#39;s Overhead","id":"1-perf-and-ebpf-moving-beyond-ptrace39s-overhead"},{"level":3,"text":"2. PTRACE_SEIZE â€” The Evolution of Attachment","id":"2-ptrace_seize-the-evolution-of-attachment"},{"level":3,"text":"3. The Observer Effect â€” Profiling as a Physics Problem","id":"3-the-observer-effect-profiling-as-a-physics-problem"},{"level":3,"text":"4. Statistical Aggregation â€” The Pattern Behind Monitoring Systems","id":"4-statistical-aggregation-the-pattern-behind-monitoring-systems"},{"level":3,"text":"5. Signal Safety and the SIGINT Handler Pattern","id":"5-signal-safety-and-the-sigint-handler-pattern"},{"level":2,"text":"A Note on What Your Measurements Mean","id":"a-note-on-what-your-measurements-mean"},{"level":2,"text":"Before you interpret your first summary table, internalize this:\nThe percentages are meaningful. If read shows 64% of your trace time, it&#39;s genuinely the dominant syscall â€” even accounting for overhead, other syscalls would show similar relative overhead, so the relative ranking is trustworthy.\nThe absolute times are not meaningful for comparing to production. A read() that takes 100Âµs in your trace may take 5Âµs untraced. What you&#39;re measuring is &quot;how much time the tracer noticed this syscall consuming,&quot; not &quot;how long this syscall actually runs.&quot;\nThe call counts are exact. They&#39;re not subject to timing distortion. If you see 2,619 read calls, the program made exactly 2,619 read calls.\nThe error counts are exact. 18 failed connect calls means 18 real failures.\nReal strace&#39;s output header says % time not % CPU time for precisely this reason. Your output should say the same. Accuracy in communicating what you measure is a form of engineering integrity.","id":"before-you-interpret-your-first-summary-table-internalize-this-the-percentages-are-meaningful-if-read-shows-64-of-your-trace-time-it39s-genuinely-the-dominant-syscall-even-accounting-for-overhead-other-syscalls-would-show-similar-relative-overhead-so-the-relative-ranking-is-trustworthy-the-absolute-times-are-not-meaningful-for-comparing-to-production-a-read-that-takes-100s-in-your-trace-may-take-5s-untraced-what-you39re-measuring-is-quothow-much-time-the-tracer-noticed-this-syscall-consumingquot-not-quothow-long-this-syscall-actually-runsquot-the-call-counts-are-exact-they39re-not-subject-to-timing-distortion-if-you-see-2619-read-calls-the-program-made-exactly-2619-read-calls-the-error-counts-are-exact-18-failed-connect-calls-means-18-real-failures-real-strace39s-output-header-says-time-not-cpu-time-for-precisely-this-reason-your-output-should-say-the-same-accuracy-in-communicating-what-you-measure-is-a-form-of-engineering-integrity"},{"level":2,"text":"Summary: What You&#39;ve Built","id":"summary-what-you39ve-built"},{"level":1,"text":"TDD","id":"tdd"},{"level":1,"text":"TECHNICAL DESIGN SPECIFICATION: Basic ptrace Syscall Intercept (build-strace-m1)","id":"technical-design-specification-basic-ptrace-syscall-intercept-build-strace-m1"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Data Model","id":"3-data-model"},{"level":3,"text":"3.1 Process State Mapping","id":"31-process-state-mapping"},{"level":3,"text":"3.2 Register Layout (x86_64 ABI)","id":"32-register-layout-x86_64-abi"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1 int main(int argc, char *argv[])","id":"41-int-mainint-argc-char-argv"},{"level":3,"text":"4.2 static void handle_syscall(pid_t pid, ProcessState *state)","id":"42-static-void-handle_syscallpid_t-pid-processstate-state"},{"level":3,"text":"4.3 static int wait_for_event(pid_t pid, int *status)","id":"43-static-int-wait_for_eventpid_t-pid-int-status"},{"level":2,"text":"5. Algorithm Specification: The Tracing Lifecycle","id":"5-algorithm-specification-the-tracing-lifecycle"},{"level":3,"text":"5.1 Initialization (Fork/Exec)","id":"51-initialization-forkexec"},{"level":3,"text":"5.2 The Main Intercept Loop","id":"52-the-main-intercept-loop"},{"level":3,"text":"5.3 Error Detection Logic","id":"53-error-detection-logic"},{"level":2,"text":"6. Error Handling Matrix","id":"6-error-handling-matrix"},{"level":2,"text":"7. Implementation Sequence","id":"7-implementation-sequence"},{"level":3,"text":"Phase 1: The Spawner (2 Hours)","id":"phase-1-the-spawner-2-hours"},{"level":3,"text":"Phase 2: The SYSCALL Loop (2 Hours)","id":"phase-2-the-syscall-loop-2-hours"},{"level":3,"text":"Phase 3: The Toggle &amp; Registers (2 Hours)","id":"phase-3-the-toggle-amp-registers-2-hours"},{"level":3,"text":"Phase 4: Output Refinement (2 Hours)","id":"phase-4-output-refinement-2-hours"},{"level":2,"text":"8. Test Specification","id":"8-test-specification"},{"level":3,"text":"8.1 Happy Path: True/False","id":"81-happy-path-truefalse"},{"level":3,"text":"8.2 Failure Case: Missing File","id":"82-failure-case-missing-file"},{"level":3,"text":"8.3 Signal Injection: SIGINT","id":"83-signal-injection-sigint"},{"level":2,"text":"9. Performance Targets","id":"9-performance-targets"},{"level":2,"text":"10. Hardware Soul &amp; Alternative Realities","id":"10-hardware-soul-amp-alternative-realities"},{"level":1,"text":"TECHNICAL DESIGN SPECIFICATION: Argument Decoding (build-strace-m2)","id":"technical-design-specification-argument-decoding-build-strace-m2"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Data Model","id":"3-data-model"},{"level":3,"text":"3.1 Syscall Metadata Types","id":"31-syscall-metadata-types"},{"level":3,"text":"3.2 Flag Decoding Table","id":"32-flag-decoding-table"},{"level":3,"text":"3.3 Extended Process State","id":"33-extended-process-state"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1 char* read_remote_string(pid_t pid, unsigned long addr)","id":"41-char-read_remote_stringpid_t-pid-unsigned-long-addr"},{"level":3,"text":"4.2 void decode_flags(unsigned long val, const FlagEntry *table, char *out_buf)","id":"42-void-decode_flagsunsigned-long-val-const-flagentry-table-char-out_buf"},{"level":3,"text":"4.3 void print_syscall(pid_t pid, ProcessState *state, long exit_code)","id":"43-void-print_syscallpid_t-pid-processstate-state-long-exit_code"},{"level":2,"text":"5. Algorithm Specification: String Extraction via Word-Walking","id":"5-algorithm-specification-string-extraction-via-word-walking"},{"level":3,"text":"Algorithm extract_string_loop:","id":"algorithm-extract_string_loop"},{"level":2,"text":"6. Error Handling Matrix","id":"6-error-handling-matrix"},{"level":2,"text":"7. Implementation Sequence","id":"7-implementation-sequence"},{"level":3,"text":"Phase 1: The Table (2 Hours)","id":"phase-1-the-table-2-hours"},{"level":3,"text":"Phase 2: Remote Memory Logic (3 Hours)","id":"phase-2-remote-memory-logic-3-hours"},{"level":3,"text":"Phase 3: The Dispatcher (3 Hours)","id":"phase-3-the-dispatcher-3-hours"},{"level":3,"text":"Phase 4: Flag Decoding (2 Hours)","id":"phase-4-flag-decoding-2-hours"},{"level":2,"text":"8. Test Specification","id":"8-test-specification"},{"level":3,"text":"8.1 String Reading: ls","id":"81-string-reading-ls"},{"level":3,"text":"8.2 NULL Pointer: execve","id":"82-null-pointer-execve"},{"level":3,"text":"8.3 Bitmask: mmap","id":"83-bitmask-mmap"},{"level":3,"text":"8.4 Long String Truncation","id":"84-long-string-truncation"},{"level":2,"text":"9. Performance Targets","id":"9-performance-targets"},{"level":2,"text":"10. Flag Tables (Sample for Implementation)","id":"10-flag-tables-sample-for-implementation"},{"level":1,"text":"TECHNICAL DESIGN SPECIFICATION: Multi-Process and Fork Following (build-strace-m3)","id":"technical-design-specification-multi-process-and-fork-following-build-strace-m3"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Complete Data Model","id":"3-complete-data-model"},{"level":3,"text":"3.1 ProcessState Struct (Byte-Level Layout)","id":"31-processstate-struct-byte-level-layout"},{"level":3,"text":"3.2 Global State Control","id":"32-global-state-control"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1 Hash Map Interface (state_map.c)","id":"41-hash-map-interface-state_mapc"},{"level":3,"text":"4.2 Event Handling (events.c)","id":"42-event-handling-eventsc"},{"level":2,"text":"5. Algorithm Specification: The Multi-Process Dispatcher","id":"5-algorithm-specification-the-multi-process-dispatcher"},{"level":3,"text":"Algorithm: Tracing_Loop_v3","id":"algorithm-tracing_loop_v3"},{"level":2,"text":"6. Error Handling Matrix","id":"6-error-handling-matrix"},{"level":2,"text":"7. Implementation Sequence with Checkpoints","id":"7-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: State Map &amp; Hash Table (2 Hours)","id":"phase-1-state-map-amp-hash-table-2-hours"},{"level":3,"text":"Phase 2: waitpid(-1) Transition (2 Hours)","id":"phase-2-waitpid-1-transition-2-hours"},{"level":3,"text":"Phase 3: Fork Interception (3 Hours)","id":"phase-3-fork-interception-3-hours"},{"level":3,"text":"Phase 4: Exec &amp; Exit Synchronization (2 Hours)","id":"phase-4-exec-amp-exit-synchronization-2-hours"},{"level":2,"text":"8. Test Specification","id":"8-test-specification"},{"level":3,"text":"8.1 Multi-Process Pipeline","id":"81-multi-process-pipeline"},{"level":3,"text":"8.2 vfork Suspension","id":"82-vfork-suspension"},{"level":3,"text":"8.3 State Map Stress","id":"83-state-map-stress"},{"level":2,"text":"9. Performance Targets","id":"9-performance-targets"},{"level":2,"text":"10. Concurrency Specification","id":"10-concurrency-specification"},{"level":1,"text":"TECHNICAL DESIGN SPECIFICATION: Filtering and Statistics (build-strace-m4)","id":"technical-design-specification-filtering-and-statistics-build-strace-m4"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Complete Data Model","id":"3-complete-data-model"},{"level":3,"text":"3.1 TracerOptions (Configuration)","id":"31-traceroptions-configuration"},{"level":3,"text":"3.2 SyscallStats (Accumulator)","id":"32-syscallstats-accumulator"},{"level":3,"text":"3.3 Updated ProcessState (Milestone 3 Extension)","id":"33-updated-processstate-milestone-3-extension"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1 Statistics Interface (stats.h)","id":"41-statistics-interface-statsh"},{"level":3,"text":"4.2 Filtering Interface (filter.h)","id":"42-filtering-interface-filterh"},{"level":3,"text":"4.3 Attachment Interface (attach.h)","id":"43-attachment-interface-attachh"},{"level":2,"text":"5. Algorithm Specification","id":"5-algorithm-specification"},{"level":3,"text":"5.1 High-Resolution Timing Algorithm","id":"51-high-resolution-timing-algorithm"},{"level":3,"text":"5.2 Clean Detach Algorithm (SIGINT)","id":"52-clean-detach-algorithm-sigint"},{"level":2,"text":"6. Error Handling Matrix","id":"6-error-handling-matrix"},{"level":2,"text":"7. Implementation Sequence with Checkpoints","id":"7-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: CLI &amp; Filtering (2 Hours)","id":"phase-1-cli-amp-filtering-2-hours"},{"level":3,"text":"Phase 2: Timing &amp; Accumulation (3 Hours)","id":"phase-2-timing-amp-accumulation-3-hours"},{"level":3,"text":"Phase 3: The Summary Table (2 Hours)","id":"phase-3-the-summary-table-2-hours"},{"level":3,"text":"Phase 4: Attachment &amp; Detach (3 Hours)","id":"phase-4-attachment-amp-detach-3-hours"},{"level":2,"text":"8. Test Specification","id":"8-test-specification"},{"level":3,"text":"8.1 Filter Accuracy","id":"81-filter-accuracy"},{"level":3,"text":"8.2 Statistics Precision","id":"82-statistics-precision"},{"level":3,"text":"8.3 Detach Verification","id":"83-detach-verification"},{"level":2,"text":"9. Performance Targets","id":"9-performance-targets"},{"level":2,"text":"10. Concurrency Specification","id":"10-concurrency-specification"},{"level":1,"text":"Project Structure: System Call Tracer (strace clone)","id":"project-structure-system-call-tracer-strace-clone"},{"level":2,"text":"Directory Tree","id":"directory-tree"},{"level":2,"text":"Creation Order","id":"creation-order"},{"level":2,"text":"File Count Summary","id":"file-count-summary"},{"level":1,"text":"ðŸ“š Beyond the Atlas: Further Reading","id":"-beyond-the-atlas-further-reading"},{"level":2,"text":"The Intercept Engine (ptrace &amp; Signals)","id":"the-intercept-engine-ptrace-amp-signals"},{"level":2,"text":"The x86_64 Syscall ABI","id":"the-x86_64-syscall-abi"},{"level":2,"text":"Memory &amp; Address Spaces","id":"memory-amp-address-spaces"},{"level":2,"text":"Process Lifecycle (Fork, Exec, Clone)","id":"process-lifecycle-fork-exec-clone"},{"level":2,"text":"Modern Observability (eBPF &amp; Performance)","id":"modern-observability-ebpf-amp-performance"},{"level":2,"text":"Technical Standards (Signals)","id":"technical-standards-signals"}],"title":"ðŸŽ¯ Project Charter: System Call Tracer (strace clone)","markdown":"# ðŸŽ¯ Project Charter: System Call Tracer (strace clone)\n\n## What You Are Building\nA functional clone of the Linux `strace` utility that intercepts, decodes, and reports every system call made by a target process on x86_64 Linux. You will build a low-level diagnostic tool that halts a tracee at the kernel boundary, extracts its register state, dereferences string arguments from its private address space, and follows its execution across multi-process `fork` and `exec` boundaries.\n\n## Why This Project Exists\nSystem calls are the narrow gateway through which every program interacts with the world, yet they are usually treated as a hidden black box by high-level languages. Building a tracer from scratch exposes the \"register dance\" of the x86_64 ABI and the mechanics of virtual memory isolation. You will learn exactly how debuggers and sandboxes control other processes at the hardware level.\n\n## What You Will Be Able to Do When Done\n- **Intercept Kernel Transitions**: Use the `ptrace` API to pause and resume processes at syscall entry and exit.\n- **Read Remote Memory**: Implement a word-by-word reader to extract null-terminated strings from a tracee's memory space using `PTRACE_PEEKDATA`.\n- **Manage Process Trees**: Build a state machine to track multiple processes and threads as they are created via `fork`, `vfork`, and `clone`.\n- **Decode Binary ABIs**: Translate raw register values into human-readable flags (e.g., `O_RDONLY | O_CREAT`) and symbolic syscall names.\n- **Profile System Performance**: Calculate high-resolution timing statistics using `CLOCK_MONOTONIC` to identify syscall bottlenecks.\n\n## Final Deliverable\nA standalone CLI utility (approximately 1,500 lines of C or Rust) that can trace complex programs like `bash` or `ls`. The tool will support PID attachment, syscall name filtering, and summary statistics output that matches the style of the professional `strace` tool.\n\n## Is This Project For You?\n**You should start this if you:**\n- Are comfortable with C or Rust and understand pointers/memory addresses.\n- Want to understand the boundary between userspace code and the Linux kernel.\n- Are curious about how debuggers like GDB actually work under the hood.\n\n**Come back after you've learned:**\n- Basic Linux process control (`fork`, `exec`, `waitpid`).\n- The fundamentals of x86_64 registers.\n- [How to use the Linux Command Line](https://linuxjourney.com/).\n\n## Estimated Effort\n| Phase | Time |\n|-------|------|\n| Basic ptrace Interception (M1) | ~5-8 hours |\n| Argument Decoding & Remote Memory (M2) | ~6-8 hours |\n| Multi-Process & Fork Following (M3) | ~5-8 hours |\n| Filtering, Statistics & Attachment (M4) | ~6-10 hours |\n| **Total** | **~22-34 hours** |\n\n## Definition of Done\nThe project is complete when:\n- The tracer prints human-readable syscall names and return values (e.g., `open(...) = 3`).\n- Path strings are successfully read from the tracee and displayed in quotes.\n- The tracer successfully follows a shell pipeline (e.g., `echo hello | cat`) across multiple PIDs.\n- The `-c` flag generates a sorted summary table of call counts, errors, and timing.\n- The tracer can attach to an existing process by PID and detach cleanly on `SIGINT` (Ctrl+C).\n\n---\n\n# System Call Tracer (strace clone)\n\nThis project builds a fully functional strace clone from scratch â€” a ptrace-based system call tracer that intercepts, decodes, and reports every syscall a target process makes on x86_64 Linux. You will start by forking a child, attaching via ptrace, and toggling between syscall entry and exit stops. Then you'll decode arguments by reading registers, dereference string pointers word-by-word from the tracee's address space, follow fork/exec across process boundaries, and finally add filtering and statistical profiling.\n\nThe project is a window into the kernel-userspace boundary. Every syscall is a precisely choreographed register dance: the application loads arguments into rdi, rsi, rdx, r10, r8, r9, puts the syscall number in rax, and executes the `syscall` instruction. The kernel saves state, dispatches, and returns a result in rax. Your tracer sits in between, mediated by ptrace, observing this dance twice per call â€” once on entry, once on exit. Understanding this mechanism is foundational to debuggers (GDB), sandboxes (seccomp), profilers (perf), and container runtimes.\n\nBy the end, you'll have a tool that can attach to any process, print decoded syscall traces with arguments, follow multi-process workloads, filter by syscall name, and produce timing statistics â€” the core functionality of the real strace.\n\n\n\n<!-- MS_ID: build-strace-m1 -->\n# Milestone 1: Basic ptrace Syscall Intercept\n## Where You Are in the System\nBefore writing a single line of code, orient yourself. Your strace clone has one job at its core: sit between a running process and the kernel, observe every syscall that crosses that boundary, and report what it sees. This milestone builds that core â€” the bare minimum tracer that intercepts syscalls and prints their numbers and return values.\nBy the end of this milestone you'll have a working tracer that can attach to any program, stop it at every syscall boundary, and print output like:\n```\nsyscall(12) = 94367748206592\nsyscall(21) = 0\nsyscall(9) = 94367748206592\nsyscall(1) = -1 EBADF\n```\nNot pretty yet â€” that's Milestone 2. But correct. And correctness here is harder than it looks, because ptrace has a behavior that trips up almost everyone the first time.\n\n![System Call Tracer â€” Satellite Architecture Map](./diagrams/diag-satellite-map.svg)\n\n---\n## The Core Revelation: ptrace Stops Twice\nHere's the assumption that will break your first implementation:\n> *You call PTRACE_SYSCALL, the child runs the syscall, stops, and you read the result.*\nThis feels right. It mirrors how you think about function interception: intercept the call, get the result. One stop, one event.\n**It's wrong.** ptrace stops the tracee *twice* per syscall â€” once at syscall entry (before the kernel executes anything) and once at syscall exit (after the kernel has completed the call and written the return value). Both stops look identical to `waitpid`. Neither stop says \"I'm the entry stop\" or \"I'm the exit stop.\" Your tracer receives a SIGTRAP both times and must maintain its own toggle flag to know which one it's seeing.\nThis isn't a quirk or an implementation detail. It's fundamental to ptrace's design â€” and it's the source of more bugs in ptrace-based tools than anything else.\nWhy does this matter practically? On entry, the return value register (`rax`) contains **garbage** â€” specifically, the return value from the *previous* syscall. On exit, the argument registers still contain the call's arguments, but they may have been modified by the kernel. If you try to read the syscall number on exit, you can â€” `orig_rax` preserves it â€” but if you try to read `rax` on entry thinking it's the return value, you'll get stale data and produce completely wrong output.\nThe double-stop model is also what makes syscall *injection* possible: between entry and exit, the kernel is executing your syscall. If you wake up at entry and modify the registers before continuing, you can change which syscall runs or what arguments it receives. If you wake up at exit and modify `rax`, you can lie about what the syscall returned. This is how `strace -e inject=` works, and how seccomp-based sandboxes intercept and redirect syscalls. You're building the foundation for all of that right now.\n\n![Syscall Entry/Exit Toggle State Machine](./diagrams/diag-m1-entry-exit-toggle.svg)\n\n---\n## The ptrace Lifecycle\nBefore the toggle flag makes sense, you need to understand the full sequence from process creation to your first intercepted syscall. Let's walk through it.\n### Step 1: Fork and TRACEME\nYour tracer starts with `fork()`. The child process needs to tell the kernel \"I want to be traced.\" It does this with `ptrace(PTRACE_TRACEME, 0, NULL, NULL)`.\n`PTRACE_TRACEME` is the only ptrace request that's made by the *tracee* (the process being traced) rather than the *tracer*. It tells the kernel: \"Whenever I make a syscall, deliver a SIGTRAP to pause me and wake up my parent.\" You call it in the child, before `exec()`.\nAfter `PTRACE_TRACEME`, the child calls `exec()` to become the target program. Here's a subtlety: after a successful `exec()` in a traced process, the kernel automatically delivers **SIGTRAP** to the tracee. This is a one-time stop that happens right at the start of the new program's execution, before any instructions run. Your parent must handle this initial stop â€” it's not a syscall stop, it's the post-exec notification.\n```c\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <program> [args...]\\n\", argv[0]);\n        return 1;\n    }\n    pid_t child = fork();\n    if (child == 0) {\n        /* Child: request tracing, then become the target program */\n        ptrace(PTRACE_TRACEME, 0, NULL, NULL);\n        execvp(argv[1], &argv[1]);\n        /* If execvp returns, something went wrong */\n        perror(\"execvp\");\n        exit(1);\n    }\n    /* Parent: wait for the initial SIGTRAP from exec */\n    int status;\n    waitpid(child, &status, 0);\n    /* status now indicates the post-exec SIGTRAP stop */\n    /* ... tracing loop goes here ... */\n}\n```\nNotice the call sequence in the child: `PTRACE_TRACEME` first, then `execvp`. Order matters. If you reverse them, the new program won't be traced because the tracing flag wasn't set when `exec` ran.\n\n![ptrace Tracing Lifecycle: Fork â†’ TRACEME â†’ Exec â†’ SYSCALL Loop](./diagrams/diag-m1-ptrace-lifecycle.svg)\n\n### Step 2: The PTRACE_SYSCALL + waitpid Loop\nOnce you've caught the initial stop, the tracing loop begins. It follows a simple rhythm:\n1. Call `ptrace(PTRACE_SYSCALL, child, NULL, NULL)` â€” this tells the kernel \"resume the tracee, but stop it at the next syscall boundary.\"\n2. Call `waitpid(child, &status, 0)` â€” block until something happens to the tracee.\n3. Check `status` to figure out what happened.\n4. If it's a syscall stop: inspect registers, print output, go to step 1.\n5. If it's a signal stop: re-inject the signal, go to step 1.\n6. If the process exited: clean up and exit the tracer.\nThe `PTRACE_SYSCALL` request is key. It means \"stop at the next syscall entry OR exit.\" The kernel doesn't distinguish between them for you â€” you get one stop notification for each boundary. Your toggle flag tracks which boundary you're at.\n```c\n    /* Start the tracing loop */\n    int in_syscall = 0;  /* Toggle: 0 = not in syscall (entry), 1 = in syscall (exit) */\n    while (1) {\n        /* Resume tracee, stop at next syscall boundary */\n        ptrace(PTRACE_SYSCALL, child, NULL, NULL);\n        /* Wait for the next stop */\n        waitpid(child, &status, 0);\n        /* Check what happened */\n        if (WIFEXITED(status)) {\n            printf(\"Process exited with status %d\\n\", WEXITSTATUS(status));\n            break;\n        }\n        if (WIFSIGNALED(status)) {\n            printf(\"Process killed by signal %d\\n\", WTERMSIG(status));\n            break;\n        }\n        if (WIFSTOPPED(status)) {\n            /* Handle the stop */\n            /* ... */\n        }\n    }\n```\nLet's unpack those `waitpid` status macros â€” they're not optional knowledge, they're your primary tool for understanding what happened to the tracee.\n---\n## Understanding waitpid Status\n`waitpid()` returns a 32-bit integer called the *wait status*. This integer is not a simple exit code â€” it encodes several different kinds of events in a bit-packed format, and you decode it with a set of macros.\n{{DIAGRAM:diag-m1-waitpid-status-decode}}\nHere's what each macro checks and returns:\n**`WIFEXITED(status)`** â€” Returns true if the child terminated normally by calling `exit()` or returning from `main()`. When true, `WEXITSTATUS(status)` extracts the exit code (the argument passed to `exit()`).\n**`WIFSIGNALED(status)`** â€” Returns true if the child was killed by a signal (like `SIGKILL` or `SIGSEGV`). When true, `WTERMSIG(status)` extracts the signal number that killed it.\n**`WIFSTOPPED(status)`** â€” Returns true if the child was *stopped* (paused) rather than terminated. This is the case for both syscall stops and signal delivery stops in a ptrace-traced process. When true, `WSTOPSIG(status)` extracts the signal number that caused the stop. For syscall stops, this will be `SIGTRAP` (signal 5).\n**`WIFCONTINUED(status)`** â€” Returns true if a stopped child was resumed with `SIGCONT`. You won't need this for basic tracing.\nFor your tracer, the most important distinction is between:\n- `WIFEXITED` / `WIFSIGNALED` â†’ the tracee is gone, stop tracing\n- `WIFSTOPPED` â†’ the tracee is paused, inspect it and decide what to do\n---\n## x86_64 Syscall Register Conventions\nNow you need to know *what* to read when the tracee stops. Syscalls on x86_64 follow a strict register convention baked into the Linux ABI (Application Binary Interface â€” the contract between userspace and kernel that specifies exactly which registers carry which values).\nWhen a program executes the `syscall` instruction on x86_64:\n- **`rax`** â€” holds the syscall number before the call\n- **`rdi`** â€” holds argument 1\n- **`rsi`** â€” holds argument 2\n- **`rdx`** â€” holds argument 3\n- **`r10`** â€” holds argument 4 (note: this is `r10`, not `rcx` as in the normal calling convention â€” the `syscall` instruction uses `rcx` internally to save the return address)\n- **`r8`** â€” holds argument 5\n- **`r9`** â€” holds argument 6\nAfter the kernel completes the syscall, **`rax`** holds the return value.\nHere's the critical problem: the kernel may use `rax` for its own purposes during dispatch. If you read `rax` on entry, you'll get the syscall number â€” but the kernel might overwrite `rax` before giving you control on exit, destroying it. So the kernel saves the original `rax` value into a special field called `orig_rax` *before* doing anything else.\nThis means:\n- **On entry**: Read `orig_rax` for the syscall number. (Reading `rax` on entry gives the syscall number too, but `orig_rax` is the authoritative source.)\n- **On exit**: Read `rax` for the return value. Read `orig_rax` if you need the syscall number again.\nTo read these registers, you use `ptrace(PTRACE_GETREGS, pid, NULL, &regs)` where `regs` is a `struct user_regs_struct` defined in `<sys/user.h>`.\n\n![x86_64 Syscall Register Convention â€” struct user_regs_struct Layout](./diagrams/diag-m1-x86-registers.svg)\n\n```c\n#include <sys/user.h>  /* struct user_regs_struct */\nstruct user_regs_struct regs;\nptrace(PTRACE_GETREGS, child, NULL, &regs);\n/* On syscall entry: */\nlong syscall_number = regs.orig_rax;\n/* On syscall exit: */\nlong return_value = regs.rax;\n```\nThe `struct user_regs_struct` contains fields for all general-purpose registers. The ones you'll use most in this milestone:\n```c\nstruct user_regs_struct {\n    /* ... many fields ... */\n    unsigned long long orig_rax;  /* Saved rax (syscall number) */\n    unsigned long long rax;       /* Return value (on exit) */\n    unsigned long long rdi;       /* Argument 1 */\n    unsigned long long rsi;       /* Argument 2 */\n    unsigned long long rdx;       /* Argument 3 */\n    unsigned long long r10;       /* Argument 4 */\n    unsigned long long r8;        /* Argument 5 */\n    unsigned long long r9;        /* Argument 6 */\n    /* ... more fields ... */\n};\n```\n---\n## Three-Level View: What Happens During a Syscall\nUnderstanding the entry/exit stops requires seeing what happens at all three levels.\n\n![Three-Level View: Application â†’ Kernel â†’ Hardware for a Syscall](./diagrams/diag-m1-three-level-view.svg)\n\n**Level 1 â€” Application (Tracee)**\nThe program calls `write(1, \"hello\", 5)`. The compiler has already translated this into: load 1 into `rdi`, load the string pointer into `rsi`, load 5 into `rdx`, load 1 (the syscall number for `write`) into `rax`, execute the `syscall` instruction.\n**Level 2 â€” Kernel**\nWhen `syscall` executes:\n1. The CPU switches to ring 0 (kernel mode) and jumps to the syscall entry point (`entry_SYSCALL_64`).\n2. The kernel checks if this process is being traced (the `PT_TRACED` flag is set on the task).\n3. If traced: before doing anything else, save `rax` to `orig_rax`, then signal the tracer with SIGTRAP. The tracee is now paused. This is the **entry stop**.\n4. The tracer wakes up, inspects registers, then calls `PTRACE_SYSCALL` to resume.\n5. The kernel executes the actual syscall (calls `sys_write`).\n6. The return value is placed in `rax`.\n7. The kernel signals the tracer again with SIGTRAP. The tracee is paused again. This is the **exit stop**.\n8. The tracer wakes up, reads the return value from `rax`, then calls `PTRACE_SYSCALL` to resume.\n9. The `syscall` instruction completes in userspace. Execution continues.\n**Level 3 â€” Hardware**\nThe `syscall` instruction does specific things at the hardware level:\n- Saves the return address (next instruction's `RIP`) into `RCX`.\n- Saves `RFLAGS` into `R11`.\n- Loads the kernel's code segment (`CS`) and stack pointer.\n- Jumps to the address stored in `IA32_LSTAR` MSR (Model-Specific Register) â€” the kernel entry point.\nThis is why `rcx` and `r11` are clobbered by the `syscall` instruction: they're used by the hardware to save state. The kernel calling convention for syscalls explicitly uses `r10` instead of `rcx` for argument 4 to avoid this conflict.\nThe `orig_rax` field exists because of step 3 above â€” the kernel overwrites `rax` during its own internal dispatch, so it first saves the original value.\n---\n## The Toggle Flag in Practice\nNow you have everything to implement the full entry/exit logic:\n```c\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/user.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <program> [args...]\\n\", argv[0]);\n        return 1;\n    }\n    pid_t child = fork();\n    if (child == 0) {\n        /* Child: enable tracing and exec the target */\n        ptrace(PTRACE_TRACEME, 0, NULL, NULL);\n        execvp(argv[1], &argv[1]);\n        perror(\"execvp\");\n        exit(1);\n    }\n    /* Parent: catch the post-exec SIGTRAP */\n    int status;\n    waitpid(child, &status, 0);\n    if (!WIFSTOPPED(status)) {\n        fprintf(stderr, \"Unexpected initial status\\n\");\n        return 1;\n    }\n    /* The tracing loop */\n    int in_syscall = 0;  /* Toggle: 0 = next stop is entry, 1 = next stop is exit */\n    while (1) {\n        /* Resume tracee, asking kernel to stop at next syscall boundary */\n        if (ptrace(PTRACE_SYSCALL, child, NULL, NULL) == -1) {\n            perror(\"ptrace PTRACE_SYSCALL\");\n            break;\n        }\n        /* Block until the tracee stops again */\n        waitpid(child, &status, 0);\n        /* Tracee has exited â€” stop tracing */\n        if (WIFEXITED(status)) {\n            printf(\"+++ exited with %d +++\\n\", WEXITSTATUS(status));\n            break;\n        }\n        /* Tracee was killed by a signal â€” stop tracing */\n        if (WIFSIGNALED(status)) {\n            printf(\"+++ killed by signal %d +++\\n\", WTERMSIG(status));\n            break;\n        }\n        /* Tracee has stopped â€” inspect why */\n        if (WIFSTOPPED(status)) {\n            int sig = WSTOPSIG(status);\n            if (sig == SIGTRAP) {\n                /* This is a syscall stop (or the initial post-exec stop) */\n                struct user_regs_struct regs;\n                ptrace(PTRACE_GETREGS, child, NULL, &regs);\n                if (!in_syscall) {\n                    /* Entry: syscall is about to execute */\n                    /* Just record that we're entering; we'll print on exit */\n                    in_syscall = 1;\n                } else {\n                    /* Exit: syscall has completed */\n                    long syscall_num = (long)regs.orig_rax;\n                    long return_val  = (long)regs.rax;\n                    /* Detect error returns */\n                    if (return_val >= -4096 && return_val <= -1) {\n                        int err_num = (int)(-return_val);\n                        printf(\"syscall(%ld) = -1 %s\\n\",\n                               syscall_num, strerror(err_num));\n                    } else {\n                        printf(\"syscall(%ld) = %ld\\n\",\n                               syscall_num, return_val);\n                    }\n                    in_syscall = 0;\n                }\n            } else {\n                /* Signal-delivery stop: a real signal for the tracee */\n                /* Re-inject it â€” do NOT pass 0 or you'll swallow the signal */\n                ptrace(PTRACE_SYSCALL, child, NULL, (void *)(long)sig);\n                continue;  /* Skip the PTRACE_SYSCALL at top of loop */\n            }\n        }\n    }\n    return 0;\n}\n```\nRead through this carefully. Notice the subtle continuation in the signal-delivery case: when you handle a signal stop, you call `PTRACE_SYSCALL` with the signal number immediately in the handler and `continue` to skip the `PTRACE_SYSCALL` at the top of the loop â€” otherwise you'd call it twice and lose an event.\n---\n## Signal Stops vs Syscall Stops\nThe code above has a subtle problem. We're distinguishing signal-delivery stops from syscall stops by checking if the stop signal is `SIGTRAP`. But `SIGTRAP` *is* the signal for both types of stops. How do you actually tell them apart?\n\n![Signal-Delivery Stop vs Syscall Stop â€” Decision Tree](./diagrams/diag-m1-signal-vs-syscall-stop.svg)\n\nThere are two approaches:\n### Approach 1: PTRACE_O_TRACESYSGOOD (Recommended)\nIf you set the option `PTRACE_O_TRACESYSGOOD` on the tracee, the kernel will set bit 7 of the stop signal number for syscall stops. That is, instead of delivering `SIGTRAP` (signal 5) for syscall stops, it delivers `SIGTRAP | 0x80` = `0x85`. Signal-delivery stops still use plain `SIGTRAP` (5).\nYou set options with:\n```c\nptrace(PTRACE_SETOPTIONS, child, NULL, PTRACE_O_TRACESYSGOOD);\n```\nCall this right after the initial `waitpid` that catches the post-exec stop.\nThen your stop handling becomes:\n```c\nif (WIFSTOPPED(status)) {\n    int sig = WSTOPSIG(status);\n    if (sig == (SIGTRAP | 0x80)) {\n        /* Syscall stop â€” handle entry/exit toggle */\n        /* sig & 0x7F == SIGTRAP, bit 7 is the TRACESYSGOOD indicator */\n        /* ... */\n    } else if (sig == SIGTRAP) {\n        /* Plain SIGTRAP â€” could be post-exec stop, breakpoint, or other ptrace event */\n        /* For now, just resume */\n    } else {\n        /* Genuine signal delivery stop â€” re-inject the signal */\n        ptrace(PTRACE_SYSCALL, child, NULL, (void *)(long)sig);\n        continue;\n    }\n}\n```\n### Approach 2: Check orig_rax\nAnother approach: on every SIGTRAP stop, call `PTRACE_GETREGS` and check `orig_rax`. If `orig_rax` is a valid syscall number (0 through ~450 on Linux), it's likely a syscall stop. But this is fragile â€” `orig_rax` can contain valid-looking values in edge cases.\n**Use `PTRACE_O_TRACESYSGOOD`.** It's the correct approach, used by real strace. The bit-7 trick was invented precisely to solve this disambiguation problem.\nHere's the updated initialization:\n```c\n    /* Catch post-exec stop */\n    waitpid(child, &status, 0);\n    /* Set options: use TRACESYSGOOD to mark syscall stops */\n    ptrace(PTRACE_SETOPTIONS, child, NULL, PTRACE_O_TRACESYSGOOD);\n    /* Now enter the tracing loop */\n```\n---\n## Error Detection on x86_64\nWhen a syscall fails, the kernel doesn't return a positive number and set `errno`. Instead, it returns a negative number in the range `[-4096, -1]`. The C library wrapper (in glibc) detects this range, negates the value, stores it in `errno`, and returns `-1` to your program.\nFor example, if you call `open(\"nonexistent\", O_RDONLY)`, the kernel returns `-2` (which is `-ENOENT`). glibc sees `-2`, sets `errno = 2` (ENOENT), and returns `-1`.\nIn your tracer, you see the *raw kernel return value* â€” not the glibc-processed one. So you need to do the same detection:\n```c\n/* On x86_64, kernel error returns are in the range [-4096, -1] */\n/* This range covers all possible errno values (the largest is ~4095) */\nlong return_val = (long)regs.rax;\nif (return_val >= -4096L && return_val <= -1L) {\n    /* Error return */\n    int err_num = (int)(-return_val);  /* Negate to get the errno value */\n    printf(\"syscall(%ld) = -1 %s\\n\", syscall_num, strerror(err_num));\n} else {\n    /* Success return */\n    printf(\"syscall(%ld) = %ld\\n\", syscall_num, return_val);\n}\n```\nWhy the range `[-4096, -1]`? The Linux kernel reserves 4096 values for error codes. The actual defined errno values top out around 133 (`EHWPOISON`), but the kernel reserves the full 4096 range to be safe for future additions.\n\n![x86_64 Syscall Return Value Error Detection](./diagrams/diag-m1-error-detection.svg)\n\nThe cast `(long)regs.rax` matters. `regs.rax` is `unsigned long long`. If a syscall returns `-2`, the bit pattern in `rax` is `0xFFFFFFFFFFFFFFFE` â€” which as an unsigned 64-bit integer is a very large positive number. By casting to `long` (signed), you restore the correct negative interpretation. Always cast `rax` to `long` before comparing.\n---\n## Putting It Together: Complete Working Tracer\nHere is the complete, correct implementation for Milestone 1. Every concept from this chapter is present:\n```c\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/user.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <signal.h>\n#include <errno.h>\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <program> [args...]\\n\", argv[0]);\n        return 1;\n    }\n    pid_t child = fork();\n    if (child < 0) {\n        perror(\"fork\");\n        return 1;\n    }\n    if (child == 0) {\n        /*\n         * CHILD PROCESS\n         * 1. Tell the kernel we want to be traced.\n         * 2. exec the target program.\n         * After exec succeeds, the kernel delivers SIGTRAP and pauses us.\n         */\n        if (ptrace(PTRACE_TRACEME, 0, NULL, NULL) == -1) {\n            perror(\"ptrace TRACEME\");\n            exit(1);\n        }\n        execvp(argv[1], &argv[1]);\n        /* execvp only returns on error */\n        perror(\"execvp\");\n        exit(1);\n    }\n    /*\n     * PARENT (TRACER) PROCESS\n     */\n    int status;\n    /* Step 1: Catch the initial SIGTRAP delivered after exec */\n    if (waitpid(child, &status, 0) == -1) {\n        perror(\"waitpid (initial)\");\n        return 1;\n    }\n    if (!WIFSTOPPED(status)) {\n        fprintf(stderr, \"Unexpected: child did not stop after exec\\n\");\n        return 1;\n    }\n    /* Step 2: Set TRACESYSGOOD so syscall stops set bit 7 of the signal */\n    if (ptrace(PTRACE_SETOPTIONS, child, NULL,\n               (void *)(long)PTRACE_O_TRACESYSGOOD) == -1) {\n        perror(\"ptrace SETOPTIONS\");\n        return 1;\n    }\n    /*\n     * Step 3: The tracing loop.\n     *\n     * Toggle state:\n     *   in_syscall == 0: next syscall stop will be an ENTRY stop\n     *   in_syscall == 1: next syscall stop will be an EXIT stop\n     */\n    int in_syscall = 0;\n    for (;;) {\n        /* Resume tracee; stop at next syscall entry or exit */\n        if (ptrace(PTRACE_SYSCALL, child, NULL, NULL) == -1) {\n            /* Tracee may have exited between our waitpid and this call */\n            if (errno == ESRCH) break;\n            perror(\"ptrace PTRACE_SYSCALL\");\n            break;\n        }\n        /* Block until the tracee changes state */\n        pid_t stopped = waitpid(child, &status, 0);\n        if (stopped == -1) {\n            perror(\"waitpid\");\n            break;\n        }\n        /* The tracee exited normally */\n        if (WIFEXITED(status)) {\n            printf(\"+++ exited with %d +++\\n\", WEXITSTATUS(status));\n            break;\n        }\n        /* The tracee was killed by a signal */\n        if (WIFSIGNALED(status)) {\n            printf(\"+++ killed by signal %d (%s) +++\\n\",\n                   WTERMSIG(status), strsignal(WTERMSIG(status)));\n            break;\n        }\n        /* The tracee stopped */\n        if (WIFSTOPPED(status)) {\n            int sig = WSTOPSIG(status);\n            if (sig == (SIGTRAP | 0x80)) {\n                /*\n                 * SYSCALL STOP (entry or exit, distinguished by toggle)\n                 * Bit 7 is set because we used PTRACE_O_TRACESYSGOOD.\n                 */\n                struct user_regs_struct regs;\n                if (ptrace(PTRACE_GETREGS, child, NULL, &regs) == -1) {\n                    perror(\"ptrace GETREGS\");\n                    break;\n                }\n                if (in_syscall == 0) {\n                    /*\n                     * ENTRY STOP\n                     * The syscall is about to execute. orig_rax has the\n                     * syscall number. We note it and flip the toggle.\n                     * (We don't print yet â€” we print on exit when we have\n                     * both the syscall number AND the return value.)\n                     */\n                    in_syscall = 1;\n                    /* Syscall number: regs.orig_rax â€” saved for exit print */\n                } else {\n                    /*\n                     * EXIT STOP\n                     * The syscall has completed. rax has the return value.\n                     * orig_rax still has the syscall number.\n                     */\n                    long syscall_num = (long)regs.orig_rax;\n                    long return_val  = (long)regs.rax;\n                    if (return_val >= -4096L && return_val <= -1L) {\n                        int err_num = (int)(-return_val);\n                        printf(\"syscall(%ld) = -1 %s\\n\",\n                               syscall_num, strerror(err_num));\n                    } else {\n                        printf(\"syscall(%ld) = %ld\\n\",\n                               syscall_num, return_val);\n                    }\n                    in_syscall = 0;\n                }\n            } else if (sig == SIGTRAP) {\n                /*\n                 * Plain SIGTRAP without bit 7 â€” this is the post-exec stop\n                 * or some other ptrace event. Just resume with no signal.\n                 * (The toggle stays at 0; we haven't entered a syscall.)\n                 */\n            } else {\n                /*\n                 * SIGNAL-DELIVERY STOP\n                 * A real signal (SIGTERM, SIGPIPE, SIGHUP, etc.) was\n                 * delivered to the tracee. We must re-inject it by passing\n                 * the signal number as the 4th argument to PTRACE_SYSCALL.\n                 * Passing 0 would suppress the signal, which would break\n                 * the traced program's signal-handling logic.\n                 */\n                if (ptrace(PTRACE_SYSCALL, child, NULL,\n                           (void *)(long)sig) == -1) {\n                    if (errno == ESRCH) break;\n                    perror(\"ptrace PTRACE_SYSCALL (signal re-inject)\");\n                    break;\n                }\n                /* Note: we re-injected via PTRACE_SYSCALL above; skip the\n                 * PTRACE_SYSCALL call at the top of the loop. */\n                continue;\n            }\n        }\n    }\n    return 0;\n}\n```\n### Building and Testing\n```makefile\n# Makefile\nCC = gcc\nCFLAGS = -Wall -Wextra -g\nstrace_clone: strace_clone.c\n\t$(CC) $(CFLAGS) -o strace_clone strace_clone.c\nclean:\n\trm -f strace_clone\n```\nTest it:\n```bash\nmake\n./strace_clone /bin/ls /tmp\n```\nYou should see a stream of `syscall(N) = M` lines, followed by `+++ exited with 0 +++`. The syscall numbers will be x86_64 numbers â€” `59` is `execve`, `12` is `brk`, `9` is `mmap`. You'll decode these in Milestone 2.\n---\n## Common Bugs and How to Avoid Them\n### Bug 1: Reading rax on Entry\n```c\n/* WRONG: rax on entry is garbage (previous syscall's return value) */\nif (!in_syscall) {\n    long return_val = (long)regs.rax;  /* â† This is wrong! */\n    printf(\"syscall(%ld) = %ld\\n\", regs.orig_rax, return_val);\n    in_syscall = 1;\n}\n```\nThe fix is to not print the return value on entry. Print on exit when `rax` is valid.\n### Bug 2: Not Re-Injecting Signals\n```c\n/* WRONG: passing 0 suppresses the signal */\nptrace(PTRACE_SYSCALL, child, NULL, NULL);  /* suppresses the signal! */\n```\nIf a program receives `SIGPIPE` (write to a closed pipe) and you suppress it by passing 0, the program won't get the signal. It will continue writing to a closed pipe and produce corrupt behavior. Always re-inject real signals.\n### Bug 3: Forgetting the Toggle\nIf your toggle flag is wrong â€” say, you initialize it to 1 instead of 0, or you increment instead of toggling â€” you'll be one stop off on every syscall. Entry reads will look like exits and vice versa. The output will look plausible but be completely wrong. The numbers will be garbage. Initialize `in_syscall = 0` and toggle it cleanly.\n### Bug 4: Missing PTRACE_TRACEME Before exec\nIf the child calls `exec` before `PTRACE_TRACEME`, the new program is not traced. The parent's `waitpid` will block forever (or until the child exits). Always `PTRACE_TRACEME` first.\n---\n## Hardware Soul: What the CPU Does\n*When your tracer intercepts a syscall, what's happening in the hardware?*\n**Cache behavior**: The `syscall` instruction causes a CPU privilege level transition. The kernel entry code lives in a different cache region than userspace. This is an L1 instruction cache miss (cold path) on the first syscall of a program, then typically hot for subsequent calls. The `struct user_regs_struct` you read with `PTRACE_GETREGS` is a 216-byte structure â€” it fits in approximately 4 cache lines (64 bytes each). Each `PTRACE_GETREGS` call copies this structure across process boundaries, touching 4 cache lines.\n**TLB behavior**: The `waitpid` call that blocks your tracer is a full context switch. The CPU flushes TLB entries on context switch (or invalidates them on architectures with ASID support). When your tracer resumes to inspect registers, the kernel maps the tracee's register state into your address space â€” no TLB miss for the register copy, but your tracer's own TLB state must be reconstructed.\n**Branch prediction**: The `WIFSTOPPED`/`WIFEXITED`/`WIFSIGNALED` macros are simple bit operations. They're essentially free. The branch predictor will correctly predict \"almost always WIFSTOPPED\" after the first few iterations.\n**Syscall overhead**: Each `ptrace(PTRACE_SYSCALL, ...)` is itself a syscall. Each `waitpid` is a syscall. So intercepting *one* syscall in the tracee costs *two* syscalls in the tracer (plus the context switch overhead and cache effects). This is why ptrace-based tracing has significant overhead â€” strace can slow a program by 2-10x depending on syscall frequency.\n---\n## Knowledge Cascade: What This Unlocks\nYou've just implemented the core mechanism of one of Linux's most powerful diagnostic tools. That toggle flag and SIGTRAP stop aren't isolated ideas â€” they connect to a wide web of systems knowledge.\n### 1. GDB Uses the Same Mechanism (Just With PTRACE_SINGLESTEP)\nGDB's breakpoints work by inserting an `INT 3` instruction (opcode `0xCC`) at a target address, which generates a SIGTRAP when executed. But GDB also uses `PTRACE_SINGLESTEP` to step one instruction at a time â€” this is the same double-stop model. When GDB says \"hit breakpoint, stopped at line 42,\" it has just received a SIGTRAP via `waitpid`, read the register state, and displayed it to you. The mechanism you built today is the foundation of every debugger on Linux.\n**The connection to your toggle**: When you understand entry/exit stops, you understand why GDB can modify syscall arguments *in flight* â€” it wakes up at entry, modifies registers before resuming, and the kernel executes the modified syscall. Fault injection (breaking programs deliberately to test error handling) is built on exactly this mechanism.\n### 2. seccomp-BPF Filters Only at Entry\nseccomp (Secure Computing Mode) is a Linux kernel feature that lets you install a BPF (Berkeley Packet Filter) program to filter syscalls. Here's the critical connection: **seccomp filters run at syscall entry only, not exit**. They can allow or deny a call, but they cannot inspect the return value. Now you know *why* â€” the entry/exit model means the filter runs at the first SIGTRAP (entry stop), before the kernel has executed the syscall. Return values don't exist yet. seccomp can block `open()` but can't block `open()` that returns a file descriptor pointing to a sensitive file â€” it has to make that decision based on arguments alone.\nContainer runtimes like runc use seccomp profiles to restrict what syscalls containers can make. When you run `docker run --security-opt seccomp=profile.json`, that profile is compiled into a BPF program loaded via `prctl(PR_SET_SECCOMP, ...)`. The ptrace entry stop is where this filter executes.\n### 3. strace -e inject: Modifying Syscalls In Flight\nReal strace has a feature called `strace -e inject=open:retval=-1:error=ENOENT` that makes `open()` always fail with ENOENT. How does it work? On the entry stop, strace notes the syscall. On the exit stop, it modifies `rax` to `-2` (which is `-ENOENT`) using `PTRACE_SETREGS`. The program's glibc library sees `-2`, sets `errno = ENOENT`, and returns `-1` to the program. The actual `open()` ran and succeeded â€” strace lied about the result. This is fault injection: a technique for testing that programs handle errors correctly.\nYou now understand the two stops well enough to implement this yourself: read on entry, modify `rax` on exit.\n### 4. The x86_64 syscall ABI vs. the C Calling Convention\nYou've learned that syscalls use `rdi, rsi, rdx, r10, r8, r9` for arguments. The normal C function calling convention uses `rdi, rsi, rdx, rcx, r8, r9`. The difference is argument 4: `r10` for syscalls vs. `rcx` for function calls. This exists because the `syscall` instruction hardware-saves the return address in `RCX` â€” so `rcx` is clobbered by the mechanism itself. The ABI designers shifted argument 4 to `r10` to avoid the conflict. Now when you see `r10` in a Linux syscall table, you know exactly why.\n### 5. The Performance Cost of Observability\nEvery syscall interception costs approximately:\n- 2 context switches (tracer â†’ tracee â†’ tracer)\n- 2 additional syscalls by the tracer (PTRACE_SYSCALL + waitpid)\n- 4 cache line reads (PTRACE_GETREGS for the register struct)\n- ~5,000-10,000 CPU cycles of overhead per intercepted syscall\nThis is why you don't use ptrace in production â€” it's too slow. Production observability tools (like `perf`, `eBPF` probes, or `ftrace`) use kernel-side hooks that avoid the full context switch. They sample in the kernel and only surface data to userspace periodically. What you're building is the *right tool* for debugging and learning, not for production profiling. Knowing this cost precisely is what lets you make the right tool choice.\n---\n## Summary: What You've Built\nYour tracer now:\n- Forks a child, has it request tracing, and execs the target program\n- Catches the post-exec SIGTRAP and configures `PTRACE_O_TRACESYSGOOD`\n- Runs a `PTRACE_SYSCALL + waitpid` loop indefinitely\n- Toggles an `in_syscall` flag to distinguish entry from exit\n- On exit: reads `orig_rax` for the syscall number and `rax` for the return value\n- Detects error returns using the `[-4096, -1]` range and prints errno names\n- Re-injects real signals to the tracee rather than suppressing them\n- Detects `WIFEXITED` / `WIFSIGNALED` to stop the tracing loop cleanly\nThe output isn't human-readable yet â€” syscall numbers instead of names, raw integers instead of decoded arguments. Milestone 2 fixes that. But the machinery underneath â€” the toggle, the register reads, the signal handling â€” is complete and correct. Everything in the remaining milestones builds on exactly what you've built here.\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-strace-m2 -->\n<!-- MS_ID: build-strace-m2 -->\n# Milestone 2: Argument Decoding\n## Where You Are Now\nYour Milestone 1 tracer produces output like this:\n```\nsyscall(59) = 0\nsyscall(12) = 94412374278144\nsyscall(21) = -1 ENOENT\nsyscall(9) = 94412374278144\nsyscall(1) = 5\n```\nThis is *correct*. The toggle works. The error detection is right. The signal handling is right. But it's completely unreadable to a human being. Syscall 59 is `execve`. Syscall 12 is `brk`. Syscall 21 is `access`. Without names, you have numbers. Without arguments, you have calls in a vacuum.\nReal strace shows you this instead:\n```\nexecve(\"/bin/ls\", [\"/bin/ls\", \"/tmp\"], 0x7ffd3b2a8120 /* 23 vars */) = 0\nbrk(NULL) = 0x55f1a3c06000\naccess(\"/etc/ld.so.preload\", R_OK) = -1 ENOENT (No such file or directory)\nmmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f...\nwrite(1, \"file1.txt  file2.txt\\n\", 21)  = 21\n```\nThis milestone builds everything that transforms the first form into the second. You'll build a syscall name table, extract arguments from the six x86_64 argument registers, read string arguments word-by-word from the tracee's memory, decode bitmask flags into human-readable names, and format output in strace style.\nThere's one concept at the center of this milestone that is genuinely surprising the first time you encounter it. Let's start there.\n---\n## The Core Revelation: Address Spaces Are Not Shared\nHere's what feels obvious: the tracee passed a string pointer to the kernel as a syscall argument. You have that pointer. The pointer is just a number â€” a virtual address like `0x7ffd1234abcd`. Surely you can just dereference it?\n```c\n/* What you want to do: */\nstruct user_regs_struct regs;\nptrace(PTRACE_GETREGS, child, NULL, &regs);\nchar *path = (char *)regs.rdi;  /* rdi = first argument */\nprintf(\"open(\\\"%s\\\", ...)\\n\", path);  /* â† SEGFAULT or garbage */\n```\nThis feels completely reasonable. The pointer exists. It points to memory. Print the memory.\n**It crashes or prints garbage.** Here is why.\n\n![Virtual Address Space Isolation: Why PEEKDATA Exists](./diagrams/diag-m2-address-space-isolation.svg)\n\nEvery process on Linux has its own *virtual address space* â€” a private, independent mapping of virtual addresses to physical memory pages. The virtual address `0x7ffd1234abcd` in the tracee's address space maps to one set of physical pages. That same virtual address in *your tracer's* address space maps to something completely different â€” your tracer's own stack, or unmapped memory that will segfault if you dereference it, or (in rare cases where the addresses happen to coincide) a completely unrelated region.\nThe CPU's Memory Management Unit (MMU) enforces this separation at the hardware level. Every process has a pointer to its own page table stored in the `CR3` register. When a context switch happens, the kernel loads the new process's page table address into `CR3`. From that moment, all virtual addresses resolve through *that process's* page tables. Virtual address isolation isn't a software policy â€” it's physics. The hardware translates addresses differently depending on which `CR3` is loaded.\nThis is the foundation of process isolation. It's why one buggy process can't corrupt another's memory. It's also exactly why you can't just dereference a pointer from the tracee: your tracer's `CR3` is loaded, not the tracee's.\n> **The key insight**: A pointer is not data. A pointer is a *key* that only makes sense within the address space that owns it. To read what a tracee pointer *points to*, you need the kernel to do the translation on your behalf, using the tracee's page tables.\n`PTRACE_PEEKDATA` is exactly that: a kernel-mediated, cross-address-space read. You ask the kernel: \"In process `pid`'s address space, at virtual address `addr`, what are the 8 bytes?\" The kernel temporarily maps the tracee's page tables, reads the data, and returns it to you. One word at a time.\n---\n## PTRACE_PEEKDATA: The Word-by-Word Bridge\n`PTRACE_PEEKDATA` has this signature:\n```c\nlong ptrace(PTRACE_PEEKDATA, pid_t pid, void *addr, void *data);\n```\n- `pid` â€” the tracee's PID\n- `addr` â€” the virtual address in the tracee's address space to read from\n- `data` â€” ignored for PEEKDATA (the return value carries the data)\n- **Return value** â€” the 8 bytes at that address, returned as a `long`\nOn x86_64, one `PTRACE_PEEKDATA` call reads exactly **8 bytes** (one machine word). If you want to read a string, you must call it repeatedly, advancing the address by 8 each time, until you find a null byte.\n\n![PTRACE_PEEKDATA Word-by-Word String Extraction](./diagrams/diag-m2-peekdata-word-walk.svg)\n\n### The errno Ambiguity â€” A Critical Trap\nHere's the trap that breaks naive implementations:\n`PTRACE_PEEKDATA` returns its data via the return value. On error, it returns `-1`. But `-1` is `0xFFFFFFFFFFFFFFFF` as an 8-byte word â€” which is *valid data* that could legitimately appear in the tracee's memory. So how do you know if `-1` means \"error\" or means \"I read 8 bytes of 0xFF\"?\nYou can't tell from the return value alone. The POSIX solution: `errno`.\nWhen `PTRACE_PEEKDATA` succeeds, it does **not** modify `errno`. When it fails, it sets `errno` to indicate the error (e.g., `EIO` if the address is unmapped, `ESRCH` if the PID is gone). So the pattern is:\n```c\nerrno = 0;                                      /* Clear before the call */\nlong word = ptrace(PTRACE_PEEKDATA, pid, addr, NULL);\nif (word == -1 && errno != 0) {\n    /* Genuine error */\n    perror(\"PTRACE_PEEKDATA\");\n    return -1;\n}\n/* word is valid data â€” may be -1, that's fine */\n```\n\n![PEEKDATA's -1 Ambiguity: Error vs Valid Data](./diagrams/diag-m2-peekdata-errno-ambiguity.svg)\n\nThis is not optional. If you skip the `errno = 0` pre-clear, you may have stale `errno` from a previous call polluting your error check. Always zero `errno` before calling `PTRACE_PEEKDATA`.\n### Reading a String Word by Word\nWith this in mind, here's the algorithm for reading a null-terminated string from the tracee:\n1. Start at the pointer address.\n2. Read one 8-byte word with `PTRACE_PEEKDATA`.\n3. Scan the 8 bytes, one byte at a time, for a null byte (`'\\0'`).\n4. Append non-null bytes to your output buffer.\n5. If a null byte is found: done.\n6. If no null byte in this word: advance address by 8, go to step 2.\n7. Stop if you've read more than your max-length limit.\nThe byte ordering matters. On x86_64 (which is little-endian), the first byte of a word stored at address `A` is the least-significant byte of the `long` returned by `PTRACE_PEEKDATA`. That is, if the memory at address `A` contains the bytes `['h', 'e', 'l', 'l', 'o', '\\0', ?, ?]`, then `PTRACE_PEEKDATA` returns a `long` whose byte 0 (least-significant) is `'h'`, byte 1 is `'e'`, and so on.\n```c\n#define MAX_STRING_LEN 32\n/* Read a string from tracee memory at virtual address 'addr'.\n * Fills 'buf' (at most 'maxlen' bytes + NUL).\n * Returns 1 if truncated, 0 if complete, -1 on error. */\nint read_tracee_string(pid_t pid, unsigned long addr,\n                       char *buf, int maxlen, int *truncated)\n{\n    int i = 0;\n    *truncated = 0;\n    while (i < maxlen) {\n        errno = 0;\n        long word = ptrace(PTRACE_PEEKDATA, pid, (void *)addr, NULL);\n        if (word == -1 && errno != 0) {\n            if (i == 0) return -1;   /* Error on first read: nothing retrieved */\n            break;                    /* Error mid-string: return what we have */\n        }\n        /* Scan the 8 bytes of this word */\n        unsigned char *bytes = (unsigned char *)&word;\n        for (int b = 0; b < 8; b++) {\n            if (bytes[b] == '\\0') {\n                buf[i] = '\\0';\n                return 0;  /* Complete string found */\n            }\n            if (i < maxlen) {\n                buf[i++] = (char)bytes[b];\n            } else {\n                buf[i] = '\\0';\n                *truncated = 1;\n                return 0;  /* Truncated */\n            }\n        }\n        addr += 8;  /* Advance to next word */\n    }\n    buf[i] = '\\0';\n    *truncated = (i >= maxlen);\n    return 0;\n}\n```\nUse it like this:\n```c\nchar path[MAX_STRING_LEN + 1];\nint truncated;\nif (read_tracee_string(child, regs.rdi, path, MAX_STRING_LEN, &truncated) == 0) {\n    printf(\"\\\"%s%s\\\"\", path, truncated ? \"...\" : \"\");\n} else {\n    printf(\"\\\"<unreadable>\\\"\");\n}\n```\n### Null Pointer Check â€” Don't Peek at NULL\nBefore calling `PTRACE_PEEKDATA`, always check that the pointer is not NULL. Many syscalls accept NULL for optional arguments â€” for example, `execve(path, argv, NULL)` with a NULL environment pointer. Attempting `PTRACE_PEEKDATA` on address 0 will fail with `EIO` because address 0 is unmapped in every normal process. Print `NULL` (strace's convention) instead:\n```c\nif (regs.rdi == 0) {\n    printf(\"NULL\");\n} else {\n    /* read_tracee_string(...) */\n}\n```\n---\n## Building the Syscall Name Table\nTo print `open` instead of `2` (or `openat` instead of `257`), you need a lookup table mapping syscall numbers to their names. On x86_64 Linux, syscall numbers are dense integers starting from 0 â€” a perfect candidate for a simple array.\n\n![Syscall Table Structure: Number â†’ Name â†’ Argument Schema](./diagrams/diag-m2-syscall-table-design.svg)\n\n### Table Design\n```c\n/* syscall_table.h */\n#define MAX_SYSCALL_NUM 335  /* Highest syscall number on modern Linux x86_64 */\nextern const char *syscall_names[MAX_SYSCALL_NUM + 1];\nstatic inline const char *syscall_name(long num) {\n    if (num < 0 || num > MAX_SYSCALL_NUM) return \"unknown\";\n    const char *name = syscall_names[num];\n    return name ? name : \"unknown\";\n}\n```\n```c\n/* syscall_table.c â€” excerpt showing the structure */\nconst char *syscall_names[] = {\n    [0]   = \"read\",\n    [1]   = \"write\",\n    [2]   = \"open\",\n    [3]   = \"close\",\n    [4]   = \"stat\",\n    [5]   = \"fstat\",\n    [6]   = \"lstat\",\n    [7]   = \"poll\",\n    [8]   = \"lseek\",\n    [9]   = \"mmap\",\n    [10]  = \"mprotect\",\n    [11]  = \"munmap\",\n    [12]  = \"brk\",\n    [13]  = \"rt_sigaction\",\n    [14]  = \"rt_sigprocmask\",\n    [15]  = \"rt_sigreturn\",\n    [16]  = \"ioctl\",\n    [17]  = \"pread64\",\n    [18]  = \"pwrite64\",\n    [19]  = \"readv\",\n    [20]  = \"writev\",\n    [21]  = \"access\",\n    [22]  = \"pipe\",\n    [23]  = \"select\",\n    [24]  = \"sched_yield\",\n    [25]  = \"mremap\",\n    [26]  = \"msync\",\n    [27]  = \"mincore\",\n    [28]  = \"madvise\",\n    [29]  = \"shmget\",\n    [30]  = \"shmat\",\n    [31]  = \"shmctl\",\n    [32]  = \"dup\",\n    [33]  = \"dup2\",\n    [34]  = \"pause\",\n    [35]  = \"nanosleep\",\n    [36]  = \"getitimer\",\n    [37]  = \"alarm\",\n    [38]  = \"setitimer\",\n    [39]  = \"getpid\",\n    [40]  = \"sendfile\",\n    [41]  = \"socket\",\n    [42]  = \"connect\",\n    [43]  = \"accept\",\n    [44]  = \"sendto\",\n    [45]  = \"recvfrom\",\n    [46]  = \"sendmsg\",\n    [47]  = \"recvmsg\",\n    [48]  = \"shutdown\",\n    [49]  = \"bind\",\n    [50]  = \"listen\",\n    [51]  = \"getsockname\",\n    [52]  = \"getpeername\",\n    [53]  = \"socketpair\",\n    [54]  = \"setsockopt\",\n    [55]  = \"getsockopt\",\n    [56]  = \"clone\",\n    [57]  = \"fork\",\n    [58]  = \"vfork\",\n    [59]  = \"execve\",\n    [60]  = \"exit\",\n    [61]  = \"wait4\",\n    [62]  = \"kill\",\n    [63]  = \"uname\",\n    [72]  = \"fcntl\",\n    [74]  = \"fsync\",\n    [78]  = \"getdents\",\n    [79]  = \"getcwd\",\n    [80]  = \"chdir\",\n    [82]  = \"rename\",\n    [83]  = \"mkdir\",\n    [84]  = \"rmdir\",\n    [85]  = \"creat\",\n    [86]  = \"link\",\n    [87]  = \"unlink\",\n    [88]  = \"symlink\",\n    [89]  = \"readlink\",\n    [90]  = \"chmod\",\n    [91]  = \"fchmod\",\n    [99]  = \"sysinfo\",\n    [102] = \"getuid\",\n    [104] = \"getgid\",\n    [107] = \"geteuid\",\n    [108] = \"getegid\",\n    [110] = \"getppid\",\n    [111] = \"getpgrp\",\n    [112] = \"setsid\",\n    [158] = \"arch_prctl\",\n    [186] = \"gettid\",\n    [202] = \"futex\",\n    [218] = \"set_tid_address\",\n    [228] = \"clock_gettime\",\n    [231] = \"exit_group\",\n    [257] = \"openat\",\n    [262] = \"newfstatat\",\n    [269] = \"faccessat\",\n    [281] = \"epoll_pwait\",\n    [302] = \"prlimit64\",\n    /* Sparse entries return NULL â†’ syscall_name() returns \"unknown\" */\n};\n```\nThe C99 designated initializer syntax (`[n] = \"name\"`) lets you define a sparse array cleanly. Entries you don't define are initialized to NULL by default, and your `syscall_name()` function handles that with the `\"unknown\"` fallback.\n> ðŸ”­ **Deep Dive**: The authoritative x86_64 syscall table lives in the Linux kernel source at `arch/x86/entry/syscalls/syscall_64.tbl`. It's generated during kernel build into header files. For the definitive current list, see [Ryan Chapman's syscall table](https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/) or the kernel source directly.\n---\n## Extracting Arguments from Registers\nWith Milestone 1, you already know how to get a `struct user_regs_struct`. Now you need to map the six argument registers to the six argument positions of each syscall.\n\n![Syscall Argument Register Mapping with Examples](./diagrams/diag-m2-argument-register-mapping.svg)\n\nThe x86_64 Linux syscall ABI assigns arguments in this fixed order:\n| Argument # | Register | `user_regs_struct` field |\n|-----------|----------|--------------------------|\n| 1         | `rdi`    | `regs.rdi`               |\n| 2         | `rsi`    | `regs.rsi`               |\n| 3         | `rdx`    | `regs.rdx`               |\n| 4         | `r10`    | `regs.r10`               |\n| 5         | `r8`     | `regs.r8`                |\n| 6         | `r9`     | `regs.r9`                |\nIt helps to put these into an array at the start of your argument-decoding code, so you can index them generically:\n```c\nunsigned long long args[6] = {\n    regs.rdi,\n    regs.rsi,\n    regs.rdx,\n    regs.r10,\n    regs.r8,\n    regs.r9\n};\n```\nNow `args[0]` is always argument 1, `args[1]` is always argument 2, and so on. You can build a dispatch table keyed on syscall number that says \"for syscall N, argument 0 is a string, argument 1 is an integer flags field, argument 2 is a mode.\"\n---\n## The Argument Schema: Knowing What Type Each Argument Is\nDifferent syscalls have different argument types. `open(path, flags, mode)` has a string, flags bitmask, and integer. `read(fd, buf, count)` has an integer, a pointer (usually printed as a hex address), and an integer. You need a way to describe each syscall's argument signature so your decoder can format each argument correctly.\nDefine an argument type enum and a syscall descriptor struct:\n```c\n/* arg_type.h */\ntypedef enum {\n    ARG_INT,      /* Print as signed decimal integer */\n    ARG_UINT,     /* Print as unsigned decimal integer */\n    ARG_HEX,      /* Print as hexadecimal (addresses, pointers) */\n    ARG_STR,      /* Read from tracee memory as a null-terminated string */\n    ARG_PTR,      /* Pointer: print as hex if non-NULL, else \"NULL\" */\n    ARG_OPEN_FLAGS,  /* Bitmask: O_RDONLY | O_CREAT | ... */\n    ARG_MMAP_PROT,   /* Bitmask: PROT_READ | PROT_WRITE | ... */\n    ARG_MMAP_FLAGS,  /* Bitmask: MAP_SHARED | MAP_PRIVATE | MAP_ANONYMOUS | ... */\n    ARG_IGNORE,   /* Don't print (e.g., padding args, high args for simple calls) */\n} ArgType;\ntypedef struct {\n    int         num_args;     /* How many arguments to display */\n    ArgType     arg_types[6]; /* Type for each argument position */\n} SyscallDesc;\n```\nThen build a table mapping syscall numbers to their descriptors:\n```c\n/* syscall_desc.c â€” partial */\nstatic const SyscallDesc desc_table[] = {\n    [0]  = { 3, { ARG_INT, ARG_PTR,  ARG_UINT } },         /* read(fd, buf, count) */\n    [1]  = { 3, { ARG_INT, ARG_STR,  ARG_UINT } },         /* write(fd, buf, count) */\n    [2]  = { 3, { ARG_STR, ARG_OPEN_FLAGS, ARG_UINT } },   /* open(path, flags, mode) */\n    [3]  = { 1, { ARG_INT } },                              /* close(fd) */\n    [4]  = { 2, { ARG_STR, ARG_PTR  } },                   /* stat(path, statbuf) */\n    [5]  = { 2, { ARG_INT, ARG_PTR  } },                   /* fstat(fd, statbuf) */\n    [9]  = { 6, { ARG_PTR, ARG_UINT, ARG_MMAP_PROT,\n                  ARG_MMAP_FLAGS, ARG_INT, ARG_UINT } },    /* mmap(...) */\n    [11] = { 2, { ARG_PTR, ARG_UINT } },                   /* munmap(addr, len) */\n    [21] = { 2, { ARG_STR, ARG_INT  } },                   /* access(path, mode) */\n    [39] = { 0, { 0 } },                                    /* getpid() */\n    [57] = { 0, { 0 } },                                    /* fork() */\n    [59] = { 3, { ARG_STR, ARG_PTR, ARG_PTR } },           /* execve(path, argv, envp) */\n    [60] = { 1, { ARG_INT } },                              /* exit(code) */\n    [257]= { 4, { ARG_INT, ARG_STR, ARG_OPEN_FLAGS,\n                  ARG_UINT } },                             /* openat(dfd, path, flags, mode) */\n    /* ... more entries ... */\n};\n#define DESC_TABLE_SIZE (sizeof(desc_table) / sizeof(desc_table[0]))\nconst SyscallDesc *get_syscall_desc(long num) {\n    if (num < 0 || (size_t)num >= DESC_TABLE_SIZE) return NULL;\n    /* Zero-initialized entries have num_args = 0 â€” that's fine, prints no args */\n    return &desc_table[num];\n}\n```\n> **Note on write(fd, buf, count)**: For `write`, argument 1 (`buf`) is technically a string in memory, but we mark it as `ARG_STR` rather than `ARG_PTR`. This lets us peek at the buffer and print its content (up to the truncation limit), which is exactly what strace does. It's intentional â€” showing what was written is the useful thing.\n---\n## Bitmask Flag Decoding\nWhen you call `open(\"/etc/passwd\", O_RDONLY | O_CLOEXEC, 0)`, the flags argument is `0x80000` (O_CLOEXEC = 0x80000, O_RDONLY = 0). Printing `0x80000` is correct but useless to a reader. Printing `O_CLOEXEC` is immediately meaningful.\n\n![Bitmask Flag Decoding: open() Flags Example](./diagrams/diag-m2-flag-bitmask-decode.svg)\n\nThe approach: define a table of `(bit_value, name)` pairs for each flag set, then iterate through the table building a string of names joined by `|`.\n```c\ntypedef struct {\n    unsigned long value;\n    const char   *name;\n} FlagEntry;\n/* open() flags â€” from <fcntl.h>, matched to actual numeric values */\nstatic const FlagEntry open_flags[] = {\n    /* Access mode â€” these are special: only bits 0-1 */\n    { O_RDONLY,   \"O_RDONLY\"   },\n    { O_WRONLY,   \"O_WRONLY\"   },\n    { O_RDWR,     \"O_RDWR\"    },\n    /* Single-bit flags */\n    { O_CREAT,    \"O_CREAT\"   },\n    { O_EXCL,     \"O_EXCL\"    },\n    { O_NOCTTY,   \"O_NOCTTY\"  },\n    { O_TRUNC,    \"O_TRUNC\"   },\n    { O_APPEND,   \"O_APPEND\"  },\n    { O_NONBLOCK, \"O_NONBLOCK\"},\n    { O_DSYNC,    \"O_DSYNC\"   },\n    { O_SYNC,     \"O_SYNC\"    },\n    { O_CLOEXEC,  \"O_CLOEXEC\" },\n    { O_TMPFILE,  \"O_TMPFILE\" },\n    { O_DIRECTORY,\"O_DIRECTORY\"},\n    { O_NOFOLLOW, \"O_NOFOLLOW\"},\n    { O_PATH,     \"O_PATH\"    },\n    { 0, NULL }   /* sentinel */\n};\n/* mmap() prot flags â€” from <sys/mman.h> */\nstatic const FlagEntry mmap_prot_flags[] = {\n    { PROT_NONE,  \"PROT_NONE\"  },\n    { PROT_READ,  \"PROT_READ\"  },\n    { PROT_WRITE, \"PROT_WRITE\" },\n    { PROT_EXEC,  \"PROT_EXEC\"  },\n    { 0, NULL }\n};\n/* mmap() map flags */\nstatic const FlagEntry mmap_map_flags[] = {\n    { MAP_SHARED,     \"MAP_SHARED\"     },\n    { MAP_PRIVATE,    \"MAP_PRIVATE\"    },\n    { MAP_FIXED,      \"MAP_FIXED\"      },\n    { MAP_ANONYMOUS,  \"MAP_ANONYMOUS\"  },\n    { MAP_GROWSDOWN,  \"MAP_GROWSDOWN\"  },\n    { MAP_DENYWRITE,  \"MAP_DENYWRITE\"  },\n    { MAP_EXECUTABLE, \"MAP_EXECUTABLE\" },\n    { MAP_LOCKED,     \"MAP_LOCKED\"     },\n    { MAP_NORESERVE,  \"MAP_NORESERVE\"  },\n    { MAP_POPULATE,   \"MAP_POPULATE\"   },\n    { MAP_HUGETLB,    \"MAP_HUGETLB\"    },\n    { 0, NULL }\n};\n```\nThe decoding function:\n```c\n/* Decode a bitmask flags value into a \"|\"-separated string.\n * Special case: O_RDONLY = 0, which needs explicit handling.\n * Returns number of bytes written to buf. */\nint decode_flags(unsigned long value, const FlagEntry *table,\n                 char *buf, int bufsize)\n{\n    int written = 0;\n    int first = 1;\n    /* Special case: if value is 0 and the first entry is 0, print its name */\n    if (value == 0 && table[0].value == 0 && table[0].name != NULL) {\n        return snprintf(buf, bufsize, \"%s\", table[0].name);\n    }\n    for (int i = 0; table[i].name != NULL; i++) {\n        if (table[i].value == 0) continue;  /* Skip the zero-value entry in loop */\n        if ((value & table[i].value) == table[i].value) {\n            int n = snprintf(buf + written, bufsize - written,\n                             \"%s%s\",\n                             first ? \"\" : \"|\",\n                             table[i].name);\n            written += n;\n            first = 0;\n            value &= ~table[i].value;  /* Clear matched bits */\n        }\n    }\n    /* If there are remaining unrecognized bits, print them as hex */\n    if (value != 0) {\n        int n = snprintf(buf + written, bufsize - written,\n                         \"%s0x%lx\", first ? \"\" : \"|\", value);\n        written += n;\n    }\n    /* If nothing matched at all, print the raw value */\n    if (first) {\n        written = snprintf(buf, bufsize, \"0x%lx\", value);\n    }\n    return written;\n}\n```\nThe O_RDONLY edge case is important. `O_RDONLY` is defined as `0` in the Linux headers. A bitwise `AND` with zero always produces zero â€” so you can't detect `O_RDONLY` by masking. The special case handles this: if the entire value is 0 and the first table entry covers 0, print it directly.\nSimilarly, `PROT_NONE` is 0 for mmap. The same logic applies.\n---\n## Three-Level View: What Happens When You Print an Argument\nLet's trace through all three levels for the specific case of `open(\"/etc/passwd\", O_RDONLY)` being printed by your tracer.\n**Level 1 â€” Application (Tracee)**\nThe tracee's code (inside glibc or your test program) calls:\n```c\nint fd = open(\"/etc/passwd\", O_RDONLY);\n```\nglibc's wrapper places `/etc/passwd`'s address in `rdi`, `O_RDONLY` (which is 0) in `rsi`, and syscall number 2 in `rax`, then executes the `syscall` instruction. The string `\"/etc/passwd\"` lives somewhere in the tracee's memory â€” perhaps on its stack at address `0x7ffd3a2c1000`.\n**Level 2 â€” Your Tracer (Kernel-mediated)**\nYour tracer wakes up on the entry stop, reads `orig_rax = 2` (open), reads `rdi = 0x7ffd3a2c1000`. It looks up syscall 2 in the descriptor table: first argument is `ARG_STR`. So it calls `PTRACE_PEEKDATA(child, 0x7ffd3a2c1000)`.\nThe kernel handles this PEEKDATA request:\n1. Finds the tracee's page table (its `mm_struct`).\n2. Walks the page table to find which physical page backs `0x7ffd3a2c1000`.\n3. Maps that physical page into kernel address space temporarily.\n4. Copies 8 bytes from that page to the return value.\n5. Returns to your tracer.\nYour tracer receives, say, `0x7361702f6374652f` â€” which as bytes (little-endian) is `/`, `e`, `t`, `c`, `/`, `p`, `a`, `s`. No null terminator yet. Advance address by 8 to `0x7ffd3a2c1008`. Call `PTRACE_PEEKDATA` again. Receive `0x0064777773`, which bytes are `s`, `w`, `d`, `\\0`. Null terminator found. The string is `/etc/passwd`.\n**Level 3 â€” Hardware**\nWhen the `ptrace(PTRACE_PEEKDATA, ...)` syscall executes:\n- The CPU is running your tracer's code. The MMU is using your tracer's page table (`CR3` points to your tracer's `mm_struct`).\n- The kernel syscall handler switches context: it uses the tracee's `mm_struct` to do the virtualâ†’physical translation for `0x7ffd3a2c1000`.\n- This translation involves a 4-level page table walk on x86_64 (PGD â†’ P4D â†’ PUD â†’ PMD â†’ PTE). If the tracee's TLB has the address cached, the walk is short. If not, it's a full 4-level walk.\n- The physical page is accessed via the kernel's direct mapping of physical memory (the kernel maps all physical memory starting at a fixed virtual address). No TLB miss for the kernel's own access.\n- The 8 bytes are copied into the `long` return value.\n- The context switches back to your tracer.\nThe cost per `PTRACE_PEEKDATA` call: roughly 1,000-3,000 CPU cycles (one full context switch into the kernel, a page table walk, and a context switch back). For a 32-byte string, you need 4 calls: **4,000â€“12,000 CPU cycles just to read a path argument**. This is why strace is slow. A program that makes 10,000 `open()` calls would have your tracer spend ~100M cycles just reading the path arguments.\n---\n## Formatting Output in strace Style\nNow you have all the pieces. The output format strace uses is:\n```\nsyscall_name(arg1, arg2, ...) = return_value\n```\nFor errors:\n```\nsyscall_name(arg1, arg2, ...) = -1 ERRNO (error message)\n```\nLet's build the `print_syscall` function that assembles this output. It's called on the **exit stop**, when you have both the entry registers (saved from the entry stop) and the return value in `rax`.\n> **Important**: To print arguments, you need the register state from **entry**, not exit. Argument registers (`rdi`, `rsi`, etc.) may have been modified by the kernel during the syscall. But the crucial field `orig_rax` persists. For arguments, you need to save the entry registers. Add a `struct user_regs_struct entry_regs` to your per-process state and populate it on entry.\n\n![Complete Trace of open() â€” From Registers to Formatted Output](./diagrams/diag-m2-full-trace-example.svg)\n\n```c\n/* print one argument of a given type */\nstatic void print_arg(pid_t pid, unsigned long long value, ArgType type)\n{\n    char buf[MAX_STRING_LEN + 4];  /* +4 for \"...\" + NUL */\n    char flags_buf[256];\n    int truncated;\n    switch (type) {\n    case ARG_INT:\n        printf(\"%lld\", (long long)value);\n        break;\n    case ARG_UINT:\n        printf(\"%llu\", (unsigned long long)value);\n        break;\n    case ARG_HEX:\n        printf(\"0x%llx\", (unsigned long long)value);\n        break;\n    case ARG_STR:\n        if (value == 0) {\n            printf(\"NULL\");\n        } else {\n            if (read_tracee_string(pid, (unsigned long)value,\n                                   buf, MAX_STRING_LEN, &truncated) == 0) {\n                printf(\"\\\"%s%s\\\"\", buf, truncated ? \"...\" : \"\");\n            } else {\n                printf(\"\\\"<unreadable>\\\"\");\n            }\n        }\n        break;\n    case ARG_PTR:\n        if (value == 0) printf(\"NULL\");\n        else            printf(\"0x%llx\", (unsigned long long)value);\n        break;\n    case ARG_OPEN_FLAGS:\n        decode_flags((unsigned long)value, open_flags, flags_buf, sizeof(flags_buf));\n        printf(\"%s\", flags_buf);\n        break;\n    case ARG_MMAP_PROT:\n        decode_flags((unsigned long)value, mmap_prot_flags, flags_buf, sizeof(flags_buf));\n        printf(\"%s\", flags_buf);\n        break;\n    case ARG_MMAP_FLAGS:\n        decode_flags((unsigned long)value, mmap_map_flags, flags_buf, sizeof(flags_buf));\n        printf(\"%s\", flags_buf);\n        break;\n    case ARG_IGNORE:\n        break;\n    }\n}\nvoid print_syscall(pid_t pid,\n                   struct user_regs_struct *entry_regs,\n                   long return_val)\n{\n    long syscall_num = (long)entry_regs->orig_rax;\n    const char *name = syscall_name(syscall_num);\n    const SyscallDesc *desc = get_syscall_desc(syscall_num);\n    unsigned long long args[6] = {\n        entry_regs->rdi, entry_regs->rsi, entry_regs->rdx,\n        entry_regs->r10, entry_regs->r8,  entry_regs->r9\n    };\n    printf(\"%s(\", name);\n    if (desc != NULL && desc->num_args > 0) {\n        for (int i = 0; i < desc->num_args; i++) {\n            if (i > 0) printf(\", \");\n            print_arg(pid, args[i], desc->arg_types[i]);\n        }\n    }\n    printf(\") = \");\n    /* Print return value */\n    if (return_val >= -4096L && return_val <= -1L) {\n        int err_num = (int)(-return_val);\n        printf(\"-1 %s (%s)\\n\", strerrorname_np(err_num), strerror(err_num));\n        /* Note: strerrorname_np is glibc >= 2.32; fallback below */\n    } else {\n        printf(\"%ld\\n\", return_val);\n    }\n}\n```\n> **Portable errno name**: `strerrorname_np` (non-portable glibc extension since 2.32) returns just the name like `\"ENOENT\"`. If your system doesn't have it, build a small table mapping errno values to their symbolic names:\n>\n> ```c\n> static const char *errno_names[] = {\n>     [EPERM]   = \"EPERM\",\n>     [ENOENT]  = \"ENOENT\",\n>     [ESRCH]   = \"ESRCH\",\n>     [EINTR]   = \"EINTR\",\n>     [EIO]     = \"EIO\",\n>     [ENXIO]   = \"ENXIO\",\n>     [E2BIG]   = \"E2BIG\",\n>     /* ... */\n>     [EBADF]   = \"EBADF\",\n>     [ECHILD]  = \"ECHILD\",\n>     [EAGAIN]  = \"EAGAIN\",\n>     [ENOMEM]  = \"ENOMEM\",\n>     [EACCES]  = \"EACCES\",\n>     [EFAULT]  = \"EFAULT\",\n>     /* ... */\n> };\n> ```\n---\n## Integrating with the Milestone 1 Loop\nIn Milestone 1, you had a single toggle flag and a `struct user_regs_struct` read on exit. Now you need to save the entry registers. Modify the state:\n```c\n/* Per-process state â€” will grow significantly in Milestone 3 */\ntypedef struct {\n    int                    in_syscall;   /* Toggle: 0=entry, 1=exit */\n    struct user_regs_struct entry_regs;  /* Registers saved at entry stop */\n} ProcessState;\n```\nAnd update the tracing loop:\n```c\nProcessState state = { .in_syscall = 0 };\n/* Inside the WIFSTOPPED / (sig == (SIGTRAP | 0x80)) branch: */\nstruct user_regs_struct regs;\nif (ptrace(PTRACE_GETREGS, child, NULL, &regs) == -1) {\n    perror(\"ptrace GETREGS\");\n    break;\n}\nif (state.in_syscall == 0) {\n    /* ENTRY: save registers, flip toggle */\n    state.entry_regs = regs;\n    state.in_syscall = 1;\n} else {\n    /* EXIT: print with saved entry registers + current return value */\n    long return_val = (long)regs.rax;\n    print_syscall(child, &state.entry_regs, return_val);\n    state.in_syscall = 0;\n}\n```\nThat's it. The entry state saves the register snapshot. The exit state uses both the saved entry registers (for arguments and syscall number) and the current `rax` (for the return value).\n---\n## What Real Traces Look Like\nAfter this milestone, running `./strace_clone /bin/ls /tmp` produces something like:\n```\nexecve(\"/bin/ls\", [\"/bin/ls\", \"/tmp\"], 0x7ffd3b2c1200) = 0\nbrk(NULL) = 0x562a1a3c0000\narch_prctl(0x3001, 0x7ffd13e26250) = -1 EINVAL (Invalid argument)\naccess(\"/etc/ld.so.preload\", R_OK) = -1 ENOENT (No such file or directory)\nopenat(AT_FDCWD, \"/etc/ld.so.cache\", O_RDONLY|O_CLOEXEC) = 3\nfstat(3, 0x7ffd13e265d0) = 0\nmmap(NULL, 25673, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f12ab312000\nclose(3) = 0\nopenat(AT_FDCWD, \"/lib/x86_64-linux-gnu/libc.so.6\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>...\", 832) = 832\n...\nwrite(1, \"file1.txt  file2.txt\\n\", 21)  = 21\n+++ exited with 0 +++\n```\nThis matches real strace output. Notice `O_RDONLY|O_CLOEXEC` for the flags, `PROT_READ` for mmap, hex address for the statbuf pointer, and the ELF magic bytes peeked out of the read buffer.\n---\n## Common Bugs in This Milestone\n### Bug 1: Using exit registers for argument printing\n```c\n/* WRONG: reading argument registers on exit */\nif (state.in_syscall == 1) {\n    /* regs is from GETREGS on EXIT STOP */\n    printf(\"arg1 = %llu\\n\", regs.rdi);  /* rdi may have been modified! */\n}\n```\nSome syscalls modify their argument registers as part of execution (rare, but it happens with some kernel internals). More importantly, you may have an architecture guarantee that arguments are preserved, but it's safer and more correct to save them at entry. Always save entry registers.\n### Bug 2: Forgetting `errno = 0` before PEEKDATA\n```c\n/* WRONG: no errno pre-clear */\nlong word = ptrace(PTRACE_PEEKDATA, pid, addr, NULL);\nif (word == -1 && errno != 0) {\n    /* Bug: errno might be non-zero from a previous failed call,\n     * making valid data look like an error */\n}\n```\nEven if your PEEKDATA succeeds, a stale non-zero `errno` from an earlier operation (like a failed `printf` call, or a prior PEEKDATA that genuinely failed) will make `word == -1` look like an error when it's actually valid data. Always `errno = 0` first.\n### Bug 3: Infinite loop on non-null-terminated strings\nIf you trace a program writing to a pipe or socket, the `buf` argument to `write()` may not be null-terminated â€” it's a binary buffer, not a C string. Your string reader *must* stop at `maxlen` bytes regardless of whether it found `'\\0'`. The loop bound is essential:\n```c\nwhile (i < maxlen) {   /* â† This bound is load-bearing. Never remove it. */\n    /* PEEKDATA + scan ... */\n}\n```\n### Bug 4: Wrong byte order when scanning a PEEKDATA word\nOn x86_64 (little-endian), the first byte of a word at address `A` is the *least significant byte* of the returned `long`. This means:\n```c\nunsigned char *bytes = (unsigned char *)&word;\n/* bytes[0] is the byte at address A     (LSB of the long) */\n/* bytes[1] is the byte at address A+1   */\n/* bytes[7] is the byte at address A+7   (MSB of the long) */\n```\nIf you extract bytes as `(word >> 0) & 0xFF`, `(word >> 8) & 0xFF`, etc., you get the same result. Either approach works as long as you start from the least significant end. Getting this wrong means reading strings in the wrong byte order â€” the test is simple: if `/etc/ld.so.cache` reads as `cte/ld.so.cache/` you have an endianness bug.\n### Bug 5: Decoding flags when O_RDONLY (0) is not explicitly flagged\nIf you open a file with `O_RDONLY`, the flags argument is 0. Iterating through your flags table with `value & flag == flag` will never match any entry (since `0 & anything = 0`). Result: decode_flags returns an empty string or prints nothing. Handle the `value == 0` case explicitly by printing the name of the first table entry (which should be `O_RDONLY`/`PROT_NONE`).\n---\n## Hardware Soul: The Memory Cost of Argument Decoding\nWhen your tracer reads a string argument, what's happening at the hardware level?\n**Cache lines**: The tracee's string data lives in the tracee's cache. When the tracer calls `PTRACE_PEEKDATA`, the kernel reads the physical page. If the tracee recently accessed this string (it just put it in `rdi` before `syscall`), the data is likely in L1 or L2 cache. The kernel can satisfy the PEEKDATA from the CPU cache â€” no DRAM access needed. This is one reason PEEKDATA is \"only\" ~1,000-3,000 cycles rather than 10,000+ cycles.\n**TLB**: The tracee's page table mapping for the string address is likely still in the TLB (the tracee just accessed it). But your tracer is running with a different `CR3` â€” its TLB entries don't include the tracee's virtual addresses. The kernel uses its own TLB tags (or temporarily switches page tables) to perform the access. Modern x86_64 CPUs use PCID (Process Context IDs) to avoid full TLB flushes on context switches, but cross-process memory access still has TLB overhead.\n**Context switch cost**: Every `ptrace()` call is a userspaceâ†’kernelâ†’userspace round trip. That's a minimum of ~200â€“500 cycles just for the mode switch, plus the actual work. For a 64-byte path name (8 PEEKDATA calls): 8 Ã— 1,500 cycles â‰ˆ 12,000 cycles. At 3 GHz, that's 4 microseconds *just to read one filename*. A program that opens 10,000 files takes 40ms of pure tracing overhead reading filenames â€” before any other tracing work.\n**This is why strace is slow**. It's not the toggle logic or the flag decoding. It's the PEEKDATA loop. The real strace codebase addresses this with multiple optimizations we'll discuss in the Knowledge Cascade.\n---\n## Knowledge Cascade: What This Unlocks\n### 1. /proc/PID/mem â€” Amortizing PEEKDATA Overhead\n`/proc/PID/mem` is a special file that represents the tracee's entire address space as a file. Open it, `lseek` to the desired virtual address, and call `read()` to get data. The key advantage: you can read *arbitrary lengths* in one `read()` call, not just 8 bytes.\n```c\n/* Alternative to PTRACE_PEEKDATA for long strings */\nchar path_buf[1024];\nint memfd;\nchar mempath[64];\nsnprintf(mempath, sizeof(mempath), \"/proc/%d/mem\", pid);\nmemfd = open(mempath, O_RDONLY);\npread(memfd, path_buf, sizeof(path_buf), (off_t)addr);\nclose(memfd);\n```\nModern strace (versions â‰¥ 4.14) uses `/proc/PID/mem` for string reads, falling back to PEEKDATA only when the file isn't accessible. A 256-byte path string costs 1 `pread()` call instead of 32 `PTRACE_PEEKDATA` calls â€” a 32Ã— reduction in syscall overhead for that read. The catch: `/proc/PID/mem` requires the tracee to be stopped (which ptrace ensures) and requires appropriate permissions (which you have, since you're the tracer).\n### 2. process_vm_readv â€” The Modern Cross-Address-Space Copy\nLinux 3.2 introduced `process_vm_readv(2)`, a syscall designed specifically for this problem:\n```c\n#include <sys/uio.h>\nssize_t process_vm_readv(pid_t pid,\n                         const struct iovec *local_iov,\n                         unsigned long liovcnt,\n                         const struct iovec *remote_iov,\n                         unsigned long riovcnt,\n                         unsigned long flags);\n```\nYou describe a list of source regions in the *remote* (tracee) address space and a list of destination buffers in your *local* address space. The kernel copies all of them in a single syscall, without the per-word overhead of PEEKDATA. This is 10-100Ã— faster than a PEEKDATA loop for multi-word copies.\n`process_vm_readv` doesn't require the tracee to be stopped â€” it works on running processes. This makes it ideal for profiling tools that want to sample the tracee's memory without full ptrace overhead. The tradeoff: less precision (the target may have moved on while you're reading), and it requires `PTRACE_MODE_ATTACH_REALCREDS` privileges if the target isn't your child.\n### 3. Virtual Memory and Page Tables â€” Why Address Spaces Are Isolated\nThe `CR3` register holds the physical address of the page directory (the top of the 4-level page table on x86_64). Every process has its own `CR3` value stored in its kernel-side task structure. During context switch, the kernel does `mov %cr3, <new_value>` â€” and from that moment, all virtual address translations go through the new process's page tables.\nThis hardware mechanism is why process isolation works and why PEEKDATA must exist. The MMU is not a software construct; it's silicon that enforces virtualâ†’physical translation on every single memory access the CPU makes. Bypassing it requires going through the kernel, which is exactly what PEEKDATA does.\nUnderstanding `CR3` and page tables is also the foundation for:\n- Container runtimes (each container process has its own address space â€” no additional mechanism needed)\n- VM introspection (hypervisors reading guest VM memory use the same \"cross-address-space read\" concept but at the VM level)\n- Kernel Samepage Merging (KSM) â€” the kernel scans different processes' physical pages looking for duplicates to merge\n> ðŸ”­ **Deep Dive**: For a thorough treatment of x86_64 virtual memory and page table structure, see the Intel Software Developer's Manual Volume 3A, Section 4 (\"Paging\"), or for a more accessible treatment, Bovet & Cesati's *Understanding the Linux Kernel* (3rd edition), Chapter 2.\n### 4. GDB's `x` Command â€” The Same Mechanism\nWhen you use GDB's `x/s $rdi` to examine a string at the address in `rdi`, GDB is doing exactly what you've just built: calling `PTRACE_PEEKDATA` in a loop, scanning for null bytes, and printing the result. This is why examining 1MB of memory in GDB can take several seconds â€” it's thousands of PEEKDATA calls, each costing a kernel round trip.\nGDB also uses `/proc/PID/mem` as an optimization (since GDB 7.12, approximately). You can verify this with `strace -p $(pgrep gdb)` â€” you'll see `pread64` calls on the `/proc/...mem` file descriptor, interspersed with the usual ptrace calls.\nNow you understand not just *that* GDB is slow at memory examination, but *exactly why* and *what the limit is*. A PEEKDATA word costs ~1,500 cycles. At 1 GHz effective throughput (accounting for kernel overhead), examining 1MB via PEEKDATA would take ~190,000 calls Ã— 1,500 cycles = 285,000,000 cycles â‰ˆ 95ms. Via `/proc/PID/mem`, it's one `pread()` â‰ˆ 5ms.\n### 5. ELF String Tables â€” The Same Index Structure\nThe syscall name table you built â€” a fixed array indexed by number, containing string pointers â€” mirrors the structure ELF binaries use to store symbol names. An ELF file contains a `.strtab` section (a flat array of null-terminated strings packed end-to-end) and a `.symtab` section (an array of symbol entries, each containing an offset into `.strtab`). To find a symbol's name, you index `.symtab` by symbol number, read the `st_name` offset, then index into `.strtab` at that offset.\nYour table is the same pattern: array index = syscall number, value = pointer to name string. ELF just flattens the strings into one big buffer and uses offsets instead of pointers. This is a common pattern in systems software: \"index â†’ offset â†’ null-terminated string in a flat buffer.\" You'll see it in font files, debug information (DWARF), and network protocol tables.\n---\n## Summary: What You've Built\nYour tracer now:\n- Looks up syscall numbers in a name table and prints human-readable names like `open`, `mmap`, `write`\n- Saves register state at entry and uses it on exit to print argument values\n- Extracts integer, pointer, and string arguments from the six x86_64 syscall argument registers (`rdi`, `rsi`, `rdx`, `r10`, `r8`, `r9`)\n- Reads string arguments from the tracee's memory word-by-word via `PTRACE_PEEKDATA`, correctly handling the `errno`-vs-`-1` ambiguity\n- Truncates strings at a configurable maximum (default 32 bytes) with a `...` suffix\n- Decodes bitmask flag arguments for `open()`, `mmap()` prot, and `mmap()` flags into `O_RDONLY|O_CLOEXEC`-style strings\n- Handles edge cases: NULL pointers (prints `NULL`), unrecognized syscalls (`unknown`), unknown flags (prints remaining bits as hex)\n- Formats output in strace style: `syscall_name(arg1, arg2) = return_value`\nThe output of your tracer is now human-readable. Milestone 3 will make it multi-process-aware: following `fork()`, `vfork()`, and `clone()` across process boundaries, tagging every line with the PID that made the call, and maintaining per-PID state to keep the entry/exit toggle correct across interleaved events.\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-strace-m3 -->\n# Milestone 3: Multi-Process and Fork Following\n## Where You Are Now\nYour Milestone 2 tracer produces beautifully formatted output for a single process:\n```\nexecve(\"/bin/ls\", [\"/bin/ls\", \"/tmp\"], 0x7ffd3b2c1200) = 0\nbrk(NULL) = 0x562a1a3c0000\naccess(\"/etc/ld.so.preload\", R_OK) = -1 ENOENT (No such file or directory)\nopenat(AT_FDCWD, \"/etc/ld.so.cache\", O_RDONLY|O_CLOEXEC) = 3\nwrite(1, \"file1.txt  file2.txt\\n\", 21) = 21\n+++ exited with 0 +++\n```\nNow run your tracer against something that calls `fork()`:\n```bash\n./strace_clone bash -c \"echo hello | cat\"\n```\nWhat happens? Your tracer prints the bash startup syscalls faithfully. Then bash calls `fork()` to spawn a subshell, and `fork()` again to run `echo`, and `fork()` again to run `cat`. The forked children run entirely unobserved. Your tracer is watching bash's side of the story â€” everything the children do is invisible. The `echo` and `cat` processes run, write to the pipe, exit, and you never saw a single syscall from them.\nThis isn't just an annoyance. It's a fundamental limitation that makes your tracer incorrect for any non-trivial workload. Shell scripts, Python programs, web servers, databases â€” they all fork. The real strace traces the *entire process tree*, and that's what you'll build in this milestone.\nBy the end, your tracer will produce output like this:\n```\n[pid 12345] execve(\"/bin/bash\", [\"/bin/bash\", \"-c\", \"echo hello | cat\"], ...) = 0\n[pid 12345] pipe([3, 4]) = 0\n[pid 12345] clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|...) = 12346\n[pid 12346] execve(\"/bin/echo\", [\"/bin/echo\", \"hello\"], ...) = 0\n[pid 12346] write(1, \"hello\\n\", 6) = 6\n[pid 12346] exit_group(0) = ?\n[pid 12345] wait4(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], ...) = 12346\n+++ exited with 0 +++\n```\nEvery process. Every syscall. Correctly interleaved. That's what this milestone delivers.\n\n![Interleaved Multi-Process Output Example](./diagrams/diag-m3-multi-process-output.svg)\n\n---\n## The Core Revelation: Tracing Is Not Inherited\nHere is the assumption that will break your first attempt at multi-process tracing:\n> *The child process inherits everything from its parent â€” file descriptors, memory mappings, signal handlers. Surely it inherits the ptrace relationship too?*\nThis feels completely reasonable. After all, if ptrace is about observation, and the child is a copy of the parent, shouldn't the kernel observe the child too? The child even shares the parent's executable code until copy-on-write kicks in. Why would the tracing relationship be different?\n**It isn't inherited. Not at all.** When a traced process calls `fork()`, the child process starts life *completely untraced*. It runs at full speed, unobserved, making syscalls your tracer never sees. By the time you even learn that a fork happened â€” via the `PTRACE_SYSCALL` event that fires in the parent â€” the child may have already run thousands of syscalls and possibly exited.\nThis is not an oversight in the kernel design. There's a deep reason: ptrace is a relationship between *specific processes*. The kernel tracks a tracer PID for each tracee. When a fork creates a new PID, that new PID has no tracer until one is explicitly designated. The kernel won't automatically assign your tracer as the observer of a process it didn't ask to observe. Automatic inheritance would be a security hole â€” imagine a traced sandbox program forking an untraced helper that escapes the sandbox's policy.\nThe solution is to opt in *before* the fork happens, using `PTRACE_SETOPTIONS`. When you set `PTRACE_O_TRACEFORK`, `PTRACE_O_TRACEVFORK`, and `PTRACE_O_TRACECLONE` on a tracee, you're telling the kernel: \"When this process calls `fork()`, `vfork()`, or `clone()`, automatically attach to the new child on my behalf, and deliver a special event stop to tell me about it.\" The kernel does this atomically â€” there is no window where the child runs untraced. The child starts in a stopped state, waiting for your tracer to give it the first `PTRACE_SYSCALL` command.\n\n![Fork Event Sequence: Parent Forks, Kernel Notifies Tracer](./diagrams/diag-m3-fork-event-sequence.svg)\n\nThis atomicity is the key property. Let's understand why it matters.\n### The Race Condition That Doesn't Exist (Because You Set the Option)\nImagine an alternative design: you receive a `fork()` exit event (child PID = 12346), then you call `ptrace(PTRACE_ATTACH, 12346, ...)` to start tracing the new child. What's the problem?\nThere's a window. Between the moment `fork()` completes in the tracee and the moment your tracer's `PTRACE_ATTACH` syscall executes, the child is running freely. For a fast child â€” one that does minimal work and exits quickly â€” it may finish entirely within this window. You'd get `ESRCH` (no such process) from `PTRACE_ATTACH` because the process no longer exists. Or worse, the child might spawn *its own* children before you attach, which are also untraced.\nThis is a classic Time-of-Check-to-Time-of-Use (TOCTOU) race condition. The \"check\" is `fork()` returning a PID, and the \"use\" is attaching to that PID â€” but the PID's lifetime is unconstrained between those two events.\n`PTRACE_O_TRACEFORK` eliminates the race entirely. The kernel performs the attachment *inside the `fork()` syscall handler*, before the child process ever gets scheduled. The child begins its life in a ptrace stop state. By the time you learn a fork happened, the child is already frozen, waiting for you. No race. No window. Atomic guarantee.\n---\n## Setting the Options: Before the Fork Happens\nYou already know how to set ptrace options â€” you used `PTRACE_SETOPTIONS` in Milestone 1 to set `PTRACE_O_TRACESYSGOOD`. Now you add the fork-following options to the same call:\n```c\n/* After the initial post-exec waitpid, set ALL options at once */\nlong opts = PTRACE_O_TRACESYSGOOD   /* Bit 7 on syscall stops          */\n           | PTRACE_O_TRACEFORK     /* Catch fork() in tracee          */\n           | PTRACE_O_TRACEVFORK    /* Catch vfork() in tracee         */\n           | PTRACE_O_TRACECLONE    /* Catch clone() in tracee         */\n           | PTRACE_O_TRACEEXEC;    /* Catch execve() in tracee        */\nif (ptrace(PTRACE_SETOPTIONS, child, NULL, (void *)opts) == -1) {\n    perror(\"ptrace SETOPTIONS\");\n    return 1;\n}\n```\nA crucial detail: **these options are set on the parent tracee, not on future children**. When a child is created with `PTRACE_O_TRACEFORK` active, the new child *automatically inherits the same options*. So if the child later forks grandchildren, those grandchildren are also automatically traced and get the same option set. Your single `PTRACE_SETOPTIONS` call propagates down the entire process tree indefinitely.\nLet's clarify what each option does:\n**`PTRACE_O_TRACEFORK`** â€” Intercepts calls to `fork()`. On x86_64, `fork()` is syscall 57. When a traced process calls `fork()`, the kernel delivers a `PTRACE_EVENT_FORK` stop to your tracer at the exit of the `fork()` syscall.\n**`PTRACE_O_TRACEVFORK`** â€” Intercepts `vfork()` (syscall 58). `vfork()` is a variant of `fork()` where the parent *suspends* until the child calls `exec()` or `_exit()`. The child borrows the parent's address space without copying it. The event is `PTRACE_EVENT_VFORK`.\n**`PTRACE_O_TRACECLONE`** â€” Intercepts `clone()` (syscall 56). `clone()` is the general-purpose process/thread creation syscall on Linux. Both `fork()` and `vfork()` are implemented as thin wrappers around `clone()` in glibc. Threads are also created via `clone()` with different flags. The event is `PTRACE_EVENT_CLONE`.\n**`PTRACE_O_TRACEEXEC`** â€” Intercepts `execve()`. When a traced process successfully replaces its image with a new program, the kernel delivers `PTRACE_EVENT_EXEC`. This is essential for handling address space replacement, which we'll cover later in this milestone.\n> **Why trace clone for threads?** When a program creates a thread using `pthread_create()`, glibc calls `clone()` with `CLONE_VM | CLONE_THREAD | ...` flags. The resulting thread shares the address space with the parent (it's not a separate process). By setting `PTRACE_O_TRACECLONE`, you trace threads too. Whether you *want* to trace every thread is a design choice â€” real strace traces all threads by default. For this milestone, we'll trace them all.\n---\n## Switching to waitpid(-1): Catching Any Child\nWith Milestones 1 and 2, your `waitpid` call looked like this:\n```c\nwaitpid(child, &status, 0);  /* Wait for ONE specific PID */\n```\nThis is no longer sufficient. You might now be tracing 5, 10, or 50 PIDs simultaneously. You don't know which one will stop next â€” it depends on scheduler timing, I/O, signals, and factors completely outside your control. If you call `waitpid(12345, ...)` while PID 12346 has just stopped and is waiting for you, you'll deadlock: 12346 is frozen waiting for your `PTRACE_SYSCALL`, and you're blocked waiting for 12345.\nThe fix is simple and powerful: use `-1` as the PID argument to `waitpid`:\n```c\npid_t stopped_pid = waitpid(-1, &status, 0);\n```\nWhen the PID argument is `-1`, `waitpid` returns the status of *any* child that changes state. It picks whoever stopped first. The return value is the PID of the process that stopped â€” this is essential, because now you need to know *which* process triggered the event to dispatch to the correct per-PID state.\nThe tracing loop structure changes from this:\n```c\n/* Milestone 2: single-process */\nwhile (1) {\n    ptrace(PTRACE_SYSCALL, child, NULL, NULL);\n    waitpid(child, &status, 0);\n    /* ... handle status ... */\n}\n```\nTo this:\n```c\n/* Milestone 3: multi-process */\nwhile (active_process_count > 0) {\n    pid_t stopped_pid = waitpid(-1, &status, 0);\n    if (stopped_pid == -1) break;\n    /* Dispatch: find state for stopped_pid, handle the event */\n    ProcessState *state = find_state(stopped_pid);\n    handle_event(stopped_pid, state, status);\n}\n```\nNotice the loop condition changed too. You no longer loop until a single process exits â€” you loop until *all* traced processes have exited.\n\n![waitpid(-1) Event Dispatch: Multi-PID Decision Tree](./diagrams/diag-m3-waitpid-dispatch-flowchart.svg)\n\n---\n## Decoding ptrace Events: The status>>16 Trick\nWhen `PTRACE_O_TRACEFORK` and friends are set, the kernel delivers special \"ptrace event\" stops to your tracer. These events come through the same `waitpid` status word you've been using, but they're encoded in the *high 16 bits* of the status â€” a region you haven't used yet.\nHere's the status word layout for a ptrace event stop:\n```\nBits 31-24: 0\nBits 23-16: PTRACE_EVENT_* constant (the event type)\nBits  15-8: SIGTRAP (signal 5)\nBits   7-0: 0x7f (stopped, not exited)\n```\nThe `WIFSTOPPED(status)` macro is true. `WSTOPSIG(status)` returns `SIGTRAP` (not `SIGTRAP | 0x80` â€” event stops don't set bit 7 even with `TRACESYSGOOD`). The event type sits in `status >> 16`.\nThe defined event constants in `<sys/ptrace.h>`:\n| Constant | Value | Triggered By |\n|----------|-------|-------------|\n| `PTRACE_EVENT_FORK` | 1 | `fork()` in tracee |\n| `PTRACE_EVENT_VFORK` | 2 | `vfork()` in tracee |\n| `PTRACE_EVENT_CLONE` | 3 | `clone()` in tracee |\n| `PTRACE_EVENT_EXEC` | 4 | successful `execve()` in tracee |\n| `PTRACE_EVENT_VFORK_DONE` | 5 | vfork child called exec/exit, parent resumes |\n| `PTRACE_EVENT_EXIT` | 6 | tracee is about to exit (not yet dead) |\nTo extract the event type:\n```c\nint event = (status >> 16) & 0xff;\n```\nOr use the macro if your headers define it:\n```c\n/* Some systems define this, some don't â€” define it yourself to be safe */\n#define PTRACE_EVENT(status) ((status) >> 16)\n```\nA complete stop classification now looks like this:\n```c\nif (WIFEXITED(status)) {\n    /* Tracee exited â€” remove from state map */\n} else if (WIFSIGNALED(status)) {\n    /* Tracee killed by signal â€” remove from state map */\n} else if (WIFSTOPPED(status)) {\n    int sig = WSTOPSIG(status);\n    int event = (status >> 16) & 0xff;\n    if (event != 0) {\n        /* ptrace event stop â€” handle fork/exec/etc. */\n        handle_ptrace_event(stopped_pid, event, status);\n    } else if (sig == (SIGTRAP | 0x80)) {\n        /* Syscall stop (TRACESYSGOOD) */\n        handle_syscall_stop(stopped_pid, state);\n    } else if (sig == SIGTRAP) {\n        /* Plain SIGTRAP â€” post-exec stop or breakpoint */\n        /* Just resume */\n        ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n    } else {\n        /* Signal-delivery stop â€” re-inject */\n        ptrace(PTRACE_SYSCALL, stopped_pid, NULL, (void *)(long)sig);\n    }\n}\n```\n---\n## Retrieving the New Child PID with PTRACE_GETEVENTMSG\nWhen you receive a `PTRACE_EVENT_FORK`, `PTRACE_EVENT_VFORK`, or `PTRACE_EVENT_CLONE` stop on process P, you know P forked. But what's the child's PID?\n`PTRACE_GETEVENTMSG` retrieves the message associated with the most recent ptrace event:\n```c\nunsigned long new_child_pid;\nif (ptrace(PTRACE_GETEVENTMSG, stopped_pid, NULL, &new_child_pid) == -1) {\n    perror(\"PTRACE_GETEVENTMSG\");\n    /* Handle error */\n} else {\n    /* new_child_pid is the new process's PID */\n    printf(\"[pid %lu] forked\\n\", new_child_pid);\n    /* Create state for new_child_pid in your state map */\n    init_process_state((pid_t)new_child_pid);\n    /* Resume the new child (it's currently stopped, waiting for us) */\n    ptrace(PTRACE_SYSCALL, (pid_t)new_child_pid, NULL, NULL);\n}\n```\nTwo things to understand here:\n**First**: When `PTRACE_GETEVENTMSG` is called after a fork event, the returned value is the new child's PID. When called after an exec event, it returns the old PID (before exec replaced the process image) â€” useful if PIDs change, though on Linux exec doesn't change the PID.\n**Second**: At the moment your tracer receives the fork event, **the new child is already stopped**. It hasn't run a single instruction. You must call `ptrace(PTRACE_SYSCALL, new_child_pid, ...)` to let it start executing. If you forget this, the child is frozen forever, and your loop will never get an exit event for it â€” you'll hang.\nHere's the complete fork event handler:\n```c\nvoid handle_fork_event(pid_t parent_pid, int event) {\n    unsigned long child_pid_ul;\n    if (ptrace(PTRACE_GETEVENTMSG, parent_pid, NULL, &child_pid_ul) == -1) {\n        perror(\"PTRACE_GETEVENTMSG\");\n        /* Resume parent anyway */\n        ptrace(PTRACE_SYSCALL, parent_pid, NULL, NULL);\n        return;\n    }\n    pid_t child_pid = (pid_t)child_pid_ul;\n    const char *fork_type = (event == PTRACE_EVENT_FORK)  ? \"fork\"  :\n                            (event == PTRACE_EVENT_VFORK) ? \"vfork\" : \"clone\";\n    fprintf(stderr, \"[pid %d] %s() = %d\\n\", parent_pid, fork_type, child_pid);\n    /* Create state for the new child */\n    ProcessState *child_state = state_map_insert(child_pid);\n    child_state->in_syscall = 0;  /* Child starts fresh â€” not mid-syscall */\n    active_process_count++;\n    /* Release the child so it can start executing */\n    if (ptrace(PTRACE_SYSCALL, child_pid, NULL, NULL) == -1) {\n        /* Child may have already exited â€” that's OK */\n        if (errno != ESRCH) {\n            perror(\"ptrace PTRACE_SYSCALL (new child)\");\n        }\n    }\n    /* Resume the parent too */\n    ptrace(PTRACE_SYSCALL, parent_pid, NULL, NULL);\n}\n```\n---\n## Per-PID State: The Hash Map\nIn Milestone 2, your per-process state was a single struct for a single process:\n```c\ntypedef struct {\n    int                     in_syscall;\n    struct user_regs_struct entry_regs;\n} ProcessState;\nProcessState state = { .in_syscall = 0 };\n```\nNow you need this for potentially dozens of PIDs simultaneously. You need a data structure that:\n1. Inserts a new PID â†’ state mapping when a child is born\n2. Looks up state by PID on every `waitpid` event (hot path â€” called for *every* syscall)\n3. Removes a PID when the process exits\n4. Handles whatever maximum number of simultaneous processes your workload generates\nOn Linux, PIDs are integers in the range `[1, 4194304]` (by default, configurable via `/proc/sys/kernel/pid_max`). A direct array of size 4M would be wasteful but possible. A hash map is more appropriate for general use.\n\n![Per-PID State Hash Map â€” Structure and Lookup](./diagrams/diag-m3-per-pid-state-map.svg)\n\n### Designing the State Struct\nBefore building the map, expand `ProcessState` to include everything per-PID you'll need:\n```c\n#include <sys/user.h>\n#include <sys/ptrace.h>\ntypedef struct {\n    pid_t                   pid;         /* Which process this entry belongs to */\n    int                     in_syscall;  /* Toggle: 0=entry next, 1=exit next */\n    struct user_regs_struct entry_regs;  /* Register snapshot from entry stop */\n    int                     valid;       /* Is this slot occupied? (for open addressing) */\n} ProcessState;\n```\nThe memory layout of this struct matters. Let's account for it:\n| Field | Type | Size | Offset |\n|-------|------|------|--------|\n| `pid` | `pid_t` (int) | 4 bytes | 0 |\n| `in_syscall` | `int` | 4 bytes | 4 |\n| `entry_regs` | `struct user_regs_struct` | 216 bytes | 8 |\n| `valid` | `int` | 4 bytes | 224 |\n| (padding) | â€” | 4 bytes | 228 |\n| **Total** | | **232 bytes** | |\nAt 232 bytes per entry, a table with 256 slots costs 59 KB â€” fits comfortably in L2 cache (typically 256 KBâ€“1 MB). The `entry_regs` struct alone is 216 bytes (27 64-bit registers), spanning approximately 4 cache lines (64 bytes each). Every `PTRACE_GETREGS` call writes all 216 bytes into your state.\n### A Simple Open-Addressing Hash Map\nFor a systems project at this level, a simple open-addressing hash map with linear probing is correct and efficient. PIDs are small integers â€” they hash well with a simple modulo. Here's a minimal implementation:\n```c\n#define STATE_MAP_SIZE 256   /* Must be a power of 2 for mask trick */\n#define STATE_MAP_MASK (STATE_MAP_SIZE - 1)\nstatic ProcessState state_map[STATE_MAP_SIZE];\n/* Initialize the map â€” all entries start invalid */\nvoid state_map_init(void) {\n    memset(state_map, 0, sizeof(state_map));\n    for (int i = 0; i < STATE_MAP_SIZE; i++) {\n        state_map[i].valid = 0;\n    }\n}\n/* Hash function: PID modulo table size (PIDs are already somewhat random) */\nstatic int hash_pid(pid_t pid) {\n    return (int)(pid & STATE_MAP_MASK);\n}\n/* Insert a new PID entry; returns pointer to the state, NULL on error */\nProcessState *state_map_insert(pid_t pid) {\n    int idx = hash_pid(pid);\n    for (int i = 0; i < STATE_MAP_SIZE; i++) {\n        int slot = (idx + i) & STATE_MAP_MASK;\n        if (!state_map[slot].valid) {\n            state_map[slot].pid = pid;\n            state_map[slot].in_syscall = 0;\n            state_map[slot].valid = 1;\n            memset(&state_map[slot].entry_regs, 0,\n                   sizeof(state_map[slot].entry_regs));\n            return &state_map[slot];\n        }\n    }\n    return NULL;  /* Table full */\n}\n/* Look up state for a PID; returns NULL if not found */\nProcessState *state_map_find(pid_t pid) {\n    int idx = hash_pid(pid);\n    for (int i = 0; i < STATE_MAP_SIZE; i++) {\n        int slot = (idx + i) & STATE_MAP_MASK;\n        if (!state_map[slot].valid) return NULL;  /* Empty slot: not present */\n        if (state_map[slot].pid == pid) return &state_map[slot];\n    }\n    return NULL;\n}\n/* Remove a PID entry */\nvoid state_map_remove(pid_t pid) {\n    int idx = hash_pid(pid);\n    for (int i = 0; i < STATE_MAP_SIZE; i++) {\n        int slot = (idx + i) & STATE_MAP_MASK;\n        if (!state_map[slot].valid) return;  /* Not found */\n        if (state_map[slot].pid == pid) {\n            state_map[slot].valid = 0;\n            /* Note: open addressing with linear probing requires tombstones\n             * or rehashing on removal to preserve lookup correctness.\n             * For simplicity here, we zero the slot and accept that\n             * lookups may stop at empty slots. For a small table with\n             * low load factor this is fine. */\n            return;\n        }\n    }\n}\n```\n> **Design Decision: Open Addressing vs. Chaining**\n>\n> | Option | Pros | Cons | Used By |\n> |--------|------|------|---------|\n> | **Open addressing (this code) âœ“** | Cache-friendly (sequential probing), no allocations | Deletion is tricky (tombstones needed), degrades at high load | Real strace (similar approach) |\n> | Chaining (linked list per bucket) | Simple deletion, no clustering | Pointer chasing, allocations, cache misses | HashMap in many languages |\n> | Direct array (4M entries) | O(1) guaranteed, zero collisions | 4M Ã— 232B = ~928 MB (!), wasteful | Not appropriate here |\n>\n> With a 256-slot table and a maximum of ~50 simultaneously traced processes (realistic for most workloads), the load factor stays below 0.2 â€” collision chains will be very short.\n> **Tombstone Note**: The removal code above has a subtle bug: open addressing with linear probing requires that you don't simply clear removed slots, or else lookups will incorrectly terminate at those empty slots and miss entries that were probed past them. For production code, use a tombstone marker (`valid = -1`) that lookup skips but insert can reuse. For this milestone, with a large table and low load factor, the practical impact is negligible, but be aware of it.\n---\n## PID-Tagged Output\nWhen multiple processes are active, output lines must identify which process made each syscall. Real strace uses the format `[pid NNNN]` as a prefix on every line when tracing more than one process.\nModify your `print_syscall` function from Milestone 2 to accept the PID and a flag indicating whether to show it:\n```c\nvoid print_syscall(pid_t pid, int show_pid,\n                   struct user_regs_struct *entry_regs,\n                   long return_val)\n{\n    if (show_pid) {\n        fprintf(stderr, \"[pid %d] \", pid);\n    }\n    long syscall_num = (long)entry_regs->orig_rax;\n    const char *name = syscall_name(syscall_num);\n    /* ... rest of formatting as in Milestone 2 ... */\n}\n```\nAlternatively â€” and this is cleaner â€” always print the PID prefix. Real strace only suppresses it when tracing a single process, but showing it always is simpler and always correct. The cost is a few extra characters per line.\nFor the fork/exec events themselves (not syscall stops), print them as strace does:\n```\n[pid 12345] clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|SIGCHLD) = 12346\n```\nThis means printing the fork-type syscall result *in the parent's context* when the fork event fires. The parent's `orig_rax` contains the clone/fork syscall number, and the new child's PID is the return value. You print it at the fork event stop, which fires at the *exit* of the fork syscall in the parent â€” so you have both the syscall name and the child PID.\n---\n## Handling PTRACE_EVENT_EXEC: Address Space Replacement\n`exec()` is the most dramatic thing a process can do short of dying. When `execve()` succeeds, the kernel throws away everything about the process's current state:\n- The entire text (code) segment is replaced\n- The heap is destroyed and rebuilt\n- The stack is replaced with a fresh one\n- All memory-mapped regions are unmapped and replaced\n- File descriptors marked `O_CLOEXEC` are closed\nWhat doesn't change:\n- The PID\n- The PPID (parent PID)\n- The ptrace attachment (the process stays traced)\n\n![PTRACE_EVENT_EXEC: Address Space Replacement](./diagrams/diag-m3-exec-state-reset.svg)\n\nFor your tracer, this means: **any pointer you cached from before the exec is now dangling**. The string `\"/bin/old_program\"` that used to be at address `0x7ffd12340000` in the tracee's address space no longer exists at that address. The address space has been completely replaced.\nWhat does this mean practically for your per-PID state?\nThe `entry_regs` you saved at a syscall entry stop is invalidated if exec happens before the exit stop. Fortunately, `exec()` fires `PTRACE_EVENT_EXEC` *at the exit of the execve syscall*, which means the previous syscall (if any) has already completed. The entry/exit toggle should be in the \"entry\" state (waiting for the next entry) at the point exec fires. But to be safe, you should reset the toggle:\n```c\nvoid handle_exec_event(pid_t pid) {\n    ProcessState *state = state_map_find(pid);\n    if (state == NULL) {\n        /* Exec from a previously unknown PID â€” this can happen if TRACEME\n         * is used and the initial stop triggers an exec event.\n         * Insert new state. */\n        state = state_map_insert(pid);\n        if (state == NULL) {\n            fprintf(stderr, \"State map full\\n\");\n            return;\n        }\n    }\n    /* Reset per-PID state: address space is now entirely different */\n    state->in_syscall = 0;\n    memset(&state->entry_regs, 0, sizeof(state->entry_regs));\n    /* The PTRACE_EVENT_EXEC stop fires at the exit of execve.\n     * The execve return value will be 0 (success) in rax.\n     * We could print execve(...) = 0 here, but we already printed\n     * the execve entry. Alternatively, handle it as a special case. */\n    fprintf(stderr, \"[pid %d] <... execve resumed> = 0\\n\", pid);\n    /* Resume the process */\n    ptrace(PTRACE_SYSCALL, pid, NULL, NULL);\n}\n```\n> **The exec entry/exit problem**: With `PTRACE_EVENT_EXEC` set, execve stops are slightly unusual. The entry stop fires normally (you see it as a syscall entry, read `orig_rax = 59` for execve). Then, if exec succeeds, instead of a plain syscall exit stop, you get a `PTRACE_EVENT_EXEC` stop. Your toggle will be in the \"in_syscall\" state (waiting for exit). The exec event handler should reset it to 0. If exec *fails* (returns -1 ENOENT etc.), you get a normal syscall exit stop instead â€” no exec event. Handle both cases.\n---\n## Tracking Active Processes: The Exit Count\nYour loop must know when all traced processes have exited so it can stop. Maintain a counter:\n```c\nint active_count = 0;  /* Number of currently-traced, live processes */\n```\n- Increment when you create a new state (on fork events and at startup for the initial child).\n- Decrement when `WIFEXITED(status)` or `WIFSIGNALED(status)` is true for any PID.\n- Loop condition: `while (active_count > 0)`.\nBe careful with the ordering: remove the PID's state from the map *and* decrement the counter when you see the exit event. Don't decrement twice.\n```c\nif (WIFEXITED(status)) {\n    int code = WEXITSTATUS(status);\n    fprintf(stderr, \"[pid %d] +++ exited with %d +++\\n\", stopped_pid, code);\n    state_map_remove(stopped_pid);\n    active_count--;\n} else if (WIFSIGNALED(status)) {\n    int sig = WTERMSIG(status);\n    fprintf(stderr, \"[pid %d] +++ killed by signal %d (%s) +++\\n\",\n            stopped_pid, sig, strsignal(sig));\n    state_map_remove(stopped_pid);\n    active_count--;\n}\n```\n---\n## Putting It All Together: The Complete Multi-Process Loop\nHere is the full tracing loop for Milestone 3. This replaces the single-process loop from Milestone 2:\n```c\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/user.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n/* ... (ProcessState, state_map_*, print_syscall, etc. from earlier sections) ... */\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <program> [args...]\\n\", argv[0]);\n        return 1;\n    }\n    state_map_init();\n    pid_t child = fork();\n    if (child < 0) { perror(\"fork\"); return 1; }\n    if (child == 0) {\n        /* Child: request tracing */\n        ptrace(PTRACE_TRACEME, 0, NULL, NULL);\n        execvp(argv[1], &argv[1]);\n        perror(\"execvp\");\n        exit(1);\n    }\n    /* Catch initial post-exec SIGTRAP */\n    int status;\n    waitpid(child, &status, 0);\n    if (!WIFSTOPPED(status)) {\n        fprintf(stderr, \"Unexpected initial status\\n\");\n        return 1;\n    }\n    /* Set all options: syscall marking + fork following + exec events */\n    long opts = PTRACE_O_TRACESYSGOOD\n               | PTRACE_O_TRACEFORK\n               | PTRACE_O_TRACEVFORK\n               | PTRACE_O_TRACECLONE\n               | PTRACE_O_TRACEEXEC;\n    if (ptrace(PTRACE_SETOPTIONS, child, NULL, (void *)opts) == -1) {\n        perror(\"ptrace SETOPTIONS\");\n        return 1;\n    }\n    /* Initialize state for the first child */\n    ProcessState *init_state = state_map_insert(child);\n    init_state->in_syscall = 0;\n    int active_count = 1;\n    /* Resume the initial child */\n    ptrace(PTRACE_SYSCALL, child, NULL, NULL);\n    /* â”€â”€ MAIN TRACING LOOP â”€â”€ */\n    while (active_count > 0) {\n        /* Wait for ANY traced process to change state */\n        pid_t stopped_pid = waitpid(-1, &status, 0);\n        if (stopped_pid == -1) {\n            if (errno == ECHILD) break;  /* No more children */\n            perror(\"waitpid\");\n            break;\n        }\n        /* â”€â”€ PROCESS EXITED OR KILLED â”€â”€ */\n        if (WIFEXITED(status)) {\n            fprintf(stderr, \"[pid %d] +++ exited with %d +++\\n\",\n                    stopped_pid, WEXITSTATUS(status));\n            state_map_remove(stopped_pid);\n            active_count--;\n            continue;\n        }\n        if (WIFSIGNALED(status)) {\n            fprintf(stderr, \"[pid %d] +++ killed by signal %d (%s) +++\\n\",\n                    stopped_pid, WTERMSIG(status), strsignal(WTERMSIG(status)));\n            state_map_remove(stopped_pid);\n            active_count--;\n            continue;\n        }\n        /* â”€â”€ PROCESS STOPPED â”€â”€ */\n        if (!WIFSTOPPED(status)) continue;\n        int sig   = WSTOPSIG(status);\n        int event = (status >> 16) & 0xff;\n        ProcessState *state = state_map_find(stopped_pid);\n        if (state == NULL) {\n            /* Unknown PID â€” this can happen for the grandchild of a clone\n             * if our state_map_insert in the fork handler raced with the\n             * grandchild's first stop. Insert it now. */\n            state = state_map_insert(stopped_pid);\n            if (state == NULL) {\n                fprintf(stderr, \"State map full â€” resuming unknown PID %d\\n\",\n                        stopped_pid);\n                ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n                continue;\n            }\n            active_count++;\n        }\n        /* â”€â”€ PTRACE EVENT STOPS (fork, exec, etc.) â”€â”€ */\n        if (event != 0) {\n            switch (event) {\n            case PTRACE_EVENT_FORK:\n            case PTRACE_EVENT_VFORK:\n            case PTRACE_EVENT_CLONE: {\n                unsigned long new_pid_ul;\n                ptrace(PTRACE_GETEVENTMSG, stopped_pid, NULL, &new_pid_ul);\n                pid_t new_pid = (pid_t)new_pid_ul;\n                const char *kind = (event == PTRACE_EVENT_FORK)  ? \"fork\"  :\n                                   (event == PTRACE_EVENT_VFORK) ? \"vfork\" : \"clone\";\n                fprintf(stderr, \"[pid %d] %s() = %d\\n\",\n                        stopped_pid, kind, new_pid);\n                /* Create state for the new child */\n                ProcessState *child_state = state_map_insert(new_pid);\n                if (child_state != NULL) {\n                    child_state->in_syscall = 0;\n                    active_count++;\n                }\n                /* Start the new child's tracing */\n                if (ptrace(PTRACE_SYSCALL, new_pid, NULL, NULL) == -1) {\n                    if (errno != ESRCH) perror(\"ptrace new child\");\n                }\n                break;\n            }\n            case PTRACE_EVENT_EXEC:\n                /* Address space replaced â€” reset cached state */\n                state->in_syscall = 0;\n                memset(&state->entry_regs, 0, sizeof(state->entry_regs));\n                fprintf(stderr, \"[pid %d] <execve resumed> = 0\\n\", stopped_pid);\n                break;\n            case PTRACE_EVENT_EXIT:\n                /* Process is about to exit â€” we'll get WIFEXITED soon */\n                break;\n            default:\n                break;\n            }\n            /* Resume after any event stop */\n            ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n            continue;\n        }\n        /* â”€â”€ SYSCALL STOP (TRACESYSGOOD: bit 7 set) â”€â”€ */\n        if (sig == (SIGTRAP | 0x80)) {\n            struct user_regs_struct regs;\n            if (ptrace(PTRACE_GETREGS, stopped_pid, NULL, &regs) == -1) {\n                if (errno == ESRCH) { continue; }\n                perror(\"ptrace GETREGS\");\n                ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n                continue;\n            }\n            if (state->in_syscall == 0) {\n                /* ENTRY: save register snapshot, flip toggle */\n                state->entry_regs = regs;\n                state->in_syscall = 1;\n            } else {\n                /* EXIT: print using saved entry registers + current rax */\n                long return_val = (long)regs.rax;\n                print_syscall(stopped_pid, /*show_pid=*/1,\n                              &state->entry_regs, return_val);\n                state->in_syscall = 0;\n            }\n            ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n            continue;\n        }\n        /* â”€â”€ PLAIN SIGTRAP (post-exec stop or other) â”€â”€ */\n        if (sig == SIGTRAP) {\n            ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n            continue;\n        }\n        /* â”€â”€ SIGNAL-DELIVERY STOP: re-inject the signal â”€â”€ */\n        ptrace(PTRACE_SYSCALL, stopped_pid, NULL, (void *)(long)sig);\n    }\n    return 0;\n}\n```\n---\n## Three-Level View: What Happens When fork() Is Intercepted\nLet's trace through what happens at all three levels when a traced process calls `fork()`.\n**Level 1 â€” Application (Tracee)**\nThe process calls `fork()`. glibc's `fork()` wrapper is, on Linux, a thin wrapper around `clone()` with `SIGCHLD` flag. The actual syscall number is 57 (`fork`) or 56 (`clone`), depending on the glibc version and architecture. The `syscall` instruction fires.\n**Level 2 â€” Kernel**\n1. The entry stop fires. Your tracer wakes up, reads `orig_rax = 57`, saves entry registers, flips toggle to `in_syscall = 1`. Calls `PTRACE_SYSCALL` to resume.\n2. The kernel performs `do_fork()`: allocates a new `task_struct`, copies the parent's address space (copy-on-write), assigns a new PID, sets up the child's kernel stack.\n3. **Because `PTRACE_O_TRACEFORK` is set**: the kernel checks the tracee's `PT_TRACED` flag and the options. It sets `PT_TRACED` on the new child's `task_struct`. It puts the new child into `TASK_STOPPED` state before it ever runs. It adds the child to the tracer's list of traced processes.\n4. The kernel delivers `PTRACE_EVENT_FORK` to the tracer: it sets `status = (PTRACE_EVENT_FORK << 16) | (SIGTRAP << 8) | 0x7f` and wakes up the tracer's `waitpid`.\n5. Both parent and child are now stopped. The parent is waiting for your `PTRACE_SYSCALL` to resume it past the exit stop. The child is waiting for your `PTRACE_SYSCALL` to start it.\n**Level 3 â€” Hardware**\n`clone()`/`fork()` is one of the most expensive syscalls. Creating a new process involves:\n- Allocating a new `task_struct` (~4 KB kernel allocation)\n- Duplicating the page table (each level of the 4-level page table must be copied â€” at minimum, the top-level PGD, which is 4 KB)\n- For copy-on-write: marking all writable pages as read-only in both parent's and child's page tables, requiring TLB invalidation\n- A TLB shootdown: sending IPIs (Inter-Processor Interrupts) to all other CPU cores to flush their TLB entries for the parent's pages\nThe TLB shootdown is significant on multi-core systems. If your traced process was running on 8 cores before the fork, the kernel must interrupt all 8 cores to invalidate their TLB entries. This is on the order of 1â€“10 microseconds per fork â€” expensive enough that fork-heavy programs benefit from `posix_spawn()` or `vfork()` optimizations.\nFrom your tracer's perspective: the `waitpid` that returns the `PTRACE_EVENT_FORK` event typically arrives 50â€“200 microseconds after the fork syscall entry, depending on system load and the cost of the page table operations.\n---\n## The Tricky Cases: What Can Go Wrong\n### Race: New Child's First Stop Arrives Before Fork Event\nThe kernel guarantees that the `PTRACE_EVENT_FORK` stop on the parent fires before the child is scheduled. But your `waitpid(-1)` loop doesn't care about ordering â€” both events are queued. In practice, the fork event arrives first because the parent's event is queued before the child is even runnable. But defensively, handle the case where `state_map_find(stopped_pid)` returns NULL by inserting a new entry. The code above does this.\n### Clone Flags and Thread vs. Process\nWhen `clone()` is called with `CLONE_VM` (shared memory map) and `CLONE_THREAD` (same thread group), it creates a thread rather than a separate process. From ptrace's perspective, threads are treated like processes: they get their own PID (actually a TID, Thread ID), and each thread gets its own entry/exit toggle. Your state map handles this naturally â€” each TID is an independent key.\nThe practical complication: when a multi-threaded program exits, all threads receive an exit event. Your `active_count` must be decremented for each TID, not just for the main process's PID. The code above already handles this because it decrements on every `WIFEXITED` event from `waitpid(-1)`.\n### Exec Mid-Trace: The Toggle Confusion\nIf a process is in the `in_syscall = 1` state (you saw the entry stop, you're waiting for the exit stop) and then calls `execve()`, you'll see the execve entry stop, flip to `in_syscall = 1` (already 1... wait, no). Let's think through this carefully:\n1. Process calls `read()`: entry stop fires, toggle â†’ 1.\n2. Process returns from `read()`: exit stop fires, toggle â†’ 0. Print `read(...) = N`.\n3. Process calls `execve()`: entry stop fires, toggle â†’ 1. You save entry_regs (with `orig_rax = 59`).\n4. Exec succeeds: instead of exit stop, you get `PTRACE_EVENT_EXEC`. Your toggle is at 1.\n5. You must reset toggle to 0 and clear entry_regs.\nThis is exactly what the exec event handler does. Without it, the *next* syscall in the new program would be treated as an exit (because toggle is still 1), and you'd read garbage from the entry_regs that belonged to the old address space.\n### vfork: Parent Waits for Child\n`vfork()` is special: the parent is suspended in the kernel until the child calls `exec()` or `_exit()`. From your tracer's perspective, after the `PTRACE_EVENT_VFORK` stop fires:\n- Resume both parent and child with `PTRACE_SYSCALL`.\n- The parent won't produce any events until the child execs or exits (because it's suspended in the kernel).\n- The child will produce a stream of events.\n- When the child execs, you'll see `PTRACE_EVENT_VFORK_DONE` on the parent.\nYour code handles this correctly already â€” `waitpid(-1)` will naturally pick up the child's events while the parent produces none. When the parent eventually unsuspends, it'll start producing events again.\n---\n## Hardware Soul: The Cost of Multi-Process Tracing\nWhen you're tracing 10 simultaneous processes, what's the hardware doing?\n**Cache thrashing from context switches**: Each `waitpid` return potentially represents a context switch to a different process. A context switch replaces the CPU's register file, flushes the L1 instruction TLB (if no PCID), and may invalidate L1 data cache lines that belonged to the previous process. With 10 processes interleaving, you're generating 20 context switches per syscall (enter tracee â†’ tracer, inspect, tracer â†’ tracee, exit tracee â†’ tracer, inspect, tracer â†’ next tracee...). Each context switch costs 1,000â€“5,000 cycles on modern hardware.\n**State map lookup on hot path**: Every `waitpid` event requires a state map lookup. With a 256-slot open-addressing table and load factor 0.1, the average lookup is O(1) with essentially zero collision probing. The entire table (59 KB) fits in L2 cache. Once the trace starts, the table stays hot. A lookup costs roughly 5â€“15 cycles for the hash computation and 1-2 cache hits.\n**`struct user_regs_struct` size**: At 216 bytes, saving entry_regs requires writing ~4 cache lines. At 64 bytes per cache line, that's 4 cache line writes per entry stop. With the state map in L2 cache (hot), this costs approximately 4 Ã— 5 cycles = 20 cycles for the memory write â€” negligible compared to the context switch overhead.\n**The TLB picture**: Your tracer runs in its own address space. Every `PTRACE_GETREGS` and `PTRACE_PEEKDATA` call is a syscall into the kernel. The kernel access to tracee memory uses the kernel's own mapping of physical memory (which doesn't require switching `CR3`) â€” so the TLB concern for your tracer's own address space is limited to the syscall entry/exit mechanism itself, not per-PEEKDATA.\n---\n## Common Bugs in This Milestone\n### Bug 1: Not Resuming the New Child\n```c\n/* WRONG: forget to resume the new child */\ncase PTRACE_EVENT_FORK: {\n    unsigned long new_pid;\n    ptrace(PTRACE_GETEVENTMSG, stopped_pid, NULL, &new_pid);\n    /* Create state... */\n    /* â† MISSING: ptrace(PTRACE_SYSCALL, new_pid, NULL, NULL) */\n    break;\n}\n```\nThe new child sits frozen forever. Your `active_count` is incremented but the child never produces an exit event. The loop hangs.\n### Bug 2: Using waitpid(original_pid) instead of waitpid(-1)\n```c\n/* WRONG: still using the original child PID */\nwaitpid(child, &status, 0);  /* Misses events from all other PIDs */\n```\nEvents from forked children are never seen. Those children are frozen, waiting for your `PTRACE_SYSCALL`. The loop deadlocks when the original process waits for a child that your tracer never resumed.\n### Bug 3: Not Checking for NULL from state_map_find\n```c\n/* WRONG: crashing if state not found */\nProcessState *state = state_map_find(stopped_pid);\nstate->in_syscall = 1;  /* SEGFAULT if state is NULL */\n```\nAlways null-check. If the state map returns NULL, a PID showed up that you didn't expect â€” insert it defensively.\n### Bug 4: Misidentifying Event Stops as Syscall Stops\n```c\n/* WRONG: checking bit 7 first, before checking event */\nif (sig == (SIGTRAP | 0x80)) {\n    /* handle as syscall stop */\n}\n```\nIf `event != 0`, it's a ptrace event stop, not a syscall stop, even if some bit patterns coincide. Always check `event` first, then `sig`.\n### Bug 5: Double-Decrementing active_count\n```c\n/* WRONG: decrementing twice for one process exit */\nif (WIFEXITED(status)) {\n    active_count--;        /* Decrement 1 */\n    state_map_remove(stopped_pid);\n}\nif (state_map_find(stopped_pid) == NULL) {\n    active_count--;        /* Decrement 2 â€” same process! */\n}\n```\nThe loop exits prematurely or goes negative. Decrement exactly once per PID exit event.\n---\n## Testing Multi-Process Tracing\nTest progressively:\n```bash\n# Simple fork: bash -c runs a subshell\n./strace_clone bash -c \"ls /tmp\"\n# Multiple children: pipeline creates two children\n./strace_clone bash -c \"echo hello | cat\"\n# exec after fork: demonstrates PTRACE_EVENT_EXEC\n./strace_clone bash -c \"exec ls /tmp\"\n# Many forks: make -j4 forks multiple compilers\n./strace_clone make -j4\n# Thread creation via clone: any threaded program\n./strace_clone python3 -c \"import threading; threading.Thread(target=lambda: None).start()\"\n```\nExpected output for the pipeline test:\n```\n[pid 12345] execve(\"/bin/bash\", [\"/bin/bash\", \"-c\", \"echo hello | cat\"], ...) = 0\n[pid 12345] pipe([3, 4]) = 0\n[pid 12345] clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|...) = 12346\n[pid 12346] execve(\"/bin/echo\", ...) = 0\n[pid 12346] write(1, \"hello\\n\", 6) = 6\n[pid 12346] exit_group(0) = ?\n[pid 12345] wait4(-1, ...) = 12346\n[pid 12345] clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|...) = 12347\n[pid 12347] execve(\"/bin/cat\", ...) = 0\n...\n[pid 12345] +++ exited with 0 +++\n[pid 12347] +++ exited with 0 +++\n```\nThe interleaving order depends on scheduler timing and may vary between runs â€” that's expected.\n---\n## Knowledge Cascade: What This Unlocks\n### 1. Container Runtimes â€” The Entire Process Tree Must Be Observed\nWhen Docker, Podman, or runc starts a container, it must enforce that *every* process inside the container operates within the container's namespaces and cgroup limits. The container runtime can't just trace the initial process â€” it needs to follow every `fork()`, `vfork()`, and `clone()` the container makes, exactly as you've just built.\nContainer runtimes use `PTRACE_O_TRACEFORK` (or its equivalent in seccomp-BPF notification mode) to catch process creation. If a container process tries to `unshare()` its namespaces to escape containment, the seccomp filter catches it. If it forks a child that tries to access forbidden resources, the child is also observed because of the fork-following options. The atomicity guarantee â€” no window between fork and ptrace attachment â€” is what makes containers secure against fork-based escape attempts.\nThe `PTRACE_O_TRACEFORK` mechanism you just implemented is the same mechanism that makes Linux containers work at a fundamental level. You've just built the observation layer that container security depends on.\n### 2. PID Namespaces and Why waitpid(-1) Works\nLinux supports *PID namespaces*: a process in a container sees PIDs starting from 1, even though the host kernel assigns them much larger PIDs. From inside the container, PID 1 is the container's init process. From outside, it might be PID 73412.\nYour tracer runs outside any container namespace, so it sees the *host PIDs*. `waitpid(-1)` collects events from all direct child PIDs in your tracer's PID namespace â€” which includes all the traced processes, since they're children (or descendants) of your tracer process.\nWhen you build a container runtime that uses ptrace for enforcement, you need to understand which PID namespace your `waitpid(-1)` operates in. Events from processes in nested PID namespaces still arrive with their host PID, not their namespace-local PID. The `/proc/PID/status` file shows both `Pid:` (host PID) and `NSpid:` (namespace-local PIDs) â€” relevant if you're building tooling that needs to correlate traces across namespace boundaries.\n### 3. Race Conditions in Tracing â€” The TOCTOU Window\nBefore `PTRACE_O_TRACEFORK` existed, the only way to trace fork children was:\n1. Receive fork exit event (child PID in rax).\n2. Call `PTRACE_ATTACH(child_pid)`.\n3. `waitpid(child_pid)` for the SIGSTOP.\nSteps 1â†’2 involve a window. The child process is running. It might:\n- Open a file your policy forbids\n- Spawn its own children (which are also untraced)\n- Complete entirely and exit\nThis is a Time-of-Check-to-Time-of-Use (TOCTOU) race. The \"check\" (learning the child PID) is temporally separated from the \"use\" (attaching). In security contexts, an adversarial program can deliberately exploit this window â€” calling fork, doing the forbidden thing in the child immediately, and exiting before the tracer attaches.\n`PTRACE_O_TRACEFORK` eliminates this by making the attachment happen *inside the kernel, inside the fork syscall handler*. The child is placed into a stopped state before it is ever scheduled. There is no window. The attachment and the fork are atomic with respect to the child's execution. This is the correct pattern for secure tracing: **push the attachment into the kernel where it's atomic**, rather than doing it from userspace where races exist.\nThis principle â€” pushing critical operations into the kernel to eliminate races â€” generalizes. `signalfd()` eliminates the signal/accept race. `epoll()` with edge triggering eliminates the epoll/read race. `O_CREAT|O_EXCL` eliminates the exists/create race. Atomicity at the kernel boundary is the pattern.\n### 4. Hash Map Design at the System Level\nYour per-PID state hash map is a microcosm of a general systems programming problem: **fast lookup keyed by process ID for a hot-path operation**. Let's compare how production systems solve this:\nThe Linux kernel itself uses a hash table for its process table (`struct pid_hash`). It uses a hash of the PID value, with chaining for collision resolution. The key operations are `find_task_by_vpid()` and `find_task_by_pid_ns()` â€” called thousands of times per second on a busy system. The kernel's hash is sized to approximately the square root of `pid_max`, giving O(1) average lookup even with many processes.\nReal strace uses a simpler structure: a sorted array of `struct tcb` (traced control block) pointers, binary-searched by PID. With fewer than ~100 traced processes (typical), binary search over a sorted 100-element array is cache-friendly and fast. The `struct tcb` in strace is large (~500 bytes) and lives in a flat array â€” no pointer chasing, good locality.\nFor your implementation, the flat open-addressing table with 256 slots is optimal for the common case (< 50 traced processes). If you need to handle 1000+ simultaneously traced processes (tracing a large build system, for example), consider increasing the table size or switching to chaining.\n### 5. exec and Address Space Replacement â€” Why Pointers Die\n`exec()` is the most radical operation in Unix process management. The kernel discards the old address space and installs a new one in a single atomic operation from the process's perspective. For your tracer, this creates a fundamental discontinuity: any memory address you read from the tracee before exec is now meaningless.\nThis is the same concept that makes certain security vulnerabilities dangerous. Return-oriented programming (ROP) attacks chain together existing code fragments (\"gadgets\") in the target process's memory. If the target calls `exec()`, all those gadgets are gone â€” the ROP chain is broken. Address Space Layout Randomization (ASLR) randomizes where libraries and stack are placed on every exec, making it impossible to predict gadget addresses across exec boundaries.\nFor database engines that implement process-based connection isolation (PostgreSQL's `postmaster`/`backend` model), exec after fork is how each connection gets a clean state. The postmaster forks a child, which optionally execs a fresh backend binary. The backend has a fresh address space with no inherited heap fragments, memory leaks, or leftover state from other connections.\nYour `PTRACE_EVENT_EXEC` handler â€” clearing cached state when exec fires â€” is the minimal correct response to this reality. The next time you build anything that persists state across exec boundaries (a container runtime, a process supervisor, a debugging framework), you'll know exactly which state survives exec (PID, file descriptors without O_CLOEXEC, certain kernel state) and which does not (everything in the address space).\n---\n## Summary: What You've Built\nYour tracer now:\n- Sets `PTRACE_O_TRACEFORK`, `PTRACE_O_TRACEVFORK`, `PTRACE_O_TRACECLONE`, and `PTRACE_O_TRACEEXEC` options so the kernel atomically attaches to every child process, with no race window\n- Uses `waitpid(-1)` to receive events from *any* traced process, with the returned PID identifying which process stopped\n- Decodes the `status >> 16` bits to distinguish fork, exec, and other ptrace event stops from normal syscall stops\n- Calls `PTRACE_GETEVENTMSG` on fork events to retrieve the new child PID, inserts it into the per-PID state map, and starts the child tracing with an initial `PTRACE_SYSCALL`\n- Maintains a hash map (open addressing, 256 slots) of `ProcessState` structs keyed by PID, each holding the entry/exit toggle and the saved entry register snapshot\n- Tags every output line with `[pid NNNN]` to identify which process made each syscall\n- Resets per-PID cached state (toggle, entry_regs) when `PTRACE_EVENT_EXEC` fires, because the address space has been entirely replaced\n- Tracks an `active_count` and exits the main loop when all traced processes have exited\nMilestone 4 will add the final layer: syscall filtering by name (`-e trace=open,read`), wall-clock timing with `CLOCK_MONOTONIC`, summary statistics tables, file output redirection, and `PTRACE_ATTACH` for tracing already-running processes.\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: build-strace-m4 -->\n# Milestone 4: Filtering and Statistics\n## Where You Are Now\nYour Milestone 3 tracer follows entire process trees, producing beautifully tagged output across every forked child and exec'd program:\n```\n[pid 12345] execve(\"/bin/bash\", [\"/bin/bash\", \"-c\", \"make -j4\"], ...) = 0\n[pid 12345] clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|SIGCHLD) = 12346\n[pid 12346] execve(\"/usr/bin/gcc\", [\"/usr/bin/gcc\", \"-O2\", \"main.c\", \"-o\", \"main\"], ...) = 0\n[pid 12346] openat(AT_FDCWD, \"/usr/include/stdio.h\", O_RDONLY|O_CLOEXEC) = 3\n[pid 12346] read(3, \"...\", 4096) = 4096\n... (thousands more lines) ...\n[pid 12345] +++ exited with 0 +++\n```\nThis works. But it has two practical problems that you'll hit immediately when using it on real workloads.\n**First**: volume. Running `make -j4` on a moderate codebase generates tens of thousands of syscall lines. You're debugging a file-not-found error â€” you care about `openat` calls, not the thousands of `mmap`, `brk`, and `futex` calls surrounding them. You need to filter.\n**Second**: insight. After your trace runs, you want to know: which syscall took the most time? Which one failed most often? Is this program spending 80% of its time in `read` or `write`? The raw trace is a log â€” what you need is a *summary*. Real strace's `-c` flag prints exactly this, and it's one of the most useful diagnostics tools in production systems work.\nBy the end of this milestone, your tracer will support:\n```bash\n./strace_clone -e trace=openat,read,write -o trace.log ./target_program\n./strace_clone -c ./target_program          # summary mode: count + time per syscall\n./strace_clone -p 8492                     # attach to running process\n```\nAnd produce, on exit, a summary like:\n```\n% time     seconds  usecs/call     calls    errors  syscall\n------ ----------- ----------- --------- --------- ----------------\n 64.32    0.031423          12      2619         0  read\n 21.17    0.010342          41       252         3  openat\n 10.44    0.005103           4      1277         0  write\n  4.07    0.001989          88        22        18  connect\n  ...\n------ ----------- ----------- --------- --------- ----------------\n100.00    0.048857                  4170        21  total\n```\nThere are two deceptions hiding in this milestone â€” one about time, one about attachment â€” that almost every first implementation gets wrong. Let's find them.\n\n![Syscall Timing: What You're Actually Measuring](./diagrams/diag-m4-timing-overhead.svg)\n\n---\n## The Core Revelation: You're Not Timing the Syscall\nHere is what seems obvious: call `clock_gettime()` when you receive the entry stop, call it again when you receive the exit stop, subtract. The difference is how long the syscall took.\nThis feels exactly right. Entry stop = syscall starts. Exit stop = syscall ends. Delta = syscall duration.\n**It's wrong.** Not wrong in a subtle, edge-case way â€” wrong in a fundamental way that makes your measurements 10x to 100x too large for fast syscalls.\nThink through what actually happens between your entry `clock_gettime()` and your exit `clock_gettime()`:\n1. The kernel delivers the entry stop. Your tracer's `waitpid` returns.\n2. **Your tracer calls `clock_gettime()` â€” entry timestamp recorded.**\n3. Your tracer calls `PTRACE_GETREGS` (one syscall into the kernel).\n4. Your tracer formats and prints the line (string operations, `fprintf`).\n5. Your tracer calls `ptrace(PTRACE_SYSCALL, ...)` to resume the tracee (another syscall).\n6. The kernel schedules the tracee. The tracee runs until the next syscall boundary.\n7. The tracee actually executes the syscall (say, `getpid` â€” about 100 nanoseconds).\n8. The kernel stops the tracee at the exit boundary. The tracer's `waitpid` returns.\n9. Your tracer calls `PTRACE_GETREGS` again (another syscall into the kernel).\n10. **Your tracer calls `clock_gettime()` â€” exit timestamp recorded.**\nThe delta between steps 2 and 10 includes: `PTRACE_GETREGS`, formatting, `fprintf`, `PTRACE_SYSCALL`, kernel scheduling, the actual syscall, another kernel wake-up, another `PTRACE_GETREGS`. That's easily 10â€“50 microseconds of overhead wrapping a `getpid` call that takes ~100 nanoseconds.\nYour measurement: 10â€“50Âµs. Actual syscall: 0.1Âµs. **Error factor: 100â€“500Ã—.**\n> **What you're actually measuring**: wall-clock time from \"tracer noticed entry\" to \"tracer noticed exit\" â€” which is dominated by ptrace overhead, not by the syscall itself.\nReal strace knows this and says so. Look at the bottom of its `-c` output:\n```\n% time     seconds  usecs/call  ...\n```\nIt says \"seconds,\" not \"CPU time.\" In `strace(1)` man page: *\"the values in 'seconds' column may be much larger than actual time spent executing system calls since the wall-clock time includes the time spent waiting for the tracer to handle events.\"*\nThis isn't a bug in your implementation â€” it's an inherent property of the ptrace observation model. The act of observing adds overhead. Your summary table is still *useful*: relative percentages tell you which syscalls dominate *even accounting for overhead*, and call counts are always accurate. Just don't mistake your timing for true syscall latency.\nThe lesson: **build the timing correctly, understand what it measures, and communicate it honestly in your output.**\nNow, the second deception: which clock to use.\n### CLOCK_MONOTONIC vs CLOCK_REALTIME\n`clock_gettime()` accepts a clock ID that selects which clock source to read. Two are relevant here:\n**`CLOCK_REALTIME`** â€” The system's wall clock. This matches what you'd see on a clock on the wall. It can be adjusted: Network Time Protocol (NTP) can step the clock forward or backward to synchronize it with time servers. If NTP steps the clock backward by 100ms between your entry and exit timestamps, you get a negative duration. If NTP steps it forward, you get an inflated duration. Real-time adjustments happen routinely on any server running `ntpd` or `chronyd`.\n**`CLOCK_MONOTONIC`** â€” A clock that only ever goes forward, monotonically. It has no epoch (it doesn't represent \"time since 1970\") â€” it's just a counter that increases at a stable rate. NTP cannot adjust it backward. It may be slewed (gradually sped up or slowed down) to stay close to real time, but it never jumps. For measuring durations, this is the correct choice.\n```c\nstruct timespec ts;\nclock_gettime(CLOCK_MONOTONIC, &ts);\n/* ts.tv_sec is seconds, ts.tv_nsec is nanoseconds [0, 999999999] */\n```\nTo compute a duration in nanoseconds:\n```c\n/* Compute elapsed nanoseconds between two timespec values */\nstatic long long timespec_diff_ns(const struct timespec *start,\n                                  const struct timespec *end)\n{\n    return (long long)(end->tv_sec  - start->tv_sec)  * 1000000000LL\n         + (long long)(end->tv_nsec - start->tv_nsec);\n}\n```\n**Always use `CLOCK_MONOTONIC` for measuring durations between two events. Always use `CLOCK_REALTIME` only when you need the actual calendar time.**\n---\n## Extending Per-PID State for Timing\nTo record timing, you need to store the entry timestamp alongside the entry registers in your per-PID state struct. Add a `timespec` field:\n```c\n#include <time.h>\ntypedef struct {\n    pid_t                   pid;\n    int                     in_syscall;\n    struct user_regs_struct entry_regs;\n    struct timespec         entry_time;   /* CLOCK_MONOTONIC timestamp at entry */\n    int                     valid;\n} ProcessState;\n```\nMemory layout update (from Milestone 3's 232-byte struct):\n| Field | Type | Size | Offset |\n|-------|------|------|--------|\n| `pid` | `pid_t` (int) | 4 bytes | 0 |\n| `in_syscall` | `int` | 4 bytes | 4 |\n| `entry_regs` | `struct user_regs_struct` | 216 bytes | 8 |\n| `entry_time` | `struct timespec` | 16 bytes | 224 |\n| `valid` | `int` | 4 bytes | 240 |\n| (padding) | â€” | 4 bytes | 244 |\n| **Total** | | **248 bytes** | |\nOn entry stop, record the timestamp immediately after `PTRACE_GETREGS` returns:\n```c\nif (state->in_syscall == 0) {\n    /* Entry stop */\n    state->entry_regs = regs;\n    clock_gettime(CLOCK_MONOTONIC, &state->entry_time);\n    state->in_syscall = 1;\n}\n```\nOn exit stop, compute the duration and pass it to the statistics accumulator:\n```c\n} else {\n    /* Exit stop */\n    struct timespec exit_time;\n    clock_gettime(CLOCK_MONOTONIC, &exit_time);\n    long long elapsed_ns = timespec_diff_ns(&state->entry_time, &exit_time);\n    long syscall_num = (long)state->entry_regs.orig_rax;\n    long return_val  = (long)regs.rax;\n    int  is_error    = (return_val >= -4096L && return_val <= -1L);\n    stats_record(syscall_num, elapsed_ns, is_error);\n    print_syscall(stopped_pid, /*show_pid=*/1, &state->entry_regs, return_val);\n    state->in_syscall = 0;\n}\n```\n---\n## Building the Statistics Accumulator\nThe statistics table needs to track, per syscall number:\n- Total call count\n- Error count\n- Cumulative time (nanoseconds)\nAt the end of the trace, you sort by cumulative time descending and print the table.\n{{DIAGRAM:diag-m4-statistics-table}}\nDefine the accumulator structure:\n```c\n#define MAX_SYSCALL_NUM 335\ntypedef struct {\n    long long total_ns;    /* Cumulative nanoseconds (measured, overhead-inclusive) */\n    long      call_count;  /* Total invocations */\n    long      error_count; /* Invocations that returned error ([-4096, -1]) */\n} SyscallStats;\nstatic SyscallStats stats[MAX_SYSCALL_NUM + 1];\nvoid stats_init(void) {\n    memset(stats, 0, sizeof(stats));\n}\nvoid stats_record(long syscall_num, long long elapsed_ns, int is_error) {\n    if (syscall_num < 0 || syscall_num > MAX_SYSCALL_NUM) return;\n    stats[syscall_num].total_ns   += elapsed_ns;\n    stats[syscall_num].call_count++;\n    if (is_error) stats[syscall_num].error_count++;\n}\n```\nThe accumulator is an array indexed by syscall number â€” O(1) update per syscall, no allocation, perfect cache behavior. The entire array is `336 Ã— (8 + 8 + 8) = 8,064 bytes` â€” fits in L1 cache (typically 32 KB). Every `stats_record` call touches exactly one 64-byte cache line within this array (the `SyscallStats` for that syscall number), and the hot syscalls stay permanently warm.\n### Printing the Summary Table\nWhen tracing ends, sort by `total_ns` descending and print. Because you're sorting a fixed-size array of 336 elements, even an O(nÂ²) sort is instantaneous. Use `qsort` with a custom comparator on an index array:\n```c\nvoid stats_print(FILE *out) {\n    /* Build index array of syscalls that had at least one call */\n    int indices[MAX_SYSCALL_NUM + 1];\n    int count = 0;\n    long long grand_total_ns = 0;\n    long grand_calls = 0;\n    long grand_errors = 0;\n    for (int i = 0; i <= MAX_SYSCALL_NUM; i++) {\n        if (stats[i].call_count > 0) {\n            indices[count++] = i;\n            grand_total_ns += stats[i].total_ns;\n            grand_calls    += stats[i].call_count;\n            grand_errors   += stats[i].error_count;\n        }\n    }\n    /* Sort by total_ns descending using qsort with a comparator */\n    /* comparator captures stats[] via global â€” acceptable here */\n    qsort(indices, count, sizeof(int), compare_by_total_ns);\n    /* Print header */\n    fprintf(out, \"%% time     seconds  usecs/call     calls    errors  syscall\\n\");\n    fprintf(out, \"------ ----------- ----------- --------- --------- ----------------\\n\");\n    /* Print each row */\n    for (int i = 0; i < count; i++) {\n        int n = indices[i];\n        double pct      = (grand_total_ns > 0)\n                          ? 100.0 * stats[n].total_ns / grand_total_ns\n                          : 0.0;\n        double secs     = stats[n].total_ns / 1e9;\n        long   usecs_pc = (stats[n].call_count > 0)\n                          ? (long)(stats[n].total_ns / 1000 / stats[n].call_count)\n                          : 0;\n        fprintf(out, \"%6.2f %11.6f %11ld %9ld %9ld  %s\\n\",\n                pct, secs, usecs_pc,\n                stats[n].call_count, stats[n].error_count,\n                syscall_name((long)n));\n    }\n    /* Print footer */\n    fprintf(out, \"------ ----------- ----------- --------- --------- ----------------\\n\");\n    fprintf(out, \"100.00 %11.6f           %9ld %9ld  total\\n\",\n            grand_total_ns / 1e9, grand_calls, grand_errors);\n}\n/* qsort comparator: sort indices by total_ns descending */\nstatic int compare_by_total_ns(const void *a, const void *b) {\n    int ia = *(const int *)a;\n    int ib = *(const int *)b;\n    if (stats[ib].total_ns > stats[ia].total_ns) return  1;\n    if (stats[ib].total_ns < stats[ia].total_ns) return -1;\n    return 0;\n}\n```\nNote that the summary is printed to `stderr` by default (or to the `-o` file if specified â€” we'll set that up shortly). When you print the normal trace output to `stderr` and the summary also to `stderr`, you can redirect them independently.\n---\n## Syscall Filtering with -e trace=\nThe `-e trace=` flag tells your tracer which syscalls to *print*. Crucially, you still trace everything (all syscalls still trigger stops, the toggle still fires, statistics still accumulate) â€” you just skip the print step for syscalls not in the filter set.\n\n![Syscall Filter: Trace Everything, Print Selectively](./diagrams/diag-m4-filter-architecture.svg)\n\nThis distinction matters enormously. If you tried to *not trace* certain syscalls, you'd need to implement selective PTRACE_SYSCALL behavior, which doesn't exist at the ptrace API level â€” ptrace gives you all-or-nothing interception. More importantly, even if you skip printing `mmap`, you still need to count it for the statistics table. The filter is purely a *display* filter, not a tracing filter.\n### Parsing the Filter String\nThe flag syntax is `-e trace=open,read,write`. Parse it at startup:\n```c\n#define MAX_FILTER_SYSCALLS 64\ntypedef struct {\n    int     enabled;                          /* 1 if filter is active */\n    int     count;                            /* Number of names in filter */\n    char    names[MAX_FILTER_SYSCALLS][32];   /* Syscall names to show */\n    int     nums[MAX_FILTER_SYSCALLS];        /* Corresponding syscall numbers (-1 if unknown) */\n} SyscallFilter;\nstatic SyscallFilter filter = { .enabled = 0 };\n/* Parse \"-e trace=open,read,write\" into the filter struct.\n * 'spec' points to the string after \"trace=\" */\nvoid filter_parse(const char *spec) {\n    filter.enabled = 1;\n    filter.count   = 0;\n    char buf[256];\n    strncpy(buf, spec, sizeof(buf) - 1);\n    buf[sizeof(buf) - 1] = '\\0';\n    char *tok = strtok(buf, \",\");\n    while (tok != NULL && filter.count < MAX_FILTER_SYSCALLS) {\n        strncpy(filter.names[filter.count], tok, 31);\n        filter.names[filter.count][31] = '\\0';\n        /* Try to resolve name to number at parse time for O(1) lookup */\n        filter.nums[filter.count] = syscall_num_by_name(tok);\n        filter.count++;\n        tok = strtok(NULL, \",\");\n    }\n}\n/* Returns 1 if syscall_num passes the filter (should be printed), 0 if not */\nint filter_passes(long syscall_num) {\n    if (!filter.enabled) return 1;  /* No filter: print everything */\n    for (int i = 0; i < filter.count; i++) {\n        if (filter.nums[i] == (int)syscall_num) return 1;\n    }\n    return 0;\n}\n```\n`syscall_num_by_name()` requires a reverse lookup: name â†’ number. The simplest implementation is a linear scan of your `syscall_names[]` array from Milestone 2:\n```c\nint syscall_num_by_name(const char *name) {\n    for (int i = 0; i <= MAX_SYSCALL_NUM; i++) {\n        if (syscall_names[i] != NULL && strcmp(syscall_names[i], name) == 0) {\n            return i;\n        }\n    }\n    return -1;  /* Unknown name */\n}\n```\nThis is O(n) and runs once at startup â€” completely acceptable. If an unknown name is given, `filter.nums[i] = -1`, which will never match a real syscall number (syscall numbers are â‰¥ 0), so the filter silently ignores unrecognized names. You could warn the user; real strace does.\n### Applying the Filter\nIn `print_syscall()`, add the filter check before formatting output:\n```c\nvoid print_syscall(pid_t pid, int show_pid,\n                   struct user_regs_struct *entry_regs,\n                   long return_val,\n                   FILE *out)\n{\n    long syscall_num = (long)entry_regs->orig_rax;\n    /* Filter check: only print if this syscall passes the display filter */\n    if (!filter_passes(syscall_num)) return;\n    /* ... rest of formatting ... */\n}\n```\nNote: `stats_record()` is called *before* `print_syscall()` in the exit handler, so statistics always accumulate regardless of the filter. The filter only gates printing.\n---\n## File Output with -o\nThe `-o filename` flag redirects trace output from `stderr` to a file. The design decision here is how to handle the file handle throughout the codebase.\nThe cleanest approach: a global `FILE *trace_out` that defaults to `stderr` and is set to the opened file if `-o` is given. Every print call uses `trace_out` instead of `stderr`.\n```c\nstatic FILE *trace_out = NULL;  /* Set in main() */\nvoid tracer_init_output(const char *filename) {\n    if (filename != NULL) {\n        trace_out = fopen(filename, \"w\");\n        if (trace_out == NULL) {\n            perror(\"fopen output file\");\n            exit(1);\n        }\n    } else {\n        trace_out = stderr;\n    }\n}\n```\nFor multi-process traces, multiple processes may have syscalls completing in the same `waitpid` batch. Since you process one event at a time (your loop is single-threaded), there's no concurrent write issue â€” each `fprintf(trace_out, ...)` call is fully sequential. If you were using threads, you'd need a mutex around writes. With your single-threaded event loop, the sequential guarantee is free.\nClean up on exit:\n```c\nvoid tracer_close_output(void) {\n    if (trace_out != NULL && trace_out != stderr) {\n        fclose(trace_out);\n    }\n}\n```\nThe summary table (`stats_print`) should write to the same `trace_out` file if `-o` is active. If no `-o` flag is used, write the summary to `stderr` (so it appears in the terminal even when the trace is piped elsewhere).\n---\n## Command-Line Argument Parsing\nNow that you have `-e`, `-o`, `-p`, and `-c` flags, you need structured argument parsing. `getopt()` is the POSIX standard:\n```c\n#include <getopt.h>\ntypedef struct {\n    const char *output_file;    /* -o filename, or NULL */\n    const char *filter_spec;    /* -e trace=..., or NULL */\n    pid_t       attach_pid;     /* -p PID, or 0 */\n    int         summary_mode;   /* -c flag */\n    /* argv for the program to run (after options), or NULL if -p */\n    char      **target_argv;\n} TracerOptions;\nTracerOptions parse_options(int argc, char *argv[]) {\n    TracerOptions opts = { NULL, NULL, 0, 0, NULL };\n    int opt;\n    while ((opt = getopt(argc, argv, \"o:e:p:c\")) != -1) {\n        switch (opt) {\n        case 'o':\n            opts.output_file = optarg;\n            break;\n        case 'e':\n            /* Expect \"trace=name,name,...\" */\n            if (strncmp(optarg, \"trace=\", 6) == 0) {\n                opts.filter_spec = optarg + 6;\n            } else {\n                fprintf(stderr, \"Unknown -e option: %s\\n\", optarg);\n                exit(1);\n            }\n            break;\n        case 'p':\n            opts.attach_pid = (pid_t)atoi(optarg);\n            if (opts.attach_pid <= 0) {\n                fprintf(stderr, \"Invalid PID: %s\\n\", optarg);\n                exit(1);\n            }\n            break;\n        case 'c':\n            opts.summary_mode = 1;\n            break;\n        default:\n            fprintf(stderr, \"Usage: %s [-o file] [-e trace=...] [-c] \"\n                            \"[-p pid | program [args...]]\\n\", argv[0]);\n            exit(1);\n        }\n    }\n    if (opts.attach_pid == 0) {\n        if (optind >= argc) {\n            fprintf(stderr, \"Need -p PID or a program to run\\n\");\n            exit(1);\n        }\n        opts.target_argv = &argv[optind];\n    }\n    return opts;\n}\n```\n`getopt()` is POSIX-standard and available on any Linux system. `optarg` is a global pointer to the current option's argument. `optind` is the index of the first non-option argument after processing â€” pointing at your target program's `argv`.\n---\n## PTRACE_ATTACH: Tracing a Running Process\nEverything you've built so far assumes you start the tracee yourself: fork, PTRACE_TRACEME, exec. But one of strace's most powerful features is `-p PID`: attach to an *already-running* process without restarting it. This requires a completely different entry point into the ptrace lifecycle.\n\n![PTRACE_ATTACH vs Fork+TRACEME: Two Entry Points](./diagrams/diag-m4-attach-vs-fork.svg)\n\n### How PTRACE_ATTACH Works\n`ptrace(PTRACE_ATTACH, pid, NULL, NULL)` tells the kernel: \"I want to become the tracer for process `pid`.\" The kernel:\n1. Checks that you have permission (you must be the process owner, or have `CAP_SYS_PTRACE` capability).\n2. Sets the `PT_TRACED` flag on the target process's `task_struct`.\n3. **Sends `SIGSTOP` to the target process.** This stops it so you can set up the tracing relationship cleanly.\n4. Returns 0 to your tracer.\nThe `SIGSTOP` is critical â€” and it's also a source of disruption. The target process was running happily; you've now injected a `SIGSTOP` into it. Any signal handlers the target has for `SIGSTOP` will fire. The process is visibly paused. If it was in the middle of a critical section, holding a mutex, or doing time-sensitive I/O, the `SIGSTOP` interrupts that.\nThis is why a newer API exists â€” but let's first implement `PTRACE_ATTACH` correctly, then discuss the alternative.\n```c\nvoid attach_to_process(pid_t pid) {\n    if (ptrace(PTRACE_ATTACH, pid, NULL, NULL) == -1) {\n        perror(\"ptrace PTRACE_ATTACH\");\n        if (errno == EPERM) {\n            fprintf(stderr, \"Permission denied. Try running as root, or:\\n\");\n            fprintf(stderr, \"  echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope\\n\");\n        }\n        exit(1);\n    }\n    /* Wait for the SIGSTOP that PTRACE_ATTACH sends */\n    int status;\n    pid_t stopped = waitpid(pid, &status, 0);\n    if (stopped == -1) {\n        perror(\"waitpid after PTRACE_ATTACH\");\n        exit(1);\n    }\n    if (!WIFSTOPPED(status)) {\n        fprintf(stderr, \"Process %d did not stop after PTRACE_ATTACH\\n\", pid);\n        exit(1);\n    }\n    /* The stop signal should be SIGSTOP (or occasionally SIGTRAP).\n     * Either way, we don't re-inject it â€” it was our attachment signal. */\n    /* Set the same options as in the fork case */\n    long opts = PTRACE_O_TRACESYSGOOD\n               | PTRACE_O_TRACEFORK\n               | PTRACE_O_TRACEVFORK\n               | PTRACE_O_TRACECLONE\n               | PTRACE_O_TRACEEXEC;\n    if (ptrace(PTRACE_SETOPTIONS, pid, NULL, (void *)opts) == -1) {\n        perror(\"ptrace SETOPTIONS after ATTACH\");\n        exit(1);\n    }\n    /* Create state for this PID and start tracing */\n    ProcessState *state = state_map_insert(pid);\n    state->in_syscall = 0;\n    active_count = 1;\n    /* Resume the process â€” it will now be traced */\n    if (ptrace(PTRACE_SYSCALL, pid, NULL, NULL) == -1) {\n        perror(\"ptrace PTRACE_SYSCALL after ATTACH\");\n        exit(1);\n    }\n}\n```\n### The ptrace_scope Permission Wall\nModern Linux kernels restrict which processes can trace which other processes, controlled by `/proc/sys/kernel/yama/ptrace_scope`:\n| Value | Meaning |\n|-------|---------|\n| 0 | Permissive: any process can trace any other process it owns |\n| 1 | Restricted: can only trace children or processes that called `prctl(PR_SET_PTRACER, tracer_pid)` |\n| 2 | Admin-only: only processes with `CAP_SYS_PTRACE` can trace |\n| 3 | Completely disabled |\nMost desktop Linux distributions default to 1. This means `PTRACE_ATTACH` on an arbitrary process will fail with `EPERM` unless you're root or the target has explicitly allowed it. Your code already handles this with the helpful error message. For development, running as root or temporarily setting `ptrace_scope` to 0 is the pragmatic approach.\n### Key Difference from Fork+TRACEME\nWith fork+TRACEME, the tracee starts in a controlled state: it requested tracing, exec'd the target program, and paused at the post-exec SIGTRAP. The toggle starts at 0 (not mid-syscall). The address space is fresh.\nWith PTRACE_ATTACH, the target process might be *anywhere* in its execution: inside a syscall (having executed the `syscall` instruction but not yet returned), between syscalls, in a signal handler. You cannot know. The toggle must conservatively start at 0 (assume you're at an entry boundary), and the first stop after `PTRACE_SYSCALL` will tell you more. If the process was stopped mid-syscall, you'll get an exit stop first â€” which, with toggle at 0, you'd misidentify as an entry stop. This produces one garbage print, then the trace self-corrects. Real strace handles this edge case by checking `orig_rax` on the first stop to determine whether it looks like an entry or exit. For this milestone, the conservative approach (start at 0) is acceptable.\n---\n## Clean Detach: The SIGINT Handler\nWhen your tracer receives `SIGINT` (Ctrl+C), it must not simply `exit()`. If the tracee is ptrace-traced and the tracer exits without detaching, the kernel sends `SIGHUP` to the tracee, which typically kills it. That's not what users expect from \"press Ctrl+C to stop tracing\" â€” they expect the traced process to continue running normally.\nThe correct sequence on tracer exit when using `PTRACE_ATTACH`:\n1. The tracee must be in a **stopped state** for `PTRACE_DETACH` to succeed.\n2. If the tracee is running (between stops), you must send it `SIGSTOP` and wait for it to stop.\n3. Call `ptrace(PTRACE_DETACH, pid, NULL, NULL)`.\n4. The tracee resumes as if it was never traced.\n\n![Clean Detach Sequence on SIGINT](./diagrams/diag-m4-clean-detach.svg)\n\nIf you forked the tracee yourself (not PTRACE_ATTACH mode), the user probably wants to kill it when they Ctrl+C. In that case, you can let the default SIGINT behavior kill both tracer and tracee via the terminal's process group signal delivery.\nThe tricky part: your `SIGINT` handler runs *asynchronously*, while your main loop might be anywhere. Signal safety rules restrict what you can call from a signal handler â€” you cannot call `ptrace()` or `waitpid()` from a signal handler, because they may allocate memory or modify global state in non-reentrant ways.\nThe correct pattern: use a flag and handle detach in the main loop.\n```c\n#include <signal.h>\nstatic volatile sig_atomic_t g_interrupted = 0;\nstatic pid_t g_attached_pid = 0;  /* Set if we used PTRACE_ATTACH */\nstatic void sigint_handler(int sig) {\n    (void)sig;\n    g_interrupted = 1;\n}\nvoid install_sigint_handler(void) {\n    struct sigaction sa;\n    memset(&sa, 0, sizeof(sa));\n    sa.sa_handler = sigint_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;  /* No SA_RESTART: let syscalls (waitpid) be interrupted */\n    sigaction(SIGINT, &sa, NULL);\n}\n```\nIn the main loop, check `g_interrupted` after each `waitpid` return:\n```c\nwhile (active_count > 0) {\n    pid_t stopped_pid = waitpid(-1, &status, 0);\n    if (stopped_pid == -1) {\n        if (errno == EINTR) {\n            /* waitpid was interrupted â€” could be SIGINT */\n            if (g_interrupted) {\n                handle_interrupt();\n                break;\n            }\n            continue;\n        }\n        if (errno == ECHILD) break;\n        perror(\"waitpid\");\n        break;\n    }\n    /* ... normal event handling ... */\n    /* Check interrupt flag between events */\n    if (g_interrupted) {\n        handle_interrupt();\n        break;\n    }\n}\n```\nThe detach sequence, called from the main loop context (safe to call ptrace here):\n```c\nvoid handle_interrupt(void) {\n    if (g_attached_pid != 0) {\n        /* We attached to a running process â€” detach cleanly */\n        /* The process may or may not be stopped right now.\n         * PTRACE_DETACH requires the tracee to be stopped.\n         * Send SIGSTOP and wait for it. */\n        kill(g_attached_pid, SIGSTOP);\n        int status;\n        waitpid(g_attached_pid, &status, 0);\n        /* Detach, allowing the process to continue */\n        ptrace(PTRACE_DETACH, g_attached_pid, NULL, NULL);\n        fprintf(stderr, \"Detached from process %d\\n\", g_attached_pid);\n    } else {\n        /* We forked the tracee â€” let it die naturally or kill it */\n        /* The traced children will be killed when the tracer exits\n         * because they're in the same process group */\n        fprintf(stderr, \"Interrupted\\n\");\n    }\n    /* Print summary if in summary mode */\n    if (summary_mode) {\n        stats_print(stderr);\n    }\n}\n```\n> **Why SA_RESTART is not set**: The `waitpid()` syscall is a blocking wait. When `SIGINT` arrives, the kernel interrupts `waitpid` and returns `-1` with `errno == EINTR`. Without `SA_RESTART`, this interruption surfaces to your code so you can check `g_interrupted`. With `SA_RESTART`, the kernel would automatically restart `waitpid`, and you might not notice the signal for a long time (until the next child event). For responsiveness, you want `EINTR` to propagate.\n---\n## Three-Level View: What PTRACE_DETACH Does\nLet's see detach at all three levels for clarity.\n**Level 1 â€” Application (Tracer)**\nYou call `ptrace(PTRACE_DETACH, pid, NULL, NULL)`. The function returns 0 on success. The target process starts running again.\n**Level 2 â€” Kernel**\nThe kernel's `ptrace_detach()` function:\n1. Clears the `PT_TRACED` flag on the target's `task_struct`.\n2. Sets the target's parent back to its real parent (before you attached, it had been reparented to your tracer for `waitpid` purposes).\n3. Removes the target from your tracer's list of traced children.\n4. Sends `SIGCONT` to the target if it was stopped, waking it up.\n5. Wakes the target's scheduler entry so it can run.\nThe target process resumes as if `ptrace` had never happened. Any pending signals that were suppressed during tracing are delivered. Any partial syscall state is intact.\n**Level 3 â€” Hardware**\nFrom the CPU's perspective, the target process was in `TASK_STOPPED` state â€” its scheduler entry was removed from the run queue. `PTRACE_DETACH` re-adds it to the run queue. The next time the scheduler runs (at the next timer interrupt, or immediately if a CPU is idle), the target's thread is scheduled and its saved `RIP` register picks up execution exactly where it stopped.\nThe `PT_TRACED` flag in the kernel's `task_struct` is what causes the entry/exit stops to fire. Clearing it stops all future tracing overhead. From that moment, the target process runs at full speed with zero ptrace overhead.\n---\n## Hardware Soul: The Observer Effect in Practice\nYour tracer imposes real overhead on the traced process. Let's quantify it.\n**Per-syscall overhead breakdown** (approximate, 3 GHz x86_64):\n- Tracer `waitpid` returns: ~100 cycles (kernel wake-up)\n- `PTRACE_GETREGS`: ~500 cycles (kernel boundary + register copy)\n- `clock_gettime(CLOCK_MONOTONIC)`: ~30 cycles (VDSO fast path)\n- Filter check (`filter_passes`): ~10 cycles\n- `fprintf` to print line (with format + string ops): ~500â€“5,000 cycles\n- `ptrace(PTRACE_SYSCALL, ...)`: ~300 cycles (kernel boundary)\n- Context switch tracer â†’ tracee: ~1,000â€“3,000 cycles\n**Total overhead per traced syscall**: ~3,000â€“10,000 cycles â‰ˆ **1â€“3 microseconds at 3 GHz**.\nFor a syscall like `gettimeofday` (~100 ns = 300 cycles), you're adding 10â€“30Ã— overhead. For `read()` on a local SSD (~50â€“100 Âµs), the overhead is negligible (2%).\n**Cache behavior**: Your `stats[]` array (8 KB) fits entirely in L1 data cache (typically 32 KB). After the first few dozen syscalls, all hot entries are permanently cached. `stats_record()` is essentially:\n- 1 bounds check (branch predicted correctly)\n- 1 L1 cache read + increment + write (Ã—3 fields)\n- Total: ~5â€“10 cycles\n**The observer effect on real programs**: If you trace a lock-contention benchmark (many threads fighting over a mutex), the ptrace overhead between syscall entry and exit extends the critical section window. Threads that would have been in and out of the kernel quickly now spend 10â€“50Ã— longer stopped, allowing more contention. Your trace may show `futex` calls dominating â€” but some of that dominance is *caused by* the tracing itself. The observed system is not the unobserved system. Keep this in mind when interpreting timing results.\n---\n## Complete Main Function: Wiring Everything Together\nHere's how all the new components wire together in `main()`:\n```c\nint main(int argc, char *argv[]) {\n    TracerOptions opts = parse_options(argc, argv);\n    /* Initialize subsystems */\n    state_map_init();\n    stats_init();\n    tracer_init_output(opts.output_file);\n    install_sigint_handler();\n    if (opts.filter_spec != NULL) {\n        filter_parse(opts.filter_spec);\n    }\n    if (opts.attach_pid != 0) {\n        /* Attach to running process */\n        g_attached_pid = opts.attach_pid;\n        attach_to_process(opts.attach_pid);\n        /* active_count set to 1 inside attach_to_process */\n    } else {\n        /* Fork and exec the target program */\n        pid_t child = fork();\n        if (child < 0) { perror(\"fork\"); return 1; }\n        if (child == 0) {\n            ptrace(PTRACE_TRACEME, 0, NULL, NULL);\n            execvp(opts.target_argv[0], opts.target_argv);\n            perror(\"execvp\");\n            exit(1);\n        }\n        /* Catch post-exec SIGTRAP */\n        int status;\n        waitpid(child, &status, 0);\n        if (!WIFSTOPPED(status)) {\n            fprintf(stderr, \"Unexpected initial status\\n\");\n            return 1;\n        }\n        long tracer_opts = PTRACE_O_TRACESYSGOOD\n                         | PTRACE_O_TRACEFORK\n                         | PTRACE_O_TRACEVFORK\n                         | PTRACE_O_TRACECLONE\n                         | PTRACE_O_TRACEEXEC;\n        ptrace(PTRACE_SETOPTIONS, child, NULL, (void *)tracer_opts);\n        ProcessState *init_state = state_map_insert(child);\n        init_state->in_syscall = 0;\n        active_count = 1;\n        ptrace(PTRACE_SYSCALL, child, NULL, NULL);\n    }\n    /* â”€â”€ MAIN TRACING LOOP (same structure as Milestone 3) â”€â”€ */\n    while (active_count > 0) {\n        pid_t stopped_pid = waitpid(-1, &status, 0);\n        if (stopped_pid == -1) {\n            if (errno == EINTR && g_interrupted) { handle_interrupt(); break; }\n            if (errno == ECHILD) break;\n            perror(\"waitpid\"); break;\n        }\n        if (g_interrupted) { handle_interrupt(); break; }\n        if (WIFEXITED(status)) {\n            if (!opts.summary_mode || filter.enabled == 0) {\n                fprintf(trace_out, \"[pid %d] +++ exited with %d +++\\n\",\n                        stopped_pid, WEXITSTATUS(status));\n            }\n            state_map_remove(stopped_pid);\n            active_count--;\n            continue;\n        }\n        if (WIFSIGNALED(status)) {\n            fprintf(trace_out, \"[pid %d] +++ killed by signal %d (%s) +++\\n\",\n                    stopped_pid, WTERMSIG(status), strsignal(WTERMSIG(status)));\n            state_map_remove(stopped_pid);\n            active_count--;\n            continue;\n        }\n        if (!WIFSTOPPED(status)) continue;\n        int sig   = WSTOPSIG(status);\n        int event = (status >> 16) & 0xff;\n        ProcessState *state = state_map_find(stopped_pid);\n        if (state == NULL) {\n            state = state_map_insert(stopped_pid);\n            if (state == NULL) {\n                ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n                continue;\n            }\n            active_count++;\n        }\n        if (event != 0) {\n            handle_ptrace_event(stopped_pid, state, event);\n            ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n            continue;\n        }\n        if (sig == (SIGTRAP | 0x80)) {\n            struct user_regs_struct regs;\n            if (ptrace(PTRACE_GETREGS, stopped_pid, NULL, &regs) == -1) {\n                ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n                continue;\n            }\n            if (state->in_syscall == 0) {\n                /* Entry: save regs + timestamp */\n                state->entry_regs = regs;\n                clock_gettime(CLOCK_MONOTONIC, &state->entry_time);\n                state->in_syscall = 1;\n            } else {\n                /* Exit: compute duration, record stats, maybe print */\n                struct timespec exit_time;\n                clock_gettime(CLOCK_MONOTONIC, &exit_time);\n                long long elapsed_ns = timespec_diff_ns(&state->entry_time,\n                                                        &exit_time);\n                long syscall_num = (long)state->entry_regs.orig_rax;\n                long return_val  = (long)regs.rax;\n                int  is_error    = (return_val >= -4096L && return_val <= -1L);\n                stats_record(syscall_num, elapsed_ns, is_error);\n                if (!opts.summary_mode) {\n                    /* Print the syscall line (filtered inside print_syscall) */\n                    print_syscall(stopped_pid, /*show_pid=*/1,\n                                  &state->entry_regs, return_val, trace_out);\n                }\n                state->in_syscall = 0;\n            }\n            ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n            continue;\n        }\n        if (sig == SIGTRAP) {\n            ptrace(PTRACE_SYSCALL, stopped_pid, NULL, NULL);\n            continue;\n        }\n        /* Signal-delivery stop: re-inject */\n        ptrace(PTRACE_SYSCALL, stopped_pid, NULL, (void *)(long)sig);\n    }\n    /* Print summary if requested */\n    if (opts.summary_mode) {\n        stats_print(stderr);\n    }\n    tracer_close_output();\n    return 0;\n}\n```\n---\n## Common Bugs in This Milestone\n### Bug 1: Timing Across the Print\n```c\n/* WRONG: clock_gettime after fprintf includes I/O time in the measurement */\nif (state->in_syscall == 0) {\n    clock_gettime(CLOCK_MONOTONIC, &state->entry_time);\n    /* ... save regs ... */\n    fprintf(trace_out, \"entering syscall...\\n\");   /* 500â€“5000 cycles of I/O */\n    state->in_syscall = 1;\n}\n```\nIf you print at entry, the I/O time is included between entry and exit timestamps, making the timing wildly inaccurate. Take the `clock_gettime` immediately after `PTRACE_GETREGS`, before any I/O. Similarly, take the exit `clock_gettime` immediately â€” before printing.\n### Bug 2: CLOCK_REALTIME for Duration\n```c\n/* WRONG: REALTIME can go backwards */\nclock_gettime(CLOCK_REALTIME, &state->entry_time);\n```\nIf NTP slews or steps the clock between entry and exit, you get a negative `elapsed_ns`. Then you add it to `stats[n].total_ns`, producing a cumulative time that decreases. The summary table shows negative seconds for that syscall. Use `CLOCK_MONOTONIC`.\n### Bug 3: Forgetting to Wait for SIGSTOP After PTRACE_ATTACH\n```c\n/* WRONG: skip the waitpid after PTRACE_ATTACH */\nptrace(PTRACE_ATTACH, pid, NULL, NULL);\nptrace(PTRACE_SETOPTIONS, pid, NULL, opts);  /* ESRCH or EIO: process not yet stopped */\n```\n`PTRACE_ATTACH` is asynchronous â€” the kernel sends `SIGSTOP` to the target, but that signal may not have been delivered and processed by the time your next `ptrace` call runs. You must `waitpid(pid, ...)` to confirm the process has stopped before calling any other ptrace request on it.\n### Bug 4: Not Filtering But Still Suppressing Stats\n```c\n/* WRONG: returning early before stats_record */\nvoid handle_exit_stop(pid_t pid, ProcessState *state,\n                      struct user_regs_struct *regs) {\n    long syscall_num = (long)state->entry_regs.orig_rax;\n    if (!filter_passes(syscall_num)) return;  /* â† Skips stats! */\n    long return_val = (long)regs->rax;\n    stats_record(syscall_num, elapsed_ns, is_error);\n    print_syscall(pid, 1, &state->entry_regs, return_val, trace_out);\n}\n```\nThe filter controls *printing*, not *recording*. Call `stats_record` unconditionally, then conditionally print.\n### Bug 5: PTRACE_DETACH Without Stopping the Tracee First\n```c\n/* WRONG: detaching from a running tracee */\nptrace(PTRACE_DETACH, pid, NULL, NULL);  /* May return EIO or corrupt state */\n```\n`PTRACE_DETACH` requires the tracee to be in a ptrace stop. If the tracee is running (between stops), `PTRACE_DETACH` fails with `EIO`. You must stop the process first (send `SIGSTOP`, then `waitpid`) before detaching.\n### Bug 6: O_RDONLY = 0 in Stats vs. \"Not Called\"\nThe `stats[]` array is zero-initialized. `stats[n].call_count == 0` means \"never called.\" But your accumulation uses `stats[n].total_ns += elapsed_ns` â€” what if `elapsed_ns` is 0? That's fine, it's still a valid count. The danger is if you mistakenly print entries with `call_count == 0` in the summary. The filter `if (stats[i].call_count > 0)` before adding to the print index prevents this.\n---\n## Testing Your Complete Tracer\nBuild and test progressively:\n```bash\n# Basic filtering: only show file operations\n./strace_clone -e trace=openat,read,write,close /bin/ls /tmp\n# Count mode: summary statistics only\n./strace_clone -c /bin/ls /tmp\n# Output to file: trace goes to trace.log, summary to stderr\n./strace_clone -c -o trace.log /bin/ls /tmp\n# Attach to a running process (find a long-running process first)\nsleep 60 &\n./strace_clone -p $!\n# Attach and filter: only network syscalls on a running server\n./strace_clone -p $(pgrep nginx | head -1) -e trace=accept,read,write,close\n# Filter + count: who's calling mmap most?\n./strace_clone -c -e trace=mmap,munmap,brk /bin/python3 -c \"import numpy\"\n```\nExpected summary output for a simple `ls /tmp`:\n```\n% time     seconds  usecs/call     calls    errors  syscall\n------ ----------- ----------- --------- --------- ----------------\n 42.18    0.001853         231         8         0  read\n 28.44    0.001249         178         7         0  mmap\n 15.21    0.000668         111         6         0  openat\n  8.02    0.000352          58         6         0  close\n  3.11    0.000136          17         8         0  fstat\n  2.14    0.000094          31         3         3  access\n  0.90    0.000039          19         2         0  getdents64\n...\n------ ----------- ----------- --------- --------- ----------------\n100.00    0.004391                    74         3  total\n```\n---\n## Knowledge Cascade: What This Unlocks\n### 1. perf and eBPF â€” Moving Beyond ptrace's Overhead\nThe fundamental problem with ptrace-based profiling is the cost you've now measured: thousands of cycles per intercepted syscall. For profiling, this is unacceptable â€” the overhead changes the program's behavior.\nModern Linux solved this with eBPF (extended Berkeley Packet Filter). An eBPF program is a small, JIT-compiled bytecode program that runs *inside the kernel* â€” attached directly to a syscall tracepoint, kprobe, or perf event. When the attached event fires, the eBPF program runs in-kernel, records timing data into a shared map structure, and returns. The profiling data accumulates in kernel memory; your userspace tool reads it periodically.\nThe critical difference: **no context switch per event**. The eBPF program runs in the same kernel context as the syscall itself. For a `getpid` call, the overhead is a few dozen nanoseconds â€” not microseconds. `bpftrace -e 'tracepoint:syscalls:sys_enter_openat { @[comm] = count(); }'` counts `openat` calls by process name with essentially zero impact on the traced system.\nThis is why production performance engineering has moved from `strace` to `bpftrace`/`bcc`/`perf` for high-frequency measurement. Your tracer is the right tool for *correctness debugging* (what exactly did this program call?). For *performance profiling* (how often, how long?), eBPF gives you accurate data at production fidelity.\n### 2. PTRACE_SEIZE â€” The Evolution of Attachment\nYou used `PTRACE_ATTACH`, which sends `SIGSTOP` to the target. Linux 3.4 introduced `PTRACE_SEIZE` as a cleaner alternative:\n```c\nptrace(PTRACE_SEIZE, pid, NULL, opts);\n```\n`PTRACE_SEIZE` attaches without sending `SIGSTOP`. The process continues running normally. Instead, you receive a notification at the next natural stop (syscall boundary, signal delivery, etc.). This is much less disruptive â€” the target doesn't experience an unexpected pause, signal handlers don't fire for `SIGSTOP`, and time-sensitive code doesn't get disrupted.\nWith `PTRACE_SEIZE`, you use `PTRACE_INTERRUPT` (instead of `SIGSTOP`) when you want to force the target to stop:\n```c\nptrace(PTRACE_INTERRUPT, pid, NULL, NULL);\n```\nAnd `PTRACE_LISTEN` replaces `PTRACE_CONT` for passively waiting for the next stop. The attach-then-detach workflow is much cleaner and safer.\nReal strace uses `PTRACE_SEIZE` since version 4.9 (2013). The `PTRACE_ATTACH` path remains for compatibility with older kernels. The evolution from `PTRACE_ATTACH` to `PTRACE_SEIZE` reflects a general principle in Linux API design: when the original API has unavoidable side effects (the `SIGSTOP`), a new API is introduced that achieves the same goal without the disruption.\n### 3. The Observer Effect â€” Profiling as a Physics Problem\nYour tracer slows the traced program by 10â€“100Ã—. This is the observer effect in systems programming: the measurement apparatus changes what it measures.\nThis isn't unique to ptrace. Every instrumentation technique has a cost:\n| Technique | Overhead per event | Production-safe? |\n|-----------|-------------------|-----------------|\n| ptrace (your tracer) | ~2â€“10 Âµs | No |\n| `strace -c` | ~1â€“5 Âµs | No |\n| eBPF tracepoint | ~50â€“200 ns | Yes (low frequency) |\n| Linux perf (sampling) | < 5 Âµs per sample | Yes |\n| Hardware PMU counters | ~1 ns | Yes |\nSampling profilers (like `perf record`) sidestep the problem: instead of intercepting every event, they use a timer interrupt to sample the program counter every N milliseconds. The overhead is proportional to *sample rate*, not event rate. A program making 1,000,000 syscalls/second with a 1ms sample interval gives you ~1000 samples â€” 1000 interrupts, not 1,000,000. The cost is roughly 0.1% instead of 100Ã—.\nThe observer effect is especially severe for concurrent programs. Lock contention benchmarks are profoundly affected by tracing: if thread A is inside a 500ns critical section and your tracer adds 5Âµs of overhead, thread B waiting for the lock experiences an apparent 10Ã— increase in contention. The trace shows \"lots of `futex` time\" â€” but the futex time is *caused by the trace*. This is why production performance investigation uses sampling or eBPF, not ptrace.\n### 4. Statistical Aggregation â€” The Pattern Behind Monitoring Systems\nThe `SyscallStats` accumulator you built is the simplest form of a *streaming aggregation* pattern:\n- **Prometheus** (CNCF metrics) maintains exactly this structure: a counter per label combination, incremented on each event, queried periodically.\n- **statsd** (Etsy, now industry standard) accumulates counts and timings in-memory, then flushes aggregates to a time-series database every 10 seconds.\n- **Kernel perf events** use ring buffers and mmap'd memory to give userspace programs running totals without system calls.\nThe design choice you made â€” `total_ns += elapsed_ns` per syscall â€” is exactly how Prometheus's `histogram_observe` works for timing data. The \"sorted by cumulative time\" output is how `perf report` ranks hot functions. The percentage calculation (`total_ns / grand_total_ns Ã— 100`) is how profilers identify bottlenecks.\nThe difference between your accumulator and a production monitoring system is primarily the *output path*. Your system prints at the end. Prometheus exposes an HTTP endpoint. statsd sends UDP packets. But the core â€” iterate events, increment counters, accumulate totals â€” is identical.\n### 5. Signal Safety and the SIGINT Handler Pattern\nYour `g_interrupted = 1` signal handler pattern is the canonical solution to a fundamental problem in Unix systems programming: signal handlers run asynchronously, interrupting the main thread at any point, but most interesting operations (`ptrace`, `waitpid`, `malloc`) are not *async-signal-safe* â€” they may be in the middle of modifying shared state when the signal arrives.\nThe POSIX specification defines a small set of async-signal-safe functions you can call from signal handlers (see `signal-safety(7)`): `write()`, `_exit()`, `kill()`, `sigprocmask()`, and about 70 others. Notably absent: `printf`, `malloc`, `ptrace`, `waitpid`.\nThe safe pattern: signal handler sets a flag (`volatile sig_atomic_t`), main loop checks the flag after each blocking operation. The main loop can then safely call whatever it needs, because it's not inside a signal handler.\nThis pattern generalizes everywhere:\n- Database systems use it for `SIGTERM` shutdown (flush WAL, checkpoint, close files)\n- Web servers use it for graceful reload (`SIGHUP` â†’ set flag â†’ drain connections â†’ reload config)\n- Container runtimes use it for clean pod termination (`SIGTERM` â†’ flag â†’ stop all traced processes â†’ report)\nYour SIGINT handler is a microcosm of production-quality signal handling. The `SA_RESTART` decision (not set, so `waitpid` returns `EINTR`) is the same decision any production daemon makes: \"do I want blocking calls to automatically restart, or do I want them to be interrupted so I can notice signals quickly?\" For a signal-responsive system, `EINTR` propagation is the right choice.\n---\n## A Note on What Your Measurements Mean\nBefore you interpret your first summary table, internalize this:\nThe percentages are meaningful. If `read` shows 64% of your trace time, it's genuinely the dominant syscall â€” even accounting for overhead, other syscalls would show similar relative overhead, so the *relative* ranking is trustworthy.\nThe absolute times are not meaningful for comparing to production. A `read()` that takes 100Âµs in your trace may take 5Âµs untraced. What you're measuring is \"how much time the tracer noticed this syscall consuming,\" not \"how long this syscall actually runs.\"\nThe call counts are exact. They're not subject to timing distortion. If you see 2,619 `read` calls, the program made exactly 2,619 `read` calls.\nThe error counts are exact. 18 failed `connect` calls means 18 real failures.\nReal strace's output header says `% time` not `% CPU time` for precisely this reason. Your output should say the same. Accuracy in communicating what you measure is a form of engineering integrity.\n---\n## Summary: What You've Built\nYour tracer now has the complete feature set of the core strace functionality:\n- Parses `-e trace=name,name,...` to build a display filter; unmatched syscalls accumulate statistics but don't print, preserving the accurate count/timing picture\n- Records `CLOCK_MONOTONIC` timestamps at entry and exit to compute elapsed nanoseconds per syscall, correctly understanding that this measures \"ptrace-observed wall time\" not true syscall CPU time\n- Maintains a zero-allocation, L1-cache-resident `SyscallStats[336]` array accumulating call count, error count, and total nanoseconds per syscall number\n- Sorts and prints a `strace -c`-style summary table (by cumulative time descending) with percentage, seconds, microseconds-per-call, total calls, error count, and syscall name\n- Opens a file on `-o filename` and directs all trace output there; summary always goes to `stderr`\n- Attaches to a running process with `PTRACE_ATTACH`, waits for the `SIGSTOP` acknowledgment, sets full options, and enters the same event loop as the fork case\n- Installs a signal-safe `SIGINT` handler using `volatile sig_atomic_t` and `SA_RESTART=0`; on interrupt, stops the attached tracee with `SIGSTOP`, waits for it to stop, calls `PTRACE_DETACH`, prints the summary, and exits without killing the traced process\n---\n<!-- END_MS -->\n\n\n\n\n# TDD\n\nA ptrace-based syscall tracer for x86_64 Linux built in four progressive milestones. Each milestone is a self-contained, testable layer: the toggle-based intercept engine, the cross-address-space argument decoder, the multi-process state machine, and the filtering/statistics aggregator. Every design decision is grounded in hardware constraints: the x86_64 syscall ABI register layout, virtual address space isolation enforced by CR3/MMU, cache line boundaries for hot structs, and the observable observer-effect overhead of ptrace itself.\n\n\n\n<!-- TDD_MOD_ID: build-strace-m1 -->\n# TECHNICAL DESIGN SPECIFICATION: Basic ptrace Syscall Intercept (build-strace-m1)\n\n## 1. Module Charter\nThis module implements the core \"heartbeat\" of the system call tracer. It establishes the master-slave relationship between the tracer (parent) and the tracee (child) using the Linux `ptrace(2)` API. Its primary responsibility is to intercept every transition across the kernel-userspace boundary on x86_64. \n\n**Core Objectives:**\n*   Orchestrate the `fork` -> `PTRACE_TRACEME` -> `execvp` sequence to initiate tracing.\n*   Implement a synchronous event loop using `waitpid` and `PTRACE_SYSCALL`.\n*   Maintain a stateful toggle to disambiguate between syscall **entry** (pre-execution) and **exit** (post-execution).\n*   Extract raw machine state from x86_64 registers (`orig_rax` and `rax`).\n*   Ensure transparent execution of the tracee by correctly re-injecting signals.\n\n**Non-Goals:**\n*   Decoding syscall arguments (Milestone 2).\n*   Handling multiple processes/threads (Milestone 3).\n*   Symbolic name resolution or timing (Milestone 4).\n\n**Invariants:**\n*   The tracer must never suppress a signal intended for the tracee unless explicitly instructed (not in this milestone).\n*   The toggle flag must remain synchronized with the kernel's stop sequence; a single missed stop desynchronizes all subsequent output.\n\n## 2. File Structure\nThe implementation follows a monolithic structure for the core loop to minimize context-switching overhead in the tracer code itself.\n\n1.  `main.c`: Entry point, command-line parsing, fork logic, and the primary tracing loop.\n2.  `common.h`: Shared type definitions and constants for x86_64 register offsets.\n3.  `Makefile`: Build instructions with `-Wall -Wextra -O2`.\n\n## 3. Data Model\n\n### 3.1 Process State Mapping\nEven though this milestone handles a single process, the state must be encapsulated in a structure that respects cache line boundaries (64 bytes) to prepare for multi-process expansion.\n\n| Field | Type | Size | Offset | Description |\n| :--- | :--- | :--- | :--- | :--- |\n| `pid` | `pid_t` | 4B | 0x00 | Tracee process ID |\n| `in_syscall` | `int` | 4B | 0x04 | Toggle: 0 = Next stop is entry, 1 = Next stop is exit |\n| `regs` | `struct user_regs_struct` | 216B | 0x08 | Copy of tracee registers from last stop |\n| `padding` | `uint8_t[32]` | 32B | 0xE0 | Padding to align to 256 bytes (4 cache lines) |\n\n```c\n#include <sys/user.h>\n#include <sys/types.h>\n#include <stdint.h>\n\ntypedef struct {\n    pid_t pid;                      // Offset 0\n    int in_syscall;                 // Offset 4\n    struct user_regs_struct regs;   // Offset 8 (Size 216)\n    // Total used: 224 bytes. \n    // Aligns to 3.5 cache lines.\n} ProcessState;\n```\n\n### 3.2 Register Layout (x86_64 ABI)\nWe focus on the `struct user_regs_struct` defined in `<sys/user.h>`. On x86_64, the kernel saves the original syscall number in a specific slot that is not overwritten by the return value.\n\n| Register | Struct Field | Purpose |\n| :--- | :--- | :--- |\n| `orig_rax` | `regs.orig_rax` | Syscall number (Persistent across entry/exit) |\n| `rax` | `regs.rax` | Return value (Only valid on Exit stop) |\n| `rdi` | `regs.rdi` | Argument 1 |\n| `rsi` | `regs.rsi` | Argument 2 |\n| `rdx` | `regs.rdx` | Argument 3 |\n\n**Hardware Soul Note:** Reading registers via `PTRACE_GETREGS` triggers a kernel-mode copy from the tracee's `task_struct->thread_struct` into the tracer's memory. This touches 4 cache lines in the tracer's address space.\n\n## 4. Interface Contracts\n\n### 4.1 `int main(int argc, char *argv[])`\n*   **Role**: Entry point for the tracer.\n*   **Input**: `argv[1]` is the path to the executable; `argv[2...]` are arguments for that executable.\n*   **Edge Case**: If `argc < 2`, print usage and exit with 1.\n\n### 4.2 `static void handle_syscall(pid_t pid, ProcessState *state)`\n*   **Role**: Dispatches the syscall stop based on the toggle flag.\n*   **Logic**:\n    1.  Call `ptrace(PTRACE_GETREGS, pid, 0, &state->regs)`.\n    2.  If `state->in_syscall == 0`:\n        *   Log: `[Entry] syscall(regs.orig_rax)` (Internal state tracking).\n        *   Set `state->in_syscall = 1`.\n    3.  Else (`state->in_syscall == 1`):\n        *   Retrieve `result = (long)state->regs.rax`.\n        *   Detect error: `if (result >= -4096 && result <= -1)`.\n        *   Log: `syscall(regs.orig_rax) = result`.\n        *   Set `state->in_syscall = 0`.\n\n### 4.3 `static int wait_for_event(pid_t pid, int *status)`\n*   **Role**: Wrapper around `waitpid`.\n*   **Return**: 0 on normal stop, 1 on exit, -1 on error.\n*   **Recovery**: On `EINTR`, retry the call.\n\n## 5. Algorithm Specification: The Tracing Lifecycle\n\n### 5.1 Initialization (Fork/Exec)\n1.  **Tracer**: Calls `fork()`.\n2.  **Child**: \n    *   Calls `ptrace(PTRACE_TRACEME, 0, NULL, NULL)`.\n    *   Calls `raise(SIGSTOP)` (Optional but recommended to ensure parent is ready).\n    *   Calls `execvp(prog, args)`.\n3.  **Tracer**:\n    *   Calls `waitpid(child_pid, &status, 0)`.\n    *   Verifies `WIFSTOPPED(status)`.\n    *   Calls `ptrace(PTRACE_SETOPTIONS, child_pid, NULL, PTRACE_O_TRACESYSGOOD)`.\n    *   **Reason**: This ensures syscall stops are reported as `SIGTRAP | 0x80` (0x85), allowing us to distinguish them from standard `SIGTRAP` (0x05) generated by breakpoints or `exec`.\n\n### 5.2 The Main Intercept Loop\n\n![ptrace Lifecycle: Fork â†’ TRACEME â†’ Exec â†’ SYSCALL Loop](./diagrams/tdd-diag-1.svg)\n\n```\n[START LOOP]\n  1. ptrace(PTRACE_SYSCALL, pid, NULL, sig_to_inject)\n  2. waitpid(pid, &status, 0)\n  3. IF WIFEXITED(status) OR WIFSIGNALED(status):\n       EXIT LOOP\n  4. IF WIFSTOPPED(status):\n       sig = WSTOPSIG(status)\n       IF sig == (SIGTRAP | 0x80):\n           // This is a syscall stop\n           handle_syscall(pid, state)\n           sig_to_inject = 0\n       ELSE IF sig == SIGTRAP:\n           // Trap from exec or other ptrace event\n           sig_to_inject = 0\n       ELSE:\n           // Real signal (e.g., SIGINT, SIGPIPE)\n           sig_to_inject = sig\n[GOTO START]\n```\n\n### 5.3 Error Detection Logic\nOn x86_64, the kernel returns errors as negative values in the range `[-4096, -1]`.\n*   Example: `-2` represents `-ENOENT`.\n*   Algorithm:\n    1.  Cast `unsigned long rax` to `long signed_rax`.\n    2.  Check `if (signed_rax < 0 && signed_rax >= -4096)`.\n    3.  `errno_val = -signed_rax`.\n    4.  Print `strerror(errno_val)`.\n\n\n![Entry/Exit Toggle State Machine](./diagrams/tdd-diag-2.svg)\n (Visualizes the `rax` register transition from entry to exit)\n\n## 6. Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n| :--- | :--- | :--- | :--- |\n| `fork() == -1` | Return value | Exit tracer with `perror`. | Yes |\n| `execvp() == -1` | Child continues | Child calls `_exit(1)`. Parent sees `WIFEXITED`. | Yes (via waitpid) |\n| `ESRCH` | `ptrace` call | Tracee likely died; terminate tracing loop. | No (clean exit) |\n| `EPERM` | `ptrace` call | Tracer lacks permissions; exit with error. | Yes |\n| `waitpid == -1` | Return value | If `errno == EINTR`, loop; else exit. | Yes |\n\n## 7. Implementation Sequence\n\n### Phase 1: The Spawner (2 Hours)\n*   Implement `fork` logic.\n*   In child: `PTRACE_TRACEME` then `execvp`.\n*   In parent: `waitpid` for the initial stop.\n*   **Checkpoint**: Run `./tracer /bin/ls`. The tracer should start, the child should execute `ls`, and the tracer should finish immediately after `ls` exits.\n\n### Phase 2: The SYSCALL Loop (2 Hours)\n*   Implement the `while(1)` loop with `PTRACE_SYSCALL`.\n*   Add `WIFEXITED` check to break the loop.\n*   Print a generic \"Stop detected\" message for every stop.\n*   **Checkpoint**: Run `./tracer /bin/ls`. You should see dozens of \"Stop detected\" messages before `ls` prints its output.\n\n### Phase 3: The Toggle & Registers (2 Hours)\n*   Define `ProcessState` with `in_syscall`.\n*   Call `PTRACE_SETOPTIONS` with `PTRACE_O_TRACESYSGOOD`.\n*   In the loop, check for `(SIGTRAP | 0x80)`.\n*   Use `PTRACE_GETREGS` to read `orig_rax`.\n*   **Checkpoint**: Output should look like `syscall(59)`, `syscall(12)`, etc. Note that each number should appear twice.\n\n### Phase 4: Output Refinement (2 Hours)\n*   Logic to only print on the **exit** stop (toggle == 1).\n*   Add `rax` reading and error range check.\n*   Implement signal re-injection (passing `sig` to `PTRACE_SYSCALL`).\n*   **Checkpoint**: `./tracer /bin/ls` should print `syscall(59) = 0`, `syscall(12) = 0x...`.\n\n## 8. Test Specification\n\n### 8.1 Happy Path: True/False\n*   **Command**: `./tracer /bin/true`\n*   **Expectation**: \n    *   Output contains `syscall(231) = 0` (exit_group) or similar termination.\n    *   Exit banner `+++ exited with 0 +++`.\n\n### 8.2 Failure Case: Missing File\n*   **Command**: `./tracer /bin/ls /nonexistent_file_999`\n*   **Expectation**:\n    *   Find the `openat` syscall (257).\n    *   Output: `syscall(257) = -1 ENOENT (No such file or directory)`.\n\n### 8.3 Signal Injection: SIGINT\n*   **Command**: `./tracer /bin/sleep 100` (then hit Ctrl+C)\n*   **Expectation**:\n    *   Tracer detects `WIFSIGNALED` or `WIFSTOPPED` with `SIGINT`.\n    *   The `sleep` process terminates correctly rather than hanging.\n\n## 9. Performance Targets\n\n| Operation | Target | Measurement Method |\n| :--- | :--- | :--- |\n| **Interception Latency** | < 10Âµs per stop | `clock_gettime` before/after `waitpid`. |\n| **Memory usage** | < 1MB RSS | `ps -o rss` |\n| **Context Switch Count** | 4 per syscall | `vmstat 1` during trace. |\n\n## 10. Hardware Soul & Alternative Realities\n\n**Hardware Soul (The LSTAR MSR):**\nOn x86_64, when the tracee executes `syscall`, the CPU doesn't look at the IDT (Interrupt Descriptor Table). It looks at the `IA32_LSTAR` Model-Specific Register. The kernel has pre-loaded this MSR with the address of `entry_SYSCALL_64`. When your tracer stops the child, the child's `RIP` (Instruction Pointer) is actually pointing to the instruction *immediately following* the `syscall` opcode, but the kernel has rolled back the registers to allow ptrace to see the pre-execution state.\n\n**Alternative Reality (Linux vs. FreeBSD):**\nOn Linux, we use `orig_rax` to get the syscall number because `rax` gets overwritten. On FreeBSD, `ptrace` provides a `PT_GET_SC_INFO` request that explicitly returns a `struct ptrace_sc_info` containing the syscall number and arguments, removing the need for architecture-specific register-scraping. Your C code for Linux is \"architecture-entangled\" by design.\n\n**Byte-Level Wait Status Layout:**\nThe `status` integer from `waitpid` is not an opaque ID. For a stop:\n*   `status & 0xFF` must be `0x7F`.\n*   `(status >> 8) & 0xFF` is the signal number.\n*   If `PTRACE_O_TRACESYSGOOD` is set, the signal number is `0x85` (5 | 0x80).\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-strace-m2 -->\n# TECHNICAL DESIGN SPECIFICATION: Argument Decoding (build-strace-m2)\n\n## 1. Module Charter\n\nThis module transforms the raw syscall numbers and register values captured in Milestone 1 into human-readable, semantic traces. It acts as the \"interpreter\" layer between the x86_64 hardware state and the user.\n\n**Core Objectives:**\n*   Map x86_64 syscall numbers (0â€“450+) to symbolic names (e.g., `2` $\\rightarrow$ `open`).\n*   Extract syscall arguments from the specific registers designated by the x86_64 System V ABI.\n*   Implement a robust remote memory reader to extract null-terminated strings from the tracee's address space.\n*   Decode complex bitmask flags for common syscalls (`open`, `mmap`) into piping-separated strings (e.g., `O_RDONLY|O_CREAT`).\n*   Handle the fundamental isolation of virtual address spaces using `PTRACE_PEEKDATA`.\n\n**Non-Goals:**\n*   Tracing across `fork()` or `clone()` boundaries (Milestone 3).\n*   High-resolution timing or summary statistics (Milestone 4).\n*   Decoding complex pointer-to-struct arguments (e.g., `struct stat`) beyond basic address printing.\n\n**Invariants:**\n*   `PTRACE_PEEKDATA` calls must always be preceded by an `errno = 0` assignment to disambiguate valid `-1` data from error returns.\n*   String reads must be capped at `MAX_STRING_LEN` to prevent infinite loops in cases of corrupted tracee memory.\n\n## 2. File Structure\n\nImplementation follows a logical separation between data tables (names/signatures) and logic (memory reading/formatting).\n\n1.  `syscall_data.h`: Declarations for the name and signature tables.\n2.  `syscall_data.c`: The actual sparse arrays for syscall names and `SyscallDesc` metadata.\n3.  `mem_reader.c`: Logic for word-aligned `PTRACE_PEEKDATA` reads and string marshalling.\n4.  `formatter.c`: Flag decoding logic and the primary `print_syscall` formatting engine.\n5.  `main.c`: Updated loop from M1 to include entry-state register saving and decoding calls.\n\n## 3. Data Model\n\n### 3.1 Syscall Metadata Types\nWe define an abstraction to describe the \"signature\" of a syscall. This allows the formatter to know how many arguments to print and how to interpret each register.\n\n```c\ntypedef enum {\n    ARG_INT,          // Print as %lld\n    ARG_UINT,         // Print as %llu\n    ARG_HEX,          // Print as 0x%llx\n    ARG_STR,          // String in tracee memory (PEEKDATA)\n    ARG_PTR,          // Pointer: print hex address or \"NULL\"\n    ARG_OPEN_FLAGS,   // Bitmask for open()\n    ARG_MMAP_PROT,    // Bitmask for mmap() PROT\n    ARG_MMAP_FLAGS,   // Bitmask for mmap() FLAGS\n    ARG_IGNORE        // Skip this argument\n} ArgType;\n\ntypedef struct {\n    const char *name;      // Syscall name\n    int num_args;          // 0 to 6\n    ArgType arg_types[6];  // Type per argument slot\n} SyscallDesc;\n```\n\n### 3.2 Flag Decoding Table\n```c\ntypedef struct {\n    unsigned long value;\n    const char *name;\n} FlagEntry;\n```\n\n### 3.3 Extended Process State\nThe `ProcessState` from M1 must be extended to store a snapshot of registers taken at **entry**. On the **exit** stop, the argument registers (rdi, rsi, etc.) may be clobbered by the kernel; the tracer must rely on the saved entry state.\n\n| Field | Type | Size | Offset | Description |\n| :--- | :--- | :--- | :--- | :--- |\n| `pid` | `pid_t` | 4B | 0x00 | Process ID |\n| `in_syscall` | `int` | 4B | 0x04 | Toggle flag |\n| `entry_regs` | `struct user_regs_struct` | 216B | 0x08 | Saved snapshot from ENTRY stop |\n\n**Hardware Soul Note:** A `struct user_regs_struct` snapshot (216B) is slightly over 3 cache lines (64B each). Saving this snapshot involves a synchronous copy from the kernel's task structure to your tracer's heap/stack, adding ~2000 cycles of latency.\n\n\n![Virtual Address Space Isolation: Why PTRACE_PEEKDATA Exists](./diagrams/tdd-diag-8.svg)\n\n\n## 4. Interface Contracts\n\n### 4.1 `char* read_remote_string(pid_t pid, unsigned long addr)`\n*   **Role**: Extracts a string from the tracee's address space.\n*   **Input**: `addr` is the virtual address in the tracee's memory.\n*   **Output**: A heap-allocated or static-buffer string.\n*   **Constraint**: Must read in 8-byte increments (word size on x86_64).\n*   **Error**: Returns `\"<unreadable>\"` if PEEKDATA fails; handles NULL by returning `\"NULL\"`.\n\n### 4.2 `void decode_flags(unsigned long val, const FlagEntry *table, char *out_buf)`\n*   **Role**: Converts a bitmask (e.g., `0x80002`) into a string (e.g., `O_RDWR|O_CLOEXEC`).\n*   **Edge Case**: `O_RDONLY` is `0x0`. The logic must check `if (val == 0)` before entering the bitwise loop.\n\n### 4.3 `void print_syscall(pid_t pid, ProcessState *state, long exit_code)`\n*   **Role**: Orchestrates the output of one trace line.\n*   **Logic**:\n    1.  Lookup `SyscallDesc` using `state->entry_regs.orig_rax`.\n    2.  Extract 6 registers into a local array: `rdi, rsi, rdx, r10, r8, r9`.\n    3.  Iterate `i < desc.num_args`, calling specific formatters based on `desc.arg_types[i]`.\n    4.  Print the syscall name, arguments, and finally the `exit_code`.\n\n## 5. Algorithm Specification: String Extraction via Word-Walking\n\n`PTRACE_PEEKDATA` on x86_64 returns one 64-bit word. Since strings are not word-aligned, we must scan each word for the null terminator.\n\n### Algorithm `extract_string_loop`:\n1.  Initialize `bytes_read = 0`, `buffer` of size `MAX_STRING_LEN`.\n2.  While `bytes_read < MAX_STRING_LEN`:\n    *   `errno = 0`.\n    *   `word = ptrace(PTRACE_PEEKDATA, pid, addr + bytes_read, NULL)`.\n    *   If `word == -1 && errno != 0`:\n        *   Terminate and return current buffer (partial read).\n    *   Cast `word` to `unsigned char[8]`.\n    *   For `j = 0` to `7`:\n        *   `c = byte_array[j]`.\n        *   If `c == '\\0'`: return buffer.\n        *   `buffer[bytes_read++] = c`.\n        *   If `bytes_read == MAX_STRING_LEN`: break and return buffer with `...` suffix.\n3.  Return buffer.\n\n**Visualizing Word-Walking:**\nTracee memory at `0x1000`: `['/','u','s','r','/','b','i','n','/','l','s','\\0', ...]`\n1.  Read `0x1000` $\\rightarrow$ `word1` contains `/usr/bin`.\n2.  Scan `word1`: no `\\0`. Append to buffer.\n3.  Read `0x1008` $\\rightarrow$ `word2` contains `/ls\\0`.\n4.  Scan `word2`: find `\\0` at index 3.\n5.  Final result: `/usr/bin/ls`.\n\n\n![PTRACE_PEEKDATA Word-by-Word String Extraction Algorithm](./diagrams/tdd-diag-9.svg)\n\n\n## 6. Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n| :--- | :--- | :--- | :--- |\n| `PTRACE_PEEKDATA` fails | `errno != 0` | Stop reading, return `\"<unreadable>\"` | Yes (in output) |\n| Invalid Syscall Num | `num > 335` | Use `\"unknown\"` as name | Yes |\n| NULL pointer | `arg == 0` | Print `\"NULL\"`, skip PEEKDATA | Yes |\n| Buffer Overrun | `bytes_read >= 1024` | Truncate and add `\"...\"` | Yes |\n| Missing `SyscallDesc` | `desc == NULL` | Print args as raw hex | Yes |\n\n## 7. Implementation Sequence\n\n### Phase 1: The Table (2 Hours)\n*   Create `syscall_data.c` with at least 50 common names (read, write, open, close, mmap, brk, etc.).\n*   Verify by printing `syscall_name(regs.orig_rax)` in the M1 exit loop.\n*   **Checkpoint**: Running `./tracer /bin/ls` shows names like `openat` and `fstat` instead of `257` and `5`.\n\n### Phase 2: Remote Memory Logic (3 Hours)\n*   Implement `read_remote_string` with the word-walking algorithm.\n*   Handle the `errno` disambiguation.\n*   Add the `MAX_STRING_LEN` (32 or 64 bytes) truncation logic.\n*   **Checkpoint**: Hardcode a check for syscall `execve` (59) and print the first argument using this function. You should see `execve(\"/bin/ls\", ...)` in your output.\n\n### Phase 3: The Dispatcher (3 Hours)\n*   Populate `SyscallDesc` for the top 20 syscalls.\n*   Implement `print_syscall` which iterates through `num_args`.\n*   Implement `print_arg` as a large switch-case over `ArgType`.\n*   **Checkpoint**: Basic integer and string arguments work. `openat(3, \"/etc/passwd\", ...)` starts to look real.\n\n### Phase 4: Flag Decoding (2 Hours)\n*   Define `open_flags` and `mmap_prot` tables.\n*   Implement `decode_flags` with the logic to handle bitwise concatenation.\n*   Fix the `O_RDONLY` (0) bug by checking `if (val == 0)` first.\n*   **Checkpoint**: `openat(..., O_RDONLY|O_CLOEXEC) = 3`.\n\n## 8. Test Specification\n\n### 8.1 String Reading: `ls`\n*   **Command**: `./tracer /bin/ls /var/log`\n*   **Test**: Search for `openat` or `stat`.\n*   **Expectation**: The path `\"/var/log\"` is visible and quoted.\n\n### 8.2 NULL Pointer: `execve`\n*   **Command**: `./tracer /bin/ls`\n*   **Test**: Look at `execve` arguments (arg 2 or 3).\n*   **Expectation**: If a pointer is 0, it should print `NULL` and NOT crash.\n\n### 8.3 Bitmask: `mmap`\n*   **Command**: `./tracer /bin/ls`\n*   **Test**: Find `mmap` calls.\n*   **Expectation**: Output shows `PROT_READ`, `MAP_PRIVATE`, etc., instead of raw hex.\n\n### 8.4 Long String Truncation\n*   **Command**: Create a test C program that opens a very long path (> 128 chars).\n*   **Expectation**: The output shows the first 32/64 chars followed by `...`.\n\n## 9. Performance Targets\n\n| Operation | Target | Measurement |\n| :--- | :--- | :--- |\n| **Name Lookup** | O(1) | Array index in `syscall_names`. |\n| **String Read** | ~1.5Âµs / word | `clock_gettime` around `read_remote_string`. |\n| **Formatting Overhead**| < 50Âµs | Total time in `print_syscall`. |\n\n**Hardware Soul Note (The TLB):** `PTRACE_PEEKDATA` is significantly slower than local memory access because it requires the kernel to temporarily switch the CPU's `CR3` register (or use a global kernel mapping) to resolve the tracee's virtual address through the tracee's page tables. This often results in a TLB miss for the tracer.\n\n## 10. Flag Tables (Sample for Implementation)\n\n```c\nstatic const FlagEntry open_flags[] = {\n    { O_WRONLY,   \"O_WRONLY\" },\n    { O_RDWR,     \"O_RDWR\" },\n    { O_CREAT,    \"O_CREAT\" },\n    { O_EXCL,     \"O_EXCL\" },\n    { O_TRUNC,    \"O_TRUNC\" },\n    { O_APPEND,   \"O_APPEND\" },\n    { O_DIRECTORY,\"O_DIRECTORY\" },\n    { O_CLOEXEC,  \"O_CLOEXEC\" },\n    { 0, NULL }\n};\n\n// Logic Note:\n// Since O_RDONLY is usually 0, your loop should be:\nif (val == 0) {\n    printf(\"O_RDONLY\");\n} else {\n    // iterate flags and print with |\n}\n```\n\n\n![PTRACE_PEEKDATA -1 Ambiguity: Error vs Valid Data](./diagrams/tdd-diag-10.svg)\n (Visualizes the bitmask decoding flow)\n\n\n\n---\n**END OF SPECIFICATION**\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-strace-m3 -->\n# TECHNICAL DESIGN SPECIFICATION: Multi-Process and Fork Following (build-strace-m3)\n\n## 1. Module Charter\n\nThis module extends the tracer from a single-process observer to a full process-tree supervisor. It implements the logic required to transparently follow children created via `fork()`, `vfork()`, and `clone()`, as well as handling the complete address space replacement during `execve()`. Its primary responsibility is the orchestration of the ptrace multi-process state machine, ensuring that new processes are atomically attached before they can execute a single instruction. It manages a centralized per-PID state repository using an open-addressing hash map optimized for cache-line alignment.\n\n**Core Objectives:**\n*   Configure ptrace options (`PTRACE_O_TRACEFORK`, etc.) to enable automatic kernel-mediated attachment to child processes.\n*   Transition the event loop to a non-blocking/any-child model using `waitpid(-1)`.\n*   Implement an O(1) lookup mechanism for per-process metadata (registers, toggle state).\n*   Correctly handle `PTRACE_EVENT_EXEC` to reset stale process state when a new image is loaded.\n*   Maintain a global `active_count` to ensure the tracer exits only when the entire process tree has terminated.\n\n**Non-Goals:**\n*   Implementing syscall name filtering (Milestone 4).\n*   High-resolution wall-clock timing or statistical aggregation (Milestone 4).\n*   Modifying syscall arguments or return values (fault injection).\n\n**Invariants:**\n*   Every process returned by `waitpid(-1)` must have a corresponding entry in the `state_map` before its registers are accessed.\n*   The `active_count` must exactly match the number of live, traced processes; any mismatch will result in either a hang or premature tracer exit.\n\n## 2. File Structure\n\nThe implementation sequence requires files to be created/modified in this order:\n\n1.  `state_map.h`: Definition of the `ProcessState` struct and hash map interface.\n2.  `state_map.c`: Implementation of the open-addressing hash map (insert, find, remove).\n3.  `events.h`: Constants for ptrace event decoding (status bit-shifts).\n4.  `events.c`: Handlers for `PTRACE_EVENT_FORK`, `PTRACE_EVENT_CLONE`, and `PTRACE_EVENT_EXEC`.\n5.  `main.c`: Integration of the `waitpid(-1)` loop and PID-tagged output.\n\n## 3. Complete Data Model\n\n### 3.1 ProcessState Struct (Byte-Level Layout)\nTo ensure high performance during the hot path (lookup on every syscall entry/exit), the `ProcessState` is designed to be cache-friendly. Each entry is padded to exactly 256 bytes (4 cache lines on x86_64).\n\n| Field | Type | Size | Offset | Description |\n| :--- | :--- | :--- | :--- | :--- |\n| `pid` | `pid_t` | 4B | 0x00 | Process ID (Key) |\n| `in_syscall` | `int` | 4B | 0x04 | Toggle: 0=Entry, 1=Exit |\n| `entry_regs` | `struct user_regs_struct` | 216B | 0x08 | Registers captured at entry stop |\n| `valid` | `int` | 4B | 0xE0 | Status: 0=Empty, 1=Active, -1=Tombstone |\n| `padding` | `uint8_t[12]` | 12B | 0xE4 | Alignment padding to 256B |\n\n```c\n#include <sys/user.h>\n#include <sys/types.h>\n#include <stdint.h>\n\ntypedef struct {\n    pid_t pid;                          // 0x00\n    int in_syscall;                     // 0x04\n    struct user_regs_struct entry_regs; // 0x08\n    int valid;                          // 0xE0\n    uint8_t padding[12];                // 0xE4\n} ProcessState;\n\n#define STATE_MAP_SIZE 256              // Must be power of 2\n```\n\n### 3.2 Global State Control\n| Variable | Type | Description |\n| :--- | :--- | :--- |\n| `state_map` | `ProcessState[256]` | The flat hash table. Total size: 64 KB (Fits in L2). |\n| `active_count` | `int` | Number of live processes currently being traced. |\n\n**Hardware Soul Section:** \nThe `state_map` occupies exactly 64KB. This is significant because it fits entirely within the L2 cache of modern x86_64 CPUs (typically 256KB-1MB). Because the `waitpid(-1)` loop is single-threaded, the `state_map` will remain \"warm\" in the cache, ensuring that the `state_map_find` operation (which uses a simple modulo hash) typically resolves in ~10-15 cycles, effectively hiding the cost of the ptrace bookkeeping.\n\n\n![PTRACE_O_TRACEFORK Atomicity: No Race Window](./diagrams/tdd-diag-15.svg)\n\n*Diagram: Memory Layout of the state_map highlighting cache line boundaries (64B segments).*\n\n## 4. Interface Contracts\n\n### 4.1 Hash Map Interface (`state_map.c`)\n\n**`ProcessState* state_map_find(pid_t pid)`**\n*   **Role**: Lookup state for a PID.\n*   **Algorithm**: Linear probing starting at `pid % 256`.\n*   **Returns**: Pointer to the state or `NULL` if not found.\n\n**`ProcessState* state_map_insert(pid_t pid)`**\n*   **Role**: Allocate a slot for a new process.\n*   **Error**: Returns `NULL` if table is full (load factor > 1).\n\n**`void state_map_remove(pid_t pid)`**\n*   **Role**: Mark a slot as a tombstone (`valid = -1`) to maintain probing chains.\n\n### 4.2 Event Handling (`events.c`)\n\n**`void handle_ptrace_event(pid_t pid, int status, ProcessState *state)`**\n*   **Input**: `status` from `waitpid`.\n*   **Logic**:\n    1.  `int event = (status >> 16) & 0xff;`\n    2.  If `event` is `FORK`, `VFORK`, or `CLONE`:\n        *   `ptrace(PTRACE_GETEVENTMSG, pid, NULL, &new_pid);`\n        *   `state_map_insert(new_pid);`\n        *   `active_count++;`\n        *   `ptrace(PTRACE_SYSCALL, new_pid, NULL, NULL);` // CRITICAL: Start the child.\n    3.  If `event` is `EXEC`:\n        *   `state->in_syscall = 0;` // Reset toggle.\n        *   `memset(&state->entry_regs, 0, sizeof(entry_regs));`\n\n## 5. Algorithm Specification: The Multi-Process Dispatcher\n\nThe core loop must now handle interleaved events. A single `waitpid` might return a syscall exit for PID A, followed immediately by a syscall entry for PID B.\n\n### Algorithm: `Tracing_Loop_v3`\n1.  **Wait**: `pid_t current = waitpid(-1, &status, 0)`.\n2.  **Verify**: If `current == -1`, check `errno`. If `ECHILD`, exit loop (all dead).\n3.  **Dispatch**:\n    *   **Exit/Signal**: \n        *   If `WIFEXITED(status)` or `WIFSIGNALED(status)`:\n            *   Print: `[pid current] +++ exited with ... +++`\n            *   `state_map_remove(current)`.\n            *   `active_count--`.\n            *   Continue loop.\n    *   **ptrace Stop**:\n        *   `int sig = WSTOPSIG(status)`.\n        *   `int event = (status >> 16) & 0xff`.\n        *   Find `ProcessState *s = state_map_find(current)`. \n        *   **Defensive Guard**: If `s == NULL`, `s = state_map_insert(current); active_count++;`.\n        *   **Branch by Event**:\n            *   If `event != 0`: Call `handle_ptrace_event(current, status, s)`.\n            *   Else if `sig == (SIGTRAP | 0x80)`:\n                *   Call `PTRACE_GETREGS`.\n                *   Toggle `s->in_syscall`.\n                *   If `s->in_syscall == 1`: Save `entry_regs`.\n                *   Else: `print_syscall(current, s, regs.rax)`.\n            *   Else: Re-inject `sig` via `PTRACE_SYSCALL(current, sig)`.\n4.  **Resume**: Unless handled in event branch, `ptrace(PTRACE_SYSCALL, current, NULL, NULL)`.\n\n\n![Per-PID State Hash Map: Structure, Probing, and Collision](./diagrams/tdd-diag-16.svg)\n\n*Diagram: Sequence diagram of Fork Interception. Parent ptrace(PTRACE_SYSCALL) -> Child born (Stopped) -> Tracer receives PTRACE_EVENT_FORK -> Tracer resumes child.*\n\n## 6. Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n| :--- | :--- | :--- | :--- |\n| `state_map` Full | `state_map_insert` returns `NULL` | Log error to stderr, `PTRACE_DETACH` unknown PID. | Yes |\n| `GETEVENTMSG` fail | Return value -1 | Log warning; the child might have exited instantly. | No |\n| `ESRCH` on Resume | `ptrace` returns -1 | Process died between wait and resume; cleanup state. | No |\n| `PTRACE_EVENT_EXEC` | `status >> 16 == 4` | Reset `in_syscall` toggle to prevent stale reg reads. | Yes (output tagged) |\n| Interleaved Syscalls | Loop Logic | Hash map lookups ensure PID A state never bleeds into PID B. | No |\n\n## 7. Implementation Sequence with Checkpoints\n\n### Phase 1: State Map & Hash Table (2 Hours)\n*   Implement `state_map.c` with linear probing.\n*   Unit test: Insert 10 PIDs, verify `find` returns correct pointers, `remove` one, verify `find` handles the gap.\n*   **Checkpoint**: `test_hash_map` executable passes all lookups.\n\n### Phase 2: waitpid(-1) Transition (2 Hours)\n*   Modify `main.c` from M2. Replace specific PID in `waitpid` with `-1`.\n*   Use the `state_map_find` to fetch the toggle flag.\n*   Add the `[pid N]` prefix to all `printf` calls.\n*   **Checkpoint**: Run `./tracer /bin/ls`. Output should be identical to M2 but prefixed with `[pid <n>]`.\n\n### Phase 3: Fork Interception (3 Hours)\n*   Set `PTRACE_SETOPTIONS` with `PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORK | PTRACE_O_TRACECLONE`.\n*   Implement `PTRACE_GETEVENTMSG` logic.\n*   Ensure `active_count` increments and the child is resumed.\n*   **Checkpoint**: Run `./tracer bash -c \"ls\"`. You should now see syscalls from *both* `bash` and `ls`.\n\n### Phase 4: Exec & Exit Synchronization (2 Hours)\n*   Implement `PTRACE_O_TRACEEXEC` handler.\n*   Add logic to decrement `active_count` and remove from map on `WIFEXITED`.\n*   Ensure the tracer only exits when `active_count == 0`.\n*   **Checkpoint**: Run `./tracer bash -c \"echo hello | cat\"`. The tracer should stay alive until both children and the shell exit.\n\n## 8. Test Specification\n\n### 8.1 Multi-Process Pipeline\n*   **Command**: `./tracer bash -c \"echo test | grep test\"`\n*   **Expectation**: \n    *   Trace shows `pipe()`, then two `clone()` calls.\n    *   Trace shows `execve()` for `echo` and `grep` under different PIDs.\n    *   Trace correctly identifies `write()` from one PID and `read()` from the other.\n\n### 8.2 vfork Suspension\n*   **Command**: A test C program using `vfork()`.\n*   **Expectation**: Parent PID produces no syscall events between the `vfork` entry and the child's `exec` or `exit`.\n\n### 8.3 State Map Stress\n*   **Command**: A test program that spawns 100 short-lived threads.\n*   **Expectation**: No \"State map full\" errors. `active_count` returns to 0.\n\n## 9. Performance Targets\n\n| Operation | Target | Measurement |\n| :--- | :--- | :--- |\n| **Hash Lookup** | < 50 ns | `clock_gettime` around `state_map_find`. |\n| **Memory Footprint** | ~128 KB | `valgrind --tool=massif`. |\n| **Max Capacity** | 256 PIDs | Hard-coded limit; verify rejection at 257. |\n| **Fork Latency** | < 500Âµs | Time from parent `fork` entry to child first syscall. |\n\n## 10. Concurrency Specification\n\n**Single-Threaded Ownership:**\nThe tracer utilizes a single-threaded event loop. This design choice is intentional:\n1.  **Atomicity**: `waitpid(-1)` is a blocking call that returns exactly one event from the kernel's queue.\n2.  **No Locking**: Since only one thread accesses the `state_map`, no mutexes or atomics are required, eliminating lock contention.\n3.  **Serialization**: The kernel serializes syscall events per-CPU. By processing them in a single loop, the tracer maintains a deterministic view of the process tree's execution.\n\n**Wait Status Byte Layout (Hardware Soul):**\nFor `PTRACE_EVENT` stops:\n*   `status & 0xFF == 0x7F` (Stopped)\n*   `(status >> 8) & 0xFF == SIGTRAP` (Stop Signal)\n*   `(status >> 16) & 0xFF == EVENT_CODE` (1=FORK, 2=VFORK, 3=CLONE, 4=EXEC)\n\n\n\n**END OF SPECIFICATION**\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: build-strace-m4 -->\n# TECHNICAL DESIGN SPECIFICATION: Filtering and Statistics (build-strace-m4)\n\n## 1. Module Charter\nThis module provides the final layer of utility and analytical power to the system call tracer. It implements selective observation, high-resolution performance profiling, and lifecycle management for external process attachment.\n\n**Core Objectives:**\n*   Implement a **Syscall Filter** to manage display volume, allowing users to isolate specific kernel interactions (e.g., `-e trace=open,read`).\n*   Establish **Performance Instrumentation** using `CLOCK_MONOTONIC` to measure wall-clock duration of syscalls with nanosecond precision.\n*   Construct a **Statistics Engine** to aggregate frequency, error rates, and cumulative latency into a summary table (`-c` mode).\n*   Enable **Live Process Attachment** (`-p` PID), moving the tracer from a spawner to a diagnostic tool for production workloads.\n*   Ensure **Clean Session Termination** via `SIGINT` (Ctrl+C) handling, implementing a safe `PTRACE_DETACH` sequence that leaves the tracee in a running state.\n\n**Non-Goals:**\n*   Implementing kernel-side eBPF filtering (this remains a userspace ptrace filter).\n*   Supporting multi-architecture (i386) syscall translation.\n*   Providing real-time graphical profiling (CLI summary only).\n\n**Invariants:**\n*   Statistics must be recorded for **all** intercepted syscalls, regardless of whether the display filter suppresses the line.\n*   Attachment to a running process must always wait for the `SIGSTOP` acknowledgment before applying ptrace options.\n*   Clock sources must never be `CLOCK_REALTIME` to avoid desynchronization during NTP adjustments.\n\n## 2. File Structure\nThe milestone follows a modular creation order, extending the base established in Milestone 3:\n\n1.  `options.h / options.c`: CLI parsing via `getopt` and the `TracerOptions` global configuration.\n2.  `filter.h / filter.c`: Syscall name-to-number resolution and the `filter_passes` predicate.\n3.  `stats.h / stats.c`: The `SyscallStats` array, sorting logic, and summary table formatter.\n4.  `signals.h / signals.c`: Async-signal-safe `SIGINT` handler and the interrupt flag.\n5.  `attach.c`: Logic for `PTRACE_ATTACH` and `PTRACE_DETACH` sequences.\n6.  `main.c`: Final integration of the event loop with timing hooks and filtered output.\n\n## 3. Complete Data Model\n\n### 3.1 TracerOptions (Configuration)\nThis structure holds the parsed CLI state and dictates the behavior of the main event loop.\n\n| Field | Type | Size | Description |\n| :--- | :--- | :--- | :--- |\n| `output_file` | `const char*` | 8B | Path to redirect trace output (or NULL for stderr). |\n| `filter_spec` | `const char*` | 8B | Raw string from `-e trace=...`. |\n| `attach_pid` | `pid_t` | 4B | Target PID if in attach mode, else 0. |\n| `summary_mode` | `int` | 4B | Boolean flag for `-c`. |\n| `target_argv` | `char**` | 8B | Argument vector for forked child. |\n\n### 3.2 SyscallStats (Accumulator)\nA fixed-size array of 336 entries (the x86_64 syscall count) is used to store statistics. This allows O(1) updates during the tracing hot-path.\n\n| Field | Type | Size | Offset | Description |\n| :--- | :--- | :--- | :--- | :--- |\n| `total_ns` | `int64_t` | 8B | 0x00 | Cumulative nanoseconds spent in call. |\n| `call_count` | `long` | 8B | 0x08 | Total number of invocations. |\n| `error_count` | `long` | 8B | 0x10 | Invocations returning `[-4096, -1]`. |\n\n**Hardware Soul (L1 Cache Alignment):**\nThe `SyscallStats` struct is exactly 24 bytes. An array of 336 entries takes **8,064 bytes**. Modern x86_64 L1 data caches are typically **32KB**. This allows the entire statistics table to reside in L1, ensuring that the `stats_record()` operation (called twice per syscall) never results in a DRAM access.\n\n### 3.3 Updated ProcessState (Milestone 3 Extension)\nWe extend the `ProcessState` from Milestone 3 to include the entry timestamp.\n\n```c\ntypedef struct {\n    pid_t pid;\n    int in_syscall;\n    struct user_regs_struct entry_regs;\n    struct timespec entry_time;  // NEW: Recorded at syscall entry stop\n    int valid;\n} ProcessState;\n```\n\n\n![What Syscall Timing Actually Measures: Observer Effect Breakdown](./diagrams/tdd-diag-22.svg)\n\n*Diagram: Memory Layout of the updated ProcessState. total size 248 bytes, aligned to cache lines.*\n\n## 4. Interface Contracts\n\n### 4.1 Statistics Interface (`stats.h`)\n**`void stats_record(long syscall_num, long long duration_ns, int is_error)`**\n*   **Input**: Syscall index, calculated delta, and error boolean.\n*   **Logic**: Increments `call_count`, adds `duration_ns` to `total_ns`, and increments `error_count` if `is_error` is true.\n\n**`void stats_print(FILE *out)`**\n*   **Role**: Formats the final table.\n*   **Logic**:\n    1.  Create an index array of syscalls where `call_count > 0`.\n    2.  `qsort` index array by `total_ns` descending.\n    3.  Iterate and print formatted columns (percentage, seconds, usecs/call).\n\n### 4.2 Filtering Interface (`filter.h`)\n**`void filter_parse(const char *spec)`**\n*   **Input**: String like `\"open,read,write\"`.\n*   **Logic**: Tokens are resolved via `syscall_num_by_name()`. Numbers are stored in a bitmask or dense array `nums[]`.\n\n**`int filter_passes(long syscall_num)`**\n*   **Return**: `1` if the syscall should be displayed, `0` otherwise. Note: if no filter is provided, it always returns `1`.\n\n### 4.3 Attachment Interface (`attach.h`)\n**`void attach_to_process(pid_t pid)`**\n*   **Sequence**:\n    1.  `ptrace(PTRACE_ATTACH, pid, NULL, NULL)`.\n    2.  `waitpid(pid, &status, 0)`.\n    3.  `ptrace(PTRACE_SETOPTIONS, pid, NULL, opts)`.\n*   **Error**: If `EPERM`, print instructions on disabling `yama/ptrace_scope`.\n\n## 5. Algorithm Specification\n\n### 5.1 High-Resolution Timing Algorithm\nThe tracer must calculate duration across the kernel boundary while minimizing overhead from the measurement itself.\n\n1.  **Syscall Entry Stop**:\n    *   Call `ptrace(PTRACE_GETREGS)`.\n    *   Call `clock_gettime(CLOCK_MONOTONIC, &state->entry_time)`. **Crucial**: Perform this immediately after the ptrace stop to exclude tracer processing time.\n2.  **Syscall Exit Stop**:\n    *   Call `clock_gettime(CLOCK_MONOTONIC, &exit_time)`.\n    *   `delta_ns = (exit_time.tv_sec - entry_time.tv_sec) * 1e9 + (exit_time.tv_nsec - entry_time.tv_nsec)`.\n    *   Record `delta_ns` into `SyscallStats[orig_rax]`.\n\n### 5.2 Clean Detach Algorithm (SIGINT)\nTo avoid killing the tracee when the tracer is interrupted, a specific handshake is required.\n\n1.  **Signal Handler**:\n    *   Set global `volatile sig_atomic_t g_interrupted = 1`.\n2.  **Event Loop**:\n    *   `waitpid` returns `EINTR` or loop checks `g_interrupted`.\n    *   For every PID in `state_map`:\n        *   Send `SIGSTOP` if not currently stopped (to ensure ptrace responsiveness).\n        *   `waitpid(pid, &status, 0)` to acknowledge stop.\n        *   `ptrace(PTRACE_DETACH, pid, NULL, NULL)`.\n3.  **Finalize**:\n    *   Call `stats_print()` if `-c` was active.\n    *   `exit(0)`.\n\n\n![CLOCK_MONOTONIC vs CLOCK_REALTIME: Why Monotonic is Mandatory](./diagrams/tdd-diag-23.svg)\n\n*Diagram: Flowchart of the SIGINT Detach sequence ensuring process continuity.*\n\n## 6. Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n| :--- | :--- | :--- | :--- |\n| `PTRACE_ATTACH EPERM` | `errno` after call | Print `ptrace_scope` help and exit. | Yes |\n| `PTRACE_ATTACH ESRCH` | `errno` after call | Target PID disappeared; exit. | Yes |\n| `fopen(-o file)` Fail | Return NULL | Print error, exit. | Yes |\n| `waitpid EINTR` | `errno == EINTR` | Check `g_interrupted`. If set, detach; else retry wait. | No |\n| Negative `delta_ns` | Comparison | Log error; indicates `CLOCK_REALTIME` usage bug. | Yes (Internal debug) |\n| `-e trace=bad_name` | Name lookup fail | Warn user that `bad_name` is unknown; ignore it. | Yes |\n\n## 7. Implementation Sequence with Checkpoints\n\n### Phase 1: CLI & Filtering (2 Hours)\n*   Implement `getopt` parsing in `options.c`.\n*   Implement `filter_parse` and `filter_passes`.\n*   **Checkpoint**: Running `./tracer -e trace=open,close /bin/ls` should suppress all lines except `open` and `close`.\n\n### Phase 2: Timing & Accumulation (3 Hours)\n*   Add `entry_time` to `ProcessState`.\n*   Implement `stats_record` and the `SyscallStats` array.\n*   Compute `delta_ns` at every exit stop.\n*   **Checkpoint**: Internal verification: the tracer can now calculate that a `read` took 12,500ns.\n\n### Phase 3: The Summary Table (2 Hours)\n*   Implement `stats_print` with `qsort`.\n*   Handle column formatting and total calculations.\n*   **Checkpoint**: Running `./tracer -c /bin/ls` produces a table similar to `strace -c` on exit.\n\n### Phase 4: Attachment & Detach (3 Hours)\n*   Implement `attach_to_process`.\n*   Install `SIGINT` handler.\n*   Implement the `PTRACE_DETACH` loop.\n*   **Checkpoint**: `./tracer -p <PID>` attaches to a running shell. Hitting Ctrl+C detaches the tracer but the shell remains responsive.\n\n## 8. Test Specification\n\n### 8.1 Filter Accuracy\n*   **Test**: `./tracer -e trace=write /bin/echo \"hello\"`\n*   **Expectation**: Output contains `write(...)` and `execve(...)` (initial), but NO `brk`, `mmap`, or `close`.\n\n### 8.2 Statistics Precision\n*   **Test**: `./tracer -c /bin/ls`\n*   **Expectation**: Percentage column totals 100%. `calls` count matches manual count from non-stats mode.\n\n### 8.3 Detach Verification\n*   **Test**: `sleep 100 &` then `./tracer -p $!`. Hit Ctrl+C.\n*   **Expectation**: `ps -p $!` still shows the sleep process in `S` (sleeping) or `R` (running) state, NOT `T` (stopped) or `<defunct>`.\n\n## 9. Performance Targets\n\n| Operation | Target | Measurement |\n| :--- | :--- | :--- |\n| **Clock Sampling** | < 100ns | `clock_gettime` VDSO overhead test. |\n| **Stats Record** | < 20ns | O(1) array update measurement. |\n| **Memory usage** | < 256KB RSS | `ps -o rss` |\n| **Attach Latency** | < 1ms | Time from command execution to first syscall capture. |\n\n## 10. Concurrency Specification\n\n**Signal Safety (Async-Signal-Safe Pattern):**\nThe `SIGINT` handler **MUST NOT** call `printf`, `malloc`, or `ptrace`. \n1.  **Handler**: Only sets `g_interrupted = 1`.\n2.  **Main Loop**: Checks `g_interrupted`.\n3.  **SA_RESTART**: Must be **unset** (`sa_flags = 0`). This ensures that the blocking `waitpid` syscall is interrupted and returns `EINTR`, allowing the loop to immediately respond to the user's Ctrl+C.\n\n**File Synchronization:**\nSince the tracer is single-threaded, `fprintf(trace_out, ...)` is implicitly serialized. No mutex is required for the `-o` file handle.\n\n\n![SyscallStats Array Memory Layout and Cache Behavior](./diagrams/tdd-diag-24.svg)\n\n*Diagram: Trace output redirection logic using a shared FILE* pointer.*\n\n\n\n---\n**END OF SPECIFICATION**\n<!-- END_TDD_MOD -->\n\n\n# Project Structure: System Call Tracer (strace clone)\n\n## Directory Tree\n\n```\nstrace-clone/\nâ”œâ”€â”€ src/                    \nâ”‚   â”œâ”€â”€ main.c              # Main loop & dispatch (M1-M4: Core orchestrator)\nâ”‚   â”œâ”€â”€ mem_reader.c        # PTRACE_PEEKDATA logic (M2: Word-walking strings)\nâ”‚   â”œâ”€â”€ formatter.c         # Syscall/Flag formatting (M2: Register-to-string logic)\nâ”‚   â”œâ”€â”€ syscall_data.c      # Name & signature tables (M2: Syscall metadata)\nâ”‚   â”œâ”€â”€ state_map.c         # PID hash map (M3: Per-process state tracking)\nâ”‚   â”œâ”€â”€ events.c            # Ptrace event handling (M3: Fork/Exec/Clone logic)\nâ”‚   â”œâ”€â”€ options.c           # CLI argument parsing (M4: getopt implementation)\nâ”‚   â”œâ”€â”€ filter.c            # Syscall filtering (M4: Name-to-number predicate)\nâ”‚   â”œâ”€â”€ stats.c             # Statistics accumulator (M4: Timing & summary table)\nâ”‚   â”œâ”€â”€ signals.c           # Signal handlers (M4: Async-safe SIGINT logic)\nâ”‚   â””â”€â”€ attach.c            # Process attachment (M4: PTRACE_ATTACH/DETACH)\nâ”œâ”€â”€ include/                \nâ”‚   â”œâ”€â”€ common.h            # Basic types & macros (M1: Register offsets)\nâ”‚   â”œâ”€â”€ syscall_data.h      # Table declarations (M2: Signature definitions)\nâ”‚   â”œâ”€â”€ state_map.h         # Map interface (M3: ProcessState struct)\nâ”‚   â”œâ”€â”€ events.h            # Event constants (M3: Ptrace bit-shifts)\nâ”‚   â”œâ”€â”€ options.h           # Config structures (M4: TracerOptions global)\nâ”‚   â”œâ”€â”€ filter.h            # Filter interface (M4: Bitmask/Lookup logic)\nâ”‚   â”œâ”€â”€ stats.h             # Stats interface (M4: Accumulator types)\nâ”‚   â””â”€â”€ signals.h           # Signal interface (M4: Global interrupt flags)\nâ”œâ”€â”€ Makefile                # Build system (M1: CC/CFLAGS configuration)\nâ””â”€â”€ README.md               # Project guide\n```\n\n## Creation Order\n\n1.  **Foundation & Skeleton** (M1)\n    *   Create `Makefile` and `include/common.h`.\n    *   Implement `src/main.c` (Phase 1): Basic `fork()`, `PTRACE_TRACEME`, and `execvp`.\n    *   Implement the `PTRACE_SYSCALL` loop and `in_syscall` toggle.\n\n2.  **Decoding Engine** (M2)\n    *   Create `include/syscall_data.h` and `src/syscall_data.c` (The syscall table).\n    *   Implement `src/mem_reader.c` for `PTRACE_PEEKDATA` string extraction.\n    *   Build `src/formatter.c` to decode registers and bitmask flags.\n    *   Update `main.c` to save `entry_regs` and print decoded calls.\n\n3.  **Multi-Process Supervision** (M3)\n    *   Implement `include/state_map.h` and `src/state_map.c` (The PID hash map).\n    *   Create `src/events.c` to handle `PTRACE_EVENT_FORK/EXEC`.\n    *   Modify `main.c` to use `waitpid(-1)` and the state map lookup.\n    *   Set `PTRACE_O_TRACEFORK` and related options in the initialization.\n\n4.  **Utility & Profiling** (M4)\n    *   Implement `src/options.c` for CLI flag handling (`-e`, `-o`, `-c`, `-p`).\n    *   Add `src/filter.c` to enable syscall suppression.\n    *   Implement `src/stats.c` using `CLOCK_MONOTONIC` for the summary table.\n    *   Add `src/attach.c` for `-p` functionality and `src/signals.c` for clean `SIGINT` detaching.\n\n## File Count Summary\n- **Total Header Files (.h):** 8\n- **Total Source Files (.c):** 11\n- **Build/Doc Files:** 2\n- **Estimated Total Lines of Code:** ~1,350 LOC\n- **Key Hardware Dependencies:** x86_64 Linux (sys/user.h register layout)\n\n# ðŸ“š Beyond the Atlas: Further Reading\n\n## The Intercept Engine (ptrace & Signals)\n\n**Paper**: *PTRACE - Process Trace* in \"The Design and Implementation of the 4.4BSD Operating System\" (McKusick, 1996). \n**Code**: [strace/strace.c](https://github.com/strace/strace/blob/master/src/strace.c) â€” The main event loop of the actual strace utility.\n**Best Explanation**: Eli Benderskyâ€™s [How debuggers work: Part 2 - Breakpoints](https://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints) (covers the `waitpid`/`SIGTRAP` dance).\n**Why**: This is the authoritative explanation of how `ptrace` and `SIGTRAP` interact to pause execution.\n**Pedagogical Timing**: Read **BEFORE Milestone 1**. It demystifies why the process stops and how the parent regains control, which is the foundation of the entire project.\n\n**Spec**: [Linux ptrace(2) Man Page](https://man7.org/linux/man-pages/man2/ptrace.2.html).\n**Best Explanation**: [Julia Evans: How does strace work?](https://jvns.ca/blog/2014/02/17/how-does-strace-work/) (Zine-style visual guide).\n**Why**: It provides a high-level mental model of the tracer/tracee relationship that makes the man page much easier to digest.\n**Pedagogical Timing**: Read **during Milestone 1** when the \"double-stop\" (entry/exit) behavior starts to feel confusing.\n\n---\n\n## The x86_64 Syscall ABI\n\n**Spec**: [System V Application Binary Interface (AMD64 Architecture Processor Supplement)](https://github.com/hjl-tools/x86-64-abi/releases) â€” Section 3.2.3 (Parameter Passing).\n**Code**: [linux/arch/x86/entry/entry_64.S](https://github.com/torvalds/linux/blob/master/arch/x86/entry/entry_64.S) â€” The kernelâ€™s assembly-level entry point for syscalls.\n**Best Explanation**: Ryan Chapmanâ€™s [Linux System Call Table for x86_64](https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/).\n**Why**: It is the \"Rosetta Stone\" for mapping syscall numbers to registers and argument types.\n**Pedagogical Timing**: Reference **during Milestone 2**. You will need this constantly as you build the `SyscallDesc` table.\n\n---\n\n## Memory & Address Spaces\n\n**Best Explanation**: *Understanding the Linux Kernel* (Bovet & Cesati), **Chapter 2: Memory Addressing**.\n**Code**: [linux/mm/memory.c](https://github.com/torvalds/linux/blob/master/mm/memory.c) â€” See `access_process_vm`, the kernel's internal version of PEEKDATA.\n**Why**: It explains the Page Global Directory (PGD) and page table walks that occur every time you call `PTRACE_PEEKDATA`.\n**Pedagogical Timing**: Read **before starting Milestone 2**. It explains why you cannot simply dereference a tracee's pointer and why the \"word-walking\" algorithm is necessary.\n\n---\n\n## Process Lifecycle (Fork, Exec, Clone)\n\n**Paper**: [Reflections on Trusting Trust](https://www.cs.cmu.edu/~rdriley/487/papers/Thompson_1984_ReflectionsonTrustingTrust.pdf) (Ken Thompson).\n**Code**: [linux/kernel/fork.c](https://github.com/torvalds/linux/blob/master/kernel/fork.c) â€” The `do_fork` (or `kernel_clone`) implementation.\n**Best Explanation**: *The Linux Programming Interface* (Michael Kerrisk), **Chapter 24 (Process Creation)** and **Chapter 27 (Program Execution)**.\n**Why**: Kerrisk is the gold standard for explaining how `execve` replaces the stack and heap, which is vital for understanding `PTRACE_EVENT_EXEC`.\n**Pedagogical Timing**: Read **before Milestone 3**. You must understand that `exec` creates a \"zombie\" relationship where the PID stays the same but the memory is fresh.\n\n---\n\n## Modern Observability (eBPF & Performance)\n\n**Paper**: [The BSD Packet Filter: A New Architecture for User-level Packet Capture](https://www.tcpdump.org/papers/bpf-usenix93.pdf) (McCanne & Jacobson, 1993).\n**Code**: [bpftrace/tools/syscount.bt](https://github.com/iovisor/bpftrace/blob/master/tools/syscount.bt) â€” A 10-line script that does what your Milestone 4 statistics engine does, but 100x faster.\n**Best Explanation**: Brendan Greggâ€™s [BPF Performance Tools](https://www.brendangregg.com/bpf-performance-tools-book.html), **Chapter 1: Introduction**.\n**Why**: It explains why \"the observer effect\" you measured in Milestone 4 is the reason the industry moved from ptrace to eBPF.\n**Pedagogical Timing**: Read **AFTER completing the project**. It provides the \"What's Next\" context for how these problems are solved in high-performance production environments.\n\n---\n\n## Technical Standards (Signals)\n\n**Spec**: [POSIX.1-2008: Signal Concepts](https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04).\n**Best Explanation**: [The \"Self-Pipe Trick\"](https://cr.yp.to/docs/selfpipe.html) by DJB.\n**Why**: It is the definitive argument for why signal handlers must be minimal and use the \"flag-setting\" pattern you implemented in Milestone 4.\n**Pedagogical Timing**: Read **during Milestone 4** when implementing the `SIGINT` handler and clean detach logic."}